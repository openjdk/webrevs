{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -38,0 +37,6 @@\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -43,0 +48,1 @@\n+import java.util.stream.Stream;\n@@ -44,1 +50,5 @@\n-\/**\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+\n+\/*\n@@ -53,2 +63,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          jdk.jfr\n+ * @modules jdk.jfr\n+ * @enablePreview\n@@ -67,1 +77,1 @@\n-    private static final String TEST_CASE_CLASS_NAME = TestCase.class.getName().replace('.', '\/');\n+    private static final ClassDesc CD_TestCase = TestCase.class.describeConstable().orElseThrow();\n@@ -103,2 +113,2 @@\n-            if (caller.className.equals(TEST_CASE_CLASS_NAME) && (callee.className.equals(TEST_CASE_CLASS_NAME)\n-                    || (callee.className.equals(\"java\/lang\/Object\") && callee.methodName.equals(\"<init>\")))) {\n+            if (caller.className.equals(CD_TestCase) && (callee.className.equals(CD_TestCase)\n+                    || (callee.className.equals(CD_Object) && callee.methodName.equals(INIT_NAME)))) {\n@@ -135,1 +145,1 @@\n-        String internalClassName = method.getType().getName().replace('.', '\/');\n+        ClassDesc classDesc = ClassDesc.of(method.getType().getName());\n@@ -137,2 +147,2 @@\n-        String methodDescriptor = method.getValue(\"descriptor\");\n-        return new MethodDesc(internalClassName, methodName, methodDescriptor);\n+        MethodTypeDesc methodDescriptor = MethodTypeDesc.ofDescriptor(method.getValue(\"descriptor\"));\n+        return new MethodDesc(classDesc, methodName, methodDescriptor);\n@@ -142,1 +152,1 @@\n-        String internalClassName = ciMethod.getValue(\"type\");\n+        ClassDesc classDesc = ClassDesc.ofInternalName(ciMethod.getValue(\"type\"));\n@@ -144,2 +154,2 @@\n-        String methodDescriptor = ciMethod.getValue(\"descriptor\");\n-        return new MethodDesc(internalClassName, methodName, methodDescriptor);\n+        MethodTypeDesc methodDescriptor = MethodTypeDesc.ofDescriptor(ciMethod.getValue(\"descriptor\"));\n+        return new MethodDesc(classDesc, methodName, methodDescriptor);\n@@ -249,1 +259,1 @@\n-    public final String className;\n+    public final ClassDesc className;\n@@ -251,5 +261,1 @@\n-    public final String descriptor;\n-\n-    public MethodDesc(Class<?> aClass, String methodName, String descriptor) {\n-        this(aClass.getName().replace('.', '\/'), methodName, descriptor);\n-    }\n+    public final MethodTypeDesc descriptor;\n@@ -257,1 +263,1 @@\n-    public MethodDesc(String className, String methodName, String descriptor) {\n+    public MethodDesc(ClassDesc className, String methodName, MethodTypeDesc descriptor) {\n@@ -261,1 +267,1 @@\n-        this.className = className.replace('.', '\/');\n+        this.className = className;\n@@ -267,2 +273,2 @@\n-        Class<?> aClass = executable.getDeclaringClass();\n-        className = Type.getInternalName(aClass).replace('.', '\/');\n+        className = executable.getDeclaringClass().describeConstable().orElseThrow();\n+        ClassDesc retType;\n@@ -270,4 +276,1 @@\n-        if (executable instanceof Constructor<?>) {\n-            methodName = \"<init>\";\n-            descriptor = Type.getConstructorDescriptor((Constructor<?>) executable);\n-        } else {\n+        if (executable instanceof Method method) {\n@@ -275,1 +278,4 @@\n-            descriptor = Type.getMethodDescriptor((Method) executable);\n+            retType = method.getReturnType().describeConstable().orElseThrow();\n+        } else {\n+            methodName = INIT_NAME;\n+            retType = CD_void;\n@@ -278,0 +284,2 @@\n+        descriptor = MethodTypeDesc.of(retType, Stream.of(executable.getParameterTypes())\n+                .map(c -> c.describeConstable().orElseThrow()).toArray(ClassDesc[]::new));\n@@ -364,2 +372,1 @@\n-        ClassWriter cw;\n-        ClassReader cr;\n+        ClassModel clm;\n@@ -367,1 +374,6 @@\n-            cr = new ClassReader(aClass.getName());\n+            var stream = ClassLoader.getSystemResourceAsStream(aClass.getName()\n+                    .replace('.', '\/') + \".class\");\n+            if (stream == null) {\n+                throw new IOException(\"Cannot find class file for \" + aClass.getName());\n+            }\n+            clm = ClassFile.of().parse(stream.readAllBytes());\n@@ -371,10 +383,0 @@\n-        cw = new ClassWriter(cr, 0);\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM7, cw) {\n-            @Override\n-            public MethodVisitor visitMethod(int access, String name, String desc, String descriptor, String[] exceptions) {\n-                System.out.println(\"Method: \" +name);\n-                MethodVisitor mv = super.visitMethod(access, name, desc, descriptor, exceptions);\n-                return new CallTracer(aClass, name, desc, mv, calls);\n-            }\n-        };\n-        cr.accept(cv, 0);\n@@ -382,0 +384,23 @@\n+        clm.methods().forEach(mm -> {\n+            System.out.println(\"Method: \" + mm.methodName().stringValue());\n+            mm.code().ifPresent(com -> {\n+                MethodDesc caller = new MethodDesc(\n+                        clm.thisClass().asSymbol(),\n+                        mm.methodName().stringValue(),\n+                        mm.methodTypeSymbol()\n+                );\n+                int offset = 0;\n+                for (var ce : com.elements()) {\n+                    if (ce instanceof Instruction ins) {\n+                        if (ins instanceof InvokeInstruction inv) {\n+                            calls.add(new Call(caller, new MethodDesc(\n+                                    inv.owner().asSymbol(),\n+                                    inv.name().stringValue(),\n+                                    inv.typeSymbol()\n+                            ), offset));\n+                        }\n+                        offset += ins.sizeInBytes();\n+                    }\n+                }\n+            });\n+        });\n@@ -384,19 +409,0 @@\n-\n-    private static class CallTracer extends MethodVisitor {\n-        private final MethodDesc caller;\n-        private Collection<Call> calls;\n-\n-        public CallTracer(Class<?> aClass, String name, String desc, MethodVisitor mv, Collection<Call> calls) {\n-            super(Opcodes.ASM7, mv);\n-            caller = new MethodDesc(aClass.getName(), name, desc);\n-            this.calls = calls;\n-        }\n-\n-        @Override\n-        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-            Label label = new Label();\n-            visitLabel(label);\n-            super.visitMethodInsn(opcode, owner, name, desc, itf);\n-            calls.add(new Call(caller, new MethodDesc(owner, name, desc), label.getOffset()));\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCompilerInlining.java","additions":67,"deletions":61,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,8 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +42,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -35,6 +45,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -44,0 +48,3 @@\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+\n@@ -51,2 +58,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.instrument\n+ * @modules java.instrument\n@@ -55,0 +61,2 @@\n+ * @enablePreview\n+ * @comment update --enable-preview in launchTest() too\n@@ -93,1 +101,1 @@\n-    private static final String[] instrMethodKeys = {\n+    private static final Set<MethodKey> instrMethodKeys = Stream.of(\n@@ -119,11 +127,5 @@\n-        \"sun\/nio\/ch\/FileChannelImpl::write::(Ljava\/nio\/ByteBuffer;)I\",\n-    };\n-\n-    private static String getInstrMethodKey(String className, String methodName, String signature) {\n-        \/\/ This key is used to identify a class and method. It is sent to callback(key)\n-        return className + \"::\" + methodName + \"::\" + signature;\n-    }\n-\n-    private static String getClassFromMethodKey(String methodKey) {\n-        return methodKey.split(\"::\")[0];\n-    }\n+        \"sun\/nio\/ch\/FileChannelImpl::write::(Ljava\/nio\/ByteBuffer;)I\"\n+    ).map(s -> {\n+        String[] a = s.split(\"::\");\n+        return new MethodKey(a[0], a[1], a[2]);\n+    }).collect(Collectors.toUnmodifiableSet());\n@@ -132,1 +134,1 @@\n-    private static Set<String> instrClassesTarget = null;\n+    private static Set<ClassDesc> instrClassesTarget = null;\n@@ -135,1 +137,1 @@\n-    private static Set<String> instrClassesDone = null;\n+    private static Set<ClassDesc> instrClassesDone = null;\n@@ -139,5 +141,4 @@\n-        instrClassesTarget = new HashSet<String>();\n-        instrClassesDone = new HashSet<String>();\n-        for (String s : instrMethodKeys) {\n-            String className = getClassFromMethodKey(s);\n-            instrClassesTarget.add(className);\n+        instrClassesTarget = new HashSet<>();\n+        instrClassesDone = new HashSet<>();\n+        for (MethodKey key : instrMethodKeys) {\n+            instrClassesTarget.add(key.owner());\n@@ -167,3 +168,4 @@\n-            Set<Class<?>> classes = new HashSet<Class<?>>();\n-            for (String className : instrClassesTarget) {\n-                Class<?> clazz = Class.forName(className.replaceAll(\"\/\", \".\"));\n+            Set<Class<?>> classes = new HashSet<>();\n+            for (ClassDesc className : instrClassesTarget) {\n+                var desc = className.descriptorString();\n+                Class<?> clazz = Class.forName(desc.substring(1, desc.length() - 1).replace('\/', '.'));\n@@ -200,2 +202,2 @@\n-                for (String key : instrMethodKeys) {\n-                    boolean gotCallback = callbackKeys.contains(key);\n+                for (MethodKey key : instrMethodKeys) {\n+                    boolean gotCallback = callbackKeys.contains(key.toString());\n@@ -203,1 +205,1 @@\n-                    String msg = String.format(\"key:%s, expects:%b\", key, expectsCallback);\n+                    String msg = String.format(\"status:%s, key:%s, expects:%b\", status, key, expectsCallback);\n@@ -217,1 +219,1 @@\n-        private static boolean isClassInstrumented(TransformStatus status, String key) throws Throwable {\n+        private static boolean isClassInstrumented(TransformStatus status, MethodKey key) throws Throwable {\n@@ -224,1 +226,1 @@\n-                String className = getClassFromMethodKey(key);\n+                var className = key.owner();\n@@ -282,1 +284,1 @@\n-            \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n+            \"--enable-preview\",\n@@ -308,1 +310,2 @@\n-        if (!instrClassesTarget.contains(className)) {\n+        ClassDesc target = ClassDesc.ofInternalName(className);\n+        if (!instrClassesTarget.contains(target)) {\n@@ -315,23 +318,17 @@\n-        ClassReader reader = new ClassReader(bytes);\n-        ClassWriter writer = new ClassWriter(\n-                reader, ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n-        CallbackClassVisitor classVisitor = new CallbackClassVisitor(writer);\n-        reader.accept(classVisitor, 0);\n-        instrClassesDone.add(className);\n-        return writer.toByteArray();\n-    }\n-\n-    private static class CallbackClassVisitor extends ClassVisitor {\n-        private String className;\n-\n-        public CallbackClassVisitor(ClassVisitor cv) {\n-            super(Opcodes.ASM7, cv);\n-        }\n-\n-        @Override\n-        public void visit(\n-                int version, int access, String name, String signature,\n-                String superName, String[] interfaces) {\n-            cv.visit(version, access, name, signature, superName, interfaces);\n-            className = name;\n-        }\n+        instrClassesDone.add(target);\n+        var cf = ClassFile.of();\n+        return cf.transform(cf.parse(bytes), (clb, ce) -> {\n+            MethodKey key;\n+            if (ce instanceof MethodModel mm && instrMethodKeys.contains(key = new MethodKey(\n+                    target, mm.methodName().stringValue(), mm.methodTypeSymbol()))) {\n+                clb.transformMethod(mm, MethodTransform.transformingCode(new CodeTransform() {\n+                    private static final MethodTypeDesc MTD_callback = MethodTypeDesc.of(CD_void, CD_String);\n+                    private static final ClassDesc CD_InstrumentationCallback = InstrumentationCallback.class\n+                            .describeConstable().orElseThrow();\n+\n+                    @Override\n+                    public void atStart(CodeBuilder cb) {\n+                        cb.constantInstruction(key.toString());\n+                        cb.invokestatic(CD_InstrumentationCallback, \"callback\", MTD_callback);\n+                        log(\"instrumented \" + key);\n+                    }\n@@ -339,9 +336,7 @@\n-        @Override\n-        public MethodVisitor visitMethod(\n-                int access, String methodName, String desc, String signature, String[] exceptions) {\n-            String methodKey = getInstrMethodKey(className, methodName, desc);\n-            boolean isInstrumentedMethod = Arrays.asList(instrMethodKeys).contains(methodKey);\n-            MethodVisitor mv = cv.visitMethod(access, methodName, desc, signature, exceptions);\n-            if (isInstrumentedMethod && mv != null) {\n-                mv = new CallbackMethodVisitor(mv, methodKey);\n-                log(\"instrumented \" + methodKey);\n+                    @Override\n+                    public void accept(CodeBuilder cb, CodeElement ce) {\n+                        cb.with(ce);\n+                    }\n+                }));\n+            } else {\n+                clb.with(ce);\n@@ -349,2 +344,1 @@\n-            return mv;\n-        }\n+        });\n@@ -353,6 +347,3 @@\n-    public static class CallbackMethodVisitor extends MethodVisitor {\n-        private String logMessage;\n-\n-        public CallbackMethodVisitor(MethodVisitor mv, String logMessage) {\n-            super(Opcodes.ASM7, mv);\n-            this.logMessage = logMessage;\n+    public record MethodKey(ClassDesc owner, String name, MethodTypeDesc desc) {\n+        public MethodKey(String className, String methodName, String signature) {\n+            this(ClassDesc.ofInternalName(className), methodName, MethodTypeDesc.ofDescriptor(signature));\n@@ -362,6 +353,3 @@\n-        public void visitCode() {\n-            mv.visitCode();\n-            String methodDescr = Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(String.class));\n-            String className = InstrumentationCallback.class.getName().replace('.', '\/');\n-            mv.visitLdcInsn(logMessage);\n-            mv.visitMethodInsn(Opcodes.INVOKESTATIC, className, \"callback\", methodDescr);\n+        public String toString() {\n+            var ownerDesc = owner.descriptorString();\n+            return ownerDesc.substring(1, ownerDesc.length() - 1) + \"::\" + name + \"::\" + desc.descriptorString();\n@@ -370,1 +358,0 @@\n-\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestInstrumentation.java","additions":72,"deletions":85,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,7 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.constant.ClassDesc;\n@@ -32,7 +39,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-\n@@ -44,0 +44,3 @@\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+\n@@ -51,2 +54,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          jdk.jartool\/sun.tools.jar\n+ * @modules jdk.jartool\/sun.tools.jar\n+ * @enablePreview\n@@ -102,0 +105,3 @@\n+        private static final ClassDesc CD_InstrumentationEventCallback = InstrumentationEventCallback.class\n+                .describeConstable().orElseThrow();\n+\n@@ -112,7 +118,19 @@\n-                ClassReader reader = new ClassReader(bytes);\n-                ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n-                CallbackClassVisitor classVisitor = new CallbackClassVisitor(writer);\n-\n-                \/\/ visit the reader's class by the classVisitor\n-                reader.accept(classVisitor, 0);\n-                result = writer.toByteArray();\n+                var cf = ClassFile.of();\n+                result = cf.transform(cf.parse(bytes), (clb, ce) -> {\n+                    if (ce instanceof MethodModel mm && mm.methodName().equalsString(INIT_NAME)) {\n+                        clb.transformMethod(mm, MethodTransform.transformingCode(new CodeTransform() {\n+                            @Override\n+                            public void atStart(CodeBuilder cb) {\n+                                cb.invokestatic(CD_InstrumentationEventCallback, \"callback\", MTD_void);\n+                                log(\"instrumented <init> in class \" + className);\n+                            }\n+\n+                            @Override\n+                            public void accept(CodeBuilder cb, CodeElement ce) {\n+                                cb.accept(ce);\n+                            }\n+                        }));\n+                    } else {\n+                        clb.with(ce);\n+                    }\n+                });\n@@ -126,44 +144,0 @@\n-\n-        private static class CallbackClassVisitor extends ClassVisitor {\n-            private String className;\n-\n-            public CallbackClassVisitor(ClassVisitor cv) {\n-                super(Opcodes.ASM7, cv);\n-            }\n-\n-            @Override\n-            public void visit(int version, int access, String name, String signature,\n-                              String superName, String[] interfaces) {\n-                \/\/ visit the header of the class - called per class header visit\n-                cv.visit(version, access, name, signature, superName, interfaces);\n-                className = name;\n-            }\n-\n-            @Override\n-            public MethodVisitor visitMethod(\n-                                             int access, String methodName, String desc,\n-                                             String signature, String[] exceptions) {\n-                \/\/ called for each method in a class\n-                boolean isInstrumentedMethod = methodName.contains(\"<init>\");\n-                MethodVisitor mv = cv.visitMethod(access, methodName, desc, signature, exceptions);\n-                if (isInstrumentedMethod) {\n-                    mv = new CallbackMethodVisitor(mv);\n-                    log(\"instrumented <init> in class \" + className);\n-                }\n-                return mv;\n-            }\n-        }\n-\n-        public static class CallbackMethodVisitor extends MethodVisitor {\n-            public CallbackMethodVisitor(MethodVisitor mv) {\n-                super(Opcodes.ASM7, mv);\n-            }\n-\n-            @Override\n-            public void visitCode() {\n-                mv.visitCode();\n-                String methodDescr = Type.getMethodDescriptor(Type.VOID_TYPE, Type.VOID_TYPE);\n-                String className = InstrumentationEventCallback.class.getName().replace('.', '\/');\n-                mv.visitMethodInsn(Opcodes.INVOKESTATIC, className, \"callback\", \"()V\", false);\n-            }\n-        }\n","filename":"test\/jdk\/jdk\/jfr\/javaagent\/TestEventInstrumentation.java","additions":35,"deletions":61,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n- *    java.base\/jdk.internal.org.objectweb.asm\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestLargeJavaEvent512k.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n- *    java.base\/jdk.internal.org.objectweb.asm\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestLargeJavaEvent64k.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}