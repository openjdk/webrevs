{"files":[{"patch":"@@ -1885,14 +1885,7 @@\n-oop java_lang_Thread::async_get_stack_trace(oop java_thread, TRAPS) {\n-  ThreadsListHandle tlh(JavaThread::current());\n-  JavaThread* thread;\n-  bool is_virtual = java_lang_VirtualThread::is_instance(java_thread);\n-  if (is_virtual) {\n-    oop carrier_thread = java_lang_VirtualThread::carrier_thread(java_thread);\n-    if (carrier_thread == nullptr) {\n-      return nullptr;\n-    }\n-    thread = java_lang_Thread::thread(carrier_thread);\n-  } else {\n-    thread = java_lang_Thread::thread(java_thread);\n-  }\n-  if (thread == nullptr) {\n+oop java_lang_Thread::async_get_stack_trace(jobject jthread, TRAPS) {\n+  ThreadsListHandle tlh(THREAD);\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop;\n+\n+  bool has_java_thread = tlh.cv_internal_thread_to_JavaThread(jthread, &java_thread, &thread_oop, true\/*use_carrier*\/);\n+  if (!has_java_thread) {\n@@ -1904,1 +1897,1 @@\n-    const Handle _java_thread;\n+    const Handle _thread_oop;\n@@ -1910,2 +1903,2 @@\n-    GetStackTraceHandshakeClosure(Handle java_thread) :\n-        HandshakeClosure(\"GetStackTraceHandshakeClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false),\n+    GetStackTraceHandshakeClosure(Handle thread_oop) :\n+        HandshakeClosure(\"GetStackTraceHandshakeClosure\"), _thread_oop(thread_oop), _depth(0), _retry_handshake(false),\n@@ -1933,1 +1926,1 @@\n-      JavaThread* thread = JavaThread::cast(th);\n+      JavaThread* java_thread = JavaThread::cast(th);\n@@ -1935,1 +1928,1 @@\n-      if (!thread->has_last_Java_frame()) {\n+      if (!java_thread->has_last_Java_frame()) {\n@@ -1940,5 +1933,6 @@\n-      if (java_lang_VirtualThread::is_instance(_java_thread())) {\n-        \/\/ if (thread->vthread() != _java_thread()) \/\/ We might be inside a System.executeOnCarrierThread\n-        const ContinuationEntry* ce = thread->vthread_continuation();\n-        if (ce == nullptr || ce->cont_oop(thread) != java_lang_VirtualThread::continuation(_java_thread())) {\n-          return; \/\/ not mounted\n+      if (java_lang_VirtualThread::is_instance(_thread_oop())) {\n+        \/\/ Ensure _thread_oop is still mounted to java_thread.\n+        const ContinuationEntry* ce = java_thread->vthread_continuation();\n+        if (ce == nullptr || ce->cont_oop(java_thread) != java_lang_VirtualThread::continuation(_thread_oop())) {\n+          \/\/ Target thread has been unmounted.\n+          return;\n@@ -1947,1 +1941,1 @@\n-        carrier = (thread->vthread_continuation() != nullptr);\n+        carrier = (java_thread->vthread_continuation() != nullptr);\n@@ -1959,1 +1953,1 @@\n-      for (vframeStream vfst(thread, false, false, carrier); \/\/ we don't process frames as we don't care about oops\n+      for (vframeStream vfst(java_thread, false, false, carrier); \/\/ we don't process frames as we don't care about oops\n@@ -1980,1 +1974,1 @@\n-  GetStackTraceHandshakeClosure gsthc(Handle(THREAD, java_thread));\n+  GetStackTraceHandshakeClosure gsthc(Handle(THREAD, thread_oop));\n@@ -1982,1 +1976,1 @@\n-   Handshake::execute(&gsthc, &tlh, thread);\n+   Handshake::execute(&gsthc, &tlh, java_thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":22,"deletions":28,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-  static oop async_get_stack_trace(oop java_thread, TRAPS);\n+  static oop async_get_stack_trace(jobject jthread, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2960,1 +2960,1 @@\n-  oop trace = java_lang_Thread::async_get_stack_trace(JNIHandles::resolve(jthread), THREAD);\n+  oop trace = java_lang_Thread::async_get_stack_trace(jthread, THREAD);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -794,0 +794,4 @@\n+\/\/ If the thread reference is a mounted virtual thread and use_carrier is true,\n+\/\/ return JavaThread for the carrier thread; if the thread is unmounted\n+\/\/ or use_carrier is false, return false.\n+\/\/\n@@ -801,1 +805,2 @@\n-                                                         oop * thread_oop_p) {\n+                                                         oop* thread_oop_p,\n+                                                         bool use_carrier) {\n@@ -819,0 +824,9 @@\n+  if (use_carrier && java_lang_VirtualThread::is_instance(thread_oop)) {\n+    \/\/ thread_oop_p is already set, can change thread_oop.\n+    thread_oop = java_lang_VirtualThread::carrier_thread(thread_oop);\n+    if (thread_oop == nullptr) {\n+      \/\/ Unmounted vthread.\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,7 @@\n+\/\/ Virtual thread support:\n+\/\/ By default ThreadsListHandle works only with platform threads.\n+\/\/ There is a way to get carrier's JavaThread for mounted virtual thread,\n+\/\/ but mount\/unmount may happen at any time and it's the caller responsibility\n+\/\/ to ensure the virtual thread is still mounted to the returned JavaThread\n+\/\/ in handshake\/VMOp.\n+\/\/\n@@ -61,0 +68,12 @@\n+\/\/ JNI jobject (if jthread can be platform or mounted virtual thread) example:\n+\/\/   jobject jthread = ...;\n+\/\/   :\n+\/\/   ThreadsListHandle tlh;\n+\/\/   JavaThread* jt = nullptr;\n+\/\/   oop vthread_oop = nullptr;\n+\/\/   bool has_java_thread = tlh.cv_internal_thread_to_JavaThread(jthread, &jt, &vthread_oop, true);\n+\/\/   if (has_java_thread) {\n+\/\/     :  \/\/ do stuff with 'jt'...\n+\/\/        \/\/ if jthread is a virtual thread, jt is its carrier's JavaThread\n+\/\/   }\n+\/\/\n@@ -321,1 +340,2 @@\n-  bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread ** jt_pp, oop * thread_oop_p);\n+  \/\/ If use_carrier is true, returns carrier's JavaThread for mounted virtual thread.\n+  bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread** jt_pp, oop* thread_oop_p, bool use_carrier = false);\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"}]}