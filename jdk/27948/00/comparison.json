{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.file.StandardCopyOption;\n@@ -109,0 +110,11 @@\n+            if (List.of(options).contains(StandardCopyOption.REPLACE_EXISTING)) {\n+                \/\/ They requested copying with replacing the existing content.\n+                if (src == null && Files.isRegularFile(dest)) {\n+                    \/\/ This copy action creates a directory, but a file at the same path already exists, so delete it.\n+                    Files.deleteIfExists(dest);\n+                } else if (src != null && Files.isDirectory(dest)) {\n+                    \/\/ This copy action copies a file, but a directory at the same path exists already, so delete it.\n+                    deleteRecursive(dest);\n+                }\n+            }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/FileUtils.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,0 +65,21 @@\n+    public ConfigurationTarget addInstallVerifier(Consumer<JPackageCommand> verifier) {\n+        cmd.ifPresent(Objects.requireNonNull(verifier));\n+        test.ifPresent(v -> {\n+            v.addInstallVerifier(verifier::accept);\n+        });\n+        return this;\n+    }\n+\n+    public ConfigurationTarget addRunOnceInitializer(Consumer<ConfigurationTarget> initializer) {\n+        Objects.requireNonNull(initializer);\n+        cmd.ifPresent(_ -> {\n+            initializer.accept(this);\n+        });\n+        test.ifPresent(v -> {\n+            v.addRunOnceInitializer(() -> {\n+                initializer.accept(this);\n+            });\n+        });\n+        return this;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigurationTarget.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -899,1 +900,8 @@\n-                (\"Check [%s] is a symbolic link\", path));\n+                (\"Check [%s] is a symbolic link\", Objects.requireNonNull(path)));\n+    }\n+\n+    public static void assertSymbolicLinkTarget(Path symlinkPath, Path expectedTargetPath) {\n+        assertSymbolicLinkExists(symlinkPath);\n+        var targetPath = toFunction(Files::readSymbolicLink).apply(symlinkPath);\n+        assertEquals(expectedTargetPath, targetPath,\n+                String.format(\"Check the target of the symbolic link [%s]\", symlinkPath));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import static jdk.internal.util.OperatingSystem.LINUX;\n-import static jdk.internal.util.OperatingSystem.MACOS;\n@@ -27,0 +25,3 @@\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.util.OperatingSystem.MACOS;\n+import static jdk.internal.util.OperatingSystem.WINDOWS;\n@@ -29,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -31,5 +33,3 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.TKit;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n@@ -37,0 +37,6 @@\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n@@ -38,0 +44,1 @@\n+import java.util.stream.StreamSupport;\n@@ -39,1 +46,5 @@\n-import jdk.jpackage.internal.util.function.ThrowingFunction;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.ConfigurationTarget;\n@@ -42,0 +53,2 @@\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.TKit;\n@@ -60,16 +73,6 @@\n-    private static final String TEST_JAVA = \"apps\/PrintEnv.java\";\n-    private static final String TEST_DUKE = \"apps\/dukeplug.png\";\n-    private static final String TEST_DUKE_LINK = \"dukeplugLink.txt\";\n-    private static final String TEST_DIR = \"apps\";\n-    private static final String TEST_BAD = \"non-existant\";\n-\n-    \/\/ On OSX `--app-content` paths will be copied into the \"Contents\" folder\n-    \/\/ of the output app image.\n-    \/\/ \"codesign\" imposes restrictions on the directory structure of \"Contents\" folder.\n-    \/\/ In particular, random files should be placed in \"Contents\/Resources\" folder\n-    \/\/ otherwise \"codesign\" will fail to sign.\n-    \/\/ Need to prepare arguments for `--app-content` accordingly.\n-    private static final boolean copyInResources = TKit.isOSX();\n-\n-    private static final String RESOURCES_DIR = \"Resources\";\n-    private static final String LINKS_DIR = \"Links\";\n+    @Test\n+    @ParameterSupplier\n+    @ParameterSupplier(value=\"testSymlink\", ifNotOS = WINDOWS)\n+    public void test(TestSpec testSpec) throws Exception {\n+        testSpec.test(new ConfigurationTarget(new PackageTest().configureHelloApp()));\n+    }\n@@ -78,39 +81,4 @@\n-    \/\/ include two files in two options\n-    @Parameter({TEST_JAVA, TEST_DUKE})\n-    \/\/ try to include non-existant content\n-    @Parameter({TEST_JAVA, TEST_BAD})\n-     \/\/ two files in one option and a dir tree in another option.\n-    @Parameter({TEST_JAVA + \",\" + TEST_DUKE, TEST_DIR})\n-     \/\/ include one file and one link to the file\n-    @Parameter(value = {TEST_JAVA, TEST_DUKE_LINK}, ifOS = {MACOS,LINUX})\n-    public void test(String... args) throws Exception {\n-        final List<String> testPathArgs = List.of(args);\n-        final int expectedJPackageExitCode;\n-        if (testPathArgs.contains(TEST_BAD)) {\n-            expectedJPackageExitCode = 1;\n-        } else {\n-            expectedJPackageExitCode = 0;\n-        }\n-\n-        var appContentInitializer = new AppContentInitializer(testPathArgs);\n-\n-        new PackageTest().configureHelloApp()\n-            .addRunOnceInitializer(appContentInitializer::initAppContent)\n-            .addInitializer(appContentInitializer::applyTo)\n-            .addInstallVerifier(cmd -> {\n-                for (String arg : testPathArgs) {\n-                    List<String> paths = Arrays.asList(arg.split(\",\"));\n-                    for (String p : paths) {\n-                        Path name = Path.of(p).getFileName();\n-                        if (isSymlinkPath(name)) {\n-                            TKit.assertSymbolicLinkExists(getAppContentRoot(cmd)\n-                                .resolve(LINKS_DIR).resolve(name));\n-                        } else {\n-                            TKit.assertPathExists(getAppContentRoot(cmd)\n-                                .resolve(name), true);\n-                        }\n-                    }\n-                }\n-            })\n-            .setExpectedExitCode(expectedJPackageExitCode)\n-            .run();\n+    @ParameterSupplier(\"test\")\n+    @ParameterSupplier(value=\"testSymlink\", ifNotOS = WINDOWS)\n+    public void testAppImage(TestSpec testSpec) throws Exception {\n+        testSpec.test(new ConfigurationTarget(JPackageCommand.helloAppImage()));\n@@ -120,2 +88,2 @@\n-    @Parameter({TEST_DIR, \"warning.non.standard.contents.sub.dir\"})\n-    @Parameter({TEST_DUKE, \"warning.app.content.is.not.dir\"})\n+    @Parameter({\"apps\", \"warning.non.standard.contents.sub.dir\"})\n+    @Parameter({\"apps\/dukeplug.png\", \"warning.app.content.is.not.dir\"})\n@@ -129,0 +97,1 @@\n+            .setFakeRuntime()\n@@ -133,0 +102,185 @@\n+    public static Collection<Object[]> test() {\n+        return Stream.of(\n+                build().add(TEST_JAVA).add(TEST_DUKE),\n+                build().add(TEST_JAVA).add(TEST_BAD),\n+                build().startGroup().add(TEST_JAVA).add(TEST_DUKE).endGroup().add(TEST_DIR),\n+                \/\/ Same directory specified multiple times.\n+                build().add(TEST_DIR).add(TEST_DIR),\n+                \/\/ Same file specified multiple times.\n+                build().add(TEST_JAVA).add(TEST_JAVA),\n+                \/\/ Two files with the same name but different content.\n+                build()\n+                        .add(createTextFileContent(\"welcome.txt\", \"Welcome\"))\n+                        .add(createTextFileContent(\"welcome.txt\", \"Benvenuti\")),\n+                \/\/ Same name: one is a directory, another is a file.\n+                build().add(createTextFileContent(\"a\/b\/c\/d\", \"Foo\")).add(createTextFileContent(\"a\", \"Bar\")),\n+                \/\/ Same name: one is a file, another is a directory.\n+                build().add(createTextFileContent(\"a\", \"Bar\")).add(createTextFileContent(\"a\/b\/c\/d\", \"Foo\"))\n+        ).map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    public static Collection<Object[]> testSymlink() {\n+        return Stream.of(\n+                build().add(TEST_JAVA)\n+                        .add(new SymlinkContentFactory(\"Links\", \"duke-link\", \"duke-target\"))\n+                        .add(new SymlinkContentFactory(\"\", \"a\/b\/foo-link\", \"c\/bar-target\"))\n+        ).map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    public record TestSpec(List<List<ContentFactory>> contentFactories) {\n+        public TestSpec {\n+            contentFactories.stream().flatMap(List::stream).forEach(Objects::requireNonNull);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return contentFactories.stream().map(group -> {\n+                return group.stream().map(ContentFactory::toString).collect(joining(\",\"));\n+            }).collect(joining(\"; \"));\n+        }\n+\n+        void test(ConfigurationTarget target) {\n+            final int expectedJPackageExitCode;\n+            if (contentFactories.stream().flatMap(List::stream).anyMatch(TEST_BAD::equals)) {\n+                expectedJPackageExitCode = 1;\n+            } else {\n+                expectedJPackageExitCode = 0;\n+            }\n+\n+            final List<List<Content>> allContent = new ArrayList<>();\n+\n+            target.addInitializer(JPackageCommand::setFakeRuntime)\n+            .addRunOnceInitializer(_ -> {\n+                contentFactories.stream().map(group -> {\n+                    return group.stream().map(ContentFactory::create).toList();\n+                }).forEach(allContent::add);\n+            }).addInitializer(cmd -> {\n+                allContent.stream().map(group -> {\n+                    return Stream.of(\"--app-content\", group.stream()\n+                            .map(Content::paths)\n+                            .flatMap(List::stream)\n+                            .map(appContentArg -> {\n+                                if (COPY_IN_RESOURCES && Optional.ofNullable(appContentArg.getParent())\n+                                        .map(Path::getFileName)\n+                                        .map(RESOURCES_DIR::equals)\n+                                        .orElse(false)) {\n+                                    return appContentArg.getParent();\n+                                } else {\n+                                    return appContentArg;\n+                                }\n+                            })\n+                            .map(Path::toString)\n+                            .collect(joining(\",\")));\n+                    }).flatMap(x -> x).forEachOrdered(cmd::addArgument);\n+            });\n+\n+            target.cmd().ifPresent(cmd -> {\n+                if (expectedJPackageExitCode == 0) {\n+                    cmd.executeAndAssertImageCreated();\n+                } else {\n+                    cmd.execute(expectedJPackageExitCode);\n+                }\n+            });\n+\n+            target.addInstallVerifier(cmd -> {\n+                var appContentRoot = getAppContentRoot(cmd);\n+\n+                Set<PathVerifier> disabledVerifiers = new HashSet<>();\n+\n+                var verifiers = allContent.stream().flatMap(List::stream).flatMap(content -> {\n+                    return StreamSupport.stream(content.verifiers(appContentRoot).spliterator(), false).map(verifier -> {\n+                        return new PathVerifierWithOrigin(verifier, content);\n+                    });\n+                }).collect(toMap(PathVerifierWithOrigin::path, x -> x, (first, second) -> {\n+                    \/\/ The same file in the content directory is sourced from multiple origins.\n+                    \/\/ jpackage will handle this case such that the following origins overwrite preceding origins.\n+                    \/\/ Scratch all path verifiers affected by overrides.\n+                    first.getNestedVerifiers(appContentRoot, first.path()).forEach(disabledVerifiers::add);\n+                    return second;\n+                }, TreeMap::new)).values().stream()\n+                        .map(PathVerifierWithOrigin::verifier)\n+                        .filter(Predicate.not(disabledVerifiers::contains))\n+                        .filter(verifier -> {\n+                            if (!(verifier instanceof DirectoryVerifier)) {\n+                                return true;\n+                            } else {\n+                                try (var files = Files.list(verifier.path())) {\n+                                    \/\/ Run the directory verifier if the directory is empty. Otherwise, it just pollutes the test log.\n+                                    return files.findAny().isEmpty();\n+                                } catch (IOException ex) {\n+                                    throw new UncheckedIOException(ex);\n+                                }\n+                            }\n+                        })\n+                        .toList();\n+\n+                verifiers.forEach(PathVerifier::verify);\n+            });\n+\n+            target.test().ifPresent(test -> {\n+                test.setExpectedExitCode(expectedJPackageExitCode).run();\n+            });\n+        }\n+\n+        static final class Builder {\n+            TestSpec create() {\n+                return new TestSpec(groups);\n+            }\n+\n+            final class GroupBuilder {\n+                GroupBuilder add(ContentFactory cf) {\n+                    group.add(Objects.requireNonNull(cf));\n+                    return this;\n+                }\n+\n+                Builder endGroup() {\n+                    if (!group.isEmpty()) {\n+                        groups.add(group);\n+                    }\n+                    return Builder.this;\n+                }\n+\n+                private final List<ContentFactory> group = new ArrayList<>();\n+            }\n+\n+            Builder add(ContentFactory cf) {\n+                return startGroup().add(cf).endGroup();\n+            }\n+\n+            GroupBuilder startGroup() {\n+                return new GroupBuilder();\n+            }\n+\n+            private final List<List<ContentFactory>> groups = new ArrayList<>();\n+        }\n+\n+        private record PathVerifierWithOrigin(PathVerifier verifier, Content origin) {\n+            PathVerifierWithOrigin {\n+                Objects.requireNonNull(verifier);\n+                Objects.requireNonNull(origin);\n+            }\n+\n+            Path path() {\n+                return verifier.path();\n+            }\n+\n+            Stream<PathVerifier> getNestedVerifiers(Path appContentRoot, Path path) {\n+                if (!path.startsWith(appContentRoot)) {\n+                    throw new IllegalArgumentException();\n+                }\n+\n+                return StreamSupport.stream(origin.verifiers(appContentRoot).spliterator(), false).filter(v -> {\n+                    return v.path().getNameCount() > path.getNameCount() && v.path().startsWith(path);\n+                });\n+            }\n+        }\n+    }\n+\n+    private static TestSpec.Builder build() {\n+        return new TestSpec.Builder();\n+    }\n+\n@@ -134,2 +288,2 @@\n-        Path contentDir = cmd.appLayout().contentDirectory();\n-        if (copyInResources) {\n+        final Path contentDir = cmd.appLayout().contentDirectory();\n+        if (COPY_IN_RESOURCES) {\n@@ -142,2 +296,11 @@\n-    private static boolean isSymlinkPath(Path v) {\n-        return v.getFileName().toString().contains(\"Link\");\n+    private static Path createAppContentRoot() {\n+        if (COPY_IN_RESOURCES) {\n+            return TKit.createTempDirectory(\"app-content\").resolve(RESOURCES_DIR);\n+        } else {\n+            return TKit.createTempDirectory(\"app-content\");\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface ContentFactory {\n+        Content create();\n@@ -146,5 +309,24 @@\n-    private static final class AppContentInitializer {\n-        AppContentInitializer(List<String> appContentArgs) {\n-            appContentPathGroups = appContentArgs.stream().map(arg -> {\n-                return Stream.of(arg.split(\",\")).map(Path::of).toList();\n-            }).toList();\n+    private interface Content {\n+        List<Path> paths();\n+        Iterable<PathVerifier> verifiers(Path appContentRoot);\n+    }\n+\n+    private sealed interface PathVerifier permits\n+            RegularFileVerifier,\n+            DirectoryVerifier,\n+            SymlinkTargetVerifier,\n+            NoPathVerifier {\n+\n+        Path path();\n+        void verify();\n+    }\n+\n+    private record RegularFileVerifier(Path path, Path srcFile) implements PathVerifier {\n+        RegularFileVerifier {\n+            Objects.requireNonNull(path);\n+            Objects.requireNonNull(srcFile);\n+        }\n+\n+        @Override\n+        public void verify() {\n+            TKit.assertSameFileContent(srcFile, path);\n@@ -152,0 +334,1 @@\n+    }\n@@ -153,9 +336,3 @@\n-        void initAppContent() {\n-            jpackageArgs = appContentPathGroups.stream()\n-                    .map(AppContentInitializer::initAppContentPaths)\n-                    .<String>mapMulti((appContentPaths, consumer) -> {\n-                        consumer.accept(\"--app-content\");\n-                        consumer.accept(\n-                        appContentPaths.stream().map(Path::toString).collect(\n-                                joining(\",\")));\n-                    }).toList();\n+    private record DirectoryVerifier(Path path) implements PathVerifier {\n+        DirectoryVerifier {\n+            Objects.requireNonNull(path);\n@@ -164,2 +341,3 @@\n-        void applyTo(JPackageCommand cmd) {\n-            cmd.addArguments(jpackageArgs);\n+        @Override\n+        public void verify() {\n+            TKit.assertDirectoryExists(path);\n@@ -167,0 +345,13 @@\n+    }\n+\n+    private record SymlinkTargetVerifier(Path path, Path targetPath) implements PathVerifier {\n+        SymlinkTargetVerifier {\n+            Objects.requireNonNull(path);\n+            Objects.requireNonNull(targetPath);\n+        }\n+\n+        @Override\n+        public void verify() {\n+            TKit.assertSymbolicLinkTarget(path, targetPath);\n+        }\n+    }\n@@ -168,6 +359,3 @@\n-        private static Path copyAppContentPath(Path appContentPath) throws IOException {\n-            var appContentArg = TKit.createTempDirectory(\"app-content\").resolve(RESOURCES_DIR);\n-            var srcPath = TKit.TEST_SRC_ROOT.resolve(appContentPath);\n-            var dstPath = appContentArg.resolve(srcPath.getFileName());\n-            FileUtils.copyRecursive(srcPath, dstPath);\n-            return appContentArg;\n+    private record NoPathVerifier(Path path) implements PathVerifier {\n+        NoPathVerifier {\n+            Objects.requireNonNull(path);\n@@ -176,2 +364,236 @@\n-        private static Path createAppContentLink(Path appContentPath) throws IOException {\n-            var appContentArg = TKit.createTempDirectory(\"app-content\");\n+        @Override\n+        public void verify() {\n+            TKit.assertPathExists(path, false);\n+        }\n+    }\n+\n+    private record FileContent(Path path, int level) implements Content {\n+\n+        FileContent {\n+            Objects.requireNonNull(path);\n+            if ((level < 0) || (path.getNameCount() <= level)) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        @Override\n+        public List<Path> paths() {\n+            return List.of(appContentOptionValue());\n+        }\n+\n+        @Override\n+        public Iterable<PathVerifier> verifiers(Path appContentRoot) {\n+            List<PathVerifier> verifiers = new ArrayList<>();\n+\n+            var appContentPath = appContentRoot.resolve(pathInAppContentRoot());\n+\n+            if (Files.isDirectory(path)) {\n+                try (var walk = Files.walk(path)) {\n+                    verifiers.addAll(walk.map(srcFile -> {\n+                        var dstFile = appContentPath.resolve(path.relativize(srcFile));\n+                        if (Files.isRegularFile(srcFile)) {\n+                            return new RegularFileVerifier(dstFile, srcFile);\n+                        } else {\n+                            return new DirectoryVerifier(dstFile);\n+                        }\n+                    }).toList());\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            } else if (Files.isRegularFile(path)) {\n+                verifiers.add(new RegularFileVerifier(appContentPath, path));\n+            } else {\n+                verifiers.add(new NoPathVerifier(appContentPath));\n+            }\n+\n+            if (level > 0) {\n+                var cur = appContentPath;\n+                for (int i = 0; i != level; i++) {\n+                    cur = cur.getParent();\n+                    verifiers.add(new DirectoryVerifier(cur));\n+                }\n+            }\n+\n+            return verifiers;\n+        }\n+\n+        private Path appContentOptionValue() {\n+            var cur = path;\n+            for (int i = 0; i != level; i++) {\n+                cur = cur.getParent();\n+            }\n+            return cur;\n+        }\n+\n+        private Path pathInAppContentRoot() {\n+            return StreamSupport.stream(path.spliterator(), false)\n+                    .skip(path.getNameCount() - level - 1)\n+                    .reduce(Path::resolve).orElseThrow();\n+        }\n+    }\n+\n+    \/**\n+     * Non-existing content.\n+     *\/\n+    private static final class NonExistantPath implements ContentFactory {\n+        @Override\n+        public Content create() {\n+            var nonExistant = TKit.createTempFile(\"non-existant\");\n+            try {\n+                TKit.deleteIfExists(nonExistant);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            return new FileContent(nonExistant, 0);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"*non-existant*\";\n+        }\n+    }\n+\n+    \/**\n+     * Creates a content from {@link TKit#TEST_SRC_ROOT} directory.\n+     *\n+     * @param path source path relative to {@link TKit#TEST_SRC_ROOT} directory\n+     *\/\n+    private static ContentFactory createTestSrcContent(Path path) {\n+        if (path.isAbsolute()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new FileContentFactory(() -> {\n+            return TKit.TEST_SRC_ROOT.resolve(path);\n+        }, path);\n+    }\n+\n+    private static ContentFactory createTestSrcContent(String path) {\n+        return createTestSrcContent(Path.of(path));\n+    }\n+\n+    \/**\n+     * Creates a content from a text file.\n+     *\n+     * @param path the path where to copy the text file in app image's content directory\n+     * @param lines the content of the source text file\n+     *\/\n+    private static ContentFactory createTextFileContent(Path path, String ... lines) {\n+        if (path.isAbsolute()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new FileContentFactory(() -> {\n+            var srcPath = TKit.createTempDirectory(\"content\").resolve(path);\n+            Files.createDirectories(srcPath.getParent());\n+            TKit.createTextFile(srcPath, Stream.of(lines));\n+            return srcPath;\n+        }, path);\n+    }\n+\n+    private static ContentFactory createTextFileContent(String path, String ... lines) {\n+        return createTextFileContent(Path.of(path), lines);\n+    }\n+\n+    \/**\n+     * Symlink content factory.\n+     *\n+     * @path basedir the directory where to write the content in app image's content\n+     *       directory\n+     * @param symlink   the path to the symlink relative to {@code basedir} path\n+     * @param symlinked the path to the source file for the symlink\n+     *\/\n+    private record SymlinkContentFactory(Path basedir, Path symlink, Path symlinked) implements ContentFactory {\n+        SymlinkContentFactory {\n+            for (final var path : List.of(basedir, symlink, symlinked)) {\n+                if (path.isAbsolute()) {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        }\n+\n+        SymlinkContentFactory(String basedir, String symlink, String symlinked) {\n+            this(Path.of(basedir), Path.of(symlink), Path.of(symlinked));\n+        }\n+\n+        @Override\n+        public Content create() {\n+            final var appContentRoot = createAppContentRoot();\n+\n+            final var symlinkPath = appContentRoot.resolve(symlinkPath());\n+            final var symlinkedPath = appContentRoot.resolve(symlinkedPath());\n+            try {\n+                Files.createDirectories(symlinkPath.getParent());\n+                Files.createDirectories(symlinkedPath.getParent());\n+                \/\/ Create the target file for the link.\n+                Files.writeString(symlinkedPath, symlinkedPath().toString());\n+                \/\/ Create the link.\n+                Files.createSymbolicLink(symlinkPath, symlinkTarget());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+\n+            List<Path> contentPaths;\n+            if (COPY_IN_RESOURCES) {\n+                contentPaths = List.of(appContentRoot);\n+            } else if (basedir.equals(Path.of(\"\"))) {\n+                contentPaths = Stream.of(symlinkPath(), symlinkedPath()).map(path -> {\n+                    return path.getName(0);\n+                }).map(appContentRoot::resolve).toList();\n+            } else {\n+                contentPaths = List.of(appContentRoot.resolve(basedir));\n+            }\n+\n+            return new Content() {\n+                @Override\n+                public List<Path> paths() {\n+                    return contentPaths;\n+                }\n+\n+                @Override\n+                public Iterable<PathVerifier> verifiers(Path appContentRoot) {\n+                    return List.of(\n+                            new RegularFileVerifier(appContentRoot.resolve(symlinkedPath()), symlinkedPath),\n+                            new SymlinkTargetVerifier(appContentRoot.resolve(symlinkPath()), symlinkTarget())\n+                    );\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"symlink:[%s]->[%s][%s]\", symlinkPath(), symlinkedPath(), symlinkTarget());\n+        }\n+\n+        private Path symlinkPath() {\n+            return basedir.resolve(symlink);\n+        }\n+\n+        private Path symlinkedPath() {\n+            return basedir.resolve(symlinked);\n+        }\n+\n+        private Path symlinkTarget() {\n+            return Optional.ofNullable(symlinkPath().getParent()).map(dir -> {\n+                return dir.relativize(symlinkedPath());\n+            }).orElseGet(this::symlinkedPath);\n+        }\n+    }\n+\n+    private static final class FileContentFactory implements ContentFactory {\n+\n+        FileContentFactory(ThrowingSupplier<Path> factory, Path pathInAppContentRoot) {\n+            this.factory = ThrowingSupplier.toSupplier(factory);\n+            this.pathInAppContentRoot = pathInAppContentRoot;\n+            if (pathInAppContentRoot.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        @Override\n+        public Content create() {\n+            Path srcPath = factory.get();\n+            if (!srcPath.endsWith(pathInAppContentRoot)) {\n+                throw new IllegalArgumentException();\n+            }\n+\n@@ -179,4 +601,2 @@\n-            if (copyInResources) {\n-                appContentArg = appContentArg.resolve(RESOURCES_DIR);\n-                dstPath = appContentArg.resolve(LINKS_DIR)\n-                                       .resolve(appContentPath.getFileName());\n+            if (!COPY_IN_RESOURCES) {\n+                dstPath = srcPath;\n@@ -184,30 +604,6 @@\n-                appContentArg = appContentArg.resolve(LINKS_DIR);\n-                dstPath = appContentArg.resolve(appContentPath.getFileName());\n-            }\n-\n-            Files.createDirectories(dstPath.getParent());\n-\n-            \/\/ Create target file for a link\n-            String tagetName = dstPath.getFileName().toString().replace(\"Link\", \"\");\n-            Path targetPath = dstPath.getParent().resolve(tagetName);\n-            Files.write(targetPath, \"foo\".getBytes());\n-            \/\/ Create link\n-            Files.createSymbolicLink(dstPath, targetPath.getFileName());\n-\n-            return appContentArg;\n-        }\n-\n-        private static List<Path> initAppContentPaths(List<Path> appContentPaths) {\n-            return appContentPaths.stream().map(appContentPath -> {\n-                if (appContentPath.endsWith(TEST_BAD)) {\n-                    return appContentPath;\n-                } else if (isSymlinkPath(appContentPath)) {\n-                    return ThrowingFunction.toFunction(\n-                            AppContentInitializer::createAppContentLink).apply(\n-                                    appContentPath);\n-                } else if (copyInResources) {\n-                    return ThrowingFunction.toFunction(\n-                            AppContentInitializer::copyAppContentPath).apply(\n-                                    appContentPath);\n-                } else {\n-                    return TKit.TEST_SRC_ROOT.resolve(appContentPath);\n+                var contentDir = createAppContentRoot();\n+                dstPath = contentDir.resolve(pathInAppContentRoot);\n+                try {\n+                    FileUtils.copyRecursive(srcPath, dstPath);\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n@@ -215,1 +611,2 @@\n-            }).toList();\n+            }\n+            return new FileContent(dstPath, pathInAppContentRoot.getNameCount() - 1);\n@@ -218,2 +615,7 @@\n-        private List<String> jpackageArgs;\n-        private final List<List<Path>> appContentPathGroups;\n+        @Override\n+        public String toString() {\n+            return pathInAppContentRoot.toString();\n+        }\n+\n+        private final Supplier<Path> factory;\n+        private final Path pathInAppContentRoot;\n@@ -221,0 +623,15 @@\n+\n+    private static final ContentFactory TEST_JAVA = createTestSrcContent(\"apps\/PrintEnv.java\");\n+    private static final ContentFactory TEST_DUKE = createTextFileContent(\"duke.txt\", \"Hi Duke!\");\n+    private static final ContentFactory TEST_DIR = createTestSrcContent(\"apps\");\n+    private static final ContentFactory TEST_BAD = new NonExistantPath();\n+\n+    \/\/ On OSX `--app-content` paths will be copied into the \"Contents\" folder\n+    \/\/ of the output app image.\n+    \/\/ \"codesign\" imposes restrictions on the directory structure of \"Contents\" folder.\n+    \/\/ In particular, random files should be placed in \"Contents\/Resources\" folder\n+    \/\/ otherwise \"codesign\" will fail to sign.\n+    \/\/ Need to prepare arguments for `--app-content` accordingly.\n+    private static final boolean COPY_IN_RESOURCES = TKit.isOSX();\n+\n+    private static final Path RESOURCES_DIR = Path.of(\"Resources\");\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppContentTest.java","additions":547,"deletions":130,"binary":false,"changes":677,"status":"modified"}]}