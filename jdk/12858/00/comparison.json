{"files":[{"patch":"@@ -149,2 +149,0 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n-\n@@ -1701,0 +1699,6 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -125,2 +125,0 @@\n-  if (!InlineIntrinsics) return nullptr; \/\/ Generate a vanilla entry\n-\n@@ -783,0 +781,1 @@\n+address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }\n@@ -786,0 +785,4 @@\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1936,0 +1936,7 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -146,4 +146,0 @@\n-  if (!InlineIntrinsics) {\n-    return NULL; \/\/ Generate a vanilla entry\n-  }\n-\n@@ -863,1 +859,1 @@\n-  return 0;\n+  return nullptr;\n@@ -873,1 +869,1 @@\n-  return 0;\n+  return nullptr;\n@@ -885,1 +881,1 @@\n-  return 0;\n+  return nullptr;\n@@ -888,0 +884,6 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2006,0 +2006,7 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -323,2 +323,0 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n-\n@@ -469,0 +467,4 @@\n+\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_32.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -345,2 +345,0 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n-\n@@ -463,0 +461,6 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -3223,0 +3224,14 @@\n+\n+bool VM_Version::is_intrinsic_supported(vmIntrinsicID id) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  switch (id) {\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!supports_f16c() && !supports_avx512vl()) return false;\n+    break;\n+  default:\n+    break;\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -762,0 +762,3 @@\n+  \/\/ Check intrinsic support\n+  static bool is_intrinsic_supported(vmIntrinsicID id);\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -648,3 +649,2 @@\n-bool vmIntrinsics::is_disabled_by_flags(const methodHandle& method) {\n-  vmIntrinsics::ID id = method->intrinsic_id();\n-  return is_disabled_by_flags(id);\n+bool vmIntrinsics::is_intrinsic_available(vmIntrinsics::ID id) {\n+  return VM_Version::is_intrinsic_supported(id) && !is_disabled_by_flags(id);\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1527,4 +1527,1 @@\n-  static bool is_disabled_by_flags(const methodHandle& method);\n-  static bool is_intrinsic_available(vmIntrinsics::ID id) {\n-    return !is_disabled_by_flags(id);\n-  }\n+  static bool is_intrinsic_available(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+    vmIntrinsics::ID id = method->intrinsic_id();\n+    assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n@@ -130,2 +132,2 @@\n-           !directive->is_intrinsic_disabled(method) &&\n-           !vmIntrinsics::is_disabled_by_flags(method);\n+           vmIntrinsics::is_intrinsic_available(id) &&\n+           !directive->is_intrinsic_disabled(id);\n","filename":"src\/hotspot\/share\/compiler\/abstractCompiler.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -552,2 +552,1 @@\n-bool DirectiveSet::is_intrinsic_disabled(const methodHandle& method) {\n-  vmIntrinsics::ID id = method->intrinsic_id();\n+bool DirectiveSet::is_intrinsic_disabled(vmIntrinsics::ID id) {\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-  bool is_intrinsic_disabled(const methodHandle& method);\n+  bool is_intrinsic_disabled(vmIntrinsicID id);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,2 +90,0 @@\n-address    AbstractInterpreter::_native_entry_begin                         = nullptr;\n-address    AbstractInterpreter::_native_entry_end                           = nullptr;\n@@ -136,1 +134,0 @@\n-#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n@@ -138,1 +135,0 @@\n-#endif\n@@ -151,1 +147,1 @@\n-      case vmIntrinsics::_dsqrt_strict:      return java_lang_math_sqrt;\n+      case vmIntrinsics::_dsqrt_strict:      return java_lang_math_sqrt_strict;\n@@ -198,1 +194,42 @@\n-void AbstractInterpreter::set_entry_for_kind(AbstractInterpreter::MethodKind kind, address entry) {\n+vmIntrinsics::ID AbstractInterpreter::method_intrinsic(MethodKind kind) {\n+  switch (kind) {\n+  case java_lang_math_sin         : return vmIntrinsics::_dsin;\n+  case java_lang_math_cos         : return vmIntrinsics::_dcos;\n+  case java_lang_math_tan         : return vmIntrinsics::_dtan;\n+  case java_lang_math_abs         : return vmIntrinsics::_dabs;\n+  case java_lang_math_log         : return vmIntrinsics::_dlog;\n+  case java_lang_math_log10       : return vmIntrinsics::_dlog10;\n+  case java_lang_math_sqrt        : return vmIntrinsics::_dsqrt;\n+  case java_lang_math_sqrt_strict : return vmIntrinsics::_dsqrt_strict;\n+  case java_lang_math_pow         : return vmIntrinsics::_dpow;\n+  case java_lang_math_exp         : return vmIntrinsics::_dexp;\n+  case java_lang_math_fmaD        : return vmIntrinsics::_fmaD;\n+  case java_lang_math_fmaF        : return vmIntrinsics::_fmaF;\n+  case java_lang_ref_reference_get: return vmIntrinsics::_Reference_get;\n+  case java_util_zip_CRC32_update : return vmIntrinsics::_updateCRC32;\n+  case java_util_zip_CRC32_updateBytes\n+                                  : return vmIntrinsics::_updateBytesCRC32;\n+  case java_util_zip_CRC32_updateByteBuffer\n+                                  : return vmIntrinsics::_updateByteBufferCRC32;\n+  case java_util_zip_CRC32C_updateBytes\n+                                  : return vmIntrinsics::_updateBytesCRC32C;\n+  case java_util_zip_CRC32C_updateDirectByteBuffer\n+                                  : return vmIntrinsics::_updateDirectByteBufferCRC32C;\n+  case java_lang_Thread_currentThread\n+                                  : return vmIntrinsics::_currentThread;\n+  case java_lang_Float_intBitsToFloat\n+                                  : return vmIntrinsics::_intBitsToFloat;\n+  case java_lang_Float_floatToRawIntBits\n+                                  : return vmIntrinsics::_floatToRawIntBits;\n+  case java_lang_Double_longBitsToDouble\n+                                  : return vmIntrinsics::_longBitsToDouble;\n+  case java_lang_Double_doubleToRawLongBits\n+                                  : return vmIntrinsics::_doubleToRawLongBits;\n+  default:\n+    fatal(\"unexpected method intrinsic kind: %d\", kind);\n+    break;\n+  }\n+  return vmIntrinsics::_none;\n+}\n+\n+void AbstractInterpreter::set_entry_for_kind(MethodKind kind, address entry) {\n@@ -274,0 +311,1 @@\n+    case java_lang_math_sqrt_strict           : tty->print(\"java_lang_math_sqrt_strict\"); break;\n@@ -279,0 +317,6 @@\n+    case java_lang_ref_reference_get          : tty->print(\"java_lang_ref_reference_get\"); break;\n+    case java_lang_Thread_currentThread       : tty->print(\"java_lang_Thread_currentThread\"); break;\n+    case java_lang_Float_intBitsToFloat       : tty->print(\"java_lang_Float_intBitsToFloat\"); break;\n+    case java_lang_Float_floatToRawIntBits    : tty->print(\"java_lang_Float_floatToRawIntBits\"); break;\n+    case java_lang_Double_longBitsToDouble    : tty->print(\"java_lang_Double_longBitsToDouble\"); break;\n+    case java_lang_Double_doubleToRawLongBits : tty->print(\"java_lang_Double_doubleToRawLongBits\"); break;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":50,"deletions":6,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+    java_lang_math_sqrt_strict,                                 \/\/ implementation of java.lang.StrictMath.sqrt(x)\n@@ -106,0 +107,3 @@\n+  \/\/ Conversion from the above enum to vmIntrinsics::ID\n+  static vmIntrinsics::ID method_intrinsic(MethodKind kind);\n+\n@@ -115,3 +119,0 @@\n-  static address    _native_entry_begin;                        \/\/ Region for native entry code\n-  static address    _native_entry_end;\n-\n@@ -222,1 +223,0 @@\n-  static bool       in_native_entry(address pc)                 { return _native_entry_begin <= pc && pc < _native_entry_end; }\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -180,3 +180,3 @@\n-#define method_entry(kind)                                                                   \\\n-  { CodeletMark cm(_masm, \"method entry point (kind = \" #kind \")\");                          \\\n-    Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind); \\\n+#define method_entry(kind)                                                                          \\\n+  { CodeletMark cm(_masm, \"method entry point (kind = \" #kind \")\");                                 \\\n+    Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind, false); \\\n@@ -197,0 +197,1 @@\n+  method_entry(java_lang_math_sqrt_strict)\n@@ -204,3 +205,0 @@\n-#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n-  method_entry(java_lang_Thread_currentThread)\n-#endif\n@@ -209,9 +207,0 @@\n-  \/\/ all native method kinds (must be one contiguous block)\n-  Interpreter::_native_entry_begin = Interpreter::code()->code_end();\n-  method_entry(native)\n-  method_entry(native_synchronized)\n-  Interpreter::_native_entry_end = Interpreter::code()->code_end();\n-\n-  method_entry(java_util_zip_CRC32_update)\n-  method_entry(java_util_zip_CRC32_updateBytes)\n-  method_entry(java_util_zip_CRC32_updateByteBuffer)\n@@ -221,5 +210,0 @@\n-  method_entry(java_lang_Float_intBitsToFloat);\n-  method_entry(java_lang_Float_floatToRawIntBits);\n-  method_entry(java_lang_Double_longBitsToDouble);\n-  method_entry(java_lang_Double_doubleToRawLongBits);\n-\n@@ -228,0 +212,25 @@\n+  \/\/ all native method kinds\n+#define native_method_entry(kind)                                                                  \\\n+  { CodeletMark cm(_masm, \"native method entry point (kind = \" #kind \")\");                         \\\n+    Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind, true); \\\n+  }\n+\n+  native_method_entry(native)\n+  native_method_entry(native_synchronized)\n+\n+  \/\/ Entries to intrinsics for native methods should follow\n+  \/\/ entries for `native` methods to use the same address in case\n+  \/\/ intrinsic is disabled.\n+  native_method_entry(java_lang_Thread_currentThread)\n+\n+  native_method_entry(java_util_zip_CRC32_update)\n+  native_method_entry(java_util_zip_CRC32_updateBytes)\n+  native_method_entry(java_util_zip_CRC32_updateByteBuffer)\n+\n+  native_method_entry(java_lang_Float_intBitsToFloat)\n+  native_method_entry(java_lang_Float_floatToRawIntBits)\n+  native_method_entry(java_lang_Double_longBitsToDouble)\n+  native_method_entry(java_lang_Double_doubleToRawLongBits)\n+\n+#undef native_method_entry\n+\n@@ -397,1 +406,1 @@\n-                                        AbstractInterpreter::MethodKind kind) {\n+                                        AbstractInterpreter::MethodKind kind, bool native) {\n@@ -399,1 +408,0 @@\n-  bool native = false;\n@@ -404,4 +412,4 @@\n-  case Interpreter::zerolocals             :                                          break;\n-  case Interpreter::zerolocals_synchronized:                synchronized = true;      break;\n-  case Interpreter::native                 : native = true;                           break;\n-  case Interpreter::native_synchronized    : native = true; synchronized = true;      break;\n+  case Interpreter::zerolocals             :                           break;\n+  case Interpreter::zerolocals_synchronized: synchronized = true;      break;\n+  case Interpreter::native                 :                           break;\n+  case Interpreter::native_synchronized    : synchronized = true;      break;\n@@ -420,0 +428,1 @@\n+  case Interpreter::java_lang_math_sqrt_strict: \/\/ fall thru\n@@ -423,30 +432,8 @@\n-  case Interpreter::java_lang_math_fmaF    : entry_point = generate_math_entry(kind);      break;\n-  case Interpreter::java_lang_ref_reference_get\n-                                           : entry_point = generate_Reference_get_entry(); break;\n-  case Interpreter::java_util_zip_CRC32_update\n-                                           : native = true; entry_point = generate_CRC32_update_entry();  break;\n-  case Interpreter::java_util_zip_CRC32_updateBytes\n-                                           : \/\/ fall thru\n-  case Interpreter::java_util_zip_CRC32_updateByteBuffer\n-                                           : native = true; entry_point = generate_CRC32_updateBytes_entry(kind); break;\n-  case Interpreter::java_util_zip_CRC32C_updateBytes\n-                                           : \/\/ fall thru\n-  case Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer\n-                                           : entry_point = generate_CRC32C_updateBytes_entry(kind); break;\n-#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n-  case Interpreter::java_lang_Thread_currentThread\n-                                           : entry_point = generate_currentThread(); break;\n-#endif\n-\n-#ifdef IA32\n-  \/\/ On x86_32 platforms, a special entry is generated for the following four methods.\n-  \/\/ On other platforms the normal entry is used to enter these methods.\n-  case Interpreter::java_lang_Float_intBitsToFloat\n-                                           : native = true; entry_point = generate_Float_intBitsToFloat_entry(); break;\n-  case Interpreter::java_lang_Float_floatToRawIntBits\n-                                           : native = true; entry_point = generate_Float_floatToRawIntBits_entry(); break;\n-  case Interpreter::java_lang_Double_longBitsToDouble\n-                                           : native = true; entry_point = generate_Double_longBitsToDouble_entry(); break;\n-  case Interpreter::java_lang_Double_doubleToRawLongBits\n-                                           : native = true; entry_point = generate_Double_doubleToRawLongBits_entry(); break;\n-#else\n+  case Interpreter::java_lang_math_fmaF    :\n+  case Interpreter::java_lang_ref_reference_get:\n+  case Interpreter::java_util_zip_CRC32_update:\n+  case Interpreter::java_util_zip_CRC32_updateBytes:\n+  case Interpreter::java_util_zip_CRC32_updateByteBuffer:\n+  case Interpreter::java_util_zip_CRC32C_updateBytes:\n+  case Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer:\n+  case Interpreter::java_lang_Thread_currentThread:\n@@ -457,1 +444,1 @@\n-    native = true;\n+    entry_point = generate_intrinsic_entry(kind);\n@@ -459,1 +446,0 @@\n-#endif \/\/ !IA32\n@@ -484,0 +470,55 @@\n+\n+\/\/ Generate intrinsic method entries\n+address TemplateInterpreterGenerator::generate_intrinsic_entry(AbstractInterpreter::MethodKind kind) {\n+  if (!InlineIntrinsics || !vmIntrinsics::is_intrinsic_available(AbstractInterpreter::method_intrinsic(kind))) {\n+    return nullptr;\n+  }\n+\n+  address entry_point = nullptr;\n+\n+  switch (kind) {\n+  case Interpreter::java_lang_math_sin     : \/\/ fall thru\n+  case Interpreter::java_lang_math_cos     : \/\/ fall thru\n+  case Interpreter::java_lang_math_tan     : \/\/ fall thru\n+  case Interpreter::java_lang_math_abs     : \/\/ fall thru\n+  case Interpreter::java_lang_math_log     : \/\/ fall thru\n+  case Interpreter::java_lang_math_log10   : \/\/ fall thru\n+  case Interpreter::java_lang_math_sqrt    : \/\/ fall thru\n+  case Interpreter::java_lang_math_pow     : \/\/ fall thru\n+  case Interpreter::java_lang_math_exp     : \/\/ fall thru\n+  case Interpreter::java_lang_math_fmaD    : \/\/ fall thru\n+  case Interpreter::java_lang_math_fmaF    : entry_point = generate_math_entry(kind);      break;\n+  case Interpreter::java_lang_math_sqrt_strict\n+                                           : entry_point = generate_math_entry(Interpreter::java_lang_math_sqrt); break;\n+  case Interpreter::java_lang_ref_reference_get\n+                                           : entry_point = generate_Reference_get_entry(); break;\n+  case Interpreter::java_util_zip_CRC32_update\n+                                           : entry_point = generate_CRC32_update_entry();  break;\n+  case Interpreter::java_util_zip_CRC32_updateBytes\n+                                           : \/\/ fall thru\n+  case Interpreter::java_util_zip_CRC32_updateByteBuffer\n+                                           : entry_point = generate_CRC32_updateBytes_entry(kind); break;\n+  case Interpreter::java_util_zip_CRC32C_updateBytes\n+                                           : \/\/ fall thru\n+  case Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer\n+                                           : entry_point = generate_CRC32C_updateBytes_entry(kind); break;\n+  case Interpreter::java_lang_Thread_currentThread\n+                                           : entry_point = generate_currentThread(); break;\n+\n+  \/\/ On x86_32 platforms, a special entry is generated for the following four methods.\n+  \/\/ On other platforms the native entry is used to enter these methods.\n+  case Interpreter::java_lang_Float_intBitsToFloat\n+                                           : entry_point = generate_Float_intBitsToFloat_entry(); break;\n+  case Interpreter::java_lang_Float_floatToRawIntBits\n+                                           : entry_point = generate_Float_floatToRawIntBits_entry(); break;\n+  case Interpreter::java_lang_Double_longBitsToDouble\n+                                           : entry_point = generate_Double_longBitsToDouble_entry(); break;\n+  case Interpreter::java_lang_Double_doubleToRawLongBits\n+                                           : entry_point = generate_Double_doubleToRawLongBits_entry(); break;\n+  default:\n+    fatal(\"unexpected intrinsic method kind: %d\", kind);\n+    break;\n+  }\n+  return entry_point;\n+}\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":99,"deletions":58,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -87,1 +87,4 @@\n-  address generate_method_entry(AbstractInterpreter::MethodKind kind);\n+  address generate_method_entry(AbstractInterpreter::MethodKind kind, bool native);\n+\n+  \/\/ generate intrinsic method entries\n+  address generate_intrinsic_entry(AbstractInterpreter::MethodKind kind);\n@@ -97,1 +100,0 @@\n-#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n@@ -99,2 +101,0 @@\n-#endif\n-#ifdef IA32\n@@ -105,1 +105,1 @@\n-#endif \/\/ IA32\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-    Interpreter::_native_entry_begin = Interpreter::code()->code_end();\n@@ -72,1 +71,0 @@\n-    Interpreter::_native_entry_end = Interpreter::code()->code_end();\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,8 +183,1 @@\n-bool C2Compiler::is_intrinsic_supported(const methodHandle& method, bool is_virtual) {\n-  vmIntrinsics::ID id = method->intrinsic_id();\n-  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n-\n-  if (id < vmIntrinsics::FIRST_ID || id > vmIntrinsics::LAST_COMPILER_INLINE) {\n-    return false;\n-  }\n-\n+bool C2Compiler::is_virtual_intrinsic_supported(vmIntrinsics::ID id, bool is_virtual) {\n@@ -204,0 +197,10 @@\n+  return true;\n+}\n+\n+bool C2Compiler::is_intrinsic_supported(const methodHandle& method) {\n+  vmIntrinsics::ID id = method->intrinsic_id();\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+\n+  if (id < vmIntrinsics::FIRST_ID || id > vmIntrinsics::LAST_COMPILER_INLINE) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -64,3 +64,1 @@\n-  virtual bool is_intrinsic_supported(const methodHandle& method) {\n-    return is_intrinsic_supported(method, false);\n-  }\n+  virtual bool is_intrinsic_supported(const methodHandle& method);\n@@ -70,1 +68,1 @@\n-  bool is_intrinsic_supported(const methodHandle& method, bool is_virtual);\n+  bool is_virtual_intrinsic_supported(vmIntrinsics::ID id, bool is_virtual);\n","filename":"src\/hotspot\/share\/opto\/c2compiler.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,4 +80,2 @@\n-    is_available = compiler != NULL && compiler->is_intrinsic_supported(mh, is_virtual) &&\n-                   !C->directive()->is_intrinsic_disabled(mh) &&\n-                   !vmIntrinsics::is_disabled_by_flags(mh);\n-\n+    is_available = compiler != NULL && compiler->is_intrinsic_available(mh, C->directive()) &&\n+                   compiler->is_virtual_intrinsic_supported(id, is_virtual);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+enum class vmIntrinsicID;\n@@ -181,0 +182,3 @@\n+  \/\/ Does this CPU support this intrinsic?\n+  static bool is_intrinsic_supported(vmIntrinsicID id) { return true; }\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1197,1 +1197,1 @@\n-          \"Inline intrinsics that can be statically resolved\")              \\\n+          \"Use intrinsics in Interpreter that can be statically resolved\")  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,2 +86,3 @@\n-            expectStableFloats = (sse >= 1);\n-            expectStableDoubles = (sse >= 2);\n+            boolean stubsPresent = WHITE_BOX.getBooleanVMFlag(\"InlineIntrinsics\");\n+            expectStableFloats = (sse >= 1) && stubsPresent;\n+            expectStableDoubles = (sse >= 2) && stubsPresent;\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/NaNTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}