{"files":[{"patch":"@@ -302,6 +302,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n-    return nullptr;\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n@@ -324,6 +319,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n-    return nullptr;\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n@@ -964,2 +954,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -967,3 +957,3 @@\n-    \/\/ rmethod: Method*\n-    \/\/ r19_sender_sp: senderSP must preserved for slow path\n-    \/\/ esp: args\n+  \/\/ rmethod: Method*\n+  \/\/ r19_sender_sp: senderSP must preserved for slow path\n+  \/\/ esp: args\n@@ -971,3 +961,3 @@\n-    Label slow_path;\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  Label slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n@@ -975,2 +965,2 @@\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n@@ -978,4 +968,4 @@\n-    \/\/ Load parameters\n-    const Register crc = c_rarg0;  \/\/ crc\n-    const Register val = c_rarg1;  \/\/ source java byte value\n-    const Register tbl = c_rarg2;  \/\/ scratch\n+  \/\/ Load parameters\n+  const Register crc = c_rarg0;  \/\/ crc\n+  const Register val = c_rarg1;  \/\/ source java byte value\n+  const Register tbl = c_rarg2;  \/\/ scratch\n@@ -983,3 +973,3 @@\n-    \/\/ Arguments are reversed on java expression stack\n-    __ ldrw(val, Address(esp, 0));              \/\/ byte value\n-    __ ldrw(crc, Address(esp, wordSize));       \/\/ Initial CRC\n+  \/\/ Arguments are reversed on java expression stack\n+  __ ldrw(val, Address(esp, 0));              \/\/ byte value\n+  __ ldrw(crc, Address(esp, wordSize));       \/\/ Initial CRC\n@@ -987,3 +977,3 @@\n-    uint64_t offset;\n-    __ adrp(tbl, ExternalAddress(StubRoutines::crc_table_addr()), offset);\n-    __ add(tbl, tbl, offset);\n+  uint64_t offset;\n+  __ adrp(tbl, ExternalAddress(StubRoutines::crc_table_addr()), offset);\n+  __ add(tbl, tbl, offset);\n@@ -991,3 +981,3 @@\n-    __ mvnw(crc, crc); \/\/ ~crc\n-    __ update_byte_crc32(crc, val, tbl);\n-    __ mvnw(crc, crc); \/\/ ~crc\n+  __ mvnw(crc, crc); \/\/ ~crc\n+  __ update_byte_crc32(crc, val, tbl);\n+  __ mvnw(crc, crc); \/\/ ~crc\n@@ -995,1 +985,1 @@\n-    \/\/ result in c_rarg0\n+  \/\/ result in c_rarg0\n@@ -997,2 +987,2 @@\n-    __ andr(sp, r19_sender_sp, -16);\n-    __ ret(lr);\n+  __ andr(sp, r19_sender_sp, -16);\n+  __ ret(lr);\n@@ -1000,6 +990,4 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -1014,2 +1002,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -1017,32 +1005,2 @@\n-    \/\/ rmethod,: Method*\n-    \/\/ r19_sender_sp: senderSP must preserved for slow path\n-\n-    Label slow_path;\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = c_rarg0;  \/\/ crc\n-    const Register buf = c_rarg1;  \/\/ source java byte array address\n-    const Register len = c_rarg2;  \/\/ length\n-    const Register off = len;      \/\/ offset (never overlaps with 'len')\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n-      __ ldr(buf, Address(esp, 2*wordSize)); \/\/ long buf\n-      __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n-      __ add(buf, buf, off); \/\/ + offset\n-      __ ldrw(crc,   Address(esp, 4*wordSize)); \/\/ Initial CRC\n-    } else {\n-      __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] array\n-      __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n-      __ add(buf, buf, off); \/\/ + offset\n-      __ ldrw(crc,   Address(esp, 3*wordSize)); \/\/ Initial CRC\n-    }\n-    \/\/ Can now load 'len' since we're finished with 'off'\n-    __ ldrw(len, Address(esp, 0x0)); \/\/ Length\n+  \/\/ rmethod,: Method*\n+  \/\/ r19_sender_sp: senderSP must preserved for slow path\n@@ -1050,1 +1008,29 @@\n-    __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n+  Label slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = c_rarg0;  \/\/ crc\n+  const Register buf = c_rarg1;  \/\/ source java byte array address\n+  const Register len = c_rarg2;  \/\/ length\n+  const Register off = len;      \/\/ offset (never overlaps with 'len')\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n+    __ ldr(buf, Address(esp, 2*wordSize)); \/\/ long buf\n+    __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n+    __ add(buf, buf, off); \/\/ + offset\n+    __ ldrw(crc,   Address(esp, 4*wordSize)); \/\/ Initial CRC\n+  } else {\n+    __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] array\n+    __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n+    __ add(buf, buf, off); \/\/ + offset\n+    __ ldrw(crc,   Address(esp, 3*wordSize)); \/\/ Initial CRC\n+  }\n+  \/\/ Can now load 'len' since we're finished with 'off'\n+  __ ldrw(len, Address(esp, 0x0)); \/\/ Length\n@@ -1052,2 +1038,1 @@\n-    \/\/ We are frameless so we can just jump to the stub.\n-    __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()));\n+  __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n@@ -1055,6 +1040,7 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ We are frameless so we can just jump to the stub.\n+  __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()));\n+\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -1071,10 +1057,2 @@\n-  if (UseCRC32CIntrinsics) {\n-    address entry = __ pc();\n-\n-    \/\/ Prepare jump to stub using parameters from the stack\n-    const Register crc = c_rarg0; \/\/ initial crc\n-    const Register buf = c_rarg1; \/\/ source java byte array address\n-    const Register len = c_rarg2; \/\/ len argument to the kernel\n-\n-    const Register end = len; \/\/ index of last element to process\n-    const Register off = crc; \/\/ offset\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -1082,11 +1060,19 @@\n-    __ ldrw(end, Address(esp)); \/\/ int end\n-    __ ldrw(off, Address(esp, wordSize)); \/\/ int offset\n-    __ sub(len, end, off);\n-    __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] buf | long buf\n-    __ add(buf, buf, off); \/\/ + offset\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n-      __ ldrw(crc, Address(esp, 4*wordSize)); \/\/ long crc\n-    } else {\n-      __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ ldrw(crc, Address(esp, 3*wordSize)); \/\/ long crc\n-    }\n+  \/\/ Prepare jump to stub using parameters from the stack\n+  const Register crc = c_rarg0; \/\/ initial crc\n+  const Register buf = c_rarg1; \/\/ source java byte array address\n+  const Register len = c_rarg2; \/\/ len argument to the kernel\n+\n+  const Register end = len; \/\/ index of last element to process\n+  const Register off = crc; \/\/ offset\n+\n+  __ ldrw(end, Address(esp)); \/\/ int end\n+  __ ldrw(off, Address(esp, wordSize)); \/\/ int offset\n+  __ sub(len, end, off);\n+  __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] buf | long buf\n+  __ add(buf, buf, off); \/\/ + offset\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n+    __ ldrw(crc, Address(esp, 4*wordSize)); \/\/ long crc\n+  } else {\n+    __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ ldrw(crc, Address(esp, 3*wordSize)); \/\/ long crc\n+  }\n@@ -1094,1 +1080,1 @@\n-    __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n+  __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n@@ -1096,2 +1082,2 @@\n-    \/\/ Jump to the stub.\n-    __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()));\n+  \/\/ Jump to the stub.\n+  __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()));\n@@ -1099,3 +1085,1 @@\n-    return entry;\n-  }\n-  return NULL;\n+  return entry;\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":98,"deletions":114,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -1749,3 +1749,3 @@\n-  if (UseCRC32Intrinsics) {\n-    address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n-    Label slow_path;\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n+  Label slow_path;\n@@ -1753,3 +1753,3 @@\n-    \/\/ Safepoint check\n-    const Register sync_state = R11_scratch1;\n-    __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n+  \/\/ Safepoint check\n+  const Register sync_state = R11_scratch1;\n+  __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1757,3 +1757,3 @@\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we not even call stub code (we generate the code inline)\n-    \/\/ and there is no safepoint on this path.\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we not even call stub code (we generate the code inline)\n+  \/\/ and there is no safepoint on this path.\n@@ -1761,6 +1761,6 @@\n-    \/\/ Load java parameters.\n-    \/\/ R15_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = R15_esp;\n-    const Register crc     = R3_ARG1;  \/\/ crc value\n-    const Register data    = R4_ARG2;\n-    const Register table   = R5_ARG3;  \/\/ address of crc32 table\n+  \/\/ Load java parameters.\n+  \/\/ R15_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = R15_esp;\n+  const Register crc     = R3_ARG1;  \/\/ crc value\n+  const Register data    = R4_ARG2;\n+  const Register table   = R5_ARG3;  \/\/ address of crc32 table\n@@ -1768,1 +1768,1 @@\n-    BLOCK_COMMENT(\"CRC32_update {\");\n+  BLOCK_COMMENT(\"CRC32_update {\");\n@@ -1770,1 +1770,1 @@\n-    \/\/ Arguments are reversed on java expression stack\n+  \/\/ Arguments are reversed on java expression stack\n@@ -1772,2 +1772,2 @@\n-    int data_offs = 0+1*wordSize;      \/\/ (stack) address of byte value. Emitter expects address, not value.\n-                                       \/\/ Being passed as an int, the single byte is at offset +0.\n+  int data_offs = 0+1*wordSize;      \/\/ (stack) address of byte value. Emitter expects address, not value.\n+                                     \/\/ Being passed as an int, the single byte is at offset +0.\n@@ -1775,2 +1775,2 @@\n-    int data_offs = 3+1*wordSize;      \/\/ (stack) address of byte value. Emitter expects address, not value.\n-                                       \/\/ Being passed from java as an int, the single byte is at offset +3.\n+  int data_offs = 3+1*wordSize;      \/\/ (stack) address of byte value. Emitter expects address, not value.\n+                                     \/\/ Being passed from java as an int, the single byte is at offset +3.\n@@ -1778,15 +1778,8 @@\n-    __ lwz(crc, 2*wordSize, argP);     \/\/ Current crc state, zero extend to 64 bit to have a clean register.\n-    __ lbz(data, data_offs, argP);     \/\/ Byte from buffer, zero-extended.\n-    __ load_const_optimized(table, StubRoutines::crc_table_addr(), R0);\n-    __ kernel_crc32_singleByteReg(crc, data, table, true);\n-\n-    \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n-    __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n-    __ blr();\n-\n-    \/\/ Generate a vanilla native entry as the slow path.\n-    BLOCK_COMMENT(\"} CRC32_update\");\n-    BIND(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), R11_scratch1);\n-    return start;\n-  }\n+  __ lwz(crc, 2*wordSize, argP);     \/\/ Current crc state, zero extend to 64 bit to have a clean register.\n+  __ lbz(data, data_offs, argP);     \/\/ Byte from buffer, zero-extended.\n+  __ load_const_optimized(table, StubRoutines::crc_table_addr(), R0);\n+  __ kernel_crc32_singleByteReg(crc, data, table, true);\n+\n+  \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n+  __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n+  __ blr();\n@@ -1794,1 +1787,5 @@\n-  return NULL;\n+  \/\/ Generate a vanilla native entry as the slow path.\n+  BLOCK_COMMENT(\"} CRC32_update\");\n+  BIND(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), R11_scratch1);\n+  return start;\n@@ -1803,48 +1800,3 @@\n-  if (UseCRC32Intrinsics) {\n-    address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n-    Label slow_path;\n-\n-    \/\/ Safepoint check\n-    const Register sync_state = R11_scratch1;\n-    __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we not even call stub code (we generate the code inline)\n-    \/\/ and there is no safepoint on this path.\n-\n-    \/\/ Load parameters.\n-    \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = R15_esp;\n-    const Register crc     = R3_ARG1;  \/\/ crc value\n-    const Register data    = R4_ARG2;  \/\/ address of java byte array\n-    const Register dataLen = R5_ARG3;  \/\/ source data len\n-    const Register tmp     = R11_scratch1;\n-\n-    \/\/ Arguments are reversed on java expression stack.\n-    \/\/ Calculate address of start element.\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n-      BLOCK_COMMENT(\"CRC32_updateByteBuffer {\");\n-      \/\/ crc     @ (SP + 5W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off\n-      __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n-      __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n-      __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-      __ lwz( crc,     5*wordSize, argP);  \/\/ current crc state\n-      __ add( data, data, tmp);            \/\/ Add byte buffer offset.\n-    } else {                                                         \/\/ Used for \"updateBytes update\".\n-      BLOCK_COMMENT(\"CRC32_updateBytes {\");\n-      \/\/ crc     @ (SP + 4W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off + base_offset\n-      __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n-      __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n-      __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-      __ add( data, data, tmp);            \/\/ add byte buffer offset\n-      __ lwz( crc,     4*wordSize, argP);  \/\/ current crc state\n-      __ addi(data, data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n-    }\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n+  Label slow_path;\n@@ -1852,1 +1804,44 @@\n-    __ crc32(crc, data, dataLen, R2, R6, R7, R8, R9, R10, R11, R12, false);\n+  \/\/ Safepoint check\n+  const Register sync_state = R11_scratch1;\n+  __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we not even call stub code (we generate the code inline)\n+  \/\/ and there is no safepoint on this path.\n+\n+  \/\/ Load parameters.\n+  \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = R15_esp;\n+  const Register crc     = R3_ARG1;  \/\/ crc value\n+  const Register data    = R4_ARG2;  \/\/ address of java byte array\n+  const Register dataLen = R5_ARG3;  \/\/ source data len\n+  const Register tmp     = R11_scratch1;\n+\n+  \/\/ Arguments are reversed on java expression stack.\n+  \/\/ Calculate address of start element.\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n+    BLOCK_COMMENT(\"CRC32_updateByteBuffer {\");\n+    \/\/ crc     @ (SP + 5W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off\n+    __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n+    __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n+    __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+    __ lwz( crc,     5*wordSize, argP);  \/\/ current crc state\n+    __ add( data, data, tmp);            \/\/ Add byte buffer offset.\n+  } else {                                                         \/\/ Used for \"updateBytes update\".\n+    BLOCK_COMMENT(\"CRC32_updateBytes {\");\n+    \/\/ crc     @ (SP + 4W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off + base_offset\n+    __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n+    __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n+    __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+    __ add( data, data, tmp);            \/\/ add byte buffer offset\n+    __ lwz( crc,     4*wordSize, argP);  \/\/ current crc state\n+    __ addi(data, data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  }\n@@ -1854,3 +1849,1 @@\n-    \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n-    __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n-    __ blr();\n+  __ crc32(crc, data, dataLen, R2, R6, R7, R8, R9, R10, R11, R12, false);\n@@ -1858,6 +1851,3 @@\n-    \/\/ Generate a vanilla native entry as the slow path.\n-    BLOCK_COMMENT(\"} CRC32_updateBytes(Buffer)\");\n-    BIND(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), R11_scratch1);\n-    return start;\n-  }\n+  \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n+  __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n+  __ blr();\n@@ -1865,1 +1855,5 @@\n-  return NULL;\n+  \/\/ Generate a vanilla native entry as the slow path.\n+  BLOCK_COMMENT(\"} CRC32_updateBytes(Buffer)\");\n+  BIND(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), R11_scratch1);\n+  return start;\n@@ -1877,47 +1871,45 @@\n-  if (UseCRC32CIntrinsics) {\n-    address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we not even call stub code (we generate the code inline)\n-    \/\/ and there is no safepoint on this path.\n-\n-    \/\/ Load parameters.\n-    \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = R15_esp;\n-    const Register crc     = R3_ARG1;  \/\/ crc value\n-    const Register data    = R4_ARG2;  \/\/ address of java byte array\n-    const Register dataLen = R5_ARG3;  \/\/ source data len\n-    const Register tmp     = R11_scratch1;\n-\n-    \/\/ Arguments are reversed on java expression stack.\n-    \/\/ Calculate address of start element.\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) { \/\/ Used for \"updateDirectByteBuffer\".\n-      BLOCK_COMMENT(\"CRC32C_updateDirectByteBuffer {\");\n-      \/\/ crc     @ (SP + 5W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off\n-      __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n-      __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n-      __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-      __ lwz( crc,     5*wordSize, argP);  \/\/ current crc state\n-      __ add( data, data, tmp);            \/\/ Add byte buffer offset.\n-      __ sub( dataLen, dataLen, tmp);      \/\/ (end_index - offset)\n-    } else {                                                         \/\/ Used for \"updateBytes update\".\n-      BLOCK_COMMENT(\"CRC32C_updateBytes {\");\n-      \/\/ crc     @ (SP + 4W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off + base_offset\n-      __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n-      __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n-      __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-      __ add( data, data, tmp);            \/\/ add byte buffer offset\n-      __ sub( dataLen, dataLen, tmp);      \/\/ (end_index - offset)\n-      __ lwz( crc,     4*wordSize, argP);  \/\/ current crc state\n-      __ addi(data, data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n-    }\n-\n-    __ crc32(crc, data, dataLen, R2, R6, R7, R8, R9, R10, R11, R12, true);\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we not even call stub code (we generate the code inline)\n+  \/\/ and there is no safepoint on this path.\n+\n+  \/\/ Load parameters.\n+  \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = R15_esp;\n+  const Register crc     = R3_ARG1;  \/\/ crc value\n+  const Register data    = R4_ARG2;  \/\/ address of java byte array\n+  const Register dataLen = R5_ARG3;  \/\/ source data len\n+  const Register tmp     = R11_scratch1;\n+\n+  \/\/ Arguments are reversed on java expression stack.\n+  \/\/ Calculate address of start element.\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) { \/\/ Used for \"updateDirectByteBuffer\".\n+    BLOCK_COMMENT(\"CRC32C_updateDirectByteBuffer {\");\n+    \/\/ crc     @ (SP + 5W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off\n+    __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n+    __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n+    __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+    __ lwz( crc,     5*wordSize, argP);  \/\/ current crc state\n+    __ add( data, data, tmp);            \/\/ Add byte buffer offset.\n+    __ sub( dataLen, dataLen, tmp);      \/\/ (end_index - offset)\n+  } else {                                                         \/\/ Used for \"updateBytes update\".\n+    BLOCK_COMMENT(\"CRC32C_updateBytes {\");\n+    \/\/ crc     @ (SP + 4W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off + base_offset\n+    __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n+    __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n+    __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+    __ add( data, data, tmp);            \/\/ add byte buffer offset\n+    __ sub( dataLen, dataLen, tmp);      \/\/ (end_index - offset)\n+    __ lwz( crc,     4*wordSize, argP);  \/\/ current crc state\n+    __ addi(data, data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  }\n@@ -1925,3 +1917,1 @@\n-    \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n-    __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n-    __ blr();\n+  __ crc32(crc, data, dataLen, R2, R6, R7, R8, R9, R10, R11, R12, true);\n@@ -1929,3 +1919,3 @@\n-    BLOCK_COMMENT(\"} CRC32C_update{Bytes|DirectByteBuffer}\");\n-    return start;\n-  }\n+  \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n+  __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n+  __ blr();\n@@ -1933,1 +1923,2 @@\n-  return NULL;\n+  BLOCK_COMMENT(\"} CRC32C_update{Bytes|DirectByteBuffer}\");\n+  return start;\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":141,"deletions":150,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -300,4 +300,0 @@\n-\/\/ Not supported\n-address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() { return nullptr; }\n-address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() { return nullptr; }\n-\n@@ -893,0 +889,2 @@\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() { return nullptr; }\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1804,0 +1804,3 @@\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  uint64_t entry_off = __ offset();\n+  Label    slow_path;\n@@ -1805,3 +1808,2 @@\n-  if (UseCRC32Intrinsics) {\n-    uint64_t entry_off = __ offset();\n-    Label    slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ safepoint_poll(slow_path, Z_R1);\n@@ -1809,2 +1811,1 @@\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ safepoint_poll(slow_path, Z_R1);\n+  BLOCK_COMMENT(\"CRC32_update {\");\n@@ -1812,1 +1813,3 @@\n-    BLOCK_COMMENT(\"CRC32_update {\");\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we not even call stub code (we generate the code inline)\n+  \/\/ and there is no safepoint on this path.\n@@ -1814,14 +1817,10 @@\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we not even call stub code (we generate the code inline)\n-    \/\/ and there is no safepoint on this path.\n-\n-    \/\/ Load java parameters.\n-    \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = Z_esp;\n-    const Register crc     = Z_ARG1;  \/\/ crc value\n-    const Register data    = Z_ARG2;  \/\/ address of java byte value (kernel_crc32 needs address)\n-    const Register dataLen = Z_ARG3;  \/\/ source data len (1 byte). Not used because calling the single-byte emitter.\n-    const Register table   = Z_ARG4;  \/\/ address of crc32 table\n-\n-    \/\/ Arguments are reversed on java expression stack.\n-    __ z_la(data, 3+1*wordSize, argP);  \/\/ byte value (stack address).\n+  \/\/ Load java parameters.\n+  \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = Z_esp;\n+  const Register crc     = Z_ARG1;  \/\/ crc value\n+  const Register data    = Z_ARG2;  \/\/ address of java byte value (kernel_crc32 needs address)\n+  const Register dataLen = Z_ARG3;  \/\/ source data len (1 byte). Not used because calling the single-byte emitter.\n+  const Register table   = Z_ARG4;  \/\/ address of crc32 table\n+\n+  \/\/ Arguments are reversed on java expression stack.\n+  __ z_la(data, 3+1*wordSize, argP);  \/\/ byte value (stack address).\n@@ -1829,1 +1828,1 @@\n-    __ z_llgf(crc, 2 * wordSize, argP); \/\/ Current crc state, zero extend to 64 bit to have a clean register.\n+  __ z_llgf(crc, 2 * wordSize, argP); \/\/ Current crc state, zero extend to 64 bit to have a clean register.\n@@ -1831,2 +1830,2 @@\n-    StubRoutines::zarch::generate_load_crc_table_addr(_masm, table);\n-    __ kernel_crc32_singleByte(crc, data, dataLen, table, Z_R1, true);\n+  StubRoutines::zarch::generate_load_crc_table_addr(_masm, table);\n+  __ kernel_crc32_singleByte(crc, data, dataLen, table, Z_R1, true);\n@@ -1834,4 +1833,2 @@\n-    \/\/ Restore caller sp for c2i case.\n-    __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n-\n-    __ z_br(Z_R14);\n+  \/\/ Restore caller sp for c2i case.\n+  __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n@@ -1839,1 +1836,1 @@\n-    BLOCK_COMMENT(\"} CRC32_update\");\n+  __ z_br(Z_R14);\n@@ -1841,5 +1838,1 @@\n-    \/\/ Use a previously generated vanilla native entry as the slow path.\n-    BIND(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), Z_R1);\n-    return __ addr_at(entry_off);\n-  }\n+  BLOCK_COMMENT(\"} CRC32_update\");\n@@ -1847,1 +1840,4 @@\n-  return NULL;\n+  \/\/ Use a previously generated vanilla native entry as the slow path.\n+  BIND(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), Z_R1);\n+  return __ addr_at(entry_off);\n@@ -1857,0 +1853,3 @@\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  uint64_t entry_off = __ offset();\n+  Label    slow_path;\n@@ -1858,48 +1857,2 @@\n-  if (UseCRC32Intrinsics) {\n-    uint64_t entry_off = __ offset();\n-    Label    slow_path;\n-\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ safepoint_poll(slow_path, Z_R1);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters.\n-    \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = Z_esp;\n-    const Register crc     = Z_ARG1;  \/\/ crc value\n-    const Register data    = Z_ARG2;  \/\/ address of java byte array\n-    const Register dataLen = Z_ARG3;  \/\/ source data len\n-    const Register table   = Z_ARG4;  \/\/ address of crc32 table\n-    const Register t0      = Z_R10;   \/\/ work reg for kernel* emitters\n-    const Register t1      = Z_R11;   \/\/ work reg for kernel* emitters\n-    const Register t2      = Z_R12;   \/\/ work reg for kernel* emitters\n-    const Register t3      = Z_R13;   \/\/ work reg for kernel* emitters\n-\n-    \/\/ Arguments are reversed on java expression stack.\n-    \/\/ Calculate address of start element.\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n-      \/\/ crc     @ (SP + 5W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off\n-      BLOCK_COMMENT(\"CRC32_updateByteBuffer {\");\n-      __ z_llgf(crc,    5*wordSize, argP);  \/\/ current crc state\n-      __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n-      __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n-      __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-    } else {                                                         \/\/ Used for \"updateBytes update\".\n-      \/\/ crc     @ (SP + 4W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off + base_offset\n-      BLOCK_COMMENT(\"CRC32_updateBytes {\");\n-      __ z_llgf(crc,    4*wordSize, argP);  \/\/ current crc state\n-      __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n-      __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n-      __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-      __ z_aghi(data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n-    }\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ safepoint_poll(slow_path, Z_R1);\n@@ -1907,1 +1860,2 @@\n-    StubRoutines::zarch::generate_load_crc_table_addr(_masm, table);\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n@@ -1909,4 +1863,38 @@\n-    __ resize_frame(-(6*8), Z_R0, true); \/\/ Resize frame to provide add'l space to spill 5 registers.\n-    __ z_stmg(t0, t3, 1*8, Z_SP);        \/\/ Spill regs 10..13 to make them available as work registers.\n-    __ kernel_crc32_1word(crc, data, dataLen, table, t0, t1, t2, t3, true);\n-    __ z_lmg(t0, t3, 1*8, Z_SP);         \/\/ Spill regs 10..13 back from stack.\n+  \/\/ Load parameters.\n+  \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = Z_esp;\n+  const Register crc     = Z_ARG1;  \/\/ crc value\n+  const Register data    = Z_ARG2;  \/\/ address of java byte array\n+  const Register dataLen = Z_ARG3;  \/\/ source data len\n+  const Register table   = Z_ARG4;  \/\/ address of crc32 table\n+  const Register t0      = Z_R10;   \/\/ work reg for kernel* emitters\n+  const Register t1      = Z_R11;   \/\/ work reg for kernel* emitters\n+  const Register t2      = Z_R12;   \/\/ work reg for kernel* emitters\n+  const Register t3      = Z_R13;   \/\/ work reg for kernel* emitters\n+\n+  \/\/ Arguments are reversed on java expression stack.\n+  \/\/ Calculate address of start element.\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n+    \/\/ crc     @ (SP + 5W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off\n+    BLOCK_COMMENT(\"CRC32_updateByteBuffer {\");\n+    __ z_llgf(crc,    5*wordSize, argP);  \/\/ current crc state\n+    __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n+    __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n+    __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+  } else {                                                         \/\/ Used for \"updateBytes update\".\n+    \/\/ crc     @ (SP + 4W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off + base_offset\n+    BLOCK_COMMENT(\"CRC32_updateBytes {\");\n+    __ z_llgf(crc,    4*wordSize, argP);  \/\/ current crc state\n+    __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n+    __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n+    __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+    __ z_aghi(data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  }\n@@ -1914,2 +1902,1 @@\n-    \/\/ Restore caller sp for c2i case.\n-    __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n+  StubRoutines::zarch::generate_load_crc_table_addr(_masm, table);\n@@ -1917,1 +1904,4 @@\n-    __ z_br(Z_R14);\n+  __ resize_frame(-(6*8), Z_R0, true); \/\/ Resize frame to provide add'l space to spill 5 registers.\n+  __ z_stmg(t0, t3, 1*8, Z_SP);        \/\/ Spill regs 10..13 to make them available as work registers.\n+  __ kernel_crc32_1word(crc, data, dataLen, table, t0, t1, t2, t3, true);\n+  __ z_lmg(t0, t3, 1*8, Z_SP);         \/\/ Spill regs 10..13 back from stack.\n@@ -1919,1 +1909,2 @@\n-    BLOCK_COMMENT(\"} CRC32_update{Bytes|ByteBuffer}\");\n+  \/\/ Restore caller sp for c2i case.\n+  __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n@@ -1921,5 +1912,1 @@\n-    \/\/ Use a previously generated vanilla native entry as the slow path.\n-    BIND(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), Z_R1);\n-    return __ addr_at(entry_off);\n-  }\n+  __ z_br(Z_R14);\n@@ -1927,1 +1914,6 @@\n-  return NULL;\n+  BLOCK_COMMENT(\"} CRC32_update{Bytes|ByteBuffer}\");\n+\n+  \/\/ Use a previously generated vanilla native entry as the slow path.\n+  BIND(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), Z_R1);\n+  return __ addr_at(entry_off);\n@@ -1939,0 +1931,2 @@\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  uint64_t entry_off = __ offset();\n@@ -1940,46 +1934,2 @@\n-  if (UseCRC32CIntrinsics) {\n-    uint64_t entry_off = __ offset();\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters.\n-    \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = Z_esp;\n-    const Register crc     = Z_ARG1;  \/\/ crc value\n-    const Register data    = Z_ARG2;  \/\/ address of java byte array\n-    const Register dataLen = Z_ARG3;  \/\/ source data len\n-    const Register table   = Z_ARG4;  \/\/ address of crc32 table\n-    const Register t0      = Z_R10;   \/\/ work reg for kernel* emitters\n-    const Register t1      = Z_R11;   \/\/ work reg for kernel* emitters\n-    const Register t2      = Z_R12;   \/\/ work reg for kernel* emitters\n-    const Register t3      = Z_R13;   \/\/ work reg for kernel* emitters\n-\n-    \/\/ Arguments are reversed on java expression stack.\n-    \/\/ Calculate address of start element.\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n-      \/\/ crc     @ (SP + 5W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off\n-      BLOCK_COMMENT(\"CRC32C_updateDirectByteBuffer {\");\n-      __ z_llgf(crc,    5*wordSize, argP);  \/\/ current crc state\n-      __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n-      __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n-      __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process, calculated as\n-      __ z_sgf(dataLen, Address(argP, 2*wordSize));  \/\/ (end_index - offset)\n-    } else {                                                                \/\/ Used for \"updateBytes update\".\n-      \/\/ crc     @ (SP + 4W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off + base_offset\n-      BLOCK_COMMENT(\"CRC32C_updateBytes {\");\n-      __ z_llgf(crc,    4*wordSize, argP);  \/\/ current crc state\n-      __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n-      __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n-      __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process, calculated as\n-      __ z_sgf(dataLen, Address(argP, 2*wordSize));  \/\/ (end_index - offset)\n-      __ z_aghi(data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n-    }\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n@@ -1987,1 +1937,40 @@\n-    StubRoutines::zarch::generate_load_crc32c_table_addr(_masm, table);\n+  \/\/ Load parameters.\n+  \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = Z_esp;\n+  const Register crc     = Z_ARG1;  \/\/ crc value\n+  const Register data    = Z_ARG2;  \/\/ address of java byte array\n+  const Register dataLen = Z_ARG3;  \/\/ source data len\n+  const Register table   = Z_ARG4;  \/\/ address of crc32 table\n+  const Register t0      = Z_R10;   \/\/ work reg for kernel* emitters\n+  const Register t1      = Z_R11;   \/\/ work reg for kernel* emitters\n+  const Register t2      = Z_R12;   \/\/ work reg for kernel* emitters\n+  const Register t3      = Z_R13;   \/\/ work reg for kernel* emitters\n+\n+  \/\/ Arguments are reversed on java expression stack.\n+  \/\/ Calculate address of start element.\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n+    \/\/ crc     @ (SP + 5W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off\n+    BLOCK_COMMENT(\"CRC32C_updateDirectByteBuffer {\");\n+    __ z_llgf(crc,    5*wordSize, argP);  \/\/ current crc state\n+    __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n+    __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n+    __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process, calculated as\n+    __ z_sgf(dataLen, Address(argP, 2*wordSize));  \/\/ (end_index - offset)\n+  } else {                                                                \/\/ Used for \"updateBytes update\".\n+    \/\/ crc     @ (SP + 4W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off + base_offset\n+    BLOCK_COMMENT(\"CRC32C_updateBytes {\");\n+    __ z_llgf(crc,    4*wordSize, argP);  \/\/ current crc state\n+    __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n+    __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n+    __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process, calculated as\n+    __ z_sgf(dataLen, Address(argP, 2*wordSize));  \/\/ (end_index - offset)\n+    __ z_aghi(data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  }\n@@ -1989,4 +1978,1 @@\n-    __ resize_frame(-(6*8), Z_R0, true); \/\/ Resize frame to provide add'l space to spill 5 registers.\n-    __ z_stmg(t0, t3, 1*8, Z_SP);        \/\/ Spill regs 10..13 to make them available as work registers.\n-    __ kernel_crc32_1word(crc, data, dataLen, table, t0, t1, t2, t3, false);\n-    __ z_lmg(t0, t3, 1*8, Z_SP);         \/\/ Spill regs 10..13 back from stack.\n+  StubRoutines::zarch::generate_load_crc32c_table_addr(_masm, table);\n@@ -1994,2 +1980,4 @@\n-    \/\/ Restore caller sp for c2i case.\n-    __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n+  __ resize_frame(-(6*8), Z_R0, true); \/\/ Resize frame to provide add'l space to spill 5 registers.\n+  __ z_stmg(t0, t3, 1*8, Z_SP);        \/\/ Spill regs 10..13 to make them available as work registers.\n+  __ kernel_crc32_1word(crc, data, dataLen, table, t0, t1, t2, t3, false);\n+  __ z_lmg(t0, t3, 1*8, Z_SP);         \/\/ Spill regs 10..13 back from stack.\n@@ -1997,1 +1985,2 @@\n-    __ z_br(Z_R14);\n+  \/\/ Restore caller sp for c2i case.\n+  __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n@@ -1999,3 +1988,1 @@\n-    BLOCK_COMMENT(\"} CRC32C_update{Bytes|DirectByteBuffer}\");\n-    return __ addr_at(entry_off);\n-  }\n+  __ z_br(Z_R14);\n@@ -2003,1 +1990,2 @@\n-  return NULL;\n+  BLOCK_COMMENT(\"} CRC32C_update{Bytes|DirectByteBuffer}\");\n+  return __ addr_at(entry_off);\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":143,"deletions":155,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -59,32 +59,32 @@\n-    \/\/ rbx: Method*\n-    \/\/ rsi: senderSP must preserved for slow path, set SP to it on fast path\n-    \/\/ rdx: scratch\n-    \/\/ rdi: scratch\n-\n-    Label slow_path;\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ get_thread(rdi);\n-    __ safepoint_poll(slow_path, rdi, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = rax;  \/\/ crc\n-    const Register val = rdx;  \/\/ source java byte value\n-    const Register tbl = rdi;  \/\/ scratch\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    __ movl(val, Address(rsp,   wordSize)); \/\/ byte value\n-    __ movl(crc, Address(rsp, 2*wordSize)); \/\/ Initial CRC\n-\n-    __ lea(tbl, ExternalAddress(StubRoutines::crc_table_addr()));\n-    __ notl(crc); \/\/ ~crc\n-    __ update_byte_crc32(crc, val, tbl);\n-    __ notl(crc); \/\/ ~crc\n-    \/\/ result in rax\n-\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, rsi);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n+  \/\/ rbx: Method*\n+  \/\/ rsi: senderSP must preserved for slow path, set SP to it on fast path\n+  \/\/ rdx: scratch\n+  \/\/ rdi: scratch\n+\n+  Label slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ get_thread(rdi);\n+  __ safepoint_poll(slow_path, rdi, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = rax;  \/\/ crc\n+  const Register val = rdx;  \/\/ source java byte value\n+  const Register tbl = rdi;  \/\/ scratch\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  __ movl(val, Address(rsp,   wordSize)); \/\/ byte value\n+  __ movl(crc, Address(rsp, 2*wordSize)); \/\/ Initial CRC\n+\n+  __ lea(tbl, ExternalAddress(StubRoutines::crc_table_addr()));\n+  __ notl(crc); \/\/ ~crc\n+  __ update_byte_crc32(crc, val, tbl);\n+  __ notl(crc); \/\/ ~crc\n+  \/\/ result in rax\n+\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, rsi);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n@@ -92,6 +92,4 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -106,49 +104,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n-\n-    \/\/ rbx,: Method*\n-    \/\/ rsi: senderSP must preserved for slow path, set SP to it on fast path\n-    \/\/ rdx: scratch\n-    \/\/ rdi: scratch\n-\n-    Label slow_path;\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ get_thread(rdi);\n-    __ safepoint_poll(slow_path, rdi, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = rax;  \/\/ crc\n-    const Register buf = rdx;  \/\/ source java byte array address\n-    const Register len = rdi;  \/\/ length\n-\n-    \/\/ value              x86_32\n-    \/\/ interp. arg ptr    ESP + 4\n-    \/\/ int java.util.zip.CRC32.updateBytes(int crc, byte[] b, int off, int len)\n-    \/\/                                         3           2      1        0\n-    \/\/ int java.util.zip.CRC32.updateByteBuffer(int crc, long buf, int off, int len)\n-    \/\/                                              4         2,3      1        0\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    __ movl(len,   Address(rsp,   4 + 0)); \/\/ Length\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n-      __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ long buf\n-      __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n-      __ movl(crc,   Address(rsp, 4 + 4 * wordSize)); \/\/ Initial CRC\n-    } else {\n-      __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ byte[] array\n-      __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n-      __ movl(crc,   Address(rsp, 4 + 3 * wordSize)); \/\/ Initial CRC\n-    }\n-\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()), crc, buf, len);\n-    \/\/ result in rax\n-\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, rsi);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -156,4 +107,37 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n+  \/\/ rbx,: Method*\n+  \/\/ rsi: senderSP must preserved for slow path, set SP to it on fast path\n+  \/\/ rdx: scratch\n+  \/\/ rdi: scratch\n+\n+  Label slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ get_thread(rdi);\n+  __ safepoint_poll(slow_path, rdi, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = rax;  \/\/ crc\n+  const Register buf = rdx;  \/\/ source java byte array address\n+  const Register len = rdi;  \/\/ length\n+\n+  \/\/ value              x86_32\n+  \/\/ interp. arg ptr    ESP + 4\n+  \/\/ int java.util.zip.CRC32.updateBytes(int crc, byte[] b, int off, int len)\n+  \/\/                                         3           2      1        0\n+  \/\/ int java.util.zip.CRC32.updateByteBuffer(int crc, long buf, int off, int len)\n+  \/\/                                              4         2,3      1        0\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  __ movl(len,   Address(rsp,   4 + 0)); \/\/ Length\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n+    __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ long buf\n+    __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n+    __ movl(crc,   Address(rsp, 4 + 4 * wordSize)); \/\/ Initial CRC\n+  } else {\n+    __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ byte[] array\n+    __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n+    __ movl(crc,   Address(rsp, 4 + 3 * wordSize)); \/\/ Initial CRC\n@@ -161,1 +145,13 @@\n-  return NULL;\n+\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()), crc, buf, len);\n+  \/\/ result in rax\n+\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, rsi);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n+\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -170,37 +166,28 @@\n-  if (UseCRC32CIntrinsics) {\n-    address entry = __ pc();\n-    \/\/ Load parameters\n-    const Register crc = rax;  \/\/ crc\n-    const Register buf = rcx;  \/\/ source java byte array address\n-    const Register len = rdx;  \/\/ length\n-    const Register end = len;\n-\n-    \/\/ value              x86_32\n-    \/\/ interp. arg ptr    ESP + 4\n-    \/\/ int java.util.zip.CRC32.updateBytes(int crc, byte[] b, int off, int end)\n-    \/\/                                         3           2      1        0\n-    \/\/ int java.util.zip.CRC32.updateByteBuffer(int crc, long address, int off, int end)\n-    \/\/                                              4         2,3          1        0\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    __ movl(end, Address(rsp, 4 + 0)); \/\/ end\n-    __ subl(len, Address(rsp, 4 + 1 * wordSize));  \/\/ end - offset == length\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n-      __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ long address\n-      __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n-      __ movl(crc, Address(rsp, 4 + 4 * wordSize)); \/\/ Initial CRC\n-    } else {\n-      __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ byte[] array\n-      __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n-      __ movl(crc, Address(rsp, 4 + 3 * wordSize)); \/\/ Initial CRC\n-    }\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()), crc, buf, len);\n-    \/\/ result in rax\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, rsi);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n-\n-    return entry;\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n+  \/\/ Load parameters\n+  const Register crc = rax;  \/\/ crc\n+  const Register buf = rcx;  \/\/ source java byte array address\n+  const Register len = rdx;  \/\/ length\n+  const Register end = len;\n+\n+  \/\/ value              x86_32\n+  \/\/ interp. arg ptr    ESP + 4\n+  \/\/ int java.util.zip.CRC32.updateBytes(int crc, byte[] b, int off, int end)\n+  \/\/                                         3           2      1        0\n+  \/\/ int java.util.zip.CRC32.updateByteBuffer(int crc, long address, int off, int end)\n+  \/\/                                              4         2,3          1        0\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  __ movl(end, Address(rsp, 4 + 0)); \/\/ end\n+  __ subl(len, Address(rsp, 4 + 1 * wordSize));  \/\/ end - offset == length\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n+    __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ long address\n+    __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n+    __ movl(crc, Address(rsp, 4 + 4 * wordSize)); \/\/ Initial CRC\n+  } else {\n+    __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ byte[] array\n+    __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n+    __ movl(crc, Address(rsp, 4 + 3 * wordSize)); \/\/ Initial CRC\n@@ -208,1 +195,8 @@\n-  return NULL;\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()), crc, buf, len);\n+  \/\/ result in rax\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, rsi);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n+\n+  return entry;\n@@ -322,6 +316,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n-    return nullptr; \/\/ Generate a vanilla entry\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n@@ -348,6 +337,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat)) {\n-    return nullptr; \/\/ Generate a vanilla entry\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_32.cpp","additions":128,"deletions":144,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -185,40 +185,38 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n-\n-    \/\/ rbx,: Method*\n-    \/\/ r13: senderSP must preserved for slow path, set SP to it on fast path\n-    \/\/ c_rarg0: scratch (rdi on non-Win64, rcx on Win64)\n-    \/\/ c_rarg1: scratch (rsi on non-Win64, rdx on Win64)\n-\n-    Label slow_path;\n-    __ safepoint_poll(slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = rax;  \/\/ crc\n-    const Register val = c_rarg0;  \/\/ source java byte value\n-    const Register tbl = c_rarg1;  \/\/ scratch\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    __ movl(val, Address(rsp,   wordSize)); \/\/ byte value\n-    __ movl(crc, Address(rsp, 2*wordSize)); \/\/ Initial CRC\n-\n-    __ lea(tbl, ExternalAddress(StubRoutines::crc_table_addr()));\n-    __ notl(crc); \/\/ ~crc\n-    __ update_byte_crc32(crc, val, tbl);\n-    __ notl(crc); \/\/ ~crc\n-    \/\/ result in rax\n-\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, r13);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n-\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n+\n+  \/\/ rbx,: Method*\n+  \/\/ r13: senderSP must preserved for slow path, set SP to it on fast path\n+  \/\/ c_rarg0: scratch (rdi on non-Win64, rcx on Win64)\n+  \/\/ c_rarg1: scratch (rsi on non-Win64, rdx on Win64)\n+\n+  Label slow_path;\n+  __ safepoint_poll(slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = rax;  \/\/ crc\n+  const Register val = c_rarg0;  \/\/ source java byte value\n+  const Register tbl = c_rarg1;  \/\/ scratch\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  __ movl(val, Address(rsp,   wordSize)); \/\/ byte value\n+  __ movl(crc, Address(rsp, 2*wordSize)); \/\/ Initial CRC\n+\n+  __ lea(tbl, ExternalAddress(StubRoutines::crc_table_addr()));\n+  __ notl(crc); \/\/ ~crc\n+  __ update_byte_crc32(crc, val, tbl);\n+  __ notl(crc); \/\/ ~crc\n+  \/\/ result in rax\n+\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, r13);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n+\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -233,34 +231,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n-\n-    \/\/ rbx,: Method*\n-    \/\/ r13: senderSP must preserved for slow path, set SP to it on fast path\n-\n-    Label slow_path;\n-    __ safepoint_poll(slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = c_rarg0;  \/\/ crc\n-    const Register buf = c_rarg1;  \/\/ source java byte array address\n-    const Register len = c_rarg2;  \/\/ length\n-    const Register off = len;      \/\/ offset (never overlaps with 'len')\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n-      __ movptr(buf, Address(rsp, 3*wordSize)); \/\/ long buf\n-      __ movl2ptr(off, Address(rsp, 2*wordSize)); \/\/ offset\n-      __ addq(buf, off); \/\/ + offset\n-      __ movl(crc,   Address(rsp, 5*wordSize)); \/\/ Initial CRC\n-    } else {\n-      __ movptr(buf, Address(rsp, 3*wordSize)); \/\/ byte[] array\n-      __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ movl2ptr(off, Address(rsp, 2*wordSize)); \/\/ offset\n-      __ addq(buf, off); \/\/ + offset\n-      __ movl(crc,   Address(rsp, 4*wordSize)); \/\/ Initial CRC\n-    }\n-    \/\/ Can now load 'len' since we're finished with 'off'\n-    __ movl(len, Address(rsp, wordSize)); \/\/ Length\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -268,2 +234,31 @@\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()), crc, buf, len);\n-    \/\/ result in rax\n+  \/\/ rbx,: Method*\n+  \/\/ r13: senderSP must preserved for slow path, set SP to it on fast path\n+\n+  Label slow_path;\n+  __ safepoint_poll(slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = c_rarg0;  \/\/ crc\n+  const Register buf = c_rarg1;  \/\/ source java byte array address\n+  const Register len = c_rarg2;  \/\/ length\n+  const Register off = len;      \/\/ offset (never overlaps with 'len')\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n+    __ movptr(buf, Address(rsp, 3*wordSize)); \/\/ long buf\n+    __ movl2ptr(off, Address(rsp, 2*wordSize)); \/\/ offset\n+    __ addq(buf, off); \/\/ + offset\n+    __ movl(crc,   Address(rsp, 5*wordSize)); \/\/ Initial CRC\n+  } else {\n+    __ movptr(buf, Address(rsp, 3*wordSize)); \/\/ byte[] array\n+    __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ movl2ptr(off, Address(rsp, 2*wordSize)); \/\/ offset\n+    __ addq(buf, off); \/\/ + offset\n+    __ movl(crc,   Address(rsp, 4*wordSize)); \/\/ Initial CRC\n+  }\n+  \/\/ Can now load 'len' since we're finished with 'off'\n+  __ movl(len, Address(rsp, wordSize)); \/\/ Length\n@@ -271,4 +266,2 @@\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, r13);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()), crc, buf, len);\n+  \/\/ result in rax\n@@ -276,6 +269,9 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, r13);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n+\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -290,40 +286,29 @@\n-  if (UseCRC32CIntrinsics) {\n-    address entry = __ pc();\n-    \/\/ Load parameters\n-    const Register crc = c_rarg0;  \/\/ crc\n-    const Register buf = c_rarg1;  \/\/ source java byte array address\n-    const Register len = c_rarg2;\n-    const Register off = c_rarg3;  \/\/ offset\n-    const Register end = len;\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n-      __ movptr(buf, Address(rsp, 3 * wordSize)); \/\/ long address\n-      __ movl2ptr(off, Address(rsp, 2 * wordSize)); \/\/ offset\n-      __ addq(buf, off); \/\/ + offset\n-      __ movl(crc, Address(rsp, 5 * wordSize)); \/\/ Initial CRC\n-      \/\/ Note on 5 * wordSize vs. 4 * wordSize:\n-      \/\/ *   int java.util.zip.CRC32C.updateByteBuffer(int crc, long address, int off, int end)\n-      \/\/                                                   4         2,3          1        0\n-      \/\/ end starts at SP + 8\n-      \/\/ The Java(R) Virtual Machine Specification Java SE 7 Edition\n-      \/\/ 4.10.2.3. Values of Types long and double\n-      \/\/    \"When calculating operand stack length, values of type long and double have length two.\"\n-    } else {\n-      __ movptr(buf, Address(rsp, 3 * wordSize)); \/\/ byte[] array\n-      __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ movl2ptr(off, Address(rsp, 2 * wordSize)); \/\/ offset\n-      __ addq(buf, off); \/\/ + offset\n-      __ movl(crc, Address(rsp, 4 * wordSize)); \/\/ Initial CRC\n-    }\n-    __ movl(end, Address(rsp, wordSize)); \/\/ end\n-    __ subl(end, off); \/\/ end - off\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()), crc, buf, len);\n-    \/\/ result in rax\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, r13);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n-\n-    return entry;\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n+  \/\/ Load parameters\n+  const Register crc = c_rarg0;  \/\/ crc\n+  const Register buf = c_rarg1;  \/\/ source java byte array address\n+  const Register len = c_rarg2;\n+  const Register off = c_rarg3;  \/\/ offset\n+  const Register end = len;\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n+    __ movptr(buf, Address(rsp, 3 * wordSize)); \/\/ long address\n+    __ movl2ptr(off, Address(rsp, 2 * wordSize)); \/\/ offset\n+    __ addq(buf, off); \/\/ + offset\n+    __ movl(crc, Address(rsp, 5 * wordSize)); \/\/ Initial CRC\n+    \/\/ Note on 5 * wordSize vs. 4 * wordSize:\n+    \/\/ *   int java.util.zip.CRC32C.updateByteBuffer(int crc, long address, int off, int end)\n+    \/\/                                                   4         2,3          1        0\n+    \/\/ end starts at SP + 8\n+    \/\/ The Java(R) Virtual Machine Specification Java SE 7 Edition\n+    \/\/ 4.10.2.3. Values of Types long and double\n+    \/\/    \"When calculating operand stack length, values of type long and double have length two.\"\n+  } else {\n+    __ movptr(buf, Address(rsp, 3 * wordSize)); \/\/ byte[] array\n+    __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ movl2ptr(off, Address(rsp, 2 * wordSize)); \/\/ offset\n+    __ addq(buf, off); \/\/ + offset\n+    __ movl(crc, Address(rsp, 4 * wordSize)); \/\/ Initial CRC\n@@ -331,0 +316,8 @@\n+  __ movl(end, Address(rsp, wordSize)); \/\/ end\n+  __ subl(end, off); \/\/ end - off\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()), crc, buf, len);\n+  \/\/ result in rax\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, r13);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n@@ -332,1 +325,1 @@\n-  return NULL;\n+  return entry;\n@@ -340,6 +333,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n-    return nullptr; \/\/ Generate a vanilla entry\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n@@ -367,6 +355,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat)) {\n-    return nullptr; \/\/ Generate a vanilla entry\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":122,"deletions":139,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -3230,1 +3230,1 @@\n-    if (!supports_f16c() && !supports_avx512vl()) {\n+    if (!supports_float16()) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,1 +313,0 @@\n-    case java_lang_math_sqrt    : tty->print(\"java_lang_math_sqrt\"    ); break;\n@@ -316,0 +315,2 @@\n+    case java_lang_math_pow     : tty->print(\"java_lang_math_pow\"     ); break;\n+    case java_lang_math_exp     : tty->print(\"java_lang_math_exp\"     ); break;\n@@ -318,0 +319,1 @@\n+    case java_lang_math_sqrt    : tty->print(\"java_lang_math_sqrt\"    ); break;\n@@ -330,0 +332,2 @@\n+    case java_lang_Float_float16ToFloat       : tty->print(\"java_lang_Float_float16ToFloat\"); break;\n+    case java_lang_Float_floatToFloat16       : tty->print(\"java_lang_Float_floatToFloat16\"); break;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -423,28 +423,0 @@\n-\n-  case Interpreter::java_lang_math_sin     : \/\/ fall thru\n-  case Interpreter::java_lang_math_cos     : \/\/ fall thru\n-  case Interpreter::java_lang_math_tan     : \/\/ fall thru\n-  case Interpreter::java_lang_math_abs     : \/\/ fall thru\n-  case Interpreter::java_lang_math_log     : \/\/ fall thru\n-  case Interpreter::java_lang_math_log10   : \/\/ fall thru\n-  case Interpreter::java_lang_math_sqrt    : \/\/ fall thru\n-  case Interpreter::java_lang_math_sqrt_strict: \/\/ fall thru\n-  case Interpreter::java_lang_math_pow     : \/\/ fall thru\n-  case Interpreter::java_lang_math_exp     : \/\/ fall thru\n-  case Interpreter::java_lang_math_fmaD    : \/\/ fall thru\n-  case Interpreter::java_lang_math_fmaF    :\n-  case Interpreter::java_lang_ref_reference_get:\n-  case Interpreter::java_util_zip_CRC32_update:\n-  case Interpreter::java_util_zip_CRC32_updateBytes:\n-  case Interpreter::java_util_zip_CRC32_updateByteBuffer:\n-  case Interpreter::java_util_zip_CRC32C_updateBytes:\n-  case Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer:\n-  case Interpreter::java_lang_Thread_currentThread:\n-  case Interpreter::java_lang_Float_float16ToFloat:\n-  case Interpreter::java_lang_Float_floatToFloat16:\n-  case Interpreter::java_lang_Float_intBitsToFloat:\n-  case Interpreter::java_lang_Float_floatToRawIntBits:\n-  case Interpreter::java_lang_Double_longBitsToDouble:\n-  case Interpreter::java_lang_Double_doubleToRawLongBits:\n-    entry_point = generate_intrinsic_entry(kind);\n-    break;\n@@ -452,1 +424,1 @@\n-    fatal(\"unexpected method kind: %d\", kind);\n+    entry_point = generate_intrinsic_entry(kind); \/\/ process the rest\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"}]}