{"files":[{"patch":"@@ -75,2 +75,0 @@\n-    \/\/ generic info repository; lazily initialized\n-    private transient volatile ConstructorRepository genericInfo;\n@@ -91,1 +89,0 @@\n-        \/\/ lazily initialize repository if necessary\n@@ -93,4 +90,6 @@\n-            \/\/ create and cache generic info repository\n-            genericInfo =\n-                ConstructorRepository.make(getSignature(),\n-                                           getFactory());\n+            var root = this.root;\n+            if (root != null) {\n+                genericInfo = root.getGenericInfo();\n+            } else {\n+                genericInfo = ConstructorRepository.make(getSignature(), getFactory());\n+            }\n@@ -99,1 +98,1 @@\n-        return genericInfo; \/\/return cached repository\n+        return genericInfo;\n@@ -102,9 +101,9 @@\n-    @Stable\n-    private ConstructorAccessor constructorAccessor;\n-    \/\/ For sharing of ConstructorAccessors. This branching structure\n-    \/\/ is currently only two levels deep (i.e., one root Constructor\n-    \/\/ and potentially many Constructor objects pointing to it.)\n-    \/\/\n-    \/\/ If this branching structure would ever contain cycles, deadlocks can\n-    \/\/ occur in annotation code.\n-    private Constructor<T>      root;\n+    \/**\n+     * Constructors are mutable due to {@link AccessibleObject#setAccessible(boolean)}.\n+     * Thus, we return a new copy of a root each time a constructor is returned.\n+     * Some lazily initialized immutable states can be stored on root and shared to the copies.\n+     *\/\n+    private Constructor<T> root;\n+    private transient volatile ConstructorRepository genericInfo;\n+    private @Stable ConstructorAccessor constructorAccessor;\n+    \/\/ End shared states\n@@ -146,7 +145,0 @@\n-        \/\/ This routine enables sharing of ConstructorAccessor objects\n-        \/\/ among Constructor objects which refer to the same underlying\n-        \/\/ method in the VM. (All of this contortion is only necessary\n-        \/\/ because of the \"accessibility\" bit in AccessibleObject,\n-        \/\/ which implicitly requires that new java.lang.reflect\n-        \/\/ objects be fabricated for each reflective call on Class\n-        \/\/ objects.)\n@@ -165,0 +157,1 @@\n+        res.genericInfo = genericInfo;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":17,"deletions":24,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,2 +79,0 @@\n-    \/\/ generic info repository; lazily initialized\n-    private transient volatile FieldRepository genericInfo;\n@@ -82,13 +80,11 @@\n-    \/\/ Cached field accessor created without override\n-    @Stable\n-    private FieldAccessor fieldAccessor;\n-    \/\/ Cached field accessor created with override\n-    @Stable\n-    private FieldAccessor overrideFieldAccessor;\n-    \/\/ For sharing of FieldAccessors. This branching structure is\n-    \/\/ currently only two levels deep (i.e., one root Field and\n-    \/\/ potentially many Field objects pointing to it.)\n-    \/\/\n-    \/\/ If this branching structure would ever contain cycles, deadlocks can\n-    \/\/ occur in annotation code.\n-    private Field               root;\n+\n+    \/**\n+     * Fields are mutable due to {@link AccessibleObject#setAccessible(boolean)}.\n+     * Thus, we return a new copy of a root each time a field is returned.\n+     * Some lazily initialized immutable states can be stored on root and shared to the copies.\n+     *\/\n+    private Field root;\n+    private transient volatile FieldRepository genericInfo;\n+    private @Stable FieldAccessor fieldAccessor; \/\/ access control enabled\n+    private @Stable FieldAccessor overrideFieldAccessor; \/\/ access control suppressed\n+    \/\/ End shared states\n@@ -110,1 +106,0 @@\n-        \/\/ lazily initialize repository if necessary\n@@ -112,3 +107,6 @@\n-            \/\/ create and cache generic info repository\n-            genericInfo = FieldRepository.make(getGenericSignature(),\n-                                               getFactory());\n+            var root = this.root;\n+            if (root != null) {\n+                genericInfo = root.getGenericInfo();\n+            } else {\n+                genericInfo = FieldRepository.make(getGenericSignature(), getFactory());\n+            }\n@@ -117,1 +115,1 @@\n-        return genericInfo; \/\/return cached repository\n+        return genericInfo;\n@@ -120,1 +118,0 @@\n-\n@@ -165,0 +162,1 @@\n+        res.genericInfo = genericInfo;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -84,2 +84,0 @@\n-    \/\/ generic info repository; lazily initialized\n-    private transient volatile MethodRepository genericInfo;\n@@ -89,11 +87,11 @@\n-    @Stable\n-    private MethodAccessor      methodAccessor;\n-    \/\/ For sharing of MethodAccessors. This branching structure is\n-    \/\/ currently only two levels deep (i.e., one root Method and\n-    \/\/ potentially many Method objects pointing to it.)\n-    \/\/\n-    \/\/ If this branching structure would ever contain cycles, deadlocks can\n-    \/\/ occur in annotation code.\n-    private Method              root;\n-    \/\/ Hash code of this object\n-    private int                 hash;\n+\n+    \/**\n+     * Methods are mutable due to {@link AccessibleObject#setAccessible(boolean)}.\n+     * Thus, we return a new copy of a root each time a method is returned.\n+     * Some lazily initialized immutable states can be stored on root and shared to the copies.\n+     *\/\n+    private Method root;\n+    private transient volatile MethodRepository genericInfo;\n+    private @Stable MethodAccessor methodAccessor;\n+    \/\/ End shared states\n+    private int hash; \/\/ not shared right now, eligible if expensive\n@@ -114,1 +112,0 @@\n-        \/\/ lazily initialize repository if necessary\n@@ -116,3 +113,6 @@\n-            \/\/ create and cache generic info repository\n-            genericInfo = MethodRepository.make(getGenericSignature(),\n-                                                getFactory());\n+            var root = this.root;\n+            if (root != null) {\n+                genericInfo = root.getGenericInfo();\n+            } else {\n+                genericInfo = MethodRepository.make(getGenericSignature(), getFactory());\n+            }\n@@ -121,1 +121,1 @@\n-        return genericInfo; \/\/return cached repository\n+        return genericInfo;\n@@ -157,7 +157,0 @@\n-        \/\/ This routine enables sharing of MethodAccessor objects\n-        \/\/ among Method objects which refer to the same underlying\n-        \/\/ method in the VM. (All of this contortion is only necessary\n-        \/\/ because of the \"accessibility\" bit in AccessibleObject,\n-        \/\/ which implicitly requires that new java.lang.reflect\n-        \/\/ objects be fabricated for each reflective call on Class\n-        \/\/ objects.)\n@@ -171,1 +164,1 @@\n-        \/\/ Might as well eagerly propagate this if already present\n+        \/\/ Propagate shared states\n@@ -173,0 +166,1 @@\n+        res.genericInfo = genericInfo;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":20,"deletions":26,"binary":false,"changes":46,"status":"modified"}]}