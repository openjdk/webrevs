{"files":[{"patch":"@@ -79,2 +79,0 @@\n-    \/\/ generic info repository; lazily initialized\n-    private transient volatile FieldRepository genericInfo;\n@@ -82,13 +80,11 @@\n-    \/\/ Cached field accessor created without override\n-    @Stable\n-    private FieldAccessor fieldAccessor;\n-    \/\/ Cached field accessor created with override\n-    @Stable\n-    private FieldAccessor overrideFieldAccessor;\n-    \/\/ For sharing of FieldAccessors. This branching structure is\n-    \/\/ currently only two levels deep (i.e., one root Field and\n-    \/\/ potentially many Field objects pointing to it.)\n-    \/\/\n-    \/\/ If this branching structure would ever contain cycles, deadlocks can\n-    \/\/ occur in annotation code.\n-    private Field               root;\n+\n+    \/**\n+     * Fields are mutable due to {@link AccessibleObject#setAccessible(boolean)}.\n+     * Thus, we return a new copy of a root each time a field is returned.\n+     * Some lazily initialized immutable states can be stored on root and shared to the copies.\n+     *\/\n+    private Field root;\n+    private transient volatile FieldRepository genericInfo;\n+    private @Stable FieldAccessor fieldAccessor; \/\/ access control enabled\n+    private @Stable FieldAccessor overrideFieldAccessor; \/\/ access control suppressed\n+    \/\/ End shared states\n@@ -110,1 +106,0 @@\n-        \/\/ lazily initialize repository if necessary\n@@ -116,3 +111,1 @@\n-                \/\/ create and cache generic info repository\n-                genericInfo = FieldRepository.make(getGenericSignature(),\n-                        getFactory());\n+                genericInfo = FieldRepository.make(getGenericSignature(), getFactory());\n@@ -122,1 +115,1 @@\n-        return genericInfo; \/\/return cached repository\n+        return genericInfo;\n@@ -125,1 +118,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"}]}