{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -115,1 +116,1 @@\n-        private static final Set<Path> activePaths = new HashSet<>();\n+        private static final List<Path> activePaths = new ArrayList<>();\n@@ -265,0 +266,17 @@\n+        private static void checkCyclicInclude(Path path) {\n+            for (Path activePath : activePaths) {\n+                try {\n+                    if (Files.isSameFile(path, activePath)) {\n+                        throw new InternalError(\n+                                \"Cyclic include of '\" + path + \"'\");\n+                    }\n+                } catch (IOException e) {\n+                    if (sdebug != null) {\n+                        sdebug.println(\"skipped exception when checking for \" +\n+                                \"cyclic inclusion of \" + path + \":\");\n+                        e.printStackTrace();\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -267,4 +285,1 @@\n-            boolean isRegularFile = Files.isRegularFile(path);\n-            if (isRegularFile) {\n-                path = path.toRealPath();\n-            } else if (Files.isDirectory(path)) {\n+            if (Files.isDirectory(path)) {\n@@ -272,5 +287,0 @@\n-            } else {\n-                path = path.toAbsolutePath();\n-            }\n-            if (activePaths.contains(path)) {\n-                throw new InternalError(\"Cyclic include of '\" + path + \"'\");\n@@ -279,0 +289,1 @@\n+                checkCyclicInclude(path);\n@@ -281,1 +292,1 @@\n-                currentPath = isRegularFile ? path : null;\n+                currentPath = Files.isRegularFile(path) ? path : null;\n@@ -288,1 +299,1 @@\n-                    activePaths.remove(path);\n+                    activePaths.removeLast();\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1,927 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpServer;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.util.FileUtils;\n-import sun.net.www.ParseUtil;\n-\n-import java.io.Closeable;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.io.PrintWriter;\n-import java.io.UncheckedIOException;\n-import java.lang.reflect.Method;\n-import java.net.HttpURLConnection;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.URI;\n-import java.nio.CharBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n-import java.security.Security;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @summary Tests security properties passed through java.security,\n- *   java.security.properties or included from other properties files.\n- * @bug 8155246 8292297 8292177 8281658 8319332\n- * @modules java.base\/sun.net.www\n- * @library \/test\/lib\n- * @run main ConfigFileTest\n- *\/\n-\n-public class ConfigFileTest {\n-    static final String SEPARATOR_THIN = \"----------------------------\";\n-\n-    private static void printTestHeader(String testName) {\n-        System.out.println();\n-        System.out.println(SEPARATOR_THIN);\n-        System.out.println(testName);\n-        System.out.println(SEPARATOR_THIN);\n-        System.out.println();\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 1 && Executor.RUNNER_ARG.equals(args[0])) {\n-            \/\/ Executed by a test-launched JVM.\n-            \/\/ Force the initialization of java.security.Security.\n-            Security.getProviders();\n-            Security.setProperty(\"postInitTest\", \"shouldNotRecord\");\n-            System.out.println(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n-                    Security.getProperty(FilesManager.LAST_FILE_PROP_NAME));\n-            assertTestSecuritySetPropertyShouldNotInclude();\n-        } else {\n-            \/\/ Executed by the test JVM.\n-            try (FilesManager filesMgr = new FilesManager()) {\n-                for (Method m : ConfigFileTest.class.getDeclaredMethods()) {\n-                    if (m.getName().startsWith(\"test\")) {\n-                        printTestHeader(m.getName());\n-                        Executor.run(m, filesMgr);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Success cases\n-     *\/\n-\n-    static void testShowSettings(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Sanity test passing the -XshowSettings:security option.\n-        ex.addJvmArg(\"-XshowSettings:security\");\n-        ex.setMasterFile(filesMgr.newMasterFile());\n-        ex.assertSuccess();\n-        ex.getOutputAnalyzer()\n-                .shouldContain(\"Security properties:\")\n-                .shouldContain(\"Security provider static configuration:\")\n-                .shouldContain(\"Security TLS configuration\");\n-    }\n-\n-    static void testIncludeBasic(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n-        PropsFile file2 = filesMgr.newFile(\"dir1\/dir2\/file2.properties\");\n-\n-        masterFile.addAbsoluteInclude(file0);\n-        extraFile.addRelativeInclude(file2);\n-        file2.addAbsoluteInclude(file1);\n-\n-        ex.setMasterFile(masterFile);\n-        ex.setExtraFile(extraFile, Executor.ExtraMode.FILE_URI, false);\n-        ex.assertSuccess();\n-    }\n-\n-    static void testRepeatedInclude(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n-\n-        masterFile.addAbsoluteInclude(file0);\n-        masterFile.addAbsoluteInclude(file1);\n-        masterFile.addAbsoluteInclude(file0);\n-        file1.addRelativeInclude(file0);\n-\n-        ex.setMasterFile(masterFile);\n-        ex.assertSuccess();\n-    }\n-\n-    static void testIncludeWithOverrideAll(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n-\n-        masterFile.addRelativeInclude(file0);\n-        extraFile.addAbsoluteInclude(file1);\n-\n-        ex.setMasterFile(masterFile);\n-        ex.setExtraFile(extraFile, Executor.ExtraMode.HTTP_SERVED, true);\n-        ex.assertSuccess();\n-    }\n-\n-    static void extraPropertiesByHelper(Executor ex, FilesManager filesMgr,\n-            Executor.ExtraMode mode) throws Exception {\n-        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-\n-        extraFile.addRelativeInclude(file0);\n-\n-        ex.setMasterFile(filesMgr.newMasterFile());\n-        ex.setExtraFile(extraFile, mode, true);\n-        ex.assertSuccess();\n-    }\n-\n-    static void testExtraPropertiesByPathAbsolute(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        extraPropertiesByHelper(ex, filesMgr, Executor.ExtraMode.PATH_ABS);\n-    }\n-\n-    static void testExtraPropertiesByPathRelative(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        extraPropertiesByHelper(ex, filesMgr, Executor.ExtraMode.PATH_REL);\n-    }\n-\n-    static void specialCharsIncludes(Executor ex, FilesManager filesMgr,\n-            char specialChar, Executor.ExtraMode extraMode,\n-            boolean useRelativeIncludes) throws Exception {\n-        String suffix = specialChar + \".properties\";\n-        ExtraPropsFile extraFile;\n-        PropsFile file0, file1;\n-        try {\n-            extraFile = filesMgr.newExtraFile(\"extra\" + suffix);\n-            file0 = filesMgr.newFile(\"file0\" + suffix);\n-            file1 = filesMgr.newFile(\"file1\" + suffix);\n-        } catch (InvalidPathException ipe) {\n-            \/\/ The platform encoding may not allow to create files with some\n-            \/\/ special characters. Skip the test in these cases.\n-            return;\n-        }\n-\n-        if (useRelativeIncludes) {\n-            extraFile.addRelativeInclude(file0);\n-        } else {\n-            extraFile.addAbsoluteInclude(file0);\n-        }\n-        extraFile.addAbsoluteInclude(file1);\n-\n-        ex.setMasterFile(filesMgr.newMasterFile());\n-        ex.setExtraFile(extraFile, extraMode, false);\n-        ex.assertSuccess();\n-    }\n-\n-    static void testUnicodeIncludes1(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        specialCharsIncludes(ex, filesMgr, '\\u2022',\n-                Executor.ExtraMode.PATH_ABS, true);\n-    }\n-\n-    static void testUnicodeIncludes2(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        specialCharsIncludes(ex, filesMgr, '\\u2022',\n-                Executor.ExtraMode.FILE_URI, true);\n-    }\n-\n-    static void testUnicodeIncludes3(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Backward compatibility check. Malformed URLs such as\n-        \/\/ file:\/tmp\/extra•.properties are supported for the extra file.\n-        \/\/ However, relative includes are not allowed in these cases.\n-        specialCharsIncludes(ex, filesMgr, '\\u2022',\n-                Executor.ExtraMode.RAW_FILE_URI1, false);\n-    }\n-\n-    static void testUnicodeIncludes4(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Backward compatibility check. Malformed URLs such as\n-        \/\/ file:\/\/\/tmp\/extra•.properties are supported for the extra file.\n-        \/\/ However, relative includes are not allowed in these cases.\n-        specialCharsIncludes(ex, filesMgr, '\\u2022',\n-                Executor.ExtraMode.RAW_FILE_URI2, false);\n-    }\n-\n-    static void testSpaceIncludes1(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        specialCharsIncludes(ex, filesMgr, ' ',\n-                Executor.ExtraMode.PATH_ABS, true);\n-    }\n-\n-    static void testSpaceIncludes2(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        specialCharsIncludes(ex, filesMgr, ' ',\n-                Executor.ExtraMode.FILE_URI, true);\n-    }\n-\n-    static void testSpaceIncludes3(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Backward compatibility check. Malformed URLs such as\n-        \/\/ file:\/tmp\/extra .properties are supported for the extra file.\n-        \/\/ However, relative includes are not allowed in these cases.\n-        specialCharsIncludes(ex, filesMgr, ' ',\n-                Executor.ExtraMode.RAW_FILE_URI1, false);\n-    }\n-\n-    static void testSpaceIncludes4(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Backward compatibility check. Malformed URLs such as\n-        \/\/ file:\/\/\/tmp\/extra .properties are supported for the extra file.\n-        \/\/ However, relative includes are not allowed in these cases.\n-        specialCharsIncludes(ex, filesMgr, ' ',\n-                Executor.ExtraMode.RAW_FILE_URI2, false);\n-    }\n-\n-    static void notOverrideOnFailureHelper(Executor ex, FilesManager filesMgr,\n-            String nonExistentExtraFile) throws Exception {\n-        \/\/ An overriding extra properties file that does not exist\n-        \/\/ should not erase properties from the master file.\n-        ex.setIgnoredExtraFile(nonExistentExtraFile, true);\n-        ex.setMasterFile(filesMgr.newMasterFile());\n-        ex.assertSuccess();\n-        ex.getOutputAnalyzer().shouldContain(\"unable to load security \" +\n-                \"properties from \" + nonExistentExtraFile);\n-    }\n-\n-    static void testNotOverrideOnEmptyFailure(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        notOverrideOnFailureHelper(ex, filesMgr, \"\");\n-        ex.getOutputAnalyzer()\n-                .shouldContain(\"Empty extra properties file path\");\n-    }\n-\n-    static void testNotOverrideOnURLFailure(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        notOverrideOnFailureHelper(ex, filesMgr,\n-                \"file:\/\/\/nonExistentFile.properties\");\n-    }\n-\n-    static void testNotOverrideOnPathFailure(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        notOverrideOnFailureHelper(ex, filesMgr, \"nonExistentFile.properties\");\n-    }\n-\n-    static void testNotOverrideOnDirFailure(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/\");\n-        ex.getOutputAnalyzer().shouldContain(\"Is a directory\");\n-    }\n-\n-    static void testNotOverrideOnBadFileURLFailure(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/%00\");\n-    }\n-\n-    static void testDisabledExtraPropertiesFile(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-\n-        masterFile.addRawProperty(\"security.overridePropertiesFile\", \"false\");\n-\n-        ex.setMasterFile(masterFile);\n-        ex.setIgnoredExtraFile(file0.path.toString(), true);\n-        ex.assertSuccess();\n-    }\n-\n-    static final String SECURITY_SET_PROP_FILE_PATH =\n-            \"testSecuritySetPropertyShouldNotInclude.propsFilePath\";\n-\n-    static void testSecuritySetPropertyShouldNotInclude(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-\n-        ex.addSystemProp(SECURITY_SET_PROP_FILE_PATH, file0.path.toString());\n-        ex.setMasterFile(masterFile);\n-        ex.assertSuccess();\n-    }\n-\n-    static void assertTestSecuritySetPropertyShouldNotInclude() {\n-        \/\/ This check is executed by the launched JVM.\n-        String propsFilePath = System.getProperty(SECURITY_SET_PROP_FILE_PATH);\n-        if (propsFilePath != null) {\n-            String name = Path.of(propsFilePath).getFileName().toString();\n-            String setPropInvokeRepr = \"Security.setProperty(\\\"include\\\", \" +\n-                    \"\\\"\" + propsFilePath + \"\\\")\";\n-            try {\n-                Security.setProperty(\"include\", propsFilePath);\n-                throw new RuntimeException(setPropInvokeRepr + \" was \" +\n-                        \"expected to throw IllegalArgumentException.\");\n-            } catch (IllegalArgumentException expected) {}\n-            if (FilesManager.APPLIED_PROP_VALUE.equals(\n-                    Security.getProperty(name))) {\n-                throw new RuntimeException(setPropInvokeRepr + \" caused \" +\n-                        \"a file inclusion.\");\n-            }\n-            try {\n-                Security.getProperty(\"include\");\n-                throw new RuntimeException(\"Security.getProperty(\\\"include\\\")\" +\n-                        \" was expected to throw IllegalArgumentException.\");\n-            } catch (IllegalArgumentException expected) {}\n-        }\n-    }\n-\n-    \/*\n-     * Error cases\n-     *\/\n-\n-    static void testCannotResolveRelativeFromHTTPServed(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-\n-        extraFile.addRelativeInclude(file0);\n-\n-        ex.setMasterFile(filesMgr.newMasterFile());\n-        ex.setExtraFile(extraFile, Executor.ExtraMode.HTTP_SERVED, true);\n-        ex.assertError(\"InternalError: Cannot resolve '\" + file0.fileName +\n-                \"' relative path when included from a non-regular \" +\n-                \"properties file (e.g. HTTP served file)\");\n-    }\n-\n-    static void testCannotIncludeCycles(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n-\n-        \/\/ Includes chain: master -> file0 -> file1 -> master.\n-        file1.addRelativeInclude(masterFile);\n-        file0.addRelativeInclude(file1);\n-        masterFile.addRelativeInclude(file0);\n-\n-        ex.setMasterFile(masterFile);\n-        ex.assertError(\n-                \"InternalError: Cyclic include of '\" + masterFile.path + \"'\");\n-    }\n-\n-    static void testCannotIncludeURL(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n-\n-        masterFile.addRawProperty(\"include\", extraFile.url.toString());\n-\n-        ex.setMasterFile(masterFile);\n-        ex.assertError(\"InternalError: Unable to include 'http:\/\/127.0.0.1:\");\n-    }\n-\n-    static void testCannotIncludeNonexistentFile(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-\n-        String nonexistentPath = \"\/nonExistentFile.properties\";\n-        masterFile.addRawProperty(\"include\", nonexistentPath);\n-\n-        ex.setMasterFile(masterFile);\n-        ex.assertError(\n-                \"InternalError: Unable to include '\" + nonexistentPath + \"'\");\n-    }\n-\n-    static void testMustHaveMasterFile(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Launch a JDK without a master java.security file present.\n-        ex.assertError(\"InternalError: Error loading java.security file\");\n-    }\n-\n-    static void testMustHaveMasterFileEvenWithExtraFile(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        \/\/ Launch a JDK without a master java.security file present, but with an\n-        \/\/ extra file passed. Since the \"security.overridePropertiesFile=true\"\n-        \/\/ security property is missing, it should fail anyway.\n-        ex.setExtraFile(\n-                filesMgr.newExtraFile(), Executor.ExtraMode.FILE_URI, true);\n-        ex.assertError(\"InternalError: Error loading java.security file\");\n-    }\n-}\n-\n-sealed class PropsFile permits ExtraPropsFile {\n-    protected static final class Include {\n-        final PropsFile propsFile;\n-        final String value;\n-\n-        private Include(PropsFile propsFile, String value) {\n-            this.propsFile = propsFile;\n-            this.value = value;\n-        }\n-\n-        static Include of(PropsFile propsFile) {\n-            return new Include(propsFile, propsFile.path.toString());\n-        }\n-\n-        static Include of(PropsFile propsFile, String value) {\n-            return new Include(propsFile, value);\n-        }\n-    }\n-\n-    protected final List<Include> includes = new ArrayList<>();\n-    protected final PrintWriter writer;\n-    protected boolean includedFromExtra = false;\n-    final String fileName;\n-    final Path path;\n-\n-    PropsFile(String fileName, Path path) throws IOException {\n-        this.fileName = fileName;\n-        this.path = path;\n-        this.writer = new PrintWriter(Files.newOutputStream(path,\n-                StandardOpenOption.CREATE, StandardOpenOption.APPEND), true);\n-    }\n-\n-    private static String escape(String text, boolean escapeSpace) {\n-        StringBuilder sb = new StringBuilder(text.length());\n-        CharBuffer cb = CharBuffer.wrap(text);\n-        while (cb.hasRemaining()) {\n-            char c = cb.get();\n-            if (c == '\\\\' || escapeSpace && c == ' ') {\n-                sb.append('\\\\');\n-            }\n-            if (Character.UnicodeBlock.of(c) ==\n-                    Character.UnicodeBlock.BASIC_LATIN) {\n-                sb.append(c);\n-            } else {\n-                sb.append(\"\\\\u%04x\".formatted((int) c));\n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-    private void addRawProperty(String key, String value, String sep) {\n-        writer.println(escape(key, true) + sep + escape(value, false));\n-    }\n-\n-    protected void addIncludeDefinition(Include include) {\n-        if (include.propsFile instanceof ExtraPropsFile) {\n-            throw new RuntimeException(\"ExtraPropsFile should not be included\");\n-        }\n-        includes.add(include);\n-        addRawProperty(\"include\", include.value, \" \");\n-    }\n-\n-    void addComment(String comment) {\n-        writer.println(\"# \" + comment);\n-    }\n-\n-    void addRawProperty(String key, String value) {\n-        addRawProperty(key, value, \"=\");\n-    }\n-\n-    void addAbsoluteInclude(PropsFile propsFile) {\n-        addIncludeDefinition(Include.of(propsFile));\n-    }\n-\n-    void addRelativeInclude(PropsFile propsFile) {\n-        addIncludeDefinition(Include.of(propsFile,\n-                path.getParent().relativize(propsFile.path).toString()));\n-    }\n-\n-    void assertApplied(OutputAnalyzer oa) {\n-        oa.shouldContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n-                FilesManager.APPLIED_PROP_VALUE);\n-        for (Include include : includes) {\n-            include.propsFile.assertApplied(oa);\n-            oa.shouldContain(\"processing include: '\" + include.value + \"'\");\n-            oa.shouldContain(\"finished processing \" + include.propsFile.path);\n-        }\n-    }\n-\n-    void assertWasOverwritten(OutputAnalyzer oa) {\n-        oa.shouldNotContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n-                FilesManager.APPLIED_PROP_VALUE);\n-        for (Include include : includes) {\n-            if (!include.propsFile.includedFromExtra) {\n-                include.propsFile.assertWasOverwritten(oa);\n-            }\n-            oa.shouldContain(\"processing include: '\" + include.value + \"'\");\n-            oa.shouldContain(\"finished processing \" + include.propsFile.path);\n-        }\n-    }\n-\n-    void markAsIncludedFromExtra() {\n-        includedFromExtra = true;\n-        for (Include include : includes) {\n-            include.propsFile.markAsIncludedFromExtra();\n-        }\n-    }\n-\n-    PropsFile getLastFile() {\n-        return includes.isEmpty() ?\n-                this : includes.getLast().propsFile.getLastFile();\n-    }\n-\n-    void close() {\n-        writer.close();\n-    }\n-}\n-\n-final class ExtraPropsFile extends PropsFile {\n-    private final Map<String, String> systemProps = new LinkedHashMap<>();\n-    final URI url;\n-\n-    ExtraPropsFile(String fileName, URI url, Path path) throws IOException {\n-        super(fileName, path);\n-        this.url = url;\n-    }\n-\n-    @Override\n-    protected void addIncludeDefinition(Include include) {\n-        if (includes.isEmpty()) {\n-            String propName = \"props.fileName\";\n-            systemProps.put(propName, include.propsFile.fileName);\n-            include = Include.of(include.propsFile,\n-                    include.value.replace(include.propsFile.fileName,\n-                            \"${props.none}${\" + propName + \"}\"));\n-        }\n-        include.propsFile.markAsIncludedFromExtra();\n-        super.addIncludeDefinition(include);\n-    }\n-\n-    Map<String, String> getSystemProperties() {\n-        return Collections.unmodifiableMap(systemProps);\n-    }\n-}\n-\n-final class FilesManager implements Closeable {\n-    private static final Path ROOT_DIR =\n-            Path.of(ConfigFileTest.class.getSimpleName()).toAbsolutePath();\n-    private static final Path PROPS_DIR = ROOT_DIR.resolve(\"properties\");\n-    private static final Path JDK_DIR = ROOT_DIR.resolve(\"jdk\");\n-    private static final Path MASTER_FILE =\n-            JDK_DIR.resolve(\"conf\/security\/java.security\");\n-    private static final Path MASTER_FILE_TEMPLATE =\n-            MASTER_FILE.resolveSibling(\"java.security.template\");\n-    static final String JAVA_EXECUTABLE =\n-            JDK_DIR.resolve(\"bin\/java\").toString();\n-    static final String LAST_FILE_PROP_NAME = \"last-file\";\n-    static final String APPLIED_PROP_VALUE = \"applied\";\n-\n-    private final List<PropsFile> createdFiles;\n-    private final Set<String> fileNamesInUse;\n-    private final HttpServer httpServer;\n-    private final URI serverUri;\n-    private final long masterFileLines;\n-\n-    FilesManager() throws Exception {\n-        createdFiles = new ArrayList<>();\n-        fileNamesInUse = new HashSet<>();\n-        httpServer = HttpServer.create(\n-                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n-        httpServer.createContext(\"\/\", this::handleRequest);\n-        InetSocketAddress address = httpServer.getAddress();\n-        httpServer.start();\n-        serverUri = new URI(\"http\", null, address.getHostString(),\n-                address.getPort(), null, null, null);\n-        copyJDK();\n-        try (Stream<String> s = Files.lines(MASTER_FILE_TEMPLATE)) {\n-            masterFileLines = s.count();\n-        }\n-    }\n-\n-    private static void copyJDK() throws Exception {\n-        Path testJDK = Path.of(Objects.requireNonNull(\n-                System.getProperty(\"test.jdk\"), \"unspecified test.jdk\"));\n-        if (!Files.exists(testJDK)) {\n-            throw new RuntimeException(\"test.jdk -> nonexistent JDK\");\n-        }\n-        Files.createDirectories(JDK_DIR);\n-        try (Stream<Path> pathStream = Files.walk(testJDK)) {\n-            pathStream.skip(1).forEach((Path file) -> {\n-                try {\n-                    Files.copy(file, JDK_DIR.resolve(testJDK.relativize(file)),\n-                            StandardCopyOption.COPY_ATTRIBUTES);\n-                } catch (IOException ioe) {\n-                    throw new UncheckedIOException(ioe);\n-                }\n-            });\n-        }\n-        Files.move(MASTER_FILE, MASTER_FILE_TEMPLATE);\n-    }\n-\n-    private void handleRequest(HttpExchange x) throws IOException {\n-        String rawPath = x.getRequestURI().getRawPath();\n-        Path f = ROOT_DIR.resolve(x.getRequestURI().getPath().substring(1));\n-        int statusCode;\n-        byte[] responseBody;\n-        \/\/ Check for unescaped space, unresolved parent or backward slash.\n-        if (rawPath.matches(\"^.*( |(\\\\.|%2[Ee]){2}|\\\\\\\\|%5[Cc]).*$\")) {\n-            statusCode = HttpURLConnection.HTTP_BAD_REQUEST;\n-            responseBody = new byte[0];\n-        } else if (Files.isRegularFile(f)) {\n-            x.getResponseHeaders().add(\"Content-type\", \"text\/plain\");\n-            statusCode = HttpURLConnection.HTTP_OK;\n-            responseBody = Files.readAllBytes(f);\n-        } else {\n-            statusCode = HttpURLConnection.HTTP_NOT_FOUND;\n-            responseBody = new byte[0];\n-        }\n-        System.out.println(\"[\" + Instant.now() + \"] \" +\n-                getClass().getSimpleName() + \": \" +\n-                x.getRequestMethod() + \" \" + rawPath + \" -> \" +\n-                statusCode + \" (\" + responseBody.length + \" bytes)\");\n-        try (OutputStream responseStream = x.getResponseBody()) {\n-            x.sendResponseHeaders(statusCode, responseBody.length);\n-            responseStream.write(responseBody);\n-        }\n-    }\n-\n-    @FunctionalInterface\n-    private interface PropsFileBuilder {\n-        PropsFile build(String fileName, Path path) throws IOException;\n-    }\n-\n-    private PropsFile newFile(Path path, PropsFileBuilder builder)\n-            throws IOException {\n-        String fileName = path.getFileName().toString();\n-        if (!fileNamesInUse.add(fileName)) {\n-            \/\/ Names must be unique in order for the special\n-            \/\/ property <fileName>=<APPLIED_PROP_VALUE> to work.\n-            throw new RuntimeException(fileName + \" is repeated\");\n-        }\n-        Files.createDirectories(path.getParent());\n-        PropsFile propsFile = builder.build(fileName, path);\n-        propsFile.addComment(\"Property to determine if this properties file \" +\n-                \"was parsed and not overwritten:\");\n-        propsFile.addRawProperty(fileName, APPLIED_PROP_VALUE);\n-        propsFile.addComment(ConfigFileTest.SEPARATOR_THIN);\n-        propsFile.addComment(\"Property to be overwritten by every properties \" +\n-                \"file (master, extra or included):\");\n-        propsFile.addRawProperty(LAST_FILE_PROP_NAME, fileName);\n-        propsFile.addComment(ConfigFileTest.SEPARATOR_THIN);\n-        createdFiles.add(propsFile);\n-        return propsFile;\n-    }\n-\n-    PropsFile newFile(String relPathStr) throws IOException {\n-        return newFile(PROPS_DIR.resolve(relPathStr), PropsFile::new);\n-    }\n-\n-    PropsFile newMasterFile() throws IOException {\n-        Files.copy(MASTER_FILE_TEMPLATE, MASTER_FILE);\n-        return newFile(MASTER_FILE, PropsFile::new);\n-    }\n-\n-    ExtraPropsFile newExtraFile() throws IOException {\n-        return newExtraFile(\"extra.properties\");\n-    }\n-\n-    ExtraPropsFile newExtraFile(String extraFileName) throws IOException {\n-        return (ExtraPropsFile) newFile(PROPS_DIR.resolve(extraFileName),\n-                (fileName, path) -> {\n-                    URI uri = serverUri.resolve(ParseUtil.encodePath(\n-                            ROOT_DIR.relativize(path).toString()));\n-                    return new ExtraPropsFile(fileName, uri, path);\n-                });\n-    }\n-\n-    void reportCreatedFiles() throws IOException {\n-        for (PropsFile propsFile : createdFiles) {\n-            System.err.println();\n-            System.err.println(propsFile.path.toString());\n-            System.err.println(ConfigFileTest.SEPARATOR_THIN.repeat(3));\n-            try (Stream<String> lines = Files.lines(propsFile.path)) {\n-                long lineNumber = 1L;\n-                Iterator<String> it = lines.iterator();\n-                while (it.hasNext()) {\n-                    String line = it.next();\n-                    if (!propsFile.path.equals(MASTER_FILE) ||\n-                            lineNumber > masterFileLines) {\n-                        System.err.println(line);\n-                    }\n-                    lineNumber++;\n-                }\n-            }\n-            System.err.println();\n-        }\n-    }\n-\n-    void clear() throws IOException {\n-        if (!createdFiles.isEmpty()) {\n-            for (PropsFile propsFile : createdFiles) {\n-                propsFile.close();\n-                Files.delete(propsFile.path);\n-            }\n-            FileUtils.deleteFileTreeUnchecked(PROPS_DIR);\n-            createdFiles.clear();\n-            fileNamesInUse.clear();\n-        }\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        clear();\n-        httpServer.stop(0);\n-        FileUtils.deleteFileTreeUnchecked(ROOT_DIR);\n-    }\n-}\n-\n-final class Executor {\n-    enum ExtraMode {\n-        HTTP_SERVED, FILE_URI, RAW_FILE_URI1, RAW_FILE_URI2, PATH_ABS, PATH_REL\n-    }\n-    static final String RUNNER_ARG = \"runner\";\n-    static final String INITIAL_PROP_LOG_MSG = \"Initial security property: \";\n-    private static final String OVERRIDING_LOG_MSG =\n-            \"overriding other security properties files!\";\n-    private static final String[] ALWAYS_UNEXPECTED_LOG_MSGS = {\n-            \"java.lang.AssertionError\",\n-            INITIAL_PROP_LOG_MSG + \"postInitTest=shouldNotRecord\",\n-            INITIAL_PROP_LOG_MSG + \"include=\",\n-    };\n-    private static final Path CWD = Path.of(\".\").toAbsolutePath();\n-    private static final String JAVA_SEC_PROPS = \"java.security.properties\";\n-    private static final String CLASS_PATH = Objects.requireNonNull(\n-            System.getProperty(\"test.classes\"), \"unspecified test.classes\");\n-    private static final String DEBUG_ARG =\n-            \"-Xrunjdwp:transport=dt_socket,address=localhost:8000,suspend=y\";\n-    private final Map<String, String> systemProps = new LinkedHashMap<>(\n-            Map.of(\"java.security.debug\", \"all\", \"javax.net.debug\", \"all\",\n-                    \/\/ Ensure we get UTF-8 debug outputs in Windows:\n-                    \"stderr.encoding\", \"UTF-8\", \"stdout.encoding\", \"UTF-8\"));\n-    private final List<String> jvmArgs = new ArrayList<>(\n-            List.of(FilesManager.JAVA_EXECUTABLE, \"-enablesystemassertions\",\n-                    \/\/ Uncomment DEBUG_ARG to debug test-launched JVMs:\n-                    \"-classpath\", CLASS_PATH\/\/, DEBUG_ARG\n-            ));\n-    private PropsFile masterPropsFile;\n-    private ExtraPropsFile extraPropsFile;\n-    private boolean expectedOverrideAll = false;\n-    private OutputAnalyzer oa;\n-\n-    static void run(Method m, FilesManager filesMgr) throws Exception {\n-        try {\n-            m.invoke(null, new Executor(), filesMgr);\n-        } catch (Throwable e) {\n-            filesMgr.reportCreatedFiles();\n-            throw e;\n-        } finally {\n-            filesMgr.clear();\n-        }\n-    }\n-\n-    void addSystemProp(String key, String value) {\n-        systemProps.put(key, value);\n-    }\n-\n-    private void setRawExtraFile(String extraFile, boolean overrideAll) {\n-        addSystemProp(JAVA_SEC_PROPS, (overrideAll ? \"=\" : \"\") + extraFile);\n-    }\n-\n-    void setMasterFile(PropsFile masterPropsFile) {\n-        this.masterPropsFile = masterPropsFile;\n-    }\n-\n-    void setExtraFile(ExtraPropsFile extraPropsFile, ExtraMode mode,\n-            boolean overrideAll) {\n-        this.extraPropsFile = extraPropsFile;\n-        expectedOverrideAll = overrideAll;\n-        setRawExtraFile(switch (mode) {\n-            case HTTP_SERVED -> extraPropsFile.url.toString();\n-            case FILE_URI -> extraPropsFile.path.toUri().toString();\n-            case RAW_FILE_URI1 -> \"file:\" + extraPropsFile.path;\n-            case RAW_FILE_URI2 -> \"file:\/\/\" +\n-                    (extraPropsFile.path.startsWith(\"\/\") ? \"\" : \"\/\") +\n-                    extraPropsFile.path;\n-            case PATH_ABS -> extraPropsFile.path.toString();\n-            case PATH_REL -> CWD.relativize(extraPropsFile.path).toString();\n-        }, overrideAll);\n-    }\n-\n-    void setIgnoredExtraFile(String extraPropsFile, boolean overrideAll) {\n-        setRawExtraFile(extraPropsFile, overrideAll);\n-        expectedOverrideAll = false;\n-    }\n-\n-    void addJvmArg(String arg) {\n-        jvmArgs.add(arg);\n-    }\n-\n-    private void execute(boolean successExpected) throws Exception {\n-        List<String> command = new ArrayList<>(jvmArgs);\n-        Collections.addAll(command, Utils.getTestJavaOpts());\n-        addSystemPropertiesAsJvmArgs(command);\n-        command.add(ConfigFileTest.class.getSimpleName());\n-        command.add(RUNNER_ARG);\n-        oa = ProcessTools.executeProcess(new ProcessBuilder(command));\n-        oa.shouldHaveExitValue(successExpected ? 0 : 1);\n-        for (String output : ALWAYS_UNEXPECTED_LOG_MSGS) {\n-            oa.shouldNotContain(output);\n-        }\n-    }\n-\n-    private void addSystemPropertiesAsJvmArgs(List<String> command) {\n-        Map<String, String> allSystemProps = new LinkedHashMap<>(systemProps);\n-        if (extraPropsFile != null) {\n-            allSystemProps.putAll(extraPropsFile.getSystemProperties());\n-        }\n-        for (Map.Entry<String, String> e : allSystemProps.entrySet()) {\n-            command.add(\"-D\" + e.getKey() + \"=\" + e.getValue());\n-        }\n-    }\n-\n-    void assertSuccess() throws Exception {\n-        execute(true);\n-\n-        \/\/ Ensure every file was processed by checking a unique property used as\n-        \/\/ a flag. Each file defines <fileName>=applied.\n-        \/\/\n-        \/\/ For example:\n-        \/\/\n-        \/\/   file0\n-        \/\/   ---------------\n-        \/\/   file0=applied\n-        \/\/   include file1\n-        \/\/\n-        \/\/   file1\n-        \/\/   ---------------\n-        \/\/   file1=applied\n-        \/\/\n-        \/\/ The assertion would be file0 == applied AND file1 == applied.\n-        \/\/\n-        if (extraPropsFile != null) {\n-            extraPropsFile.assertApplied(oa);\n-        }\n-        if (expectedOverrideAll) {\n-            \/\/ When overriding with an extra file, check that neither\n-            \/\/ the master file nor its includes are visible.\n-            oa.shouldContain(OVERRIDING_LOG_MSG);\n-            masterPropsFile.assertWasOverwritten(oa);\n-        } else {\n-            oa.shouldNotContain(OVERRIDING_LOG_MSG);\n-            masterPropsFile.assertApplied(oa);\n-        }\n-\n-        \/\/ Ensure the last included file overwrote a fixed property. Each file\n-        \/\/ defines last-file=<fileName>.\n-        \/\/\n-        \/\/ For example:\n-        \/\/\n-        \/\/   file0\n-        \/\/   ---------------\n-        \/\/   last-file=file0\n-        \/\/   include file1\n-        \/\/\n-        \/\/   file1\n-        \/\/   ---------------\n-        \/\/   last-file=file1\n-        \/\/\n-        \/\/ The assertion would be last-file == file1.\n-        \/\/\n-        PropsFile lastFile = (extraPropsFile == null ?\n-                masterPropsFile : extraPropsFile).getLastFile();\n-        oa.shouldContain(FilesManager.LAST_FILE_PROP_NAME + \"=\" +\n-                lastFile.fileName);\n-        oa.stdoutShouldContain(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n-                lastFile.fileName);\n-    }\n-\n-    void assertError(String message) throws Exception {\n-        execute(false);\n-        oa.shouldContain(message);\n-    }\n-\n-    OutputAnalyzer getOutputAnalyzer() {\n-        return oa;\n-    }\n-}\n","filename":"test\/jdk\/java\/security\/Security\/ConfigFileTest.java","additions":0,"deletions":927,"binary":false,"changes":927,"status":"deleted"},{"patch":"@@ -0,0 +1,937 @@\n+\/*\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+import sun.net.www.ParseUtil;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.Method;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.nio.CharBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.security.Security;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @summary Tests security properties passed through java.security,\n+ *   java.security.properties or included from other properties files.\n+ * @bug 4303068 8155246 8292297 8292177 8281658 8319332\n+ * @modules java.base\/sun.net.www\n+ * @library \/test\/lib\n+ * @run main ExtraFileAndIncludes\n+ *\/\n+\n+public class ExtraFileAndIncludes {\n+    static final String SEPARATOR_THIN = \"----------------------------\";\n+\n+    private static void printTestHeader(String testName) {\n+        System.out.println();\n+        System.out.println(SEPARATOR_THIN);\n+        System.out.println(testName);\n+        System.out.println(SEPARATOR_THIN);\n+        System.out.println();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 1 && Executor.RUNNER_ARG.equals(args[0])) {\n+            \/\/ Executed by a test-launched JVM.\n+            \/\/ Force the initialization of java.security.Security.\n+            Security.getProviders();\n+            Security.setProperty(\"postInitTest\", \"shouldNotRecord\");\n+            System.out.println(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n+                    Security.getProperty(FilesManager.LAST_FILE_PROP_NAME));\n+            assertTestSecuritySetPropertyShouldNotInclude();\n+        } else {\n+            \/\/ Executed by the test JVM.\n+            try (FilesManager filesMgr = new FilesManager()) {\n+                for (Method m :\n+                        ExtraFileAndIncludes.class.getDeclaredMethods()) {\n+                    if (m.getName().startsWith(\"test\")) {\n+                        printTestHeader(m.getName());\n+                        Executor.run(m, filesMgr);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Success cases\n+     *\/\n+\n+    static void testShowSettings(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Sanity test passing the -XshowSettings:security option.\n+        ex.addJvmArg(\"-XshowSettings:security\");\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.assertSuccess();\n+        ex.getOutputAnalyzer()\n+                .shouldContain(\"Security properties:\")\n+                .shouldContain(\"Security provider static configuration:\")\n+                .shouldContain(\"Security TLS configuration\");\n+    }\n+\n+    static void testIncludeBasic(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile(ExtraMode.FILE_URI);\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+        PropsFile file2 = filesMgr.newFile(\"dir1\/dir2\/file2.properties\");\n+\n+        masterFile.addAbsoluteInclude(file0);\n+        extraFile.addRelativeInclude(file2);\n+        file2.addAbsoluteInclude(file1);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.setExtraFile(extraFile, false);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testRepeatedInclude(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+\n+        masterFile.addAbsoluteInclude(file0);\n+        masterFile.addAbsoluteInclude(file1);\n+        masterFile.addAbsoluteInclude(file0);\n+        file1.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testIncludeWithOverrideAll(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile(ExtraMode.HTTP_SERVED);\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+\n+        masterFile.addRelativeInclude(file0);\n+        extraFile.addAbsoluteInclude(file1);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.setExtraFile(extraFile, true);\n+        ex.assertSuccess();\n+    }\n+\n+    static void extraPropertiesByHelper(Executor ex, FilesManager filesMgr,\n+            ExtraMode mode) throws Exception {\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile(mode);\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        extraFile.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, true);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testExtraPropertiesByPathAbsolute(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        extraPropertiesByHelper(ex, filesMgr, ExtraMode.PATH_ABS);\n+    }\n+\n+    static void testExtraPropertiesByPathRelative(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        extraPropertiesByHelper(ex, filesMgr, ExtraMode.PATH_REL);\n+    }\n+\n+    static void specialCharsIncludes(Executor ex, FilesManager filesMgr,\n+            char specialChar, ExtraMode extraMode, boolean useRelativeIncludes)\n+            throws Exception {\n+        String suffix = specialChar + \".properties\";\n+        ExtraPropsFile extraFile;\n+        PropsFile file0, file1;\n+        try {\n+            extraFile = filesMgr.newExtraFile(\"extra\" + suffix, extraMode);\n+            file0 = filesMgr.newFile(\"file0\" + suffix);\n+            file1 = filesMgr.newFile(\"file1\" + suffix);\n+        } catch (InvalidPathException ipe) {\n+            \/\/ The platform encoding may not allow to create files with some\n+            \/\/ special characters. Skip the test in these cases.\n+            return;\n+        }\n+\n+        if (useRelativeIncludes) {\n+            extraFile.addRelativeInclude(file0);\n+        } else {\n+            extraFile.addAbsoluteInclude(file0);\n+        }\n+        extraFile.addAbsoluteInclude(file1);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, false);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testUnicodeIncludes1(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, '\\u2022', ExtraMode.PATH_ABS, true);\n+    }\n+\n+    static void testUnicodeIncludes2(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, '\\u2022', ExtraMode.FILE_URI, true);\n+    }\n+\n+    static void testUnicodeIncludes3(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/tmp\/extra•.properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                ExtraMode.RAW_FILE_URI1, false);\n+    }\n+\n+    static void testUnicodeIncludes4(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/\/\/tmp\/extra•.properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                ExtraMode.RAW_FILE_URI2, false);\n+    }\n+\n+    static void testSpaceIncludes1(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, ' ', ExtraMode.PATH_ABS, true);\n+    }\n+\n+    static void testSpaceIncludes2(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, ' ', ExtraMode.FILE_URI, true);\n+    }\n+\n+    static void testSpaceIncludes3(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/tmp\/extra .properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, ' ', ExtraMode.RAW_FILE_URI1, false);\n+    }\n+\n+    static void testSpaceIncludes4(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/\/\/tmp\/extra .properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, ' ', ExtraMode.RAW_FILE_URI2, false);\n+    }\n+\n+    static void notOverrideOnFailureHelper(Executor ex, FilesManager filesMgr,\n+            String nonExistentExtraFile) throws Exception {\n+        \/\/ An overriding extra properties file that does not exist\n+        \/\/ should not erase properties from the master file.\n+        ex.setIgnoredExtraFile(nonExistentExtraFile, true);\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.assertSuccess();\n+        ex.getOutputAnalyzer().shouldContain(\"unable to load security \" +\n+                \"properties from \" + nonExistentExtraFile);\n+    }\n+\n+    static void testNotOverrideOnEmptyFailure(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"\");\n+        ex.getOutputAnalyzer()\n+                .shouldContain(\"Empty extra properties file path\");\n+    }\n+\n+    static void testNotOverrideOnURLFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr,\n+                \"file:\/\/\/nonExistentFile.properties\");\n+    }\n+\n+    static void testNotOverrideOnPathFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"nonExistentFile.properties\");\n+    }\n+\n+    static void testNotOverrideOnDirFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/\");\n+        ex.getOutputAnalyzer().shouldContain(\"Is a directory\");\n+    }\n+\n+    static void testNotOverrideOnBadFileURLFailure(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/%00\");\n+    }\n+\n+    static void testDisabledExtraPropertiesFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        masterFile.addRawProperty(\"security.overridePropertiesFile\", \"false\");\n+\n+        ex.setMasterFile(masterFile);\n+        ex.setIgnoredExtraFile(file0.path.toString(), true);\n+        ex.assertSuccess();\n+    }\n+\n+    static final String SECURITY_SET_PROP_FILE_PATH =\n+            \"testSecuritySetPropertyShouldNotInclude.propsFilePath\";\n+\n+    static void testSecuritySetPropertyShouldNotInclude(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        ex.addSystemProp(SECURITY_SET_PROP_FILE_PATH, file0.path.toString());\n+        ex.setMasterFile(masterFile);\n+        ex.assertSuccess();\n+    }\n+\n+    static void assertTestSecuritySetPropertyShouldNotInclude() {\n+        \/\/ This check is executed by the launched JVM.\n+        String propsFilePath = System.getProperty(SECURITY_SET_PROP_FILE_PATH);\n+        if (propsFilePath != null) {\n+            String name = Path.of(propsFilePath).getFileName().toString();\n+            String setPropInvokeRepr = \"Security.setProperty(\\\"include\\\", \" +\n+                    \"\\\"\" + propsFilePath + \"\\\")\";\n+            try {\n+                Security.setProperty(\"include\", propsFilePath);\n+                throw new RuntimeException(setPropInvokeRepr + \" was \" +\n+                        \"expected to throw IllegalArgumentException.\");\n+            } catch (IllegalArgumentException expected) {}\n+            if (FilesManager.APPLIED_PROP_VALUE.equals(\n+                    Security.getProperty(name))) {\n+                throw new RuntimeException(setPropInvokeRepr + \" caused \" +\n+                        \"a file inclusion.\");\n+            }\n+            try {\n+                Security.getProperty(\"include\");\n+                throw new RuntimeException(\"Security.getProperty(\\\"include\\\")\" +\n+                        \" was expected to throw IllegalArgumentException.\");\n+            } catch (IllegalArgumentException expected) {}\n+        }\n+    }\n+\n+    \/*\n+     * Error cases\n+     *\/\n+\n+    static void testCannotResolveRelativeFromHTTPServed(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile(ExtraMode.HTTP_SERVED);\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        extraFile.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, true);\n+        ex.assertError(\"InternalError: Cannot resolve '\" + file0.fileName +\n+                \"' relative path when included from a non-regular \" +\n+                \"properties file (e.g. HTTP served file)\");\n+    }\n+\n+    static void testCannotIncludeCycles(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+\n+        \/\/ Includes chain: master -> file0 -> file1 -> master.\n+        file1.addRelativeInclude(masterFile);\n+        file0.addRelativeInclude(file1);\n+        masterFile.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\"Cyclic include\");\n+        ex.getOutputAnalyzer().stderrShouldMatch(\"\\\\QInternalError: Cyclic \" +\n+                \"include of '\\\\E[^']+\\\\Q\" + masterFile.fileName + \"'\\\\E\");\n+    }\n+\n+    static void testCannotIncludeURL(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile(ExtraMode.HTTP_SERVED);\n+\n+        masterFile.addRawProperty(\"include\", extraFile.url.toString());\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\"InternalError: Unable to include 'http:\/\/127.0.0.1:\");\n+    }\n+\n+    static void testCannotIncludeNonexistentFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+\n+        String nonexistentPath = \"\/nonExistentFile.properties\";\n+        masterFile.addRawProperty(\"include\", nonexistentPath);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\n+                \"InternalError: Unable to include '\" + nonexistentPath + \"'\");\n+    }\n+\n+    static void testMustHaveMasterFile(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Launch a JDK without a master java.security file present.\n+        ex.assertError(\"InternalError: Error loading java.security file\");\n+    }\n+\n+    static void testMustHaveMasterFileEvenWithExtraFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        \/\/ Launch a JDK without a master java.security file present, but with an\n+        \/\/ extra file passed. Since the \"security.overridePropertiesFile=true\"\n+        \/\/ security property is missing, it should fail anyway.\n+        ex.setExtraFile(filesMgr.newExtraFile(ExtraMode.FILE_URI), true);\n+        ex.assertError(\"InternalError: Error loading java.security file\");\n+    }\n+}\n+\n+sealed class PropsFile permits ExtraPropsFile {\n+    protected static final class Include {\n+        final PropsFile propsFile;\n+        final String value;\n+\n+        private Include(PropsFile propsFile, String value) {\n+            this.propsFile = propsFile;\n+            this.value = value;\n+        }\n+\n+        static Include of(PropsFile propsFile) {\n+            return new Include(propsFile, propsFile.path.toString());\n+        }\n+\n+        static Include of(PropsFile propsFile, String value) {\n+            return new Include(propsFile, value);\n+        }\n+\n+        void assertProcessed(OutputAnalyzer oa) {\n+            oa.shouldContain(\"processing include: '\" + value + \"'\");\n+            oa.shouldContain(\"finished processing \" + propsFile.displayPath);\n+        }\n+    }\n+\n+    protected final List<Include> includes = new ArrayList<>();\n+    protected final PrintWriter writer;\n+    protected boolean includedFromExtra = false;\n+    protected Path displayPath;\n+    final String fileName;\n+    final Path path;\n+\n+    PropsFile(String fileName, Path path) throws IOException {\n+        this.fileName = fileName;\n+        this.path = path;\n+        this.displayPath = path;\n+        this.writer = new PrintWriter(Files.newOutputStream(path,\n+                StandardOpenOption.CREATE, StandardOpenOption.APPEND), true);\n+    }\n+\n+    private static String escape(String text, boolean escapeSpace) {\n+        StringBuilder sb = new StringBuilder(text.length());\n+        CharBuffer cb = CharBuffer.wrap(text);\n+        while (cb.hasRemaining()) {\n+            char c = cb.get();\n+            if (c == '\\\\' || escapeSpace && c == ' ') {\n+                sb.append('\\\\');\n+            }\n+            if (Character.UnicodeBlock.of(c) ==\n+                    Character.UnicodeBlock.BASIC_LATIN) {\n+                sb.append(c);\n+            } else {\n+                sb.append(\"\\\\u%04x\".formatted((int) c));\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private void addRawProperty(String key, String value, String sep) {\n+        writer.println(escape(key, true) + sep + escape(value, false));\n+    }\n+\n+    protected void addIncludeDefinition(Include include) {\n+        if (include.propsFile instanceof ExtraPropsFile) {\n+            throw new RuntimeException(\"ExtraPropsFile should not be included\");\n+        }\n+        includes.add(include);\n+        addRawProperty(\"include\", include.value, \" \");\n+    }\n+\n+    void addComment(String comment) {\n+        writer.println(\"# \" + comment);\n+    }\n+\n+    void addRawProperty(String key, String value) {\n+        addRawProperty(key, value, \"=\");\n+    }\n+\n+    void addAbsoluteInclude(PropsFile propsFile) {\n+        addIncludeDefinition(Include.of(propsFile));\n+    }\n+\n+    void addRelativeInclude(PropsFile propsFile) {\n+        Path rel = path.getParent().relativize(propsFile.path);\n+        addIncludeDefinition(Include.of(propsFile, rel.toString()));\n+        propsFile.displayPath = displayPath.getParent().resolve(rel);\n+    }\n+\n+    void assertApplied(OutputAnalyzer oa) {\n+        oa.shouldContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n+                FilesManager.APPLIED_PROP_VALUE);\n+        for (Include include : includes) {\n+            include.propsFile.assertApplied(oa);\n+            include.assertProcessed(oa);\n+        }\n+    }\n+\n+    void assertWasOverwritten(OutputAnalyzer oa) {\n+        oa.shouldNotContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n+                FilesManager.APPLIED_PROP_VALUE);\n+        for (Include include : includes) {\n+            if (!include.propsFile.includedFromExtra) {\n+                include.propsFile.assertWasOverwritten(oa);\n+            }\n+            include.assertProcessed(oa);\n+        }\n+    }\n+\n+    void markAsIncludedFromExtra() {\n+        includedFromExtra = true;\n+        for (Include include : includes) {\n+            include.propsFile.markAsIncludedFromExtra();\n+        }\n+    }\n+\n+    PropsFile getLastFile() {\n+        return includes.isEmpty() ?\n+                this : includes.getLast().propsFile.getLastFile();\n+    }\n+\n+    void close() {\n+        writer.close();\n+    }\n+}\n+\n+enum ExtraMode {\n+    HTTP_SERVED, FILE_URI, RAW_FILE_URI1, RAW_FILE_URI2, PATH_ABS, PATH_REL\n+}\n+\n+final class ExtraPropsFile extends PropsFile {\n+    private static final Path CWD = Path.of(\".\").toAbsolutePath();\n+    private final Map<String, String> systemProps = new LinkedHashMap<>();\n+    private final ExtraMode mode;\n+    final URI url;\n+\n+    ExtraPropsFile(String fileName, URI url, Path path, ExtraMode mode)\n+            throws IOException {\n+        super(fileName, path);\n+        this.url = url;\n+        this.mode = mode;\n+        if (mode == ExtraMode.PATH_REL) {\n+            this.displayPath = CWD.relativize(path);\n+        }\n+    }\n+\n+    @Override\n+    protected void addIncludeDefinition(Include include) {\n+        if (includes.isEmpty()) {\n+            String propName = \"props.fileName\";\n+            systemProps.put(propName, include.propsFile.fileName);\n+            include = Include.of(include.propsFile,\n+                    include.value.replace(include.propsFile.fileName,\n+                            \"${props.none}${\" + propName + \"}\"));\n+        }\n+        include.propsFile.markAsIncludedFromExtra();\n+        super.addIncludeDefinition(include);\n+    }\n+\n+    String getSysPropValue() {\n+        return switch (mode) {\n+            case HTTP_SERVED -> url.toString();\n+            case FILE_URI -> path.toUri().toString();\n+            case RAW_FILE_URI1 -> \"file:\" + path;\n+            case RAW_FILE_URI2 ->\n+                    \"file:\/\/\" + (path.startsWith(\"\/\") ? \"\" : \"\/\") + path;\n+            case PATH_ABS, PATH_REL -> displayPath.toString();\n+        };\n+    }\n+\n+    Map<String, String> getSystemProperties() {\n+        return Collections.unmodifiableMap(systemProps);\n+    }\n+}\n+\n+final class FilesManager implements Closeable {\n+    private static final Path ROOT_DIR = Path.of(\n+            ExtraFileAndIncludes.class.getSimpleName()).toAbsolutePath();\n+    private static final Path PROPS_DIR = ROOT_DIR.resolve(\"properties\");\n+    private static final Path JDK_DIR = ROOT_DIR.resolve(\"jdk\");\n+    private static final Path MASTER_FILE =\n+            JDK_DIR.resolve(\"conf\/security\/java.security\");\n+    private static final Path MASTER_FILE_TEMPLATE =\n+            MASTER_FILE.resolveSibling(\"java.security.template\");\n+    static final String JAVA_EXECUTABLE =\n+            JDK_DIR.resolve(\"bin\/java\").toString();\n+    static final String LAST_FILE_PROP_NAME = \"last-file\";\n+    static final String APPLIED_PROP_VALUE = \"applied\";\n+\n+    private final List<PropsFile> createdFiles;\n+    private final Set<String> fileNamesInUse;\n+    private final HttpServer httpServer;\n+    private final URI serverUri;\n+    private final long masterFileLines;\n+\n+    FilesManager() throws Exception {\n+        createdFiles = new ArrayList<>();\n+        fileNamesInUse = new HashSet<>();\n+        httpServer = HttpServer.create(\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n+        httpServer.createContext(\"\/\", this::handleRequest);\n+        InetSocketAddress address = httpServer.getAddress();\n+        httpServer.start();\n+        serverUri = new URI(\"http\", null, address.getHostString(),\n+                address.getPort(), null, null, null);\n+        copyJDK();\n+        try (Stream<String> s = Files.lines(MASTER_FILE_TEMPLATE)) {\n+            masterFileLines = s.count();\n+        }\n+    }\n+\n+    private static void copyJDK() throws Exception {\n+        Path testJDK = Path.of(Objects.requireNonNull(\n+                System.getProperty(\"test.jdk\"), \"unspecified test.jdk\"));\n+        if (!Files.exists(testJDK)) {\n+            throw new RuntimeException(\"test.jdk -> nonexistent JDK\");\n+        }\n+        Files.createDirectories(JDK_DIR);\n+        try (Stream<Path> pathStream = Files.walk(testJDK)) {\n+            pathStream.skip(1).forEach((Path file) -> {\n+                try {\n+                    Files.copy(file, JDK_DIR.resolve(testJDK.relativize(file)),\n+                            StandardCopyOption.COPY_ATTRIBUTES);\n+                } catch (IOException ioe) {\n+                    throw new UncheckedIOException(ioe);\n+                }\n+            });\n+        }\n+        Files.move(MASTER_FILE, MASTER_FILE_TEMPLATE);\n+    }\n+\n+    private void handleRequest(HttpExchange x) throws IOException {\n+        String rawPath = x.getRequestURI().getRawPath();\n+        Path f = ROOT_DIR.resolve(x.getRequestURI().getPath().substring(1));\n+        int statusCode;\n+        byte[] responseBody;\n+        \/\/ Check for unescaped space, unresolved parent or backward slash.\n+        if (rawPath.matches(\"^.*( |(\\\\.|%2[Ee]){2}|\\\\\\\\|%5[Cc]).*$\")) {\n+            statusCode = HttpURLConnection.HTTP_BAD_REQUEST;\n+            responseBody = new byte[0];\n+        } else if (Files.isRegularFile(f)) {\n+            x.getResponseHeaders().add(\"Content-type\", \"text\/plain\");\n+            statusCode = HttpURLConnection.HTTP_OK;\n+            responseBody = Files.readAllBytes(f);\n+        } else {\n+            statusCode = HttpURLConnection.HTTP_NOT_FOUND;\n+            responseBody = new byte[0];\n+        }\n+        System.out.println(\"[\" + Instant.now() + \"] \" +\n+                getClass().getSimpleName() + \": \" +\n+                x.getRequestMethod() + \" \" + rawPath + \" -> \" +\n+                statusCode + \" (\" + responseBody.length + \" bytes)\");\n+        try (OutputStream responseStream = x.getResponseBody()) {\n+            x.sendResponseHeaders(statusCode, responseBody.length);\n+            responseStream.write(responseBody);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface PropsFileBuilder {\n+        PropsFile build(String fileName, Path path) throws IOException;\n+    }\n+\n+    private PropsFile newFile(Path path, PropsFileBuilder builder)\n+            throws IOException {\n+        String fileName = path.getFileName().toString();\n+        if (!fileNamesInUse.add(fileName)) {\n+            \/\/ Names must be unique in order for the special\n+            \/\/ property <fileName>=<APPLIED_PROP_VALUE> to work.\n+            throw new RuntimeException(fileName + \" is repeated\");\n+        }\n+        Files.createDirectories(path.getParent());\n+        PropsFile propsFile = builder.build(fileName, path);\n+        propsFile.addComment(\"Property to determine if this properties file \" +\n+                \"was parsed and not overwritten:\");\n+        propsFile.addRawProperty(fileName, APPLIED_PROP_VALUE);\n+        propsFile.addComment(ExtraFileAndIncludes.SEPARATOR_THIN);\n+        propsFile.addComment(\"Property to be overwritten by every properties \" +\n+                \"file (master, extra or included):\");\n+        propsFile.addRawProperty(LAST_FILE_PROP_NAME, fileName);\n+        propsFile.addComment(ExtraFileAndIncludes.SEPARATOR_THIN);\n+        createdFiles.add(propsFile);\n+        return propsFile;\n+    }\n+\n+    PropsFile newFile(String relPathStr) throws IOException {\n+        return newFile(PROPS_DIR.resolve(relPathStr), PropsFile::new);\n+    }\n+\n+    PropsFile newMasterFile() throws IOException {\n+        Files.copy(MASTER_FILE_TEMPLATE, MASTER_FILE);\n+        return newFile(MASTER_FILE, PropsFile::new);\n+    }\n+\n+    ExtraPropsFile newExtraFile(ExtraMode mode) throws IOException {\n+        return newExtraFile(\"extra.properties\", mode);\n+    }\n+\n+    ExtraPropsFile newExtraFile(String extraFileName, ExtraMode mode)\n+            throws IOException {\n+        return (ExtraPropsFile) newFile(PROPS_DIR.resolve(extraFileName),\n+                (fileName, path) -> {\n+                    URI uri = serverUri.resolve(ParseUtil.encodePath(\n+                            ROOT_DIR.relativize(path).toString()));\n+                    return new ExtraPropsFile(fileName, uri, path, mode);\n+                });\n+    }\n+\n+    void reportCreatedFiles() throws IOException {\n+        for (PropsFile propsFile : createdFiles) {\n+            System.err.println();\n+            System.err.println(propsFile.path.toString());\n+            System.err.println(ExtraFileAndIncludes.SEPARATOR_THIN.repeat(3));\n+            try (Stream<String> lines = Files.lines(propsFile.path)) {\n+                long lineNumber = 1L;\n+                Iterator<String> it = lines.iterator();\n+                while (it.hasNext()) {\n+                    String line = it.next();\n+                    if (!propsFile.path.equals(MASTER_FILE) ||\n+                            lineNumber > masterFileLines) {\n+                        System.err.println(line);\n+                    }\n+                    lineNumber++;\n+                }\n+            }\n+            System.err.println();\n+        }\n+    }\n+\n+    void clear() throws IOException {\n+        if (!createdFiles.isEmpty()) {\n+            for (PropsFile propsFile : createdFiles) {\n+                propsFile.close();\n+                Files.delete(propsFile.path);\n+            }\n+            FileUtils.deleteFileTreeUnchecked(PROPS_DIR);\n+            createdFiles.clear();\n+            fileNamesInUse.clear();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        clear();\n+        httpServer.stop(0);\n+        FileUtils.deleteFileTreeUnchecked(ROOT_DIR);\n+    }\n+}\n+\n+final class Executor {\n+    static final String RUNNER_ARG = \"runner\";\n+    static final String INITIAL_PROP_LOG_MSG = \"Initial security property: \";\n+    private static final String OVERRIDING_LOG_MSG =\n+            \"overriding other security properties files!\";\n+    private static final String[] ALWAYS_UNEXPECTED_LOG_MSGS = {\n+            \"java.lang.AssertionError\",\n+            INITIAL_PROP_LOG_MSG + \"postInitTest=shouldNotRecord\",\n+            INITIAL_PROP_LOG_MSG + \"include=\",\n+    };\n+    private static final String JAVA_SEC_PROPS = \"java.security.properties\";\n+    private static final String CLASS_PATH = Objects.requireNonNull(\n+            System.getProperty(\"test.classes\"), \"unspecified test.classes\");\n+    private static final String DEBUG_ARG =\n+            \"-Xrunjdwp:transport=dt_socket,address=localhost:8000,suspend=y\";\n+    private final Map<String, String> systemProps = new LinkedHashMap<>(\n+            Map.of(\"java.security.debug\", \"all\", \"javax.net.debug\", \"all\",\n+                    \/\/ Ensure we get UTF-8 debug outputs in Windows:\n+                    \"stderr.encoding\", \"UTF-8\", \"stdout.encoding\", \"UTF-8\"));\n+    private final List<String> jvmArgs = new ArrayList<>(\n+            List.of(FilesManager.JAVA_EXECUTABLE, \"-enablesystemassertions\",\n+                    \/\/ Uncomment DEBUG_ARG to debug test-launched JVMs:\n+                    \"-classpath\", CLASS_PATH\/\/, DEBUG_ARG\n+            ));\n+    private PropsFile masterPropsFile;\n+    private ExtraPropsFile extraPropsFile;\n+    private boolean expectedOverrideAll = false;\n+    private OutputAnalyzer oa;\n+\n+    static void run(Method m, FilesManager filesMgr) throws Exception {\n+        try {\n+            m.invoke(null, new Executor(), filesMgr);\n+        } catch (Throwable e) {\n+            filesMgr.reportCreatedFiles();\n+            throw e;\n+        } finally {\n+            filesMgr.clear();\n+        }\n+    }\n+\n+    void addSystemProp(String key, String value) {\n+        systemProps.put(key, value);\n+    }\n+\n+    private void setRawExtraFile(String extraFile, boolean overrideAll) {\n+        addSystemProp(JAVA_SEC_PROPS, (overrideAll ? \"=\" : \"\") + extraFile);\n+    }\n+\n+    void setMasterFile(PropsFile masterPropsFile) {\n+        this.masterPropsFile = masterPropsFile;\n+    }\n+\n+    void setExtraFile(ExtraPropsFile extraPropsFile, boolean overrideAll) {\n+        this.extraPropsFile = extraPropsFile;\n+        expectedOverrideAll = overrideAll;\n+        setRawExtraFile(extraPropsFile.getSysPropValue(), overrideAll);\n+    }\n+\n+    void setIgnoredExtraFile(String extraPropsFile, boolean overrideAll) {\n+        setRawExtraFile(extraPropsFile, overrideAll);\n+        expectedOverrideAll = false;\n+    }\n+\n+    void addJvmArg(String arg) {\n+        jvmArgs.add(arg);\n+    }\n+\n+    private void execute(boolean successExpected) throws Exception {\n+        List<String> command = new ArrayList<>(jvmArgs);\n+        Collections.addAll(command, Utils.getTestJavaOpts());\n+        addSystemPropertiesAsJvmArgs(command);\n+        command.add(ExtraFileAndIncludes.class.getSimpleName());\n+        command.add(RUNNER_ARG);\n+        oa = ProcessTools.executeProcess(new ProcessBuilder(command));\n+        oa.shouldHaveExitValue(successExpected ? 0 : 1);\n+        for (String output : ALWAYS_UNEXPECTED_LOG_MSGS) {\n+            oa.shouldNotContain(output);\n+        }\n+    }\n+\n+    private void addSystemPropertiesAsJvmArgs(List<String> command) {\n+        Map<String, String> allSystemProps = new LinkedHashMap<>(systemProps);\n+        if (extraPropsFile != null) {\n+            allSystemProps.putAll(extraPropsFile.getSystemProperties());\n+        }\n+        for (Map.Entry<String, String> e : allSystemProps.entrySet()) {\n+            command.add(\"-D\" + e.getKey() + \"=\" + e.getValue());\n+        }\n+    }\n+\n+    void assertSuccess() throws Exception {\n+        execute(true);\n+\n+        \/\/ Ensure every file was processed by checking a unique property used as\n+        \/\/ a flag. Each file defines <fileName>=applied.\n+        \/\/\n+        \/\/ For example:\n+        \/\/\n+        \/\/   file0\n+        \/\/   ---------------\n+        \/\/   file0=applied\n+        \/\/   include file1\n+        \/\/\n+        \/\/   file1\n+        \/\/   ---------------\n+        \/\/   file1=applied\n+        \/\/\n+        \/\/ The assertion would be file0 == applied AND file1 == applied.\n+        \/\/\n+        if (extraPropsFile != null) {\n+            extraPropsFile.assertApplied(oa);\n+        }\n+        if (expectedOverrideAll) {\n+            \/\/ When overriding with an extra file, check that neither\n+            \/\/ the master file nor its includes are visible.\n+            oa.shouldContain(OVERRIDING_LOG_MSG);\n+            masterPropsFile.assertWasOverwritten(oa);\n+        } else {\n+            oa.shouldNotContain(OVERRIDING_LOG_MSG);\n+            masterPropsFile.assertApplied(oa);\n+        }\n+\n+        \/\/ Ensure the last included file overwrote a fixed property. Each file\n+        \/\/ defines last-file=<fileName>.\n+        \/\/\n+        \/\/ For example:\n+        \/\/\n+        \/\/   file0\n+        \/\/   ---------------\n+        \/\/   last-file=file0\n+        \/\/   include file1\n+        \/\/\n+        \/\/   file1\n+        \/\/   ---------------\n+        \/\/   last-file=file1\n+        \/\/\n+        \/\/ The assertion would be last-file == file1.\n+        \/\/\n+        PropsFile lastFile = (extraPropsFile == null ?\n+                masterPropsFile : extraPropsFile).getLastFile();\n+        oa.shouldContain(FilesManager.LAST_FILE_PROP_NAME + \"=\" +\n+                lastFile.fileName);\n+        oa.stdoutShouldContain(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n+                lastFile.fileName);\n+    }\n+\n+    void assertError(String message) throws Exception {\n+        execute(false);\n+        oa.shouldContain(message);\n+    }\n+\n+    OutputAnalyzer getOutputAnalyzer() {\n+        return oa;\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/ExtraFileAndIncludes.java","additions":937,"deletions":0,"binary":false,"changes":937,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2026, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/*\n+ * @test\n+ * @summary Ensures the java executable is able to load extra security\n+ * properties files from anonymous files and pipes.\n+ * @bug 8352728\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/java.io:+open\n+ * @library \/test\/lib\n+ * @run main LinuxAnonymousFiles\n+ *\/\n+\n+public class LinuxAnonymousFiles {\n+    private static final String TEST_PROP = \"property.name=PROPERTY_VALUE\";\n+\n+    private static final class AnonymousFile implements AutoCloseable {\n+        public final Path fdPath;\n+        private final FileInputStream fis;\n+\n+        private AnonymousFile(CharSequence content) throws Exception {\n+            Path tmp = Files.createTempFile(\"anonymous-file-\", \"\");\n+            Files.writeString(tmp, content + System.lineSeparator());\n+            fis = new FileInputStream(tmp.toFile());\n+            Files.delete(tmp);\n+            \/\/ Now the file is regular but anonymous, and will be unlinked\n+            \/\/ when we close the last file descriptor referring to it. The\n+            \/\/ fis instance ensures we keep it alive until close() is invoked.\n+            Field field = FileDescriptor.class.getDeclaredField(\"fd\");\n+            field.setAccessible(true);\n+            int fd = field.getInt(fis.getFD());\n+            fdPath = Path.of(\"\/proc\/self\").toRealPath().resolve(\"fd\/\" + fd);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            fis.close();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path java = Path.of(System.getProperty(\"test.jdk\"), \"bin\", \"java\");\n+        try (AnonymousFile af = new AnonymousFile(\"include \/dev\/stdin\")) {\n+            ProcessTools.executeProcess(new ProcessBuilder(java.toString(),\n+                            \"-Djava.security.debug=properties\",\n+                            \"-Djava.security.properties=\" + af.fdPath,\n+                            \"-XshowSettings:security:properties\", \"-version\"),\n+                    TEST_PROP).shouldHaveExitValue(0).shouldContain(TEST_PROP);\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/LinuxAnonymousFiles.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -1,1 +0,0 @@\n-policy.url.2=file:${test.src}\/SecurityPropFile.policy\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/SecurityPropFile.file","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4303068\n- * @summary be allowed to specify the security properties file\n- *      as a -D system property\n- *\n- * @run main\/othervm -Djava.security.properties=${test.src}\/SecurityPropFile.file -Djava.security.debug=properties SecurityPropFile\n- *\/\n-\n-public class SecurityPropFile {\n-    public static void main(String[] args) {\n-        System.out.println(java.security.Security.getProperty\n-                                (\"policy.provider\"));\n-        System.out.println(java.security.Security.getProperty\n-                                (\"policy.url.1\"));\n-        System.out.println(java.security.Security.getProperty\n-                                (\"policy.url.2\"));\n-    }\n-}\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/SecurityPropFile.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2026, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.AclEntry;\n+import java.nio.file.attribute.AclEntryType;\n+import java.nio.file.attribute.AclFileAttributeView;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Ensures java.security is loadable in Windows, even when the user\n+ * does not have permissions on one of the parent directories.\n+ * @bug 8352728\n+ * @requires os.family == \"windows\"\n+ * @library \/test\/lib\n+ * @run main WindowsParentDirPermissions\n+ *\/\n+\n+public class WindowsParentDirPermissions {\n+    private static AutoCloseable restrictedAcl(Path path) throws IOException {\n+        AclFileAttributeView view =\n+                Files.getFileAttributeView(path, AclFileAttributeView.class);\n+        List<AclEntry> originalAcl = List.copyOf(view.getAcl());\n+        view.setAcl(List.of(AclEntry.newBuilder().setType(AclEntryType.DENY)\n+                .setPrincipal(Files.getOwner(path)).build()));\n+        return () -> view.setAcl(originalAcl);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path temp = Files.createTempDirectory(\"JDK-8352728-tmp-\");\n+        try (AutoCloseable a1 = () -> FileUtils.deleteFileTreeUnchecked(temp)) {\n+            \/\/ Copy the jdk to a different directory\n+            Path originalJdk = Path.of(System.getProperty(\"test.jdk\"));\n+            Path jdk = temp.resolve(\"jdk-parent-dir\", \"jdk\");\n+            Files.createDirectories(jdk);\n+            FileUtils.copyDirectory(originalJdk, jdk);\n+\n+            \/\/ Remove current user permissions from jdk-parent-dir\n+            try (AutoCloseable a2 = restrictedAcl(jdk.getParent())) {\n+                \/\/ Make sure the permissions are affecting the current user\n+                try {\n+                    jdk.toRealPath();\n+                    throw new jtreg.SkippedException(\"Must run non-elevated!\");\n+                } catch (IOException expected) { }\n+\n+                \/\/ Execute the copied jdk, ensuring java.security.Security is\n+                \/\/ loaded (i.e. use -XshowSettings:security:properties)\n+                ProcessTools.executeProcess(new ProcessBuilder(\n+                        List.of(jdk.resolve(\"bin\", \"java.exe\").toString(),\n+                                \"-Djava.security.debug=properties\",\n+                                \"-XshowSettings:security:properties\",\n+                                \"-version\"))).shouldHaveExitValue(0);\n+            }\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/WindowsParentDirPermissions.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"}]}