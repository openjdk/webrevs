{"files":[{"patch":"@@ -29,0 +29,2 @@\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -30,0 +32,2 @@\n+#include \"oops\/symbol.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n@@ -31,0 +35,2 @@\n+\/\/ Detector for class names we wish to handle specially.\n+\/\/ It is either an exact string match or a string prefix match.\n@@ -44,0 +50,1 @@\n+    assert(_class_name != nullptr, \"caller resp.\");\n@@ -53,0 +60,1 @@\n+\/\/ Tell if ik has a name that matches one of the given specs.\n@@ -98,1 +106,5 @@\n-  if (ik->java_super() == vmClasses::Enum_klass()) {\n+  if (ik->is_hidden()) {\n+    return HeapShared::is_archivable_hidden_klass(ik);\n+  }\n+\n+  if (ik->is_enum_subclass()) {\n@@ -102,0 +114,150 @@\n+  \/\/ About \"static field that may hold a different value\" errors:\n+  \/\/\n+  \/\/ Automatic selection for aot-inited classes\n+  \/\/ ==========================================\n+  \/\/\n+  \/\/ When CDSConfig::is_initing_classes_at_dump_time() is enabled,\n+  \/\/ HeapShared::find_all_aot_initialized_classes() finds the classes of all\n+  \/\/ heap objects that are reachable from HeapShared::_run_time_special_subgraph,\n+  \/\/ and mark these classes as aot-inited. This preserves the initialized\n+  \/\/ mirrors of these classes, and their <clinit> methods are NOT executed\n+  \/\/ at runtime.\n+  \/\/\n+  \/\/ For example, with -XX:+AOTInvokeDynamicLinking, _run_time_special_subgraph\n+  \/\/ will contain some DirectMethodHandle objects. As a result, the DirectMethodHandle\n+  \/\/ class is automatically marked as aot-inited.\n+  \/\/\n+  \/\/ When a class is aot-inited, its static fields are already set up\n+  \/\/ by executing the <clinit> method at AOT assembly time.  Later on\n+  \/\/ in the production run, when the class would normally be\n+  \/\/ initialized, the VM performs guarding and synchronization as if\n+  \/\/ it were going to run the <clinit> again, but instead it simply\n+  \/\/ observes that that class was aot-inited.  The VM assumes that, if\n+  \/\/ it were to run <clinit> again, it would get a semantically\n+  \/\/ equivalent set of final field values, so it just adopts the\n+  \/\/ existing field values (from AOT assembly) and skips the call to\n+  \/\/ <clinit>.  There may at that point be fixups performed by ad hoc\n+  \/\/ code, if the VM recognizes a request in the library.\n+  \/\/\n+  \/\/ It is true that this is not generally correct for all possible\n+  \/\/ Java code.  A <clinit> method might have a side effect beyond\n+  \/\/ initializing the static fields.  It might send an email somewhere\n+  \/\/ noting the current time of day.  In that case, such an email\n+  \/\/ would have been sent during the AOT assembly phase, and the email\n+  \/\/ would NOT be sent again during production.  This is clearly NOT\n+  \/\/ what a user would want, if this were a general purpose facility.\n+  \/\/ But in fact it is only for certain well-behaved classes, which\n+  \/\/ are known NOT to have such side effects.  We know this because\n+  \/\/ the optimization (of skipping <clinit> for aot-init classes) is\n+  \/\/ only applied to classes fully defined by the JDK.\n+  \/\/\n+  \/\/ (A day may come when we figure out how to gracefully extend this\n+  \/\/ optimization to untrusted third parties, but it is not this day.)\n+  \/\/\n+  \/\/ Manual selection\n+  \/\/ ================\n+  \/\/\n+  \/\/ There are important cases where one aot-init class has a side\n+  \/\/ effect on another aot-class, a side effect which is not captured\n+  \/\/ in any static field value in either class.  The simplest example\n+  \/\/ is class A forces the initialization of class B.  In that case,\n+  \/\/ we need to aot-init either both classes or neither.  From looking\n+  \/\/ at the JDK state after AOT assembly is done, it is hard to tell\n+  \/\/ that A \"touched\" B and B might escape our notice.  Another common\n+  \/\/ example is A copying a field value from B.  We don't know where A\n+  \/\/ got the value, but it would be wrong to re-initialize B at\n+  \/\/ startup, while keeping the snapshot of the old B value in A.  In\n+  \/\/ general, if we aot-init A, we need to aot-init every class B that\n+  \/\/ somehow contributed to A's initial state, and every class C that\n+  \/\/ was somehow side-effected by A's initialization.  We say that the\n+  \/\/ aot-init of A is \"init-coupled\" to those of B and C.\n+  \/\/\n+  \/\/ So there are init-coupled classes that cannot be automatically discovered. For\n+  \/\/ example, DirectMethodHandle::IMPL_NAMES points to MethodHandles::IMPL_NAMES,\n+  \/\/ but the MethodHandles class is not automatically marked because there are\n+  \/\/ no archived instances of the MethodHandles type.\n+  \/\/\n+  \/\/ If we aot-initialize DirectMethodHandle, but allow MethodHandles to be\n+  \/\/ initialized at runtime, MethodHandles::IMPL_NAMES will get a different\n+  \/\/ value than DirectMethodHandle::IMPL_NAMES. This *may or may not* be a problem,\n+  \/\/ but to ensure compatibility, we should try to preserve the identity equality\n+  \/\/ of these two fields.\n+  \/\/\n+  \/\/ To do that, we add MethodHandles to the indy_specs[] table below.\n+  \/\/\n+  \/\/ Luckily we do not need to be all-knowing in order to choose which\n+  \/\/ items to add to that table.  We have tools to help detect couplings.\n+  \/\/\n+  \/\/ Automatic validation\n+  \/\/ ====================\n+  \/\/\n+  \/\/ CDSHeapVerifier is used to detect potential problems with identity equality.\n+  \/\/\n+  \/\/ A class B is assumed to be init-coupled to some aot-init class if\n+  \/\/ B has a field which points to a live object X in the AOT heap.\n+  \/\/ The live object X was created by some other class A which somehow\n+  \/\/ used B's reference to X, perhaps with the help of an intermediate\n+  \/\/ class Z.  Or, B pulled the reference to X from some other class\n+  \/\/ Y, and B obtained that reference from Y (or an intermediate Z).\n+  \/\/ It is not certain how X got into the heap, nor whether B\n+  \/\/ contributed it, but it is a good heuristic that B is init-coupled\n+  \/\/ to X's class or some other aot-init class.  In any case, B should\n+  \/\/ be made an aot-init class as well, unless a manual inspection\n+  \/\/ shows that would be a problem.  If there is a problem, then the\n+  \/\/ JDK code for B and\/or X probably needs refactoring.  If there is\n+  \/\/ no problem, we add B to the list.  Typically the same scan will\n+  \/\/ find any other accomplices Y, Z, etc.  One failure would be a\n+  \/\/ class Q whose only initialization action is to scribble a special\n+  \/\/ value into B, from which the value X is derived and then makes\n+  \/\/ its way into the heap.  In that case, the heuristic does not\n+  \/\/ identify Q.  It is (currently) a human responsibility, of JDK\n+  \/\/ engineers, not to write such dirty JDK code, or to repair it if\n+  \/\/ it crops up.  Eventually we may have tools, or even a user mode\n+  \/\/ with design rules and checks, that will vet our code base more\n+  \/\/ automatically.\n+  \/\/\n+  \/\/ To see how the tool detects the problem with MethodHandles::IMPL_NAMES:\n+  \/\/\n+  \/\/ - Comment out all the lines in indy_specs[] except the {nullptr} line.\n+  \/\/ - Rebuild the JDK\n+  \/\/\n+  \/\/ Then run the following:\n+  \/\/    java -XX:AOTMode=record -XX:AOTConfiguration=jc.aotconfig com.sun.tools.javac.Main\n+  \/\/    java -XX:AOTMode=create -Xlog:cds -XX:AOTCache=jc.aot -XX:AOTConfiguration=jc.aotconfig\n+  \/\/\n+  \/\/ You will see an error like this:\n+  \/\/\n+  \/\/ Archive heap points to a static field that may hold a different value at runtime:\n+  \/\/ Field: java\/lang\/invoke\/MethodHandles::IMPL_NAMES\n+  \/\/ Value: java.lang.invoke.MemberName$Factory\n+  \/\/ {0x000000060e906ae8} - klass: 'java\/lang\/invoke\/MemberName$Factory' - flags:\n+  \/\/\n+  \/\/  - ---- fields (total size 2 words):\n+  \/\/ --- trace begin ---\n+  \/\/ [ 0] {0x000000060e8deeb0} java.lang.Class (java.lang.invoke.DirectMethodHandle::IMPL_NAMES)\n+  \/\/ [ 1] {0x000000060e906ae8} java.lang.invoke.MemberName$Factory\n+  \/\/ --- trace end ---\n+  \/\/\n+  \/\/ Trouble-shooting\n+  \/\/ ================\n+  \/\/\n+  \/\/ If you see a \"static field that may hold a different value\" error, it's probably\n+  \/\/ because you've made some changes in the JDK core libraries (most likely\n+  \/\/ java.lang.invoke).\n+  \/\/\n+  \/\/  - Did you add a new static field to a class that could be referenced by\n+  \/\/    cached object instances of MethodType, MethodHandle, etc? You may need\n+  \/\/    to add that class to indy_specs[].\n+  \/\/  - Did you modify the <clinit> of the classes in java.lang.invoke such that\n+  \/\/    a static field now points to an object that should not be cached (e.g.,\n+  \/\/    a native resource such as a file descriptior, or a Thread)?\n+  \/\/\n+  \/\/ Note that these potential problems only occur when one class gets\n+  \/\/ the aot-init treatment, AND another class is init-coupled to it,\n+  \/\/ AND the coupling is not detected.  Currently there are a number\n+  \/\/ classes that get the aot-init treatment, in java.lang.invoke\n+  \/\/ because of invokedynamic.  They are few enough for now to be\n+  \/\/ manually tracked.  There may be more in the future.\n+\n+  \/\/ IS_PREFIX means that we match all class names that start with a\n+  \/\/ prefix.  Otherwise, it is an exact match, of just one class name.\n@@ -106,0 +268,1 @@\n+      \/\/ everybody's favorite super\n@@ -107,0 +270,2 @@\n+\n+      \/\/ above we selected all enums; we must include their super as well\n@@ -115,14 +280,11 @@\n-  {\n-    \/\/ These classes are special cases needed to support the aot-caching of\n-    \/\/ java.lang.invoke.MethodType instances:\n-    \/\/ - MethodType points to sun.invoke.util.Wrapper enums\n-    \/\/ - The Wrapper enums point to static final fields in these classes.\n-    \/\/   E.g., ConstantDescs.CD_Boolean.\n-    \/\/ - If we re-run the <clinit> of these classes again during the production\n-    \/\/   run, ConstantDescs.CD_Boolean will get a new value that has a different\n-    \/\/   object identity than the value referenced by the the Wrapper enums.\n-    \/\/ - However, Wrapper requires object identity (it allows the use of == to\n-    \/\/   test the equality of ClassDesc, etc).\n-    \/\/ Therefore, we must preserve the static fields of these classes from\n-    \/\/ the assembly phase.\n-    static AllowedSpec specs[] = {\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ This table was created with the help of CDSHeapVerifier.\n+    \/\/ Also, some $Holder classes are needed. E.g., Invokers.<clinit> explicitly\n+    \/\/ initializes Invokers$Holder. Since Invokers.<clinit> won't be executed\n+    \/\/ at runtime, we need to make sure Invokers$Holder is also aot-inited.\n+    \/\/\n+    \/\/ We hope we can reduce the size of this list over time, and move\n+    \/\/ the responsibility for identifying such classes into the JDK\n+    \/\/ code itself.  See tracking RFE JDK-8342481.\n+    static AllowedSpec indy_specs[] = {\n+      {\"java\/lang\/constant\/ConstantDescs\"},\n@@ -130,0 +292,20 @@\n+      {\"java\/lang\/invoke\/BoundMethodHandle\"},\n+      {\"java\/lang\/invoke\/BoundMethodHandle$Specializer\"},\n+      {\"java\/lang\/invoke\/BoundMethodHandle$Species_\", IS_PREFIX},\n+      {\"java\/lang\/invoke\/ClassSpecializer\"},\n+      {\"java\/lang\/invoke\/ClassSpecializer$\", IS_PREFIX},\n+      {\"java\/lang\/invoke\/DelegatingMethodHandle\"},\n+      {\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\"},     \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/DirectMethodHandle\"},\n+      {\"java\/lang\/invoke\/DirectMethodHandle$Constructor\"},\n+      {\"java\/lang\/invoke\/DirectMethodHandle$Holder\"},         \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/Invokers\"},\n+      {\"java\/lang\/invoke\/Invokers$Holder\"},                   \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/LambdaForm\"},\n+      {\"java\/lang\/invoke\/LambdaForm$Holder\"},                 \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/LambdaForm$NamedFunction\"},\n+      {\"java\/lang\/invoke\/MethodHandle\"},\n+      {\"java\/lang\/invoke\/MethodHandles\"},\n+      {\"java\/lang\/invoke\/SimpleMethodHandle\"},\n+      {\"java\/util\/Collections\"},\n+      {\"java\/util\/stream\/Collectors\"},\n@@ -132,1 +314,7 @@\n-      {\"java\/lang\/constant\/ConstantDescs\"},\n+\n+    \/\/ Can't include this, as it will pull in MethodHandleStatics which has many environment\n+    \/\/ dependencies (on system properties, etc).\n+    \/\/ MethodHandleStatics is an example of a class that must NOT get the aot-init treatment,\n+    \/\/ because of its strong reliance on (a) final fields which are (b) environmentally determined.\n+    \/\/{\"java\/lang\/invoke\/InvokerBytecodeGenerator\"},\n+\n@@ -135,1 +323,1 @@\n-    if (is_allowed(specs, ik)) {\n+    if (is_allowed(indy_specs, ik)) {\n@@ -143,11 +331,8 @@\n-#ifdef ASSERT\n-void AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(InstanceKlass* ik) {\n-  assert(ik->has_aot_initialized_mirror(), \"must be\");\n-\n-  InstanceKlass* s = ik->java_super();\n-  if (s != nullptr) {\n-    DEBUG_ONLY(ResourceMark rm);\n-    assert(s->is_initialized(), \"super class %s of aot-inited class %s must have been initialized\",\n-           s->external_name(), ik->external_name());\n-    AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(s);\n-  }\n+\/\/ TODO: currently we have a hard-coded list. We should turn this into\n+\/\/ an annotation: @jdk.internal.vm.annotation.RuntimeSetupRequired\n+\/\/ See JDK-8342481.\n+bool AOTClassInitializer::is_runtime_setup_required(InstanceKlass* ik) {\n+  return ik == vmClasses::Class_klass() ||\n+         ik == vmClasses::internal_Unsafe_klass() ||\n+         ik == vmClasses::ConcurrentHashMap_klass();\n+}\n@@ -155,8 +340,6 @@\n-  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n-  int len = interfaces->length();\n-  for (int i = 0; i < len; i++) {\n-    InstanceKlass* intf = interfaces->at(i);\n-    if (!intf->is_initialized()) {\n-      \/\/ Note: interfaces with no <clinit> are not marked as is_initialized().\n-      assert(intf->class_initializer() == nullptr, \"uninitialized super interface %s of aot-inited class %s must not have <clinit>\",\n-             intf->external_name(), ik->external_name());\n+void AOTClassInitializer::call_runtime_setup(InstanceKlass* ik, TRAPS) {\n+  assert(ik->has_aot_initialized_mirror(), \"sanity\");\n+  if (ik->is_runtime_setup_required()) {\n+    if (log_is_enabled(Info, cds, init)) {\n+      ResourceMark rm;\n+      log_info(cds, init)(\"Calling %s::runtimeSetup()\", ik->external_name());\n@@ -164,0 +347,4 @@\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_static(&result, ik,\n+                           vmSymbols::runtimeSetup(),\n+                           vmSymbols::void_method_signature(), CHECK);\n@@ -166,1 +353,1 @@\n-#endif\n+\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":224,"deletions":37,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -42,1 +42,2 @@\n-  static void assert_no_clinit_will_run_for_aot_init_class(InstanceKlass* ik) NOT_DEBUG_RETURN;\n+  static bool is_runtime_setup_required(InstanceKlass* ik);\n+  static void call_runtime_setup(InstanceKlass* ik, TRAPS);\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -97,1 +97,4 @@\n-    add_candidate(ik);\n+    if (CDSConfig::is_dumping_aot_linked_classes()) {\n+      bool v = try_add_candidate(ik);\n+      assert(v, \"must succeed for VM class\");\n+    }\n@@ -116,0 +119,5 @@\n+\n+  if (log_is_enabled(Info, cds, aot, link)) {\n+    ResourceMark rm;\n+    log_info(cds, aot, link)(\"%s %s %p\", class_category_name(ik), ik->external_name(), ik);\n+  }\n@@ -118,0 +126,4 @@\n+\/\/ ik is a candidate for aot-linking; see if it can really work\n+\/\/ that way, and return success or failure.  Not only must ik itself\n+\/\/ look like a class we can preload but its supers must also be\n+\/\/ aot-linkable.\n@@ -123,0 +135,1 @@\n+    \/\/ not loaded by a class loader which we know about\n@@ -131,1 +144,15 @@\n-    return false;\n+    assert(ik->shared_class_loader_type() != ClassLoader::OTHER, \"must have been set\");\n+    if (!CDSConfig::is_dumping_invokedynamic()) {\n+      return false;\n+    }\n+    if (!SystemDictionaryShared::should_hidden_class_be_archived(ik)) {\n+      return false;\n+    }\n+    if (HeapShared::is_lambda_proxy_klass(ik)) {\n+      InstanceKlass* nest_host = ik->nest_host_not_null();\n+      if (!try_add_candidate(nest_host)) {\n+        ResourceMark rm;\n+        log_warning(cds, aot, link)(\"%s cannot be aot-linked because it nest host is not aot-linked\", ik->external_name());\n+        return false;\n+      }\n+    }\n@@ -150,5 +177,0 @@\n-  if (log_is_enabled(Info, cds, aot, link)) {\n-    ResourceMark rm;\n-    log_info(cds, aot, link)(\"%s %s\", class_category_name(ik), ik->external_name());\n-  }\n-\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"memory\/allStatic.hpp\"\n@@ -32,0 +30,2 @@\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"utilities\/macros.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -123,3 +123,3 @@\n-  BOOT2,       \/\/ All boots classes that not in java.base are loaded in the 2nd phase\n-  PLATFORM,\n-  APP,\n+  BOOT2,       \/\/ All boot classes that not in java.base are loaded in the 2nd phase\n+  PLATFORM,    \/\/ Classes for platform loader, loaded in the 2nd phase\n+  APP,         \/\/ Classes for the app loader, loaded in the 2nd phase\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+  } else if (cp->tag_at(cp_index).is_invoke_dynamic()) {\n+    return is_indy_resolution_deterministic(cp, cp_index);\n@@ -111,1 +113,3 @@\n-      if (AOTClassLinker::is_candidate(ik)) {\n+      \/\/ Need to call try_add_candidate instead of is_candidate, as this may be called\n+      \/\/ before AOTClassLinker::add_candidates().\n+      if (AOTClassLinker::try_add_candidate(ik)) {\n@@ -252,0 +256,1 @@\n+      case Bytecodes::_invokehandle:\n@@ -304,0 +309,4 @@\n+  case Bytecodes::_invokehandle:\n+    InterpreterRuntime::cds_resolve_invokehandle(raw_index, cp, CHECK);\n+    break;\n+\n@@ -321,0 +330,195 @@\n+void AOTConstantPoolResolver::preresolve_indy_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n+  JavaThread* THREAD = current;\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  if (!CDSConfig::is_dumping_invokedynamic() || cp->cache() == nullptr) {\n+    return;\n+  }\n+\n+  assert(preresolve_list != nullptr, \"preresolve_indy_cp_entries() should not be called for \"\n+         \"regenerated LambdaForm Invoker classes, which should not have indys anyway.\");\n+\n+  Array<ResolvedIndyEntry>* indy_entries = cp->cache()->resolved_indy_entries();\n+  for (int i = 0; i < indy_entries->length(); i++) {\n+    ResolvedIndyEntry* rie = indy_entries->adr_at(i);\n+    int cp_index = rie->constant_pool_index();\n+    if (preresolve_list->at(cp_index) == true && !rie->is_resolved() && is_indy_resolution_deterministic(cp(), cp_index)) {\n+      InterpreterRuntime::cds_resolve_invokedynamic(i, cp, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Check the method signatures used by parameters to LambdaMetafactory::metafactory. Make sure we don't\n+\/\/ use types that have been excluded, or else we might end up creating MethodTypes that cannot be stored\n+\/\/ in the AOT cache.\n+bool AOTConstantPoolResolver::check_lambda_metafactory_signature(ConstantPool* cp, Symbol* sig, bool check_return_type) {\n+  ResourceMark rm;\n+  for (SignatureStream ss(sig); !ss.is_done(); ss.next()) {\n+    if (ss.is_reference()) {\n+      Symbol* type = ss.as_symbol();\n+      Klass* k = find_loaded_class(Thread::current(), cp->pool_holder()->class_loader(), type);\n+      if (k == nullptr) {\n+        return false;\n+      }\n+\n+      if (SystemDictionaryShared::check_for_exclusion(k)) {\n+        if (log_is_enabled(Warning, cds, resolve)) {\n+          ResourceMark rm;\n+          log_warning(cds, resolve)(\"Cannot aot-resolve Lambda proxy because %s is excluded\", k->external_name());\n+        }\n+        return false;\n+      }\n+\n+      if (check_return_type && ss.at_return_type()) {\n+        \/\/ <k> is the interface type implemented by the lambda proxy\n+        if (!k->is_interface()) {\n+          \/\/ cp->pool_holder() doesn't look like a valid class generated by javac\n+          return false;\n+        }\n+\n+        InstanceKlass* intf = InstanceKlass::cast(k);\n+        bool unsupported = intf->interface_needs_clinit_execution_as_super();\n+        if (log_is_enabled(Debug, cds, resolve)) {\n+          ResourceMark rm;\n+          log_debug(cds, resolve)(\"%s aot-resolve Lambda proxy of interface type %s\",\n+                                  unsupported ? \"Cannot\" : \"Can\", k->external_name());\n+        }\n+        if (unsupported) {\n+          return false;\n+        }\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+bool AOTConstantPoolResolver::check_lambda_metafactory_methodtype_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i) {\n+  int mt_index = cp->operand_argument_index_at(bsms_attribute_index, arg_i);\n+  if (!cp->tag_at(mt_index).is_method_type()) {\n+    \/\/ malformed class?\n+    return false;\n+  }\n+\n+  Symbol* sig = cp->method_type_signature_at(mt_index);\n+  if (log_is_enabled(Debug, cds, resolve)) {\n+    ResourceMark rm;\n+    log_debug(cds, resolve)(\"Checking MethodType for LambdaMetafactory BSM arg %d: %s\", arg_i, sig->as_C_string());\n+  }\n+\n+  return check_lambda_metafactory_signature(cp, sig, false);\n+}\n+\n+bool AOTConstantPoolResolver::check_lambda_metafactory_methodhandle_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i) {\n+  int mh_index = cp->operand_argument_index_at(bsms_attribute_index, arg_i);\n+  if (!cp->tag_at(mh_index).is_method_handle()) {\n+    \/\/ malformed class?\n+    return false;\n+  }\n+\n+  Symbol* sig = cp->method_handle_signature_ref_at(mh_index);\n+  if (log_is_enabled(Debug, cds, resolve)) {\n+    ResourceMark rm;\n+    log_debug(cds, resolve)(\"Checking MethodType of MethodHandle for LambdaMetafactory BSM arg %d: %s\", arg_i, sig->as_C_string());\n+  }\n+  return check_lambda_metafactory_signature(cp, sig, false);\n+}\n+\n+bool AOTConstantPoolResolver::is_indy_resolution_deterministic(ConstantPool* cp, int cp_index) {\n+  assert(cp->tag_at(cp_index).is_invoke_dynamic(), \"sanity\");\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return false;\n+  }\n+\n+  InstanceKlass* pool_holder = cp->pool_holder();\n+  if (!SystemDictionaryShared::is_builtin(pool_holder)) {\n+    return false;\n+  }\n+\n+  int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n+  int bsm_ref = cp->method_handle_index_at(bsm);\n+  Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n+  Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n+  Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n+\n+  \/\/ We currently support only StringConcatFactory::makeConcatWithConstants() and LambdaMetafactory::metafactory()\n+  \/\/ We should mark the allowed BSMs in the JDK code using a private annotation.\n+  \/\/ See notes on RFE JDK-8342481.\n+\n+  if (bsm_klass->equals(\"java\/lang\/invoke\/StringConcatFactory\") &&\n+      bsm_name->equals(\"makeConcatWithConstants\")) {\n+    return true;\n+  }\n+\n+  if (bsm_klass->equals(\"java\/lang\/invoke\/LambdaMetafactory\") &&\n+      bsm_name->equals(\"metafactory\") &&\n+      bsm_signature->equals(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;\"\n+                             \"Ljava\/lang\/String;\"\n+                             \"Ljava\/lang\/invoke\/MethodType;\"\n+                             \"Ljava\/lang\/invoke\/MethodType;\"\n+                             \"Ljava\/lang\/invoke\/MethodHandle;\"\n+                             \"Ljava\/lang\/invoke\/MethodType;\"\n+                            \")Ljava\/lang\/invoke\/CallSite;\")) {\n+    \/*\n+     * An indy callsite is associated with the following MethodType and MethodHandles:\n+     *\n+     * https:\/\/github.com\/openjdk\/jdk\/blob\/580eb62dc097efeb51c76b095c1404106859b673\/src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java#L293-L309\n+     *\n+     * MethodType factoryType         The expected signature of the {@code CallSite}.  The\n+     *                                parameter types represent the types of capture variables;\n+     *                                the return type is the interface to implement.   When\n+     *                                used with {@code invokedynamic}, this is provided by\n+     *                                the {@code NameAndType} of the {@code InvokeDynamic}\n+     *\n+     * MethodType interfaceMethodType Signature and return type of method to be\n+     *                                implemented by the function object.\n+     *\n+     * MethodHandle implementation    A direct method handle describing the implementation\n+     *                                method which should be called (with suitable adaptation\n+     *                                of argument types and return types, and with captured\n+     *                                arguments prepended to the invocation arguments) at\n+     *                                invocation time.\n+     *\n+     * MethodType dynamicMethodType   The signature and return type that should\n+     *                                be enforced dynamically at invocation time.\n+     *                                In simple use cases this is the same as\n+     *                                {@code interfaceMethodType}.\n+     *\/\n+    Symbol* factory_type__sig = cp->uncached_signature_ref_at(cp_index);\n+    if (log_is_enabled(Debug, cds, resolve)) {\n+      ResourceMark rm;\n+      log_debug(cds, resolve)(\"Checking indy callsite signature [%d]: %s\", cp_index, factory_type__sig->as_C_string());\n+    }\n+\n+    if (!check_lambda_metafactory_signature(cp, factory_type__sig, true)) {\n+      return false;\n+    }\n+\n+    int bsms_attribute_index = cp->bootstrap_methods_attribute_index(cp_index);\n+    int arg_count = cp->operand_argument_count_at(bsms_attribute_index);\n+    if (arg_count != 3) {\n+      \/\/ Malformed class?\n+      return false;\n+    }\n+\n+    \/\/ interfaceMethodType\n+    if (!check_lambda_metafactory_methodtype_arg(cp, bsms_attribute_index, 0)) {\n+      return false;\n+    }\n+\n+    \/\/ implementation\n+    if (!check_lambda_metafactory_methodhandle_arg(cp, bsms_attribute_index, 1)) {\n+      return false;\n+    }\n+\n+    \/\/ dynamicMethodType\n+    if (!check_lambda_metafactory_methodtype_arg(cp, bsms_attribute_index, 2)) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":205,"deletions":1,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -68,0 +68,1 @@\n+  static bool is_indy_resolution_deterministic(ConstantPool* cp, int cp_index);\n@@ -75,0 +76,5 @@\n+\n+  static bool check_lambda_metafactory_signature(ConstantPool* cp, Symbol* sig, bool check_return_type);\n+  static bool check_lambda_metafactory_methodtype_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i);\n+  static bool check_lambda_metafactory_methodhandle_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i);\n+\n@@ -81,0 +87,1 @@\n+  static void preresolve_indy_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list);\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,5 @@\n+bool AOTLinkedClassBulkLoader::_boot2_completed = false;\n+bool AOTLinkedClassBulkLoader::_platform_completed = false;\n+bool AOTLinkedClassBulkLoader::_app_completed = false;\n+bool AOTLinkedClassBulkLoader::_all_completed = false;\n+\n@@ -63,0 +68,2 @@\n+  _boot2_completed = true;\n+\n@@ -64,0 +71,2 @@\n+  _platform_completed = true;\n+\n@@ -65,0 +74,2 @@\n+  _app_completed = true;\n+  _all_completed = true;\n@@ -176,2 +187,1 @@\n-        \/\/ TODO: AOTClassLinking is not implemented for hidden class until JDK-8293336\n-        ShouldNotReachHere();\n+        load_hidden_class(loader_data, ik, CHECK);\n@@ -236,0 +246,66 @@\n+\/\/ Currently, we archive only three types of hidden classes:\n+\/\/    - LambdaForms\n+\/\/    - lambda proxy classes\n+\/\/    - StringConcat classes\n+\/\/ See HeapShared::is_archivable_hidden_klass().\n+\/\/\n+\/\/ LambdaForm classes (with names like java\/lang\/invoke\/LambdaForm$MH+0x800000015) logically\n+\/\/ belong to the boot loader, but they are usually stored in their own special ClassLoaderData to\n+\/\/ facilitate class unloading, as a LambdaForm may refer to a class loaded by a custom loader\n+\/\/ that may be unloaded.\n+\/\/\n+\/\/ We only support AOT-resolution of indys in the boot\/platform\/app loader, so there's no need\n+\/\/ to support class unloading. For simplicity, we put all archived LambdaForm classes in the\n+\/\/ \"main\" ClassLoaderData of the boot loader.\n+\/\/\n+\/\/ (Even if we were to support other loaders, we would still feel free to ignore any requirement\n+\/\/ of class unloading, for any class asset in the AOT cache.  Anything that makes it into the AOT\n+\/\/ cache has a lifetime dispensation from unloading.  After all, the AOT cache never grows, and\n+\/\/ we can assume that the user is content with its size, and doesn't need its footprint to shrink.)\n+\/\/\n+\/\/ Lambda proxy classes are normally stored in the same ClassLoaderData as their nest hosts, and\n+\/\/ StringConcat are normally stored in the main ClassLoaderData of the boot class loader. We\n+\/\/ do the same for the archived copies of such classes.\n+void AOTLinkedClassBulkLoader::load_hidden_class(ClassLoaderData* loader_data, InstanceKlass* ik, TRAPS) {\n+  assert(HeapShared::is_lambda_form_klass(ik) ||\n+         HeapShared::is_lambda_proxy_klass(ik) ||\n+         HeapShared::is_string_concat_klass(ik), \"sanity\");\n+  DEBUG_ONLY({\n+      assert(ik->java_super()->is_loaded(), \"must be\");\n+      for (int i = 0; i < ik->local_interfaces()->length(); i++) {\n+        assert(ik->local_interfaces()->at(i)->is_loaded(), \"must be\");\n+      }\n+    });\n+\n+  Handle pd;\n+  PackageEntry* pkg_entry = nullptr;\n+\n+  \/\/ Since a hidden class does not have a name, it cannot be reloaded\n+  \/\/ normally via the system dictionary. Instead, we have to finish the\n+  \/\/ loading job here.\n+\n+  if (HeapShared::is_lambda_proxy_klass(ik)) {\n+    InstanceKlass* nest_host = ik->nest_host_not_null();\n+    assert(nest_host->is_loaded(), \"must be\");\n+    pd = Handle(THREAD, nest_host->protection_domain());\n+    pkg_entry = nest_host->package();\n+  }\n+\n+  ik->restore_unshareable_info(loader_data, pd, pkg_entry, CHECK);\n+  SystemDictionary::load_shared_class_misc(ik, loader_data);\n+  ik->add_to_hierarchy(THREAD);\n+  assert(ik->is_loaded(), \"Must be in at least loaded state\");\n+\n+  DEBUG_ONLY({\n+      \/\/ Make sure we don't make this hidden class available by name, even if we don't\n+      \/\/ use any special ClassLoaderData.\n+      Handle loader(THREAD, loader_data->class_loader());\n+      ResourceMark rm(THREAD);\n+      assert(SystemDictionary::resolve_or_null(ik->name(), loader, pd, THREAD) == nullptr,\n+             \"hidden classes cannot be accessible by name: %s\", ik->external_name());\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION;\n+      }\n+    });\n+}\n+\n@@ -255,5 +331,1 @@\n-        \/\/ No <clinit> of ik or any of its supertypes will be executed.\n-        \/\/ Their mirrors were already initialized during AOT cache assembly.\n-        AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(ik);\n-\n-        ik->initialize_from_cds(CHECK);\n+        ik->initialize_with_aot_initialized_mirror(CHECK);\n@@ -266,0 +338,50 @@\n+\n+bool AOTLinkedClassBulkLoader::is_pending_aot_linked_class(Klass* k) {\n+  if (!CDSConfig::is_using_aot_linked_classes()) {\n+    return false;\n+  }\n+\n+  if (_all_completed) { \/\/ no more pending aot-linked classes\n+    return false;\n+  }\n+\n+  if (k->is_objArray_klass()) {\n+    k = ObjArrayKlass::cast(k)->bottom_klass();\n+  }\n+  if (!k->is_instance_klass()) {\n+    \/\/ type array klasses (and their higher domensions),\n+    \/\/ must have been loaded before a GC can ever happen.\n+    return false;\n+  }\n+\n+  \/\/ There's a small window during VM start-up where a not-yet loaded aot-linked\n+  \/\/ class k may be discovered by the GC during VM initialization. This can happen\n+  \/\/ when the heap contains an aot-cached instance of k, but k is not ready to be\n+  \/\/ loaded yet. (TODO: JDK-8342429 eliminates this possibility)\n+  \/\/\n+  \/\/ The following checks try to limit this window as much as possible for each of\n+  \/\/ the four AOTLinkedClassCategory of classes that can be aot-linked.\n+\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  if (ik->is_shared_boot_class()) {\n+    if (ik->module() != nullptr && ik->in_javabase_module()) {\n+      \/\/ AOTLinkedClassCategory::BOOT1 -- all aot-linked classes in\n+      \/\/ java.base must have been loaded before a GC can ever happen.\n+      return false;\n+    } else {\n+      \/\/ AOTLinkedClassCategory::BOOT2 classes cannot be loaded until\n+      \/\/ module system is ready.\n+      return !_boot2_completed;\n+    }\n+  } else if (ik->is_shared_platform_class()) {\n+    \/\/ AOTLinkedClassCategory::PLATFORM classes cannot be loaded until\n+    \/\/ the platform class loader is initialized.\n+    return !_platform_completed;\n+  } else if (ik->is_shared_app_class()) {\n+    \/\/ AOTLinkedClassCategory::APP cannot be loaded until the app class loader\n+    \/\/ is initialized.\n+    return !_app_completed;\n+  } else {\n+    return false;\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":129,"deletions":7,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -46,0 +46,4 @@\n+  static bool _boot2_completed;\n+  static bool _platform_completed;\n+  static bool _app_completed;\n+  static bool _all_completed;\n@@ -52,0 +56,1 @@\n+  static void load_hidden_class(ClassLoaderData* loader_data, InstanceKlass* ik, TRAPS);\n@@ -53,1 +58,0 @@\n-\n@@ -60,0 +64,2 @@\n+\n+  static bool is_pending_aot_linked_class(Klass* k);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"classfile\/classLoaderExt.hpp\"\n@@ -231,0 +233,4 @@\n+      if (klass->is_hidden()) {\n+        assert(klass->is_instance_klass(), \"must be\");\n+        assert(SystemDictionaryShared::should_hidden_class_be_archived(InstanceKlass::cast(klass)), \"must be\");\n+      }\n@@ -785,0 +791,1 @@\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_old_klasses);\n@@ -812,0 +819,1 @@\n+    const char* old = \"\";\n@@ -854,0 +862,6 @@\n+        if (CDSConfig::is_dumping_invokedynamic()) {\n+          assert(HeapShared::is_archivable_hidden_klass(ik), \"sanity\");\n+        } else {\n+          \/\/ Legacy CDS support for lambda proxies\n+          assert(HeapShared::is_lambda_proxy_klass(ik), \"sanity\");\n+        }\n@@ -889,1 +903,1 @@\n-      } else if (src_ik->java_super() == vmClasses::Enum_klass()) {\n+      } else if (src_ik->is_enum_subclass()) {\n@@ -894,0 +908,5 @@\n+      if (!ik->can_be_verified_at_dumptime()) {\n+        ADD_COUNT(num_old_klasses);\n+        old = \" old\";\n+      }\n+\n@@ -910,1 +929,1 @@\n-      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s%s%s%s\", i,\n+      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s%s%s%s%s\", i,\n@@ -912,1 +931,1 @@\n-                            kind, hidden, unlinked, generated, aotlinked_msg, inited_msg);\n+                            kind, hidden, old, unlinked, generated, aotlinked_msg, inited_msg);\n@@ -928,0 +947,1 @@\n+  log_info(cds)(\"      (old)            \" STATS_FORMAT, STATS_PARAMS(old_klasses));\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -440,4 +440,0 @@\n-    \/\/ Currently we have only Klass pointers in heap objects.\n-    \/\/ This needs to be relaxed when we support other types of native\n-    \/\/ pointers such as Method.\n-    assert(((Klass*)(*p))->is_klass(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -374,0 +374,7 @@\n+bool ArchiveUtils::has_aot_initialized_mirror(InstanceKlass* src_ik) {\n+  if (SystemDictionaryShared::is_excluded_class(src_ik)) {\n+    return false;\n+  }\n+  return ArchiveBuilder::current()->get_buffered_addr(src_ik)->has_aot_initialized_mirror();\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -254,1 +254,1 @@\n-\n+  static bool has_aot_initialized_mirror(InstanceKlass* src_ik);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-#include \"utilities\/growableArray.hpp\"\n-\n@@ -35,0 +33,1 @@\n+#include \"utilities\/growableArray.hpp\"\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+bool CDSConfig::_has_archived_invokedynamic = false;\n@@ -332,1 +333,0 @@\n-\n@@ -414,0 +414,8 @@\n+  if (AOTClassLinking) {\n+    \/\/ If AOTClassLinking is specified, enable all AOT optimizations by default.\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTInvokeDynamicLinking, true);\n+  } else {\n+    \/\/ AOTInvokeDynamicLinking depends on AOTClassLinking.\n+    FLAG_SET_ERGO(AOTInvokeDynamicLinking, false);\n+  }\n+\n@@ -479,0 +487,5 @@\n+bool CDSConfig::allow_only_single_java_thread() {\n+  \/\/ See comments in JVM_StartThread()\n+  return is_dumping_static_archive();\n+}\n+\n@@ -565,0 +578,11 @@\n+\n+bool CDSConfig::is_dumping_invokedynamic() {\n+  \/\/ Requires is_dumping_aot_linked_classes(). Otherwise the classes of some archived heap\n+  \/\/ objects used by the archive indy callsites may be replaced at runtime.\n+  return AOTInvokeDynamicLinking && is_dumping_aot_linked_classes() && is_dumping_heap();\n+}\n+\n+bool CDSConfig::is_loading_invokedynamic() {\n+  return UseSharedSpaces && is_using_full_module_graph() && _has_archived_invokedynamic;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  static bool _has_archived_invokedynamic;\n@@ -90,0 +91,3 @@\n+  \/\/ Misc CDS features\n+  static bool allow_only_single_java_thread()                NOT_CDS_RETURN_(false);\n+\n@@ -115,0 +119,4 @@\n+  static bool is_dumping_invokedynamic()                     NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_loading_invokedynamic()                     NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void set_has_archived_invokedynamic()               { CDS_JAVA_HEAP_ONLY(_has_archived_invokedynamic = true); }\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-         InstanceKlass::cast(k)->java_super() == vmClasses::Enum_klass();\n+         InstanceKlass::cast(k)->is_enum_subclass();\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -42,1 +45,1 @@\n-\/\/ static field that may be reinitialized at runtime. In the following example,\n+\/\/ static field that may be get a different value at runtime. In the following example,\n@@ -44,1 +47,2 @@\n-\/\/ correctly returns true when CDS disabled, but incorrectly returns false when CDS is enabled.\n+\/\/ correctly returns true when CDS disabled, but incorrectly returns false when CDS is enabled,\n+\/\/ because the archived archivedFoo.bar value is different than Bar.bar.\n@@ -47,1 +51,1 @@\n-\/\/     final Foo archivedFoo; \/\/ this field is archived by CDS\n+\/\/     static final Foo archivedFoo; \/\/ this field is archived by CDS\n@@ -127,0 +131,5 @@\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    ADD_EXCL(\"java\/lang\/invoke\/InvokerBytecodeGenerator\", \"MEMBERNAME_FACTORY\",    \/\/ D\n+                                                          \"INVOKER_SUPER_DESC\");   \/\/ E same as java.lang.constant.ConstantDescs::CD_Object\n+  }\n+\n@@ -134,3 +143,4 @@\n-    log_warning(cds, heap)(\"Scanned %d objects. Found %d case(s) where \"\n-                           \"an object points to a static field that may be \"\n-                           \"reinitialized at runtime.\", _archived_objs, _problems);\n+    log_error(cds, heap)(\"Scanned %d objects. Found %d case(s) where \"\n+                         \"an object points to a static field that \"\n+                         \"may hold a different value at runtime.\", _archived_objs, _problems);\n+    MetaspaceShared::unrecoverable_writing_error();\n@@ -157,1 +167,1 @@\n-      Klass* klass_of_field = static_obj_field->klass();\n+      Klass* field_type = static_obj_field->klass();\n@@ -177,9 +187,15 @@\n-      if (klass_of_field->has_archived_enum_objs()) {\n-        \/\/ This field is an Enum. If any instance of this Enum has been archived, we will archive\n-        \/\/ all static fields of this Enum as well.\n-        \/\/ See HeapShared::initialize_enum_klass().\n-        return;\n-      }\n-      if (klass_of_field->is_instance_klass()) {\n-        if (InstanceKlass::cast(klass_of_field)->is_initialized() &&\n-            AOTClassInitializer::can_archive_initialized_mirror(InstanceKlass::cast(klass_of_field))) {\n+\n+      if (field_type->is_instance_klass()) {\n+        InstanceKlass* field_ik = InstanceKlass::cast(field_type);\n+        if (field_ik->is_enum_subclass()) {\n+          if (field_ik->has_archived_enum_objs() || ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+            \/\/ This field is an Enum. If any instance of this Enum has been archived, we will archive\n+            \/\/ all static fields of this Enum as well.\n+            return;\n+          }\n+        }\n+\n+        if (field_ik->is_hidden() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          \/\/ We have a static field in a core-library class that points to a method reference, which\n+          \/\/ are safe to archive.\n+          guarantee(_ik->module()->name() == vmSymbols::java_base(), \"sanity\");\n@@ -188,1 +204,0 @@\n-      }\n@@ -190,2 +205,11 @@\n-      if (AOTClassInitializer::can_archive_initialized_mirror(_ik)) {\n-        return;\n+        if (field_ik == vmClasses::MethodType_klass()) {\n+          \/\/ The identity of MethodTypes are preserved between assembly phase and production runs\n+          \/\/ (by MethodType::AOTHolder::archivedMethodTypes). No need to check.\n+          return;\n+        }\n+\n+        if (field_ik == vmClasses::internal_Unsafe_klass() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          \/\/ There's only a single instance of jdk\/internal\/misc\/Unsafe, so all references will\n+          \/\/ be pointing to this singleton, which has been archived.\n+          return;\n+        }\n@@ -202,1 +226,2 @@\n-\/\/ loaded.\n+\/\/ loaded. Later, we will check if any archived objects reference one of\n+\/\/ these fields.\n@@ -214,0 +239,6 @@\n+    if (ArchiveUtils::has_aot_initialized_mirror(ik)) {\n+      \/\/ ik's <clinit> won't be executed at runtime, the static fields in\n+      \/\/ ik will carry their values to runtime.\n+      return;\n+    }\n+\n@@ -235,0 +266,3 @@\n+    if (info->_holder->is_hidden()) {\n+      return true;\n+    }\n@@ -236,0 +270,2 @@\n+    char* class_name = info->_holder->name()->as_C_string();\n+    char* field_name = info->_name->as_C_string();\n@@ -237,2 +273,2 @@\n-    ls.print_cr(\"Archive heap points to a static field that may be reinitialized at runtime:\");\n-    ls.print_cr(\"Field: %s::%s\", info->_holder->name()->as_C_string(), info->_name->as_C_string());\n+    ls.print_cr(\"Archive heap points to a static field that may hold a different value at runtime:\");\n+    ls.print_cr(\"Field: %s::%s\", class_name, field_name);\n@@ -280,0 +316,23 @@\n+const char* static_field_name(oop mirror, oop field) {\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  if (k->is_instance_klass()) {\n+    for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        switch (fd.field_type()) {\n+        case T_OBJECT:\n+        case T_ARRAY:\n+          if (mirror->obj_field(fd.offset()) == field) {\n+            return fs.name()->as_C_string();\n+          }\n+          break;\n+        default:\n+          break;\n+        }\n+      }\n+    }\n+  }\n+\n+  return \"<unknown>\";\n+}\n+\n@@ -295,1 +354,1 @@\n-    st->print(\" (%s)\", java_lang_Class::as_Klass(orig_obj)->external_name());\n+    st->print(\" (%s::%s)\", java_lang_Class::as_Klass(orig_obj)->external_name(), static_field_name(orig_obj, orig_field));\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":82,"deletions":23,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+  product(bool, AOTInvokeDynamicLinking, false, DIAGNOSTIC,                 \\\n+          \"AOT-link JVM_CONSTANT_InvokeDynamic entries in cached \"          \\\n+          \"ConstantPools\")                                                  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -602,0 +602,12 @@\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ The CP entry for the invokedynamic instruction will be resolved.\n+    \/\/ No need to do the following.\n+    return;\n+  }\n+\n+  \/\/ This is an older CDS optimization:\n+  \/\/ We store a pre-generated version of the lambda proxy class in the AOT cache,\n+  \/\/ which will be loaded via JVM_LookupLambdaProxyClassFromArchive().\n+  \/\/ This eliminate dynamic class generation of the proxy class, but we still need to\n+  \/\/ resolve the CP entry for the invokedynamic instruction, which may result in\n+  \/\/ generation of LambdaForm classes.\n@@ -844,0 +856,2 @@\n+    case JVM_CONSTANT_InvokeDynamic:\n+      preresolve_indy = true;\n@@ -858,0 +872,3 @@\n+  if (preresolve_indy) {\n+    AOTConstantPoolResolver::preresolve_indy_cp_entries(THREAD, ik, &preresolve_list);\n+  }\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -131,3 +131,9 @@\n-  \/\/ filter out java\/lang\/invoke\/BoundMethodHandle$Species...\n-  if (cfs != nullptr && cfs->source() != nullptr && strcmp(cfs->source(), \"_ClassSpecializer_generateConcreteSpeciesCode\") == 0) {\n-    return;\n+  if (cfs != nullptr && cfs->source() != nullptr) {\n+    if (strcmp(cfs->source(), \"_ClassSpecializer_generateConcreteSpeciesCode\") == 0) {\n+      return;\n+    }\n+\n+    if (strncmp(cfs->source(), \"__\", 2) == 0) {\n+      \/\/ generated class: __dynamic_proxy__, __JVM_LookupDefineClass__, etc\n+      return;\n+    }\n@@ -259,0 +265,12 @@\n+    Array<ResolvedIndyEntry>* indy_entries = cp->cache()->resolved_indy_entries();\n+    if (indy_entries != nullptr) {\n+      for (int i = 0; i < indy_entries->length(); i++) {\n+        ResolvedIndyEntry* rie = indy_entries->adr_at(i);\n+        int cp_index = rie->constant_pool_index();\n+        if (rie->is_resolved()) {\n+          list.at_put(cp_index, true);\n+          print = true;\n+        }\n+      }\n+    }\n+\n@@ -277,1 +295,2 @@\n-            rme->is_resolved(Bytecodes::_invokeinterface)) {\n+            rme->is_resolved(Bytecodes::_invokeinterface) ||\n+            rme->is_resolved(Bytecodes::_invokehandle)) {\n@@ -294,1 +313,2 @@\n-               cp_tag.value() == JVM_CONSTANT_InterfaceMethodref, \"sanity\");\n+               cp_tag.value() == JVM_CONSTANT_InterfaceMethodref ||\n+               cp_tag.value() == JVM_CONSTANT_InvokeDynamic, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -118,0 +118,4 @@\n+  msg.info(\"Indy   CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n+           _num_indy_cp_entries, _num_indy_cp_entries_archived,\n+           percent_of(_num_indy_cp_entries_archived, _num_indy_cp_entries),\n+           _num_indy_cp_entries_reverted);\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+  int _num_indy_cp_entries;\n+  int _num_indy_cp_entries_archived;\n+  int _num_indy_cp_entries_reverted;\n@@ -87,0 +90,3 @@\n+    _num_indy_cp_entries            = 0;\n+    _num_indy_cp_entries_archived   = 0;\n+    _num_indy_cp_entries_reverted   = 0;\n@@ -125,0 +131,6 @@\n+  void record_indy_cp_entry(bool archived, bool reverted) {\n+    _num_indy_cp_entries ++;\n+    _num_indy_cp_entries_archived += archived ? 1 : 0;\n+    _num_indy_cp_entries_reverted += reverted ? 1 : 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,2 @@\n-\n+  bool                         _is_required;\n+  bool                         _has_scanned_constant_pool;\n@@ -140,0 +141,2 @@\n+    _is_required = false;\n+    _has_scanned_constant_pool = false;\n@@ -217,0 +220,5 @@\n+  bool is_required() const                          { return _is_required; }\n+  void set_is_required()                            { _is_required = true; }\n+  bool has_scanned_constant_pool() const            { return _has_scanned_constant_pool; }\n+  void set_has_scanned_constant_pool()              { _has_scanned_constant_pool = true; }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -52,0 +51,1 @@\n+#include \"runtime\/vmThread.hpp\"\n@@ -115,1 +115,1 @@\n-    SystemDictionaryShared::check_excluded_classes();\n+    SystemDictionaryShared::find_all_archivable_classes();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -219,0 +219,1 @@\n+  _has_archived_invokedynamic = CDSConfig::is_dumping_invokedynamic();\n@@ -306,0 +307,1 @@\n+  st->print_cr(\"- has_archived_invokedynamic      %d\", _has_archived_invokedynamic);\n@@ -1057,0 +1059,2 @@\n+  check_main_module_name();\n+\n@@ -2438,0 +2442,30 @@\n+void FileMapInfo::check_main_module_name() {\n+  const char* runtime_main_module_name = Arguments::get_property(\"jdk.module.main\");\n+  const char* archived_main_module_name = main_module_name();\n+  bool no_archived_main_module_name = strcmp(archived_main_module_name, \"\") == 0;\n+\n+  log_info(cds)(\"_archived_main_module_name: '%s'\", archived_main_module_name);\n+  bool disable = false;\n+  if (runtime_main_module_name == nullptr) {\n+    if (!no_archived_main_module_name) {\n+      log_info(cds)(\"Module %s specified during dump time but not during runtime\", archived_main_module_name);\n+      disable = true;\n+    }\n+  } else {\n+    if (no_archived_main_module_name) {\n+      log_info(cds)(\"Module %s specified during runtime but not during dump time\", runtime_main_module_name);\n+      disable = true;\n+    } else if (strcmp(runtime_main_module_name, archived_main_module_name) != 0) {\n+      log_info(cds)(\"Mismatched modules: runtime %s dump time %s\", runtime_main_module_name, archived_main_module_name);\n+      disable = true;\n+    }\n+  }\n+\n+  if (disable) {\n+    log_info(cds)(\"Disabling optimized module handling\");\n+    CDSConfig::stop_using_optimized_module_handling();\n+  }\n+  log_info(cds)(\"optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+  log_info(cds)(\"full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n+}\n+\n@@ -2553,1 +2587,1 @@\n-  if (is_static() && !_has_full_module_graph) {\n+  if (is_static()) {\n@@ -2555,1 +2589,7 @@\n-    CDSConfig::stop_using_full_module_graph(\"archive was created without full module graph\");\n+    if (!_has_full_module_graph) {\n+      CDSConfig::stop_using_full_module_graph(\"archive was created without full module graph\");\n+    }\n+\n+    if (_has_archived_invokedynamic) {\n+      CDSConfig::set_has_archived_invokedynamic();\n+    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+  size_t _main_module_name_offset;      \/\/ property of \"jdk.module.main\"\n@@ -230,0 +231,1 @@\n+  bool   _has_archived_invokedynamic;   \/\/ Does the archive have aot-linked invokedynamic CP entries?\n@@ -267,0 +269,1 @@\n+  char* main_module_name()                 const { return from_mapped_offset(_main_module_name_offset); }\n@@ -290,0 +293,1 @@\n+  void set_main_module_name(char* p)             { set_as_offset(p, &_main_module_name_offset); }\n@@ -404,0 +408,2 @@\n+  char* main_module_name()                    const { return header()->main_module_name(); }\n+  void  set_main_module_name(char* p)         const { header()->set_main_module_name(p); }\n@@ -489,0 +495,1 @@\n+  void check_main_module_name();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+\n@@ -434,0 +435,26 @@\n+\/\/TODO: we eventually want a more direct test for these kinds of things.\n+\/\/For example the JVM could record some bit of context from the creation\n+\/\/of the klass, such as who called the hidden class factory.  Using\n+\/\/string compares on names is fragile and will break as soon as somebody\n+\/\/changes the names in the JDK code.  See discussion in JDK-8342481 for\n+\/\/related ideas about marking AOT-related classes.\n+bool HeapShared::is_lambda_form_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() &&\n+    (ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$MH+\") ||\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$DMH+\") ||\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$BMH+\"));\n+}\n+\n+bool HeapShared::is_lambda_proxy_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() && (ik->name()->index_of_at(0, \"$$Lambda+\", 9) > 0);\n+}\n+\n+bool HeapShared::is_string_concat_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() && ik->name()->starts_with(\"java\/lang\/String$$StringConcat\");\n+}\n+\n+bool HeapShared::is_archivable_hidden_klass(InstanceKlass* ik) {\n+  return CDSConfig::is_dumping_invokedynamic() &&\n+    (is_lambda_form_klass(ik) || is_lambda_proxy_klass(ik) || is_string_concat_klass(ik));\n+}\n+\n@@ -435,3 +462,1 @@\n-  if (!orig_k->is_instance_klass()) {\n-    return;\n-  }\n+  assert(orig_k->is_instance_klass(), \"sanity\");\n@@ -439,1 +464,9 @@\n-  if (!ik->is_initialized() || !AOTClassInitializer::can_archive_initialized_mirror(ik)) {\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n+\n+  if (HeapShared::is_archivable_hidden_klass(ik)) {\n+    \/\/ We can't rerun the <clinit> method of hidden classes as we don't save\n+    \/\/ the classData, so we must archive its mirror in initialized state.\n+    assert(ik->is_initialized(), \"must be\");\n+  }\n+\n+  if (!ik->is_initialized()) {\n@@ -484,0 +517,2 @@\n+  java_lang_Class::set_class_data(m, java_lang_Class::class_data(orig_mirror));\n+\n@@ -493,3 +528,0 @@\n-\n-  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n-  buffered_ik->set_has_aot_initialized_mirror();\n@@ -507,0 +539,13 @@\n+static objArrayOop get_archived_resolved_references(InstanceKlass* src_ik) {\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n+  if (buffered_ik->is_shared_boot_class() ||\n+      buffered_ik->is_shared_platform_class() ||\n+      buffered_ik->is_shared_app_class()) {\n+    objArrayOop rr = src_ik->constants()->resolved_references_or_null();\n+    if (rr != nullptr && !ArchiveHeapWriter::is_too_large_to_archive(rr)) {\n+      return HeapShared::scratch_resolved_references(src_ik->constants());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -535,1 +580,0 @@\n-      copy_aot_initialized_mirror(orig_k, orig_mirror, m);\n@@ -556,2 +600,2 @@\n-        oop rr = ik->constants()->prepare_resolved_references_for_archiving();\n-        if (rr != nullptr && !ArchiveHeapWriter::is_too_large_to_archive(rr)) {\n+        objArrayOop rr = get_archived_resolved_references(InstanceKlass::cast(orig_k));\n+        if (rr != nullptr) {\n@@ -588,0 +632,2 @@\n+  } else if (java_lang_invoke_ResolvedMethodName::is_instance(orig_obj)) {\n+    ArchiveHeapWriter::mark_native_pointer(orig_obj, java_lang_invoke_ResolvedMethodName::vmtarget_offset());\n@@ -604,0 +650,98 @@\n+void HeapShared::start_finding_archivable_hidden_classes() {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return;\n+  }\n+  NoSafepointVerifier nsv;\n+\n+  init_seen_objects_table();\n+\n+  find_archivable_hidden_classes_helper(archive_subgraph_entry_fields);\n+  if (CDSConfig::is_dumping_full_module_graph()) {\n+    find_archivable_hidden_classes_helper(fmg_archive_subgraph_entry_fields);\n+  }\n+}\n+\n+void HeapShared::end_finding_archivable_hidden_classes() {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return;\n+  }\n+  NoSafepointVerifier nsv;\n+\n+  delete_seen_objects_table();\n+}\n+\n+void HeapShared::find_archivable_hidden_classes_helper(ArchivableStaticFieldInfo fields[]) {\n+  if (!CDSConfig::is_dumping_heap()) {\n+    return;\n+  }\n+  for (int i = 0; fields[i].valid(); ) {\n+    ArchivableStaticFieldInfo* info = &fields[i];\n+    const char* klass_name = info->klass_name;\n+    for (; fields[i].valid(); i++) {\n+      ArchivableStaticFieldInfo* f = &fields[i];\n+      if (f->klass_name != klass_name) {\n+        break;\n+      }\n+\n+      InstanceKlass* k = f->klass;\n+      oop m = k->java_mirror();\n+      oop o = m->obj_field(f->offset);\n+      if (o != nullptr) {\n+        find_archivable_hidden_classes_in_object(o);\n+      }\n+    }\n+  }\n+}\n+\n+class HeapShared::FindHiddenClassesOopClosure: public BasicOopIterateClosure {\n+  GrowableArray<oop> _stack;\n+  template <class T> void do_oop_work(T *p) {\n+    \/\/ Recurse on a GrowableArray to avoid overflowing the C stack.\n+    oop o = RawAccess<>::oop_load(p);\n+    if (o != nullptr) {\n+      _stack.append(o);\n+    }\n+  }\n+\n+ public:\n+\n+  void do_oop(narrowOop *p) { FindHiddenClassesOopClosure::do_oop_work(p); }\n+  void do_oop(      oop *p) { FindHiddenClassesOopClosure::do_oop_work(p); }\n+\n+  FindHiddenClassesOopClosure(oop o) {\n+    _stack.append(o);\n+  }\n+  oop pop() {\n+    if (_stack.length() == 0) {\n+      return nullptr;\n+    } else {\n+      return _stack.pop();\n+    }\n+  }\n+};\n+\n+void HeapShared::find_archivable_hidden_classes_in_object(oop root) {\n+  ResourceMark rm;\n+  FindHiddenClassesOopClosure c(root);\n+  oop o;\n+  while ((o = c.pop()) != nullptr) {\n+    if (!has_been_seen_during_subgraph_recording(o)) {\n+      set_has_been_seen_during_subgraph_recording(o);\n+\n+      if (java_lang_Class::is_instance(o)) {\n+        Klass* k = java_lang_Class::as_Klass(o);\n+        if (k != nullptr && k->is_instance_klass()) {\n+          SystemDictionaryShared::mark_required_class(InstanceKlass::cast(k));\n+        }\n+      } else if (java_lang_invoke_ResolvedMethodName::is_instance(o)) {\n+        Method* m = java_lang_invoke_ResolvedMethodName::vmtarget(o);\n+        if (m != nullptr && m->method_holder() != nullptr) {\n+          SystemDictionaryShared::mark_required_class(m->method_holder());\n+        }\n+      }\n+\n+      o->oop_iterate(&c);\n+    }\n+  }\n+}\n+\n@@ -650,0 +794,1 @@\n+\n@@ -651,3 +796,5 @@\n-  archive_java_mirrors();\n-  archive_strings();\n-  Universe::archive_exception_instances();\n+  {\n+    archive_java_mirrors();\n+    archive_strings();\n+    Universe::archive_exception_instances();\n+  }\n@@ -657,0 +804,11 @@\n+void HeapShared::prepare_resolved_references() {\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* src_k = klasses->at(i);\n+    if (src_k->is_instance_klass()) {\n+      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_k));\n+      buffered_ik->constants()->prepare_resolved_references_for_archiving();\n+    }\n+  }\n+}\n+\n@@ -660,0 +818,2 @@\n+  prepare_resolved_references();\n+  find_all_aot_initialized_classes();\n@@ -672,0 +832,192 @@\n+\/\/ Closure used by HeapShared::scan_for_aot_initialized_classes() to look for all objects\n+\/\/ that are reachable from a given root.\n+class HeapShared::AOTInitializedClassScanner : public BasicOopIterateClosure {\n+  bool _made_progress;\n+\n+  template <class T> void check(T *p) {\n+    oop obj = HeapAccess<>::oop_load(p);\n+    if (!java_lang_Class::is_instance(obj)) {\n+      \/\/ Don't scan the mirrors, as we may see an orig_mirror while scanning\n+      \/\/ the object graph, .... TODO more info\n+      _made_progress |= HeapShared::scan_for_aot_initialized_classes(obj);\n+    }\n+  }\n+\n+public:\n+  AOTInitializedClassScanner() : _made_progress(false) {}\n+  void do_oop(narrowOop *p) { check(p); }\n+  void do_oop(      oop *p) { check(p); }\n+  bool made_progress() { return _made_progress; }\n+};\n+\n+\/\/ If <buffered_ik> has been initialized during the assembly phase, mark its\n+\/\/ has_aot_initialized_mirror bit. And then do the same for all supertypes of\n+\/\/ <buffered_ik>.\n+\/\/\n+\/\/ Note: a super interface <intf> of <buffered_ik> may not have been initialized, if\n+\/\/ <intf> has not declared any default methods.\n+\/\/\n+\/\/ Note: this function doesn not call InstanceKlass::initialize() -- we are inside\n+\/\/ a safepoint.\n+\/\/\n+\/\/ Returns true if one or more classes have been newly marked.\n+static bool mark_for_aot_initialization(InstanceKlass* buffered_ik) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"sanity\");\n+  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_ik), \"sanity\");\n+\n+  if (buffered_ik->has_aot_initialized_mirror()) { \/\/ already marked\n+    return false;\n+  }\n+\n+  bool made_progress = false;\n+  if (buffered_ik->is_initialized()) {\n+    if (log_is_enabled(Info, cds, init)) {\n+      ResourceMark rm;\n+      log_info(cds, init)(\"Mark class for aot-init: %s\", buffered_ik->external_name());\n+    }\n+\n+    InstanceKlass* src_ik = ArchiveBuilder::current()->get_source_addr(buffered_ik);\n+\n+    \/\/ If we get here with a \"wild\" user class, which may have\n+    \/\/ uncontrolled <clinit> code, exit with an error.  Obviously\n+    \/\/ filtering logic upstream needs to detect APP classes and not mark\n+    \/\/ them for aot-init in the first place, but this will be the final\n+    \/\/ firewall.\n+\n+#ifndef PRODUCT\n+    \/\/ ArchiveHeapTestClass is used for a very small number of internal regression\n+    \/\/ tests (non-product builds only). It may initialize some unexpected classes.\n+    if (ArchiveHeapTestClass == nullptr)\n+#endif\n+    {\n+      if (!src_ik->in_javabase_module()) {\n+        \/\/ Class\/interface types in the boot loader may have been initialized as side effects\n+        \/\/ of JVM bootstrap code, so they are fine. But we need to check all other classes.\n+        if (buffered_ik->is_interface()) {\n+          \/\/ This probably means a bug in AOTConstantPoolResolver.::is_indy_resolution_deterministic()\n+          guarantee(!buffered_ik->interface_needs_clinit_execution_as_super(),\n+                    \"should not have initialized an interface whose <clinit> might have unpredictable side effects\");\n+        } else {\n+          \/\/ \"normal\" classes\n+          guarantee(HeapShared::is_archivable_hidden_klass(buffered_ik),\n+                    \"should not have initialized any non-interface, non-hidden classes outside of java.base\");\n+        }\n+      }\n+    }\n+\n+    buffered_ik->set_has_aot_initialized_mirror();\n+    if (AOTClassInitializer::is_runtime_setup_required(src_ik)) {\n+      buffered_ik->set_is_runtime_setup_required();\n+    }\n+    made_progress = true;\n+\n+    InstanceKlass* super = buffered_ik->java_super();\n+    if (super != nullptr) {\n+      mark_for_aot_initialization(super);\n+    }\n+\n+    Array<InstanceKlass*>* interfaces = buffered_ik->transitive_interfaces();\n+    for (int i = 0; i < interfaces->length(); i++) {\n+      InstanceKlass* intf = interfaces->at(i);\n+      mark_for_aot_initialization(intf);\n+      if (!intf->is_initialized()) {\n+        assert(!intf->interface_needs_clinit_execution_as_super(\/*also_check_supers*\/false), \"sanity\");\n+        assert(!intf->has_aot_initialized_mirror(), \"must not be marked\");\n+      }\n+    }\n+  }\n+\n+  return made_progress;\n+}\n+\n+void HeapShared::find_all_aot_initialized_classes() {\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    return;\n+  }\n+\n+  init_seen_objects_table();\n+  find_all_aot_initialized_classes_helper();\n+  delete_seen_objects_table();\n+}\n+\n+\/\/ Recursively find all class that should be aot-initialized:\n+\/\/ - the class has at least one instance that can be reachable from the special subgraph; or\n+\/\/ - the class is hard-coded in AOTClassInitializer::can_archive_initialized_mirror()\n+void HeapShared::find_all_aot_initialized_classes_helper() {\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  assert(klasses != nullptr, \"sanity\");\n+\n+  \/\/ First scan all resolved constant pools references.\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* src_k = klasses->at(i);\n+    if (src_k->is_instance_klass()) {\n+      InstanceKlass* src_ik = InstanceKlass::cast(src_k);\n+      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n+      objArrayOop rr = get_archived_resolved_references(src_ik);\n+      if (rr != nullptr) {\n+        objArrayOop scratch_rr = scratch_resolved_references(src_ik->constants());\n+        for (int i = 0; i < scratch_rr->length(); i++) {\n+          scan_for_aot_initialized_classes(scratch_rr->obj_at(i));\n+        }\n+      }\n+\n+      \/\/ If a class is hard-coded to be aot-initialize, mark it as such.\n+      if (AOTClassInitializer::can_archive_initialized_mirror(src_ik)) {\n+        mark_for_aot_initialization(buffered_ik);\n+      }\n+    }\n+  }\n+\n+  \/\/ These objects also belong to the special subgraph\n+  scan_for_aot_initialized_classes(Universe::null_ptr_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::arithmetic_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::internal_error_instance());\n+  scan_for_aot_initialized_classes(Universe::array_index_out_of_bounds_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::array_store_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::class_cast_exception_instance());\n+\n+  bool made_progress;\n+  do {\n+    \/\/ In each pass, we copy the scratch mirrors of the classes that were marked\n+    \/\/ as aot-init in the previous pass. We then scan these mirrors, which may\n+    \/\/ mark more classes. Keep iterating until no more progress can be made.\n+    made_progress = false;\n+    for (int i = 0; i < klasses->length(); i++) {\n+      Klass* orig_k = klasses->at(i);\n+      if (orig_k->is_instance_klass()) {\n+        InstanceKlass* orig_ik = InstanceKlass::cast(orig_k);\n+        if (ArchiveBuilder::current()->get_buffered_addr(orig_ik)->has_aot_initialized_mirror()) {\n+          oop orig_mirror = orig_ik->java_mirror();\n+          oop scratch_mirror = scratch_java_mirror(orig_k);\n+          if (!has_been_seen_during_subgraph_recording(scratch_mirror)) {\n+            \/\/ Scan scratch_mirror instead of orig_mirror (which has fields like ClassLoader that\n+            \/\/ are not archived).\n+            copy_aot_initialized_mirror(orig_k, orig_mirror, scratch_mirror);\n+            made_progress |= scan_for_aot_initialized_classes(scratch_mirror);\n+          }\n+        }\n+      }\n+    }\n+  } while (made_progress);\n+}\n+\n+bool HeapShared::scan_for_aot_initialized_classes(oop obj) {\n+  if (obj == nullptr || has_been_seen_during_subgraph_recording(obj)) {\n+    return false;\n+  }\n+  set_has_been_seen_during_subgraph_recording(obj);\n+\n+  bool made_progress = false;\n+  Klass* k = obj->klass();\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* orig_ik = InstanceKlass::cast(k);\n+    InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(orig_ik);\n+    made_progress = mark_for_aot_initialization(buffered_ik);\n+  }\n+\n+  AOTInitializedClassScanner scanner;\n+  obj->oop_iterate(&scanner);\n+  made_progress |= scanner.made_progress();\n+  return made_progress;\n+}\n+\n@@ -730,2 +1082,8 @@\n-    assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class(),\n-          \"must be boot class\");\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class() ||\n+             HeapShared::is_lambda_proxy_klass(InstanceKlass::cast(buffered_k)),\n+            \"we can archive only instances of boot classes or lambda proxy classes\");\n+    } else {\n+      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class(),\n+             \"must be boot class\");\n+    }\n@@ -740,0 +1098,4 @@\n+    if (buffered_k->has_aot_initialized_mirror()) {\n+      \/\/ No need to add to the runtime-init list.\n+      return;\n+    }\n@@ -776,0 +1138,11 @@\n+  const char* lambda_msg = \"\";\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    lambda_msg = \", or a lambda proxy class\";\n+    if (HeapShared::is_lambda_proxy_klass(ik) &&\n+        (ik->class_loader() == nullptr ||\n+         ik->class_loader() == SystemDictionary::java_platform_loader() ||\n+         ik->class_loader() == SystemDictionary::java_system_loader())) {\n+      return;\n+    }\n+  }\n+\n@@ -777,1 +1150,1 @@\n-  if (!ik->module()->is_named() && ik->package() == nullptr) {\n+  if (!ik->module()->is_named() && ik->package() == nullptr && ArchiveHeapTestClass != nullptr) {\n@@ -781,1 +1154,1 @@\n-  const char* extra_msg = \", or in an unnamed package of an unnamed module\";\n+  const char* testcls_msg = \", or a test class in an unnamed package of an unnamed module\";\n@@ -783,1 +1156,1 @@\n-  const char* extra_msg = \"\";\n+  const char* testcls_msg = \"\";\n@@ -787,2 +1160,2 @@\n-  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s\",\n-                       ik->external_name(), extra_msg);\n+  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s%s\",\n+                       ik->external_name(), lambda_msg, testcls_msg);\n@@ -856,1 +1229,3 @@\n-\n+        if (subgraph_k->is_instance_klass()) {\n+          InstanceKlass* src_ik = InstanceKlass::cast(ArchiveBuilder::current()->get_source_addr(subgraph_k));\n+        }\n@@ -1009,0 +1384,25 @@\n+void HeapShared::resolve_classes_for_subgraph_of(JavaThread* current, Klass* k) {\n+  JavaThread* THREAD = current;\n+  ExceptionMark em(THREAD);\n+  const ArchivedKlassSubGraphInfoRecord* record =\n+   resolve_or_init_classes_for_subgraph_of(k, \/*do_init=*\/false, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+   CLEAR_PENDING_EXCEPTION;\n+  }\n+  if (record == nullptr) {\n+   clear_archived_roots_of(k);\n+  }\n+}\n+\n+void HeapShared::initialize_java_lang_invoke(TRAPS) {\n+  if (CDSConfig::is_loading_invokedynamic() || CDSConfig::is_dumping_invokedynamic()) {\n+    resolve_or_init(\"java\/lang\/invoke\/Invokers$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/MethodHandle\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/MethodHandleNatives\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/DirectMethodHandle$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/LambdaForm$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/BoundMethodHandle$Species_L\", true, CHECK);\n+  }\n+}\n+\n@@ -1056,13 +1456,0 @@\n-void HeapShared::resolve_classes_for_subgraph_of(JavaThread* current, Klass* k) {\n-  JavaThread* THREAD = current;\n-  ExceptionMark em(THREAD);\n-  const ArchivedKlassSubGraphInfoRecord* record =\n-   resolve_or_init_classes_for_subgraph_of(k, \/*do_init=*\/false, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-   CLEAR_PENDING_EXCEPTION;\n-  }\n-  if (record == nullptr) {\n-   clear_archived_roots_of(k);\n-  }\n-}\n-\n@@ -1172,0 +1559,13 @@\n+void HeapShared::resolve_or_init(const char* klass_name, bool do_init, TRAPS) {\n+  TempNewSymbol klass_name_sym =  SymbolTable::new_symbol(klass_name);\n+  InstanceKlass* k = SystemDictionaryShared::find_builtin_class(klass_name_sym);\n+  if (k == nullptr) {\n+    return;\n+  }\n+  assert(k->is_shared_boot_class(), \"sanity\");\n+  resolve_or_init(k, false, CHECK);\n+  if (do_init) {\n+    resolve_or_init(k, true, CHECK);\n+  }\n+}\n+\n@@ -1204,1 +1604,5 @@\n-      m->obj_field_put(field_offset, v);\n+      if (k->has_aot_initialized_mirror()) {\n+        assert(v == m->obj_field(field_offset), \"must be aot-initialized\");\n+      } else {\n+        m->obj_field_put(field_offset, v);\n+      }\n@@ -1212,2 +1616,3 @@\n-      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s\",\n-                          k->external_name(), p2i(k), JvmtiExport::is_early_phase() ? \" (early)\" : \"\");\n+      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s%s\",\n+                          k->external_name(), p2i(k), JvmtiExport::is_early_phase() ? \" (early)\" : \"\",\n+                          k->has_aot_initialized_mirror() ? \" (aot-inited)\" : \"\");\n@@ -1809,2 +2214,2 @@\n-        \/\/ See KlassSubGraphInfo::check_allowed_klass() - only two types of\n-        \/\/ classes are allowed:\n+        \/\/ See KlassSubGraphInfo::check_allowed_klass() - we only allow test classes\n+        \/\/ to be:\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":444,"deletions":39,"binary":false,"changes":483,"status":"modified"},{"patch":"@@ -169,0 +169,4 @@\n+  static void start_finding_archivable_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n+  static void find_archivable_hidden_classes_in_object(oop o) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void end_finding_archivable_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n+\n@@ -253,0 +257,3 @@\n+  class FindHiddenClassesOopClosure;\n+  static void find_archivable_hidden_classes_helper(ArchivableStaticFieldInfo fields[]);\n+\n@@ -343,0 +350,1 @@\n+  static void resolve_or_init(const char* klass_name, bool do_init, TRAPS);\n@@ -357,0 +365,1 @@\n+  static void prepare_resolved_references();\n@@ -360,0 +369,6 @@\n+\n+  class AOTInitializedClassScanner;\n+  static void find_all_aot_initialized_classes();\n+  static void find_all_aot_initialized_classes_helper();\n+  static bool scan_for_aot_initialized_classes(oop obj);\n+\n@@ -445,0 +460,1 @@\n+  static void initialize_java_lang_invoke(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -446,0 +462,5 @@\n+\n+  static bool is_lambda_form_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_lambda_proxy_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_string_concat_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_archivable_hidden_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/classLoadInfo.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"classfile\/classLoadInfo.hpp\"\n@@ -99,0 +99,6 @@\n+  if (CDSConfig::is_dumping_static_archive() && CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ Work around JDK-8310831, as some methods in lambda form holder classes may not get generated.\n+    log_info(cds)(\"Archived MethodHandles may refer to lambda form holder classes. Cannot regenerate.\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"cds\/cds_globals.hpp\"\n@@ -431,1 +430,0 @@\n-  CDS_JAVA_HEAP_ONLY(Modules::serialize(soc);)\n@@ -479,0 +477,1 @@\n+  char* _archived_main_module_name;\n@@ -490,1 +489,2 @@\n-    VM_Operation(), _heap_info(), _map_info(nullptr), _builder(b) {}\n+    VM_Operation(), _heap_info(), _map_info(nullptr), _builder(b),\n+    _archived_main_module_name(nullptr) {}\n@@ -499,0 +499,9 @@\n+\n+  void dump_main_module_name() {\n+    const char* module_name = Arguments::get_property(\"jdk.module.main\");\n+    if (module_name != nullptr) {\n+      _archived_main_module_name = ArchiveBuilder::current()->ro_strdup(module_name);\n+    } else {\n+      _archived_main_module_name = ArchiveBuilder::current()->ro_strdup(\"\");\n+    }\n+  }\n@@ -538,1 +547,1 @@\n-  CDS_JAVA_HEAP_ONLY(Modules::dump_main_module_name();)\n+  CDS_JAVA_HEAP_ONLY(dump_main_module_name();)\n@@ -566,1 +575,2 @@\n-  SystemDictionaryShared::check_excluded_classes();\n+\n+  SystemDictionaryShared::find_all_archivable_classes();\n@@ -600,0 +610,1 @@\n+  _map_info->set_main_module_name(_archived_main_module_name);\n@@ -844,0 +855,23 @@\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n+      \/\/ updated concurrently when we are saving their contents into a side table.\n+      assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n+\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n+                             vmSymbols::createArchivedObjects(),\n+                             vmSymbols::void_method_signature(),\n+                             CHECK);\n+\n+      \/\/ java.lang.Class::reflectionFactory cannot be archived yet. We set this field\n+      \/\/ to null, and it will be initialized again at runtime.\n+      log_debug(cds)(\"Resetting Class::reflectionFactory\");\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"resetArchivedStates\");\n+      Symbol* method_sig = vmSymbols::void_method_signature();\n+      JavaCalls::call_static(&result, vmClasses::Class_klass(),\n+                             method_name, method_sig, CHECK);\n+\n+      \/\/ Perhaps there is a way to avoid hard-coding these names here.\n+      \/\/ See discussion in JDK-8342481.\n+    }\n+\n@@ -1505,4 +1539,0 @@\n-  if (!mapinfo->validate_aot_class_linking()) {\n-    return MAP_ARCHIVE_OTHER_FAILURE;\n-  }\n-\n@@ -1529,0 +1559,5 @@\n+  if (!mapinfo->validate_aot_class_linking()) {\n+    unmap_archive(mapinfo);\n+    return MAP_ARCHIVE_OTHER_FAILURE;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"classfile\/klassFactory.hpp\"\n@@ -38,1 +40,0 @@\n-#include \"classfile\/klassFactory.hpp\"\n@@ -1285,1 +1286,1 @@\n-    \/\/ We do not archive hidden classes.\n+    record_hidden_class(ik);\n@@ -1387,0 +1388,38 @@\n+\n+void ClassLoader::record_hidden_class(InstanceKlass* ik) {\n+  assert(ik->is_hidden(), \"must be\");\n+\n+  s2 classloader_type;\n+  if (HeapShared::is_lambda_form_klass(ik)) {\n+    classloader_type = ClassLoader::BOOT_LOADER;\n+  } else {\n+    oop loader = ik->class_loader();\n+\n+    if (loader == nullptr) {\n+      classloader_type = ClassLoader::BOOT_LOADER;\n+    } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+      classloader_type = ClassLoader::PLATFORM_LOADER;\n+    } else if (SystemDictionary::is_system_class_loader(loader)) {\n+      classloader_type = ClassLoader::APP_LOADER;\n+    } else {\n+      \/\/ This class won't be archived, so no need to update its\n+      \/\/ classloader_type\/classpath_index.\n+      return;\n+    }\n+  }\n+  ik->set_shared_class_loader_type(classloader_type);\n+\n+  if (HeapShared::is_lambda_proxy_klass(ik)) {\n+    InstanceKlass* nest_host = ik->nest_host_not_null();\n+    ik->set_shared_classpath_index(nest_host->shared_classpath_index());\n+  } else if (HeapShared::is_lambda_form_klass(ik)) {\n+    ik->set_shared_classpath_index(0);\n+  } else {\n+    \/\/ Generated invoker classes.\n+    if (classloader_type == ClassLoader::APP_LOADER) {\n+      ik->set_shared_classpath_index(ClassLoaderExt::app_class_paths_start_index());\n+    } else {\n+      ik->set_shared_classpath_index(0);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -389,0 +389,1 @@\n+  static void record_hidden_class(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5432,14 +5432,12 @@\n-  if (klass == vmClasses::ClassLoader_klass() ||  \/\/ ClassLoader::loader_data is malloc'ed.\n-      \/\/ The next 3 classes are used to implement java.lang.invoke, and are not used directly in\n-      \/\/ regular Java code. The implementation of java.lang.invoke uses generated hidden classes\n-      \/\/ (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.\n-      \/\/ So for now we cannot not support these classes for archiving.\n-      \/\/\n-      \/\/ These objects typically are not referenced by static fields, but rather by resolved\n-      \/\/ constant pool entries, so excluding them shouldn't affect the archiving of static fields.\n-      klass == vmClasses::ResolvedMethodName_klass() ||\n-      klass == vmClasses::MemberName_klass() ||\n-      klass == vmClasses::Context_klass() ||\n-      \/\/ It's problematic to archive Reference objects. One of the reasons is that\n-      \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n-      klass->is_subclass_of(vmClasses::Reference_klass())) {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ These are supported by CDS only when CDSConfig::is_dumping_invokedynamic() is enabled.\n+    if (klass == vmClasses::ResolvedMethodName_klass() ||\n+        klass == vmClasses::MemberName_klass() ||\n+        klass == vmClasses::Context_klass()) {\n+      return false;\n+    }\n+  }\n+\n+  if (klass->is_subclass_of(vmClasses::Reference_klass())) {\n+    \/\/ It's problematic to archive Reference objects. One of the reasons is that\n+    \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -567,41 +567,0 @@\n-char* Modules::_archived_main_module_name = nullptr;\n-\n-void Modules::dump_main_module_name() {\n-  const char* module_name = Arguments::get_property(\"jdk.module.main\");\n-  if (module_name != nullptr) {\n-    _archived_main_module_name = ArchiveBuilder::current()->ro_strdup(module_name);\n-  }\n-  ArchivePtrMarker::mark_pointer(&_archived_main_module_name);\n-}\n-\n-void Modules::serialize(SerializeClosure* soc) {\n-  soc->do_ptr(&_archived_main_module_name);\n-  if (soc->reading()) {\n-    const char* runtime_main_module = Arguments::get_property(\"jdk.module.main\");\n-    log_info(cds)(\"_archived_main_module_name %s\",\n-      _archived_main_module_name != nullptr ? _archived_main_module_name : \"(null)\");\n-    bool disable = false;\n-    if (runtime_main_module == nullptr) {\n-      if (_archived_main_module_name != nullptr) {\n-        log_info(cds)(\"Module %s specified during dump time but not during runtime\", _archived_main_module_name);\n-        disable = true;\n-      }\n-    } else {\n-      if (_archived_main_module_name == nullptr) {\n-        log_info(cds)(\"Module %s specified during runtime but not during dump time\", runtime_main_module);\n-        disable = true;\n-      } else if (strcmp(runtime_main_module, _archived_main_module_name) != 0) {\n-        log_info(cds)(\"Mismatched modules: runtime %s dump time %s\", runtime_main_module, _archived_main_module_name);\n-        disable = true;\n-      }\n-    }\n-\n-    if (disable) {\n-      log_info(cds)(\"Disabling optimized module handling\");\n-      CDSConfig::stop_using_optimized_module_handling();\n-    }\n-    log_info(cds)(\"optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,6 +62,0 @@\n-  static void dump_main_module_name() NOT_CDS_JAVA_HEAP_RETURN;\n-  static void serialize(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  static char* _archived_main_module_name;\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/cdsProtectionDomain.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"cds\/dumpTimeClassInfo.inline.hpp\"\n@@ -34,2 +36,1 @@\n-#include \"cds\/cdsProtectionDomain.hpp\"\n-#include \"cds\/dumpTimeClassInfo.inline.hpp\"\n+#include \"cds\/heapShared.hpp\"\n@@ -196,0 +197,8 @@\n+void SystemDictionaryShared::mark_required_class(InstanceKlass* k) {\n+  DumpTimeClassInfo* info = _dumptime_table->get(k);\n+  ResourceMark rm;\n+  if (info != nullptr) {\n+    info->set_is_required();\n+  }\n+}\n+\n@@ -279,3 +288,7 @@\n-      ResourceMark rm;\n-      log_info(cds)(\"Skipping %s because it is dynamically generated\", k->name()->as_C_string());\n-      return true; \/\/ exclude without warning\n+      if (CDSConfig::is_dumping_aot_linked_classes()) {\n+        k->set_shared_classpath_index(0);\n+      } else {\n+        ResourceMark rm;\n+        log_info(cds)(\"Skipping %s because it is dynamically generated\", k->name()->as_C_string());\n+        return true; \/\/ exclude without warning\n+      }\n@@ -318,3 +331,2 @@\n-  if (k->is_hidden() && !is_registered_lambda_proxy_class(k)) {\n-    ResourceMark rm;\n-    log_debug(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n+  if (k->is_hidden() && !should_hidden_class_be_archived(k)) {\n+    log_info(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n@@ -580,1 +592,5 @@\n-      assert(is_registered_lambda_proxy_class(k), \"unexpected hidden class %s\", name);\n+      if (CDSConfig::is_dumping_invokedynamic()) {\n+        assert(should_hidden_class_be_archived(k), \"unexpected hidden class %s\", name);\n+      } else {\n+        assert(is_registered_lambda_proxy_class(k), \"unexpected hidden class %s\", name);\n+      }\n@@ -632,1 +648,77 @@\n-void SystemDictionaryShared::check_excluded_classes() {\n+void SystemDictionaryShared::scan_constant_pool(InstanceKlass* k) {\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    k->constants()->find_archivable_hidden_classes();\n+  }\n+}\n+\n+bool SystemDictionaryShared::should_hidden_class_be_archived(InstanceKlass* k) {\n+  assert(k->is_hidden(), \"sanity\");\n+  if (is_registered_lambda_proxy_class(k)) {\n+    return true;\n+  }\n+\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    if (HeapShared::is_archivable_hidden_klass(k)) {\n+      return true;\n+    }\n+\n+    DumpTimeClassInfo* info = _dumptime_table->get(k);\n+    if (info != nullptr && info->is_required()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ Returns true if the class should be excluded. This can be called before\n+\/\/ SystemDictionaryShared::check_excluded_classes().\n+bool SystemDictionaryShared::check_for_exclusion(Klass* k) {\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n+\n+  if (k->is_objArray_klass()) {\n+    return check_for_exclusion(ObjArrayKlass::cast(k)->bottom_klass());\n+  }\n+\n+  if (!k->is_instance_klass()) {\n+    return false;\n+  } else {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      return is_excluded_class(ik);\n+    }\n+\n+    if (!ik->is_linked()) {\n+      JavaThread* THREAD = JavaThread::current();\n+      ik->link_class(THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION;\n+        return true;\n+      }\n+    }\n+\n+    MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+    DumpTimeClassInfo* p = get_info_locked(ik);\n+    if (p->is_excluded()) {\n+      return true;\n+    }\n+    return check_for_exclusion(ik, p);\n+  }\n+}\n+\n+void SystemDictionaryShared::find_all_archivable_classes() {\n+  HeapShared::start_finding_archivable_hidden_classes();\n+  find_all_archivable_classes_impl();\n+  HeapShared::end_finding_archivable_hidden_classes();\n+}\n+\n+\/\/ Iterate over all the classes in _dumptime_table, marking the ones that must be\n+\/\/ excluded from the archive. Those that are not excluded will be archivable.\n+\/\/\n+\/\/ (a) Non-hidden classes are easy. They are only check by the rules in\n+\/\/     SystemDictionaryShared::check_for_exclusion().\n+\/\/ (b) For hidden classes, we only archive those that are required (i.e., they are\n+\/\/     referenced by Java objects (such as CallSites) that are reachable from\n+\/\/     ConstantPools.\n+void SystemDictionaryShared::find_all_archivable_classes_impl() {\n@@ -645,2 +737,11 @@\n-  auto check_for_exclusion = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n-    SystemDictionaryShared::check_for_exclusion(k, &info);\n+  ResourceMark rm;\n+\n+  \/\/ First, scan all non-hidden classes\n+  auto check_non_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!k->is_hidden()) {\n+      SystemDictionaryShared::check_for_exclusion(k, &info);\n+      if (!info.is_excluded() && !info.has_scanned_constant_pool()) {\n+        scan_constant_pool(k);\n+        info.set_has_scanned_constant_pool();\n+      }\n+    }\n@@ -648,1 +749,32 @@\n-  _dumptime_table->iterate_all_live_classes(check_for_exclusion);\n+  _dumptime_table->iterate_all_live_classes(check_non_hidden);\n+\n+  \/\/ Then, scan all the hidden classes that have been marked as required to\n+  \/\/ discover more hidden classes. Stop when we cannot make progress anymore.\n+  bool made_progress;\n+  do {\n+    made_progress = false;\n+    auto check_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+      if (k->is_hidden() && should_hidden_class_be_archived(k)) {\n+        SystemDictionaryShared::check_for_exclusion(k, &info);\n+        if (info.is_excluded()) {\n+          guarantee(!info.is_required(), \"A required hidden class cannot be marked as excluded\");\n+        } else if (!info.has_scanned_constant_pool()) {\n+          scan_constant_pool(k);\n+          info.set_has_scanned_constant_pool();\n+          \/\/ The CP entries in k *MAY* refer to other hidden classes, so scan\n+          \/\/ every hidden class again.\n+          made_progress = true;\n+        }\n+      }\n+    };\n+    _dumptime_table->iterate_all_live_classes(check_hidden);\n+  } while (made_progress);\n+\n+  \/\/ Now, all hidden classes that have not yet been scanned must be marked as excluded\n+  auto exclude_remaining_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (k->is_hidden() && !info.has_checked_exclusion()) {\n+      SystemDictionaryShared::check_for_exclusion(k, &info);\n+      guarantee(info.is_excluded(), \"Must be\");\n+    }\n+  };\n+  _dumptime_table->iterate_all_live_classes(exclude_remaining_hidden);\n@@ -758,0 +890,5 @@\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ The lambda proxy classes will be stored as part of aot-resolved constant pool entries.\n+    \/\/ There's no need to remember them in a separate table.\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":150,"deletions":13,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,1 @@\n+  static void find_all_archivable_classes_impl();\n@@ -202,1 +203,1 @@\n-\n+  static void scan_constant_pool(InstanceKlass* k);\n@@ -206,0 +207,2 @@\n+  static bool should_hidden_class_be_archived(InstanceKlass* k);\n+  static void mark_required_class(InstanceKlass* k);\n@@ -291,1 +294,2 @@\n-  static void check_excluded_classes();\n+  static void find_all_archivable_classes();\n+  static bool check_for_exclusion(Klass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -732,0 +732,1 @@\n+  template(createArchivedObjects,                           \"createArchivedObjects\")                              \\\n@@ -745,0 +746,1 @@\n+  template(runtimeSetup,                                    \"runtimeSetup\")                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -952,0 +952,9 @@\n+void InterpreterRuntime::cds_resolve_invokehandle(int raw_index,\n+                                                  constantPoolHandle& pool, TRAPS) {\n+  const Bytecodes::Code bytecode = Bytecodes::_invokehandle;\n+  CallInfo info;\n+  LinkResolver::resolve_invoke(info, Handle(), pool, raw_index, bytecode, CHECK);\n+\n+  pool->cache()->set_method_handle(raw_index, info);\n+}\n+\n@@ -971,0 +980,8 @@\n+void InterpreterRuntime::cds_resolve_invokedynamic(int raw_index,\n+                                                   constantPoolHandle& pool, TRAPS) {\n+  const Bytecodes::Code bytecode = Bytecodes::_invokedynamic;\n+  CallInfo info;\n+  LinkResolver::resolve_invoke(info, Handle(), pool, raw_index, bytecode, CHECK);\n+  pool->cache()->set_dynamic_call(info, raw_index);\n+}\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -100,1 +100,4 @@\n-\n+  static void cds_resolve_invokehandle(int raw_index,\n+                                       constantPoolHandle& pool, TRAPS);\n+  static void cds_resolve_invokedynamic(int raw_index,\n+                                        constantPoolHandle& pool, TRAPS);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -72,0 +73,13 @@\n+\n+#ifdef ASSERT\n+\/\/ A not-yet loaded aot-linked class k may be discovered by the GC during VM\n+\/\/ initialization only. This can happen when the heap contains an aot-cached\n+\/\/ instance of k, but k is not ready to be loaded yet. (TODO: JDK-8342429\n+\/\/ eliminates this possibility)\n+\/\/\n+\/\/ AOTLinkedClassBulkLoader checks the the exact (narrow set of) conditions\n+\/\/ when this could happen.\n+void ClaimMetadataVisitingOopIterateClosure::assert_is_pending_aot_linked_class(Klass* k) {\n+  assert(AOTLinkedClassBulkLoader::is_pending_aot_linked_class(k), \"sanity\");\n+}\n+#endif\n","filename":"src\/hotspot\/share\/memory\/iterator.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -175,0 +176,2 @@\n+ private:\n+  static void assert_is_pending_aot_linked_class(Klass* k) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,5 @@\n-  ClaimMetadataVisitingOopIterateClosure::do_cld(cld);\n+  if (cld != nullptr) {\n+    ClaimMetadataVisitingOopIterateClosure::do_cld(cld);\n+  } else {\n+    assert_is_pending_aot_linked_class(k);\n+  }\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-#include \"cds\/archiveHeapWriter.hpp\"\n-#include \"cds\/archiveHeapLoader.hpp\"\n@@ -30,0 +28,2 @@\n+#include \"cds\/archiveHeapLoader.hpp\"\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -38,0 +38,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -286,0 +287,29 @@\n+template <typename Function>\n+void ConstantPool::iterate_archivable_resolved_references(Function function) {\n+  objArrayOop rr = resolved_references();\n+  if (rr != nullptr && cache() != nullptr && CDSConfig::is_dumping_invokedynamic()) {\n+    Array<ResolvedIndyEntry>* indy_entries = cache()->resolved_indy_entries();\n+    if (indy_entries != nullptr) {\n+      for (int i = 0; i < indy_entries->length(); i++) {\n+        ResolvedIndyEntry *rie = indy_entries->adr_at(i);\n+        if (rie->is_resolved() && AOTConstantPoolResolver::is_resolution_deterministic(this, rie->constant_pool_index())) {\n+          int rr_index = rie->resolved_references_index();\n+          function(rr_index);\n+        }\n+      }\n+    }\n+\n+    Array<ResolvedMethodEntry>* method_entries = cache()->resolved_method_entries();\n+    if (method_entries != nullptr) {\n+      for (int i = 0; i < method_entries->length(); i++) {\n+        ResolvedMethodEntry* rme = method_entries->adr_at(i);\n+        if (rme->is_resolved(Bytecodes::_invokehandle) && rme->has_appendix() &&\n+            cache()->can_archive_resolved_method(this, rme)) {\n+          int rr_index = rme->resolved_references_index();\n+          function(rr_index);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -303,0 +333,1 @@\n+    ResourceMark rm;\n@@ -304,0 +335,2 @@\n+    GrowableArray<bool> keep_resolved_refs(rr_len, rr_len, false);\n+\n@@ -305,0 +338,4 @@\n+    src_cp->iterate_archivable_resolved_references([&](int rr_index) {\n+      keep_resolved_refs.at_put(rr_index, true);\n+      });\n+\n@@ -320,0 +357,2 @@\n+        } else if (keep_resolved_refs.at(i)) {\n+          scratch_rr->obj_at_put(i, obj);\n@@ -328,0 +367,26 @@\n+void ConstantPool::find_archivable_hidden_classes() {\n+  if (_cache == nullptr) {\n+    return;\n+  }\n+\n+  ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n+  if (loader_data == nullptr) {\n+    \/\/ These are custom loader classes from the preimage\n+    return;\n+  }\n+\n+  if (!SystemDictionaryShared::is_builtin_loader(loader_data)) {\n+    \/\/ Archiving resolved references for classes from non-builtin loaders\n+    \/\/ is not yet supported.\n+    return;\n+  }\n+\n+  objArrayOop rr = resolved_references();\n+  if (rr != nullptr) {\n+    iterate_archivable_resolved_references([&](int rr_index) {\n+      oop obj = rr->obj_at(rr_index);\n+      HeapShared::find_archivable_hidden_classes_in_object(obj);\n+    });\n+  }\n+}\n+\n@@ -764,3 +829,1 @@\n-      tty->print_cr(\"Unexpected bytecode: %d\", code);\n-      ShouldNotReachHere(); \/\/ All cases should have been handled\n-      return -1;\n+      fatal(\"Unexpected bytecode: %s\", Bytecodes::name(code));\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":68,"deletions":5,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -686,0 +686,1 @@\n+  void find_archivable_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -692,0 +693,1 @@\n+  template <typename Function> void iterate_archivable_resolved_references(Function function);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -404,3 +404,1 @@\n-    for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n-      resolved_indy_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_indy_entries_if_non_deterministic();\n@@ -459,1 +457,2 @@\n-                    rme->is_resolved(Bytecodes::_invokeinterface);\n+                    rme->is_resolved(Bytecodes::_invokeinterface) ||\n+                    rme->is_resolved(Bytecodes::_invokehandle);\n@@ -462,2 +461,1 @@\n-    resolved &= !(rme->is_resolved(Bytecodes::_invokehandle) ||\n-                  rme->is_resolved(Bytecodes::_invokestatic));\n+    resolved &= !(rme->is_resolved(Bytecodes::_invokestatic));\n@@ -465,1 +463,1 @@\n-    if (resolved && can_archive_resolved_method(rme)) {\n+    if (resolved && can_archive_resolved_method(src_cp, rme)) {\n@@ -497,1 +495,35 @@\n-bool ConstantPoolCache::can_archive_resolved_method(ResolvedMethodEntry* method_entry) {\n+void ConstantPoolCache::remove_resolved_indy_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n+    ResolvedIndyEntry* rei = _resolved_indy_entries->adr_at(i);\n+    int cp_index = rei->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rei->is_resolved();\n+    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+      rei->mark_and_relocate();\n+      archived = true;\n+    } else {\n+      rei->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n+        int bsm_ref = cp->method_handle_index_at(bsm);\n+        Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n+        Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n+        Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n+        log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  cp_index, cp->pool_holder()->name()->as_C_string(), i);\n+        log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(),\n+                  bsm_name->as_C_string(), bsm_signature->as_C_string());\n+      }\n+      ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n+    }\n+  }\n+}\n+\n+bool ConstantPoolCache::can_archive_resolved_method(ConstantPool* src_cp, ResolvedMethodEntry* method_entry) {\n@@ -522,1 +554,0 @@\n-  ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(constant_pool());\n@@ -533,0 +564,7 @@\n+  } else if (method_entry->is_resolved(Bytecodes::_invokehandle)) {\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      \/\/ invokehandle depends on archived MethodType and LambdaForms.\n+      return true;\n+    } else {\n+      return false;\n+    }\n@@ -534,1 +572,0 @@\n-    \/\/ invokestatic and invokehandle are not supported yet.\n@@ -537,1 +574,0 @@\n-\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":47,"deletions":11,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+  void remove_resolved_indy_entries_if_non_deterministic();\n@@ -228,1 +229,1 @@\n-  bool can_archive_resolved_method(ResolvedMethodEntry* method_entry);\n+  bool can_archive_resolved_method(ConstantPool* src_cp, ResolvedMethodEntry* method_entry);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -732,0 +732,12 @@\n+\/\/ JLS 8.9: An enum class is either implicitly final and derives\n+\/\/ from java.lang.Enum, or else is implicitly sealed to its\n+\/\/ anonymous subclasses.  This query detects both kinds, unless\n+\/\/ direct_only is true.  It does not validate the finality or\n+\/\/ sealing conditions: it merely checks for a super of Enum.\n+\/\/ This is sufficient for recognizing well-formed enums.\n+bool InstanceKlass::is_enum_subclass(bool direct_only) const {\n+  InstanceKlass* s = java_super();\n+  return (s == vmClasses::Enum_klass() ||\n+          (s != nullptr && s->java_super() == vmClasses::Enum_klass()));\n+}\n+\n@@ -789,2 +801,3 @@\n-static bool check_supertypes_of_aot_inited_class(InstanceKlass* ik) {\n-  assert(ik->has_aot_initialized_mirror(), \"must be\");\n+#ifdef ASSERT\n+void InstanceKlass::assert_no_clinit_will_run_for_aot_initialized_class() const {\n+  assert(has_aot_initialized_mirror(), \"must be\");\n@@ -792,2 +805,7 @@\n-  \/\/ Sanity check of all superclasses and superinterfaces.\n-  AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(ik);\n+  InstanceKlass* s = java_super();\n+  if (s != nullptr) {\n+    DEBUG_ONLY(ResourceMark rm);\n+    assert(s->is_initialized(), \"super class %s of aot-inited class %s must have been initialized\",\n+           s->external_name(), external_name());\n+    s->assert_no_clinit_will_run_for_aot_initialized_class();\n+  }\n@@ -795,15 +813,12 @@\n-  if (ik->has_nonstatic_concrete_methods()) {\n-    Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n-    int len = interfaces->length();\n-    for (int i = 0; i < len; i++) {\n-      InstanceKlass* intf = interfaces->at(i);\n-      if (!intf->is_initialized()) {\n-        assert(intf->class_initializer() == nullptr, \"should have been asserted\");\n-        if (log_is_enabled(Info, cds, init)) {\n-          ResourceMark rm;\n-          log_info(cds, init)(\"%s takes slow path because interface %s (%s <clinit>) is not yet initialized\",\n-                              ik->external_name(), intf->external_name(),\n-                              (intf->class_initializer() != nullptr) ? \"has\" : \"no\");\n-        }\n-        return false;\n-      }\n+  Array<InstanceKlass*>* interfaces = local_interfaces();\n+  int len = interfaces->length();\n+  for (int i = 0; i < len; i++) {\n+    InstanceKlass* intf = interfaces->at(i);\n+    if (!intf->is_initialized()) {\n+      ResourceMark rm;\n+      \/\/ Note: an interface needs to be marked as is_initialized() only if\n+      \/\/ - it has a <clinit>\n+      \/\/ - it has declared a default method.\n+      assert(!intf->interface_needs_clinit_execution_as_super(\/*also_check_supers*\/false),\n+             \"uninitialized super interface %s of aot-inited class %s must not have <clinit>\",\n+             intf->external_name(), external_name());\n@@ -812,2 +827,0 @@\n-\n-  return true;\n@@ -815,0 +828,7 @@\n+#endif\n+\n+void InstanceKlass::initialize_with_aot_initialized_mirror(TRAPS) {\n+  assert(has_aot_initialized_mirror(), \"must be\");\n+  assert(CDSConfig::is_loading_heap(), \"must be\");\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"must be\");\n+  assert_no_clinit_will_run_for_aot_initialized_class();\n@@ -816,1 +836,0 @@\n-void InstanceKlass::initialize_from_cds(TRAPS) {\n@@ -821,6 +840,4 @@\n-  if (has_aot_initialized_mirror() && CDSConfig::is_loading_heap() &&\n-      check_supertypes_of_aot_inited_class(this)) {\n-    if (log_is_enabled(Info, cds, init)) {\n-      ResourceMark rm;\n-      log_info(cds, init)(\"%s (quickest)\", external_name());\n-    }\n+  if (log_is_enabled(Info, cds, init)) {\n+    ResourceMark rm;\n+    log_info(cds, init)(\"%s (aot-inited)\", external_name());\n+  }\n@@ -828,1 +845,1 @@\n-    link_class(CHECK);\n+  link_class(CHECK);\n@@ -831,12 +848,6 @@\n-    {\n-      Handle h_init_lock(THREAD, init_lock());\n-      ObjectLocker ol(h_init_lock, THREAD);\n-      assert(!is_initialized(), \"sanity\");\n-      assert(!is_being_initialized(), \"sanity\");\n-      assert(!is_in_error_state(), \"sanity\");\n-    }\n-#endif\n-\n-    set_init_thread(THREAD);\n-    set_initialization_state_and_notify(fully_initialized, CHECK);\n-    return;\n+  {\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, THREAD);\n+    assert(!is_initialized(), \"sanity\");\n+    assert(!is_being_initialized(), \"sanity\");\n+    assert(!is_in_error_state(), \"sanity\");\n@@ -844,0 +855,1 @@\n+#endif\n@@ -845,9 +857,3 @@\n-  if (log_is_enabled(Info, cds, init)) {\n-    \/\/ If we have a preinit mirror, we may come to here if a supertype is not\n-    \/\/ yet initialized. It will still be quicker than usual, as we will skip the\n-    \/\/ execution of <clinit> of this class.\n-    ResourceMark rm;\n-    log_info(cds, init)(\"%s%s\", external_name(),\n-                        (has_aot_initialized_mirror() && CDSConfig::is_loading_heap()) ? \" (quicker)\" : \"\");\n-  }\n-  initialize(THREAD);\n+  set_init_thread(THREAD);\n+  set_initialization_state_and_notify(fully_initialized, CHECK);\n+  AOTClassInitializer::call_runtime_setup(this, CHECK);\n@@ -1652,0 +1658,1 @@\n+    AOTClassInitializer::call_runtime_setup(this, CHECK);\n@@ -1681,0 +1688,41 @@\n+\/\/ If a class that implements this interface is initialized, is the JVM required\n+\/\/ to first execute a <clinit> method declared in this interface,\n+\/\/ or (if also_check_supers==true) any of the super types of this interface?\n+\/\/\n+\/\/ JVMS 5.5. Initialization, step 7: Next, if C is a class rather than\n+\/\/ an interface, then let SC be its superclass and let SI1, ..., SIn\n+\/\/ be all superinterfaces of C (whether direct or indirect) that\n+\/\/ declare at least one non-abstract, non-static method.\n+\/\/\n+\/\/ So when an interface is initialized, it does not look at its\n+\/\/ supers. But a proper class will ensure that all of its supers have\n+\/\/ run their <clinit> methods, except that it disregards interfaces\n+\/\/ that lack a non-static concrete method (i.e., a default method).\n+\/\/ Therefore, you should probably call this method only when the\n+\/\/ current class is a super of some proper class, not an interface.\n+bool InstanceKlass::interface_needs_clinit_execution_as_super(bool also_check_supers) const {\n+  assert(is_interface(), \"must be\");\n+\n+  if (!has_nonstatic_concrete_methods()) {\n+    \/\/ quick check: no nonstatic concrete methods are declared by this or any super interfaces\n+    return false;\n+  }\n+\n+  \/\/ JVMS 5.5. Initialization\n+  \/\/ ...If C is an interface that declares a non-abstract,\n+  \/\/ non-static method, the initialization of a class that\n+  \/\/ implements C directly or indirectly.\n+  if (declares_nonstatic_concrete_methods() && class_initializer() != nullptr) {\n+    return true;\n+  }\n+  if (also_check_supers) {\n+    Array<InstanceKlass*>* all_ifs = transitive_interfaces();\n+    for (int i = 0; i < all_ifs->length(); ++i) {\n+      InstanceKlass* super_intf = all_ifs->at(i);\n+      if (super_intf->declares_nonstatic_concrete_methods() && super_intf->class_initializer() != nullptr) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n@@ -2571,0 +2619,1 @@\n+  it->push(&_nest_host);\n@@ -2634,2 +2683,6 @@\n-  \/\/ clear _nest_host to ensure re-load at runtime\n-  _nest_host = nullptr;\n+  if (CDSConfig::is_dumping_invokedynamic() && HeapShared::is_lambda_proxy_klass(this)) {\n+    \/\/ keep _nest_host\n+  } else {\n+    \/\/ clear _nest_host to ensure re-load at runtime\n+    _nest_host = nullptr;\n+  }\n@@ -3003,0 +3056,4 @@\n+bool InstanceKlass::in_javabase_module() const {\n+  return module()->name() == vmSymbols::java_base();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":109,"deletions":52,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -433,0 +433,3 @@\n+  \/\/ test for enum class (or possibly an anonymous subclass within a sealed enum)\n+  bool is_enum_subclass(bool direct_only = false) const;\n+\n@@ -479,0 +482,1 @@\n+  bool in_javabase_module() const;\n@@ -535,1 +539,2 @@\n-  void initialize_from_cds(TRAPS);\n+  void initialize_with_aot_initialized_mirror(TRAPS);\n+  void assert_no_clinit_will_run_for_aot_initialized_class() const NOT_DEBUG_RETURN;\n@@ -542,0 +547,1 @@\n+  bool interface_needs_clinit_execution_as_super(bool also_check_supers=true) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-    \/\/ The archived mirror is already initialized dur AOT-cache assembly. No need to call <clinit>\n+    \/\/ archived mirror already initialized by AOT-cache assembly: no further need to call <clinit>\n@@ -199,0 +199,3 @@\n+    \/\/ If this class has been aot-inititalized, do we need to call its runtimeSetup()\n+    \/\/ method during the production run?\n+    _is_runtime_setup_required             = 1 << 7,\n@@ -389,0 +392,9 @@\n+  void set_is_runtime_setup_required() {\n+    assert(has_aot_initialized_mirror(), \"sanity\");\n+    CDS_ONLY(_shared_class_flags |= _is_runtime_setup_required;)\n+  }\n+  bool is_runtime_setup_required() const {\n+    CDS_ONLY(return (_shared_class_flags & _is_runtime_setup_required) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2922,1 +2922,1 @@\n-  if (CDSConfig::is_dumping_static_archive()) {\n+  if (CDSConfig::allow_only_single_java_thread()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -349,0 +350,1 @@\n+\n@@ -404,0 +406,1 @@\n+  initialize_class(vmSymbols::java_lang_InternalError(), CHECK);\n@@ -413,0 +416,4 @@\n+\n+  if (UseSharedSpaces) {\n+    HeapShared::initialize_java_lang_invoke(CHECK);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -234,0 +234,5 @@\n+        runtimeSetup();\n+    }\n+\n+    \/\/ Called from JVM when loading an AOT cache\n+    private static void runtimeSetup() {\n@@ -4058,0 +4063,9 @@\n+    \/**\n+     * When CDS is enabled, the Class class may be aot-initialized. However,\n+     * we can't archive reflectionFactory, so we reset it to null, so it\n+     * will be allocated again at runtime.\n+     *\/\n+    private static void resetArchivedStates() {\n+        reflectionFactory = null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import java.util.HashMap;\n+import java.util.Iterator;\n@@ -49,0 +51,1 @@\n+import jdk.internal.misc.CDS;\n@@ -401,0 +404,11 @@\n+        if (archivedMethodTypes != null) {\n+            \/\/ If this JVM process reads from archivedMethodTypes, it never\n+            \/\/ modifies the table. So there's no need for synchronization.\n+            \/\/ See copyInternTable() below.\n+            assert CDS.isUsingArchive();\n+            MethodType mt = archivedMethodTypes.get(primordialMT);\n+            if (mt != null) {\n+                return mt;\n+            }\n+        }\n+\n@@ -419,0 +433,1 @@\n+\n@@ -420,0 +435,1 @@\n+    private static @Stable HashMap<MethodType,MethodType> archivedMethodTypes;\n@@ -1400,0 +1416,26 @@\n+\n+    static HashMap<MethodType,MethodType> copyInternTable() {\n+        HashMap<MethodType,MethodType> copy = new HashMap<>();\n+\n+        for (Iterator<MethodType> i = internTable.iterator(); i.hasNext(); ) {\n+            MethodType t = i.next();\n+            copy.put(t, t);\n+        }\n+\n+        return copy;\n+    }\n+\n+    \/\/ This is called from C code, at the very end of Java code execution\n+    \/\/ during the AOT cache assembly phase.\n+    static void createArchivedObjects() {\n+        \/\/ After the archivedMethodTypes field is assigned, this table\n+        \/\/ is never modified. So we don't need synchronization when reading from\n+        \/\/ it (which happens only in a future JVM process, never in the current process).\n+        \/\/\n+        \/\/ @implNote CDS.isDumpingStaticArchive() is mutually exclusive with\n+        \/\/ CDS.isUsingArchive(); at most one of them can return true for any given JVM\n+        \/\/ process.\n+        assert CDS.isDumpingStaticArchive();\n+        archivedMethodTypes = copyInternTable();\n+        internTable.clear();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1083,0 +1083,2 @@\n+        \/\/ The CLASS_NAME prefix must be the same as used by HeapShared::is_string_concat_klass()\n+        \/\/ in the HotSpot code.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -598,1 +599,10 @@\n-    static final int NCPU = Runtime.getRuntime().availableProcessors();\n+    static @Stable int NCPU;\n+\n+    static {\n+        runtimeSetup();\n+    }\n+\n+    \/\/ Called from JVM when loading an AOT cache.\n+    private static void runtimeSetup() {\n+        NCPU = Runtime.getRuntime().availableProcessors();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+        runtimeSetup();\n+    }\n+\n+    \/\/ Called from JVM when loading an AOT cache\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -532,0 +532,1 @@\n+ -runtime\/cds\/appcds\/BadBSM.java \\\n@@ -539,0 +540,1 @@\n+ -runtime\/cds\/appcds\/DumpClassListWithLF.java \\\n@@ -541,0 +543,2 @@\n+ -runtime\/cds\/appcds\/dynamicArchive\/LambdasInTwoArchives.java \\\n+ -runtime\/cds\/appcds\/HelloExtTest.java \\\n@@ -554,0 +558,1 @@\n+ -runtime\/cds\/appcds\/LambdaProxyClasslist.java \\\n@@ -559,0 +564,3 @@\n+ -runtime\/cds\/appcds\/StaticArchiveWithLambda.java \\\n+ -runtime\/cds\/appcds\/TestEpsilonGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestParallelGCWithCDS.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,5 @@\n-            output.shouldMatch(\"Skipping.LambdaContainsOldInfApp[$][$]Lambda.*0x.*:.*Old.class.has.been.linked\");\n+            if (CDSTestUtils.isAOTClassLinkingEnabled()) {\n+                output.shouldMatch(\"Cannot aot-resolve Lambda proxy because OldProvider is excluded\");\n+            } else {\n+                output.shouldMatch(\"Skipping.LambdaContainsOldInfApp[$][$]Lambda.*0x.*:.*Old.class.has.been.linked\");\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaContainsOldInf.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-              .shouldMatch(\".class.load. LambdaWithOldClassApp[$][$]Lambda.*\/0x.*source:.*shared objects file\")\n@@ -73,0 +72,5 @@\n+        if (!CDSTestUtils.isAOTClassLinkingEnabled()) {\n+            \/\/ With AOTClassLinking, we don't archive any lambda with old classes in the method\n+            \/\/ signatures.\n+            output.shouldMatch(\".class.load. LambdaWithOldClassApp[$][$]Lambda.*\/0x.*source:.*shared objects file\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaWithOldClass.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,5 @@\n+        test(false);\n+        test(true);\n+    }\n+\n+    static void test(boolean aotClassLinking) throws Exception {\n@@ -60,0 +65,3 @@\n+        if (aotClassLinking) {\n+            opts.addPrefix(\"-XX:+AOTClassLinking\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaWithUseImplMethodHandle.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,0 +65,5 @@\n+        testCase(\"Cannot use a different main module\");\n+        TestCommon.run(\"-cp\", appJar, \"-Xlog:cds\", \"-m\", \"jdk.compiler\/com.sun.tools.javac.Main\")\n+            .assertAbnormalExit(\"CDS archive has aot-linked classes.\" +\n+                                \" It cannot be used when archived full module graph is not used.\");\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/AOTClassLinkingVMOptions.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.test.lib.cds.CDSTestUtils;\n@@ -154,3 +155,4 @@\n-        testCase(\"Use a disallowed class: in unnamed module but not in unname package\");\n-        output = dumpBootAndHello(CDSTestClassE_name);\n-        mustFail(output, \"Class pkg.ClassInPackage not allowed in archive heap\");\n+        if (!CDSTestUtils.isAOTClassLinkingEnabled()) {\n+            testCase(\"Use a disallowed class: in unnamed module but not in unname package\");\n+            output = dumpBootAndHello(CDSTestClassE_name);\n+            mustFail(output, \"Class pkg.ClassInPackage not allowed in archive heap\");\n@@ -158,3 +160,4 @@\n-        testCase(\"Use a disallowed class: not in java.base module\");\n-        output = dumpBootAndHello(CDSTestClassF_name);\n-        mustFail(output, \"Class java.util.logging.Level not allowed in archive heap\");\n+            testCase(\"Use a disallowed class: not in java.base module\");\n+            output = dumpBootAndHello(CDSTestClassF_name);\n+            mustFail(output, \"Class java.util.logging.Level not allowed in archive heap\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-            .shouldContain(\"unreg OldClass unlinked\");\n+            .shouldContain(\"unreg OldClass old unlinked\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/CustomClassListDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,388 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary AOT resolution of lambda expressions\n+ * @bug 8340836\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/\n+ * @build AOTLinkedLambdas\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 AOTLinkedLambdasApp InitTracker\n+ *                 IntfWithNoClinit IntfWithNoClinit2\n+ *                 IA IB IC ID1 ID2 IE1 IE2 IF1 IF2 IG1 IG2 IH1 IH2 IH3\n+ *                 FooA FooB\n+ *                 BarA BarB BarC\n+ * @run driver AOTLinkedLambdas\n+ *\/\n+\n+import java.util.function.Supplier;\n+import static java.util.stream.Collectors.*;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTLinkedLambdas {\n+    static final String classList = \"AOTLinkedLambdas.classlist\";\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = AOTLinkedLambdasApp.class.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        CDSTestUtils.dumpClassList(classList, \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"Hello AOTLinkedLambdasApp\");\n+            });\n+\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-XX:+AOTClassLinking\",\n+                       \"-Xlog:cds+resolve=trace\",\n+                       \"-Xlog:cds+class=debug\",\n+                       \"-cp\", appJar);\n+\n+        OutputAnalyzer dumpOut = CDSTestUtils.createArchiveAndCheck(opts);\n+        dumpOut.shouldContain(\"Can aot-resolve Lambda proxy of interface type IA\");\n+        dumpOut.shouldContain(\"Can aot-resolve Lambda proxy of interface type IB\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IC\");\n+        dumpOut.shouldContain(\"Can aot-resolve Lambda proxy of interface type ID2\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IE2\"); \/\/ unsupported = IE1\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IF2\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IG2\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IH3\"); \/\/ unsupported = IH1\n+\n+        CDSOptions runOpts = (new CDSOptions())\n+            .setUseVersion(false)\n+            .addPrefix(\"-Xlog:cds\",\n+                       \"-esa\",         \/\/ see JDK-8340836\n+                       \"-cp\", appJar)\n+            .addSuffix(mainClass);\n+\n+        CDSTestUtils.run(runOpts)\n+            .assertNormalExit(\"Hello AOTLinkedLambdasApp\",\n+                              \"hello, world\");\n+    }\n+}\n+\n+class AOTLinkedLambdasApp {\n+    static {\n+        System.out.println(\"AOTLinkedLambdasApp.<clinit>\");\n+    }\n+    public static void main(String args[]) {\n+        System.out.println(\"Hello AOTLinkedLambdasApp\");\n+\n+        \/\/ (1) Simple tests\n+        var words = java.util.List.of(\"hello\", \"fuzzy\", \"world\");\n+        System.out.println(words.stream().filter(w->!w.contains(\"u\")).collect(joining(\", \")));\n+        \/\/ => hello, world\n+\n+        \/\/ (2) Test for <clinit> order.\n+        testClinitOrder();\n+    }\n+\n+\n+    \/\/ Check that aot-linking of lambdas does not cause <clinit> to be skipped or\n+    \/\/ otherwise executed in the wrong order.\n+    \/\/\n+    \/\/ A lambda is declared to implement an interface X, but it also implicitly\n+    \/\/ implements all super interfaces of X.\n+    \/\/\n+    \/\/ For any interface IN that's implemented by a lambda, if IN has declared\n+    \/\/ a non-abstract, non-static method (JVMS 5.5. Initialization), IN must be\n+    \/\/ initialized before the lambda can be linked. If IN::<clinit> exists, the\n+    \/\/ initialization of IN can have side effects.\n+    \/\/\n+    \/\/ AOTConstantPoolResolver::is_indy_resolution_deterministic() excludes\n+    \/\/ any lambda if initializing its interfaces can cause side effects. This test\n+    \/\/ checks that such exclusions are working as expected.\n+    \/\/\n+    \/\/ This test also proves that is_indy_resolution_deterministic() doen't need to check\n+    \/\/ for all other types that are mentioned by the lambda call site, as those classes\n+    \/\/ will not be initialized as part of linking the lambda.\n+    static void testClinitOrder() {\n+        \/*\n+         * An indy callsite is associated with the following MethodType and MethodHandles:\n+         *\n+         * https:\/\/github.com\/openjdk\/jdk\/blob\/580eb62dc097efeb51c76b095c1404106859b673\/src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java#L293-L309\n+         *\n+         * MethodType factoryType         The expected signature of the {@code CallSite}.  The\n+         *                                parameter types represent the types of capture variables;\n+         *                                the return type is the interface to implement.   When\n+         *                                used with {@code invokedynamic}, this is provided by\n+         *                                the {@code NameAndType} of the {@code InvokeDynamic}\n+         *\n+         * MethodType interfaceMethodType Signature and return type of method to be\n+         *                                implemented by the function object.\n+         *\n+         * MethodHandle implementation    A direct method handle describing the implementation\n+         *                                method which should be called (with suitable adaptation\n+         *                                of argument types and return types, and with captured\n+         *                                arguments prepended to the invocation arguments) at\n+         *                                invocation time.\n+         *\n+         * MethodType dynamicMethodType   The signature and return type that should\n+         *                                be enforced dynamically at invocation time.\n+         *                                In simple use cases this is the same as\n+         *                                {@code interfaceMethodType}.\n+         *\/\n+\n+        \/\/ Initial condition: no <clinit> used by our Foo* and Bar* types have been called.\n+        InitTracker.assertOrder(\"InitTracker\");\n+\n+        \/\/==============================\n+        \/\/ Case (i) -- Check for types used by factoryType, interfaceMethodType and dynamicMethodType\n+        \/\/             (Note: no tests for captured variables in factoryType yet; will be tested in case (ii))\n+        \/\/ factoryType         = \"()LIntfWithNoClinit;\n+        \/\/ interfaceMethodType = \"(LFooB;)LFooA;\"\n+        \/\/ implementation      = \"REF_invokeStatic AOTLinkedLambdasApp.implAB:(LBarB;)LBarA;\"\n+        \/\/ dynamicMethodType   = \"(LBarB;)LBarA;\"\n+        IntfWithNoClinit<BarA, BarB> noclinit = AOTLinkedLambdasApp::implAB;\n+\n+        \/\/ None of the Foo? and Bar? types used by the lambda should have been initialized yet, even though\n+        \/\/ the indy callsite has been resolved now.\n+        InitTracker.assertOrder(\"InitTracker\");\n+\n+        BarB barB = new BarB();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB\");\n+        BarA barA = noclinit.doit(barB);\n+        System.out.println(barB);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA\");\n+\n+        \/\/==============================\n+        \/\/ Case (ii) -- Check for types used by captured variables in factoryType\n+        BarC barC = null;\n+        IntfWithNoClinit2 noclinit2 = () -> { return barC.hashCode(); };\n+        try {\n+            noclinit2.doit();\n+            throw new RuntimeException(\"NullPointerException should have been thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected\n+        }\n+        \/\/ BarC shouldn't be initialized as no instances of it has been created.\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA\");\n+\n+\n+        \/\/==============================\n+        \/\/ (IA) No default methods -- is not initialized during lambda linking. Lambda can be archived.\n+        IA ia = () -> {};\n+        ia.doit();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA\");\n+        System.out.println(IA._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA\");\n+\n+        \/\/==============================\n+        \/\/ (IB) Has default method but has not <clinit> -- OK to initialize IB during lambda linking. Lambda can be archived.\n+        IB ib = () -> {};\n+        ib.doit();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA\");\n+\n+        \/\/==============================\n+        \/\/ (IC) Has both default method and <clinit> -- cannot AOT link the lambda\n+        IC ic = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC\");\n+        ic.doit();\n+\n+        \/\/==============================\n+        \/\/ ID1 - has default method, but no <clinit>\n+        \/\/ ID2 - has <clinit>, but no default method\n+        ID2 id2 = () -> {};\n+        id2.doit();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC\");\n+        System.out.println(ID2._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2\");\n+\n+       \/\/==============================\n+        \/\/ IE1 - has both default method and <clinit>\n+        \/\/ IE2 - has <clinit>, but no default method\n+        IE2 ie2 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1\");\n+        System.out.println(IE2._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2\");\n+\n+       \/\/==============================\n+        \/\/ IF1 - has <clinit>, but no default method\n+        \/\/ IF2 - has both default method and <clinit>\n+        IF2 if2 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2\");\n+        System.out.println(IF1._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1\");\n+\n+       \/\/==============================\n+        \/\/ IG1 - has both default method and <clinit>\n+        \/\/ IG2 - has both default method and <clinit>\n+        IG2 ig2 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2\");\n+\n+       \/\/==============================\n+        \/\/ Similar to IE1\/IE2, but IH3 is one more level away from IH1\n+        \/\/ IH1 - has both default method and <clinit>\n+        \/\/ IH2 - has <clinit>, but no default method\n+        \/\/ IH3 - has <clinit>, but no default method\n+        IH3 ih3 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2, IH1\");\n+        System.out.println(IH3._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2, IH1, IH3\");\n+        System.out.println(IH2._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2, IH1, IH3, IH2\");\n+    }\n+\n+    static BarA implAB(BarB param) {\n+        return new BarA(param);\n+    }\n+}\n+\n+\n+\/\/ An interface with no <clinit> method. A lambda implementing this\n+\/\/ interface can be AOT-linked.\n+@FunctionalInterface\n+interface IntfWithNoClinit<X extends FooA, Y extends FooB> {\n+    X doit(Y param);\n+}\n+\n+\/\/ Another interface with no <clinit> method. A lambda implementing this\n+\/\/ interface can be AOT-linked.\n+@FunctionalInterface\n+interface IntfWithNoClinit2 {\n+    int doit();\n+}\n+\n+\n+\/\/ (IA) No default methods -- is not initialized during lambda linking. Lambda can be archived.\n+@FunctionalInterface interface IA {\n+    static int _dummy = InitTracker.trackEvent(\"IA\");\n+    void doit();\n+}\n+\n+\/\/ (IB) Has default method but has not <clinit> -- OK to initialize IB during lambda linking. Lambda can be archived.\n+@FunctionalInterface interface IB {\n+    default int dummy() { return 0; }\n+    void doit();\n+}\n+\n+\/\/ (IC) Has both default method and <clinit> -- cannot AOT link the lambda\n+@FunctionalInterface interface IC {\n+    static int _dummy = InitTracker.trackEvent(\"IC\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n+}\n+\n+\/\/ (ID1\/ID2)\n+@FunctionalInterface interface ID1 { \/\/ has default method, but no <clinit>\n+    default int dummy() { return 0; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface ID2 extends ID1 { \/\/ has <clinit>, but no default method\n+    static int _dummy = InitTracker.trackEvent(\"ID2\");\n+}\n+\n+\/\/ (IE1\/IE2)\n+@FunctionalInterface interface IE1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IE1\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IE2 extends IE1 { \/\/ has <clinit>, but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IE2\");\n+}\n+\n+\/\/ (IF1\/IF2)\n+@FunctionalInterface interface IF1 { \/\/ has <clinit>, but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IF1\");\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IF2 extends IF1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IF2\");\n+    default int dummy() { return 0; }\n+}\n+\n+\/\/ (IG1\/IG2)\n+@FunctionalInterface interface IG1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IG1\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IG2 extends IG1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IG2\");\n+    default int dummy() { return _dummy; }\n+}\n+\n+\/\/ (IH1\/IH2\/IH3)\n+@FunctionalInterface interface IH1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IH1\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IH2 extends IH1 { \/\/ has <clinit> but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IH2\");\n+}\n+\n+@FunctionalInterface interface IH3 extends IH2 { \/\/ has <clinit> but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IH3\");\n+}\n+\n+\n+class InitTracker {\n+    static String actualOrder = \"InitTracker\";\n+    static int trackEvent(String event) {\n+        actualOrder += \", \" + event;\n+        return actualOrder.lastIndexOf(',');\n+    }\n+    static void assertOrder(String wantOrder) {\n+        System.out.println(\"wantOrder   = \" + wantOrder);\n+        System.out.println(\"actualOrder = \" + actualOrder);\n+        if (!actualOrder.equals(wantOrder)) {\n+            throw new RuntimeException(\"Want <clinit> order: {\" + wantOrder + \"}, but got {\" + actualOrder + \"}\");\n+        }\n+    }\n+}\n+\n+interface FooA {\n+    static final int _dummy = InitTracker.trackEvent(\"FooA\");\n+    default int dummy() { return _dummy; }\n+}\n+\n+interface FooB {\n+    static final int _dummy = InitTracker.trackEvent(\"FooB\");\n+    default int dummy() { return _dummy; }\n+}\n+\n+class BarA implements FooA {\n+    static {InitTracker.trackEvent(\"BarA\");}\n+    BarA(BarB dummy) {}\n+}\n+\n+class BarB implements FooB {\n+    static {InitTracker.trackEvent(\"BarB\");}\n+}\n+\n+class BarC {\n+    static {InitTracker.trackEvent(\"BarC\");}\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedLambdas.java","additions":388,"deletions":0,"binary":false,"changes":388,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Dump time resolutiom of constant pool entries.\n+ * @summary Dump time resolution of constant pool entries.\n@@ -31,1 +31,2 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/\n+ * @build OldProvider OldClass OldConsumer\n@@ -33,1 +34,4 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar ResolvedConstantsApp ResolvedConstantsFoo ResolvedConstantsBar\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 ResolvedConstantsApp ResolvedConstantsFoo ResolvedConstantsBar\n+ *                 MyInterface InterfaceWithClinit NormalClass\n+ *                 OldProvider OldClass OldConsumer SubOfOldClass\n@@ -37,0 +41,1 @@\n+import java.util.function.Consumer;\n@@ -40,0 +45,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -62,1 +68,2 @@\n-                       \"-Xlog:cds+resolve=trace\");\n+                       \"-Xlog:cds+resolve=trace\",\n+                       \"-Xlog:cds+class=debug\");\n@@ -69,1 +76,1 @@\n-        CDSTestUtils.createArchiveAndCheck(opts)\n+        OutputAnalyzer out = CDSTestUtils.createArchiveAndCheck(opts);\n@@ -73,1 +80,1 @@\n-            .shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\"))\n+        out.shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\"))\n@@ -139,0 +146,11 @@\n+\n+\n+        \/\/ Indy References ---\n+        if (aotClassLinking) {\n+            out.shouldContain(\"Cannot aot-resolve Lambda proxy because OldConsumer is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldProvider is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldClass is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy of interface type InterfaceWithClinit\")\n+               .shouldMatch(\"klasses.* app *NormalClass[$][$]Lambda\/.* hidden aot-linked inited\")\n+               .shouldNotMatch(\"klasses.* app *SubOfOldClass[$][$]Lambda\/\");\n+        }\n@@ -169,0 +187,2 @@\n+\n+        testLambda();\n@@ -175,0 +195,66 @@\n+\n+    static void testLambda() {\n+        \/\/ The functional type used in the Lambda is an excluded class\n+        OldProvider op = () -> {\n+            return null;\n+        };\n+\n+        \/\/ A captured value is an instance of an excluded Class\n+        OldClass c = new OldClass();\n+        Runnable r = () -> {\n+            System.out.println(\"Test 1 \" + c);\n+        };\n+        r.run();\n+\n+        \/\/ The functional interface accepts an argument that's an excluded class\n+        MyInterface i = (o) -> {\n+            System.out.println(\"Test 2 \" + o);\n+        };\n+        i.dispatch(c);\n+\n+        \/\/ Method reference to old class\n+        OldConsumer oldConsumer = new OldConsumer();\n+        Consumer<String> wrapper = oldConsumer::consumeString;\n+        wrapper.accept(\"Hello\");\n+\n+        \/\/ Lambda of interfaces that have <clinit> are not archived.\n+        InterfaceWithClinit i2 = () -> {\n+            System.out.println(\"Test 3\");\n+        };\n+        i2.dispatch();\n+\n+        \/\/ These two classes have almost identical source code, but\n+        \/\/ only NormalClass should have its lambdas pre-resolved.\n+        \/\/ SubOfOldClass is \"old\" -- it should be excluded from the AOT cache,\n+        \/\/ so none of its lambda proxies should be cached\n+        NormalClass.testLambda();   \/\/ Lambda proxy should be cached\n+        SubOfOldClass.testLambda(); \/\/ Lambda proxy shouldn't be cached\n+    }\n+}\n+\n+class NormalClass {\n+    static void testLambda() {\n+        Runnable r = () -> {\n+            System.out.println(\"NormalClass testLambda\");\n+        };\n+        r.run();\n+    }\n+}\n+\n+class SubOfOldClass extends OldClass {\n+    static void testLambda() {\n+        Runnable r = () -> {\n+            System.out.println(\"SubOfOldClass testLambda\");\n+        };\n+        r.run();\n+    }\n+}\n+\n+interface MyInterface {\n+    void dispatch(OldClass c);\n+}\n+\n+interface InterfaceWithClinit {\n+    static final long X = System.currentTimeMillis();\n+    void dispatch();\n+    default long dummy() { return X; }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":92,"deletions":6,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/OldClass.jasm","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+super class OldConsumer\n+    version 49:0\n+{\n+\n+\n+Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+public Method consumeString:\"(Ljava\/lang\/String;)V\"\n+    stack 3 locals 2\n+{\n+        getstatic        Field java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+        new              class java\/lang\/StringBuilder;\n+        dup;\n+        invokespecial    Method java\/lang\/StringBuilder.\"<init>\":\"()V\";\n+        ldc              String \"Hello: \";\n+        invokevirtual    Method java\/lang\/StringBuilder.append:\"(Ljava\/lang\/String;)Ljava\/lang\/StringBuilder;\";\n+        aload_1;\n+        invokevirtual    Method java\/lang\/StringBuilder.append:\"(Ljava\/lang\/String;)Ljava\/lang\/StringBuilder;\";\n+        invokevirtual    Method java\/lang\/StringBuilder.toString:\"()Ljava\/lang\/String;\";\n+        invokevirtual    Method java\/io\/PrintStream.println:\"(Ljava\/lang\/String;)V\";\n+        return;\n+}\n+\n+} \/\/ end Class OldConsumer\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/OldConsumer.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.test.lib.cds.CDSTestUtils;\n@@ -49,1 +50,1 @@\n-        out.shouldNotContain(\"object points to a static field that may be reinitialized at runtime\");\n+        out.shouldNotContain(CDSTestUtils.MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n","filename":"test\/jdk\/jdk\/internal\/misc\/CDS\/ArchivedEnumTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+        output.shouldNotContain(CDSTestUtils.MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+    public static final String MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE =\n+        \"an object points to a static field that may hold a different value at runtime\";\n@@ -287,0 +289,1 @@\n+        output.shouldNotContain(MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n@@ -299,0 +302,1 @@\n+        output.shouldNotContain(MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n@@ -866,4 +870,10 @@\n-        String vmopts = System.getProperty(\"test.vm.opts\");\n-        String javaopts = System.getProperty(\"test.java.opts\");\n-        if (vmopts != null && vmopts.contains(\"-XX:+AOTClassLinking\")) {\n-            return true;\n+        return isBooleanVMOptionEnabledInCommandLine(\"AOTClassLinking\");\n+    }\n+\n+    public static boolean isBooleanVMOptionEnabledInCommandLine(String optionName) {\n+        String lastMatch = null;\n+        String pattern = \"^-XX:.\" + optionName + \"$\";\n+        for (String s : Utils.getTestJavaOpts()) {\n+            if (s.matches(pattern)) {\n+                lastMatch = s;\n+            }\n@@ -871,1 +881,1 @@\n-        if (javaopts != null && javaopts.contains(\"-XX:+AOTClassLinking\")) {\n+        if (lastMatch != null && lastMatch.equals(\"-XX:+\" + optionName)) {\n@@ -874,1 +884,0 @@\n-\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"}]}