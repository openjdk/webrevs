{"files":[{"patch":"@@ -35,0 +35,2 @@\n+\/\/ Detector for class names we wish to handle specially.\n+\/\/ It is either an exact string match or a string prefix match.\n@@ -48,0 +50,1 @@\n+    assert(_class_name != nullptr, \"caller resp.\");\n@@ -57,0 +60,1 @@\n+\/\/ Tell if ik has a name that matches one of the given specs.\n@@ -106,1 +110,1 @@\n-  if (ik->java_super() == vmClasses::Enum_klass()) {\n+  if (ik->is_enum_subclass()) {\n@@ -126,0 +130,27 @@\n+  \/\/ When a class is aot-inited, its static fields are already set up\n+  \/\/ by executing the <clinit> method at AOT assembly time.  Later on\n+  \/\/ in the production run, when the class would normally be\n+  \/\/ initialized, the VM performs guarding and synchronization as if\n+  \/\/ it were going to run the <clinit> again, but instead it simply\n+  \/\/ observes that that class was aot-inited.  The VM assumes that, if\n+  \/\/ it were to run <clinit> again, it would get a semantically\n+  \/\/ equivalent set of final field values, so it just adopts the\n+  \/\/ existing field values (from AOT assembly) and skips the call to\n+  \/\/ <clinit>.  There may at that point be fixups performed by ad hoc\n+  \/\/ code, if the VM recognizes a request in the library.\n+  \/\/\n+  \/\/ It is true that this is not generally correct for all possible\n+  \/\/ Java code.  A <clinit> method might have a side effect beyond\n+  \/\/ initializing the static fields.  It might send an email somewhere\n+  \/\/ noting the current time of day.  In that case, such an email\n+  \/\/ would have been sent during the AOT assembly phase, and the email\n+  \/\/ would NOT be sent again during production.  This is clearly NOT\n+  \/\/ what a user would want, if this were a general purpose facility.\n+  \/\/ But in fact it is only for certain well-behaved classes, which\n+  \/\/ are known NOT to have such side effects.  We know this because\n+  \/\/ the optimization (of skipping <clinit> for aot-init classes) is\n+  \/\/ only applied to classes fully defined by the JDK.\n+  \/\/\n+  \/\/ (A day may come when we figure out how to gracefully extend this\n+  \/\/ optimization to untrusted third parties, but it is not this day.)\n+  \/\/\n@@ -129,1 +160,16 @@\n-  \/\/ However, there are cases that cannot be automatically discovered. For\n+  \/\/ There are important cases where one aot-init class has a side\n+  \/\/ effect on another aot-class, a side effect which is not captured\n+  \/\/ in any static field value in either class.  The simplest example\n+  \/\/ is class A forces the initialization of class B.  In that case,\n+  \/\/ we need to aot-init either both classes or neither.  From looking\n+  \/\/ at the JDK state after AOT assembly is done, it is hard to tell\n+  \/\/ that A \"touched\" B and B might escape our notice.  Another common\n+  \/\/ example is A copying a field value from B.  We don't know where A\n+  \/\/ got the value, but it would be wrong to re-initialize B at\n+  \/\/ startup, while keeping the snapshot of the old B value in A.  In\n+  \/\/ general, if we aot-init A, we need to aot-init every class B that\n+  \/\/ somehow contributed to A's initial state, and every class C that\n+  \/\/ was somehow side-effected by A's initialization.  We say that the\n+  \/\/ aot-init of A is \"init-coupled\" to those of B and C.\n+  \/\/\n+  \/\/ So there are init-coupled classes that cannot be automatically discovered. For\n@@ -142,0 +188,3 @@\n+  \/\/ Luckily we do not need to be all-knowing in order to choose which\n+  \/\/ items to add to that table.  We have tools to help detect couplings.\n+  \/\/\n@@ -146,1 +195,25 @@\n-  \/\/ To see how it detects the problem with MethodHandles::IMPL_NAMES:\n+  \/\/\n+  \/\/ A class B is assumed to be init-coupled to some aot-init class if\n+  \/\/ B has a field which points to a live object X in the AOT heap.\n+  \/\/ The live object X was created by some other class A which somehow\n+  \/\/ used B's reference to X, perhaps with the help of an intermediate\n+  \/\/ class Z.  Or, B pulled the reference to X from some other class\n+  \/\/ Y, and B obtained that reference from Y (or an intermediate Z).\n+  \/\/ It is not certain how X got into the heap, nor whether B\n+  \/\/ contributed it, but it is a good heuristic that B is init-coupled\n+  \/\/ to X's class or some other aot-init class.  In any case, B should\n+  \/\/ be made an aot-init class as well, unless a manual inspection\n+  \/\/ shows that would be a problem.  If there is a problem, then the\n+  \/\/ JDK code for B and\/or X probably needs refactoring.  If there is\n+  \/\/ no problem, we add B to the list.  Typically the same scan will\n+  \/\/ find any other accomplices Y, Z, etc.  One failure would be a\n+  \/\/ class Q whose only initialization action is to scribble a special\n+  \/\/ value into B, from which the value X is derived and then makes\n+  \/\/ its way into the heap.  In that case, the heuristic does not\n+  \/\/ identify Q.  It is (currently) a human responsibility, of JDK\n+  \/\/ engineers, not to write such dirty JDK code, or to repair it if\n+  \/\/ it crops up.  Eventually we may have tools, or even a user mode\n+  \/\/ with design rules and checks, that will vet our code base more\n+  \/\/ automatically.\n+  \/\/\n+  \/\/ To see how the tool detects the problem with MethodHandles::IMPL_NAMES:\n@@ -181,0 +254,7 @@\n+  \/\/\n+  \/\/ Note that these potential problems only occur when one class gets\n+  \/\/ the aot-init treatment, AND another class is init-coupled to it,\n+  \/\/ AND the coupling is not detected.  Currently there are a number\n+  \/\/ classes that get the aot-init treatment, in java.lang.invoke\n+  \/\/ because of invokedynamic.  They are few enough for now to be\n+  \/\/ manually tracked.  There may be more in the future.\n@@ -182,0 +262,2 @@\n+  \/\/ IS_PREFIX means that we match all class names that start with a\n+  \/\/ prefix.  Otherwise, it is an exact match, of just one class name.\n@@ -186,0 +268,1 @@\n+      \/\/ everybody's favorite super\n@@ -187,0 +270,2 @@\n+\n+      \/\/ above we selected all enums; we must include their super as well\n@@ -200,0 +285,4 @@\n+    \/\/\n+    \/\/ We hope we can reduce the size of this list over time, and move\n+    \/\/ the responsibility for identifying such classes into the JDK\n+    \/\/ code itself.  See tracking RFE JDK-8342481.\n@@ -228,0 +317,2 @@\n+    \/\/ MethodHandleStatics is an example of a class that must NOT get the aot-init treatment,\n+    \/\/ because of its strong reliance on (a) final fields which are (b) environmentally determined.\n@@ -242,0 +333,1 @@\n+\/\/ See JDK-8342481.\n@@ -262,26 +354,0 @@\n-#ifdef ASSERT\n-void AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(InstanceKlass* ik) {\n-  assert(ik->has_aot_initialized_mirror(), \"must be\");\n-\n-  InstanceKlass* s = ik->java_super();\n-  if (s != nullptr) {\n-    DEBUG_ONLY(ResourceMark rm);\n-    assert(s->is_initialized(), \"super class %s of aot-inited class %s must have been initialized\",\n-           s->external_name(), ik->external_name());\n-    AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(s);\n-  }\n-\n-  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n-  int len = interfaces->length();\n-  for (int i = 0; i < len; i++) {\n-    InstanceKlass* intf = interfaces->at(i);\n-    if (!intf->is_initialized()) {\n-      \/\/ Note: an interface needs to be marked as is_initialized() only if\n-      \/\/ - it has a <clinit>\n-      \/\/ - it has at least one default method.\n-      assert(!intf->has_nonstatic_concrete_methods() || intf->class_initializer() == nullptr, \"uninitialized super interface %s of aot-inited class %s must not have <clinit>\",\n-             intf->external_name(), ik->external_name());\n-    }\n-  }\n-}\n-#endif\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":95,"deletions":29,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-\n-  static void assert_no_clinit_will_run_for_aot_init_class(InstanceKlass* ik) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,0 +126,4 @@\n+\/\/ ik is a candidate for aot-linking; see if it can really work\n+\/\/ that way, and return success or failure.  Not only must ik itself\n+\/\/ look like a class we can preload but its supers must also be\n+\/\/ aot-linkable.\n@@ -131,0 +135,1 @@\n+    \/\/ not loaded by a class loader which we know about\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -123,3 +123,3 @@\n-  BOOT2,       \/\/ All boots classes that not in java.base are loaded in the 2nd phase\n-  PLATFORM,\n-  APP,\n+  BOOT2,       \/\/ All boot classes that not in java.base are loaded in the 2nd phase\n+  PLATFORM,    \/\/ Classes for platform loader, loaded in the 2nd phase\n+  APP,         \/\/ Classes for the app loader, loaded in the 2nd phase\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-        \/\/ This is the interface type implemented by the lambda proxy\n+        \/\/ <k> is the interface type implemented by the lambda proxy\n@@ -377,1 +377,1 @@\n-          \/\/ pool_holder doesn't look like a valid class generated by javac\n+          \/\/ cp->pool_holder() doesn't look like a valid class generated by javac\n@@ -381,9 +381,8 @@\n-        InstanceKlass* ik = InstanceKlass::cast(k);\n-        if (ik->has_nonstatic_concrete_methods() && ik->class_initializer() != nullptr) {\n-          \/\/ We initialize the class of the archived lambda proxy at VM start-up, which will also initialize\n-          \/\/ the interface that it implements. If that interface has a clinit method that needs to be executed,\n-          \/\/ we can potentially change program execution order.\n-          if (log_is_enabled(Debug, cds, resolve)) {\n-            ResourceMark rm;\n-            log_debug(cds, resolve)(\"Cannot aot-resolve Lambda proxy of interface type %s (has <clinit>)\", k->external_name());\n-          }\n+        InstanceKlass* intf = InstanceKlass::cast(k);\n+        bool unsupported = intf->interface_needs_clinit_execution_as_super();\n+        if (log_is_enabled(Debug, cds, resolve)) {\n+          ResourceMark rm;\n+          log_debug(cds, resolve)(\"%s aot-resolve Lambda proxy of interface type %s\",\n+                                  unsupported ? \"Cannot\" : \"Can\", k->external_name());\n+        }\n+        if (unsupported) {\n@@ -447,0 +446,2 @@\n+  \/\/ We should mark the allowed BSMs in the JDK code using a private annotation.\n+  \/\/ See notes on RFE JDK-8342481.\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -250,0 +250,5 @@\n+\/\/ (Even if we were to support other loaders, we would still feel free to ignore any requirement\n+\/\/ of class unloading, for any class asset in the AOT cache.  Anything that makes it into the AOT\n+\/\/ cache has a lifetime dispensation from unloading.  After all, the AOT cache never grows, and\n+\/\/ we can assume that the user is content with its size, and doesn't need its footprint to shrink.)\n+\/\/\n@@ -267,0 +272,4 @@\n+  \/\/ Since a hidden class does not have a name, it cannot be reloaded\n+  \/\/ normally via the system dictionary. Instead, we have to finish the\n+  \/\/ loading job here.\n+\n@@ -311,5 +320,1 @@\n-        \/\/ No <clinit> of ik or any of its supertypes will be executed.\n-        \/\/ Their mirrors were already initialized during AOT cache assembly.\n-        AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(ik);\n-\n-        ik->initialize_from_cds(CHECK);\n+        ik->initialize_with_aot_initialized_mirror(CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -903,1 +903,1 @@\n-      } else if (src_ik->java_super() == vmClasses::Enum_klass()) {\n+      } else if (src_ik->is_enum_subclass()) {\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-         InstanceKlass::cast(k)->java_super() == vmClasses::Enum_klass();\n+         InstanceKlass::cast(k)->is_enum_subclass();\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-        if (field_ik->java_super() == vmClasses::Enum_klass()) {\n+        if (field_ik->is_enum_subclass()) {\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -435,0 +435,6 @@\n+\/\/TODO: we eventually want a more direct test for these kinds of things.\n+\/\/For example the JVM could record some bit of context from the creation\n+\/\/of the klass, such as who called the hidden class factory.  Using\n+\/\/string compares on names is fragile and will break as soon as somebody\n+\/\/changes the names in the JDK code.  See discussion in JDK-8342481 for\n+\/\/related ideas about marking AOT-related classes.\n@@ -847,0 +853,11 @@\n+\/\/ If <buffered_ik> has been initialized during the assembly phase, mark its\n+\/\/ has_aot_initialized_mirror bit. And then do the same for all supertypes of\n+\/\/ <buffered_ik>.\n+\/\/\n+\/\/ Note: a super interface <intf> of <buffered_ik> may not have been initialized, if\n+\/\/ <intf> has not declared any default methods.\n+\/\/\n+\/\/ Note: this function doesn not call InstanceKlass::initialize() -- we are inside\n+\/\/ a safepoint.\n+\/\/\n+\/\/ Returns true if one or more classes have been newly marked.\n@@ -848,1 +865,4 @@\n-  if (buffered_ik->name()->equals(\"java\/lang\/String\")) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"sanity\");\n+  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_ik), \"sanity\");\n+\n+  if (buffered_ik->has_aot_initialized_mirror()) { \/\/ already marked\n@@ -852,2 +872,0 @@\n-  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_ik), \"sanity\");\n-\n@@ -855,1 +873,1 @@\n-  if (buffered_ik->is_initialized() && !buffered_ik->has_aot_initialized_mirror()) {\n+  if (buffered_ik->is_initialized()) {\n@@ -861,0 +879,29 @@\n+    InstanceKlass* src_ik = ArchiveBuilder::current()->get_source_addr(buffered_ik);\n+\n+    \/\/ If we get here with a \"wild\" user class, which may have\n+    \/\/ uncontrolled <clinit> code, exit with an error.  Obviously\n+    \/\/ filtering logic upstream needs to detect APP classes and not mark\n+    \/\/ them for aot-init in the first place, but this will be the final\n+    \/\/ firewall.\n+\n+#ifndef PRODUCT\n+    \/\/ ArchiveHeapTestClass is used for a very small number of internal regression\n+    \/\/ tests (non-product builds only). It may initialize some unexpected classes.\n+    if (ArchiveHeapTestClass == nullptr)\n+#endif\n+    {\n+      if (!src_ik->in_javabase_module()) {\n+        \/\/ Class\/interface types in the boot loader may have been initialized as side effects\n+        \/\/ of JVM bootstrap code, so they are fine. But we need to check all other classes.\n+        if (buffered_ik->is_interface()) {\n+          \/\/ This probably means a bug in AOTConstantPoolResolver.::is_indy_resolution_deterministic()\n+          guarantee(!buffered_ik->interface_needs_clinit_execution_as_super(),\n+                    \"should not have initialized an interface whose <clinit> might have unpredictable side effects\");\n+        } else {\n+          \/\/ \"normal\" classes\n+          guarantee(HeapShared::is_archivable_hidden_klass(buffered_ik),\n+                    \"should not have initialized any non-interface, non-hidden classes outside of java.base\");\n+        }\n+      }\n+    }\n+\n@@ -862,1 +909,1 @@\n-    if (AOTClassInitializer::is_runtime_setup_required(ArchiveBuilder::current()->get_source_addr(buffered_ik))) {\n+    if (AOTClassInitializer::is_runtime_setup_required(src_ik)) {\n@@ -872,1 +919,1 @@\n-    Array<InstanceKlass*>* interfaces = buffered_ik->local_interfaces();\n+    Array<InstanceKlass*>* interfaces = buffered_ik->transitive_interfaces();\n@@ -874,1 +921,6 @@\n-      mark_for_aot_initialization(interfaces->at(i));\n+      InstanceKlass* intf = interfaces->at(i);\n+      mark_for_aot_initialization(intf);\n+      if (!intf->is_initialized()) {\n+        assert(!intf->interface_needs_clinit_execution_as_super(\/*also_check_supers*\/false), \"sanity\");\n+        assert(!intf->has_aot_initialized_mirror(), \"must not be marked\");\n+      }\n@@ -1130,19 +1182,0 @@\n-static bool is_trivial_clinit(InstanceKlass* ik) {\n-  if (ik->class_initializer() != nullptr) {\n-    return false;\n-  }\n-\n-  InstanceKlass* super = ik->java_super();\n-  if (super != nullptr && !is_trivial_clinit(super)) {\n-    return false;\n-  }\n-\n-  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n-  for (int i = 0; i < interfaces->length(); i++) {\n-    if (!is_trivial_clinit(interfaces->at(i))) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -1196,1 +1229,0 @@\n-        const char* trivial_clinit = \"\";\n@@ -1199,3 +1231,0 @@\n-          if (is_trivial_clinit(InstanceKlass::cast(src_ik))) {\n-            trivial_clinit = \" (trivial clinit)\";\n-          }\n@@ -1204,2 +1233,2 @@\n-          \"Archived object klass %s (%2d) => %s%s\",\n-          owner_name, i, subgraph_k->external_name(), trivial_clinit);\n+          \"Archived object klass %s (%2d) => %s\",\n+          owner_name, i, subgraph_k->external_name());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":61,"deletions":32,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -873,0 +873,3 @@\n+\n+      \/\/ Perhaps there is a way to avoid hard-coding these names here.\n+      \/\/ See discussion in JDK-8342481.\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -732,0 +732,12 @@\n+\/\/ JLS 8.9: An enum class is either implicitly final and derives\n+\/\/ from java.lang.Enum, or else is implicitly sealed to its\n+\/\/ anonymous subclasses.  This query detects both kinds, unless\n+\/\/ direct_only is true.  It does not validate the finality or\n+\/\/ sealing conditions: it merely checks for a super of Enum.\n+\/\/ This is sufficient for recognizing well-formed enums.\n+bool InstanceKlass::is_enum_subclass(bool direct_only) const {\n+  InstanceKlass* s = java_super();\n+  return (s == vmClasses::Enum_klass() ||\n+          (s != nullptr && s->java_super() == vmClasses::Enum_klass()));\n+}\n+\n@@ -789,2 +801,3 @@\n-static bool check_supertypes_of_aot_inited_class(InstanceKlass* ik) {\n-  assert(ik->has_aot_initialized_mirror(), \"must be\");\n+#ifdef ASSERT\n+void InstanceKlass::assert_no_clinit_will_run_for_aot_initialized_class() const {\n+  assert(has_aot_initialized_mirror(), \"must be\");\n@@ -792,2 +805,7 @@\n-  \/\/ Sanity check of all superclasses and superinterfaces.\n-  AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(ik);\n+  InstanceKlass* s = java_super();\n+  if (s != nullptr) {\n+    DEBUG_ONLY(ResourceMark rm);\n+    assert(s->is_initialized(), \"super class %s of aot-inited class %s must have been initialized\",\n+           s->external_name(), external_name());\n+    s->assert_no_clinit_will_run_for_aot_initialized_class();\n+  }\n@@ -795,15 +813,12 @@\n-  if (ik->has_nonstatic_concrete_methods()) {\n-    Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n-    int len = interfaces->length();\n-    for (int i = 0; i < len; i++) {\n-      InstanceKlass* intf = interfaces->at(i);\n-      if (!intf->is_initialized()) {\n-        assert(intf->class_initializer() == nullptr, \"should have been asserted\");\n-        if (log_is_enabled(Info, cds, init)) {\n-          ResourceMark rm;\n-          log_info(cds, init)(\"%s takes slow path because interface %s (%s <clinit>) is not yet initialized\",\n-                              ik->external_name(), intf->external_name(),\n-                              (intf->class_initializer() != nullptr) ? \"has\" : \"no\");\n-        }\n-        return false;\n-      }\n+  Array<InstanceKlass*>* interfaces = local_interfaces();\n+  int len = interfaces->length();\n+  for (int i = 0; i < len; i++) {\n+    InstanceKlass* intf = interfaces->at(i);\n+    if (!intf->is_initialized()) {\n+      ResourceMark rm;\n+      \/\/ Note: an interface needs to be marked as is_initialized() only if\n+      \/\/ - it has a <clinit>\n+      \/\/ - it has declared a default method.\n+      assert(!intf->interface_needs_clinit_execution_as_super(\/*also_check_supers*\/false),\n+             \"uninitialized super interface %s of aot-inited class %s must not have <clinit>\",\n+             intf->external_name(), external_name());\n@@ -812,2 +827,0 @@\n-\n-  return true;\n@@ -815,0 +828,7 @@\n+#endif\n+\n+void InstanceKlass::initialize_with_aot_initialized_mirror(TRAPS) {\n+  assert(has_aot_initialized_mirror(), \"must be\");\n+  assert(CDSConfig::is_loading_heap(), \"must be\");\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"must be\");\n+  assert_no_clinit_will_run_for_aot_initialized_class();\n@@ -816,1 +836,0 @@\n-void InstanceKlass::initialize_from_cds(TRAPS) {\n@@ -821,6 +840,4 @@\n-  if (has_aot_initialized_mirror() && CDSConfig::is_loading_heap() &&\n-      check_supertypes_of_aot_inited_class(this)) {\n-    if (log_is_enabled(Info, cds, init)) {\n-      ResourceMark rm;\n-      log_info(cds, init)(\"%s (quickest)\", external_name());\n-    }\n+  if (log_is_enabled(Info, cds, init)) {\n+    ResourceMark rm;\n+    log_info(cds, init)(\"%s (aot-inited)\", external_name());\n+  }\n@@ -828,1 +845,1 @@\n-    link_class(CHECK);\n+  link_class(CHECK);\n@@ -831,13 +848,6 @@\n-    {\n-      Handle h_init_lock(THREAD, init_lock());\n-      ObjectLocker ol(h_init_lock, THREAD);\n-      assert(!is_initialized(), \"sanity\");\n-      assert(!is_being_initialized(), \"sanity\");\n-      assert(!is_in_error_state(), \"sanity\");\n-    }\n-#endif\n-\n-    set_init_thread(THREAD);\n-    set_initialization_state_and_notify(fully_initialized, CHECK);\n-    AOTClassInitializer::call_runtime_setup(this, CHECK);\n-    return;\n+  {\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, THREAD);\n+    assert(!is_initialized(), \"sanity\");\n+    assert(!is_being_initialized(), \"sanity\");\n+    assert(!is_in_error_state(), \"sanity\");\n@@ -845,0 +855,1 @@\n+#endif\n@@ -846,9 +857,3 @@\n-  if (log_is_enabled(Info, cds, init)) {\n-    \/\/ If we have a preinit mirror, we may come to here if a supertype is not\n-    \/\/ yet initialized. It will still be quicker than usual, as we will skip the\n-    \/\/ execution of <clinit> of this class.\n-    ResourceMark rm;\n-    log_info(cds, init)(\"%s%s\", external_name(),\n-                        (has_aot_initialized_mirror() && CDSConfig::is_loading_heap()) ? \" (quicker)\" : \"\");\n-  }\n-  initialize(THREAD);\n+  set_init_thread(THREAD);\n+  set_initialization_state_and_notify(fully_initialized, CHECK);\n+  AOTClassInitializer::call_runtime_setup(this, CHECK);\n@@ -1683,0 +1688,41 @@\n+\/\/ If a class that implements this interface is initialized, is the JVM required\n+\/\/ to first execute a <clinit> method declared in this interface,\n+\/\/ or (if also_check_supers==true) any of the super types of this interface?\n+\/\/\n+\/\/ JVMS 5.5. Initialization, step 7: Next, if C is a class rather than\n+\/\/ an interface, then let SC be its superclass and let SI1, ..., SIn\n+\/\/ be all superinterfaces of C (whether direct or indirect) that\n+\/\/ declare at least one non-abstract, non-static method.\n+\/\/\n+\/\/ So when an interface is initialized, it does not look at its\n+\/\/ supers. But a proper class will ensure that all of its supers have\n+\/\/ run their <clinit> methods, except that it disregards interfaces\n+\/\/ that lack a non-static concrete method (i.e., a default method).\n+\/\/ Therefore, you should probably call this method only when the\n+\/\/ current class is a super of some proper class, not an interface.\n+bool InstanceKlass::interface_needs_clinit_execution_as_super(bool also_check_supers) const {\n+  assert(is_interface(), \"must be\");\n+\n+  if (!has_nonstatic_concrete_methods()) {\n+    \/\/ quick check: no nonstatic concrete methods are declared by this or any super interfaces\n+    return false;\n+  }\n+\n+  \/\/ JVMS 5.5. Initialization\n+  \/\/ ...If C is an interface that declares a non-abstract,\n+  \/\/ non-static method, the initialization of a class that\n+  \/\/ implements C directly or indirectly.\n+  if (declares_nonstatic_concrete_methods() && class_initializer() != nullptr) {\n+    return true;\n+  }\n+  if (also_check_supers) {\n+    Array<InstanceKlass*>* all_ifs = transitive_interfaces();\n+    for (int i = 0; i < all_ifs->length(); ++i) {\n+      InstanceKlass* super_intf = all_ifs->at(i);\n+      if (super_intf->declares_nonstatic_concrete_methods() && super_intf->class_initializer() != nullptr) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n@@ -3010,0 +3056,4 @@\n+bool InstanceKlass::in_javabase_module() const {\n+  return module()->name() == vmSymbols::java_base();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":101,"deletions":51,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -433,0 +433,3 @@\n+  \/\/ test for enum class (or possibly an anonymous subclass within a sealed enum)\n+  bool is_enum_subclass(bool direct_only = false) const;\n+\n@@ -479,0 +482,1 @@\n+  bool in_javabase_module() const;\n@@ -535,1 +539,2 @@\n-  void initialize_from_cds(TRAPS);\n+  void initialize_with_aot_initialized_mirror(TRAPS);\n+  void assert_no_clinit_will_run_for_aot_initialized_class() const NOT_DEBUG_RETURN;\n@@ -542,0 +547,1 @@\n+  bool interface_needs_clinit_execution_as_super(bool also_check_supers=true) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-    \/\/ The archived mirror is already initialized dur AOT-cache assembly. No need to call <clinit>\n+    \/\/ archived mirror already initialized by AOT-cache assembly: no further need to call <clinit>\n@@ -199,1 +199,2 @@\n-    \/\/ If this class has an aot-inititalized mirror, does this class require runtimeSetup() to be called?\n+    \/\/ If this class has been aot-inititalized, do we need to call its runtimeSetup()\n+    \/\/ method during the production run?\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- *                 IntfWithClinit IntfWithClinit2\n+ *                 IA IB IC ID1 ID2 IE1 IE2 IF1 IF2 IG1 IG2 IH1 IH2 IH3\n@@ -68,2 +68,8 @@\n-        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IntfWithClinit (has <clinit>)\");\n-        dumpOut.shouldNotContain(\"Cannot aot-resolve Lambda proxy of interface type IntfWithClinit2 (has <clinit>)\");\n+        dumpOut.shouldContain(\"Can aot-resolve Lambda proxy of interface type IA\");\n+        dumpOut.shouldContain(\"Can aot-resolve Lambda proxy of interface type IB\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IC\");\n+        dumpOut.shouldContain(\"Can aot-resolve Lambda proxy of interface type ID2\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IE2\"); \/\/ unsupported = IE1\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IF2\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IG2\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IH3\"); \/\/ unsupported = IH1\n@@ -101,1 +107,2 @@\n-    \/\/ Check that aot-linking of indys do not run <clinit> in unexpected order:\n+    \/\/ Check that aot-linking of lambdas does not cause <clinit> to be skipped or\n+    \/\/ otherwise executed in the wrong order.\n@@ -103,3 +110,2 @@\n-    \/\/     For any type T that *appears* in an indy callsite, if T::<clinit> exists and\n-    \/\/     must be executed during the linking of this callsite, then T::<clinit>\n-    \/\/     must be executed the first time this indy instruction is executed, not earlier.\n+    \/\/ A lambda is declared to implement an interface X, but it also implicitly\n+    \/\/ implements all super interfaces of X.\n@@ -107,2 +113,4 @@\n-    \/\/ This test case tries to enumerate all possibilities where a type T may appear\n-    \/\/ in an indy callsite, and asserts when T is initialized.\n+    \/\/ For any interface IN that's implemented by a lambda, if IN has declared\n+    \/\/ a non-abstract, non-static method (JVMS 5.5. Initialization), IN must be\n+    \/\/ initialized before the lambda can be linked. If IN::<clinit> exists, the\n+    \/\/ initialization of IN can have side effects.\n@@ -110,3 +118,7 @@\n-    \/\/ Note: although T may appear in many parts of an indy callsite, ONLY the return type\n-    \/\/ of factoryType must be initialized during the linking of this callsite. All other types\n-    \/\/ will be initialized per the regular \"4 bytecode rule\" of getstatic\/putstatic\/new\/instanceof.\n+    \/\/ AOTConstantPoolResolver::is_indy_resolution_deterministic() excludes\n+    \/\/ any lambda if initializing its interfaces can cause side effects. This test\n+    \/\/ checks that such exclusions are working as expected.\n+    \/\/\n+    \/\/ This test also proves that is_indy_resolution_deterministic() doen't need to check\n+    \/\/ for all other types that are mentioned by the lambda call site, as those classes\n+    \/\/ will not be initialized as part of linking the lambda.\n@@ -140,1 +152,1 @@\n-        \/\/ Initial condition: no <clinit> used by our Foo? and Bar? types have been called.\n+        \/\/ Initial condition: no <clinit> used by our Foo* and Bar* types have been called.\n@@ -175,0 +187,9 @@\n+\n+        \/\/==============================\n+        \/\/ (IA) No default methods -- is not initialized during lambda linking. Lambda can be archived.\n+        IA ia = () -> {};\n+        ia.doit();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA\");\n+        System.out.println(IA._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA\");\n+\n@@ -176,4 +197,4 @@\n-        \/\/ Case (iii) -- factoryType has a <clinit> and must be initialized during\n-        \/\/ the indy resolution. This lambda CANNOT be aot-linked.\n-        \/\/ factoryType = \"()LIntfWithClinit;\"\n-        IntfWithClinit hasclinit = () -> { return 1234; };\n+        \/\/ (IB) Has default method but has not <clinit> -- OK to initialize IB during lambda linking. Lambda can be archived.\n+        IB ib = () -> {};\n+        ib.doit();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA\");\n@@ -181,2 +202,5 @@\n-        \/\/ must be initialized even before the lambda is used.\n-        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IntfWithClinit\");\n+        \/\/==============================\n+        \/\/ (IC) Has both default method and <clinit> -- cannot AOT link the lambda\n+        IC ic = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC\");\n+        ic.doit();\n@@ -185,13 +209,41 @@\n-        \/\/ Case (iv) -- factoryType has a <clinit>, but it doesn't need to be initialized during\n-        \/\/ the indy resolution (see IntfWithClinit2). This lambda can be aot-linked.\n-        \/\/ factoryType = \"()LIntfWithClinit2;\"\n-        IntfWithClinit2 hasclinit2 = () -> { return 1234; };\n-        \/\/ IntfWithClinit2 must not be initialized yet\n-        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IntfWithClinit\");\n-\n-        System.out.println(hasclinit2.doit());\n-        \/\/ IntfWithClinit2 must not be initialized yet\n-        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IntfWithClinit\");\n-\n-         System.out.println(IntfWithClinit2._dummy);\n-        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IntfWithClinit, IntfWithClinit2\");\n+        \/\/ ID1 - has default method, but no <clinit>\n+        \/\/ ID2 - has <clinit>, but no default method\n+        ID2 id2 = () -> {};\n+        id2.doit();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC\");\n+        System.out.println(ID2._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2\");\n+\n+       \/\/==============================\n+        \/\/ IE1 - has both default method and <clinit>\n+        \/\/ IE2 - has <clinit>, but no default method\n+        IE2 ie2 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1\");\n+        System.out.println(IE2._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2\");\n+\n+       \/\/==============================\n+        \/\/ IF1 - has <clinit>, but no default method\n+        \/\/ IF2 - has both default method and <clinit>\n+        IF2 if2 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2\");\n+        System.out.println(IF1._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1\");\n+\n+       \/\/==============================\n+        \/\/ IG1 - has both default method and <clinit>\n+        \/\/ IG2 - has both default method and <clinit>\n+        IG2 ig2 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2\");\n+\n+       \/\/==============================\n+        \/\/ Similar to IE1\/IE2, but IH3 is one more level away from IH1\n+        \/\/ IH1 - has both default method and <clinit>\n+        \/\/ IH2 - has <clinit>, but no default method\n+        \/\/ IH3 - has <clinit>, but no default method\n+        IH3 ih3 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2, IH1\");\n+        System.out.println(IH3._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2, IH1, IH3\");\n+        System.out.println(IH2._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2, IH1, IH3, IH2\");\n@@ -220,7 +272,16 @@\n-\/\/ A functional interface with a <clinit> that must be executed before we instantiate\n-\/\/ any lambda that implements this interface. Requirements:\n-\/\/ - the interface has a <clinit> function.\n-\/\/ - the interface has at least one default method.\n-@FunctionalInterface\n-interface IntfWithClinit {\n-    static final int _dummy = InitTracker.trackEvent(\"IntfWithClinit\");\n+\n+\/\/ (IA) No default methods -- is not initialized during lambda linking. Lambda can be archived.\n+@FunctionalInterface interface IA {\n+    static int _dummy = InitTracker.trackEvent(\"IA\");\n+    void doit();\n+}\n+\n+\/\/ (IB) Has default method but has not <clinit> -- OK to initialize IB during lambda linking. Lambda can be archived.\n+@FunctionalInterface interface IB {\n+    default int dummy() { return 0; }\n+    void doit();\n+}\n+\n+\/\/ (IC) Has both default method and <clinit> -- cannot AOT link the lambda\n+@FunctionalInterface interface IC {\n+    static int _dummy = InitTracker.trackEvent(\"IC\");\n@@ -228,1 +289,1 @@\n-    int doit();\n+    void doit();\n@@ -231,7 +292,37 @@\n-\/\/ A functional interface with a <clinit>, but it doesn't need to be initialized because\n-\/\/ it doesn't have any default methods.\n-\/\/ The <clinit> should be accessed only when IntfWithClinit2._dummy is accessed.\n-@FunctionalInterface\n-interface IntfWithClinit2 {\n-    static final int _dummy = InitTracker.trackEvent(\"IntfWithClinit2\");\n-    int doit();\n+\/\/ (ID1\/ID2)\n+@FunctionalInterface interface ID1 { \/\/ has default method, but no <clinit>\n+    default int dummy() { return 0; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface ID2 extends ID1 { \/\/ has <clinit>, but no default method\n+    static int _dummy = InitTracker.trackEvent(\"ID2\");\n+}\n+\n+\/\/ (IE1\/IE2)\n+@FunctionalInterface interface IE1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IE1\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IE2 extends IE1 { \/\/ has <clinit>, but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IE2\");\n+}\n+\n+\/\/ (IF1\/IF2)\n+@FunctionalInterface interface IF1 { \/\/ has <clinit>, but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IF1\");\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IF2 extends IF1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IF2\");\n+    default int dummy() { return 0; }\n+}\n+\n+\/\/ (IG1\/IG2)\n+@FunctionalInterface interface IG1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IG1\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n@@ -240,0 +331,21 @@\n+@FunctionalInterface interface IG2 extends IG1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IG2\");\n+    default int dummy() { return _dummy; }\n+}\n+\n+\/\/ (IH1\/IH2\/IH3)\n+@FunctionalInterface interface IH1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IH1\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IH2 extends IH1 { \/\/ has <clinit> but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IH2\");\n+}\n+\n+@FunctionalInterface interface IH3 extends IH2 { \/\/ has <clinit> but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IH3\");\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedLambdas.java","additions":159,"deletions":47,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-               .shouldContain(\"Cannot aot-resolve Lambda proxy of interface type InterfaceWithClinit (has <clinit>)\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy of interface type InterfaceWithClinit\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}