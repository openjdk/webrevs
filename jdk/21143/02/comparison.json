{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -98,0 +99,4 @@\n+  if (ik->is_hidden()) {\n+    return HeapShared::is_archivable_hidden_klass(ik);\n+  }\n+\n@@ -102,0 +107,72 @@\n+  \/\/ About \"static field that may hold a different value\" errors:\n+  \/\/\n+  \/\/ Automatic selection for aot-inited classes\n+  \/\/ ==========================================\n+  \/\/\n+  \/\/ When CDSConfig::is_initing_classes_at_dump_time() is enabled,\n+  \/\/ HeapShared::find_all_aot_initialized_classes() finds the classes of all\n+  \/\/ heap objects that are reachable from HeapShared::_run_time_special_subgraph,\n+  \/\/ and mark these classes as aot-inited. This preserves the initialized\n+  \/\/ mirrors of these classes, and their <clinit> methods are NOT executed\n+  \/\/ at runtime.\n+  \/\/\n+  \/\/ For example, with -XX:+AOTInvokeDynamicLinking, _run_time_special_subgraph\n+  \/\/ will contain some DirectMethodHandle objects. As a result, the DirectMethodHandle\n+  \/\/ class is automatically marked as aot-inited.\n+  \/\/\n+  \/\/ Manual selection\n+  \/\/ ================\n+  \/\/\n+  \/\/ However, there are cases that cannot be automatically discovered. For\n+  \/\/ example, DirectMethodHandle::IMPL_NAMES points to MethodHandles::IMPL_NAMES,\n+  \/\/ but the MethodHandles class is not automatically marked because there are\n+  \/\/ no archived instances of the MethodHandles type.\n+  \/\/\n+  \/\/ If we aot-initialize DirectMethodHandle, but allow MethodHandles to be\n+  \/\/ initialized at runtime, MethodHandles::IMPL_NAMES will get a different\n+  \/\/ value than DirectMethodHandle::IMPL_NAMES. This *may or may not* be a problem,\n+  \/\/ but to ensure compatibility, we should try to preserve the identity equality\n+  \/\/ of these two fields.\n+  \/\/\n+  \/\/ To do that, we add MethodHandles to the indy_specs[] table below.\n+  \/\/\n+  \/\/ Automatic validation\n+  \/\/ ====================\n+  \/\/\n+  \/\/ CDSHeapVerifier is used to detect potential problems with identity equality.\n+  \/\/ To see how it detects the problem with MethodHandles::IMPL_NAMES:\n+  \/\/\n+  \/\/ - Comment out all the lines in indy_specs[] except the {nullptr} line.\n+  \/\/ - Rebuild the JDK\n+  \/\/\n+  \/\/ Then run the following:\n+  \/\/    java -XX:AOTMode=record -XX:AOTConfiguration=jc.aotconfig com.sun.tools.javac.Main\n+  \/\/    java -XX:AOTMode=create -Xlog:cds -XX:AOTCache=jc.aot -XX:AOTConfiguration=jc.aotconfig\n+  \/\/\n+  \/\/ You will see an error like this:\n+  \/\/\n+  \/\/ Archive heap points to a static field that may hold a different value at runtime:\n+  \/\/ Field: java\/lang\/invoke\/MethodHandles::IMPL_NAMES\n+  \/\/ Value: java.lang.invoke.MemberName$Factory\n+  \/\/ {0x000000060e906ae8} - klass: 'java\/lang\/invoke\/MemberName$Factory' - flags:\n+  \/\/\n+  \/\/  - ---- fields (total size 2 words):\n+  \/\/ --- trace begin ---\n+  \/\/ [ 0] {0x000000060e8deeb0} java.lang.Class (java.lang.invoke.DirectMethodHandle::IMPL_NAMES)\n+  \/\/ [ 1] {0x000000060e906ae8} java.lang.invoke.MemberName$Factory\n+  \/\/ --- trace end ---\n+  \/\/\n+  \/\/ Trouble-shooting\n+  \/\/ ================\n+  \/\/\n+  \/\/ If you see a \"static field that may hold a different value\" error, it's probably\n+  \/\/ because you've made some changes in the JDK core libraries (most likely\n+  \/\/ java.lang.invoke).\n+  \/\/\n+  \/\/  - Did you add a new static field to a class that could be referenced by\n+  \/\/    cached object instances of MethodType, MethodHandle, etc? You may need\n+  \/\/    to add that class to indy_specs[].\n+  \/\/  - Did you modify the <clinit> of the classes in java.lang.invoke such that\n+  \/\/    a static field now points to an object that should not be cached (e.g.,\n+  \/\/    a native resource such as a file descriptior, or a Thread)?\n+\n@@ -115,14 +192,7 @@\n-  {\n-    \/\/ These classes are special cases needed to support the aot-caching of\n-    \/\/ java.lang.invoke.MethodType instances:\n-    \/\/ - MethodType points to sun.invoke.util.Wrapper enums\n-    \/\/ - The Wrapper enums point to static final fields in these classes.\n-    \/\/   E.g., ConstantDescs.CD_Boolean.\n-    \/\/ - If we re-run the <clinit> of these classes again during the production\n-    \/\/   run, ConstantDescs.CD_Boolean will get a new value that has a different\n-    \/\/   object identity than the value referenced by the the Wrapper enums.\n-    \/\/ - However, Wrapper requires object identity (it allows the use of == to\n-    \/\/   test the equality of ClassDesc, etc).\n-    \/\/ Therefore, we must preserve the static fields of these classes from\n-    \/\/ the assembly phase.\n-    static AllowedSpec specs[] = {\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ This table was created with the help of CDSHeapVerifier.\n+    \/\/ Also, some $Holder classes are needed. E.g., Invokers.<clinit> explicitly\n+    \/\/ initializes Invokers$Holder. Since Invokers.<clinit> won't be executed\n+    \/\/ at runtime, we need to make sure Invokers$Holder is also aot-inited.\n+    static AllowedSpec indy_specs[] = {\n+      {\"java\/lang\/constant\/ConstantDescs\"},\n@@ -130,0 +200,20 @@\n+      {\"java\/lang\/invoke\/BoundMethodHandle\"},\n+      {\"java\/lang\/invoke\/BoundMethodHandle$Specializer\"},\n+      {\"java\/lang\/invoke\/BoundMethodHandle$Species_\", IS_PREFIX},\n+      {\"java\/lang\/invoke\/ClassSpecializer\"},\n+      {\"java\/lang\/invoke\/ClassSpecializer$\", IS_PREFIX},\n+      {\"java\/lang\/invoke\/DelegatingMethodHandle\"},\n+      {\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\"},     \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/DirectMethodHandle\"},\n+      {\"java\/lang\/invoke\/DirectMethodHandle$Constructor\"},\n+      {\"java\/lang\/invoke\/DirectMethodHandle$Holder\"},         \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/Invokers\"},\n+      {\"java\/lang\/invoke\/Invokers$Holder\"},                   \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/LambdaForm\"},\n+      {\"java\/lang\/invoke\/LambdaForm$Holder\"},                 \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/LambdaForm$NamedFunction\"},\n+      {\"java\/lang\/invoke\/MethodHandle\"},\n+      {\"java\/lang\/invoke\/MethodHandles\"},\n+      {\"java\/lang\/invoke\/SimpleMethodHandle\"},\n+      {\"java\/util\/Collections\"},\n+      {\"java\/util\/stream\/Collectors\"},\n@@ -132,1 +222,5 @@\n-      {\"java\/lang\/constant\/ConstantDescs\"},\n+\n+    \/\/ Can't include this, as it will pull in MethodHandleStatics which has many environment\n+    \/\/ dependencies (on system properties, etc).\n+    \/\/{\"java\/lang\/invoke\/InvokerBytecodeGenerator\"},\n+\n@@ -135,1 +229,1 @@\n-    if (is_allowed(specs, ik)) {\n+    if (is_allowed(indy_specs, ik)) {\n@@ -160,2 +254,4 @@\n-      \/\/ Note: interfaces with no <clinit> are not marked as is_initialized().\n-      assert(intf->class_initializer() == nullptr, \"uninitialized super interface %s of aot-inited class %s must not have <clinit>\",\n+      \/\/ Note: an interface needs to be marked as is_initialized() only if\n+      \/\/ - it has a <clinit>\n+      \/\/ - it has at least one default method.\n+      assert(!intf->has_nonstatic_concrete_methods() || intf->class_initializer() == nullptr, \"uninitialized super interface %s of aot-inited class %s must not have <clinit>\",\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":114,"deletions":18,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -97,1 +97,4 @@\n-    add_candidate(ik);\n+    if (CDSConfig::is_dumping_aot_linked_classes()) {\n+      bool v = try_add_candidate(ik);\n+      assert(v, \"must succeed for VM class\");\n+    }\n@@ -116,0 +119,5 @@\n+\n+  if (log_is_enabled(Info, cds, aot, link)) {\n+    ResourceMark rm;\n+    log_info(cds, aot, link)(\"%s %s %p\", class_category_name(ik), ik->external_name(), ik);\n+  }\n@@ -131,1 +139,15 @@\n-    return false;\n+    assert(ik->shared_class_loader_type() != ClassLoader::OTHER, \"must have been set\");\n+    if (!CDSConfig::is_dumping_invokedynamic()) {\n+      return false;\n+    }\n+    if (!SystemDictionaryShared::should_hidden_class_be_archived(ik)) {\n+      return false;\n+    }\n+    if (HeapShared::is_lambda_proxy_klass(ik)) {\n+      InstanceKlass* nest_host = ik->nest_host_not_null();\n+      if (!try_add_candidate(nest_host)) {\n+        ResourceMark rm;\n+        log_warning(cds, aot, link)(\"%s cannot be aot-linked because it nest host is not aot-linked\", ik->external_name());\n+        return false;\n+      }\n+    }\n@@ -150,5 +172,0 @@\n-  if (log_is_enabled(Info, cds, aot, link)) {\n-    ResourceMark rm;\n-    log_info(cds, aot, link)(\"%s %s\", class_category_name(ik), ik->external_name());\n-  }\n-\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+  } else if (cp->tag_at(cp_index).is_invoke_dynamic()) {\n+    return is_indy_resolution_deterministic(cp, cp_index);\n@@ -111,1 +113,3 @@\n-      if (AOTClassLinker::is_candidate(ik)) {\n+      \/\/ Need to call try_add_candidate instead of is_candidate, as this may be called\n+      \/\/ before AOTClassLinker::add_candidates().\n+      if (AOTClassLinker::try_add_candidate(ik)) {\n@@ -252,0 +256,1 @@\n+      case Bytecodes::_invokehandle:\n@@ -304,0 +309,4 @@\n+  case Bytecodes::_invokehandle:\n+    InterpreterRuntime::cds_resolve_invokehandle(raw_index, cp, CHECK);\n+    break;\n+\n@@ -321,0 +330,194 @@\n+void AOTConstantPoolResolver::preresolve_indy_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n+  JavaThread* THREAD = current;\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  if (!CDSConfig::is_dumping_invokedynamic() || cp->cache() == nullptr) {\n+    return;\n+  }\n+\n+  assert(preresolve_list != nullptr, \"preresolve_indy_cp_entries() should not be called for \"\n+         \"regenerated LambdaForm Invoker classes, which should not have indys anyway.\");\n+\n+  Array<ResolvedIndyEntry>* indy_entries = cp->cache()->resolved_indy_entries();\n+  for (int i = 0; i < indy_entries->length(); i++) {\n+    ResolvedIndyEntry* rie = indy_entries->adr_at(i);\n+    int cp_index = rie->constant_pool_index();\n+    if (preresolve_list->at(cp_index) == true && !rie->is_resolved() && is_indy_resolution_deterministic(cp(), cp_index)) {\n+      InterpreterRuntime::cds_resolve_invokedynamic(i, cp, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Check the method signatures used by parameters to LambdaMetafactory::metafactory. Make sure we don't\n+\/\/ use types that have been excluded, or else we might end up creating MethodTypes that cannot be stored\n+\/\/ in the AOT cache.\n+bool AOTConstantPoolResolver::check_lambda_metafactory_signature(ConstantPool* cp, Symbol* sig, bool check_return_type) {\n+  ResourceMark rm;\n+  for (SignatureStream ss(sig); !ss.is_done(); ss.next()) {\n+    if (ss.is_reference()) {\n+      Symbol* type = ss.as_symbol();\n+      Klass* k = find_loaded_class(Thread::current(), cp->pool_holder()->class_loader(), type);\n+      if (k == nullptr) {\n+        return false;\n+      }\n+\n+      if (SystemDictionaryShared::check_for_exclusion(k)) {\n+        if (log_is_enabled(Warning, cds, resolve)) {\n+          ResourceMark rm;\n+          log_warning(cds, resolve)(\"Cannot aot-resolve Lambda proxy because %s is excluded\", k->external_name());\n+        }\n+        return false;\n+      }\n+\n+      if (check_return_type && ss.at_return_type()) {\n+        \/\/ This is the interface type implemented by the lambda proxy\n+        if (!k->is_interface()) {\n+          \/\/ pool_holder doesn't look like a valid class generated by javac\n+          return false;\n+        }\n+\n+        InstanceKlass* ik = InstanceKlass::cast(k);\n+        if (ik->has_nonstatic_concrete_methods() && ik->class_initializer() != nullptr) {\n+          \/\/ We initialize the class of the archived lambda proxy at VM start-up, which will also initialize\n+          \/\/ the interface that it implements. If that interface has a clinit method that needs to be executed,\n+          \/\/ we can potentially change program execution order.\n+          if (log_is_enabled(Debug, cds, resolve)) {\n+            ResourceMark rm;\n+            log_debug(cds, resolve)(\"Cannot aot-resolve Lambda proxy of interface type %s (has <clinit>)\", k->external_name());\n+          }\n+          return false;\n+        }\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+bool AOTConstantPoolResolver::check_lambda_metafactory_methodtype_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i) {\n+  int mt_index = cp->operand_argument_index_at(bsms_attribute_index, arg_i);\n+  if (!cp->tag_at(mt_index).is_method_type()) {\n+    \/\/ malformed class?\n+    return false;\n+  }\n+\n+  Symbol* sig = cp->method_type_signature_at(mt_index);\n+  if (log_is_enabled(Debug, cds, resolve)) {\n+    ResourceMark rm;\n+    log_debug(cds, resolve)(\"Checking MethodType for LambdaMetafactory BSM arg %d: %s\", arg_i, sig->as_C_string());\n+  }\n+\n+  return check_lambda_metafactory_signature(cp, sig, false);\n+}\n+\n+bool AOTConstantPoolResolver::check_lambda_metafactory_methodhandle_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i) {\n+  int mh_index = cp->operand_argument_index_at(bsms_attribute_index, arg_i);\n+  if (!cp->tag_at(mh_index).is_method_handle()) {\n+    \/\/ malformed class?\n+    return false;\n+  }\n+\n+  Symbol* sig = cp->method_handle_signature_ref_at(mh_index);\n+  if (log_is_enabled(Debug, cds, resolve)) {\n+    ResourceMark rm;\n+    log_debug(cds, resolve)(\"Checking MethodType of MethodHandle for LambdaMetafactory BSM arg %d: %s\", arg_i, sig->as_C_string());\n+  }\n+  return check_lambda_metafactory_signature(cp, sig, false);\n+}\n+\n+bool AOTConstantPoolResolver::is_indy_resolution_deterministic(ConstantPool* cp, int cp_index) {\n+  assert(cp->tag_at(cp_index).is_invoke_dynamic(), \"sanity\");\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return false;\n+  }\n+\n+  InstanceKlass* pool_holder = cp->pool_holder();\n+  if (!SystemDictionaryShared::is_builtin(pool_holder)) {\n+    return false;\n+  }\n+\n+  int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n+  int bsm_ref = cp->method_handle_index_at(bsm);\n+  Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n+  Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n+  Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n+\n+  \/\/ We currently support only StringConcatFactory::makeConcatWithConstants() and LambdaMetafactory::metafactory()\n+\n+  if (bsm_klass->equals(\"java\/lang\/invoke\/StringConcatFactory\") &&\n+      bsm_name->equals(\"makeConcatWithConstants\")) {\n+    return true;\n+  }\n+\n+  if (bsm_klass->equals(\"java\/lang\/invoke\/LambdaMetafactory\") &&\n+      bsm_name->equals(\"metafactory\") &&\n+      bsm_signature->equals(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;\"\n+                             \"Ljava\/lang\/String;\"\n+                             \"Ljava\/lang\/invoke\/MethodType;\"\n+                             \"Ljava\/lang\/invoke\/MethodType;\"\n+                             \"Ljava\/lang\/invoke\/MethodHandle;\"\n+                             \"Ljava\/lang\/invoke\/MethodType;\"\n+                            \")Ljava\/lang\/invoke\/CallSite;\")) {\n+    \/*\n+     * An indy callsite is associated with the following MethodType and MethodHandles:\n+     *\n+     * https:\/\/github.com\/openjdk\/jdk\/blob\/580eb62dc097efeb51c76b095c1404106859b673\/src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java#L293-L309\n+     *\n+     * MethodType factoryType         The expected signature of the {@code CallSite}.  The\n+     *                                parameter types represent the types of capture variables;\n+     *                                the return type is the interface to implement.   When\n+     *                                used with {@code invokedynamic}, this is provided by\n+     *                                the {@code NameAndType} of the {@code InvokeDynamic}\n+     *\n+     * MethodType interfaceMethodType Signature and return type of method to be\n+     *                                implemented by the function object.\n+     *\n+     * MethodHandle implementation    A direct method handle describing the implementation\n+     *                                method which should be called (with suitable adaptation\n+     *                                of argument types and return types, and with captured\n+     *                                arguments prepended to the invocation arguments) at\n+     *                                invocation time.\n+     *\n+     * MethodType dynamicMethodType   The signature and return type that should\n+     *                                be enforced dynamically at invocation time.\n+     *                                In simple use cases this is the same as\n+     *                                {@code interfaceMethodType}.\n+     *\/\n+    Symbol* factory_type__sig = cp->uncached_signature_ref_at(cp_index);\n+    if (log_is_enabled(Debug, cds, resolve)) {\n+      ResourceMark rm;\n+      log_debug(cds, resolve)(\"Checking indy callsite signature [%d]: %s\", cp_index, factory_type__sig->as_C_string());\n+    }\n+\n+    if (!check_lambda_metafactory_signature(cp, factory_type__sig, true)) {\n+      return false;\n+    }\n+\n+    int bsms_attribute_index = cp->bootstrap_methods_attribute_index(cp_index);\n+    int arg_count = cp->operand_argument_count_at(bsms_attribute_index);\n+    if (arg_count != 3) {\n+      \/\/ Malformed class?\n+      return false;\n+    }\n+\n+    \/\/ interfaceMethodType\n+    if (!check_lambda_metafactory_methodtype_arg(cp, bsms_attribute_index, 0)) {\n+      return false;\n+    }\n+\n+    \/\/ implementation\n+    if (!check_lambda_metafactory_methodhandle_arg(cp, bsms_attribute_index, 1)) {\n+      return false;\n+    }\n+\n+    \/\/ dynamicMethodType\n+    if (!check_lambda_metafactory_methodtype_arg(cp, bsms_attribute_index, 2)) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":204,"deletions":1,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  static bool is_indy_resolution_deterministic(ConstantPool* cp, int cp_index);\n@@ -75,0 +76,5 @@\n+\n+  static bool check_lambda_metafactory_signature(ConstantPool* cp, Symbol* sig, bool check_return_type);\n+  static bool check_lambda_metafactory_methodtype_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i);\n+  static bool check_lambda_metafactory_methodhandle_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i);\n+\n@@ -81,0 +87,1 @@\n+  static void preresolve_indy_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list);\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -176,2 +176,1 @@\n-        \/\/ TODO: AOTClassLinking is not implemented for hidden class until JDK-8293336\n-        ShouldNotReachHere();\n+        load_hidden_class(loader_data, ik, CHECK);\n@@ -236,0 +235,25 @@\n+\/\/ TODO -- is this really correct? Do we need a special ClassLoaderData for each hidden class?\n+void AOTLinkedClassBulkLoader::load_hidden_class(ClassLoaderData* loader_data, InstanceKlass* ik, TRAPS) {\n+  DEBUG_ONLY({\n+      assert(ik->java_super()->is_loaded(), \"must be\");\n+      for (int i = 0; i < ik->local_interfaces()->length(); i++) {\n+        assert(ik->local_interfaces()->at(i)->is_loaded(), \"must be\");\n+      }\n+    });\n+\n+  Handle pd;\n+  PackageEntry* pkg_entry = nullptr;\n+\n+  if (HeapShared::is_lambda_proxy_klass(ik)) {\n+    InstanceKlass* nest_host = ik->nest_host_not_null();\n+    assert(nest_host->is_loaded(), \"must be\");\n+    pd = Handle(THREAD, nest_host->protection_domain());\n+    pkg_entry = nest_host->package();\n+  }\n+\n+  ik->restore_unshareable_info(loader_data, pd, pkg_entry, CHECK);\n+  SystemDictionary::load_shared_class_misc(ik, loader_data);\n+  ik->add_to_hierarchy(THREAD);\n+  assert(ik->is_loaded(), \"Must be in at least loaded state\");\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  static void load_hidden_class(ClassLoaderData* loader_data, InstanceKlass* ik, TRAPS);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderExt.hpp\"\n@@ -231,0 +233,4 @@\n+      if (klass->is_hidden()) {\n+        assert(klass->is_instance_klass(), \"must be\");\n+        assert(SystemDictionaryShared::should_hidden_class_be_archived(InstanceKlass::cast(klass)), \"must be\");\n+      }\n@@ -785,0 +791,1 @@\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_old_klasses);\n@@ -812,0 +819,1 @@\n+    const char* old = \"\";\n@@ -894,0 +902,5 @@\n+      if (!ik->can_be_verified_at_dumptime()) {\n+        ADD_COUNT(num_old_klasses);\n+        old = \" old\";\n+      }\n+\n@@ -910,1 +923,1 @@\n-      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s%s%s%s\", i,\n+      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s%s%s%s%s\", i,\n@@ -912,1 +925,1 @@\n-                            kind, hidden, unlinked, generated, aotlinked_msg, inited_msg);\n+                            kind, hidden, old, unlinked, generated, aotlinked_msg, inited_msg);\n@@ -928,0 +941,1 @@\n+  log_info(cds)(\"      (old)            \" STATS_FORMAT, STATS_PARAMS(old_klasses));\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -441,4 +441,0 @@\n-    \/\/ Currently we have only Klass pointers in heap objects.\n-    \/\/ This needs to be relaxed when we support other types of native\n-    \/\/ pointers such as Method.\n-    assert(((Klass*)(*p))->is_klass(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -374,0 +374,7 @@\n+bool ArchiveUtils::has_aot_initialized_mirror(InstanceKlass* src_ik) {\n+  if (SystemDictionaryShared::is_excluded_class(src_ik)) {\n+    return false;\n+  }\n+  return ArchiveBuilder::current()->get_buffered_addr(src_ik)->has_aot_initialized_mirror();\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -254,1 +254,1 @@\n-\n+  static bool has_aot_initialized_mirror(InstanceKlass* src_ik);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+bool CDSConfig::_has_archived_invokedynamic = false;\n@@ -332,1 +333,0 @@\n-\n@@ -414,0 +414,8 @@\n+  if (AOTClassLinking) {\n+    \/\/ If AOTClassLinking is specified, enable all AOT optimizations by default.\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTInvokeDynamicLinking, true);\n+  } else {\n+    \/\/ AOTInvokeDynamicLinking depends on AOTClassLinking.\n+    FLAG_SET_ERGO(AOTInvokeDynamicLinking, false);\n+  }\n+\n@@ -476,0 +484,5 @@\n+bool CDSConfig::allow_only_single_java_thread() {\n+  \/\/ See comments in JVM_StartThread()\n+  return is_dumping_static_archive();\n+}\n+\n@@ -562,0 +575,11 @@\n+\n+bool CDSConfig::is_dumping_invokedynamic() {\n+  \/\/ Requires is_dumping_aot_linked_classes(). Otherwise the classes of some archived heap\n+  \/\/ objects used by the archive indy callsites may be replaced at runtime.\n+  return AOTInvokeDynamicLinking && is_dumping_aot_linked_classes() && is_dumping_heap();\n+}\n+\n+bool CDSConfig::is_loading_invokedynamic() {\n+  return UseSharedSpaces && is_using_full_module_graph() && _has_archived_invokedynamic;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  static bool _has_archived_invokedynamic;\n@@ -90,0 +91,3 @@\n+  \/\/ Misc CDS features\n+  static bool allow_only_single_java_thread()                NOT_CDS_RETURN_(false);\n+\n@@ -115,0 +119,4 @@\n+  static bool is_dumping_invokedynamic()                     NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_loading_invokedynamic()                     NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void set_has_archived_invokedynamic()               { CDS_JAVA_HEAP_ONLY(_has_archived_invokedynamic = true); }\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -42,1 +45,1 @@\n-\/\/ static field that may be reinitialized at runtime. In the following example,\n+\/\/ static field that may be get a different value at runtime. In the following example,\n@@ -44,1 +47,2 @@\n-\/\/ correctly returns true when CDS disabled, but incorrectly returns false when CDS is enabled.\n+\/\/ correctly returns true when CDS disabled, but incorrectly returns false when CDS is enabled,\n+\/\/ because the archived archivedFoo.bar value is different than Bar.bar.\n@@ -47,1 +51,1 @@\n-\/\/     final Foo archivedFoo; \/\/ this field is archived by CDS\n+\/\/     static final Foo archivedFoo; \/\/ this field is archived by CDS\n@@ -127,0 +131,5 @@\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    ADD_EXCL(\"java\/lang\/invoke\/InvokerBytecodeGenerator\", \"MEMBERNAME_FACTORY\",    \/\/ D\n+                                                          \"INVOKER_SUPER_DESC\");   \/\/ E same as java.lang.constant.ConstantDescs::CD_Object\n+  }\n+\n@@ -134,3 +143,4 @@\n-    log_warning(cds, heap)(\"Scanned %d objects. Found %d case(s) where \"\n-                           \"an object points to a static field that may be \"\n-                           \"reinitialized at runtime.\", _archived_objs, _problems);\n+    log_error(cds, heap)(\"Scanned %d objects. Found %d case(s) where \"\n+                         \"an object points to a static field that \"\n+                         \"may hold a different value at runtime.\", _archived_objs, _problems);\n+    MetaspaceShared::unrecoverable_writing_error();\n@@ -157,1 +167,1 @@\n-      Klass* klass_of_field = static_obj_field->klass();\n+      Klass* field_type = static_obj_field->klass();\n@@ -177,9 +187,15 @@\n-      if (klass_of_field->has_archived_enum_objs()) {\n-        \/\/ This field is an Enum. If any instance of this Enum has been archived, we will archive\n-        \/\/ all static fields of this Enum as well.\n-        \/\/ See HeapShared::initialize_enum_klass().\n-        return;\n-      }\n-      if (klass_of_field->is_instance_klass()) {\n-        if (InstanceKlass::cast(klass_of_field)->is_initialized() &&\n-            AOTClassInitializer::can_archive_initialized_mirror(InstanceKlass::cast(klass_of_field))) {\n+\n+      if (field_type->is_instance_klass()) {\n+        InstanceKlass* field_ik = InstanceKlass::cast(field_type);\n+        if (field_ik->java_super() == vmClasses::Enum_klass()) {\n+          if (field_ik->has_archived_enum_objs() || ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+            \/\/ This field is an Enum. If any instance of this Enum has been archived, we will archive\n+            \/\/ all static fields of this Enum as well.\n+            return;\n+          }\n+        }\n+\n+        if (field_ik->is_hidden() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          \/\/ We have a static field in a core-library class that points to a method reference, which\n+          \/\/ are safe to archive.\n+          guarantee(_ik->module()->name() == vmSymbols::java_base(), \"sanity\");\n@@ -188,1 +204,0 @@\n-      }\n@@ -190,2 +205,11 @@\n-      if (AOTClassInitializer::can_archive_initialized_mirror(_ik)) {\n-        return;\n+        if (field_ik == vmClasses::MethodType_klass()) {\n+          \/\/ The identity of MethodTypes are preserved between assembly phase and production runs\n+          \/\/ (by MethodType::AOTHolder::archivedMethodTypes). No need to check.\n+          return;\n+        }\n+\n+        if (field_ik == vmClasses::internal_Unsafe_klass() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          \/\/ There's only a single instance of jdk\/internal\/misc\/Unsafe, so all references will\n+          \/\/ be pointing to this singleton, which has been archived.\n+          return;\n+        }\n@@ -202,1 +226,2 @@\n-\/\/ loaded.\n+\/\/ loaded. Later, we will check if any archived objects reference one of\n+\/\/ these fields.\n@@ -214,0 +239,6 @@\n+    if (ArchiveUtils::has_aot_initialized_mirror(ik)) {\n+      \/\/ ik's <clinit> won't be executed at runtime, the static fields in\n+      \/\/ ik will carry their values to runtime.\n+      return;\n+    }\n+\n@@ -235,0 +266,3 @@\n+    if (info->_holder->is_hidden()) {\n+      return true;\n+    }\n@@ -236,0 +270,2 @@\n+    char* class_name = info->_holder->name()->as_C_string();\n+    char* field_name = info->_name->as_C_string();\n@@ -237,2 +273,2 @@\n-    ls.print_cr(\"Archive heap points to a static field that may be reinitialized at runtime:\");\n-    ls.print_cr(\"Field: %s::%s\", info->_holder->name()->as_C_string(), info->_name->as_C_string());\n+    ls.print_cr(\"Archive heap points to a static field that may hold a different value at runtime:\");\n+    ls.print_cr(\"Field: %s::%s\", class_name, field_name);\n@@ -280,0 +316,23 @@\n+const char* static_field_name(oop mirror, oop field) {\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  if (k->is_instance_klass()) {\n+    for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        switch (fd.field_type()) {\n+        case T_OBJECT:\n+        case T_ARRAY:\n+          if (mirror->obj_field(fd.offset()) == field) {\n+            return fs.name()->as_C_string();\n+          }\n+          break;\n+        default:\n+          break;\n+        }\n+      }\n+    }\n+  }\n+\n+  return \"<unknown>\";\n+}\n+\n@@ -295,1 +354,1 @@\n-    st->print(\" (%s)\", java_lang_Class::as_Klass(orig_obj)->external_name());\n+    st->print(\" (%s::%s)\", java_lang_Class::as_Klass(orig_obj)->external_name(), static_field_name(orig_obj, orig_field));\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":82,"deletions":23,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+  product(bool, AOTInvokeDynamicLinking, false, DIAGNOSTIC,                 \\\n+          \"AOT-link JVM_CONSTANT_InvokeDynamic entries in cached \"          \\\n+          \"ConstantPools\")                                                  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -600,0 +600,12 @@\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ The CP entry for the invokedynamic instruction will be resolved.\n+    \/\/ No need to do the following.\n+    return;\n+  }\n+\n+  \/\/ This is an older CDS optimization:\n+  \/\/ We store a pre-generated version of the lambda proxy class in the AOT cache,\n+  \/\/ which will be loaded via JVM_LookupLambdaProxyClassFromArchive().\n+  \/\/ This eliminate dynamic class generation of the proxy class, but we still need to\n+  \/\/ resolve the CP entry for the invokedynamic instruction, which may result in\n+  \/\/ generation of LambdaForm classes.\n@@ -842,0 +854,2 @@\n+    case JVM_CONSTANT_InvokeDynamic:\n+      preresolve_indy = true;\n@@ -856,0 +870,3 @@\n+  if (preresolve_indy) {\n+    AOTConstantPoolResolver::preresolve_indy_cp_entries(THREAD, ik, &preresolve_list);\n+  }\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -131,3 +131,9 @@\n-  \/\/ filter out java\/lang\/invoke\/BoundMethodHandle$Species...\n-  if (cfs != nullptr && cfs->source() != nullptr && strcmp(cfs->source(), \"_ClassSpecializer_generateConcreteSpeciesCode\") == 0) {\n-    return;\n+  if (cfs != nullptr && cfs->source() != nullptr) {\n+    if (strcmp(cfs->source(), \"_ClassSpecializer_generateConcreteSpeciesCode\") == 0) {\n+      return;\n+    }\n+\n+    if (strncmp(cfs->source(), \"__\", 2) == 0) {\n+      \/\/ generated class: __dynamic_proxy__, __JVM_LookupDefineClass__, etc\n+      return;\n+    }\n@@ -257,0 +263,12 @@\n+    Array<ResolvedIndyEntry>* indy_entries = cp->cache()->resolved_indy_entries();\n+    if (indy_entries != nullptr) {\n+      for (int i = 0; i < indy_entries->length(); i++) {\n+        ResolvedIndyEntry* rie = indy_entries->adr_at(i);\n+        int cp_index = rie->constant_pool_index();\n+        if (rie->is_resolved()) {\n+          list.at_put(cp_index, true);\n+          print = true;\n+        }\n+      }\n+    }\n+\n@@ -275,1 +293,2 @@\n-            rme->is_resolved(Bytecodes::_invokeinterface)) {\n+            rme->is_resolved(Bytecodes::_invokeinterface) ||\n+            rme->is_resolved(Bytecodes::_invokehandle)) {\n@@ -292,1 +311,2 @@\n-               cp_tag.value() == JVM_CONSTANT_InterfaceMethodref, \"sanity\");\n+               cp_tag.value() == JVM_CONSTANT_InterfaceMethodref ||\n+               cp_tag.value() == JVM_CONSTANT_InvokeDynamic, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -118,0 +118,4 @@\n+  msg.info(\"Indy   CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n+           _num_indy_cp_entries, _num_indy_cp_entries_archived,\n+           percent_of(_num_indy_cp_entries_archived, _num_indy_cp_entries),\n+           _num_indy_cp_entries_reverted);\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+  int _num_indy_cp_entries;\n+  int _num_indy_cp_entries_archived;\n+  int _num_indy_cp_entries_reverted;\n@@ -87,0 +90,3 @@\n+    _num_indy_cp_entries            = 0;\n+    _num_indy_cp_entries_archived   = 0;\n+    _num_indy_cp_entries_reverted   = 0;\n@@ -125,0 +131,6 @@\n+  void record_indy_cp_entry(bool archived, bool reverted) {\n+    _num_indy_cp_entries ++;\n+    _num_indy_cp_entries_archived += archived ? 1 : 0;\n+    _num_indy_cp_entries_reverted += reverted ? 1 : 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,2 @@\n-\n+  bool                         _is_required;\n+  bool                         _has_scanned_constant_pool;\n@@ -140,0 +141,2 @@\n+    _is_required = false;\n+    _has_scanned_constant_pool = false;\n@@ -217,0 +220,5 @@\n+  bool is_required() const                          { return _is_required; }\n+  void set_is_required()                            { _is_required = true; }\n+  bool has_scanned_constant_pool() const            { return _has_scanned_constant_pool; }\n+  void set_has_scanned_constant_pool()              { _has_scanned_constant_pool = true; }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    SystemDictionaryShared::check_excluded_classes();\n+    SystemDictionaryShared::find_all_archivable_classes();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -219,0 +219,1 @@\n+  _has_archived_invokedynamic = CDSConfig::is_dumping_invokedynamic();\n@@ -306,0 +307,1 @@\n+  st->print_cr(\"- has_archived_invokedynamic      %d\", _has_archived_invokedynamic);\n@@ -2523,1 +2525,1 @@\n-  if (is_static() && !_has_full_module_graph) {\n+  if (is_static()) {\n@@ -2525,1 +2527,7 @@\n-    CDSConfig::stop_using_full_module_graph(\"archive was created without full module graph\");\n+    if (!_has_full_module_graph) {\n+      CDSConfig::stop_using_full_module_graph(\"archive was created without full module graph\");\n+    }\n+\n+    if (_has_archived_invokedynamic) {\n+      CDSConfig::set_has_archived_invokedynamic();\n+    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -230,0 +230,1 @@\n+  bool   _has_archived_invokedynamic;   \/\/ Does the archive have aot-linked invokedynamic CP entries?\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+\n@@ -421,0 +422,15 @@\n+bool HeapShared::is_lambda_form_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() &&\n+    (ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$MH+\") ||\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$DMH+\") ||\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$BMH+\"));\n+}\n+\n+bool HeapShared::is_lambda_proxy_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() && (ik->name()->index_of_at(0, \"$$Lambda+\", 9) > 0);\n+}\n+\n+bool HeapShared::is_archivable_hidden_klass(InstanceKlass* ik) {\n+  return CDSConfig::is_dumping_invokedynamic() && (is_lambda_form_klass(ik) || is_lambda_proxy_klass(ik));\n+}\n+\n@@ -422,3 +438,1 @@\n-  if (!orig_k->is_instance_klass()) {\n-    return;\n-  }\n+  assert(orig_k->is_instance_klass(), \"sanity\");\n@@ -426,1 +440,9 @@\n-  if (!ik->is_initialized() || !AOTClassInitializer::can_archive_initialized_mirror(ik)) {\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n+\n+  if (HeapShared::is_archivable_hidden_klass(ik)) {\n+    \/\/ We can't rerun the <clinit> method of hidden classes as we don't save\n+    \/\/ the classData, so we must archive its mirror in initialized state.\n+    assert(ik->is_initialized(), \"must be\");\n+  }\n+\n+  if (!ik->is_initialized()) {\n@@ -471,0 +493,2 @@\n+  java_lang_Class::set_class_data(m, java_lang_Class::class_data(orig_mirror));\n+\n@@ -480,3 +504,0 @@\n-\n-  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n-  buffered_ik->set_has_aot_initialized_mirror();\n@@ -494,0 +515,13 @@\n+static objArrayOop get_archived_resolved_references(InstanceKlass* src_ik) {\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n+  if (buffered_ik->is_shared_boot_class() ||\n+      buffered_ik->is_shared_platform_class() ||\n+      buffered_ik->is_shared_app_class()) {\n+    objArrayOop rr = src_ik->constants()->resolved_references_or_null();\n+    if (rr != nullptr && !ArchiveHeapWriter::is_too_large_to_archive(rr)) {\n+      return HeapShared::scratch_resolved_references(src_ik->constants());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -522,1 +556,0 @@\n-      copy_aot_initialized_mirror(orig_k, orig_mirror, m);\n@@ -543,2 +576,2 @@\n-        oop rr = ik->constants()->prepare_resolved_references_for_archiving();\n-        if (rr != nullptr && !ArchiveHeapWriter::is_too_large_to_archive(rr)) {\n+        objArrayOop rr = get_archived_resolved_references(InstanceKlass::cast(orig_k));\n+        if (rr != nullptr) {\n@@ -575,0 +608,2 @@\n+  } else if (java_lang_invoke_ResolvedMethodName::is_instance(orig_obj)) {\n+    ArchiveHeapWriter::mark_native_pointer(orig_obj, java_lang_invoke_ResolvedMethodName::vmtarget_offset());\n@@ -591,0 +626,98 @@\n+void HeapShared::start_finding_archivable_hidden_classes() {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return;\n+  }\n+  NoSafepointVerifier nsv;\n+\n+  init_seen_objects_table();\n+\n+  find_archivable_hidden_classes_helper(archive_subgraph_entry_fields);\n+  if (CDSConfig::is_dumping_full_module_graph()) {\n+    find_archivable_hidden_classes_helper(fmg_archive_subgraph_entry_fields);\n+  }\n+}\n+\n+void HeapShared::end_finding_archivable_hidden_classes() {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return;\n+  }\n+  NoSafepointVerifier nsv;\n+\n+  delete_seen_objects_table();\n+}\n+\n+void HeapShared::find_archivable_hidden_classes_helper(ArchivableStaticFieldInfo fields[]) {\n+  if (!CDSConfig::is_dumping_heap()) {\n+    return;\n+  }\n+  for (int i = 0; fields[i].valid(); ) {\n+    ArchivableStaticFieldInfo* info = &fields[i];\n+    const char* klass_name = info->klass_name;\n+    for (; fields[i].valid(); i++) {\n+      ArchivableStaticFieldInfo* f = &fields[i];\n+      if (f->klass_name != klass_name) {\n+        break;\n+      }\n+\n+      InstanceKlass* k = f->klass;\n+      oop m = k->java_mirror();\n+      oop o = m->obj_field(f->offset);\n+      if (o != nullptr) {\n+        find_archivable_hidden_classes_in_object(o);\n+      }\n+    }\n+  }\n+}\n+\n+class HeapShared::FindHiddenClassesOopClosure: public BasicOopIterateClosure {\n+  GrowableArray<oop> _stack;\n+  template <class T> void do_oop_work(T *p) {\n+    \/\/ Recurse on a GrowableArray to avoid overflowing the C stack.\n+    oop o = RawAccess<>::oop_load(p);\n+    if (o != nullptr) {\n+      _stack.append(o);\n+    }\n+  }\n+\n+ public:\n+\n+  void do_oop(narrowOop *p) { FindHiddenClassesOopClosure::do_oop_work(p); }\n+  void do_oop(      oop *p) { FindHiddenClassesOopClosure::do_oop_work(p); }\n+\n+  FindHiddenClassesOopClosure(oop o) {\n+    _stack.append(o);\n+  }\n+  oop pop() {\n+    if (_stack.length() == 0) {\n+      return nullptr;\n+    } else {\n+      return _stack.pop();\n+    }\n+  }\n+};\n+\n+void HeapShared::find_archivable_hidden_classes_in_object(oop root) {\n+  ResourceMark rm;\n+  FindHiddenClassesOopClosure c(root);\n+  oop o;\n+  while ((o = c.pop()) != nullptr) {\n+    if (!has_been_seen_during_subgraph_recording(o)) {\n+      set_has_been_seen_during_subgraph_recording(o);\n+\n+      if (java_lang_Class::is_instance(o)) {\n+        Klass* k = java_lang_Class::as_Klass(o);\n+        if (k != nullptr && k->is_instance_klass()) {\n+          SystemDictionaryShared::mark_required_class(InstanceKlass::cast(k));\n+        }\n+      } else if (java_lang_invoke_ResolvedMethodName::is_instance(o)) {\n+        Method* m = java_lang_invoke_ResolvedMethodName::vmtarget(o);\n+        if (m != nullptr && m->method_holder() != nullptr) {\n+          SystemDictionaryShared::mark_required_class(m->method_holder());\n+        }\n+      }\n+\n+      o->oop_iterate(&c);\n+    }\n+  }\n+}\n+\n@@ -637,0 +770,1 @@\n+\n@@ -638,3 +772,5 @@\n-  archive_java_mirrors();\n-  archive_strings();\n-  Universe::archive_exception_instances();\n+  {\n+    archive_java_mirrors();\n+    archive_strings();\n+    Universe::archive_exception_instances();\n+  }\n@@ -644,0 +780,11 @@\n+void HeapShared::prepare_resolved_references() {\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* src_k = klasses->at(i);\n+    if (src_k->is_instance_klass()) {\n+      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_k));\n+      buffered_ik->constants()->prepare_resolved_references_for_archiving();\n+    }\n+  }\n+}\n+\n@@ -647,0 +794,2 @@\n+  prepare_resolved_references();\n+  find_all_aot_initialized_classes();\n@@ -659,0 +808,143 @@\n+\/\/ Closure used by HeapShared::scan_for_aot_initialized_classes() to look for all objects\n+\/\/ that are reachable from a given root.\n+class HeapShared::AOTInitializedClassScanner : public BasicOopIterateClosure {\n+  bool _made_progress;\n+\n+  template <class T> void check(T *p) {\n+    oop obj = HeapAccess<>::oop_load(p);\n+    if (!java_lang_Class::is_instance(obj)) {\n+      \/\/ Don't scan the mirrors, as we may see an orig_mirror while scanning\n+      \/\/ the object graph, .... TODO more info\n+      _made_progress |= HeapShared::scan_for_aot_initialized_classes(obj);\n+    }\n+  }\n+\n+public:\n+  AOTInitializedClassScanner() : _made_progress(false) {}\n+  void do_oop(narrowOop *p) { check(p); }\n+  void do_oop(      oop *p) { check(p); }\n+  bool made_progress() { return _made_progress; }\n+};\n+\n+static bool mark_for_aot_initialization(InstanceKlass* buffered_ik) {\n+  if (buffered_ik->name()->equals(\"java\/lang\/String\")) {\n+    return false;\n+  }\n+\n+  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_ik), \"sanity\");\n+\n+  bool made_progress = false;\n+  if (buffered_ik->is_initialized() && !buffered_ik->has_aot_initialized_mirror()) {\n+    if (log_is_enabled(Info, cds, init)) {\n+      ResourceMark rm;\n+      log_info(cds, init)(\"Mark class for aot-init: %s\", buffered_ik->external_name());\n+    }\n+\n+    buffered_ik->set_has_aot_initialized_mirror();\n+    made_progress = true;\n+\n+    InstanceKlass* super = buffered_ik->java_super();\n+    if (super != nullptr) {\n+      mark_for_aot_initialization(super);\n+    }\n+\n+    Array<InstanceKlass*>* interfaces = buffered_ik->local_interfaces();\n+    for (int i = 0; i < interfaces->length(); i++) {\n+      mark_for_aot_initialization(interfaces->at(i));\n+    }\n+  }\n+\n+  return made_progress;\n+}\n+\n+void HeapShared::find_all_aot_initialized_classes() {\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    return;\n+  }\n+\n+  init_seen_objects_table();\n+  find_all_aot_initialized_classes_helper();\n+  delete_seen_objects_table();\n+}\n+\n+\/\/ Recursively find all class that should be aot-initialized:\n+\/\/ - the class has at least one instance that can be reachable from the special subgraph; or\n+\/\/ - the class is hard-coded in AOTClassInitializer::can_archive_initialized_mirror()\n+void HeapShared::find_all_aot_initialized_classes_helper() {\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  assert(klasses != nullptr, \"sanity\");\n+\n+  \/\/ First scan all resolved constant pools references.\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* src_k = klasses->at(i);\n+    if (src_k->is_instance_klass()) {\n+      InstanceKlass* src_ik = InstanceKlass::cast(src_k);\n+      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n+      objArrayOop rr = get_archived_resolved_references(src_ik);\n+      if (rr != nullptr) {\n+        objArrayOop scratch_rr = scratch_resolved_references(src_ik->constants());\n+        for (int i = 0; i < scratch_rr->length(); i++) {\n+          scan_for_aot_initialized_classes(scratch_rr->obj_at(i));\n+        }\n+      }\n+\n+      \/\/ If a class is hard-coded to be aot-initialize, mark it as such.\n+      if (AOTClassInitializer::can_archive_initialized_mirror(src_ik)) {\n+        mark_for_aot_initialization(buffered_ik);\n+      }\n+    }\n+  }\n+\n+  \/\/ These objects also belong to the special subgraph\n+  scan_for_aot_initialized_classes(Universe::null_ptr_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::arithmetic_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::internal_error_instance());\n+  scan_for_aot_initialized_classes(Universe::array_index_out_of_bounds_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::array_store_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::class_cast_exception_instance());\n+\n+  bool made_progress;\n+  do {\n+    \/\/ In each pass, we copy the scratch mirrors of the classes that were marked\n+    \/\/ as aot-init in the previous pass. We then scan these mirrors, which may\n+    \/\/ mark more classes. Keep iterating until no more progress can be made.\n+    made_progress = false;\n+    for (int i = 0; i < klasses->length(); i++) {\n+      Klass* orig_k = klasses->at(i);\n+      if (orig_k->is_instance_klass()) {\n+        InstanceKlass* orig_ik = InstanceKlass::cast(orig_k);\n+        if (ArchiveBuilder::current()->get_buffered_addr(orig_ik)->has_aot_initialized_mirror()) {\n+          oop orig_mirror = orig_ik->java_mirror();\n+          oop scratch_mirror = scratch_java_mirror(orig_k);\n+          if (!has_been_seen_during_subgraph_recording(scratch_mirror)) {\n+            \/\/ Scan scratch_mirror instead of orig_mirror (which has fields like ClassLoader that\n+            \/\/ are not archived).\n+            copy_aot_initialized_mirror(orig_k, orig_mirror, scratch_mirror);\n+            made_progress |= scan_for_aot_initialized_classes(scratch_mirror);\n+          }\n+        }\n+      }\n+    }\n+  } while (made_progress);\n+}\n+\n+bool HeapShared::scan_for_aot_initialized_classes(oop obj) {\n+  if (obj == nullptr || has_been_seen_during_subgraph_recording(obj)) {\n+    return false;\n+  }\n+  set_has_been_seen_during_subgraph_recording(obj);\n+\n+  bool made_progress = false;\n+  Klass* k = obj->klass();\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* orig_ik = InstanceKlass::cast(k);\n+    InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(orig_ik);\n+    made_progress = mark_for_aot_initialization(buffered_ik);\n+  }\n+\n+  AOTInitializedClassScanner scanner;\n+  obj->oop_iterate(&scanner);\n+  made_progress |= scanner.made_progress();\n+  return made_progress;\n+}\n+\n@@ -717,2 +1009,8 @@\n-    assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class(),\n-          \"must be boot class\");\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class() ||\n+             HeapShared::is_lambda_proxy_klass(InstanceKlass::cast(buffered_k)),\n+            \"we can archive only instances of boot classes or lambda proxy classes\");\n+    } else {\n+      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class(),\n+             \"must be boot class\");\n+    }\n@@ -727,0 +1025,4 @@\n+    if (buffered_k->has_aot_initialized_mirror()) {\n+      \/\/ No need to add to the runtime-init list.\n+      return;\n+    }\n@@ -763,0 +1065,11 @@\n+  const char* lambda_msg = \"\";\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    lambda_msg = \", or a lambda proxy class\";\n+    if (HeapShared::is_lambda_proxy_klass(ik) &&\n+        (ik->class_loader() == nullptr ||\n+         ik->class_loader() == SystemDictionary::java_platform_loader() ||\n+         ik->class_loader() == SystemDictionary::java_system_loader())) {\n+      return;\n+    }\n+  }\n+\n@@ -764,1 +1077,1 @@\n-  if (!ik->module()->is_named() && ik->package() == nullptr) {\n+  if (!ik->module()->is_named() && ik->package() == nullptr && ArchiveHeapTestClass != nullptr) {\n@@ -768,1 +1081,1 @@\n-  const char* extra_msg = \", or in an unnamed package of an unnamed module\";\n+  const char* testcls_msg = \", or a test class in an unnamed package of an unnamed module\";\n@@ -770,1 +1083,1 @@\n-  const char* extra_msg = \"\";\n+  const char* testcls_msg = \"\";\n@@ -774,2 +1087,2 @@\n-  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s\",\n-                       ik->external_name(), extra_msg);\n+  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s%s\",\n+                       ik->external_name(), lambda_msg, testcls_msg);\n@@ -796,0 +1109,19 @@\n+static bool is_trivial_clinit(InstanceKlass* ik) {\n+  if (ik->class_initializer() != nullptr) {\n+    return false;\n+  }\n+\n+  InstanceKlass* super = ik->java_super();\n+  if (super != nullptr && !is_trivial_clinit(super)) {\n+    return false;\n+  }\n+\n+  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    if (!is_trivial_clinit(interfaces->at(i))) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -843,1 +1175,7 @@\n-\n+        const char* trivial_clinit = \"\";\n+        if (subgraph_k->is_instance_klass()) {\n+          InstanceKlass* src_ik = InstanceKlass::cast(ArchiveBuilder::current()->get_source_addr(subgraph_k));\n+          if (is_trivial_clinit(InstanceKlass::cast(src_ik))) {\n+            trivial_clinit = \" (trivial clinit)\";\n+          }\n+        }\n@@ -845,2 +1183,2 @@\n-          \"Archived object klass %s (%2d) => %s\",\n-          owner_name, i, subgraph_k->external_name());\n+          \"Archived object klass %s (%2d) => %s%s\",\n+          owner_name, i, subgraph_k->external_name(), trivial_clinit);\n@@ -998,0 +1336,25 @@\n+void HeapShared::resolve_classes_for_subgraph_of(JavaThread* current, Klass* k) {\n+  JavaThread* THREAD = current;\n+  ExceptionMark em(THREAD);\n+  const ArchivedKlassSubGraphInfoRecord* record =\n+   resolve_or_init_classes_for_subgraph_of(k, \/*do_init=*\/false, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+   CLEAR_PENDING_EXCEPTION;\n+  }\n+  if (record == nullptr) {\n+   clear_archived_roots_of(k);\n+  }\n+}\n+\n+void HeapShared::initialize_java_lang_invoke(TRAPS) {\n+  if (CDSConfig::is_loading_invokedynamic() || CDSConfig::is_dumping_invokedynamic()) {\n+    resolve_or_init(\"java\/lang\/invoke\/Invokers$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/MethodHandle\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/MethodHandleNatives\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/DirectMethodHandle$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/LambdaForm$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/BoundMethodHandle$Species_L\", true, CHECK);\n+  }\n+}\n+\n@@ -1045,13 +1408,0 @@\n-void HeapShared::resolve_classes_for_subgraph_of(JavaThread* current, Klass* k) {\n-  JavaThread* THREAD = current;\n-  ExceptionMark em(THREAD);\n-  const ArchivedKlassSubGraphInfoRecord* record =\n-   resolve_or_init_classes_for_subgraph_of(k, \/*do_init=*\/false, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-   CLEAR_PENDING_EXCEPTION;\n-  }\n-  if (record == nullptr) {\n-   clear_archived_roots_of(k);\n-  }\n-}\n-\n@@ -1150,0 +1500,13 @@\n+void HeapShared::resolve_or_init(const char* klass_name, bool do_init, TRAPS) {\n+  TempNewSymbol klass_name_sym =  SymbolTable::new_symbol(klass_name);\n+  InstanceKlass* k = SystemDictionaryShared::find_builtin_class(klass_name_sym);\n+  if (k == nullptr) {\n+    return;\n+  }\n+  assert(k->is_shared_boot_class(), \"sanity\");\n+  resolve_or_init(k, false, CHECK);\n+  if (do_init) {\n+    resolve_or_init(k, true, CHECK);\n+  }\n+}\n+\n@@ -1182,1 +1545,5 @@\n-      m->obj_field_put(field_offset, v);\n+      if (k->has_aot_initialized_mirror()) {\n+        assert(v == m->obj_field(field_offset), \"must be aot-initialized\");\n+      } else {\n+        m->obj_field_put(field_offset, v);\n+      }\n@@ -1190,2 +1557,3 @@\n-      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s\",\n-                          k->external_name(), p2i(k), JvmtiExport::is_early_phase() ? \" (early)\" : \"\");\n+      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s%s\",\n+                          k->external_name(), p2i(k), JvmtiExport::is_early_phase() ? \" (early)\" : \"\",\n+                          k->has_aot_initialized_mirror() ? \" (aot-inited)\" : \"\");\n@@ -1787,2 +2155,2 @@\n-        \/\/ See KlassSubGraphInfo::check_allowed_klass() - only two types of\n-        \/\/ classes are allowed:\n+        \/\/ See KlassSubGraphInfo::check_allowed_klass() - we only allow test classes\n+        \/\/ to be:\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":409,"deletions":41,"binary":false,"changes":450,"status":"modified"},{"patch":"@@ -169,0 +169,4 @@\n+  static void start_finding_archivable_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n+  static void find_archivable_hidden_classes_in_object(oop o) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void end_finding_archivable_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n+\n@@ -253,0 +257,3 @@\n+  class FindHiddenClassesOopClosure;\n+  static void find_archivable_hidden_classes_helper(ArchivableStaticFieldInfo fields[]);\n+\n@@ -344,0 +351,1 @@\n+  static void resolve_or_init(const char* klass_name, bool do_init, TRAPS);\n@@ -358,0 +366,1 @@\n+  static void prepare_resolved_references();\n@@ -361,0 +370,6 @@\n+\n+  class AOTInitializedClassScanner;\n+  static void find_all_aot_initialized_classes();\n+  static void find_all_aot_initialized_classes_helper();\n+  static bool scan_for_aot_initialized_classes(oop obj);\n+\n@@ -444,0 +459,1 @@\n+  static void initialize_java_lang_invoke(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -445,0 +461,4 @@\n+\n+  static bool is_lambda_form_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_lambda_proxy_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_archivable_hidden_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -99,0 +99,6 @@\n+  if (CDSConfig::is_dumping_static_archive() && CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ Work around JDK-8310831, as some methods in lambda form holder classes may not get generated.\n+    log_info(cds)(\"Archived MethodHandles may refer to lambda form holder classes. Cannot regenerate.\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -564,1 +565,2 @@\n-  SystemDictionaryShared::check_excluded_classes();\n+\n+  SystemDictionaryShared::find_all_archivable_classes();\n@@ -842,0 +844,20 @@\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n+      \/\/ updated concurrently when we are saving their contents into a side table.\n+      assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n+\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n+                             vmSymbols::createArchivedObjects(),\n+                             vmSymbols::void_method_signature(),\n+                             CHECK);\n+\n+      \/\/ java.lang.Class::reflectionFactory cannot be archived yet. We set this field\n+      \/\/ to null, and it will be initialized again at runtime.\n+      log_debug(cds)(\"Resetting Class::reflectionFactory\");\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"resetArchivedStates\");\n+      Symbol* method_sig = vmSymbols::void_method_signature();\n+      JavaCalls::call_static(&result, vmClasses::Class_klass(),\n+                             method_name, method_sig, CHECK);\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -1239,1 +1240,1 @@\n-    \/\/ We do not archive hidden classes.\n+    record_hidden_class(ik);\n@@ -1341,0 +1342,38 @@\n+\n+void ClassLoader::record_hidden_class(InstanceKlass* ik) {\n+  assert(ik->is_hidden(), \"must be\");\n+\n+  s2 classloader_type;\n+  if (HeapShared::is_lambda_form_klass(ik)) {\n+    classloader_type = ClassLoader::BOOT_LOADER;\n+  } else {\n+    oop loader = ik->class_loader();\n+\n+    if (loader == nullptr) {\n+      classloader_type = ClassLoader::BOOT_LOADER;\n+    } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+      classloader_type = ClassLoader::PLATFORM_LOADER;\n+    } else if (SystemDictionary::is_system_class_loader(loader)) {\n+      classloader_type = ClassLoader::APP_LOADER;\n+    } else {\n+      \/\/ This class won't be archived, so no need to update its\n+      \/\/ classloader_type\/classpath_index.\n+      return;\n+    }\n+  }\n+  ik->set_shared_class_loader_type(classloader_type);\n+\n+  if (HeapShared::is_lambda_proxy_klass(ik)) {\n+    InstanceKlass* nest_host = ik->nest_host_not_null();\n+    ik->set_shared_classpath_index(nest_host->shared_classpath_index());\n+  } else if (HeapShared::is_lambda_form_klass(ik)) {\n+    ik->set_shared_classpath_index(0);\n+  } else {\n+    \/\/ Generated invoker classes.\n+    if (classloader_type == ClassLoader::APP_LOADER) {\n+      ik->set_shared_classpath_index(ClassLoaderExt::app_class_paths_start_index());\n+    } else {\n+      ik->set_shared_classpath_index(0);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -389,0 +389,1 @@\n+  static void record_hidden_class(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5431,14 +5431,12 @@\n-  if (klass == vmClasses::ClassLoader_klass() ||  \/\/ ClassLoader::loader_data is malloc'ed.\n-      \/\/ The next 3 classes are used to implement java.lang.invoke, and are not used directly in\n-      \/\/ regular Java code. The implementation of java.lang.invoke uses generated hidden classes\n-      \/\/ (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.\n-      \/\/ So for now we cannot not support these classes for archiving.\n-      \/\/\n-      \/\/ These objects typically are not referenced by static fields, but rather by resolved\n-      \/\/ constant pool entries, so excluding them shouldn't affect the archiving of static fields.\n-      klass == vmClasses::ResolvedMethodName_klass() ||\n-      klass == vmClasses::MemberName_klass() ||\n-      klass == vmClasses::Context_klass() ||\n-      \/\/ It's problematic to archive Reference objects. One of the reasons is that\n-      \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n-      klass->is_subclass_of(vmClasses::Reference_klass())) {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ These are supported by CDS only when CDSConfig::is_dumping_invokedynamic() is enabled.\n+    if (klass == vmClasses::ResolvedMethodName_klass() ||\n+        klass == vmClasses::MemberName_klass() ||\n+        klass == vmClasses::Context_klass()) {\n+      return false;\n+    }\n+  }\n+\n+  if (klass->is_subclass_of(vmClasses::Reference_klass())) {\n+    \/\/ It's problematic to archive Reference objects. One of the reasons is that\n+    \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -196,0 +197,8 @@\n+void SystemDictionaryShared::mark_required_class(InstanceKlass* k) {\n+  DumpTimeClassInfo* info = _dumptime_table->get(k);\n+  ResourceMark rm;\n+  if (info != nullptr) {\n+    info->set_is_required();\n+  }\n+}\n+\n@@ -279,3 +288,7 @@\n-      ResourceMark rm;\n-      log_info(cds)(\"Skipping %s because it is dynamically generated\", k->name()->as_C_string());\n-      return true; \/\/ exclude without warning\n+      if (CDSConfig::is_dumping_aot_linked_classes()) {\n+        k->set_shared_classpath_index(0);\n+      } else {\n+        ResourceMark rm;\n+        log_info(cds)(\"Skipping %s because it is dynamically generated\", k->name()->as_C_string());\n+        return true; \/\/ exclude without warning\n+      }\n@@ -318,3 +331,2 @@\n-  if (k->is_hidden() && !is_registered_lambda_proxy_class(k)) {\n-    ResourceMark rm;\n-    log_debug(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n+  if (k->is_hidden() && !should_hidden_class_be_archived(k)) {\n+    log_info(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n@@ -580,1 +592,5 @@\n-      assert(is_registered_lambda_proxy_class(k), \"unexpected hidden class %s\", name);\n+      if (CDSConfig::is_dumping_invokedynamic()) {\n+        assert(should_hidden_class_be_archived(k), \"unexpected hidden class %s\", name);\n+      } else {\n+        assert(is_registered_lambda_proxy_class(k), \"unexpected hidden class %s\", name);\n+      }\n@@ -632,1 +648,77 @@\n-void SystemDictionaryShared::check_excluded_classes() {\n+void SystemDictionaryShared::scan_constant_pool(InstanceKlass* k) {\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    k->constants()->find_archivable_hidden_classes();\n+  }\n+}\n+\n+bool SystemDictionaryShared::should_hidden_class_be_archived(InstanceKlass* k) {\n+  assert(k->is_hidden(), \"sanity\");\n+  if (is_registered_lambda_proxy_class(k)) {\n+    return true;\n+  }\n+\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    if (HeapShared::is_archivable_hidden_klass(k)) {\n+      return true;\n+    }\n+\n+    DumpTimeClassInfo* info = _dumptime_table->get(k);\n+    if (info != nullptr && info->is_required()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ Returns true if the class should be excluded. This can be called before\n+\/\/ SystemDictionaryShared::check_excluded_classes().\n+bool SystemDictionaryShared::check_for_exclusion(Klass* k) {\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n+\n+  if (k->is_objArray_klass()) {\n+    return check_for_exclusion(ObjArrayKlass::cast(k)->bottom_klass());\n+  }\n+\n+  if (!k->is_instance_klass()) {\n+    return false;\n+  } else {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      return is_excluded_class(ik);\n+    }\n+\n+    if (!ik->is_linked()) {\n+      JavaThread* THREAD = JavaThread::current();\n+      ik->link_class(THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION;\n+        return true;\n+      }\n+    }\n+\n+    MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+    DumpTimeClassInfo* p = get_info_locked(ik);\n+    if (p->is_excluded()) {\n+      return true;\n+    }\n+    return check_for_exclusion(ik, p);\n+  }\n+}\n+\n+void SystemDictionaryShared::find_all_archivable_classes() {\n+  HeapShared::start_finding_archivable_hidden_classes();\n+  find_all_archivable_classes_impl();\n+  HeapShared::end_finding_archivable_hidden_classes();\n+}\n+\n+\/\/ Iterate over all the classes in _dumptime_table, marking the ones that must be\n+\/\/ excluded from the archive. Those that are not excluded will be archivable.\n+\/\/\n+\/\/ (a) Non-hidden classes are easy. They are only check by the rules in\n+\/\/     SystemDictionaryShared::check_for_exclusion().\n+\/\/ (b) For hidden classes, we only archive those that are required (i.e., they are\n+\/\/     referenced by Java objects (such as CallSites) that are reachable from\n+\/\/     ConstantPools.\n+void SystemDictionaryShared::find_all_archivable_classes_impl() {\n@@ -645,2 +737,42 @@\n-  auto check_for_exclusion = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n-    SystemDictionaryShared::check_for_exclusion(k, &info);\n+  ResourceMark rm;\n+\n+  \/\/ First, scan all non-hidden classes\n+  auto check_non_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!k->is_hidden()) {\n+      SystemDictionaryShared::check_for_exclusion(k, &info);\n+      if (!info.is_excluded() && !info.has_scanned_constant_pool()) {\n+        scan_constant_pool(k);\n+        info.set_has_scanned_constant_pool();\n+      }\n+    }\n+  };\n+  _dumptime_table->iterate_all_live_classes(check_non_hidden);\n+\n+  \/\/ Then, scan all the hidden classes that have been marked as required to\n+  \/\/ discover more hidden classes. Stop when we cannot make progress anymore.\n+  bool made_progress;\n+  do {\n+    made_progress = false;\n+    auto check_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+      if (k->is_hidden() && should_hidden_class_be_archived(k)) {\n+        SystemDictionaryShared::check_for_exclusion(k, &info);\n+        if (info.is_excluded()) {\n+          guarantee(!info.is_required(), \"A required hidden class cannot be marked as excluded\");\n+        } else if (!info.has_scanned_constant_pool()) {\n+          scan_constant_pool(k);\n+          info.set_has_scanned_constant_pool();\n+          \/\/ The CP entries in k *MAY* refer to other hidden classes, so scan\n+          \/\/ every hidden class again.\n+          made_progress = true;\n+        }\n+      }\n+    };\n+    _dumptime_table->iterate_all_live_classes(check_hidden);\n+  } while (made_progress);\n+\n+  \/\/ Now, all hidden classes that have not yet been scanned must be marked as excluded\n+  auto exclude_remaining_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (k->is_hidden() && !info.has_checked_exclusion()) {\n+      SystemDictionaryShared::check_for_exclusion(k, &info);\n+      guarantee(info.is_excluded(), \"Must be\");\n+    }\n@@ -648,1 +780,1 @@\n-  _dumptime_table->iterate_all_live_classes(check_for_exclusion);\n+  _dumptime_table->iterate_all_live_classes(exclude_remaining_hidden);\n@@ -758,0 +890,5 @@\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ The lambda proxy classes will be stored as part of aot-resolved constant pool entries.\n+    \/\/ There's no need to remember them in a separate table.\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":148,"deletions":11,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,1 @@\n+  static void find_all_archivable_classes_impl();\n@@ -202,1 +203,1 @@\n-\n+  static void scan_constant_pool(InstanceKlass* k);\n@@ -206,0 +207,2 @@\n+  static bool should_hidden_class_be_archived(InstanceKlass* k);\n+  static void mark_required_class(InstanceKlass* k);\n@@ -291,1 +294,2 @@\n-  static void check_excluded_classes();\n+  static void find_all_archivable_classes();\n+  static bool check_for_exclusion(Klass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -732,0 +732,1 @@\n+  template(createArchivedObjects,                           \"createArchivedObjects\")                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -952,0 +952,9 @@\n+void InterpreterRuntime::cds_resolve_invokehandle(int raw_index,\n+                                                  constantPoolHandle& pool, TRAPS) {\n+  const Bytecodes::Code bytecode = Bytecodes::_invokehandle;\n+  CallInfo info;\n+  LinkResolver::resolve_invoke(info, Handle(), pool, raw_index, bytecode, CHECK);\n+\n+  pool->cache()->set_method_handle(raw_index, info);\n+}\n+\n@@ -971,0 +980,8 @@\n+void InterpreterRuntime::cds_resolve_invokedynamic(int raw_index,\n+                                                   constantPoolHandle& pool, TRAPS) {\n+  const Bytecodes::Code bytecode = Bytecodes::_invokedynamic;\n+  CallInfo info;\n+  LinkResolver::resolve_invoke(info, Handle(), pool, raw_index, bytecode, CHECK);\n+  pool->cache()->set_dynamic_call(info, raw_index);\n+}\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -100,1 +100,4 @@\n-\n+  static void cds_resolve_invokehandle(int raw_index,\n+                                       constantPoolHandle& pool, TRAPS);\n+  static void cds_resolve_invokedynamic(int raw_index,\n+                                        constantPoolHandle& pool, TRAPS);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,5 @@\n-  cld->oops_do(this, _claim);\n+  if (cld != nullptr) {\n+    \/\/ Could be null during early VM bootstrap for archived heap objects whose\n+    \/\/ class has not yet been loaded by CDS.\n+    cld->oops_do(this, _claim);\n+  }\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -286,0 +287,29 @@\n+template <typename Function>\n+void ConstantPool::iterate_archivable_resolved_references(Function function) {\n+  objArrayOop rr = resolved_references();\n+  if (rr != nullptr && cache() != nullptr && CDSConfig::is_dumping_invokedynamic()) {\n+    Array<ResolvedIndyEntry>* indy_entries = cache()->resolved_indy_entries();\n+    if (indy_entries != nullptr) {\n+      for (int i = 0; i < indy_entries->length(); i++) {\n+        ResolvedIndyEntry *rie = indy_entries->adr_at(i);\n+        if (rie->is_resolved() && AOTConstantPoolResolver::is_resolution_deterministic(this, rie->constant_pool_index())) {\n+          int rr_index = rie->resolved_references_index();\n+          function(rr_index);\n+        }\n+      }\n+    }\n+\n+    Array<ResolvedMethodEntry>* method_entries = cache()->resolved_method_entries();\n+    if (method_entries != nullptr) {\n+      for (int i = 0; i < method_entries->length(); i++) {\n+        ResolvedMethodEntry* rme = method_entries->adr_at(i);\n+        if (rme->is_resolved(Bytecodes::_invokehandle) && rme->has_appendix() &&\n+            cache()->can_archive_resolved_method(this, rme)) {\n+          int rr_index = rme->resolved_references_index();\n+          function(rr_index);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -303,0 +333,1 @@\n+    ResourceMark rm;\n@@ -304,0 +335,2 @@\n+    GrowableArray<bool> keep_resolved_refs(rr_len, rr_len, false);\n+\n@@ -305,0 +338,4 @@\n+    src_cp->iterate_archivable_resolved_references([&](int rr_index) {\n+      keep_resolved_refs.at_put(rr_index, true);\n+      });\n+\n@@ -320,0 +357,2 @@\n+        } else if (keep_resolved_refs.at(i)) {\n+          scratch_rr->obj_at_put(i, obj);\n@@ -328,0 +367,26 @@\n+void ConstantPool::find_archivable_hidden_classes() {\n+  if (_cache == nullptr) {\n+    return;\n+  }\n+\n+  ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n+  if (loader_data == nullptr) {\n+    \/\/ These are custom loader classes from the preimage\n+    return;\n+  }\n+\n+  if (!SystemDictionaryShared::is_builtin_loader(loader_data)) {\n+    \/\/ Archiving resolved references for classes from non-builtin loaders\n+    \/\/ is not yet supported.\n+    return;\n+  }\n+\n+  objArrayOop rr = resolved_references();\n+  if (rr != nullptr) {\n+    iterate_archivable_resolved_references([&](int rr_index) {\n+      oop obj = rr->obj_at(rr_index);\n+      HeapShared::find_archivable_hidden_classes_in_object(obj);\n+    });\n+  }\n+}\n+\n@@ -764,3 +829,1 @@\n-      tty->print_cr(\"Unexpected bytecode: %d\", code);\n-      ShouldNotReachHere(); \/\/ All cases should have been handled\n-      return -1;\n+      fatal(\"Unexpected bytecode: %s\", Bytecodes::name(code));\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":66,"deletions":3,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -685,0 +685,1 @@\n+  void find_archivable_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -691,0 +692,1 @@\n+  template <typename Function> void iterate_archivable_resolved_references(Function function);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -404,3 +405,1 @@\n-    for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n-      resolved_indy_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_indy_entries_if_non_deterministic();\n@@ -459,1 +458,2 @@\n-                    rme->is_resolved(Bytecodes::_invokeinterface);\n+                    rme->is_resolved(Bytecodes::_invokeinterface) ||\n+                    rme->is_resolved(Bytecodes::_invokehandle);\n@@ -462,2 +462,1 @@\n-    resolved &= !(rme->is_resolved(Bytecodes::_invokehandle) ||\n-                  rme->is_resolved(Bytecodes::_invokestatic));\n+    resolved &= !(rme->is_resolved(Bytecodes::_invokestatic));\n@@ -465,1 +464,1 @@\n-    if (resolved && can_archive_resolved_method(rme)) {\n+    if (resolved && can_archive_resolved_method(src_cp, rme)) {\n@@ -497,1 +496,35 @@\n-bool ConstantPoolCache::can_archive_resolved_method(ResolvedMethodEntry* method_entry) {\n+void ConstantPoolCache::remove_resolved_indy_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n+    ResolvedIndyEntry* rei = _resolved_indy_entries->adr_at(i);\n+    int cp_index = rei->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rei->is_resolved();\n+    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+      rei->mark_and_relocate();\n+      archived = true;\n+    } else {\n+      rei->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n+        int bsm_ref = cp->method_handle_index_at(bsm);\n+        Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n+        Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n+        Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n+        log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  cp_index, cp->pool_holder()->name()->as_C_string(), i);\n+        log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(),\n+                  bsm_name->as_C_string(), bsm_signature->as_C_string());\n+      }\n+      ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n+    }\n+  }\n+}\n+\n+bool ConstantPoolCache::can_archive_resolved_method(ConstantPool* src_cp, ResolvedMethodEntry* method_entry) {\n@@ -522,1 +555,0 @@\n-  ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(constant_pool());\n@@ -533,0 +565,7 @@\n+  } else if (method_entry->is_resolved(Bytecodes::_invokehandle)) {\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      \/\/ invokehandle depends on archived MethodType and LambdaForms.\n+      return true;\n+    } else {\n+      return false;\n+    }\n@@ -534,1 +573,0 @@\n-    \/\/ invokestatic and invokehandle are not supported yet.\n@@ -537,1 +575,0 @@\n-\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+  void remove_resolved_indy_entries_if_non_deterministic();\n@@ -228,1 +229,1 @@\n-  bool can_archive_resolved_method(ResolvedMethodEntry* method_entry);\n+  bool can_archive_resolved_method(ConstantPool* src_cp, ResolvedMethodEntry* method_entry);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1323,1 +1323,0 @@\n-\n@@ -2571,0 +2570,1 @@\n+  it->push(&_nest_host);\n@@ -2578,1 +2578,0 @@\n-\n@@ -2634,2 +2633,6 @@\n-  \/\/ clear _nest_host to ensure re-load at runtime\n-  _nest_host = nullptr;\n+  if (CDSConfig::is_dumping_invokedynamic() && HeapShared::is_lambda_proxy_klass(this)) {\n+    \/\/ keep _nest_host\n+  } else {\n+    \/\/ clear _nest_host to ensure re-load at runtime\n+    _nest_host = nullptr;\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -2654,3 +2655,11 @@\n-      \/\/ If no caller class, or caller class has a different loader, then\n-      \/\/ issue a warning below.\n-      do_warning = (caller == nullptr) || caller->class_loader() != cl;\n+      if (CDSConfig::is_loading_invokedynamic() &&\n+          (k == vmClasses::Class_klass() || k == vmClasses::internal_Unsafe_klass())) {\n+        \/\/ With archived indys, these two classes are aot-inited, but we need to\n+        \/\/ call their registerNative() methods directly from C++ code, so caller\n+        \/\/ will be null.\n+        assert(k->has_aot_initialized_mirror(), \"sanity\");\n+        assert(caller == nullptr, \"sanity\");\n+        assert(cl == nullptr, \"sanity\");\n+      } else {\n+        do_warning = (caller == nullptr) || caller->class_loader() != cl;\n+      }\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2921,1 +2921,1 @@\n-  if (CDSConfig::is_dumping_static_archive()) {\n+  if (CDSConfig::allow_only_single_java_thread()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -337,0 +338,8 @@\n+static void call_register_natives_for_aot_inited_class(InstanceKlass* ik, TRAPS) {\n+  assert(ik->has_aot_initialized_mirror(), \"sanity\");\n+  JavaValue result(T_VOID);\n+  TempNewSymbol method_name = SymbolTable::new_symbol(\"registerNatives\");\n+  JavaCalls::call_static(&result, ik, method_name,\n+                         vmSymbols::void_method_signature(), CHECK);\n+}\n+\n@@ -349,0 +358,8 @@\n+\n+  if (CDSConfig::is_loading_invokedynamic()) {\n+    \/\/ The <clinit> of these two classes won't be executed, but we still need to register\n+    \/\/ their natives.\n+    call_register_natives_for_aot_inited_class(vmClasses::Class_klass(), CHECK);\n+    call_register_natives_for_aot_inited_class(vmClasses::internal_Unsafe_klass(), CHECK);\n+  }\n+\n@@ -404,0 +421,1 @@\n+  initialize_class(vmSymbols::java_lang_InternalError(), CHECK);\n@@ -413,0 +431,4 @@\n+\n+  if (UseSharedSpaces) {\n+    HeapShared::initialize_java_lang_invoke(CHECK);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4057,0 +4057,9 @@\n+    \/**\n+     * When CDS is enabled, the Class class may be aot-initialized. However,\n+     * we can't archive reflectionFactory, so we reset it to null, so it\n+     * will be allocated again at runtime.\n+     *\/\n+    private static void resetArchivedStates() {\n+        reflectionFactory = null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1648,1 +1648,1 @@\n-                    cob.ldc(os.toString());\n+                    cob.loadConstant(os.toString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import java.util.HashMap;\n+import java.util.Iterator;\n@@ -401,0 +403,7 @@\n+        if (archivedMethodTypes != null) {\n+            MethodType mt = archivedMethodTypes.get(primordialMT);\n+            if (mt != null) {\n+                return mt;\n+            }\n+        }\n+\n@@ -419,0 +428,1 @@\n+\n@@ -420,0 +430,1 @@\n+    private static @Stable HashMap<MethodType,MethodType> archivedMethodTypes;\n@@ -1400,0 +1411,18 @@\n+\n+    static HashMap<MethodType,MethodType> copyInternTable() {\n+        HashMap<MethodType,MethodType> copy = new HashMap<>();\n+\n+        for (Iterator<MethodType> i = internTable.iterator(); i.hasNext(); ) {\n+            MethodType t = i.next();\n+            copy.put(t, t);\n+        }\n+\n+        return copy;\n+    }\n+\n+    \/\/ This is called from C code, at the very end of Java code execution\n+    \/\/ during the AOT cache assembly phase.\n+    static void createArchivedObjects() {\n+        archivedMethodTypes = copyInternTable();\n+        internTable.clear();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+ -runtime\/cds\/appcds\/BadBSM.java \\\n@@ -535,0 +536,1 @@\n+ -runtime\/cds\/appcds\/DumpClassListWithLF.java \\\n@@ -536,0 +538,2 @@\n+ -runtime\/cds\/appcds\/dynamicArchive\/LambdasInTwoArchives.java \\\n+ -runtime\/cds\/appcds\/HelloExtTest.java \\\n@@ -543,0 +547,1 @@\n+ -runtime\/cds\/appcds\/LambdaProxyClasslist.java \\\n@@ -548,0 +553,3 @@\n+ -runtime\/cds\/appcds\/StaticArchiveWithLambda.java \\\n+ -runtime\/cds\/appcds\/TestEpsilonGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestParallelGCWithCDS.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,5 @@\n-            output.shouldMatch(\"Skipping.LambdaContainsOldInfApp[$][$]Lambda.*0x.*:.*Old.class.has.been.linked\");\n+            if (CDSTestUtils.isAOTClassLinkingEnabled()) {\n+                output.shouldMatch(\"Cannot aot-resolve Lambda proxy because OldProvider is excluded\");\n+            } else {\n+                output.shouldMatch(\"Skipping.LambdaContainsOldInfApp[$][$]Lambda.*0x.*:.*Old.class.has.been.linked\");\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaContainsOldInf.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-              .shouldMatch(\".class.load. LambdaWithOldClassApp[$][$]Lambda.*\/0x.*source:.*shared objects file\")\n@@ -73,0 +72,5 @@\n+        if (!CDSTestUtils.isAOTClassLinkingEnabled()) {\n+            \/\/ With AOTClassLinking, we don't archive any lambda with old classes in the method\n+            \/\/ signatures.\n+            output.shouldMatch(\".class.load. LambdaWithOldClassApp[$][$]Lambda.*\/0x.*source:.*shared objects file\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaWithOldClass.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,5 @@\n+        test(false);\n+        test(true);\n+    }\n+\n+    static void test(boolean aotClassLinking) throws Exception {\n@@ -60,0 +65,3 @@\n+        if (aotClassLinking) {\n+            opts.addPrefix(\"-XX:+AOTClassLinking\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaWithUseImplMethodHandle.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.test.lib.cds.CDSTestUtils;\n@@ -154,3 +155,4 @@\n-        testCase(\"Use a disallowed class: in unnamed module but not in unname package\");\n-        output = dumpBootAndHello(CDSTestClassE_name);\n-        mustFail(output, \"Class pkg.ClassInPackage not allowed in archive heap\");\n+        if (!CDSTestUtils.isAOTClassLinkingEnabled()) {\n+            testCase(\"Use a disallowed class: in unnamed module but not in unname package\");\n+            output = dumpBootAndHello(CDSTestClassE_name);\n+            mustFail(output, \"Class pkg.ClassInPackage not allowed in archive heap\");\n@@ -158,3 +160,4 @@\n-        testCase(\"Use a disallowed class: not in java.base module\");\n-        output = dumpBootAndHello(CDSTestClassF_name);\n-        mustFail(output, \"Class java.util.logging.Level not allowed in archive heap\");\n+            testCase(\"Use a disallowed class: not in java.base module\");\n+            output = dumpBootAndHello(CDSTestClassF_name);\n+            mustFail(output, \"Class java.util.logging.Level not allowed in archive heap\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-            .shouldContain(\"unreg OldClass unlinked\");\n+            .shouldContain(\"unreg OldClass old unlinked\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/CustomClassListDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,276 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary AOT resolution of lambda expressions\n+ * @bug 8340836\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/\n+ * @build AOTLinkedLambdas\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 AOTLinkedLambdasApp InitTracker\n+ *                 IntfWithNoClinit IntfWithNoClinit2\n+ *                 IntfWithClinit IntfWithClinit2\n+ *                 FooA FooB\n+ *                 BarA BarB BarC\n+ * @run driver AOTLinkedLambdas\n+ *\/\n+\n+import java.util.function.Supplier;\n+import static java.util.stream.Collectors.*;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTLinkedLambdas {\n+    static final String classList = \"AOTLinkedLambdas.classlist\";\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = AOTLinkedLambdasApp.class.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        CDSTestUtils.dumpClassList(classList, \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"Hello AOTLinkedLambdasApp\");\n+            });\n+\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-XX:+AOTClassLinking\",\n+                       \"-Xlog:cds+resolve=trace\",\n+                       \"-Xlog:cds+class=debug\",\n+                       \"-cp\", appJar);\n+\n+        OutputAnalyzer dumpOut = CDSTestUtils.createArchiveAndCheck(opts);\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IntfWithClinit (has <clinit>)\");\n+        dumpOut.shouldNotContain(\"Cannot aot-resolve Lambda proxy of interface type IntfWithClinit2 (has <clinit>)\");\n+\n+        CDSOptions runOpts = (new CDSOptions())\n+            .setUseVersion(false)\n+            .addPrefix(\"-Xlog:cds\",\n+                       \"-esa\",         \/\/ see JDK-8340836\n+                       \"-cp\", appJar)\n+            .addSuffix(mainClass);\n+\n+        CDSTestUtils.run(runOpts)\n+            .assertNormalExit(\"Hello AOTLinkedLambdasApp\",\n+                              \"hello, world\");\n+    }\n+}\n+\n+class AOTLinkedLambdasApp {\n+    static {\n+        System.out.println(\"AOTLinkedLambdasApp.<clinit>\");\n+    }\n+    public static void main(String args[]) {\n+        System.out.println(\"Hello AOTLinkedLambdasApp\");\n+\n+        \/\/ (1) Simple tests\n+        var words = java.util.List.of(\"hello\", \"fuzzy\", \"world\");\n+        System.out.println(words.stream().filter(w->!w.contains(\"u\")).collect(joining(\", \")));\n+        \/\/ => hello, world\n+\n+        \/\/ (2) Test for <clinit> order.\n+        testClinitOrder();\n+    }\n+\n+\n+    \/\/ Check that aot-linking of indys do not run <clinit> in unexpected order:\n+    \/\/\n+    \/\/     For any type T that *appears* in an indy callsite, if T::<clinit> exists and\n+    \/\/     must be executed during the linking of this callsite, then T::<clinit>\n+    \/\/     must be executed the first time this indy instruction is executed, not earlier.\n+    \/\/\n+    \/\/ This test case tries to enumerate all possibilities where a type T may appear\n+    \/\/ in an indy callsite, and asserts when T is initialized.\n+    \/\/\n+    \/\/ Note: although T may appear in many parts of an indy callsite, ONLY the return type\n+    \/\/ of factoryType must be initialized during the linking of this callsite. All other types\n+    \/\/ will be initialized per the regular \"4 bytecode rule\" of getstatic\/putstatic\/new\/instanceof.\n+    static void testClinitOrder() {\n+        \/*\n+         * An indy callsite is associated with the following MethodType and MethodHandles:\n+         *\n+         * https:\/\/github.com\/openjdk\/jdk\/blob\/580eb62dc097efeb51c76b095c1404106859b673\/src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java#L293-L309\n+         *\n+         * MethodType factoryType         The expected signature of the {@code CallSite}.  The\n+         *                                parameter types represent the types of capture variables;\n+         *                                the return type is the interface to implement.   When\n+         *                                used with {@code invokedynamic}, this is provided by\n+         *                                the {@code NameAndType} of the {@code InvokeDynamic}\n+         *\n+         * MethodType interfaceMethodType Signature and return type of method to be\n+         *                                implemented by the function object.\n+         *\n+         * MethodHandle implementation    A direct method handle describing the implementation\n+         *                                method which should be called (with suitable adaptation\n+         *                                of argument types and return types, and with captured\n+         *                                arguments prepended to the invocation arguments) at\n+         *                                invocation time.\n+         *\n+         * MethodType dynamicMethodType   The signature and return type that should\n+         *                                be enforced dynamically at invocation time.\n+         *                                In simple use cases this is the same as\n+         *                                {@code interfaceMethodType}.\n+         *\/\n+\n+        \/\/ Initial condition: no <clinit> used by our Foo? and Bar? types have been called.\n+        InitTracker.assertOrder(\"InitTracker\");\n+\n+        \/\/==============================\n+        \/\/ Case (i) -- Check for types used by factoryType, interfaceMethodType and dynamicMethodType\n+        \/\/             (Note: no tests for captured variables in factoryType yet; will be tested in case (ii))\n+        \/\/ factoryType         = \"()LIntfWithNoClinit;\n+        \/\/ interfaceMethodType = \"(LFooB;)LFooA;\"\n+        \/\/ implementation      = \"REF_invokeStatic AOTLinkedLambdasApp.implAB:(LBarB;)LBarA;\"\n+        \/\/ dynamicMethodType   = \"(LBarB;)LBarA;\"\n+        IntfWithNoClinit<BarA, BarB> noclinit = AOTLinkedLambdasApp::implAB;\n+\n+        \/\/ None of the Foo? and Bar? types used by the lambda should have been initialized yet, even though\n+        \/\/ the indy callsite has been resolved now.\n+        InitTracker.assertOrder(\"InitTracker\");\n+\n+        BarB barB = new BarB();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB\");\n+        BarA barA = noclinit.doit(barB);\n+        System.out.println(barB);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA\");\n+\n+        \/\/==============================\n+        \/\/ Case (ii) -- Check for types used by captured variables in factoryType\n+        BarC barC = null;\n+        IntfWithNoClinit2 noclinit2 = () -> { return barC.hashCode(); };\n+        try {\n+            noclinit2.doit();\n+            throw new RuntimeException(\"NullPointerException should have been thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected\n+        }\n+        \/\/ BarC shouldn't be initialized as no instances of it has been created.\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA\");\n+\n+        \/\/==============================\n+        \/\/ Case (iii) -- factoryType has a <clinit> and must be initialized during\n+        \/\/ the indy resolution. This lambda CANNOT be aot-linked.\n+        \/\/ factoryType = \"()LIntfWithClinit;\"\n+        IntfWithClinit hasclinit = () -> { return 1234; };\n+\n+        \/\/ must be initialized even before the lambda is used.\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IntfWithClinit\");\n+\n+        \/\/==============================\n+        \/\/ Case (iv) -- factoryType has a <clinit>, but it doesn't need to be initialized during\n+        \/\/ the indy resolution (see IntfWithClinit2). This lambda can be aot-linked.\n+        \/\/ factoryType = \"()LIntfWithClinit2;\"\n+        IntfWithClinit2 hasclinit2 = () -> { return 1234; };\n+        \/\/ IntfWithClinit2 must not be initialized yet\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IntfWithClinit\");\n+\n+        System.out.println(hasclinit2.doit());\n+        \/\/ IntfWithClinit2 must not be initialized yet\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IntfWithClinit\");\n+\n+         System.out.println(IntfWithClinit2._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IntfWithClinit, IntfWithClinit2\");\n+    }\n+\n+    static BarA implAB(BarB param) {\n+        return new BarA(param);\n+    }\n+}\n+\n+\n+\/\/ An interface with no <clinit> method. A lambda implementing this\n+\/\/ interface can be AOT-linked.\n+@FunctionalInterface\n+interface IntfWithNoClinit<X extends FooA, Y extends FooB> {\n+    X doit(Y param);\n+}\n+\n+\/\/ Another interface with no <clinit> method. A lambda implementing this\n+\/\/ interface can be AOT-linked.\n+@FunctionalInterface\n+interface IntfWithNoClinit2 {\n+    int doit();\n+}\n+\n+\/\/ A functional interface with a <clinit> that must be executed before we instantiate\n+\/\/ any lambda that implements this interface. Requirements:\n+\/\/ - the interface has a <clinit> function.\n+\/\/ - the interface has at least one default method.\n+@FunctionalInterface\n+interface IntfWithClinit {\n+    static final int _dummy = InitTracker.trackEvent(\"IntfWithClinit\");\n+    default int dummy() { return _dummy; }\n+    int doit();\n+}\n+\n+\/\/ A functional interface with a <clinit>, but it doesn't need to be initialized because\n+\/\/ it doesn't have any default methods.\n+\/\/ The <clinit> should be accessed only when IntfWithClinit2._dummy is accessed.\n+@FunctionalInterface\n+interface IntfWithClinit2 {\n+    static final int _dummy = InitTracker.trackEvent(\"IntfWithClinit2\");\n+    int doit();\n+}\n+\n+class InitTracker {\n+    static String actualOrder = \"InitTracker\";\n+    static int trackEvent(String event) {\n+        actualOrder += \", \" + event;\n+        return actualOrder.lastIndexOf(',');\n+    }\n+    static void assertOrder(String wantOrder) {\n+        System.out.println(\"wantOrder   = \" + wantOrder);\n+        System.out.println(\"actualOrder = \" + actualOrder);\n+        if (!actualOrder.equals(wantOrder)) {\n+            throw new RuntimeException(\"Want <clinit> order: {\" + wantOrder + \"}, but got {\" + actualOrder + \"}\");\n+        }\n+    }\n+}\n+\n+interface FooA {\n+    static final int _dummy = InitTracker.trackEvent(\"FooA\");\n+    default int dummy() { return _dummy; }\n+}\n+\n+interface FooB {\n+    static final int _dummy = InitTracker.trackEvent(\"FooB\");\n+    default int dummy() { return _dummy; }\n+}\n+\n+class BarA implements FooA {\n+    static {InitTracker.trackEvent(\"BarA\");}\n+    BarA(BarB dummy) {}\n+}\n+\n+class BarB implements FooB {\n+    static {InitTracker.trackEvent(\"BarB\");}\n+}\n+\n+class BarC {\n+    static {InitTracker.trackEvent(\"BarC\");}\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedLambdas.java","additions":276,"deletions":0,"binary":false,"changes":276,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Dump time resolutiom of constant pool entries.\n+ * @summary Dump time resolution of constant pool entries.\n@@ -31,1 +31,2 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/\n+ * @build OldProvider OldClass OldConsumer\n@@ -33,1 +34,4 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar ResolvedConstantsApp ResolvedConstantsFoo ResolvedConstantsBar\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 ResolvedConstantsApp ResolvedConstantsFoo ResolvedConstantsBar\n+ *                 MyInterface InterfaceWithClinit NormalClass\n+ *                 OldProvider OldClass OldConsumer SubOfOldClass\n@@ -37,0 +41,1 @@\n+import java.util.function.Consumer;\n@@ -40,0 +45,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -62,1 +68,2 @@\n-                       \"-Xlog:cds+resolve=trace\");\n+                       \"-Xlog:cds+resolve=trace\",\n+                       \"-Xlog:cds+class=debug\");\n@@ -69,1 +76,1 @@\n-        CDSTestUtils.createArchiveAndCheck(opts)\n+        OutputAnalyzer out = CDSTestUtils.createArchiveAndCheck(opts);\n@@ -73,1 +80,1 @@\n-            .shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\"))\n+        out.shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\"))\n@@ -139,0 +146,11 @@\n+\n+\n+        \/\/ Indy References ---\n+        if (aotClassLinking) {\n+            out.shouldContain(\"Cannot aot-resolve Lambda proxy because OldConsumer is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldProvider is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldClass is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy of interface type InterfaceWithClinit (has <clinit>)\")\n+               .shouldMatch(\"klasses.* app *NormalClass[$][$]Lambda\/.* hidden aot-linked inited\")\n+               .shouldNotMatch(\"klasses.* app *SubOfOldClass[$][$]Lambda\/\");\n+        }\n@@ -169,0 +187,2 @@\n+\n+        testLambda();\n@@ -175,0 +195,66 @@\n+\n+    static void testLambda() {\n+        \/\/ The functional type used in the Lambda is an excluded class\n+        OldProvider op = () -> {\n+            return null;\n+        };\n+\n+        \/\/ A captured value is an instance of an excluded Class\n+        OldClass c = new OldClass();\n+        Runnable r = () -> {\n+            System.out.println(\"Test 1 \" + c);\n+        };\n+        r.run();\n+\n+        \/\/ The functional interface accepts an argument that's an excluded class\n+        MyInterface i = (o) -> {\n+            System.out.println(\"Test 2 \" + o);\n+        };\n+        i.dispatch(c);\n+\n+        \/\/ Method reference to old class\n+        OldConsumer oldConsumer = new OldConsumer();\n+        Consumer<String> wrapper = oldConsumer::consumeString;\n+        wrapper.accept(\"Hello\");\n+\n+        \/\/ Lambda of interfaces that have <clinit> are not archived.\n+        InterfaceWithClinit i2 = () -> {\n+            System.out.println(\"Test 3\");\n+        };\n+        i2.dispatch();\n+\n+        \/\/ These two classes have almost identical source code, but\n+        \/\/ only NormalClass should have its lambdas pre-resolved.\n+        \/\/ SubOfOldClass is \"old\" -- it should be excluded from the AOT cache,\n+        \/\/ so none of its lambda proxies should be cached\n+        NormalClass.testLambda();   \/\/ Lambda proxy should be cached\n+        SubOfOldClass.testLambda(); \/\/ Lambda proxy shouldn't be cached\n+    }\n+}\n+\n+class NormalClass {\n+    static void testLambda() {\n+        Runnable r = () -> {\n+            System.out.println(\"NormalClass testLambda\");\n+        };\n+        r.run();\n+    }\n+}\n+\n+class SubOfOldClass extends OldClass {\n+    static void testLambda() {\n+        Runnable r = () -> {\n+            System.out.println(\"SubOfOldClass testLambda\");\n+        };\n+        r.run();\n+    }\n+}\n+\n+interface MyInterface {\n+    void dispatch(OldClass c);\n+}\n+\n+interface InterfaceWithClinit {\n+    static final long X = System.currentTimeMillis();\n+    void dispatch();\n+    default long dummy() { return X; }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":92,"deletions":6,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/OldClass.jasm","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+super class OldConsumer\n+    version 49:0\n+{\n+\n+\n+Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+public Method consumeString:\"(Ljava\/lang\/String;)V\"\n+    stack 3 locals 2\n+{\n+        getstatic        Field java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+        new              class java\/lang\/StringBuilder;\n+        dup;\n+        invokespecial    Method java\/lang\/StringBuilder.\"<init>\":\"()V\";\n+        ldc              String \"Hello: \";\n+        invokevirtual    Method java\/lang\/StringBuilder.append:\"(Ljava\/lang\/String;)Ljava\/lang\/StringBuilder;\";\n+        aload_1;\n+        invokevirtual    Method java\/lang\/StringBuilder.append:\"(Ljava\/lang\/String;)Ljava\/lang\/StringBuilder;\";\n+        invokevirtual    Method java\/lang\/StringBuilder.toString:\"()Ljava\/lang\/String;\";\n+        invokevirtual    Method java\/io\/PrintStream.println:\"(Ljava\/lang\/String;)V\";\n+        return;\n+}\n+\n+} \/\/ end Class OldConsumer\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/OldConsumer.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.test.lib.cds.CDSTestUtils;\n@@ -49,1 +50,1 @@\n-        out.shouldNotContain(\"object points to a static field that may be reinitialized at runtime\");\n+        out.shouldNotContain(CDSTestUtils.MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n","filename":"test\/jdk\/jdk\/internal\/misc\/CDS\/ArchivedEnumTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+        output.shouldNotContain(CDSTestUtils.MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+    public static final String MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE =\n+        \"an object points to a static field that may hold a different value at runtime\";\n@@ -287,0 +289,1 @@\n+        output.shouldNotContain(MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n@@ -299,0 +302,1 @@\n+        output.shouldNotContain(MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n@@ -866,4 +870,10 @@\n-        String vmopts = System.getProperty(\"test.vm.opts\");\n-        String javaopts = System.getProperty(\"test.java.opts\");\n-        if (vmopts != null && vmopts.contains(\"-XX:+AOTClassLinking\")) {\n-            return true;\n+        return isBooleanVMOptionEnabledInCommandLine(\"AOTClassLinking\");\n+    }\n+\n+    public static boolean isBooleanVMOptionEnabledInCommandLine(String optionName) {\n+        String lastMatch = null;\n+        String pattern = \"^-XX:.\" + optionName + \"$\";\n+        for (String s : Utils.getTestJavaOpts()) {\n+            if (s.matches(pattern)) {\n+                lastMatch = s;\n+            }\n@@ -871,1 +881,1 @@\n-        if (javaopts != null && javaopts.contains(\"-XX:+AOTClassLinking\")) {\n+        if (lastMatch != null && lastMatch.equals(\"-XX:+\" + optionName)) {\n@@ -874,1 +884,0 @@\n-\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"}]}