{"files":[{"patch":"@@ -748,0 +748,10 @@\n+bool ArchiveBuilder::has_been_buffered(address src_addr) const {\n+  if (RegeneratedClasses::has_been_regenerated(src_addr) ||\n+      _src_obj_table.get(src_addr) == nullptr ||\n+      get_buffered_addr(src_addr) == nullptr) {\n+    return false;\n+  } else {\n+    return true;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -414,0 +414,5 @@\n+  bool has_been_buffered(address src_addr) const;\n+  template <typename T> bool has_been_buffered(T src_addr) const {\n+    return has_been_buffered((address)src_addr);\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -376,0 +376,1 @@\n+    assert(!ArchiveBuilder::current()->has_been_buffered(src_ik), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -466,9 +466,1 @@\n-  if (HeapShared::is_archivable_hidden_klass(ik)) {\n-    \/\/ We can't rerun the <clinit> method of hidden classes as we don't save\n-    \/\/ the classData, so we must archive its mirror in initialized state.\n-    assert(ik->is_initialized(), \"must be\");\n-  }\n-\n-  if (!ik->is_initialized()) {\n-    return;\n-  }\n+  assert(ik->is_initialized(), \"must be\");\n@@ -682,15 +674,7 @@\n-  for (int i = 0; fields[i].valid(); ) {\n-    ArchivableStaticFieldInfo* info = &fields[i];\n-    const char* klass_name = info->klass_name;\n-    for (; fields[i].valid(); i++) {\n-      ArchivableStaticFieldInfo* f = &fields[i];\n-      if (f->klass_name != klass_name) {\n-        break;\n-      }\n-\n-      InstanceKlass* k = f->klass;\n-      oop m = k->java_mirror();\n-      oop o = m->obj_field(f->offset);\n-      if (o != nullptr) {\n-        find_required_hidden_classes_in_object(o);\n-      }\n+  for (int i = 0; fields[i].valid(); i++) {\n+    ArchivableStaticFieldInfo* f = &fields[i];\n+    InstanceKlass* k = f->klass;\n+    oop m = k->java_mirror();\n+    oop o = m->obj_field(f->offset);\n+    if (o != nullptr) {\n+      find_required_hidden_classes_in_object(o);\n@@ -728,0 +712,10 @@\n+static void mark_required_if_hidden_class(Klass* k) {\n+  if (k != nullptr && k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->is_hidden()) {\n+      SystemDictionaryShared::mark_required_hidden_class(ik);\n+    }\n+  }\n+}\n+\n+\n@@ -736,3 +730,6 @@\n-      \/\/ These are all the cases we care about for now:\n-      \/\/ - an object points to a mirror of an hidden class\n-      \/\/ - an object points to a method declared in a hidden class\n+      \/\/ Mark the klass of this object\n+      mark_required_if_hidden_class(o->klass());\n+\n+      \/\/ For special objects, mark the klass that they contain information about.\n+      \/\/ - a Class that refers to an hidden class\n+      \/\/ - a ResolvedMethodName that refers to a method declared in a hidden class\n@@ -740,7 +737,1 @@\n-        Klass* k = java_lang_Class::as_Klass(o);\n-        if (k != nullptr && k->is_instance_klass()) {\n-          InstanceKlass* ik = InstanceKlass::cast(k);\n-          if (ik->is_hidden()) {\n-            SystemDictionaryShared::mark_required_hidden_class(ik);\n-          }\n-        }\n+        mark_required_if_hidden_class(java_lang_Class::as_Klass(o));\n@@ -749,5 +740,2 @@\n-        if (m != nullptr && m->method_holder() != nullptr) {\n-          InstanceKlass* ik = m->method_holder();\n-          if (ik->is_hidden()) {\n-            SystemDictionaryShared::mark_required_hidden_class(ik);\n-          }\n+        if (m != nullptr) {\n+          mark_required_if_hidden_class(m->method_holder());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":27,"deletions":39,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -662,4 +662,0 @@\n-    if (HeapShared::is_archivable_hidden_klass(k)) {\n-      return true;\n-    }\n-\n@@ -776,1 +772,1 @@\n-    if (k->is_hidden() && !info.has_checked_exclusion()) {\n+    if (k->is_hidden()) {\n@@ -778,1 +774,7 @@\n-      guarantee(info.is_excluded(), \"Must be\");\n+      if (CDSConfig::is_dumping_invokedynamic()) {\n+        if (should_hidden_class_be_archived(k)) {\n+          guarantee(!info.is_excluded(), \"Must be\");\n+        } else {\n+          guarantee(info.is_excluded(), \"Must be\");\n+        }\n+      }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-      });\n+    });\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,5 @@\n+    static boolean checkSkipUncompressedOopsTests(String prop) {\n+        String opts = System.getProperty(prop);\n+        return opts.contains(\"+AOTClassLinking\") &&\n+               opts.matches(\".*[+]Use[A-Za-z]+GC.*\") && !opts.contains(\"+UseG1GC\");\n+    }\n@@ -78,1 +83,0 @@\n-        String opts = System.getProperty(\"test.vm.opts\");\n@@ -80,2 +84,2 @@\n-            opts.contains(\"+AOTClassLinking\") &&\n-            opts.matches(\".*[+]Use[A-Za-z]+GC.*\") && !opts.contains(\"+UseG1GC\");\n+            checkSkipUncompressedOopsTests(\"test.vm.opts\") ||\n+            checkSkipUncompressedOopsTests(\"test.java.opts\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/SharedBaseAddress.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}