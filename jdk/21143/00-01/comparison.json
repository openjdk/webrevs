{"files":[{"patch":"@@ -233,2 +233,3 @@\n-      if (klass->is_hidden() && klass->is_instance_klass()) {\n-        update_hidden_class_loader_type(InstanceKlass::cast(klass));\n+      if (klass->is_hidden()) {\n+        assert(klass->is_instance_klass(), \"must be\");\n+        assert(SystemDictionaryShared::should_hidden_class_be_archived(InstanceKlass::cast(klass)), \"must be\");\n@@ -296,41 +297,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-\n-void ArchiveBuilder::update_hidden_class_loader_type(InstanceKlass* ik) {\n-  assert(ik->is_hidden(), \"must be\");\n-\n-  s2 classloader_type;\n-  if (HeapShared::is_lambda_form_klass(ik)) {\n-    assert(CDSConfig::is_dumping_invokedynamic(), \"lambda form classes are archived only if CDSConfig::is_dumping_invokedynamic() is true\");\n-    classloader_type = ClassLoader::BOOT_LOADER;\n-  } else {\n-    assert(SystemDictionaryShared::should_hidden_class_be_archived(ik), \"must be\");\n-    oop loader = ik->class_loader();\n-\n-    if (loader == nullptr) {\n-      classloader_type = ClassLoader::BOOT_LOADER;\n-    } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-      classloader_type = ClassLoader::PLATFORM_LOADER;\n-    } else {\n-      assert(SystemDictionary::is_system_class_loader(loader), \"must be\");\n-      classloader_type = ClassLoader::APP_LOADER;\n-    }\n-  }\n-  ik->set_shared_class_loader_type(classloader_type);\n-\n-  if (HeapShared::is_lambda_proxy_klass(ik)) {\n-    InstanceKlass* nest_host = ik->nest_host_not_null();\n-    ik->set_shared_classpath_index(nest_host->shared_classpath_index());\n-  } else if (HeapShared::is_lambda_form_klass(ik)) {\n-    ik->set_shared_classpath_index(0);\n-  } else {\n-    \/\/ Generated invoker classes.\n-    if (classloader_type == ClassLoader::APP_LOADER) {\n-      ik->set_shared_classpath_index(ClassLoaderExt::app_class_paths_start_index());\n-    } else {\n-      ik->set_shared_classpath_index(0);\n-    }\n-  }\n-}\n-\n-#endif \/\/INCLUDE_CDS_JAVA_HEAP\n-\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -261,1 +261,0 @@\n-  void update_hidden_class_loader_type(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-\/\/     final Foo archivedFoo; \/\/ this field is archived by CDS\n+\/\/     static final Foo archivedFoo; \/\/ this field is archived by CDS\n@@ -274,4 +274,0 @@\n-    if (strstr(class_name, \"java\/lang\/invoke\/BoundMethodHandle$Species_\") == class_name &&\n-        strcmp(field_name, \"BMH_SPECIES\") == 0) {\n-      return true;\n-    }\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -892,4 +892,0 @@\n-  if (CDSConfig::is_dumping_invokedynamic()) {\n-    \/\/ We allow LambdaProxy classes in platform and app loaders as well.\n-    return;\n-  }\n@@ -901,0 +897,11 @@\n+  const char* lambda_msg = \"\";\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    lambda_msg = \", or a lambda proxy class\";\n+    if (HeapShared::is_lambda_proxy_klass(ik) &&\n+        (ik->class_loader() == nullptr ||\n+         ik->class_loader() == SystemDictionary::java_platform_loader() ||\n+         ik->class_loader() == SystemDictionary::java_system_loader())) {\n+      return;\n+    }\n+  }\n+\n@@ -902,1 +909,1 @@\n-  if (!ik->module()->is_named() && ik->package() == nullptr) {\n+  if (!ik->module()->is_named() && ik->package() == nullptr && ArchiveHeapTestClass != nullptr) {\n@@ -906,1 +913,1 @@\n-  const char* extra_msg = \", or in an unnamed package of an unnamed module\";\n+  const char* testcls_msg = \", or a test class in an unnamed package of an unnamed module\";\n@@ -908,1 +915,1 @@\n-  const char* extra_msg = \"\";\n+  const char* testcls_msg = \"\";\n@@ -912,2 +919,2 @@\n-  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s\",\n-                       ik->external_name(), extra_msg);\n+  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s%s\",\n+                       ik->external_name(), lambda_msg, testcls_msg);\n@@ -1975,2 +1982,2 @@\n-        \/\/ See KlassSubGraphInfo::check_allowed_klass() - only two types of\n-        \/\/ classes are allowed:\n+        \/\/ See KlassSubGraphInfo::check_allowed_klass() - we only allow test classes\n+        \/\/ to be:\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -1239,1 +1240,1 @@\n-    \/\/ We do not archive hidden classes.\n+    record_hidden_class(ik);\n@@ -1341,0 +1342,38 @@\n+\n+void ClassLoader::record_hidden_class(InstanceKlass* ik) {\n+  assert(ik->is_hidden(), \"must be\");\n+\n+  s2 classloader_type;\n+  if (HeapShared::is_lambda_form_klass(ik)) {\n+    classloader_type = ClassLoader::BOOT_LOADER;\n+  } else {\n+    oop loader = ik->class_loader();\n+\n+    if (loader == nullptr) {\n+      classloader_type = ClassLoader::BOOT_LOADER;\n+    } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+      classloader_type = ClassLoader::PLATFORM_LOADER;\n+    } else if (SystemDictionary::is_system_class_loader(loader)) {\n+      classloader_type = ClassLoader::APP_LOADER;\n+    } else {\n+      \/\/ This class won't be archived, so no need to update its\n+      \/\/ classloader_type\/classpath_index.\n+      return;\n+    }\n+  }\n+  ik->set_shared_class_loader_type(classloader_type);\n+\n+  if (HeapShared::is_lambda_proxy_klass(ik)) {\n+    InstanceKlass* nest_host = ik->nest_host_not_null();\n+    ik->set_shared_classpath_index(nest_host->shared_classpath_index());\n+  } else if (HeapShared::is_lambda_form_klass(ik)) {\n+    ik->set_shared_classpath_index(0);\n+  } else {\n+    \/\/ Generated invoker classes.\n+    if (classloader_type == ClassLoader::APP_LOADER) {\n+      ik->set_shared_classpath_index(ClassLoaderExt::app_class_paths_start_index());\n+    } else {\n+      ik->set_shared_classpath_index(0);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -389,0 +389,1 @@\n+  static void record_hidden_class(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2921,1 +2921,1 @@\n-  if (CDSConfig::is_dumping_static_archive()) {\n+  if (CDSConfig::allow_only_single_java_thread()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -881,1 +881,1 @@\n-        if (lastMatch != null && lastMatch.equals(\"-XX:+\" +  optionName)) {\n+        if (lastMatch != null && lastMatch.equals(\"-XX:+\" + optionName)) {\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}