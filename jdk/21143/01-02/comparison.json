{"files":[{"patch":"@@ -107,1 +107,1 @@\n-  \/\/ Diagnosing problems with AOT-initialized classes\n+  \/\/ About \"static field that may hold a different value\" errors:\n@@ -109,3 +109,2 @@\n-  \/\/ If you suspect that a bug is related to AOT-initialized classes:\n-  \/\/    - test program passes with -XX:AOTMode=off\n-  \/\/    - test program fails with -XX:AOTMode=auto\n+  \/\/ Automatic selection for aot-inited classes\n+  \/\/ ==========================================\n@@ -113,2 +112,6 @@\n-  \/\/ The problem may occur after you've made some changes in the JDK\n-  \/\/ core libraries (most likely java.lang.invoke).\n+  \/\/ When CDSConfig::is_initing_classes_at_dump_time() is enabled,\n+  \/\/ HeapShared::find_all_aot_initialized_classes() finds the classes of all\n+  \/\/ heap objects that are reachable from HeapShared::_run_time_special_subgraph,\n+  \/\/ and mark these classes as aot-inited. This preserves the initialized\n+  \/\/ mirrors of these classes, and their <clinit> methods are NOT executed\n+  \/\/ at runtime.\n@@ -116,2 +119,3 @@\n-  \/\/ [1] Create the AOT cache and look for warnings like this (generated by cdsHeapVerifier.cpp):\n-  \/\/     [warning][cds,heap] Archive heap points to a static field that may be reinitialized at runtime\n+  \/\/ For example, with -XX:+AOTInvokeDynamicLinking, _run_time_special_subgraph\n+  \/\/ will contain some DirectMethodHandle objects. As a result, the DirectMethodHandle\n+  \/\/ class is automatically marked as aot-inited.\n@@ -119,6 +123,55 @@\n-  \/\/ [2] Check the AllowedSpec tables below:\n-  \/\/     - Did you add a new static field to a class that could be referenced by cached object\n-  \/\/       instances of MethodType, MethodHandle, etc? You may need to add that class to the tables.\n-  \/\/     - Did you modify the <clinit> of the classes listed below such that a static field\n-  \/\/       now points to an object that should not be cached (e.g., the object points to a native\n-  \/\/       resource such as a file descriptior, or a Thread)?\n+  \/\/ Manual selection\n+  \/\/ ================\n+  \/\/\n+  \/\/ However, there are cases that cannot be automatically discovered. For\n+  \/\/ example, DirectMethodHandle::IMPL_NAMES points to MethodHandles::IMPL_NAMES,\n+  \/\/ but the MethodHandles class is not automatically marked because there are\n+  \/\/ no archived instances of the MethodHandles type.\n+  \/\/\n+  \/\/ If we aot-initialize DirectMethodHandle, but allow MethodHandles to be\n+  \/\/ initialized at runtime, MethodHandles::IMPL_NAMES will get a different\n+  \/\/ value than DirectMethodHandle::IMPL_NAMES. This *may or may not* be a problem,\n+  \/\/ but to ensure compatibility, we should try to preserve the identity equality\n+  \/\/ of these two fields.\n+  \/\/\n+  \/\/ To do that, we add MethodHandles to the indy_specs[] table below.\n+  \/\/\n+  \/\/ Automatic validation\n+  \/\/ ====================\n+  \/\/\n+  \/\/ CDSHeapVerifier is used to detect potential problems with identity equality.\n+  \/\/ To see how it detects the problem with MethodHandles::IMPL_NAMES:\n+  \/\/\n+  \/\/ - Comment out all the lines in indy_specs[] except the {nullptr} line.\n+  \/\/ - Rebuild the JDK\n+  \/\/\n+  \/\/ Then run the following:\n+  \/\/    java -XX:AOTMode=record -XX:AOTConfiguration=jc.aotconfig com.sun.tools.javac.Main\n+  \/\/    java -XX:AOTMode=create -Xlog:cds -XX:AOTCache=jc.aot -XX:AOTConfiguration=jc.aotconfig\n+  \/\/\n+  \/\/ You will see an error like this:\n+  \/\/\n+  \/\/ Archive heap points to a static field that may hold a different value at runtime:\n+  \/\/ Field: java\/lang\/invoke\/MethodHandles::IMPL_NAMES\n+  \/\/ Value: java.lang.invoke.MemberName$Factory\n+  \/\/ {0x000000060e906ae8} - klass: 'java\/lang\/invoke\/MemberName$Factory' - flags:\n+  \/\/\n+  \/\/  - ---- fields (total size 2 words):\n+  \/\/ --- trace begin ---\n+  \/\/ [ 0] {0x000000060e8deeb0} java.lang.Class (java.lang.invoke.DirectMethodHandle::IMPL_NAMES)\n+  \/\/ [ 1] {0x000000060e906ae8} java.lang.invoke.MemberName$Factory\n+  \/\/ --- trace end ---\n+  \/\/\n+  \/\/ Trouble-shooting\n+  \/\/ ================\n+  \/\/\n+  \/\/ If you see a \"static field that may hold a different value\" error, it's probably\n+  \/\/ because you've made some changes in the JDK core libraries (most likely\n+  \/\/ java.lang.invoke).\n+  \/\/\n+  \/\/  - Did you add a new static field to a class that could be referenced by\n+  \/\/    cached object instances of MethodType, MethodHandle, etc? You may need\n+  \/\/    to add that class to indy_specs[].\n+  \/\/  - Did you modify the <clinit> of the classes in java.lang.invoke such that\n+  \/\/    a static field now points to an object that should not be cached (e.g.,\n+  \/\/    a native resource such as a file descriptior, or a Thread)?\n@@ -139,25 +192,0 @@\n-  {\n-    \/\/ These classes are special cases needed to support the aot-caching of\n-    \/\/ java.lang.invoke.MethodType instances:\n-    \/\/ - MethodType points to sun.invoke.util.Wrapper enums\n-    \/\/ - The Wrapper enums point to static final fields in these classes.\n-    \/\/   E.g., ConstantDescs.CD_Boolean.\n-    \/\/ - If we re-run the <clinit> of these classes again during the production\n-    \/\/   run, ConstantDescs.CD_Boolean will get a new value that has a different\n-    \/\/   object identity than the value referenced by the the Wrapper enums.\n-    \/\/ - However, Wrapper requires object identity (it allows the use of == to\n-    \/\/   test the equality of ClassDesc, etc).\n-    \/\/ Therefore, we must preserve the static fields of these classes from\n-    \/\/ the assembly phase.\n-    static AllowedSpec specs[] = {\n-      {\"java\/lang\/constant\/DynamicConstantDesc\"},\n-      {\"jdk\/internal\/constant\/PrimitiveClassDescImpl\"},\n-      {\"jdk\/internal\/constant\/ReferenceClassDescImpl\"},\n-      {\"java\/lang\/constant\/ConstantDescs\"},\n-      {nullptr}\n-    };\n-    if (is_allowed(specs, ik)) {\n-      return true;\n-    }\n-  }\n-\n@@ -165,17 +193,7 @@\n-    static AllowedSpec specs[] = {\n-      \/\/ Java heap objects (MethodTypes, MethodHandle, etc) that are associated with resolved indy\n-      \/\/ call sites may have references to static final fields in the following classes.\n-      \/\/\n-      \/\/ For example, a BoundMethodHandle could reference SimpleMethodHandle::BMH_SPECIES.\n-      \/\/\n-      \/\/ Try doing this:\n-      \/\/    - Comment out all the lines in specs[] except the {nullptr} line.\n-      \/\/    - Rebuild the JDK\n-      \/\/\n-      \/\/ The run the following:\n-      \/\/    java -XX:AOTMode=record -XX:AOTConfiguration=jc.aotconfig com.sun.tools.javac.Main\n-      \/\/    java -XX:AOTMode=create -Xlog:cds -XX:AOTCache=jc.aot -XX:AOTConfiguration=jc.aotconfig\n-      \/\/\n-      \/\/ You will see a warning like this:\n-      \/\/    [warning][cds,heap] Archive heap points to a static field that may be reinitialized at runtime:\n-      \/\/    [warning][cds,heap] Field: java\/lang\/invoke\/SimpleMethodHandle::BMH_SPECIES\n+    \/\/ This table was created with the help of CDSHeapVerifier.\n+    \/\/ Also, some $Holder classes are needed. E.g., Invokers.<clinit> explicitly\n+    \/\/ initializes Invokers$Holder. Since Invokers.<clinit> won't be executed\n+    \/\/ at runtime, we need to make sure Invokers$Holder is also aot-inited.\n+    static AllowedSpec indy_specs[] = {\n+      {\"java\/lang\/constant\/ConstantDescs\"},\n+      {\"java\/lang\/constant\/DynamicConstantDesc\"},\n@@ -188,0 +206,1 @@\n+      {\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\"},     \/\/ UNSAFE.ensureClassInitialized()\n@@ -189,1 +208,4 @@\n-      {\"java\/lang\/invoke\/DirectMethodHandle$Holder\"},\n+      {\"java\/lang\/invoke\/DirectMethodHandle$Constructor\"},\n+      {\"java\/lang\/invoke\/DirectMethodHandle$Holder\"},         \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/Invokers\"},\n+      {\"java\/lang\/invoke\/Invokers$Holder\"},                   \/\/ UNSAFE.ensureClassInitialized()\n@@ -191,0 +213,1 @@\n+      {\"java\/lang\/invoke\/LambdaForm$Holder\"},                 \/\/ UNSAFE.ensureClassInitialized()\n@@ -193,1 +216,1 @@\n-      {\"java\/lang\/invoke\/MethodType$AOTHolder\"},\n+      {\"java\/lang\/invoke\/MethodHandles\"},\n@@ -195,0 +218,9 @@\n+      {\"java\/util\/Collections\"},\n+      {\"java\/util\/stream\/Collectors\"},\n+      {\"jdk\/internal\/constant\/PrimitiveClassDescImpl\"},\n+      {\"jdk\/internal\/constant\/ReferenceClassDescImpl\"},\n+\n+    \/\/ Can't include this, as it will pull in MethodHandleStatics which has many environment\n+    \/\/ dependencies (on system properties, etc).\n+    \/\/{\"java\/lang\/invoke\/InvokerBytecodeGenerator\"},\n+\n@@ -197,1 +229,1 @@\n-    if (is_allowed(specs, ik)) {\n+    if (is_allowed(indy_specs, ik)) {\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":91,"deletions":59,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -374,0 +374,7 @@\n+bool ArchiveUtils::has_aot_initialized_mirror(InstanceKlass* src_ik) {\n+  if (SystemDictionaryShared::is_excluded_class(src_ik)) {\n+    return false;\n+  }\n+  return ArchiveBuilder::current()->get_buffered_addr(src_ik)->has_aot_initialized_mirror();\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -254,1 +254,1 @@\n-\n+  static bool has_aot_initialized_mirror(InstanceKlass* src_ik);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -44,1 +45,1 @@\n-\/\/ static field that may be reinitialized at runtime. In the following example,\n+\/\/ static field that may be get a different value at runtime. In the following example,\n@@ -46,1 +47,2 @@\n-\/\/ correctly returns true when CDS disabled, but incorrectly returns false when CDS is enabled.\n+\/\/ correctly returns true when CDS disabled, but incorrectly returns false when CDS is enabled,\n+\/\/ because the archived archivedFoo.bar value is different than Bar.bar.\n@@ -130,2 +132,0 @@\n-    ADD_EXCL(\"java\/lang\/invoke\/MethodHandles\",            \"IMPL_NAMES\");           \/\/ D\n-    ADD_EXCL(\"java\/lang\/invoke\/MemberName$Factory\",       \"INSTANCE\");             \/\/ D\n@@ -143,3 +143,4 @@\n-    log_warning(cds, heap)(\"Scanned %d objects. Found %d case(s) where \"\n-                           \"an object points to a static field that may be \"\n-                           \"reinitialized at runtime.\", _archived_objs, _problems);\n+    log_error(cds, heap)(\"Scanned %d objects. Found %d case(s) where \"\n+                         \"an object points to a static field that \"\n+                         \"may hold a different value at runtime.\", _archived_objs, _problems);\n+    MetaspaceShared::unrecoverable_writing_error();\n@@ -190,1 +191,1 @@\n-          if (field_ik->has_archived_enum_objs() || AOTClassInitializer::can_archive_initialized_mirror(field_ik)) {\n+          if (field_ik->has_archived_enum_objs() || ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n@@ -197,4 +198,3 @@\n-        if (field_ik->is_hidden() && AOTClassInitializer::can_archive_initialized_mirror(field_ik)) {\n-          \/\/ We have a static field in a core-library class that points to a method reference\n-          \/\/ E.g., SharedSecrets::javaSecuritySpecAccess => EncodedKeySpec::clear(). These are safe\n-          \/\/ to archive.\n+        if (field_ik->is_hidden() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          \/\/ We have a static field in a core-library class that points to a method reference, which\n+          \/\/ are safe to archive.\n@@ -204,1 +204,0 @@\n-      }\n@@ -206,2 +205,11 @@\n-      if (AOTClassInitializer::can_archive_initialized_mirror(_ik)) {\n-        return;\n+        if (field_ik == vmClasses::MethodType_klass()) {\n+          \/\/ The identity of MethodTypes are preserved between assembly phase and production runs\n+          \/\/ (by MethodType::AOTHolder::archivedMethodTypes). No need to check.\n+          return;\n+        }\n+\n+        if (field_ik == vmClasses::internal_Unsafe_klass() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          \/\/ There's only a single instance of jdk\/internal\/misc\/Unsafe, so all references will\n+          \/\/ be pointing to this singleton, which has been archived.\n+          return;\n+        }\n@@ -218,1 +226,2 @@\n-\/\/ loaded.\n+\/\/ loaded. Later, we will check if any archived objects reference one of\n+\/\/ these fields.\n@@ -230,2 +239,3 @@\n-    if (HeapShared::is_lambda_form_klass(ik)) {\n-      \/\/ Archived lambda forms have preinitialized mirrors, so <clinit> won't run.\n+    if (ArchiveUtils::has_aot_initialized_mirror(ik)) {\n+      \/\/ ik's <clinit> won't be executed at runtime, the static fields in\n+      \/\/ ik will carry their values to runtime.\n@@ -241,12 +251,0 @@\n-  if (field->klass() == vmClasses::MethodType_klass()) {\n-    \/\/ The identity of MethodTypes are preserved between assembly phase and production runs\n-    \/\/ (by MethodType::AOTHolder::archivedMethodTypes). No need to check.\n-    return;\n-  }\n-  if (field->klass() == vmClasses::LambdaForm_klass()) {\n-    \/\/ LambdaForms are non-modifiable and are not tested for object equality, so\n-    \/\/ it's OK if static fields of the LambdaForm type are reinitialized at runtime with\n-    \/\/ alternative instances. No need to check.\n-    return;\n-  }\n-\n@@ -275,1 +273,1 @@\n-    ls.print_cr(\"Archive heap points to a static field that may be reinitialized at runtime:\");\n+    ls.print_cr(\"Archive heap points to a static field that may hold a different value at runtime:\");\n@@ -318,0 +316,23 @@\n+const char* static_field_name(oop mirror, oop field) {\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  if (k->is_instance_klass()) {\n+    for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        switch (fd.field_type()) {\n+        case T_OBJECT:\n+        case T_ARRAY:\n+          if (mirror->obj_field(fd.offset()) == field) {\n+            return fs.name()->as_C_string();\n+          }\n+          break;\n+        default:\n+          break;\n+        }\n+      }\n+    }\n+  }\n+\n+  return \"<unknown>\";\n+}\n+\n@@ -333,1 +354,1 @@\n-    st->print(\" (%s)\", java_lang_Class::as_Klass(orig_obj)->external_name());\n+    st->print(\" (%s::%s)\", java_lang_Class::as_Klass(orig_obj)->external_name(), static_field_name(orig_obj, orig_field));\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":53,"deletions":32,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -438,3 +438,1 @@\n-  if (!orig_k->is_instance_klass()) {\n-    return;\n-  }\n+  assert(orig_k->is_instance_klass(), \"sanity\");\n@@ -442,0 +440,1 @@\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n@@ -449,1 +448,1 @@\n-  if (!ik->is_initialized() || !AOTClassInitializer::can_archive_initialized_mirror(ik)) {\n+  if (!ik->is_initialized()) {\n@@ -505,3 +504,0 @@\n-\n-  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n-  buffered_ik->set_has_aot_initialized_mirror();\n@@ -519,0 +515,13 @@\n+static objArrayOop get_archived_resolved_references(InstanceKlass* src_ik) {\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n+  if (buffered_ik->is_shared_boot_class() ||\n+      buffered_ik->is_shared_platform_class() ||\n+      buffered_ik->is_shared_app_class()) {\n+    objArrayOop rr = src_ik->constants()->resolved_references_or_null();\n+    if (rr != nullptr && !ArchiveHeapWriter::is_too_large_to_archive(rr)) {\n+      return HeapShared::scratch_resolved_references(src_ik->constants());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -547,1 +556,0 @@\n-      copy_aot_initialized_mirror(orig_k, orig_mirror, m);\n@@ -568,2 +576,2 @@\n-        oop rr = ik->constants()->prepare_resolved_references_for_archiving();\n-        if (rr != nullptr && !ArchiveHeapWriter::is_too_large_to_archive(rr)) {\n+        objArrayOop rr = get_archived_resolved_references(InstanceKlass::cast(orig_k));\n+        if (rr != nullptr) {\n@@ -762,0 +770,1 @@\n+\n@@ -763,3 +772,5 @@\n-  archive_java_mirrors();\n-  archive_strings();\n-  Universe::archive_exception_instances();\n+  {\n+    archive_java_mirrors();\n+    archive_strings();\n+    Universe::archive_exception_instances();\n+  }\n@@ -769,0 +780,11 @@\n+void HeapShared::prepare_resolved_references() {\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* src_k = klasses->at(i);\n+    if (src_k->is_instance_klass()) {\n+      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_k));\n+      buffered_ik->constants()->prepare_resolved_references_for_archiving();\n+    }\n+  }\n+}\n+\n@@ -772,0 +794,2 @@\n+  prepare_resolved_references();\n+  find_all_aot_initialized_classes();\n@@ -784,0 +808,143 @@\n+\/\/ Closure used by HeapShared::scan_for_aot_initialized_classes() to look for all objects\n+\/\/ that are reachable from a given root.\n+class HeapShared::AOTInitializedClassScanner : public BasicOopIterateClosure {\n+  bool _made_progress;\n+\n+  template <class T> void check(T *p) {\n+    oop obj = HeapAccess<>::oop_load(p);\n+    if (!java_lang_Class::is_instance(obj)) {\n+      \/\/ Don't scan the mirrors, as we may see an orig_mirror while scanning\n+      \/\/ the object graph, .... TODO more info\n+      _made_progress |= HeapShared::scan_for_aot_initialized_classes(obj);\n+    }\n+  }\n+\n+public:\n+  AOTInitializedClassScanner() : _made_progress(false) {}\n+  void do_oop(narrowOop *p) { check(p); }\n+  void do_oop(      oop *p) { check(p); }\n+  bool made_progress() { return _made_progress; }\n+};\n+\n+static bool mark_for_aot_initialization(InstanceKlass* buffered_ik) {\n+  if (buffered_ik->name()->equals(\"java\/lang\/String\")) {\n+    return false;\n+  }\n+\n+  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_ik), \"sanity\");\n+\n+  bool made_progress = false;\n+  if (buffered_ik->is_initialized() && !buffered_ik->has_aot_initialized_mirror()) {\n+    if (log_is_enabled(Info, cds, init)) {\n+      ResourceMark rm;\n+      log_info(cds, init)(\"Mark class for aot-init: %s\", buffered_ik->external_name());\n+    }\n+\n+    buffered_ik->set_has_aot_initialized_mirror();\n+    made_progress = true;\n+\n+    InstanceKlass* super = buffered_ik->java_super();\n+    if (super != nullptr) {\n+      mark_for_aot_initialization(super);\n+    }\n+\n+    Array<InstanceKlass*>* interfaces = buffered_ik->local_interfaces();\n+    for (int i = 0; i < interfaces->length(); i++) {\n+      mark_for_aot_initialization(interfaces->at(i));\n+    }\n+  }\n+\n+  return made_progress;\n+}\n+\n+void HeapShared::find_all_aot_initialized_classes() {\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    return;\n+  }\n+\n+  init_seen_objects_table();\n+  find_all_aot_initialized_classes_helper();\n+  delete_seen_objects_table();\n+}\n+\n+\/\/ Recursively find all class that should be aot-initialized:\n+\/\/ - the class has at least one instance that can be reachable from the special subgraph; or\n+\/\/ - the class is hard-coded in AOTClassInitializer::can_archive_initialized_mirror()\n+void HeapShared::find_all_aot_initialized_classes_helper() {\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  assert(klasses != nullptr, \"sanity\");\n+\n+  \/\/ First scan all resolved constant pools references.\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* src_k = klasses->at(i);\n+    if (src_k->is_instance_klass()) {\n+      InstanceKlass* src_ik = InstanceKlass::cast(src_k);\n+      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n+      objArrayOop rr = get_archived_resolved_references(src_ik);\n+      if (rr != nullptr) {\n+        objArrayOop scratch_rr = scratch_resolved_references(src_ik->constants());\n+        for (int i = 0; i < scratch_rr->length(); i++) {\n+          scan_for_aot_initialized_classes(scratch_rr->obj_at(i));\n+        }\n+      }\n+\n+      \/\/ If a class is hard-coded to be aot-initialize, mark it as such.\n+      if (AOTClassInitializer::can_archive_initialized_mirror(src_ik)) {\n+        mark_for_aot_initialization(buffered_ik);\n+      }\n+    }\n+  }\n+\n+  \/\/ These objects also belong to the special subgraph\n+  scan_for_aot_initialized_classes(Universe::null_ptr_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::arithmetic_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::internal_error_instance());\n+  scan_for_aot_initialized_classes(Universe::array_index_out_of_bounds_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::array_store_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::class_cast_exception_instance());\n+\n+  bool made_progress;\n+  do {\n+    \/\/ In each pass, we copy the scratch mirrors of the classes that were marked\n+    \/\/ as aot-init in the previous pass. We then scan these mirrors, which may\n+    \/\/ mark more classes. Keep iterating until no more progress can be made.\n+    made_progress = false;\n+    for (int i = 0; i < klasses->length(); i++) {\n+      Klass* orig_k = klasses->at(i);\n+      if (orig_k->is_instance_klass()) {\n+        InstanceKlass* orig_ik = InstanceKlass::cast(orig_k);\n+        if (ArchiveBuilder::current()->get_buffered_addr(orig_ik)->has_aot_initialized_mirror()) {\n+          oop orig_mirror = orig_ik->java_mirror();\n+          oop scratch_mirror = scratch_java_mirror(orig_k);\n+          if (!has_been_seen_during_subgraph_recording(scratch_mirror)) {\n+            \/\/ Scan scratch_mirror instead of orig_mirror (which has fields like ClassLoader that\n+            \/\/ are not archived).\n+            copy_aot_initialized_mirror(orig_k, orig_mirror, scratch_mirror);\n+            made_progress |= scan_for_aot_initialized_classes(scratch_mirror);\n+          }\n+        }\n+      }\n+    }\n+  } while (made_progress);\n+}\n+\n+bool HeapShared::scan_for_aot_initialized_classes(oop obj) {\n+  if (obj == nullptr || has_been_seen_during_subgraph_recording(obj)) {\n+    return false;\n+  }\n+  set_has_been_seen_during_subgraph_recording(obj);\n+\n+  bool made_progress = false;\n+  Klass* k = obj->klass();\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* orig_ik = InstanceKlass::cast(k);\n+    InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(orig_ik);\n+    made_progress = mark_for_aot_initialization(buffered_ik);\n+  }\n+\n+  AOTInitializedClassScanner scanner;\n+  obj->oop_iterate(&scanner);\n+  made_progress |= scanner.made_progress();\n+  return made_progress;\n+}\n+\n@@ -858,1 +1025,2 @@\n-    if (AOTClassInitializer::can_archive_initialized_mirror(InstanceKlass::cast(orig_k))) {\n+    if (buffered_k->has_aot_initialized_mirror()) {\n+      \/\/ No need to add to the runtime-init list.\n@@ -1377,1 +1545,5 @@\n-      m->obj_field_put(field_offset, v);\n+      if (k->has_aot_initialized_mirror()) {\n+        assert(v == m->obj_field(field_offset), \"must be aot-initialized\");\n+      } else {\n+        m->obj_field_put(field_offset, v);\n+      }\n@@ -1385,2 +1557,3 @@\n-      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s\",\n-                          k->external_name(), p2i(k), JvmtiExport::is_early_phase() ? \" (early)\" : \"\");\n+      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s%s\",\n+                          k->external_name(), p2i(k), JvmtiExport::is_early_phase() ? \" (early)\" : \"\",\n+                          k->has_aot_initialized_mirror() ? \" (aot-inited)\" : \"\");\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":190,"deletions":17,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -366,0 +366,1 @@\n+  static void prepare_resolved_references();\n@@ -369,0 +370,6 @@\n+\n+  class AOTInitializedClassScanner;\n+  static void find_all_aot_initialized_classes();\n+  static void find_all_aot_initialized_classes_helper();\n+  static bool scan_for_aot_initialized_classes(oop obj);\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -854,0 +854,8 @@\n+\n+      \/\/ java.lang.Class::reflectionFactory cannot be archived yet. We set this field\n+      \/\/ to null, and it will be initialized again at runtime.\n+      log_debug(cds)(\"Resetting Class::reflectionFactory\");\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"resetArchivedStates\");\n+      Symbol* method_sig = vmSymbols::void_method_signature();\n+      JavaCalls::call_static(&result, vmClasses::Class_klass(),\n+                             method_name, method_sig, CHECK);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -2654,3 +2655,11 @@\n-      \/\/ If no caller class, or caller class has a different loader, then\n-      \/\/ issue a warning below.\n-      do_warning = (caller == nullptr) || caller->class_loader() != cl;\n+      if (CDSConfig::is_loading_invokedynamic() &&\n+          (k == vmClasses::Class_klass() || k == vmClasses::internal_Unsafe_klass())) {\n+        \/\/ With archived indys, these two classes are aot-inited, but we need to\n+        \/\/ call their registerNative() methods directly from C++ code, so caller\n+        \/\/ will be null.\n+        assert(k->has_aot_initialized_mirror(), \"sanity\");\n+        assert(caller == nullptr, \"sanity\");\n+        assert(cl == nullptr, \"sanity\");\n+      } else {\n+        do_warning = (caller == nullptr) || caller->class_loader() != cl;\n+      }\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -337,0 +338,8 @@\n+static void call_register_natives_for_aot_inited_class(InstanceKlass* ik, TRAPS) {\n+  assert(ik->has_aot_initialized_mirror(), \"sanity\");\n+  JavaValue result(T_VOID);\n+  TempNewSymbol method_name = SymbolTable::new_symbol(\"registerNatives\");\n+  JavaCalls::call_static(&result, ik, method_name,\n+                         vmSymbols::void_method_signature(), CHECK);\n+}\n+\n@@ -349,0 +358,8 @@\n+\n+  if (CDSConfig::is_loading_invokedynamic()) {\n+    \/\/ The <clinit> of these two classes won't be executed, but we still need to register\n+    \/\/ their natives.\n+    call_register_natives_for_aot_inited_class(vmClasses::Class_klass(), CHECK);\n+    call_register_natives_for_aot_inited_class(vmClasses::internal_Unsafe_klass(), CHECK);\n+  }\n+\n@@ -404,0 +421,1 @@\n+  initialize_class(vmSymbols::java_lang_InternalError(), CHECK);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4057,0 +4057,9 @@\n+    \/**\n+     * When CDS is enabled, the Class class may be aot-initialized. However,\n+     * we can't archive reflectionFactory, so we reset it to null, so it\n+     * will be allocated again at runtime.\n+     *\/\n+    private static void resetArchivedStates() {\n+        reflectionFactory = null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -403,2 +403,2 @@\n-        if (AOTHolder.archivedMethodTypes != null) {\n-            MethodType mt = AOTHolder.archivedMethodTypes.get(primordialMT);\n+        if (archivedMethodTypes != null) {\n+            MethodType mt = archivedMethodTypes.get(primordialMT);\n@@ -429,7 +429,2 @@\n-    \/\/ AOT cache support - the identity of MethodTypes are important (their object equality are\n-    \/\/ check with the == operator). We need to preserve the identity of all MethodTypes that\n-    \/\/ we have created during the AOT cache assembly phase.\n-    static class AOTHolder {\n-        private static final @Stable MethodType[] objectOnlyTypes = new MethodType[20];\n-        private static @Stable HashMap<MethodType,MethodType> archivedMethodTypes;\n-    }\n+    private static final @Stable MethodType[] objectOnlyTypes = new MethodType[20];\n+    private static @Stable HashMap<MethodType,MethodType> archivedMethodTypes;\n@@ -453,2 +448,2 @@\n-        if (ootIndex < AOTHolder.objectOnlyTypes.length) {\n-            mt = AOTHolder.objectOnlyTypes[ootIndex];\n+        if (ootIndex < objectOnlyTypes.length) {\n+            mt = objectOnlyTypes[ootIndex];\n@@ -461,2 +456,2 @@\n-        if (ootIndex < AOTHolder.objectOnlyTypes.length) {\n-            AOTHolder.objectOnlyTypes[ootIndex] = mt;     \/\/ cache it here also!\n+        if (ootIndex < objectOnlyTypes.length) {\n+            objectOnlyTypes[ootIndex] = mt;     \/\/ cache it here also!\n@@ -1431,1 +1426,2 @@\n-        AOTHolder.archivedMethodTypes = copyInternTable();\n+        archivedMethodTypes = copyInternTable();\n+        internTable.clear();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.test.lib.cds.CDSTestUtils;\n@@ -49,1 +50,1 @@\n-        out.shouldNotContain(\"object points to a static field that may be reinitialized at runtime\");\n+        out.shouldNotContain(CDSTestUtils.MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n","filename":"test\/jdk\/jdk\/internal\/misc\/CDS\/ArchivedEnumTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-        output.shouldNotContain(CDSTestUtils.MSG_STATIC_FIELD_MAY_BE_REINITIALIZED);\n+        output.shouldNotContain(CDSTestUtils.MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-    public static final String MSG_STATIC_FIELD_MAY_BE_REINITIALIZED =\n-        \"an object points to a static field that may be reinitialized at runtime\";\n+    public static final String MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE =\n+        \"an object points to a static field that may hold a different value at runtime\";\n@@ -289,1 +289,1 @@\n-        output.shouldNotContain(MSG_STATIC_FIELD_MAY_BE_REINITIALIZED);\n+        output.shouldNotContain(MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n@@ -302,1 +302,1 @@\n-        output.shouldNotContain(MSG_STATIC_FIELD_MAY_BE_REINITIALIZED);\n+        output.shouldNotContain(MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}