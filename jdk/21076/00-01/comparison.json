{"files":[{"patch":"@@ -96,1 +96,1 @@\n-  const static size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n+  static const size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zAddress_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    lightweight_lock(Roop, Rmark, Rscratch, slow_int);\n+    lightweight_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  compiler_fast_lock_lightweight_object(flag, obj, tmp1, tmp2, tmp3);\n+  compiler_fast_lock_lightweight_object(flag, obj, box, tmp1, tmp2, tmp3);\n@@ -47,1 +47,1 @@\n-  compiler_fast_unlock_lightweight_object(flag, obj, tmp1, tmp2, tmp3);\n+  compiler_fast_unlock_lightweight_object(flag, obj, box, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  const static size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n+  static const size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zAddress_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -971,1 +971,1 @@\n-      lightweight_lock(object, header, tmp, slow_case);\n+      lightweight_lock(monitor, object, header, tmp, slow_case);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2733,3 +2733,3 @@\n-void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register tmp1,\n-                                                           Register tmp2, Register tmp3) {\n-  assert_different_registers(obj, tmp1, tmp2, tmp3);\n+void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n+                                                           Register tmp1, Register tmp2, Register tmp3) {\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3);\n@@ -2745,0 +2745,6 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    li(tmp1, 0);\n+    std(tmp1, in_bytes(BasicObjectLock::lock_offset()) + BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+  }\n+\n@@ -2748,2 +2754,2 @@\n-    testbitdi(flag, R0, tmp1, exact_log2(KlassFlags::_misc_is_value_based_class));\n-    bne(flag, slow_path);\n+    testbitdi(CCR0, R0, tmp1, exact_log2(KlassFlags::_misc_is_value_based_class));\n+    bne(CCR0, slow_path);\n@@ -2764,2 +2770,2 @@\n-    cmplwi(flag, top, LockStack::end_offset() - 1);\n-    bgt(flag, slow_path);\n+    cmplwi(CCR0, top, LockStack::end_offset() - 1);\n+    bgt(CCR0, slow_path);\n@@ -2773,2 +2779,2 @@\n-    cmpd(flag, obj, t);\n-    beq(flag, push);\n+    cmpd(CCR0, obj, t);\n+    beq(CCR0, push);\n@@ -2779,3 +2785,3 @@\n-    cmpldi(flag, t, markWord::unlocked_value);\n-    bgt(flag, inflated);\n-    bne(flag, slow_path);\n+    cmpldi(CCR0, t, markWord::unlocked_value);\n+    bgt(CCR0, inflated);\n+    bne(CCR0, slow_path);\n@@ -2785,1 +2791,1 @@\n-    \/\/ Try to lock. Transition lock bits 0b00 => 0b01\n+    \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n@@ -2800,0 +2806,6 @@\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register monitor = mark;\n+    const Register owner_addr = tmp2;\n+    Label monitor_locked;\n+\n@@ -2801,4 +2813,36 @@\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register tagged_monitor = mark;\n-      const uintptr_t monitor_tag = markWord::monitor_value;\n-      const Register owner_addr = tmp2;\n+      \/\/ Compute owner address.\n+      addi(owner_addr, mark, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n+    } else {\n+      Label monitor_found;\n+      Register cache_addr = tmp2;\n+\n+      \/\/ Load cache address\n+      addi(cache_addr, R16_thread, in_bytes(JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ld(tmp3, 0, cache_addr);\n+        cmpd(CCR0, tmp3, obj);\n+        beq(CCR0, monitor_found);\n+        addi(cache_addr, cache_addr, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ld(tmp3, 0, cache_addr);\n+      cmpd(CCR0, tmp3, obj);\n+      beq(CCR0, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      addi(cache_addr, cache_addr, in_bytes(OMCache::oop_to_oop_difference()));\n+      cmpdi(CCR1, tmp3, 0);\n+      bne(CCR1, loop);\n+      \/\/ Cache Miss, CCR0.NE set from cmp above\n+      b(slow_path);\n+\n+      bind(monitor_found);\n+      ld(monitor, in_bytes(OMCache::oop_to_monitor_difference()), cache_addr);\n@@ -2807,17 +2851,20 @@\n-      addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n-\n-      \/\/ CAS owner (null => current thread).\n-      cmpxchgd(\/*flag=*\/flag,\n-              \/*current_value=*\/t,\n-              \/*compare_value=*\/(intptr_t)0,\n-              \/*exchange_value=*\/R16_thread,\n-              \/*where=*\/owner_addr,\n-              MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-              MacroAssembler::cmpxchgx_hint_acquire_lock());\n-      beq(flag, locked);\n-\n-      \/\/ Check if recursive.\n-      cmpd(flag, t, R16_thread);\n-      bne(flag, slow_path);\n-\n-      \/\/ Recursive.\n+      addi(owner_addr, monitor, in_bytes(ObjectMonitor::owner_offset()));\n+    }\n+\n+    \/\/ CAS owner (null => current thread).\n+    cmpxchgd(\/*flag=*\/CCR0,\n+            \/*current_value=*\/t,\n+            \/*compare_value=*\/(intptr_t)0,\n+            \/*exchange_value=*\/R16_thread,\n+            \/*where=*\/owner_addr,\n+            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+            MacroAssembler::cmpxchgx_hint_acquire_lock());\n+    beq(CCR0, monitor_locked);\n+\n+    \/\/ Check if recursive.\n+    cmpd(CCR0, t, R16_thread);\n+    bne(CCR0, slow_path);\n+\n+    \/\/ Recursive.\n+    if (!UseObjectMonitorTable) {\n+      assert_different_registers(tmp1, owner_addr);\n@@ -2828,4 +2875,9 @@\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      \/\/ Set flag to NE\n-      crxor(flag, Assembler::equal, flag, Assembler::equal);\n-      b(slow_path);\n+      assert_different_registers(tmp2, monitor);\n+      ld(tmp2, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      addi(tmp2, tmp2, 1);\n+      std(tmp2, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+    }\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      std(monitor, BasicLock::object_monitor_cache_offset_in_bytes(), box);\n@@ -2841,1 +2893,1 @@\n-  beq(flag, flag_correct);\n+  beq(CCR0, flag_correct);\n@@ -2847,1 +2899,1 @@\n-  bne(flag, flag_correct);\n+  bne(CCR0, flag_correct);\n@@ -2854,2 +2906,2 @@\n-void MacroAssembler::compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register obj, Register tmp1,\n-                                                             Register tmp2, Register tmp3) {\n+void MacroAssembler::compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n+                                                             Register tmp1, Register tmp2, Register tmp3) {\n@@ -2877,1 +2929,1 @@\n-    cmpd(flag, obj, t);\n+    cmpd(CCR0, obj, t);\n@@ -2879,1 +2931,1 @@\n-    bne(flag, inflated_load_monitor);\n+    bne(CCR0, inflated_load_monitor);\n@@ -2892,2 +2944,2 @@\n-    cmpd(flag, obj, t);\n-    beq(flag, unlocked);\n+    cmpd(CCR0, obj, t);\n+    beq(CCR0, unlocked);\n@@ -2944,2 +2996,2 @@\n-    cmpd(flag, obj, t);\n-    bne(flag, inflated);\n+    cmpd(CCR0, obj, t);\n+    bne(CCR0, inflated);\n@@ -2950,4 +3002,3 @@\n-    if (!UseObjectMonitorTable) {\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register monitor = mark;\n-      const uintptr_t monitor_tag = markWord::monitor_value;\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register monitor = mark;\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n@@ -2955,0 +3006,1 @@\n+    if (!UseObjectMonitorTable) {\n@@ -2957,0 +3009,6 @@\n+    } else {\n+      ld(monitor, BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+      \/\/ null check with Flags == NE, no valid pointer below alignof(ObjectMonitor*)\n+      cmpldi(CCR0, monitor, checked_cast<uint8_t>(alignof(ObjectMonitor*)));\n+      blt(CCR0, slow_path);\n+    }\n@@ -2958,2 +3016,2 @@\n-      const Register recursions = tmp2;\n-      Label not_recursive;\n+    const Register recursions = tmp2;\n+    Label not_recursive;\n@@ -2961,4 +3019,4 @@\n-      \/\/ Check if recursive.\n-      ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-      addic_(recursions, recursions, -1);\n-      blt(CCR0, not_recursive);\n+    \/\/ Check if recursive.\n+    ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+    addic_(recursions, recursions, -1);\n+    blt(CCR0, not_recursive);\n@@ -2966,4 +3024,4 @@\n-      \/\/ Recursive unlock.\n-      std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n-      b(unlocked);\n+    \/\/ Recursive unlock.\n+    std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n+    b(unlocked);\n@@ -2971,1 +3029,1 @@\n-      bind(not_recursive);\n+    bind(not_recursive);\n@@ -2973,2 +3031,2 @@\n-      Label release_;\n-      const Register t2 = tmp2;\n+    Label release_;\n+    const Register t2 = tmp2;\n@@ -2976,6 +3034,6 @@\n-      \/\/ Check if the entry lists are empty.\n-      ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n-      ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n-      orr(t, t, t2);\n-      cmpdi(flag, t, 0);\n-      beq(flag, release_);\n+    \/\/ Check if the entry lists are empty.\n+    ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n+    ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n+    orr(t, t, t2);\n+    cmpdi(CCR0, t, 0);\n+    beq(CCR0, release_);\n@@ -2983,5 +3041,5 @@\n-      \/\/ The owner may be anonymous and we removed the last obj entry in\n-      \/\/ the lock-stack. This loses the information about the owner.\n-      \/\/ Write the thread to the owner field so the runtime knows the owner.\n-      std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-      b(slow_path);\n+    \/\/ The owner may be anonymous and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    b(slow_path);\n@@ -2989,11 +3047,5 @@\n-      bind(release_);\n-      \/\/ Set owner to null.\n-      release();\n-      \/\/ t contains 0\n-      std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-    } else {\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      \/\/ Set flag to NE\n-      crxor(flag, Assembler::equal, flag, Assembler::equal);\n-      b(slow_path);\n-    }\n+    bind(release_);\n+    \/\/ Set owner to null.\n+    release();\n+    \/\/ t contains 0\n+    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n@@ -3008,1 +3060,1 @@\n-  beq(flag, flag_correct);\n+  beq(CCR0, flag_correct);\n@@ -3014,1 +3066,1 @@\n-  bne(flag, flag_correct);\n+  bne(CCR0, flag_correct);\n@@ -4643,1 +4695,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register box, Register obj, Register t1, Register t2, Label& slow) {\n@@ -4645,1 +4697,1 @@\n-  assert_different_registers(obj, t1, t2);\n+  assert_different_registers(box, obj, t1, t2);\n@@ -4652,0 +4704,6 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    li(t, 0);\n+    std(t, in_bytes(BasicObjectLock::lock_offset()) + BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+  }\n+\n@@ -4672,1 +4730,1 @@\n-  \/\/ Try to lock. Transition lock bits 0b00 => 0b01\n+  \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":150,"deletions":92,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -657,1 +657,1 @@\n-  void lightweight_lock(Register obj, Register t1, Register t2, Label& slow);\n+  void lightweight_lock(Register box, Register obj, Register t1, Register t2, Label& slow);\n@@ -678,2 +678,2 @@\n-  void compiler_fast_lock_lightweight_object(ConditionRegister flag, Register oop, Register tmp1,\n-                                             Register tmp2, Register tmp3);\n+  void compiler_fast_lock_lightweight_object(ConditionRegister flag, Register oop, Register box,\n+                                             Register tmp1, Register tmp2, Register tmp3);\n@@ -681,2 +681,2 @@\n-  void compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register oop, Register tmp1,\n-                                               Register tmp2, Register tmp3);\n+  void compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register oop, Register box,\n+                                               Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -12109,1 +12109,1 @@\n-instruct cmpFastLockLightweight(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{\n+instruct cmpFastLockLightweight(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR1 cr1) %{\n@@ -12112,1 +12112,1 @@\n-  effect(TEMP tmp1, TEMP tmp2);\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr1);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2402,1 +2402,1 @@\n-      __ compiler_fast_lock_lightweight_object(CCR0, r_oop, r_temp_1, r_temp_2, r_temp_3);\n+      __ compiler_fast_lock_lightweight_object(CCR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n@@ -2608,1 +2608,1 @@\n-      __ compiler_fast_unlock_lightweight_object(CCR0, r_oop, r_temp_1, r_temp_2, r_temp_3);\n+      __ compiler_fast_unlock_lightweight_object(CCR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  const static size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n+  static const  size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zAddress_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+\/\/ Generic implementation. GCs can provide an optimized one.\n@@ -109,3 +110,0 @@\n-  NearLabel Ldone;\n-  __ z_ltgr(tmp1, value);\n-  __ z_bre(Ldone);          \/\/ Use null result as-is.\n@@ -113,2 +111,4 @@\n-  __ z_nill(value, ~JNIHandles::tag_mask);\n-  __ z_lg(value, 0, value); \/\/ Resolve (untagged) jobject.\n+  assert_different_registers(value, tmp1, tmp2);\n+  NearLabel done, weak_tag, verify, tagged;\n+  __ z_ltgr(value, value);\n+  __ z_bre(done);          \/\/ Use null result as-is.\n@@ -116,0 +116,44 @@\n+  __ z_tmll(value, JNIHandles::tag_mask);\n+  __ z_btrue(tagged); \/\/ not zero\n+\n+  \/\/ Resolve Local handle\n+  __ access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, Address(value, 0), value, tmp1, tmp2);\n+  __ z_bru(verify);\n+\n+  __ bind(tagged);\n+  __ testbit(value, exact_log2(JNIHandles::TypeTag::weak_global)); \/\/ test for weak tag\n+  __ z_btrue(weak_tag);\n+\n+  \/\/ resolve global handle\n+  __ access_load_at(T_OBJECT, IN_NATIVE, Address(value, -JNIHandles::TypeTag::global), value, tmp1, tmp2);\n+  __ z_bru(verify);\n+\n+  __ bind(weak_tag);\n+  \/\/ resolve jweak.\n+  __ access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n+                    Address(value, -JNIHandles::TypeTag::weak_global), value, tmp1, tmp2);\n+  __ bind(verify);\n+  __ verify_oop(value, FILE_AND_LINE);\n+  __ bind(done);\n+}\n+\n+\/\/ Generic implementation. GCs can provide an optimized one.\n+void BarrierSetAssembler::resolve_global_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  NearLabel done;\n+\n+  __ z_ltgr(value, value);\n+  __ z_bre(done); \/\/ use null as-is.\n+\n+#ifdef ASSERT\n+  {\n+    NearLabel valid_global_tag;\n+    __ testbit(value, exact_log2(JNIHandles::TypeTag::global)); \/\/ test for global tag\n+    __ z_btrue(valid_global_tag);\n+    __ stop(\"non global jobject using resolve_global_jobject\");\n+    __ bind(valid_global_tag);\n+  }\n+#endif \/\/ ASSERT\n+\n+  \/\/ Resolve global handle\n+  __ access_load_at(T_OBJECT, IN_NATIVE, Address(value, -JNIHandles::TypeTag::global), value, tmp1, tmp2);\n@@ -117,1 +161,1 @@\n-  __ bind(Ldone);\n+  __ bind(done);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":50,"deletions":6,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  virtual void resolve_global_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/jniHandles.hpp\"\n@@ -61,0 +62,13 @@\n+\n+void ModRefBarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2) {\n+  NearLabel done;\n+\n+  __ z_ltgr(value, value);\n+  __ z_bre(done);  \/\/ use null as-is.\n+\n+  __ z_nill(value, ~JNIHandles::tag_mask);\n+  __ z_lg(value, 0, value); \/\/ Resolve (untagged) jobject.\n+\n+  __ verify_oop(value, FILE_AND_LINE);\n+  __ bind(done);\n+}\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/modRefBarrierSetAssembler_s390.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n@@ -51,0 +51,2 @@\n+\n+  virtual void resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/modRefBarrierSetAssembler_s390.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3675,0 +3675,5 @@\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->resolve_global_jobject(this, value, tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -761,0 +761,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n@@ -822,1 +823,0 @@\n- private:\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -639,1 +639,1 @@\n-  __ andq(dst, _zpointer_address_mask);\n+  __ andq(dst, ZPointerAddressMask);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  static const int32_t _zpointer_address_mask = 0xFFFF0000;\n+  static const int32_t ZPointerAddressMask = 0xFFFF0000;\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    __ testq($op$$Address, ZBarrierSetAssembler::_zpointer_address_mask);\n+    __ testq($op$$Address, ZBarrierSetAssembler::ZPointerAddressMask);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/z_x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-static const char* z_preferred_tmpfs_mountpoints[] = {\n+static const char* ZPreferredTmpfsMountpoints[] = {\n@@ -113,1 +113,1 @@\n-static const char* z_preferred_hugetlbfs_mountpoints[] = {\n+static const char* ZPreferredHugetlbfsMountpoints[] = {\n@@ -229,2 +229,2 @@\n-                                             ? z_preferred_hugetlbfs_mountpoints\n-                                             : z_preferred_tmpfs_mountpoints;\n+                                             ? ZPreferredHugetlbfsMountpoints\n+                                             : ZPreferredTmpfsMountpoints;\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-    guarantee(UseG1GC, \"implementation limitation\");\n@@ -455,3 +454,0 @@\n-  assert(UseG1GC, \"must be\");\n-  address heap_end = (address)G1CollectedHeap::heap()->reserved().end();\n-  log_info(cds, heap)(\"Heap end = %p\", heap_end);\n@@ -462,1 +458,0 @@\n-\n@@ -464,1 +459,9 @@\n-    _requested_bottom = align_down(heap_end - heap_region_byte_size, G1HeapRegion::GrainBytes);\n+    if (UseG1GC) {\n+      address heap_end = (address)G1CollectedHeap::heap()->reserved().end();\n+      log_info(cds, heap)(\"Heap end = %p\", heap_end);\n+      _requested_bottom = align_down(heap_end - heap_region_byte_size, G1HeapRegion::GrainBytes);\n+      _requested_bottom = align_down(_requested_bottom, MIN_GC_REGION_ALIGNMENT);\n+      assert(is_aligned(_requested_bottom, G1HeapRegion::GrainBytes), \"sanity\");\n+    } else {\n+      _requested_bottom = align_up(CompressedOops::begin(), MIN_GC_REGION_ALIGNMENT);\n+    }\n@@ -471,1 +474,1 @@\n-    _requested_bottom = (address)NOCOOPS_REQUESTED_BASE;\n+    _requested_bottom = align_up((address)NOCOOPS_REQUESTED_BASE, MIN_GC_REGION_ALIGNMENT);\n@@ -474,1 +477,1 @@\n-  assert(is_aligned(_requested_bottom, G1HeapRegion::GrainBytes), \"sanity\");\n+  assert(is_aligned(_requested_bottom, MIN_GC_REGION_ALIGNMENT), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -474,5 +474,7 @@\n-    log_info(cds)(\"Heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n-                   UseCompressedOops ? p2i(CompressedOops::begin()) :\n-                                       p2i((address)G1CollectedHeap::heap()->reserved().start()),\n-                   UseCompressedOops ? p2i(CompressedOops::end()) :\n-                                       p2i((address)G1CollectedHeap::heap()->reserved().end()));\n+    if (UseCompressedOops || UseG1GC) {\n+      log_info(cds)(\"Heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+                    UseCompressedOops ? p2i(CompressedOops::begin()) :\n+                                        p2i((address)G1CollectedHeap::heap()->reserved().start()),\n+                    UseCompressedOops ? p2i(CompressedOops::end()) :\n+                                        p2i((address)G1CollectedHeap::heap()->reserved().end()));\n+    }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  \/\/ Can this VM write a heap region into the CDS archive? Currently only G1+compressed{oops,cp}\n+  \/\/ Can this VM write a heap region into the CDS archive? Currently only {G1|Parallel|Serial}+compressed_cp\n@@ -152,1 +152,1 @@\n-      return (UseG1GC && UseCompressedClassPointers);\n+      return (UseG1GC || UseParallelGC || UseSerialGC) && UseCompressedClassPointers;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1152,0 +1152,1 @@\n+    ik->set_shared_loading_failed();\n@@ -1156,0 +1157,1 @@\n+    ik->set_shared_loading_failed();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-template<typename K, typename V, size_t _table_size>\n+template<typename K, typename V, size_t TableSize>\n@@ -58,1 +58,1 @@\n-  static const size_t _table_mask = _table_size - 1;\n+  static const size_t TableMask = TableSize - 1;\n@@ -61,1 +61,1 @@\n-  ZArenaHashtableEntry* _table[_table_size];\n+  ZArenaHashtableEntry* _table[TableSize];\n@@ -87,1 +87,1 @@\n-      while (_current_entry == nullptr && ++_current_index < _table_size) {\n+      while (_current_entry == nullptr && ++_current_index < TableSize) {\n@@ -103,2 +103,2 @@\n-    entry->_next = _table[key & _table_mask];\n-    _table[key & _table_mask] = entry;\n+    entry->_next = _table[key & TableMask];\n+    _table[key & TableMask] = entry;\n@@ -108,1 +108,1 @@\n-    for (ZArenaHashtableEntry* e = _table[key & _table_mask]; e != nullptr; e = e->_next) {\n+    for (ZArenaHashtableEntry* e = _table[key & TableMask]; e != nullptr; e = e->_next) {\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-  static const BarrierSet::Name value = BarrierSet::ZBarrierSet;\n+  static const BarrierSet::Name Value = BarrierSet::ZBarrierSet;\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -842,1 +842,1 @@\n-  const uint64_t interval_ms = MILLIUNITS \/ decision_hz;\n+  const uint64_t interval_ms = MILLIUNITS \/ DecisionHz;\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  static const uint64_t decision_hz = 100;\n+  static const uint64_t DecisionHz = 100;\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-static size_t bitmap_size(uint32_t size, size_t nsegments) {\n+static size_t bitmap_size(uint32_t size, size_t NumSegments) {\n@@ -40,1 +40,1 @@\n-  return MAX2<size_t>(size, nsegments) * 2;\n+  return MAX2<size_t>(size, NumSegments) * 2;\n@@ -49,1 +49,1 @@\n-    _bitmap(bitmap_size(size, nsegments)),\n+    _bitmap(bitmap_size(size, NumSegments)),\n@@ -130,1 +130,1 @@\n-  const size_t new_bitmap_size = bitmap_size(size, nsegments);\n+  const size_t new_bitmap_size = bitmap_size(size, NumSegments);\n","filename":"src\/hotspot\/share\/gc\/z\/zLiveMap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  static const size_t nsegments = 64;\n+  static const size_t NumSegments = 64;\n","filename":"src\/hotspot\/share\/gc\/z\/zLiveMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  return BitMapView(const_cast<BitMap::bm_word_t*>(&_segment_live_bits), nsegments);\n+  return BitMapView(const_cast<BitMap::bm_word_t*>(&_segment_live_bits), NumSegments);\n@@ -59,1 +59,1 @@\n-  return BitMapView(const_cast<BitMap::bm_word_t*>(&_segment_claim_bits), nsegments);\n+  return BitMapView(const_cast<BitMap::bm_word_t*>(&_segment_claim_bits), NumSegments);\n@@ -63,1 +63,1 @@\n-  return BitMapView(&_segment_live_bits, nsegments);\n+  return BitMapView(&_segment_live_bits, NumSegments);\n@@ -67,1 +67,1 @@\n-  return BitMapView(&_segment_claim_bits, nsegments);\n+  return BitMapView(&_segment_claim_bits, NumSegments);\n@@ -83,1 +83,1 @@\n-  return segment_live_bits().find_first_set_bit(0, nsegments);\n+  return segment_live_bits().find_first_set_bit(0, NumSegments);\n@@ -87,1 +87,1 @@\n-  return segment_live_bits().find_first_set_bit(segment + 1, nsegments);\n+  return segment_live_bits().find_first_set_bit(segment + 1, NumSegments);\n@@ -91,1 +91,1 @@\n-  return _bitmap.size() \/ nsegments;\n+  return _bitmap.size() \/ NumSegments;\n@@ -170,1 +170,1 @@\n-  for (BitMap::idx_t segment = first_live_segment(); segment < nsegments; segment = next_live_segment(segment)) {\n+  for (BitMap::idx_t segment = first_live_segment(); segment < NumSegments; segment = next_live_segment(segment)) {\n","filename":"src\/hotspot\/share\/gc\/z\/zLiveMap.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-  static const size_t reference_type_count = REF_PHANTOM + 1;\n-  typedef size_t Counters[reference_type_count];\n+  static const size_t ReferenceTypeCount = REF_PHANTOM + 1;\n+  typedef size_t Counters[ReferenceTypeCount];\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-    assert(_old_watermarks_newest < _old_watermarks_max, \"Unexpected amount of old watermarks\");\n+    assert(_old_watermarks_newest < OldWatermarksMax, \"Unexpected amount of old watermarks\");\n","filename":"src\/hotspot\/share\/gc\/z\/zStackWatermark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-  const static int      _old_watermarks_max = 3;\n-  ZColorWatermark       _old_watermarks[_old_watermarks_max];\n+  static const int      OldWatermarksMax = 3;\n+  ZColorWatermark       _old_watermarks[OldWatermarksMax];\n","filename":"src\/hotspot\/share\/gc\/z\/zStackWatermark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1022,1 +1022,1 @@\n-  : _metronome(sample_hz) {\n+  : _metronome(SampleHz) {\n@@ -1101,1 +1101,1 @@\n-  static const size_t _buffer_size = 256;\n+  static const size_t BufferSize = 256;\n@@ -1105,1 +1105,1 @@\n-  char         _buffer[_buffer_size];\n+  char         _buffer[BufferSize];\n@@ -1122,1 +1122,1 @@\n-      const int res = jio_vsnprintf(_buffer + position, _buffer_size - position, fmt, va);\n+      const int res = jio_vsnprintf(_buffer + position, BufferSize - position, fmt, va);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-  static const uint64_t sample_hz = 1;\n+  static const uint64_t SampleHz = 1;\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    _current(ZBufferStoreBarriers ? _buffer_size_bytes : 0) {}\n+    _current(ZBufferStoreBarriers ? BufferSizeBytes : 0) {}\n@@ -66,1 +66,1 @@\n-  _current = _buffer_size_bytes;\n+  _current = BufferSizeBytes;\n@@ -70,1 +70,1 @@\n-  return _current == _buffer_size_bytes;\n+  return _current == BufferSizeBytes;\n@@ -82,1 +82,1 @@\n-  for (size_t i = current(); i < _buffer_length; ++i) {\n+  for (size_t i = current(); i < BufferLength; ++i) {\n@@ -232,1 +232,1 @@\n-  for (size_t i = current(); i < _buffer_length; ++i) {\n+  for (size_t i = current(); i < BufferLength; ++i) {\n@@ -262,1 +262,1 @@\n-  for (size_t i = current(); i < _buffer_length; ++i) {\n+  for (size_t i = current(); i < BufferLength; ++i) {\n@@ -279,1 +279,1 @@\n-  for (size_t i = current(); i < _buffer_length; ++i) {\n+  for (size_t i = current(); i < BufferLength; ++i) {\n@@ -299,1 +299,1 @@\n-    for (size_t i = buffer->current(); i < _buffer_length; ++i) {\n+    for (size_t i = buffer->current(); i < BufferLength; ++i) {\n","filename":"src\/hotspot\/share\/gc\/z\/zStoreBarrierBuffer.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-  static const size_t _buffer_length     = 32;\n-  static const size_t _buffer_size_bytes = _buffer_length * sizeof(ZStoreBarrierEntry);\n+  static const size_t BufferLength    = 32;\n+  static const size_t BufferSizeBytes = BufferLength * sizeof(ZStoreBarrierEntry);\n@@ -48,1 +48,1 @@\n-  ZStoreBarrierEntry _buffer[_buffer_length];\n+  ZStoreBarrierEntry _buffer[BufferLength];\n@@ -57,1 +57,1 @@\n-  zaddress_unsafe    _base_pointers[_buffer_length];\n+  zaddress_unsafe    _base_pointers[BufferLength];\n","filename":"src\/hotspot\/share\/gc\/z\/zStoreBarrierBuffer.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  static const size_t offset = 4 * K;\n+  static const size_t Offset = 4 * K;\n","filename":"src\/hotspot\/share\/gc\/z\/zValue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  assert(size <= offset, \"Allocation too large\");\n+  assert(size <= Offset, \"Allocation too large\");\n@@ -59,2 +59,2 @@\n-  const size_t block_alignment = offset;\n-  const size_t block_size = offset * S::count();\n+  const size_t block_alignment = Offset;\n+  const size_t block_size = Offset * S::count();\n@@ -62,1 +62,1 @@\n-  _end = _top + offset;\n+  _end = _top + Offset;\n@@ -122,1 +122,1 @@\n-  return _addr + (value_id * S::offset);\n+  return _addr + (value_id * S::Offset);\n","filename":"src\/hotspot\/share\/gc\/z\/zValue.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -592,1 +592,1 @@\n-    for (size_t i = buffer->current(); i < ZStoreBarrierBuffer::_buffer_length; ++i) {\n+    for (size_t i = buffer->current(); i < ZStoreBarrierBuffer::BufferLength; ++i) {\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(RISCV64)\n+#if defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64)\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-<p>For example, suppose your applet contains the following\n+<p>For example, suppose your application contains the following\n@@ -95,1 +95,1 @@\n-            repaint();\n+            blink();\n@@ -100,1 +100,1 @@\n-applet's <code>stop<\/code> and <code>run<\/code> methods with:\n+application's <code>stop<\/code> and <code>run<\/code> methods with:\n@@ -115,1 +115,1 @@\n-            repaint();\n+            blink();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -376,2 +376,1 @@\n-     * be automatically followed by this class.  True by default.  Applets\n-     * cannot change this variable.\n+     * be automatically followed by this class.  True by default.\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpURLConnection.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * the ability of an application\/applet to use certain\n+ * the ability of an application to use certain\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/CryptoPermission.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * <p>Applications or applets that use an exemption mechanism may be granted\n+ * <p>Applications that use an exemption mechanism may be granted\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/ExemptionMechanism.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * allowable cryptographic strength for a given applet\/application, for a given\n+ * allowable cryptographic strength for a given application, for a given\n@@ -41,1 +41,1 @@\n- * the cryptographic permissions bundled with the applet\/application.\n+ * the cryptographic permissions bundled with the application.\n@@ -88,1 +88,1 @@\n-     * applet\/application, for the given algorithm.\n+     * application, for the given algorithm.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/JceSecurityManager.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n- * a factory that was appropriate for a particular user or applet, and a\n+ * a factory that was appropriate for a particular application, and a\n","filename":"src\/java.base\/share\/classes\/javax\/net\/SocketFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1135,1 +1135,0 @@\n-        KeyStore cakstore = buildTrustedCerts();\n@@ -1144,0 +1143,1 @@\n+            KeyStore cakstore = buildTrustedCerts();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1466,0 +1466,1 @@\n+            JLI_ReportErrorMessage(ARG_DEPRECATED, \"-verbosegc\");\n@@ -1470,0 +1471,1 @@\n+            JLI_ReportErrorMessage(ARG_DEPRECATED, \"-noclassgc\");\n@@ -1472,0 +1474,1 @@\n+            JLI_ReportErrorMessage(ARG_DEPRECATED, \"-verify\");\n@@ -1474,0 +1477,1 @@\n+            JLI_ReportErrorMessage(ARG_DEPRECATED, \"-verifyremote\");\n@@ -1482,1 +1486,0 @@\n-                   JLI_StrCCmp(arg, \"-oss\") == 0 ||\n@@ -1485,0 +1488,2 @@\n+            JLI_ReportErrorMessage(\"Warning: %.3s option is deprecated\"\n+                                   \" and may be removed in a future release.\", arg);\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-            return readLinkImpl(handle);\n+            return readLinkImpl(path, handle);\n@@ -300,1 +300,3 @@\n-    private static String readLinkImpl(long handle) throws IOException {\n+    private static String readLinkImpl(WindowsPath path, long handle)\n+        throws IOException\n+    {\n@@ -306,1 +308,1 @@\n-                \/\/ FIXME: exception doesn't have file name\n+                String pathname = path.getPathForExceptionMessage();\n@@ -308,2 +310,2 @@\n-                    throw new NotLinkException(null, null, x.errorString());\n-                x.rethrowAsIOException((String)null);\n+                    throw new NotLinkException(pathname, null, x.errorString());\n+                x.rethrowAsIOException(pathname + \": \" + x.errorString());\n@@ -345,2 +347,2 @@\n-                \/\/ FIXME: exception doesn't have file name\n-                throw new NotLinkException(null, null, \"Reparse point is not a symbolic link\");\n+                String pathname = path.getPathForExceptionMessage();\n+                throw new NotLinkException(pathname, null, \"Reparse point is not a symbolic link\");\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -111,3 +111,3 @@\n-        \/\/ incompatible GCs\n-        testDump(2, \"-XX:+UseParallelGC\", \"\", GC_WARNING, false);\n-        testDump(3, \"-XX:+UseSerialGC\", \"\", GC_WARNING, false);\n+        \/\/ Dump heap objects with ParallelGC and SerialGC\n+        testDump(2, \"-XX:+UseParallelGC\", \"\", \"\", false);\n+        testDump(3, \"-XX:+UseSerialGC\", \"\", \"\", false);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/IncompatibleOptions.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.gc.G1\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsHumongous.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-            TestCommon.concat(extraOptions, \"-XX:+UseCompressedOops\", \"-XX:+UseG1GC\",\n+            TestCommon.concat(extraOptions, \"-XX:+UseCompressedOops\",\n@@ -127,1 +127,1 @@\n-            \"-cp\", appJar, \"-XX:+UseCompressedOops\", \"-XX:+UseG1GC\", className);\n+            \"-cp\", appJar, \"-XX:+UseCompressedOops\", className);\n@@ -146,1 +146,1 @@\n-            \"-XX:+UseCompressedOops\", \"-XX:+UseG1GC\", className);\n+            \"-XX:+UseCompressedOops\", className);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsUtils.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    private static final String wincommitted = winbase + \"c-pvt\" + space + someNumber + space;\n+    private static final String wincommitted = winbase + \"(c-pvt|c-map)\" + space + someNumber + space;\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -717,0 +717,1 @@\n+java\/util\/zip\/CloseInflaterDeflaterTest.java  8339216 linux-s390x\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4247913\n+ * @summary Tests that Label repaints after call Container.validate()\n+ * @run main ContainerValidateTest\n+ *\/\n+\n+public class ContainerValidateTest extends Frame implements MouseListener {\n+    private static Robot robot;\n+    private static Panel currentPanel;\n+    private static Button currentBtn;\n+    private static Panel updatedPanel;\n+    private static Label updatedLabel;\n+    private static TextField updatedTxtField;\n+    private static Button updatedBtn;\n+\n+    private static volatile Rectangle btnBounds;\n+\n+    Panel pnl1 = new Panel();\n+    Panel pnl2 = new Panel();\n+    Label lbl1 = new Label(\"Label 1\");\n+    Label lbl2 = new Label(\"Label 2\");\n+    TextField txt1 = new TextField(\"field1\", 20);\n+    TextField txt2 = new TextField(\"field2\", 20);\n+    Button btn1 = new Button(\"Swap 1\");\n+    Button btn2 = new Button(\"Swap 2\");\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+\n+        ContainerValidateTest containerValidate = new ContainerValidateTest();\n+        EventQueue.invokeAndWait(containerValidate::createAndShowUI);\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+\n+        containerValidate.testUI();\n+    }\n+\n+    private void createAndShowUI() {\n+        this.setTitle(\"ContainerValidateTest Test\");\n+        pnl1.add(lbl1);\n+        pnl1.add(txt1);\n+        pnl1.add(btn1);\n+\n+        pnl2.add(lbl2);\n+        pnl2.add(txt2);\n+        pnl2.add(btn2);\n+\n+        btn1.addMouseListener(this);\n+        btn2.addMouseListener(this);\n+\n+        this.add(pnl1, BorderLayout.CENTER);\n+        pack();\n+        setLocationRelativeTo(null);\n+        setVisible(true);\n+    }\n+\n+    private void testUI() throws Exception {\n+        EventQueue.invokeAndWait(() -> btnBounds\n+                = new Rectangle(btn1.getLocationOnScreen().x,\n+                                btn1.getLocationOnScreen().y,\n+                                btn1.getWidth(),\n+                                btn1.getHeight()));\n+        for (int i= 1; i < 4 ; i++) {\n+            EventQueue.invokeAndWait(() -> {\n+                currentPanel = (Panel) this.getComponent(0);\n+                currentBtn = (Button) currentPanel.getComponent(2);\n+            });\n+\n+            robot.mouseMove(btnBounds.x + (int) btnBounds.getWidth() \/ 2,\n+                            btnBounds.y + (int) btnBounds.getHeight() \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            \/\/large delay set for completion of UI validate()\n+            robot.delay(500);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                updatedPanel = (Panel) this.getComponent(0);\n+                updatedLabel = (Label) updatedPanel.getComponent(0);\n+                updatedTxtField = (TextField) updatedPanel.getComponent(1);\n+                updatedBtn = (Button) updatedPanel.getComponent(2);\n+            });\n+            testPanelComponents(currentBtn.getLabel());\n+        }\n+    }\n+\n+    private void testPanelComponents(String btnLabel) {\n+        if (btnLabel.equals(\"Swap 1\")) {\n+            if (!(updatedLabel.getText().equals(lbl2.getText())\n+                  && updatedTxtField.getText().equals(txt2.getText())\n+                  && updatedBtn.getLabel().equals(btn2.getLabel()))) {\n+                throw new RuntimeException(\"Test Failed!! Labels not repainted\"\n+                                           + \" after Container.validate()\");\n+            }\n+        } else {\n+            if (!(updatedLabel.getText().equals(lbl1.getText())\n+                  && updatedTxtField.getText().equals(txt1.getText())\n+                  && updatedBtn.getLabel().equals(btn1.getLabel()))) {\n+                throw new RuntimeException(\"Test Failed!! Labels not repainted\"\n+                                           + \" after Container.validate()\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void mousePressed(MouseEvent evt) {\n+        if (evt.getComponent() instanceof Button btn) {\n+            if (btn.equals(btn1)) {\n+                remove(pnl1);\n+                add(pnl2, BorderLayout.CENTER);\n+            } else {\n+                remove(pnl2);\n+                add(pnl1, BorderLayout.CENTER);\n+            }\n+            invalidate();\n+            validate();\n+        }\n+    }\n+\n+    @Override\n+    public void mouseReleased(MouseEvent e) {}\n+\n+    @Override\n+    public void mouseEntered(MouseEvent e) {}\n+\n+    @Override\n+    public void mouseExited(MouseEvent e) {}\n+\n+    @Override\n+    public void mouseClicked(MouseEvent e) {}\n+}\n","filename":"test\/jdk\/java\/awt\/Label\/ContainerValidateTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4292503\n+ * @summary OutOfMemoryError with lots of Robot.createScreenCapture\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"linux\")\n+ * @run main\/manual CreateScreenCapture\n+*\/\n+\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Image;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+\n+public class CreateScreenCapture {\n+\n+    static TextArea messageText;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+         This test is linux only!\n+         Once you see these instructions, run 'top' program.\n+         Watch for java process.\n+         The memory size used by this process should stop growing after several steps.\n+         Numbers of steps test is performing are displayed in output window.\n+         After 5-7 steps the size taken by the process should become stable.\n+         If this happens, then test passed otherwise test failed.\n+\n+         Small oscillations of the memory size are, however, acceptable.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        PassFailJFrame passFail = new PassFailJFrame(INSTRUCTIONS);\n+        Dialog dialog = new Dialog(new Frame(), \"Instructions\");\n+        messageText = new TextArea(\"\", 5, 80, TextArea.SCROLLBARS_BOTH);\n+        dialog.add(messageText);\n+        PassFailJFrame.addTestWindow(dialog);\n+        PassFailJFrame.positionTestWindow(dialog, PassFailJFrame.Position.HORIZONTAL);\n+        dialog.setSize(200, 300);\n+        dialog.setVisible(true);\n+        Rectangle rect = new Rectangle(0, 0, 1000, 1000);\n+        for (int i = 0; i < 100; i++) {\n+            Image image = robot.createScreenCapture(rect);\n+            image.flush();\n+            image = null;\n+            robot.delay(200);\n+            log(\"step #\" + i);\n+        }\n+        passFail.awaitAndCheck();\n+    }\n+\n+    private static void log(String messageIn) {\n+        messageText.append(messageIn + \"\\n\");\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Robot\/CreateScreenCapture.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4374578\n+ * @summary Test robot wheel scrolling of Text\n+ * @requires (os.family == \"Windows\") | (os.family == \"linux\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual RobotScrollTest\n+*\/\n+\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+\n+public class RobotScrollTest {\n+\n+    static TextArea ta;\n+    static Robot robot;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+         0. DON'T TOUCH ANYTHING!\n+         1. This test is for Windows and Linux only.\n+         2. Just sit back, and watch the Robot move the mouse to the TextArea.\n+         3. Once the pointer is on the text area, the Robot will use the mouse wheel\n+            to scroll the text.\n+            If the text scrolled, press PASS, else, press FAIL.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        PassFailJFrame passFail = new PassFailJFrame(INSTRUCTIONS);\n+        createTestUI();\n+        passFail.awaitAndCheck();\n+    }\n+\n+    private static void createTestUI() {\n+        Frame f = new Frame(\"RobotScrollTest\");\n+        ta = new TextArea();\n+        for (int i = 0; i < 100; i++) {\n+            ta.append(i + \"\\n\");\n+        }\n+        f.add(ta);\n+        f.setLocation(0, 400);\n+        f.pack();\n+        PassFailJFrame.addTestWindow(f);\n+        PassFailJFrame.positionTestWindow(f, PassFailJFrame.Position.HORIZONTAL);\n+        f.setVisible(true);\n+        doTest();\n+    }\n+\n+    private static void doTest() {\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+        \/\/ get loc of TextArea\n+        Point taAt = ta.getLocationOnScreen();\n+        \/\/ get bounds of button\n+        Rectangle bounds = ta.getBounds();\n+\n+        \/\/ move mouse to middle of button\n+        robot.mouseMove(taAt.x + bounds.width \/ 2,\n+                        taAt.y + bounds.height \/ 2);\n+\n+        \/\/ rotate wheel a few times\n+        for (int j = 1; j < 8; j++) {\n+            for (int k = 0; k < 5; k++) {\n+                robot.mouseWheel(j);\n+            }\n+\n+            for (int k = 0; k < 5; k++) {\n+                robot.mouseWheel(-1 * j);\n+            }\n+        }\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Robot\/RobotScrollTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import jdk.test.lib.Platform;\n+\n+\/*\n+ * @test\n+ * @bug 4124697\n+ * @key headful\n+ * @summary Make sure that after setting and then changing the echo\n+ *         character again, the TextField continues to function as expected.\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main SetEchoCharTest\n+ *\/\n+\n+public class SetEchoCharTest {\n+    private static Frame frame;\n+    private static Robot robot;\n+    private static TextField tfPassword;\n+    private static Button btn1;\n+    private static Button btn2;\n+    private static volatile Point btn1Loc;\n+    private static volatile Point btn2Loc;\n+\n+    private static final String CHANGE = \"Change echo char\";\n+    private static final String PRINT = \"Print text\";\n+    private static final String INITIAL_TEXT = \"DefaultPwd\";\n+    private static final String CHANGED_TEXT = \"NewPwd\";\n+    private static final char NEW_ECHO_CHAR = '*';\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(50);\n+\n+            EventQueue.invokeAndWait(() -> createAndShowUI());\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            testEchoChar();\n+            robot.waitForIdle();\n+            robot.delay(200);\n+\n+            testNewEchoChar();\n+            robot.waitForIdle();\n+            robot.delay(200);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new Frame(\"SetEchoCharTest\");\n+        frame.setLayout(new FlowLayout());\n+\n+        Label label = new Label(\"Pwd:\");\n+        tfPassword = new TextField(INITIAL_TEXT, 10);\n+        tfPassword.setEchoChar('X');\n+        tfPassword.addActionListener((ActionListener) e -> {\n+            if (e.getActionCommand().equals(CHANGED_TEXT)) {\n+                \/\/check the 2nd condition only if ActionEvent\n+                \/\/is triggered by changed text\n+                if (!(tfPassword.getText().equals(CHANGED_TEXT)\n+                    && tfPassword.getEchoChar() == NEW_ECHO_CHAR)) {\n+                    throw new RuntimeException(\"Test Failed!!! TextField not working\"\n+                                               + \" as expected after echo char change\");\n+                }\n+            }\n+        });\n+        frame.add(label);\n+        frame.add(tfPassword);\n+\n+        btn1 = new Button(PRINT);\n+        btn1.addActionListener(new BtnActionListener());\n+        frame.add(btn1);\n+\n+        btn2 = new Button(CHANGE);\n+        btn2.addActionListener(new BtnActionListener());\n+        frame.add(btn2);\n+        frame.setSize(200,200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void testEchoChar() throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            btn1Loc = btn1.getLocationOnScreen();\n+            btn2Loc = btn2.getLocationOnScreen();\n+        });\n+\n+        robot.mouseMove(btn1Loc.x + btn1.getWidth() \/ 2,\n+                        btn1Loc.y + btn1.getHeight() \/ 2);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(1000);\n+\n+        robot.mouseMove(btn2Loc.x + btn2.getWidth() \/ 2,\n+                        btn2Loc.y + btn2.getHeight() \/ 2);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(1000);\n+    }\n+\n+    private static void testNewEchoChar() {\n+        StringSelection stringSelection = new StringSelection(CHANGED_TEXT);\n+        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+        clipboard.setContents(stringSelection, stringSelection);\n+\n+        int ctrlKey = Platform.isOSX() ? KeyEvent.VK_META : KeyEvent.VK_CONTROL;\n+        robot.keyPress(ctrlKey);\n+        robot.keyPress(KeyEvent.VK_V);\n+        robot.keyRelease(KeyEvent.VK_V);\n+        robot.keyRelease(ctrlKey);\n+\n+        robot.keyPress(KeyEvent.VK_ENTER);\n+        robot.keyRelease(KeyEvent.VK_ENTER);\n+    }\n+\n+    private static class BtnActionListener implements ActionListener {\n+        public void actionPerformed(ActionEvent evt) {\n+            String ac = evt.getActionCommand();\n+            if (CHANGE.equals(ac)) {\n+                tfPassword.setText(\"\");\n+                tfPassword.setEchoChar(NEW_ECHO_CHAR);\n+                tfPassword.requestFocus();\n+            }\n+            if (PRINT.equals(ac)) {\n+                if (!tfPassword.getText().equals(INITIAL_TEXT)) {\n+                    throw new RuntimeException(\"Test Failed!!!\"\n+                                               + \" Initial text not as expected\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/TextField\/SetEchoCharTest.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Label;\n+import java.awt.TextField;\n+import javax.swing.JPanel;\n+\n+import jdk.test.lib.Platform;\n+\n+\/*\n+ * @test\n+ * @bug 6191897\n+ * @summary Verifies that ctrl+left\/right does not move word-by-word in a TextField\n+ *          with echo character set\n+ * @library \/java\/awt\/regtesthelpers  \/test\/lib\n+ * @build PassFailJFrame jdk.test.lib.Platform\n+ * @run main\/manual SetEchoCharWordOpsTest\n+ *\/\n+\n+public class SetEchoCharWordOpsTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        String selectAllKey;\n+        String moveKeys;\n+        String selectKeys;\n+\n+        if (Platform.isOSX()) {\n+            selectAllKey = \"Cmd + A\";\n+            moveKeys = \"Alt + Right\/Left\";\n+            selectKeys = \"Shift + Alt + Right\/Left\";\n+        } else {\n+            selectAllKey = \"Ctrl + A\";\n+            moveKeys = \"Ctrl + Right\/Left\";\n+            selectKeys = \"Shift + Ctrl + Right\/Left\";\n+        }\n+\n+        String instructions =\n+                \"The password field (in the bottom panel) in this test contains\"\n+                 + \" a few words (3 words).\\n\"\n+                 + \"Move the focus to the text field and press \" + selectAllKey + \".\\n\"\n+                 + \"Try moving the caret word-by-word with \" + moveKeys + \" or\"\n+                 + \" extending selection with \" + selectKeys + \".\"\n+                 + \" You should NOT be able to do that.\\n\\n\"\n+                 + \"If you are able to move the caret word-by-word press FAIL,\"\n+                 + \" else press PASS.\";\n+\n+        PassFailJFrame.builder()\n+                      .title(\"SetEchoCharClipboard Instructions\")\n+                      .instructions(instructions)\n+                      .rows((int) instructions.lines().count() + 3)\n+                      .columns(45)\n+                      .splitUIBottom(SetEchoCharWordOpsTest::createAndShowUI)\n+                      .build()\n+                      .awaitAndCheck();\n+    }\n+\n+\n+    private static JPanel createAndShowUI() {\n+        JPanel jPanel = new JPanel();\n+        TextField tf = new TextField(\"one two three\", 15);\n+        Label tfLabel = new Label(\"Password Field:\");\n+\n+        jPanel.setLayout(new FlowLayout());\n+        tf.setEchoChar('*');\n+        jPanel.add(tfLabel);\n+        jPanel.add(tf);\n+        return jPanel;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/TextField\/SetEchoCharWordOpsTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,12 @@\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static java.awt.Event.KEY_ACTION;\n+import static java.awt.Event.KEY_ACTION_RELEASE;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n@@ -42,2 +54,2 @@\n-public class FunctionKeyTest {\n-    private static FunctionKeyTester frame;\n+public final class FunctionKeyTest {\n+    private static Frame frame;\n@@ -46,2 +58,2 @@\n-    static volatile boolean keyPressReceived;\n-    static volatile boolean keyReleaseReceived;\n+    private static final CyclicBarrier keyPress = new CyclicBarrier(2);\n+    private static final CyclicBarrier keyRelease = new CyclicBarrier(2);\n@@ -49,1 +61,1 @@\n-    static final StringBuilder failures = new StringBuilder();\n+    private static final CountDownLatch frameActivated = new CountDownLatch(1);\n@@ -51,3 +63,2 @@\n-    private static void testKey(int keyCode, String keyText) {\n-        keyPressReceived = false;\n-        keyReleaseReceived = false;\n+    private static final List<Error> failures = new ArrayList<>(4);\n+    private static final AtomicReference<Exception> edtException = new AtomicReference<>();\n@@ -55,0 +66,1 @@\n+    private static void testKey(int keyCode, String keyText) throws Exception {\n@@ -56,3 +68,5 @@\n-\n-        if (!keyPressReceived) {\n-            failures.append(keyText).append(\" key press is not received\\n\");\n+        try {\n+            keyPress.await(2, SECONDS);\n+        } catch (TimeoutException e) {\n+            keyPress.reset();\n+            failures.add(new Error(keyText + \" key press is not received\", e));\n@@ -62,3 +76,5 @@\n-\n-        if (!keyReleaseReceived) {\n-            failures.append(keyText).append(\" key release is not received\\n\");\n+        try {\n+            keyRelease.await(2, SECONDS);\n+        } catch (TimeoutException e) {\n+            keyRelease.reset();\n+            failures.add(new Error(keyText + \" key release is not received\", e));\n@@ -70,1 +86,0 @@\n-        robot.setAutoWaitForIdle(true);\n@@ -78,0 +93,7 @@\n+                frame.addWindowListener(new WindowAdapter() {\n+                    @Override\n+                    public void windowActivated(WindowEvent e) {\n+                        System.out.println(\"frame.windowActivated\");\n+                        frameActivated.countDown();\n+                    }\n+                });\n@@ -81,2 +103,4 @@\n-            robot.waitForIdle();\n-            robot.delay(1000);\n+            if (!frameActivated.await(2, SECONDS)) {\n+                throw new Error(\"Frame wasn't activated\");\n+            }\n+            robot.delay(100);\n@@ -94,4 +118,10 @@\n-        if (failures.isEmpty()) {\n-            System.out.println(\"Passed\");\n-        } else {\n-            throw new RuntimeException(failures.toString());\n+        if (!failures.isEmpty()) {\n+            System.err.println(\"Failures detected:\");\n+            failures.forEach(System.err::println);\n+            if (edtException.get() != null) {\n+                System.err.println(\"\\nException on EDT:\");\n+                edtException.get().printStackTrace();\n+            }\n+            System.err.println();\n+            throw new RuntimeException(\"Test failed: \" + failures.get(0).getMessage(),\n+                                       failures.get(0));\n@@ -99,2 +129,0 @@\n-    }\n-}\n@@ -102,15 +130,4 @@\n-class FunctionKeyTester extends Frame {\n-    Label l = new Label (\"NULL\");\n-    Button b = new Button();\n-    TextArea log = new TextArea();\n-\n-    FunctionKeyTester() {\n-        super(\"Function Key Test\");\n-        this.setLayout(new BorderLayout());\n-        this.add(BorderLayout.NORTH, l);\n-        this.add(BorderLayout.SOUTH, b);\n-        this.add(BorderLayout.CENTER, log);\n-        log.setFocusable(false);\n-        log.setEditable(false);\n-        l.setBackground(Color.red);\n-        setSize(200, 200);\n+        if (edtException.get() != null) {\n+            throw new RuntimeException(\"Test failed because of exception on EDT\",\n+                                       edtException.get());\n+        }\n@@ -119,8 +136,15 @@\n-    public boolean handleEvent(Event e) {\n-        String message = \"e.id=\" + e.id + \"\\n\";\n-        System.out.print(message);\n-        log.append(message);\n-\n-        switch (e.id) {\n-            case 403 -> FunctionKeyTest.keyPressReceived = true;\n-            case 404 -> FunctionKeyTest.keyReleaseReceived = true;\n+    private static final class FunctionKeyTester extends Frame {\n+        Label l = new Label (\"NULL\");\n+        Button b = new Button(\"button\");\n+        TextArea log = new TextArea();\n+\n+        FunctionKeyTester() {\n+            super(\"Function Key Test\");\n+            this.setLayout(new BorderLayout());\n+            this.add(BorderLayout.NORTH, l);\n+            this.add(BorderLayout.SOUTH, b);\n+            this.add(BorderLayout.CENTER, log);\n+            log.setFocusable(false);\n+            log.setEditable(false);\n+            l.setBackground(Color.red);\n+            setSize(200, 200);\n@@ -129,2 +153,19 @@\n-        return super.handleEvent(e);\n-    }\n+        @Override\n+        @SuppressWarnings(\"deprecation\")\n+        public boolean handleEvent(Event e) {\n+            String message = \"e.id=\" + e.id + \"\\n\";\n+            System.out.print(message);\n+            log.append(message);\n+\n+            try {\n+                switch (e.id) {\n+                    case KEY_ACTION\n+                            -> keyPress.await();\n+                    case KEY_ACTION_RELEASE\n+                            -> keyRelease.await();\n+                }\n+            } catch (Exception ex) {\n+                if (!edtException.compareAndSet(null, ex)) {\n+                    edtException.get().addSuppressed(ex);\n+                }\n+            }\n@@ -132,3 +173,9 @@\n-    public boolean keyDown(Event e, int key) {\n-        l.setText(\"e.key=\" + Integer.valueOf(e.key).toString());\n-        return false;\n+            return super.handleEvent(e);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"deprecation\")\n+        public boolean keyDown(Event e, int key) {\n+            l.setText(\"e.key=\" + e.key);\n+            return false;\n+        }\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/FunctionKeyTest.java","additions":99,"deletions":52,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+import static javax.swing.BorderFactory.createEmptyBorder;\n@@ -504,0 +505,1 @@\n+        text.setBorder(createEmptyBorder(4, 4, 4, 4));\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/PassFailJFrame.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -425,0 +425,3 @@\n+                    if (info1 == null) {\n+                        continue; \/\/ Missing thread, e.g. completed. Ignore.\n+                    }\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/Locks.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -117,0 +117,3 @@\n+        \/\/ output details of dual stack lookup by address\n+        System.out.println(\"dual stack lookup for addr \" + addr + \" returned IP address \" + ia);\n+        System.out.println(\" with hostname \" + name);\n","filename":"test\/jdk\/java\/net\/InetAddress\/ptr\/Lookup.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,2 @@\n-\n+        dprintln (\"sender endpoint = \" + s1.getLocalSocketAddress());\n+        dprintln (\"echo endpoint = \" + s2.getLocalSocketAddress());\n","filename":"test\/jdk\/java\/net\/ipv6tests\/Tests.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n- * @modules provider\n- * @build provider\/module-info provider\/spi.BazProvider\n+ * @build provider\/*\n@@ -41,0 +40,1 @@\n+        \/\/ check provider is providing BAZ via charsets()\n@@ -45,0 +45,4 @@\n+            \/\/ check provider is in a named module\n+            if (!bazCs.getClass().getModule().isNamed()) {\n+                throw new RuntimeException(\"BazProvider is not a named module\");\n+            }\n@@ -46,0 +50,1 @@\n+            \/\/ check BAZ cs aliases were loaded correctly\n@@ -49,0 +54,1 @@\n+            \/\/ check provider implements charsetForName()\n","filename":"test\/jdk\/java\/nio\/charset\/spi\/CharsetProviderAsModuleTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-    exports spi;\n","filename":"test\/jdk\/java\/nio\/charset\/spi\/provider\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 6863864\n+ * @bug 4313887 6838333 6863864 8340329\n@@ -48,1 +48,1 @@\n-     * Exercise createSymbolicLink and readLink methods\n+     * Exercise createSymbolicLink and readSymbolicLink methods\n@@ -134,0 +134,21 @@\n+\n+        \/\/ Check message of NotLinkException\n+        try {\n+            Files.createDirectory(mydir);\n+\n+            try {\n+                Path mytarget = Files.readSymbolicLink(mydir);\n+            } catch (NotLinkException expected) {\n+                String filename = mydir.getFileName().toString();\n+                String message = expected.getMessage();\n+                boolean okay = message.contains(filename);\n+                if (!okay) {\n+                    System.err.println(\"Message \\\"\" + message + \"\\\"\" +\n+                        \" does not contain the filename \\\"\" +\n+                        filename + \"\\\"\");\n+                    assertTrue(okay);\n+                }\n+            }\n+        } finally {\n+            Files.deleteIfExists(mydir);\n+        }\n","filename":"test\/jdk\/java\/nio\/file\/Files\/Links.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -228,1 +228,1 @@\n-                \"-Dswing.defaultlaf=\" + laf.getClassName(), \"-mx9m\",\n+                \"-Dswing.defaultlaf=\" + laf.getClassName(), \"-Xmx9m\",\n","filename":"test\/jdk\/javax\/swing\/UI\/UnninstallUIMemoryLeaks\/UnninstallUIMemoryLeaks.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4725045\n+ * @key headful\n+ * @summary verifies that there are no artifacts due to using\n+ * GDI for copies to the back buffer (GDI should only be used\n+ * for copies to the screen)\n+ * @run main GdiBlitOffscreenTest\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+public class GdiBlitOffscreenTest {\n+\n+    static volatile JFrame f;\n+    static final int imageW = 100, imageH = 100, FW = 500, FH = 500;\n+    static volatile BufferedImage greenImage;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ First, create an image.\n+        greenImage = new BufferedImage(imageW, imageH,\n+                                       BufferedImage.TYPE_INT_RGB);\n+        Graphics redG = greenImage.getGraphics();\n+        redG.setColor(Color.green);\n+        redG.fillRect(0, 0, imageW, imageH);\n+        redG.setColor(Color.white);\n+        redG.drawString(\"Passed!\", 30, 80);\n+\n+        Robot robot = new Robot();\n+        try {\n+            SwingUtilities.invokeAndWait(GdiBlitOffscreenTest::createUI);\n+            robot.delay(1000);\n+            robot.waitForIdle();\n+            Point p = f.getLocationOnScreen();\n+            Color c = robot.getPixelColor(p.x+FW\/2, p.y+FH\/2);\n+            if (!c.equals(Color.green)) {\n+                throw new RuntimeException(\"Color is \" + c);\n+            }\n+        } finally {\n+            if (f != null) {\n+                SwingUtilities.invokeAndWait(f::dispose);\n+            }\n+        }\n+    }\n+\n+    private static void createUI() {\n+        f = new JFrame(\"GdiBlitOffscreenTest\");\n+        f.setSize(FW, FH);\n+        f.setVisible(true);\n+\n+        \/\/ copy the image to the window.\n+        Graphics g = f.getGraphics();\n+        g.drawImage(greenImage, 0, 0, null);\n+\n+        \/\/ Now, get on with the rest of the test\n+        JComponent app = new GdiBlitOffscreenTestComponent(imageW, imageH, greenImage);\n+        app.setSize(500, 500);\n+        f.getContentPane().add(app);\n+        f.validate();\n+        f.repaint();\n+    }\n+}\n+\n+class GdiBlitOffscreenTestComponent extends JComponent {\n+\n+    int imageW, imageH;\n+    Image theImage;\n+\n+    public GdiBlitOffscreenTestComponent(int imageW, int imageH,\n+                                         Image theImage)\n+    {\n+        this.theImage = theImage;\n+        this.imageW = imageW;\n+        this.imageH = imageH;\n+    }\n+\n+    public void paintComponent(Graphics g) {\n+        int imageX = (getWidth() - imageW) \/ 2;\n+        int imageY = (getHeight() - imageH) \/ 2;\n+        g.setColor(Color.blue);\n+        g.fillRect(0, 0, getWidth(), getHeight());\n+        g.setColor(Color.red);\n+        g.fillRect(imageX, imageY, imageW, imageH);\n+        g.setColor(Color.white);\n+        g.drawString(\"Failed!\", imageX + 30, imageY + 80);\n+        g.drawImage(theImage, imageX, imageY, null);\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/java2d\/GdiRendering\/GdiBlitOffscreenTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4693644\n+ * @summary verifies that there are no artifacts due to copying with GDI\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual GdiLockTest\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+\n+public class GdiLockTest {\n+\n+        static final String INSTRUCTIONS = \"\"\"\n+            A window will open up next to these instructions.\n+            The text you see in that window should blink on and off.\n+            If it never disappears, then the test has failed.\n+        \"\"\";\n+\n+    public static void main(String[] argv) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"GdiLockTest\")\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(5)\n+                .rows(5)\n+                .columns(45)\n+                .testUI(GdiLockTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame f = new Frame(\"GdiLockTest\");\n+        f.setSize(300, 300);\n+        GdiLockTestComponent test = new GdiLockTestComponent();\n+        Thread t = new Thread(test);\n+        f.add(test);\n+        t.start();\n+        return f;\n+    }\n+}\n+\n+class GdiLockTestComponent extends Component implements Runnable {\n+\n+    boolean textVisible = true;\n+\n+    public void paint(Graphics g) {\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, getWidth(), getHeight());\n+        g.setColor(Color.black);\n+        if (!textVisible) {\n+            g.setClip(200, 200, 300, 300);\n+        }\n+        g.drawString(\"This text should be blinking\", 10, 30);\n+        if (!textVisible) {\n+            g.setClip(0, 0, getWidth(), getHeight());\n+        }\n+    }\n+\n+    public void run() {\n+        while (true) {\n+            repaint();\n+            textVisible = !textVisible;\n+            try {\n+                Thread.sleep(500);\n+            } catch (Exception e) {}\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/GdiRendering\/GdiLockTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4515761\n+ * @summary verify that drawRoundRect produces correct output for 0 w\/h\n+ *\/\n+\n+import java.awt.Color;\n+import static java.awt.Color.*;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+\n+public class DrawRoundRect0Bug {\n+\n+    public static void main(String argv[]) {\n+        BufferedImage img = new BufferedImage(250, 250, BufferedImage.TYPE_INT_RGB);\n+        Graphics2D g = img.createGraphics();\n+\n+        g.setColor(white);\n+        g.fillRect(0, 0, img.getWidth(), img.getHeight());\n+\n+        g.setColor(green);\n+        g.drawLine(150, 90, 150, 110);\n+        if (img.getRGB(150, 100) != green.getRGB()) {\n+            throw new RuntimeException(\"Vertical line not green\");\n+        }\n+\n+        g.setColor(blue);\n+        g.drawRoundRect(160, 90, 0, 20, 4, 4);\n+        if (img.getRGB(160, 100) != blue.getRGB()) {\n+            throw new RuntimeException(\"Vertical (ie zero width) round rect not blue\");\n+        }\n+\n+        g.setColor(green);\n+        g.drawLine(150, 140, 170, 140);\n+        if (img.getRGB(160, 140) != green.getRGB()) {\n+            throw new RuntimeException(\"Horizontal line not green\");\n+        }\n+\n+        g.setColor(blue);\n+        g.drawRoundRect(150, 150, 20, 0, 4, 4);\n+        if (img.getRGB(160, 150) != blue.getRGB()) {\n+            throw new RuntimeException(\"Horizontal (ie zero height) round rect not blue\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/java2d\/SunGraphics2D\/DrawRoundRect0Bug.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4652373\n+ * @summary verify that SunGraphics2D survives surface revalidation\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual RevalidateBug\n+ * @requires (os.family == \"windows\")\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+\n+public class RevalidateBug {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        This bug only reproduces on Windows systems with a task manager that can lock the computer.\n+\n+        This test draws a grayscale gradient in a window.\n+\n+        After the gradient becomes visible above, use ctrl-alt-del to bring up\n+        the task manager and lock the computer.\n+        Then unlock the computer and the gradient should be repainted to pass.\n+\n+        If the gradient does not appear after unlocking (or if the test gets\n+        an error on its own after unlocking the computer) then it fails.\n+        \"\"\";\n+\n+    public static void main(String[] argv) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"RevalidateBug\")\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(5)\n+                .rows(12)\n+                .columns(50)\n+                .testUI(RevalidateBug::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static JFrame createUI() {\n+\n+        JComponent comp = new JComponent() {\n+\n+            protected void paintComponent(Graphics g) {\n+                super.paintComponent(g);\n+                System.out.println(\"paintComponent\");\n+                Graphics2D g2d = (Graphics2D) g;\n+\n+                Insets insets = getInsets();\n+                Rectangle rect =\n+                    new Rectangle(insets.left, insets.top,\n+                                  getWidth() - insets.right - insets.left,\n+                                  getHeight() - insets.top - insets.bottom);\n+                g2d.setPaint(new GradientPaint(rect.x, rect.y, Color.white,\n+                                               rect.x + rect.width, rect.y, Color.black));\n+\n+                System.out.println(rect + \" w:\" + getWidth() + \" h:\"+getHeight());\n+\n+                g2d.fillRect(0, 0, getWidth(), getHeight());\n+            }\n+\n+            public Dimension getPreferredSize() {\n+                return new Dimension(500, 500);\n+            }\n+        };\n+\n+        JFrame f = new JFrame(\"RevalidateTest\");\n+        f.add(comp);\n+        f.pack();\n+        return f;\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/java2d\/SunGraphics2D\/RevalidateBug.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4516037\n+ * @summary verify that scaled Polygons honor the transform\n+ *\/\n+\n+import java.awt.Color;\n+import static java.awt.Color.*;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.image.BufferedImage;\n+\n+public class ScaledPolyTest {\n+\n+    public static void main(String[] args) {\n+\n+        Polygon poly = new Polygon();\n+        poly.addPoint(20, 10);\n+        poly.addPoint(30, 30);\n+        poly.addPoint(10, 30);\n+        poly.addPoint(20, 10);\n+\n+        int height = 300;\n+        int width = 300;\n+        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n+        Graphics2D g2d = bi.createGraphics();\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, bi.getWidth(), bi.getHeight());\n+\n+        g2d.translate(10, 10);\n+        g2d.scale(2, 2);\n+        g2d.setColor(Color.yellow);\n+        g2d.fill(poly);\n+        g2d.setColor(Color.blue);\n+        g2d.draw(poly);\n+\n+        \/*\n+         * Examine each row of the image.\n+         * If the stroked polygon is correctly aligned on the filled polygon,\n+         * if there is anything except white on the line,\n+         * the transition will always be white+->blue+->yellow*->blue*->white+\n+         *\/\n+        int bluePix = blue.getRGB();\n+        int yellowPix = yellow.getRGB();\n+        int whitePix = white.getRGB();\n+        for (int y = 0; y < height; y++ ) {\n+            int x = 0;\n+            int pix = whitePix;\n+\n+            while (pix == whitePix && x < width) pix = bi.getRGB(x++, y);\n+            if (pix == whitePix && x == width) continue; \/\/ all white row.\n+\n+            if (pix != bluePix) throw new RuntimeException(\"Expected blue\");\n+\n+            while (pix == bluePix) pix = bi.getRGB(x++, y);\n+\n+            if (pix == yellowPix) {\n+               while (pix == yellowPix) pix = bi.getRGB(x++, y);\n+               if (pix != bluePix) throw new RuntimeException(\"Expected blue\");\n+               while (pix == bluePix) pix = bi.getRGB(x++, y);\n+               if (pix != whitePix) throw new RuntimeException(\"Expected white\");\n+            }\n+\n+            while (pix == whitePix && x < width) pix = bi.getRGB(x++, y);\n+            if (pix == whitePix && x == width) {\n+                continue;\n+            } else {\n+                throw new RuntimeException(\"Expected white to finish the row\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/SunGraphics2D\/ScaledPolyTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}