{"files":[{"patch":"@@ -4592,1 +4592,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -4656,0 +4656,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -4686,0 +4687,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -5395,1 +5397,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_QVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8194,0 +8196,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8367,1 +8370,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8386,1 +8389,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8405,1 +8408,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8425,1 +8428,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8445,1 +8448,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8464,1 +8467,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8483,1 +8486,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8502,1 +8505,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8870,1 +8873,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8893,1 +8896,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8916,1 +8919,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8939,1 +8942,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9039,1 +9042,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9062,1 +9065,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9087,1 +9090,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9110,1 +9113,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10555,1 +10558,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10582,1 +10585,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10725,1 +10728,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10752,1 +10755,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10895,1 +10898,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10922,1 +10925,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10949,1 +10952,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10976,1 +10979,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11003,1 +11006,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11030,1 +11033,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11057,1 +11060,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11085,1 +11088,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11112,1 +11115,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11378,1 +11381,0 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11393,1 +11395,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11407,1 +11409,0 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11422,1 +11423,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11542,1 +11543,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11571,0 +11572,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11597,0 +11599,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11623,0 +11626,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11649,0 +11653,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12017,0 +12022,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12042,0 +12048,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12071,0 +12078,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12099,0 +12107,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12126,0 +12135,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12152,0 +12162,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12180,0 +12191,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12207,0 +12219,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12577,1 +12590,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12642,1 +12655,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12670,1 +12683,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -14855,1 +14868,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -14864,1 +14877,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -16446,1 +16459,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16467,1 +16480,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16488,1 +16501,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16509,1 +16522,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16530,1 +16543,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16551,1 +16564,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":60,"deletions":47,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2910,0 +2936,106 @@\n+    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINByte128VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte128VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void minByte128VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte128VectorTests::min);\n+    }\n+\n+    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MINByte128VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte128VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXByte128VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte128VectorTests::MAX);\n+    }\n+\n+    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void maxByte128VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte128VectorTests::max);\n+    }\n+\n+    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MAXByte128VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2910,0 +2936,106 @@\n+    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINByte256VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte256VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void minByte256VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte256VectorTests::min);\n+    }\n+\n+    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MINByte256VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte256VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXByte256VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte256VectorTests::MAX);\n+    }\n+\n+    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void maxByte256VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte256VectorTests::max);\n+    }\n+\n+    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MAXByte256VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2910,0 +2936,106 @@\n+    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINByte512VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte512VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void minByte512VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte512VectorTests::min);\n+    }\n+\n+    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MINByte512VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte512VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXByte512VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte512VectorTests::MAX);\n+    }\n+\n+    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void maxByte512VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte512VectorTests::max);\n+    }\n+\n+    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MAXByte512VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2910,0 +2936,106 @@\n+    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINByte64VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte64VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void minByte64VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte64VectorTests::min);\n+    }\n+\n+    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MINByte64VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte64VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXByte64VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte64VectorTests::MAX);\n+    }\n+\n+    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void maxByte64VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte64VectorTests::max);\n+    }\n+\n+    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MAXByte64VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte64VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -424,0 +424,11 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -463,0 +474,15 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2915,0 +2941,106 @@\n+    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINByteMaxVectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, ByteMaxVectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void minByteMaxVectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, ByteMaxVectorTests::min);\n+    }\n+\n+    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MINByteMaxVectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, ByteMaxVectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXByteMaxVectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, ByteMaxVectorTests::MAX);\n+    }\n+\n+    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void maxByteMaxVectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, ByteMaxVectorTests::max);\n+    }\n+\n+    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MAXByteMaxVectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, ByteMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2027,0 +2053,106 @@\n+    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINDouble128VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double128VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void minDouble128VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double128VectorTests::min);\n+    }\n+\n+    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MINDouble128VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double128VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXDouble128VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double128VectorTests::MAX);\n+    }\n+\n+    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void maxDouble128VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double128VectorTests::max);\n+    }\n+\n+    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MAXDouble128VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2027,0 +2053,106 @@\n+    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINDouble256VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double256VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void minDouble256VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double256VectorTests::min);\n+    }\n+\n+    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MINDouble256VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double256VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXDouble256VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double256VectorTests::MAX);\n+    }\n+\n+    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void maxDouble256VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double256VectorTests::max);\n+    }\n+\n+    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MAXDouble256VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2027,0 +2053,106 @@\n+    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINDouble512VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double512VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void minDouble512VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double512VectorTests::min);\n+    }\n+\n+    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MINDouble512VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double512VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXDouble512VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double512VectorTests::MAX);\n+    }\n+\n+    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void maxDouble512VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double512VectorTests::max);\n+    }\n+\n+    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MAXDouble512VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2027,0 +2053,106 @@\n+    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINDouble64VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double64VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void minDouble64VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double64VectorTests::min);\n+    }\n+\n+    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MINDouble64VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double64VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXDouble64VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double64VectorTests::MAX);\n+    }\n+\n+    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void maxDouble64VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double64VectorTests::max);\n+    }\n+\n+    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MAXDouble64VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double64VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -442,0 +442,11 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -481,0 +492,15 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2032,0 +2058,106 @@\n+    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINDoubleMaxVectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, DoubleMaxVectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void minDoubleMaxVectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, DoubleMaxVectorTests::min);\n+    }\n+\n+    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MINDoubleMaxVectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, DoubleMaxVectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXDoubleMaxVectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, DoubleMaxVectorTests::MAX);\n+    }\n+\n+    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void maxDoubleMaxVectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, DoubleMaxVectorTests::max);\n+    }\n+\n+    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MAXDoubleMaxVectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, DoubleMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2038,0 +2064,106 @@\n+    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINFloat128VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float128VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void minFloat128VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float128VectorTests::min);\n+    }\n+\n+    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MINFloat128VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float128VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXFloat128VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float128VectorTests::MAX);\n+    }\n+\n+    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void maxFloat128VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float128VectorTests::max);\n+    }\n+\n+    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MAXFloat128VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2038,0 +2064,106 @@\n+    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINFloat256VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float256VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void minFloat256VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float256VectorTests::min);\n+    }\n+\n+    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MINFloat256VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float256VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXFloat256VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float256VectorTests::MAX);\n+    }\n+\n+    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void maxFloat256VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float256VectorTests::max);\n+    }\n+\n+    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MAXFloat256VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2038,0 +2064,106 @@\n+    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINFloat512VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float512VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void minFloat512VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float512VectorTests::min);\n+    }\n+\n+    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MINFloat512VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float512VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXFloat512VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float512VectorTests::MAX);\n+    }\n+\n+    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void maxFloat512VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float512VectorTests::max);\n+    }\n+\n+    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MAXFloat512VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2038,0 +2064,106 @@\n+    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINFloat64VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float64VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void minFloat64VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float64VectorTests::min);\n+    }\n+\n+    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MINFloat64VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float64VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXFloat64VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float64VectorTests::MAX);\n+    }\n+\n+    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void maxFloat64VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float64VectorTests::max);\n+    }\n+\n+    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MAXFloat64VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float64VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -442,0 +442,11 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -481,0 +492,15 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2043,0 +2069,106 @@\n+    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINFloatMaxVectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, FloatMaxVectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void minFloatMaxVectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, FloatMaxVectorTests::min);\n+    }\n+\n+    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MINFloatMaxVectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, FloatMaxVectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXFloatMaxVectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, FloatMaxVectorTests::MAX);\n+    }\n+\n+    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void maxFloatMaxVectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, FloatMaxVectorTests::max);\n+    }\n+\n+    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MAXFloatMaxVectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, FloatMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2954,0 +2980,106 @@\n+    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINInt128VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int128VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void minInt128VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int128VectorTests::min);\n+    }\n+\n+    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MINInt128VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int128VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXInt128VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int128VectorTests::MAX);\n+    }\n+\n+    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void maxInt128VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int128VectorTests::max);\n+    }\n+\n+    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MAXInt128VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2954,0 +2980,106 @@\n+    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINInt256VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int256VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void minInt256VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int256VectorTests::min);\n+    }\n+\n+    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MINInt256VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int256VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXInt256VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int256VectorTests::MAX);\n+    }\n+\n+    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void maxInt256VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int256VectorTests::max);\n+    }\n+\n+    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MAXInt256VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2954,0 +2980,106 @@\n+    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINInt512VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int512VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void minInt512VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int512VectorTests::min);\n+    }\n+\n+    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MINInt512VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int512VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXInt512VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int512VectorTests::MAX);\n+    }\n+\n+    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void maxInt512VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int512VectorTests::max);\n+    }\n+\n+    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MAXInt512VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2953,0 +2979,106 @@\n+\n+    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINInt64VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int64VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void minInt64VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int64VectorTests::min);\n+    }\n+\n+    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MINInt64VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int64VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXInt64VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int64VectorTests::MAX);\n+    }\n+\n+    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void maxInt64VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int64VectorTests::max);\n+    }\n+\n+    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MAXInt64VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int64VectorTests::MAX);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -424,0 +424,11 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -463,0 +474,15 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2959,0 +2985,106 @@\n+    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINIntMaxVectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, IntMaxVectorTests::MIN);\n+    }\n+\n+    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void minIntMaxVectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, IntMaxVectorTests::min);\n+    }\n+\n+    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MINIntMaxVectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, IntMaxVectorTests::MIN);\n+    }\n+\n+    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXIntMaxVectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, IntMaxVectorTests::MAX);\n+    }\n+\n+    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void maxIntMaxVectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, IntMaxVectorTests::max);\n+    }\n+\n+    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MAXIntMaxVectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, IntMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -376,0 +376,11 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -415,0 +426,15 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2976,0 +3002,106 @@\n+    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINLong128VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long128VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void minLong128VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long128VectorTests::min);\n+    }\n+\n+    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MINLong128VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long128VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXLong128VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long128VectorTests::MAX);\n+    }\n+\n+    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void maxLong128VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long128VectorTests::max);\n+    }\n+\n+    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MAXLong128VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -376,0 +376,11 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -415,0 +426,15 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2976,0 +3002,106 @@\n+    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINLong256VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long256VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void minLong256VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long256VectorTests::min);\n+    }\n+\n+    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MINLong256VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long256VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXLong256VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long256VectorTests::MAX);\n+    }\n+\n+    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void maxLong256VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long256VectorTests::max);\n+    }\n+\n+    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MAXLong256VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -376,0 +376,11 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -415,0 +426,15 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2976,0 +3002,106 @@\n+    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINLong512VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long512VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void minLong512VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long512VectorTests::min);\n+    }\n+\n+    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MINLong512VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long512VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXLong512VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long512VectorTests::MAX);\n+    }\n+\n+    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void maxLong512VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long512VectorTests::max);\n+    }\n+\n+    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MAXLong512VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -376,0 +376,11 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -415,0 +426,15 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2976,0 +3002,106 @@\n+    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINLong64VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long64VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void minLong64VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long64VectorTests::min);\n+    }\n+\n+    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MINLong64VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long64VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXLong64VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long64VectorTests::MAX);\n+    }\n+\n+    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void maxLong64VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long64VectorTests::max);\n+    }\n+\n+    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MAXLong64VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long64VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -381,0 +381,11 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -420,0 +431,15 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2981,0 +3007,106 @@\n+    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINLongMaxVectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, LongMaxVectorTests::MIN);\n+    }\n+\n+    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void minLongMaxVectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, LongMaxVectorTests::min);\n+    }\n+\n+    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MINLongMaxVectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, LongMaxVectorTests::MIN);\n+    }\n+\n+    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXLongMaxVectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, LongMaxVectorTests::MAX);\n+    }\n+\n+    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void maxLongMaxVectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, LongMaxVectorTests::max);\n+    }\n+\n+    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MAXLongMaxVectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, LongMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2901,0 +2927,106 @@\n+    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINShort128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short128VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minShort128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short128VectorTests::min);\n+    }\n+\n+    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINShort128VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short128VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXShort128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short128VectorTests::MAX);\n+    }\n+\n+    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxShort128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short128VectorTests::max);\n+    }\n+\n+    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXShort128VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2901,0 +2927,106 @@\n+    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINShort256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short256VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minShort256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short256VectorTests::min);\n+    }\n+\n+    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINShort256VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short256VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXShort256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short256VectorTests::MAX);\n+    }\n+\n+    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxShort256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short256VectorTests::max);\n+    }\n+\n+    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXShort256VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2901,0 +2927,106 @@\n+    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINShort512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short512VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minShort512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short512VectorTests::min);\n+    }\n+\n+    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINShort512VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short512VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXShort512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short512VectorTests::MAX);\n+    }\n+\n+    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxShort512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short512VectorTests::max);\n+    }\n+\n+    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXShort512VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2901,0 +2927,106 @@\n+    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINShort64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short64VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minShort64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short64VectorTests::min);\n+    }\n+\n+    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINShort64VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short64VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXShort64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short64VectorTests::MAX);\n+    }\n+\n+    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxShort64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short64VectorTests::max);\n+    }\n+\n+    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXShort64VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short64VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -424,0 +424,11 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -463,0 +474,15 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2906,0 +2932,106 @@\n+    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINShortMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, ShortMaxVectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minShortMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, ShortMaxVectorTests::min);\n+    }\n+\n+    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINShortMaxVectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, ShortMaxVectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXShortMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, ShortMaxVectorTests::MAX);\n+    }\n+\n+    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxShortMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, ShortMaxVectorTests::max);\n+    }\n+\n+    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXShortMaxVectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, ShortMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+binary_memop=\"Binary-mem-op\"\n+binary_masked_memop=\"Binary-Masked-mem-op\"\n@@ -258,0 +260,6 @@\n+function gen_binary_alu_mem_op {\n+  echo \"Generating binary op $1 ($2)...\"\n+  gen_op_tmpl $binary_memop \"$@\"\n+  gen_op_tmpl $binary_masked_memop \"$@\"\n+}\n+\n@@ -467,0 +475,4 @@\n+# Binary operation with one memory operand\n+gen_binary_alu_mem_op \"MIN+min+withMask\", \"Math.min(a, b)\"\n+gen_binary_alu_mem_op \"MAX+max+withMask\", \"Math.max(a, b)\"\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.[[TEST]], bv_[[TEST]]_M, vmask).intoArray(r, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-Masked-mem-op.template","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.[[TEST]], bv_[[TEST]]).intoArray(r, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-mem-op.template","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+\n+    static $abstractvectortype$ bv_[[TEST]]_M = $abstractvectortype$.broadcast(SPECIES, ($type$)10);\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void [[TEST]]$vectorteststype$MaskedWithMemOp(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, ($type$)10, mask, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-Masked-mem-op.template","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+\n+    static $abstractvectortype$ bv_[[TEST]] = $abstractvectortype$.broadcast(SPECIES, ($type$)10);\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$WithMemOp(IntFunction<$type$[]> fa) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, ($type$)10, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-mem-op.template","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -516,0 +516,11 @@\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$ b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -555,0 +566,15 @@\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$ b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$ b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}