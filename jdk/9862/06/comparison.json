{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2387,1 +2387,4 @@\n-                    String name = cf.constant_pool.getUTF8Value(e.name_index);\n+                    String name = null;\n+                    if (e.name_index != 0) {\n+                        name = cf.constant_pool.getUTF8Value(e.name_index);\n+                    }\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -196,1 +196,7 @@\n-    int[] parameterNameIndices;\n+    int[] parameterNameIndicesLvt;\n+\n+    \/**\n+     * A table to hold the constant pool indices for method parameter\n+     * names, as given in the MethodParameters attribute.\n+     *\/\n+    int[] parameterNameIndicesMp;\n@@ -223,12 +229,0 @@\n-    \/**\n-     * Whether or not any parameter names have been found.\n-     *\/\n-    boolean haveParameterNameIndices;\n-\n-    \/** Set this to false every time we start reading a method\n-     * and are saving parameter names.  Set it to true when we see\n-     * MethodParameters, if it's set when we see a LocalVariableTable,\n-     * then we ignore the parameter names from the LVT.\n-     *\/\n-    boolean sawMethodParameters;\n-\n@@ -899,1 +893,1 @@\n-                    if (saveParameterNames && !sawMethodParameters) {\n+                    if (saveParameterNames) {\n@@ -918,1 +912,1 @@\n-                                if (register >= parameterNameIndices.length) {\n+                                if (register >= parameterNameIndicesLvt.length) {\n@@ -920,3 +914,3 @@\n-                                            Math.max(register + 1, parameterNameIndices.length + 8);\n-                                    parameterNameIndices =\n-                                            Arrays.copyOf(parameterNameIndices, newSize);\n+                                            Math.max(register + 1, parameterNameIndicesLvt.length + 8);\n+                                    parameterNameIndicesLvt =\n+                                            Arrays.copyOf(parameterNameIndicesLvt, newSize);\n@@ -924,2 +918,1 @@\n-                                parameterNameIndices[register] = nameIndex;\n-                                haveParameterNameIndices = true;\n+                                parameterNameIndicesLvt[register] = nameIndex;\n@@ -1076,1 +1069,0 @@\n-                        sawMethodParameters = true;\n@@ -1078,1 +1070,1 @@\n-                        parameterNameIndices = new int[numEntries];\n+                        parameterNameIndicesMp = new int[numEntries];\n@@ -1080,1 +1072,0 @@\n-                        haveParameterNameIndices = true;\n@@ -1088,1 +1079,1 @@\n-                            parameterNameIndices[index] = nameIndex;\n+                            parameterNameIndicesMp[index] = nameIndex;\n@@ -2346,3 +2337,3 @@\n-        if (parameterNameIndices == null\n-                || parameterNameIndices.length < expectedParameterSlots) {\n-            parameterNameIndices = new int[expectedParameterSlots];\n+        if (parameterNameIndicesLvt == null\n+                || parameterNameIndicesLvt.length < expectedParameterSlots) {\n+            parameterNameIndicesLvt = new int[expectedParameterSlots];\n@@ -2350,3 +2341,1 @@\n-            Arrays.fill(parameterNameIndices, 0);\n-        haveParameterNameIndices = false;\n-        sawMethodParameters = false;\n+            Arrays.fill(parameterNameIndicesLvt, 0);\n@@ -2367,33 +2356,28 @@\n-        \/\/ If we get parameter names from MethodParameters, then we\n-        \/\/ don't need to skip.\n-        int firstParam = 0;\n-        if (!sawMethodParameters) {\n-            firstParam = ((sym.flags() & STATIC) == 0) ? 1 : 0;\n-            \/\/ the code in readMethod may have skipped the first\n-            \/\/ parameter when setting up the MethodType. If so, we\n-            \/\/ make a corresponding allowance here for the position of\n-            \/\/ the first parameter.  Note that this assumes the\n-            \/\/ skipped parameter has a width of 1 -- i.e. it is not\n-            \/\/ a double width type (long or double.)\n-            if (sym.name == names.init && currentOwner.hasOuterInstance()) {\n-                \/\/ Sometimes anonymous classes don't have an outer\n-                \/\/ instance, however, there is no reliable way to tell so\n-                \/\/ we never strip this$n\n-                if (!currentOwner.name.isEmpty())\n-                    firstParam += 1;\n-            }\n-\n-            if (sym.type != jvmType) {\n-                \/\/ reading the method attributes has caused the\n-                \/\/ symbol's type to be changed. (i.e. the Signature\n-                \/\/ attribute.)  This may happen if there are hidden\n-                \/\/ (synthetic) parameters in the descriptor, but not\n-                \/\/ in the Signature.  The position of these hidden\n-                \/\/ parameters is unspecified; for now, assume they are\n-                \/\/ at the beginning, and so skip over them. The\n-                \/\/ primary case for this is two hidden parameters\n-                \/\/ passed into Enum constructors.\n-                int skip = Code.width(jvmType.getParameterTypes())\n-                        - Code.width(sym.type.getParameterTypes());\n-                firstParam += skip;\n-            }\n+        int firstParamLvt = ((sym.flags() & STATIC) == 0) ? 1 : 0;\n+        \/\/ the code in readMethod may have skipped the first\n+        \/\/ parameter when setting up the MethodType. If so, we\n+        \/\/ make a corresponding allowance here for the position of\n+        \/\/ the first parameter.  Note that this assumes the\n+        \/\/ skipped parameter has a width of 1 -- i.e. it is not\n+        \/\/ a double width type (long or double.)\n+        if (sym.name == names.init && currentOwner.hasOuterInstance()) {\n+            \/\/ Sometimes anonymous classes don't have an outer\n+            \/\/ instance, however, there is no reliable way to tell so\n+            \/\/ we never strip this$n\n+            if (!currentOwner.name.isEmpty())\n+                firstParamLvt += 1;\n+        }\n+\n+        if (sym.type != jvmType) {\n+            \/\/ reading the method attributes has caused the\n+            \/\/ symbol's type to be changed. (i.e. the Signature\n+            \/\/ attribute.)  This may happen if there are hidden\n+            \/\/ (synthetic) parameters in the descriptor, but not\n+            \/\/ in the Signature.  The position of these hidden\n+            \/\/ parameters is unspecified; for now, assume they are\n+            \/\/ at the beginning, and so skip over them. The\n+            \/\/ primary case for this is two hidden parameters\n+            \/\/ passed into Enum constructors.\n+            int skip = Code.width(jvmType.getParameterTypes())\n+                    - Code.width(sym.type.getParameterTypes());\n+            firstParamLvt += skip;\n@@ -2403,1 +2387,7 @@\n-        int nameIndex = firstParam;\n+        \/\/ we maintain two index pointers, one for the LocalVariableTable attribute\n+        \/\/ and the other for the MethodParameters attribute.\n+        \/\/ This is needed as the MethodParameters attribute may contain\n+        \/\/ name_index = 0 in which case we want to fall back to the LocalVariableTable.\n+        \/\/ In such case, we still want to read the flags from the MethodParameters with that index.\n+        int nameIndexLvt = firstParamLvt;\n+        int nameIndexMp = 0;\n@@ -2406,1 +2396,1 @@\n-            VarSymbol param = parameter(nameIndex, t, sym, paramNames);\n+            VarSymbol param = parameter(nameIndexMp, nameIndexLvt, t, sym, paramNames);\n@@ -2415,1 +2405,2 @@\n-            nameIndex += sawMethodParameters ? 1 : Code.width(t);\n+            nameIndexLvt += Code.width(t);\n+            nameIndexMp++;\n@@ -2424,1 +2415,2 @@\n-        parameterNameIndices = null;\n+        parameterNameIndicesLvt = null;\n+        parameterNameIndicesMp = null;\n@@ -2428,5 +2420,9 @@\n-\n-    \/\/ Returns the name for the parameter at position 'index', either using\n-    \/\/ names read from the MethodParameters, or by synthesizing a name that\n-    \/\/ is not on the 'exclude' list.\n-    private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set<Name> exclude) {\n+    \/**\n+     * Creates the parameter at the position {@code mpIndex} in the parameter list of the owning method.\n+     * Flags are optionally read from the MethodParameters attribute.\n+     * Names are optionally read from the MethodParameters attribute. If the constant pool index\n+     * of the name is 0, then the name is optionally read from the LocalVariableTable attribute.\n+     * @param mpIndex the index of the parameter in the MethodParameters attribute\n+     * @param lvtIndex the index of the parameter in the LocalVariableTable attribute\n+     *\/\n+    private VarSymbol parameter(int mpIndex, int lvtIndex, Type t, MethodSymbol owner, Set<Name> exclude) {\n@@ -2435,7 +2431,12 @@\n-        if (parameterAccessFlags != null && index < parameterAccessFlags.length\n-                && parameterAccessFlags[index] != 0) {\n-            flags |= parameterAccessFlags[index];\n-        }\n-        if (parameterNameIndices != null && index < parameterNameIndices.length\n-                && parameterNameIndices[index] != 0) {\n-            argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);\n+        if (parameterAccessFlags != null && mpIndex < parameterAccessFlags.length\n+                && parameterAccessFlags[mpIndex] != 0) {\n+            flags |= parameterAccessFlags[mpIndex];\n+        }\n+        if (parameterNameIndicesMp != null\n+                \/\/ if name_index is 0, then we might still get a name from the LocalVariableTable\n+                && parameterNameIndicesMp[mpIndex] != 0) {\n+            argName = optPoolEntry(parameterNameIndicesMp[mpIndex], poolReader::getName, names.empty);\n+            flags |= NAME_FILLED;\n+        } else if (parameterNameIndicesLvt != null && lvtIndex < parameterNameIndicesLvt.length\n+                && parameterNameIndicesLvt[lvtIndex] != 0) {\n+            argName = optPoolEntry(parameterNameIndicesLvt[lvtIndex], poolReader::getName, names.empty);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":80,"deletions":79,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -386,1 +385,1 @@\n-    int writeMethodParametersAttr(MethodSymbol m) {\n+    int writeMethodParametersAttr(MethodSymbol m, boolean writeParamNames) {\n@@ -397,1 +396,4 @@\n-                databuf.appendChar(poolWriter.putName(s.name));\n+                if (writeParamNames)\n+                    databuf.appendChar(poolWriter.putName(s.name));\n+                else\n+                    databuf.appendChar(0);\n@@ -405,1 +407,4 @@\n-                databuf.appendChar(poolWriter.putName(s.name));\n+                if (writeParamNames)\n+                    databuf.appendChar(poolWriter.putName(s.name));\n+                else\n+                    databuf.appendChar(0);\n@@ -413,1 +418,4 @@\n-                databuf.appendChar(poolWriter.putName(s.name));\n+                if (writeParamNames)\n+                    databuf.appendChar(poolWriter.putName(s.name));\n+                else\n+                    databuf.appendChar(0);\n@@ -1012,3 +1020,6 @@\n-        if (target.hasMethodParameters() && (options.isSet(PARAMETERS) || m.isConstructor() && (m.flags_field & RECORD) != 0)) {\n-            if (!m.isLambdaMethod()) \/\/ Per JDK-8138729, do not emit parameters table for lambda bodies.\n-                acount += writeMethodParametersAttr(m);\n+        if (target.hasMethodParameters()) {\n+            if (!m.isLambdaMethod()) { \/\/ Per JDK-8138729, do not emit parameters table for lambda bodies.\n+                boolean requiresParamNames = requiresParamNames(m);\n+                if (requiresParamNames || requiresParamFlags(m))\n+                    acount += writeMethodParametersAttr(m, requiresParamNames);\n+            }\n@@ -1023,0 +1034,19 @@\n+    private boolean requiresParamNames(MethodSymbol m) {\n+        if (options.isSet(PARAMETERS))\n+            return true;\n+        if (m.isConstructor() && (m.flags_field & RECORD) != 0)\n+            return true;\n+        return false;\n+    }\n+\n+    private boolean requiresParamFlags(MethodSymbol m) {\n+        if (!m.extraParams.isEmpty()) {\n+            return m.extraParams.stream().anyMatch(p -> (p.flags_field & (SYNTHETIC | MANDATED)) != 0);\n+        }\n+        if (m.params != null) {\n+            \/\/ parameter is stored in params for Enum#valueOf(name)\n+            return m.params.stream().anyMatch(p -> (p.flags_field & (SYNTHETIC | MANDATED)) != 0);\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":39,"deletions":9,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4135,1 +4135,1 @@\n-                                .VarDef(F.Modifiers(Flags.PARAMETER | Flags.GENERATED_MEMBER | param.mods.flags & Flags.VARARGS,\n+                                .VarDef(F.Modifiers(Flags.PARAMETER | Flags.GENERATED_MEMBER | Flags.MANDATED | param.mods.flags & Flags.VARARGS,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.Parameter;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8292275\n+ * @summary Test required flags on parameters\n+ * @compile RequiredMethodParameterFlagTest.java\n+ * @run junit RequiredMethodParameterFlagTest\n+ *\/\n+class RequiredMethodParameterFlagTest {\n+\n+    private static final Set<AccessFlag> CHECKED_FLAGS = Set.of(AccessFlag.MANDATED, AccessFlag.SYNTHETIC);\n+\n+    static Stream<Arguments> testCases() throws ReflectiveOperationException {\n+        Set<AccessFlag> mandated = Set.of(AccessFlag.MANDATED);\n+        Set<AccessFlag> synthetic = Set.of(AccessFlag.SYNTHETIC);\n+\n+        return Stream.of(\n+                \/\/ test for implicit parameters\n+                \/\/ inner class\n+                Arguments.of(Outer.Inner.class.getDeclaredConstructors()[0],\n+                        List.of(mandated, Set.of())),\n+                \/\/ anonymous class extending an inner class\n+                Arguments.of(Class.forName(\"Outer$1\")\n+                                .getDeclaredConstructors()[0],\n+                        List.of(mandated, Set.of(), Set.of())),\n+                \/\/ anonymous class\n+                Arguments.of(Class.forName(\"Outer$2\")\n+                                .getDeclaredConstructors()[0],\n+                        List.of(mandated)),\n+                \/\/ enum class\n+                Arguments.of(Outer.MyEnum.class.getDeclaredMethod(\"valueOf\", String.class),\n+                        List.of(mandated)),\n+                \/\/ record class\n+                Arguments.of(Outer.MyRecord.class.getDeclaredConstructors()[0],\n+                        List.of(mandated, mandated)),\n+                \/\/ local class\n+                Arguments.of(Class.forName(\"Outer$1Task\")\n+                                .getDeclaredConstructors()[0],\n+                        List.of(mandated, Set.of(), synthetic)),\n+                \/\/ test for synthetic parameters\n+                \/\/ assuming javac creates two synthetic parameters corresponding to\n+                \/\/ Enum(String name, int ordinal)\n+                Arguments.of(Outer.MyEnum.class.getDeclaredConstructors()[0],\n+                        List.of(synthetic, synthetic, Set.of(), Set.of()))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    void check(Executable method, List<Set<AccessFlag>> paramFlags) {\n+        Parameter[] parameters = method.getParameters();\n+        assertEquals(paramFlags.size(), parameters.length, () -> \"Parameter count of \" + method);\n+\n+        for (int i = 0; i < parameters.length; i++) {\n+            Set<AccessFlag> expected = new HashSet<>(paramFlags.get(i));\n+            expected.retainAll(CHECKED_FLAGS);\n+            Set<AccessFlag> found = new HashSet<>(parameters[i].accessFlags());\n+            found.retainAll(CHECKED_FLAGS);\n+            final int index = i;\n+            assertEquals(expected, found, () -> \"Parameter \" + index + \" in \" + method);\n+        }\n+    }\n+}\n+\n+\/\/ keep this in sync with test\/langtools\/tools\/javac\/RequiredParameterFlags\/ImplicitParameters.java\n+class Outer {\n+    class Inner {\n+        public Inner(Inner notMandated) {}\n+    }\n+\n+    Inner anonymousInner = this.new Inner(null) {};\n+\n+    Object anonymous = new Object() {};\n+\n+    private void instanceMethod(int i) {\n+        class Task implements Runnable {\n+            final int j;\n+\n+            Task(int j) {\n+                this.j = j;\n+            }\n+\n+            @Override\n+            public void run() {\n+                System.out.println(Outer.this.toString() + (i * j));\n+            }\n+        }\n+\n+        new Task(5).run();\n+    }\n+\n+    enum MyEnum {\n+        ;\n+        MyEnum(String s, int i) {}\n+    }\n+\n+    record MyRecord(int a, Object b) {\n+        MyRecord {}\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/RequiredMethodParameterFlagTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8292275\n+ * @summary check that implicit parameter flags are available by default\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @run main ImplicitParameters\n+ *\/\n+\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.ConstantPoolException;\n+import com.sun.tools.classfile.MethodParameters_attribute;\n+import com.sun.tools.javac.code.Flags;\n+import toolbox.Assert;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+import java.io.IOException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class ImplicitParameters extends TestRunner {\n+    private static final int CHECKED_FLAGS = Flags.MANDATED | Flags.SYNTHETIC;\n+    private static final int NO_FLAGS = 0;\n+\n+    public ImplicitParameters() {\n+        super(System.err);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new ImplicitParameters().runTests();\n+    }\n+\n+    @Override\n+    protected void runTests() throws Exception {\n+        Path base = Path.of(\".\").toAbsolutePath();\n+        compileClasses(base);\n+        runTests(method -> new Object[]{ readClassFile(base.resolve(\"classes\"), method) });\n+    }\n+\n+    private void compileClasses(Path base) throws IOException {\n+        \/\/ Keep this in sync with test\/jdk\/java\/lang\/reflect\/AccessFlag\/RequiredMethodParameterFlagTest.java\n+        String outer = \"\"\"\n+                class Outer {\n+                    class Inner {\n+                        public Inner(Inner notMandated) {}\n+                    }\n+\n+                    Inner anonymousInner = this.new Inner(null) {};\n+\n+                    Object anonymous = new Object() {};\n+\n+                    private void instanceMethod(int i) {\n+                        class Task implements Runnable {\n+                            final int j;\n+\n+                            Task(int j) {\n+                                this.j = j;\n+                            }\n+\n+                            @Override\n+                            public void run() {\n+                                System.out.println(Outer.this.toString() + (i * j));\n+                            }\n+                        }\n+\n+                        new Task(5).run();\n+                    }\n+\n+                    enum MyEnum {\n+                        ;\n+                        MyEnum(String s, int i) {}\n+                    }\n+\n+                    record MyRecord(int a, Object b) {\n+                        MyRecord {}\n+                    }\n+                }\n+                \"\"\";\n+        Path src = base.resolve(\"src\");\n+        ToolBox tb = new ToolBox();\n+        tb.writeJavaFiles(src, outer);\n+        Path classes = base.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        new JavacTask(tb)\n+                .files(tb.findJavaFiles(src))\n+                .outdir(classes)\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+    }\n+\n+    private ClassFile readClassFile(Path classes, Method method) {\n+        String className = method.getAnnotation(ClassName.class).value();\n+        try {\n+            return ClassFile.read(classes.resolve(\"Outer$\" + className + \".class\"));\n+        } catch (IOException | ConstantPoolException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface ClassName {\n+        String value();\n+    }\n+\n+    @Test\n+    @ClassName(\"Inner\")\n+    public void testInnerClassConstructor(ClassFile classFile) {\n+        checkParameters(classFile.methods[0], Flags.MANDATED, 0);\n+    }\n+\n+    @Test\n+    @ClassName(\"1Task\")\n+    public void testLocalClassConstructor(ClassFile classFile) throws ConstantPoolException {\n+        for (com.sun.tools.classfile.Method method : classFile.methods) {\n+            if (method.getName(classFile.constant_pool).equals(ConstantDescs.INIT_NAME)) {\n+                checkParameters(method, Flags.MANDATED, NO_FLAGS, Flags.SYNTHETIC);\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @ClassName(\"1\")\n+    public void testAnonymousClassExtendingInnerClassConstructor(ClassFile classFile) {\n+        checkParameters(classFile.methods[0], Flags.MANDATED, NO_FLAGS, NO_FLAGS);\n+    }\n+\n+    @Test\n+    @ClassName(\"2\")\n+    public void testAnonymousClassConstructor(ClassFile classFile) {\n+        checkParameters(classFile.methods[0], Flags.MANDATED);\n+    }\n+\n+    @Test\n+    @ClassName(\"MyEnum\")\n+    public void testValueOfInEnum(ClassFile classFile) throws ConstantPoolException {\n+        for (com.sun.tools.classfile.Method method : classFile.methods) {\n+            if (method.getName(classFile.constant_pool).equals(\"valueOf\")) {\n+                checkParameters(method, Flags.MANDATED);\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @ClassName(\"MyEnum\")\n+    public void testEnumClassConstructor(ClassFile classFile) throws ConstantPoolException {\n+        for (com.sun.tools.classfile.Method method : classFile.methods) {\n+            if (method.getName(classFile.constant_pool).equals(ConstantDescs.INIT_NAME)) {\n+                checkParameters(method, Flags.SYNTHETIC, Flags.SYNTHETIC, NO_FLAGS, NO_FLAGS);\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @ClassName(\"MyRecord\")\n+    public void testCompactConstructor(ClassFile classFile) {\n+        checkParameters(classFile.methods[0], Flags.MANDATED, Flags.MANDATED);\n+    }\n+\n+    private void checkParameters(com.sun.tools.classfile.Method method, int... parametersFlags) {\n+        MethodParameters_attribute methodParameters = (MethodParameters_attribute) method.attributes.get(\"MethodParameters\");\n+        Assert.checkNonNull(methodParameters, \"MethodParameters attribute must be present\");\n+        MethodParameters_attribute.Entry[] table = methodParameters.method_parameter_table;\n+        Assert.check(table.length == parametersFlags.length, () -> \"Expected \" + parametersFlags.length\n+                + \" MethodParameters entries, found \" + table.length);\n+        for (int i = 0; i < methodParameters.method_parameter_table_length; i++) {\n+            int foundFlags = table[i].flags & CHECKED_FLAGS;\n+            int desiredFlags = parametersFlags[i] & CHECKED_FLAGS;\n+            Assert.check(foundFlags == desiredFlags, () -> \"Expected mandated and synthethic flags to be \"\n+                    + convertFlags(desiredFlags) + \", found \" + convertFlags(foundFlags));\n+        }\n+    }\n+\n+    private static String convertFlags(int flags) {\n+        return ((flags & Flags.MANDATED) == Flags.MANDATED) + \" and \" + ((flags & Flags.SYNTHETIC) == Flags.SYNTHETIC);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/RequiredParameterFlags\/ImplicitParameters.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        if (!javapOut.contains(\"0: #20(): CLASS_EXTENDS, type_index=65535\"))\n+        if (!javapOut.contains(\"0: #21(): CLASS_EXTENDS, type_index=65535\"))\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnnotatedExtendsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8292275\n+ * @summary Verify specific executables in enums and records have mandated parameters\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ * @build   JavacTestingAbstractProcessor ImplicitParametersProcessor\n+ * @compile -processor ImplicitParametersProcessor -proc:only ImplicitParametersProcessor.java\n+ *\/\n+\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.Elements;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static javax.lang.model.util.ElementFilter.constructorsIn;\n+import static javax.lang.model.util.ElementFilter.methodsIn;\n+import static javax.lang.model.util.ElementFilter.typesIn;\n+\n+public class ImplicitParametersProcessor extends JavacTestingAbstractProcessor {\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (roundEnv.processingOver()) {\n+            return true;\n+        }\n+        boolean hasError = false;\n+        for (TypeElement typeElement : typesIn(roundEnv.getRootElements())) {\n+            for (TypeElement innerType : typesIn(typeElement.getEnclosedElements())) {\n+                System.out.println(\"Visiting \" + innerType);\n+                ExpectedOrigin[] expectedOrigins = innerType.getAnnotationsByType(ExpectedOrigin.class);\n+                    hasError |= checkAllExecutables(innerType, Arrays.stream(expectedOrigins)\n+                            .collect(Collectors.toMap(ExpectedOrigin::method, ExpectedOrigin::origins)));\n+            }\n+        }\n+        if (hasError) {\n+            throw new IllegalStateException(\"Wrong element origins found\");\n+        }\n+        return true;\n+    }\n+\n+    boolean checkAllExecutables(TypeElement element, Map<String, Elements.Origin[]> expectations) {\n+        boolean hasError = false;\n+        for (ExecutableElement executable : constructorsIn(element.getEnclosedElements())) {\n+            hasError |= checkExecutable(expectations, executable);\n+        }\n+        for (ExecutableElement executable : methodsIn(element.getEnclosedElements())) {\n+            hasError |= checkExecutable(expectations, executable);\n+        }\n+        return hasError;\n+    }\n+\n+    private boolean checkExecutable(Map<String, Elements.Origin[]> expectations, ExecutableElement executable) {\n+        System.out.println(\"Looking at executable \" + executable);\n+        Elements.Origin[] origins = expectations.get(executable.getSimpleName().toString());\n+        if (origins == null) {\n+            System.out.println(\"ignoring this executable due to missing expectations\");\n+            return false;\n+        }\n+        List<? extends VariableElement> parameters = executable.getParameters();\n+        boolean hasError = false;\n+        for (int i = 0; i < parameters.size(); i++) {\n+            VariableElement parameter = parameters.get(i);\n+            Elements.Origin origin = eltUtils.getOrigin(parameter);\n+            if (origin != origins[i]) {\n+                System.err.println(\"ERROR: Wrong origin for \" + executable + \". Expected: \" + origins[i] + \" but got \" + origin + \" at index \" + i);\n+                hasError = true;\n+            }\n+        }\n+        return hasError;\n+    }\n+\n+    \/\/ the valueOf(String) method has one mandated parameter\n+    @ExpectedOrigin(method = \"valueOf\", origins = {Elements.Origin.MANDATED})\n+    enum MyEnum {}\n+\n+    \/\/ the parameters of a compact record constructor are mandated\n+    @ExpectedOrigin(method = \"<init>\", origins = {Elements.Origin.MANDATED, Elements.Origin.MANDATED})\n+    record MyRecord(int a, Object b) {\n+        MyRecord {}\n+    }\n+\n+    @interface ExpectedOrigin {\n+        String method();\n+        Elements.Origin[] origins();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/MethodParameters\/ImplicitParametersProcessor.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-                \"  0: #17(#18=B#19)\\n\" +\n+                \"  0: #18(#19=B#20)\\n\" +\n@@ -56,1 +56,1 @@\n-                \"  1: #20(#18=S#21)\\n\" +\n+                \"  1: #21(#19=S#22)\\n\" +\n@@ -62,1 +62,1 @@\n-                \"  0: #23(#18=[J#24,J#26,J#28,J#30,J#32])\\n\" +\n+                \"  0: #24(#19=[J#25,J#27,J#29,J#31,J#33])\\n\" +\n@@ -66,1 +66,1 @@\n-                \"  1: #34(#18=Z#35)\\n\" +\n+                \"  1: #35(#19=Z#36)\\n\" +\n@@ -70,1 +70,1 @@\n-                \"  2: #36(#37=c#38)\\n\" +\n+                \"  2: #37(#38=c#39)\\n\" +\n@@ -74,1 +74,1 @@\n-                \"  3: #39(#40=e#41.#42)\\n\" +\n+                \"  3: #40(#41=e#42.#43)\\n\" +\n@@ -78,1 +78,1 @@\n-                \"  4: #43(#18=I#44)\\n\" +\n+                \"  4: #44(#19=I#45)\\n\" +\n@@ -82,1 +82,1 @@\n-                \"  5: #45()\\n\" +\n+                \"  5: #46()\\n\" +\n@@ -84,1 +84,1 @@\n-                \"  6: #46(#47=s#48)\\n\" +\n+                \"  6: #47(#48=s#49)\\n\" +\n@@ -88,1 +88,1 @@\n-                \"  7: #49(#50=D#51,#53=F#54)\\n\" +\n+                \"  7: #50(#51=D#52,#54=F#55)\\n\" +\n@@ -93,1 +93,1 @@\n-                \"  8: #55()\\n\" +\n+                \"  8: #56()\\n\" +\n@@ -95,1 +95,1 @@\n-                \"  9: #56(#18=@#43(#18=I#57))\\n\" +\n+                \"  9: #57(#19=@#44(#19=I#58))\\n\" +\n@@ -103,1 +103,1 @@\n-                \"  0: #59(): CLASS_EXTENDS, type_index=0\\n\" +\n+                \"  0: #60(): CLASS_EXTENDS, type_index=0\\n\" +\n","filename":"test\/langtools\/tools\/javap\/AnnoTest.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"}]}