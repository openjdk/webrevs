{"files":[{"patch":"@@ -73,0 +73,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n@@ -89,0 +90,2 @@\n+    private static final String TEMPLATE_RUNTIMEIMAGE_INFO_PLIST =\n+            \"RuntimeImage-Info.plist.template\";\n@@ -290,1 +293,1 @@\n-                doSigning(params);\n+                doSigning(params, root, true);\n@@ -369,1 +372,1 @@\n-        doSigning(params);\n+        doSigning(params, root, true);\n@@ -395,2 +398,2 @@\n-    private void doSigning(Map<String, ? super Object> params)\n-            throws IOException {\n+    public static void doSigning(Map<String, ? super Object> params, Path root,\n+            boolean isAppImage) throws IOException {\n@@ -418,1 +421,2 @@\n-                signAppBundle(params, root, signingIdentity,\n+                if (isAppImage) {\n+                    signAppBundle(params, root, signingIdentity,\n@@ -421,0 +425,5 @@\n+                } else {\n+                    signRuntimeOrFrameworkBundle(params, root, signingIdentity,\n+                        BUNDLE_ID_SIGNING_PREFIX.fetchFrom(params),\n+                        ENTITLEMENTS.fetchFrom(params));\n+                }\n@@ -427,1 +436,5 @@\n-            signAppBundle(params, root, \"-\", null, null);\n+            if (isAppImage) {\n+                signAppBundle(params, root, \"-\", null, null);\n+            } else {\n+                signRuntimeOrFrameworkBundle(params, root, \"-\", null, null);\n+            }\n@@ -435,1 +448,1 @@\n-    private String getBundleName(Map<String, ? super Object> params) {\n+    private static String getBundleName(Map<String, ? super Object> params) {\n@@ -484,0 +497,28 @@\n+    static void writeRuntimeImageInfoPlist(Path file,\n+            Map<String, ? super Object> params) throws IOException {\n+        Map<String, String> data = new HashMap<>();\n+        String identifier = MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);\n+        data.put(\"CF_BUNDLE_IDENTIFIER\", identifier);\n+        String name = getBundleName(params);\n+        data.put(\"CF_BUNDLE_NAME\", name);\n+        String ver = VERSION.fetchFrom(params);\n+        String sver = ver;\n+        int index = ver.indexOf(\".\");\n+        if (index > 0 && ((index + 1) < ver.length())) {\n+            index = ver.indexOf(\".\", index + 1);\n+            if (index > 0 ) {\n+                sver = ver.substring(0, index);\n+            }\n+        }\n+        data.put(\"CF_BUNDLE_VERSION\", ver);\n+        data.put(\"CF_BUNDLE_SHORT_VERSION_STRING\", sver);\n+        String ven = VENDOR.fetchFrom(params);\n+        data.put(\"CF_BUNDLE_VENDOR\", ven);\n+\n+        createResource(TEMPLATE_RUNTIMEIMAGE_INFO_PLIST, params)\n+                .setPublicName(\"RuntimeImage-Info.plist\")\n+                .setCategory(I18N.getString(\"resource.runtime-bundle-info-plist\"))\n+                .setSubstitutionData(data)\n+                .saveToFile(file);\n+    }\n+\n@@ -782,0 +823,30 @@\n+    public static void signRuntimeOrFrameworkBundle(\n+            Map<String, ? super Object> params, Path pathToSign,\n+            String signingIdentity, String identifierPrefix, Path entitlements)\n+            throws IOException {\n+        AtomicReference<IOException> toThrow = new AtomicReference<>();\n+        String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);\n+\n+        Consumer<? super Path> signIdentifiedByPList = path -> {\n+            \/\/ noinspection ThrowableResultOfMethodCallIgnored\n+            if (toThrow.get() != null)\n+                return;\n+\n+            try {\n+                List<String> args = getCodesignArgs(true, path, signingIdentity,\n+                        identifierPrefix, entitlements, keyChain);\n+                ProcessBuilder pb = new ProcessBuilder(args);\n+                runCodesign(pb, false, params);\n+            } catch (IOException e) {\n+                toThrow.set(e);\n+            }\n+        };\n+\n+        signIdentifiedByPList.accept(pathToSign);\n+\n+        IOException ioe = toThrow.get();\n+        if (ioe != null) {\n+            throw ioe;\n+        }\n+    }\n+\n@@ -867,15 +938,0 @@\n-        \/\/ sign all runtime and frameworks\n-        Consumer<? super Path> signIdentifiedByPList = path -> {\n-            \/\/noinspection ThrowableResultOfMethodCallIgnored\n-            if (toThrow.get() != null) return;\n-\n-            try {\n-                List<String> args = getCodesignArgs(true, path, signingIdentity,\n-                            identifierPrefix, entitlements, keyChain);\n-                ProcessBuilder pb = new ProcessBuilder(args);\n-                runCodesign(pb, false, params);\n-            } catch (IOException e) {\n-                toThrow.set(e);\n-            }\n-        };\n-\n@@ -884,6 +940,2 @@\n-            signIdentifiedByPList.accept(javaPath);\n-\n-            ioe = toThrow.get();\n-            if (ioe != null) {\n-                throw ioe;\n-            }\n+            signRuntimeOrFrameworkBundle(params, javaPath, signingIdentity,\n+                identifierPrefix, entitlements);\n@@ -894,1 +946,8 @@\n-                fileList.forEach(signIdentifiedByPList);\n+                fileList.forEach(pathToSign -> {\n+                    try {\n+                        signRuntimeOrFrameworkBundle(params, pathToSign,\n+                            signingIdentity, identifierPrefix, entitlements);\n+                    } catch (IOException ioe2) {\n+                        toThrow.set(ioe2);\n+                    }\n+                });\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":88,"deletions":29,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.HashMap;\n@@ -35,0 +36,3 @@\n+import java.util.NoSuchElementException;\n+import java.util.stream.Stream;\n+\n@@ -39,0 +43,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n@@ -41,0 +46,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n@@ -163,0 +169,17 @@\n+        } else if (StandardBundlerParam.isRuntimeInstaller(params)) {\n+            \/\/ Call appImageBundler.validate(params); to validate signing\n+            \/\/ requirements.\n+            appImageBundler.validate(params);\n+\n+            Path runtimeImage = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n+\n+            \/\/ Make sure we have valid runtime image.\n+            if (!isRuntimeImageJDKBundle(runtimeImage)\n+                    && !isRuntimeImageJDKImage(runtimeImage)) {\n+                throw new ConfigException(\n+                    MessageFormat.format(I18N.getString(\n+                    \"message.runtime-image-invalid\"),\n+                    runtimeImage.toString()),\n+                    I18N.getString(\n+                    \"message.runtime-image-invalid.advice\"));\n+            }\n@@ -174,0 +197,2 @@\n+        Path runtimeImage =\n+                PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n@@ -191,0 +216,26 @@\n+        } else if (StandardBundlerParam.isRuntimeInstaller(params)) {\n+            if (isRuntimeImageJDKBundle(runtimeImage)) {\n+                appDir = runtimeImage;\n+            } else {\n+                \/\/ It is a valid JDK image, so convert it to JDK bundle.\n+                Path jdkBundleRoot = Files.createTempDirectory(TEMP_ROOT.fetchFrom(params),\n+                    \"root-\");\n+\n+                convertJDKImageToJDKBundle(jdkBundleRoot, runtimeImage, params);\n+\n+                appDir = jdkBundleRoot;\n+            }\n+\n+            \/\/ Figure out if we need to sign\n+            boolean signingRequested = Optional.ofNullable(\n+                SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE);\n+\n+            \/\/ Check if bundle is already signed\n+            Path codeSignature = appDir.resolve(\"Contents\/_CodeSignature\");\n+            boolean bundleIsSigned = IOUtils.exists(codeSignature);\n+\n+            \/\/ We do signing when it is requested or if bundle is not signed to\n+            \/\/ create ad-hoc signature\n+            if (signingRequested || !bundleIsSigned) {\n+                MacAppImageBuilder.doSigning(params, appDir, false);\n+            }\n@@ -198,0 +249,56 @@\n+    public static void convertJDKImageToJDKBundle(Path jdkBundleRoot,\n+            Path runtimeImage,\n+            Map<String, ? super Object> params) throws IOException {\n+        Path path1 = jdkBundleRoot.resolve(\"Contents\/Home\");\n+        Files.createDirectories(path1);\n+        FileUtils.copyRecursive(runtimeImage, path1);\n+\n+        \/\/ Copy libjli.dylib library\n+        Path path2 = Files.createDirectories(\n+                jdkBundleRoot.resolve(\"Contents\/MacOS\"));\n+\n+        final Path jliName = Path.of(\"libjli.dylib\");\n+        try (Stream<Path> walk = Files.walk(runtimeImage.resolve(\"lib\"))) {\n+            final Path jli = walk\n+                    .filter(file -> file.getFileName().equals(jliName))\n+                    .findFirst()\n+                    .get();\n+            Files.copy(jli, path2.resolve(jliName));\n+        }\n+\n+        MacAppImageBuilder.writeRuntimeImageInfoPlist(\n+                jdkBundleRoot.resolve(\"Contents\/Info.plist\"), params);\n+    }\n+\n+    \/\/ JDK bundle: \"Contents\/Home\", \"Contents\/MacOS\/libjli.dylib\"\n+    \/\/ and \"Contents\/Info.plist\"\n+    private boolean isRuntimeImageJDKBundle(Path runtimeImage) {\n+        Path path1 = runtimeImage.resolve(\"Contents\/Home\");\n+        Path path2 = runtimeImage.resolve(\"Contents\/MacOS\/libjli.dylib\");\n+        Path path3 = runtimeImage.resolve(\"Contents\/Info.plist\");\n+        if (IOUtils.exists(path1)\n+                && path1.toFile().list() != null\n+                && path1.toFile().list().length > 0\n+                && IOUtils.exists(path2)\n+                && IOUtils.exists(path3)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/\/ JDK image: \"lib\/*\/libjli.dylib\"\n+    private boolean isRuntimeImageJDKImage(Path runtimeImage) {\n+        final Path jliName = Path.of(\"libjli.dylib\");\n+        try (Stream<Path> walk = Files.walk(runtimeImage.resolve(\"lib\"))) {\n+            final Path jli = walk\n+                    .filter(file -> file.getFileName().equals(jliName))\n+                    .findFirst()\n+                    .get();\n+            return IOUtils.exists(jli);\n+        } catch (IOException | NoSuchElementException ex) {\n+            Log.verbose(ex);\n+            return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -130,2 +130,10 @@\n-        String targetItem = (StandardBundlerParam.isRuntimeInstaller(params)) ?\n-              APP_NAME.fetchFrom(params) : appLocation.getFileName().toString();\n+        String targetItem = null;\n+        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n+            if (APP_NAME.fetchFrom(params).endsWith(\".jdk\")) {\n+                targetItem = APP_NAME.fetchFrom(params);\n+            } else {\n+                targetItem = APP_NAME.fetchFrom(params).concat(\".jdk\");\n+            }\n+        } else {\n+            targetItem = appLocation.getFileName().toString();\n+        }\n@@ -278,7 +286,3 @@\n-            \/\/ first, is this already a runtime with\n-            \/\/ <runtime>\/Contents\/Home - if so we need the Home dir\n-            Path home = appLocation.resolve(\"Contents\/Home\");\n-            Path source = (Files.exists(home)) ? home : appLocation;\n-\n-            \/\/ Then we need to put back the <NAME>\/Content\/Home\n-            Path root = newRoot.resolve(\n+            \/\/ We need to copy entire runtime folder as provided to include\n+            \/\/ .plist and signing files.\n+            Path dest = newRoot.resolve(\n@@ -286,1 +290,4 @@\n-            Path dest = root.resolve(\"Contents\/Home\");\n+            \/\/ Add .jdk if needed.\n+            if (!dest.getFileName().endsWith(\".jdk\")) {\n+                dest = dest.resolveSibling(dest.getFileName() + \".jdk\");\n+            }\n@@ -288,1 +295,1 @@\n-            FileUtils.copyRecursive(source, dest);\n+            FileUtils.copyRecursive(appLocation, dest);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -438,5 +438,1 @@\n-            \/\/ firs, is this already a runtime with\n-            \/\/ <runtime>\/Contents\/Home - if so we need the Home dir\n-            Path original = appLocation;\n-            Path home = original.resolve(\"Contents\/Home\");\n-            source = (Files.exists(home)) ? home : original;\n+            source = appLocation;\n@@ -444,1 +440,2 @@\n-            \/\/ Then we need to put back the <NAME>\/Content\/Home\n+            \/\/ We need to copy entire runtime folder as provided to include\n+            \/\/ .plist and signing files.\n@@ -446,1 +443,5 @@\n-                MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) + \"\/Contents\/Home\");\n+                MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params));\n+            \/\/ Add .jdk if needed.\n+            if (!dest.getFileName().endsWith(\".jdk\")) {\n+                dest = dest.resolveSibling(dest.getFileName() + \".jdk\");\n+            }\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+resource.runtime-bundle-info-plist=Java Runtime Bundle Info.plist\n@@ -86,0 +87,2 @@\n+message.runtime-image-invalid=Provided runtime image at \"{0}\" is invalid or corrupted.\n+message.runtime-image-invalid.advice=Runtime image should be valid JDK bundle or JDK image.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!DOCTYPE plist PUBLIC \"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\" \"https:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\">\n+<plist version=\"1.0\">\n+<dict>\n+        <key>CFBundleDevelopmentRegion<\/key>\n+        <string>English<\/string>\n+        <key>CFBundleExecutable<\/key>\n+        <string>libjli.dylib<\/string>\n+        <key>CFBundleIdentifier<\/key>\n+        <string>CF_BUNDLE_IDENTIFIER<\/string>\n+        <key>CFBundleInfoDictionaryVersion<\/key>\n+        <string>7.0<\/string>\n+        <key>CFBundleName<\/key>\n+        <string>CF_BUNDLE_NAME<\/string>\n+        <key>CFBundlePackageType<\/key>\n+        <string>BNDL<\/string>\n+        <key>CFBundleShortVersionString<\/key>\n+        <string>CF_BUNDLE_SHORT_VERSION_STRING<\/string>\n+        <key>CFBundleSignature<\/key>\n+        <string>????<\/string>\n+        <key>CFBundleVersion<\/key>\n+        <string>CF_BUNDLE_VERSION<\/string>\n+        <key>NSMicrophoneUsageDescription<\/key>\n+        <string>The application is requesting access to the microphone.<\/string>\n+        <key>JavaVM<\/key>\n+        <dict>\n+                <key>JVMCapabilities<\/key>\n+                <array>\n+                        <string>CommandLine<\/string>\n+                <\/array>\n+                <key>JVMPlatformVersion<\/key>\n+                <string>CF_BUNDLE_VERSION<\/string>\n+                <key>JVMVendor<\/key>\n+                <string>CF_BUNDLE_VENDOR<\/string>\n+                <key>JVMVersion<\/key>\n+                <string>CF_BUNDLE_VERSION<\/string>\n+        <\/dict>\n+<\/dict>\n+<\/plist>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/RuntimeImage-Info.plist.template","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -93,1 +93,1 @@\n-        allArgs = Arguments.getPropertiesFromFile(filename);\n+        allArgs = IOUtils.getPropertiesFromFile(Path.of(filename));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AddLauncherArguments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.io.Reader;\n@@ -42,1 +41,0 @@\n-import java.util.Properties;\n@@ -217,1 +215,2 @@\n-            Map<String, String> initialMap = getPropertiesFromFile(popArg());\n+            Map<String, String> initialMap =\n+                IOUtils.getPropertiesFromFile(Path.of(popArg()));\n@@ -762,17 +761,0 @@\n-    static Map<String, String> getPropertiesFromFile(String filename) {\n-        Map<String, String> map = new HashMap<>();\n-        \/\/ load properties file\n-        Properties properties = new Properties();\n-        try (Reader reader = Files.newBufferedReader(Path.of(filename))) {\n-            properties.load(reader);\n-        } catch (IOException e) {\n-            Log.error(\"Exception: \" + e.getMessage());\n-        }\n-\n-        for (final String name: properties.stringPropertyNames()) {\n-            map.put(name, properties.getProperty(name));\n-        }\n-\n-        return map;\n-    }\n-\n@@ -808,1 +790,1 @@\n-    private static String unquoteIfNeeded(String in) {\n+    public static String unquoteIfNeeded(String in) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.io.Reader;\n@@ -36,0 +37,1 @@\n+import java.util.HashMap;\n@@ -37,0 +39,2 @@\n+import java.util.Map;\n+import java.util.Properties;\n@@ -44,1 +48,1 @@\n-final class IOUtils {\n+public final class IOUtils {\n@@ -223,0 +227,28 @@\n+\n+    static Map<String, String> getPropertiesFromFile(Path filename) {\n+        Map<String, String> map = new HashMap<>();\n+        \/\/ load properties file\n+        Properties properties = new Properties();\n+        try (Reader reader = Files.newBufferedReader(filename)) {\n+            properties.load(reader);\n+        } catch (IOException e) {\n+            Log.error(\"Exception: \" + e.getMessage());\n+        }\n+\n+        for (final String name: properties.stringPropertyNames()) {\n+            map.put(name, properties.getProperty(name));\n+        }\n+\n+        return map;\n+    }\n+\n+    public static String getPropertyFromFile(Path filename, String name)\n+            throws IOException {\n+        \/\/ load properties file\n+        Properties properties = new Properties();\n+        try (Reader reader = Files.newBufferedReader(filename)) {\n+            properties.load(reader);\n+        }\n+\n+        return properties.getProperty(name);\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -617,1 +617,29 @@\n-            return appVersion;\n+            Path runtimePath = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n+            Path releasePath = null;\n+            \/\/ Try special case for macOS first. \"Contents\/Home\/release\"\n+            if (OperatingSystem.isMacOS()) {\n+                releasePath = runtimePath.resolve(\"Contents\/Home\/release\");\n+                if (!IOUtils.exists(releasePath)) {\n+                    releasePath = null;\n+                }\n+            }\n+\n+            \/\/ Try root for all platforms including macOS.\n+            if (releasePath == null) {\n+                releasePath = runtimePath.resolve(\"release\");\n+                if (!IOUtils.exists(releasePath)) {\n+                    releasePath = null;\n+                }\n+            }\n+\n+            String releaseVersion = null;\n+            if (releasePath != null) {\n+                try {\n+                    releaseVersion = IOUtils.getPropertyFromFile(releasePath, \"JAVA_VERSION\");\n+                    releaseVersion = Arguments.unquoteIfNeeded(releaseVersion);\n+                } catch (IOException ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+            }\n+\n+            return releaseVersion == null ? appVersion : releaseVersion;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -188,1 +188,12 @@\n-                    VERSION::fetchFrom,\n+                    params -> {\n+                        String version = VERSION.fetchFrom(params);\n+                        \/\/ Special case for MSI product version for runtime\n+                        \/\/ installer. Runtime version can be single digit\n+                        \/\/ for example \"25\", but product version requires 2 or 4\n+                        \/\/ components. JDK uses \"25.0.0.0\" in this case.\n+                        if (StandardBundlerParam.isRuntimeInstaller(params) &&\n+                                !version.contains(\".\")) {\n+                            version = version.concat(\".0.0.0\");\n+                        }\n+                        return version;\n+                    },\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+import jdk.jpackage.internal.Arguments;\n+import jdk.jpackage.internal.IOUtils;\n@@ -227,1 +229,48 @@\n-        return getArgumentValue(\"--app-version\", () -> \"1.0\");\n+        if (isRuntime()) {\n+            String appVersion = getArgumentValue(\"--app-image\");\n+            if (appVersion != null) {\n+                return appVersion;\n+            } else {\n+                Path runtimePath = Path.of(getArgumentValue(\"--runtime-image\"));\n+                Path releasePath = null;\n+                \/\/ Try special case for macOS first. \"Contents\/Home\/release\"\n+                if (TKit.isOSX()) {\n+                    releasePath = runtimePath.resolve(\"Contents\/Home\/release\");\n+                    if (!Files.exists(releasePath)) {\n+                        releasePath = null;\n+                    }\n+                }\n+\n+                \/\/ Try root for all platforms including macOS.\n+                if (releasePath == null) {\n+                    releasePath = runtimePath.resolve(\"release\");\n+                    if (!Files.exists(releasePath)) {\n+                        releasePath = null;\n+                    }\n+                }\n+\n+                String releaseVersion = null;\n+                if (releasePath != null) {\n+                    try {\n+                        releaseVersion = IOUtils.getPropertyFromFile(releasePath, \"JAVA_VERSION\");\n+                        releaseVersion = Arguments.unquoteIfNeeded(releaseVersion);\n+                    } catch (IOException ex) {\n+                        TKit.error(String.format(\n+                            \"Failed to read property file at %s: %s\",\n+                            releasePath, ex));\n+                    }\n+                }\n+\n+                if (releaseVersion == null) {\n+                    if (appVersion == null) {\n+                        return \"1.0\";\n+                    } else {\n+                        return appVersion;\n+                    }\n+                } else {\n+                    return releaseVersion;\n+                }\n+            }\n+        } else {\n+            return getArgumentValue(\"--app-version\", () -> \"1.0\");\n+        }\n@@ -958,1 +1007,6 @@\n-        RUNTIME_IMAGE(new Builder(\"--runtime-image\").create());\n+        RUNTIME_IMAGE(new Builder(\"--runtime-image\").enable(cmd -> {\n+            \/\/ External runtime image should be R\/O unless it is runtime installer\n+            \/\/ on macOS. On macOS runtime image will be signed ad-hoc or with\n+            \/\/ real certificate when creating runtime installers.\n+            return !(cmd.isRuntime() && TKit.isOSX());\n+        }).create());\n@@ -1073,5 +1127,1 @@\n-                if (cmd.isRuntime()) {\n-                    TKit.assertPathExists(libjliPath, false);\n-                } else {\n-                    TKit.assertFileExists(libjliPath);\n-                }\n+                TKit.assertFileExists(libjliPath);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":57,"deletions":7,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-        return installLocation.resolve(cmd.name() + (cmd.isRuntime() ? \"\" : \".app\"));\n+        return installLocation.resolve(cmd.name() + (cmd.isRuntime() ? \".jdk\" : \".app\"));\n@@ -419,1 +419,4 @@\n-            \"Home\"\n+            \"Home\",\n+            \"MacOS\",\n+            \"Info.plist\",\n+            \"_CodeSignature\"\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+\n+import jdk.jpackage.test.ApplicationLayout;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.JavaTool;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.internal.MacBaseInstallerBundler;\n+import jdk.jpackage.internal.MacAppImageBuilder;\n+\n+\/**\n+ * Tests generation of dmg and pkg with --mac-sign and related arguments.\n+ * Test will generate pkg and verifies its signature. It verifies that dmg\n+ * is not signed, but runtime image inside dmg is signed.\n+ *\n+ * Note: Specific UNICODE signing is not tested, since it is shared code\n+ * with app image signing and it will be covered by SigningPackageTest.\n+ *\n+ * Following combinations are tested:\n+ * 1) \"--runtime-image\" points to unsigned JDK bundle and --mac-sign is not\n+ * provided. Expected result: runtime image ad-hoc signed.\n+ * 2) \"--runtime-image\" points to unsigned JDK bundle and --mac-sign is\n+ * provided. Expected result: Everything is signed with provided certificate.\n+ * 3) \"--runtime-image\" points to signed JDK bundle and --mac-sign is not\n+ * provided. Expected result: runtime image is signed with original certificate.\n+ * 4) \"--runtime-image\" points to signed JDK bundle and --mac-sign is provided.\n+ * Expected result: runtime image is signed with provided certificate.\n+ * 5) \"--runtime-image\" points to JDK image and --mac-sign is not provided.\n+ * Expected result: runtime image ad-hoc signed.\n+ * 6) \"--runtime-image\" points to JDK image and --mac-sign is provided.\n+ * Expected result: Everything is signed with provided certificate.\n+ *\n+ * This test requires that the machine is configured with test certificate for\n+ * \"Developer ID Installer: jpackage.openjdk.java.net\" in\n+ * jpackagerTest keychain with\n+ * always allowed access to this keychain for user which runs test.\n+ * note:\n+ * \"jpackage.openjdk.java.net\" can be over-ridden by systerm property\n+ * \"jpackage.mac.signing.key.user.name\", and\n+ * \"jpackagerTest\" can be over-ridden by system property\n+ * \"jpackage.mac.signing.keychain\"\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --type pkg,dmg --runtime-image --mac-sign\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @library base\n+ * @key jpackagePlatformPackage\n+ * @build SigningBase\n+ * @build jdk.jpackage.test.*\n+ * @build SigningRuntimeImagePackageTest\n+ * @requires (jpackage.test.MacSignTests == \"run\")\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningRuntimeImagePackageTest\n+ *  --jpt-before-run=SigningBase.verifySignTestEnvReady\n+ *\/\n+public class SigningRuntimeImagePackageTest {\n+\n+    private static void verifyPKG(JPackageCommand cmd) {\n+        Path outputBundle = cmd.outputBundle();\n+        SigningBase.verifyPkgutil(outputBundle, isPKGSigned(cmd), getCertIndex(cmd));\n+        if (isPKGSigned(cmd)) {\n+            SigningBase.verifySpctl(outputBundle, \"install\", getCertIndex(cmd));\n+        }\n+    }\n+\n+    private static void verifyDMG(JPackageCommand cmd) {\n+        Path outputBundle = cmd.outputBundle();\n+        SigningBase.verifyDMG(outputBundle);\n+    }\n+\n+    private static void verifyRuntimeImageInDMG(JPackageCommand cmd,\n+                                                boolean isRuntimeImageSigned,\n+                                                int JDKBundleCertIndex) {\n+        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n+            Path launcherPath = ApplicationLayout.platformAppImage()\n+                    .resolveAt(dmgImage).launchersDirectory().resolve(\"libjli.dylib\");\n+            \/\/ We will be called with all folders in DMG since JDK-8263155, but\n+            \/\/ we only need to verify app.\n+            if (dmgImage.endsWith(cmd.name() + \".jdk\")) {\n+                SigningBase.verifyCodesign(launcherPath, isRuntimeImageSigned,\n+                        JDKBundleCertIndex);\n+                SigningBase.verifyCodesign(dmgImage, isRuntimeImageSigned,\n+                        JDKBundleCertIndex);\n+                if (isRuntimeImageSigned) {\n+                    SigningBase.verifySpctl(dmgImage, \"exec\", JDKBundleCertIndex);\n+                }\n+            }\n+        });\n+    }\n+\n+    private static boolean isPKGSigned(JPackageCommand cmd) {\n+        return cmd.hasArgument(\"--mac-signing-key-user-name\") ||\n+               cmd.hasArgument(\"--mac-installer-sign-identity\");\n+    }\n+\n+    private static int getCertIndex(JPackageCommand cmd) {\n+        if (cmd.hasArgument(\"--mac-signing-key-user-name\")) {\n+            String devName = cmd.getArgumentValue(\"--mac-signing-key-user-name\");\n+            return SigningBase.getDevNameIndex(devName);\n+        } else {\n+            return SigningBase.CertIndex.INVALID_INDEX.value();\n+        }\n+    }\n+\n+    private static Path getRuntimeImagePath(boolean useJDKBundle,\n+                                            boolean isRuntimeImageSigned,\n+                                            int JDKBundleCertIndex) throws IOException {\n+        final Path runtimeImageDir =\n+                TKit.createTempDirectory(\"runtimeimage\").resolve(\"data\");\n+\n+        new Executor()\n+            .setToolProvider(JavaTool.JLINK)\n+            .dumpOutput()\n+            .addArguments(\n+                \"--output\", runtimeImageDir.toString(),\n+                \"--add-modules\", \"java.desktop\",\n+                \"--strip-debug\",\n+                \"--no-header-files\",\n+                \"--no-man-pages\")\n+            .execute();\n+\n+        if (useJDKBundle) {\n+            Map<String, Object> params = new LinkedHashMap<>();\n+            params.put(\"name\", \"Foo\");\n+            params.put(\"runtime-image\", runtimeImageDir);\n+\n+            final Path runtimeBundleDir =\n+                TKit.createTempDirectory(\"runtimebundle\").resolve(\"data\");\n+\n+            MacBaseInstallerBundler.convertJDKImageToJDKBundle(runtimeBundleDir,\n+                runtimeImageDir, params);\n+\n+            if (isRuntimeImageSigned) {\n+                params = new LinkedHashMap<>();\n+                params.put(\"name\", \"Foo\");\n+                params.put(\"runtime-image\", runtimeBundleDir);\n+                params.put(\"mac-sign\", Boolean.TRUE);\n+                params.put(\"mac-signing-keychain\",\n+                        SigningBase.getKeyChain());\n+                params.put(\"mac-signing-key-user-name\",\n+                        SigningBase.getDevName(JDKBundleCertIndex));\n+\n+                MacAppImageBuilder.doSigning(params, runtimeBundleDir, false);\n+            }\n+\n+            return runtimeBundleDir;\n+        } else {\n+            return runtimeImageDir;\n+        }\n+    }\n+\n+    @Test\n+    \/\/ useJDKBundle  - If \"true\" predefined runtime image will be converted to\n+    \/\/                 JDK bundle. If \"false\" JDK image will be used.\n+    \/\/ JDKBundleCert - Certificate to sign JDK bundle before calling jpackage.\n+    \/\/ signCert      - Certificate to sign bundle produced by jpackage.\n+    \/\/ 1) unsigned JDK bundle and --mac-sign is not provided\n+    @Parameter({\"true\", \"INVALID_INDEX\", \"INVALID_INDEX\"})\n+    \/\/ 2) unsigned JDK bundle and --mac-sign is provided\n+    @Parameter({\"true\", \"INVALID_INDEX\", \"ASCII_INDEX\"})\n+    \/\/ 3) signed JDK bundle and --mac-sign is not provided\n+    @Parameter({\"true\", \"UNICODE_INDEX\", \"INVALID_INDEX\"})\n+    \/\/ 4) signed JDK bundle and --mac-sign is provided\n+    @Parameter({\"true\", \"UNICODE_INDEX\", \"ASCII_INDEX\"})\n+    \/\/ 5) JDK image and --mac-sign is not provided\n+    @Parameter({\"false\", \"INVALID_INDEX\", \"INVALID_INDEX\"})\n+    \/\/ 6) JDK image and --mac-sign is provided\n+    @Parameter({\"false\", \"INVALID_INDEX\", \"ASCII_INDEX\"})\n+    public static void test(boolean useJDKBundle,\n+                            SigningBase.CertIndex JDKBundleCert,\n+                            SigningBase.CertIndex signCert) throws Exception {\n+        final int JDKBundleCertIndex = JDKBundleCert.value();\n+        final int signCertIndex = signCert.value();\n+\n+        final boolean isRuntimeImageSigned =\n+            (JDKBundleCertIndex != SigningBase.CertIndex.INVALID_INDEX.value());\n+        final boolean isSigned =\n+            (signCertIndex != SigningBase.CertIndex.INVALID_INDEX.value());\n+\n+        new PackageTest()\n+                .forTypes(PackageType.MAC)\n+                .addInitializer(cmd -> {\n+                    cmd.addArguments(\"--runtime-image\",\n+                        getRuntimeImagePath(useJDKBundle,\n+                            isRuntimeImageSigned, JDKBundleCertIndex));\n+                    \/\/ Remove --input parameter from jpackage command line as we don't\n+                    \/\/ create input directory in the test and jpackage fails\n+                    \/\/ if --input references non existant directory.\n+                    cmd.removeArgumentWithValue(\"--input\");\n+\n+                    if (isSigned) {\n+                        cmd.addArguments(\"--mac-sign\",\n+                                \"--mac-signing-keychain\", SigningBase.getKeyChain());\n+                        cmd.addArguments(\"--mac-signing-key-user-name\",\n+                                         SigningBase.getDevName(signCertIndex));\n+                    }\n+                })\n+                .forTypes(PackageType.MAC_PKG)\n+                .addBundleVerifier(SigningRuntimeImagePackageTest::verifyPKG)\n+                .forTypes(PackageType.MAC_DMG)\n+                .addBundleVerifier(SigningRuntimeImagePackageTest::verifyDMG)\n+                .addBundleVerifier(cmd -> {\n+                    int certIndex = SigningBase.CertIndex.INVALID_INDEX.value();\n+                    if (isSigned)\n+                        certIndex = signCertIndex;\n+                    else if (isRuntimeImageSigned)\n+                        certIndex = JDKBundleCertIndex;\n+                    verifyRuntimeImageInDMG(cmd, isRuntimeImageSigned || isSigned,\n+                        certIndex);\n+                })\n+                .run();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningRuntimeImagePackageTest.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.file.Files;\n@@ -43,0 +44,1 @@\n+import java.io.IOException;\n@@ -91,0 +93,25 @@\n+        INVALID_JDK_BUNDLE(cmd -> {\n+            \/\/ Missing \"Contents\/MacOS\/libjli.dylib\"\n+            try {\n+                final Path runtimePath = TKit.createTempDirectory(\"invalidJDKBundle\");\n+                Files.createDirectories(runtimePath.resolve(\"Contents\/Home\"));\n+                Files.createFile(runtimePath.resolve(\"Contents\/Info.plist\"));\n+                return runtimePath.toAbsolutePath().toString();\n+            } catch (IOException ex) {\n+                TKit.error(ex.getMessage());\n+                return null;\n+            }\n+        }),\n+        INVALID_JDK_IMAGE(cmd -> {\n+            \/\/ Missing \"\"lib\/*\/libjli.dylib\"\"\n+            try {\n+                final Path runtimePath = TKit.createTempDirectory(\"invalidJDKImage\");\n+                Files.createDirectories(runtimePath.resolve(\"jmods\"));\n+                Files.createDirectories(runtimePath.resolve(\"lib\"));\n+                Files.createFile(runtimePath.resolve(\"lib\/src.zip\"));\n+                return runtimePath.toAbsolutePath().toString();\n+            } catch (IOException ex) {\n+                TKit.error(ex.getMessage());\n+                return null;\n+            }\n+        }),\n@@ -606,1 +633,13 @@\n-                        }, Token.JAVA_HOME.token()))\n+                        }, Token.JAVA_HOME.token())),\n+                testSpec().noAppDesc().nativeType()\n+                        .addArgs(\"--runtime-image\", Token.INVALID_JDK_BUNDLE.token())\n+                        .error(\"message.runtime-image-invalid\", JPackageCommand.cannedArgument(cmd -> {\n+                            return Path.of(cmd.getArgumentValue(\"--runtime-image\")).toAbsolutePath();\n+                        }, Token.INVALID_JDK_BUNDLE.token()))\n+                        .error(\"message.runtime-image-invalid.advice\"),\n+                testSpec().noAppDesc().nativeType()\n+                        .addArgs(\"--runtime-image\", Token.INVALID_JDK_IMAGE.token())\n+                        .error(\"message.runtime-image-invalid\", JPackageCommand.cannedArgument(cmd -> {\n+                            return Path.of(cmd.getArgumentValue(\"--runtime-image\")).toAbsolutePath();\n+                        }, Token.INVALID_JDK_IMAGE.token()))\n+                        .error(\"message.runtime-image-invalid.advice\")\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"}]}