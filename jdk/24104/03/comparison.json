{"files":[{"patch":"@@ -153,0 +153,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -146,0 +146,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -155,0 +155,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -152,0 +152,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -149,0 +149,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6611,3 +6611,2 @@\n-  assert(vector_len == AVX_128bit? VM_Version::supports_avx() :\n-         vector_len == AVX_256bit? VM_Version::supports_avx2() :\n-         0, \"\");\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n@@ -6619,0 +6618,9 @@\n+void Assembler::evalignd(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x3, (0xC0 | encode), imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2170,0 +2170,1 @@\n+  void evalignd(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7115,0 +7115,127 @@\n+void C2_MacroAssembler::vector_slice_32B_op(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                            XMMRegister xtmp, int origin, int vlen_enc) {\n+   assert(vlen_enc == Assembler::AVX_256bit, \"\");\n+   if (origin < 16) {\n+     \/\/ ALIGNR instruction concatenates the corresponding 128 bit\n+     \/\/ lanes of two source vectors and then performs the right\n+     \/\/ shift operation over intermediate value. Thus source vectors\n+     \/\/ lanes needs to shuffled to a format consumable by ALIGNR.\n+     \/\/ i.e.\n+     \/\/ Initial source vectors\n+     \/\/         0...256            0...256\n+     \/\/ src1 = [v1 v2]   and src2= [v3  v4]\n+     \/\/ Formatted source vectors when SHIFT < 16 bytes\n+     \/\/         0...256            0...256\n+     \/\/ src1 = [v1  v2] and src2 = [v2  v3]\n+     \/\/ Higher 128bit lane of src2 will not impact result, which will be\n+     \/\/ sliced from lower and higher 128 bit lane of src1 and lower 128 bit\n+     \/\/ lane of src2.\n+     \/\/ i.e.\n+     \/\/ Result lanes\n+     \/\/ res[127:0]   = {src1[255:128] , src1[127:0]}    >> SHIFT\n+     \/\/ res[255:128] = {src2[127:0]   , src1[255:128]}  >> SHIFT\n+     vperm2i128(xtmp, src1, src2, 0x21);\n+     vpalignr(dst, xtmp, src1, origin, Assembler::AVX_256bit);\n+   } else {\n+     assert(origin > 16 && origin <= 32, \"\");\n+     \/\/ Similarly, when SHIFT >= 16 bytes, lower 128bit lane of\n+     \/\/ src1 will not impact result, which will be sliced from\n+     \/\/ higher 128 bit lane of src1 and lower and upper 128 bit\n+     \/\/ lanes of src2.\n+     \/\/ Thus, two source vector should have following format\n+     \/\/         0...256            0...256\n+     \/\/ src1 = [v2  v3] and src2 = [v3  v4]\n+     \/\/ Result lanes\n+     \/\/ res[127:0]   = {src2[127:0]   , src1[255:127]}  >> SHIFT\n+     \/\/ res[255:128] = {src2[255:128] , src2[127:0]}    >> SHIFT\n+     vperm2i128(xtmp, src1, src2, 0x21);\n+     vpalignr(dst, src2, xtmp, origin - 16, Assembler::AVX_256bit);\n+   }\n+}\n+\n+\n+void C2_MacroAssembler::vector_slice_64B_op(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                            XMMRegister xtmp, int origin, int vlen_enc) {\n+  if (origin < 16) {\n+    \/\/ Initial source vectors\n+    \/\/        0.........512            0.........512\n+    \/\/ src1 = [v1 v2 v3 v4] and src2 = [v5 v6 v7 v8]\n+    \/\/ where v* represents 128 bit wide vector lanes.\n+    \/\/ When SHIFT <= 16 result will be sliced out from src1 and\n+    \/\/ lowest 128 bit vector lane\n+    \/\/ of src2.\n+    \/\/ ALIGNR will consider following source vector lanes pairs\n+    \/\/ spread across two source vectors in order to compute 128 bit\n+    \/\/ lanes of result vector.\n+    \/\/ res[127:0]   = {src1[255:128], src1[127:0]}\n+    \/\/ res[255:128] = {src1[383:256], src1[255:128]}\n+    \/\/ res[383:256] = {src1[511:384], src1[383:256]}\n+    \/\/ res[511:384] = {src2[127:0],   src1[511:384]}\n+    \/\/\n+    \/\/ ALIGNR concatenates corresponding lanes across source vectors\n+    \/\/ before right shifting the intermediate result. Therefore, source\n+    \/\/ vector lanes should be shuffled to have following format\n+    \/\/ src1 = {v1, v2, v3, v4} and src2 = {v2, v3, v4, v5}\n+    \/\/\n+    \/\/                       |-------------|\n+    \/\/                 |-----|--------|    |\n+    \/\/ alignr ->  [v1 v2 v3 v4] [v2 v3 v4 v5]\n+    \/\/            |_____|________|    |\n+    \/\/                  |_____________|\n+     evalignd(xtmp, src2, src1, 4, vlen_enc);\n+     vpalignr(dst, xtmp, src1, origin, vlen_enc);\n+   } else if (origin > 16 && origin < 32) {\n+    \/\/ Similarly, for SHIFT between 16 and 32 bytes\n+    \/\/ result will be sliced out of src1 and lower\n+    \/\/ two 128 bit lanes of src2.\n+    \/\/ i.e.\n+    \/\/ res[127:0]   = {src1[383:256], src1[255:128]}\n+    \/\/ res[255:128] = {src1[511:384], src1[383:256]}\n+    \/\/ res[383:256] = {src2[127:0],   src1[511:384]}\n+    \/\/ res[511:384] = {src2[255:128], src2[127:0]}\n+    \/\/ Thus, source vector lanes should have following format.\n+    \/\/ src1 = {v2, v3, v4, v5} and src2 = {v3, v4, v5, v6}\n+     evalignd(xtmp, src2, src1, 4, vlen_enc);\n+     evalignd(dst, src2, src1, 8, vlen_enc);\n+     vpalignr(dst, dst, xtmp, origin - 16, vlen_enc);\n+   } else if (origin > 32 && origin < 48) {\n+    \/\/ For SHIFT between 32 and 48 bytes\n+    \/\/ result will be sliced out of src1 and lower\n+    \/\/ four 128 bit lanes of src2.\n+    \/\/ i.e.\n+    \/\/ res[127:0]   = {src1[511:384], src1[383:255]}\n+    \/\/ res[255:128] = {src2[127:0],   src1[511:384]}\n+    \/\/ res[383:256] = {src2[255:128], src2[127:0]}\n+    \/\/ res[511:384] = {src2[383:256], src2[255:128]}\n+    \/\/ Thus, source vector lanes should have following format.\n+    \/\/ src1 = {v3, v4, v5, v6} and src2 = {v4, v5, v6, v7}\n+     evalignd(xtmp, src2, src1, 8, vlen_enc);\n+     evalignd(dst, src2, src1, 12, vlen_enc);\n+     vpalignr(dst, dst, xtmp, origin - 32, vlen_enc);\n+   } else {\n+    \/\/ Finally, for SHIFT greater than 48 bytes\n+    \/\/ result will be sliced out of upper 128 bit lane of src1 and\n+    \/\/ src2.\n+    \/\/ i.e.\n+    \/\/ res[127:0]   = {src2[127:0],   src1[511:383]}\n+    \/\/ res[255:128] = {src2[255:127], src2[127:0]}\n+    \/\/ res[383:256] = {src2[383:256], src2[255:128]}\n+    \/\/ res[511:384] = {src2[511:384], src2[383:256]}\n+    \/\/ Thus, source vector lanes should have following format.\n+    \/\/ src1 = {v4, v5, v6, v7} and src2 = {v5, v6, v7, v8}\n+     assert(origin > 48 && origin < 64, \"\");\n+     evalignd(xtmp, src2, src1, 12, vlen_enc);\n+     vpalignr(dst, src2, xtmp, origin - 48, vlen_enc);\n+   }\n+}\n+\n+void C2_MacroAssembler::vector_slice_op(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                        XMMRegister xtmp, int origin, int vlen_enc) {\n+  if (VM_Version::supports_avx512vlbw()) {\n+    vector_slice_64B_op(dst, src1, src2, xtmp, origin, vlen_enc);\n+  } else {\n+    assert(vlen_enc == Assembler::AVX_256bit, \"\");\n+    vector_slice_32B_op(dst, src1, src2, xtmp, origin, vlen_enc);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":127,"deletions":0,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -573,0 +573,6 @@\n+  void vector_slice_32B_op(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp, int origin, int vlen_enc);\n+\n+  void vector_slice_64B_op(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp, int origin, int vlen_enc);\n+\n+  void vector_slice_op(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp, int origin, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,0 +144,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1726,0 +1726,8 @@\n+    case Op_VectorSlice:\n+      if (UseAVX < 1 || size_in_bits < 128) {\n+        return false;\n+      }\n+      if (size_in_bits == 512 && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      break;\n@@ -10762,0 +10770,64 @@\n+instruct vector_slice_const_origin_LT16B_reg(vec dst, vec src1, vec src2, immI origin)\n+%{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  format %{ \"vector_slice_const_origin $dst, $origin, $src1, $src2 \\t\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpalignr($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, $origin$$constant, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_slice_const_origin_GT16B_index16B_reg(vec dst, vec src1, vec src2, immI origin)\n+%{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 && !VM_Version::supports_avx512vlbw() && n->in(2)->get_int() == 16);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  format %{ \"vector_slice_const_origin $dst, $origin, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    \/\/ src1 = [v2, v1], src2 = [v4, v3]\n+    \/\/ dst = [v3, v2]\n+    __ vperm2i128($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, 0x21);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_slice_const_origin_GT16B_reg(vec dst, vec src1, vec src2, immI origin, vec xtmp)\n+%{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 && !VM_Version::supports_avx512vlbw() && n->in(2)->get_int() != 16);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  effect(TEMP xtmp);\n+  format %{ \"vector_slice_const_origin $dst, $origin, $src1, $src2 \\t!using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_slice_op($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp$$XMMRegister, $origin$$constant, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_slice_const_origin_GT16B_index_multiple4_reg_evex(vec dst, vec src1, vec src2, immI origin)\n+%{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 && VM_Version::supports_avx512vlbw() && (n->in(2)->get_int() & 0x3) == 0);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  format %{ \"vector_slice_const_origin $dst, $origin, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int normalized_origin = $origin$$constant >> 2;\n+    __ evalignd($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, normalized_origin, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_slice_const_origin_GT16B_reg_evex(vec dst, vec src1, vec src2, immI origin, vec xtmp)\n+%{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 && VM_Version::supports_avx512vlbw() && (n->in(2)->get_int() & 0x3) != 0);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"vector_slice_const_origin $dst, $origin, $src1, $src2 \\t!using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_slice_op($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp$$XMMRegister, $origin$$constant, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -4366,1 +4366,1 @@\n-    \"VectorUCastB2X\", \"VectorUCastS2X\", \"VectorUCastI2X\",\n+    \"VectorUCastB2X\", \"VectorUCastS2X\", \"VectorUCastI2X\", \"VectorSlice\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1170,0 +1170,12 @@\n+  do_intrinsic(_VectorSlice, jdk_internal_vm_vector_VectorSupport, vector_slice_name, vector_slice_sig, F_S)                                   \\\n+   do_signature(vector_slice_sig, \"(I\"                                                                                                         \\\n+                                   \"Ljava\/lang\/Class;\"                                                                                         \\\n+                                   \"Ljava\/lang\/Class;\"                                                                                         \\\n+                                   \"I\"                                                                                                         \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                             \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                             \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSliceOp;)\"                                                     \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                     \\\n+   do_name(vector_slice_name, \"sliceOp\")                                                                                                         \\\n+                                                                                                                                               \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -844,0 +844,1 @@\n+  case vmIntrinsics::_VectorSlice:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -444,0 +444,25 @@\n+class LateInlineVectorCallGenerator : public LateInlineCallGenerator {\n+ protected:\n+ CallGenerator* _inline_cg;\n+\n+ public:\n+  LateInlineVectorCallGenerator(ciMethod* method, CallGenerator* intrinsic_cg, CallGenerator* inline_cg) :\n+    LateInlineCallGenerator(method, intrinsic_cg) , _inline_cg(inline_cg) {}\n+\n+  CallGenerator* inline_cg2() const { return _inline_cg; }\n+  bool inline_fallback();\n+  virtual bool is_vector_late_inline() const { return true; }\n+};\n+\n+bool LateInlineVectorCallGenerator::inline_fallback() {\n+  switch (method()->intrinsic_id()) {\n+    case vmIntrinsics::_VectorSlice: return true;\n+    default : return false;\n+  }\n+}\n+\n+CallGenerator* CallGenerator::for_vector_late_inline(ciMethod* m, CallGenerator* intrinsic_cg, CallGenerator* inline_cg) {\n+  return new LateInlineVectorCallGenerator(m, intrinsic_cg, inline_cg);\n+}\n+\n+\n@@ -676,0 +701,8 @@\n+    \/\/ Attempt inlining fallback implementation in case of\n+    \/\/ intrinsification failure.\n+    if (new_jvms == nullptr && is_vector_late_inline()) {\n+      LateInlineVectorCallGenerator* late_inline_vec_cg =  static_cast<LateInlineVectorCallGenerator*>(this);\n+      if (late_inline_vec_cg->inline_fallback()) {\n+        new_jvms = late_inline_vec_cg->inline_cg2()->generate(jvms);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  virtual bool      is_vector_late_inline() const  { return false; }\n@@ -144,0 +145,1 @@\n+  static CallGenerator* for_vector_late_inline(ciMethod* m, CallGenerator* intrinsic_cg, CallGenerator* inline_cg);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -524,0 +524,1 @@\n+macro(VectorSlice)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -167,1 +167,3 @@\n-        return CallGenerator::for_late_inline(callee, cg);\n+        float expected_uses = jvms->method()->scale_count(site_count, prof_factor);\n+        CallGenerator* inline_cg = CallGenerator::for_inline(callee, expected_uses);\n+        return CallGenerator::for_vector_late_inline(callee, cg, inline_cg);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -776,0 +776,2 @@\n+  case vmIntrinsics::_VectorSlice:\n+    return inline_vector_slice();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -414,0 +414,1 @@\n+  bool inline_vector_slice();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2512,0 +2512,1 @@\n+    case Op_VectorSlice:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1663,0 +1663,70 @@\n+\n+\/\/ public interface VectorSliceOp<V extends Vector<?>> {\n+\/\/     VectorPayload apply(int origin, V v1, V v2);\n+\/\/ }\n+\/\/\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  E>\n+\/\/ VectorPayload sliceOp(int origin,\n+\/\/                       Class<? extends V> vClass, Class<E> eClass, int length, V v1, V v2,\n+\/\/                       VectorSliceOp<V> defaultImpl)\n+bool LibraryCallKit::inline_vector_slice() {\n+  const TypeInt*     origin       = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n+\n+  if (origin == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {\n+    return false; \/\/ dead code\n+  }\n+  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()]);\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+  if (!is_klass_initialized(vector_klass)) {\n+    log_if_needed(\"  ** klass argument not initialized\");\n+    return false;\n+  }\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = elem_type->basic_type();\n+\n+  if (Matcher::supports_vector_slice_with_non_constant_index(num_elem, elem_bt) || !origin->is_con()) {\n+    log_if_needed(\"  ** vector slice from non-constant index not supported\");\n+    return false;\n+  }\n+\n+  if (!arch_supports_vector(Op_VectorSlice, num_elem, elem_bt, VecMaskNotUsed)) {\n+    log_if_needed(\"  ** not supported: arity=2 op=slice vlen=%d etype=%s\",\n+                    num_elem, type2name(elem_bt));\n+    return false; \/\/ not supported\n+  }\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  Node* v1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  Node* v2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  if (v1 == nullptr || v2 == nullptr) {\n+    return false; \/\/ operand unboxing failed\n+  }\n+\n+  \/\/ Defining origin in terms of number of bytes to make it type agnostic value.\n+  Node* origin_node = gvn().intcon(origin->get_con() * type2aelembytes(elem_bt));\n+  const TypeVect* vector_type = TypeVect::make(elem_bt, num_elem);\n+  Node* operation = gvn().transform(new VectorSliceNode(v1, v2, origin_node, vector_type));\n+  Node* box = box_vector(operation, vbox_type, elem_bt, num_elem);\n+  set_result(box);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2406,0 +2406,15 @@\n+\n+Node* VectorSliceNode::Identity(PhaseGVN* phase) {\n+  if (origin()->is_Con()) {\n+    jint index = origin()->get_int();\n+    uint vlen = vect_type()->length_in_bytes();\n+    if (vlen == (uint)index) {\n+      return vec2();\n+    }\n+    if (index == 0) {\n+      return vec1();\n+    }\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1720,0 +1720,14 @@\n+class VectorSliceNode : public VectorNode {\n+ public:\n+  VectorSliceNode(Node* vec1, Node* vec2, Node* origin, const TypeVect* vt)\n+    : VectorNode(vec1, vec2, origin, vt) {\n+  }\n+\n+  virtual int Opcode() const;\n+  Node* vec1() const { return in(1); }\n+  Node* vec2() const { return in(2); }\n+  Node* origin() const { return in(3); }\n+  virtual Node* Identity(PhaseGVN* phase);\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -761,0 +761,14 @@\n+    public interface VectorSliceOp<V extends Vector<E>, E> {\n+        V apply(int origin, V v1, V v2);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     E>\n+    V sliceOp(int origin, Class<?> vClass, Class<E> eClass, int length, V v1, V v2,\n+              VectorSliceOp<V, E> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(origin, v1, v2);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2307,0 +2307,1 @@\n+\n@@ -2310,1 +2311,2 @@\n-    ByteVector sliceTemplate(int origin, Vector<Byte> v1) {\n+    <V extends Vector<Byte>>\n+    ByteVector sliceTemplate(int origin, V v1) {\n@@ -2314,5 +2316,9 @@\n-        ByteVector iotaVector = (ByteVector) iotaShuffle().toBitsVector();\n-        ByteVector filter = broadcast((byte)(length() - origin));\n-        VectorMask<Byte> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Byte> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (ByteVector)VectorSupport.sliceOp(origin, getClass(), byte.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                ByteVector iotaVector = (ByteVector) vec1.iotaShuffle().toBitsVector();\n+                ByteVector filter = vec1.broadcast((byte)(vec1.length() - index));\n+                VectorMask<Byte> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Byte> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2345,5 +2351,10 @@\n-        ByteVector iotaVector = (ByteVector) iotaShuffle().toBitsVector();\n-        ByteVector filter = broadcast((byte)(length() - origin));\n-        VectorMask<Byte> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Byte> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        ByteVector that = (ByteVector) vspecies().zero();\n+        return (ByteVector)VectorSupport.sliceOp(origin, getClass(), byte.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                ByteVector iotaVector = (ByteVector) vec1.iotaShuffle().toBitsVector();\n+                ByteVector filter = vec1.broadcast((byte)(vec1.length() - index));\n+                VectorMask<Byte> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Byte> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2161,0 +2161,1 @@\n+\n@@ -2164,1 +2165,2 @@\n-    DoubleVector sliceTemplate(int origin, Vector<Double> v1) {\n+    <V extends Vector<Double>>\n+    DoubleVector sliceTemplate(int origin, V v1) {\n@@ -2168,5 +2170,10 @@\n-        LongVector iotaVector = (LongVector) iotaShuffle().toBitsVector();\n-        LongVector filter = LongVector.broadcast((LongVector.LongSpecies) vspecies().asIntegral(), (long)(length() - origin));\n-        VectorMask<Double> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n-        AbstractShuffle<Double> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (DoubleVector)VectorSupport.sliceOp(origin, getClass(), double.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                LongVector iotaVector = (LongVector) vec1.iotaShuffle().toBitsVector();\n+                LongVector filter = LongVector.broadcast((LongVector.LongSpecies) vec1.vspecies().asIntegral(),\n+                                                                     (long)(vec1.length() - index));\n+                VectorMask<Double> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n+                AbstractShuffle<Double> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2199,5 +2206,11 @@\n-        LongVector iotaVector = (LongVector) iotaShuffle().toBitsVector();\n-        LongVector filter = LongVector.broadcast((LongVector.LongSpecies) vspecies().asIntegral(), (long)(length() - origin));\n-        VectorMask<Double> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n-        AbstractShuffle<Double> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        DoubleVector that = (DoubleVector) vspecies().zero();\n+        return (DoubleVector)VectorSupport.sliceOp(origin, getClass(), double.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                LongVector iotaVector = (LongVector) vec1.iotaShuffle().toBitsVector();\n+                LongVector filter = LongVector.broadcast((LongVector.LongSpecies) vec1.vspecies().asIntegral(),\n+                                                                     (long)(vec1.length() - index));\n+                VectorMask<Double> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n+                AbstractShuffle<Double> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2173,0 +2173,1 @@\n+\n@@ -2176,1 +2177,2 @@\n-    FloatVector sliceTemplate(int origin, Vector<Float> v1) {\n+    <V extends Vector<Float>>\n+    FloatVector sliceTemplate(int origin, V v1) {\n@@ -2180,5 +2182,10 @@\n-        IntVector iotaVector = (IntVector) iotaShuffle().toBitsVector();\n-        IntVector filter = IntVector.broadcast((IntVector.IntSpecies) vspecies().asIntegral(), (int)(length() - origin));\n-        VectorMask<Float> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n-        AbstractShuffle<Float> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (FloatVector)VectorSupport.sliceOp(origin, getClass(), float.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                IntVector iotaVector = (IntVector) vec1.iotaShuffle().toBitsVector();\n+                IntVector filter = IntVector.broadcast((IntVector.IntSpecies) vec1.vspecies().asIntegral(),\n+                                                                     (int)(vec1.length() - index));\n+                VectorMask<Float> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n+                AbstractShuffle<Float> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2211,5 +2218,11 @@\n-        IntVector iotaVector = (IntVector) iotaShuffle().toBitsVector();\n-        IntVector filter = IntVector.broadcast((IntVector.IntSpecies) vspecies().asIntegral(), (int)(length() - origin));\n-        VectorMask<Float> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n-        AbstractShuffle<Float> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        FloatVector that = (FloatVector) vspecies().zero();\n+        return (FloatVector)VectorSupport.sliceOp(origin, getClass(), float.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                IntVector iotaVector = (IntVector) vec1.iotaShuffle().toBitsVector();\n+                IntVector filter = IntVector.broadcast((IntVector.IntSpecies) vec1.vspecies().asIntegral(),\n+                                                                     (int)(vec1.length() - index));\n+                VectorMask<Float> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n+                AbstractShuffle<Float> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2292,0 +2292,1 @@\n+\n@@ -2295,1 +2296,2 @@\n-    IntVector sliceTemplate(int origin, Vector<Integer> v1) {\n+    <V extends Vector<Integer>>\n+    IntVector sliceTemplate(int origin, V v1) {\n@@ -2299,5 +2301,9 @@\n-        IntVector iotaVector = (IntVector) iotaShuffle().toBitsVector();\n-        IntVector filter = broadcast((int)(length() - origin));\n-        VectorMask<Integer> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Integer> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (IntVector)VectorSupport.sliceOp(origin, getClass(), int.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                IntVector iotaVector = (IntVector) vec1.iotaShuffle().toBitsVector();\n+                IntVector filter = vec1.broadcast((int)(vec1.length() - index));\n+                VectorMask<Integer> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Integer> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2330,5 +2336,10 @@\n-        IntVector iotaVector = (IntVector) iotaShuffle().toBitsVector();\n-        IntVector filter = broadcast((int)(length() - origin));\n-        VectorMask<Integer> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Integer> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        IntVector that = (IntVector) vspecies().zero();\n+        return (IntVector)VectorSupport.sliceOp(origin, getClass(), int.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                IntVector iotaVector = (IntVector) vec1.iotaShuffle().toBitsVector();\n+                IntVector filter = vec1.broadcast((int)(vec1.length() - index));\n+                VectorMask<Integer> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Integer> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2158,0 +2158,1 @@\n+\n@@ -2161,1 +2162,2 @@\n-    LongVector sliceTemplate(int origin, Vector<Long> v1) {\n+    <V extends Vector<Long>>\n+    LongVector sliceTemplate(int origin, V v1) {\n@@ -2165,5 +2167,9 @@\n-        LongVector iotaVector = (LongVector) iotaShuffle().toBitsVector();\n-        LongVector filter = broadcast((long)(length() - origin));\n-        VectorMask<Long> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Long> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (LongVector)VectorSupport.sliceOp(origin, getClass(), long.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                LongVector iotaVector = (LongVector) vec1.iotaShuffle().toBitsVector();\n+                LongVector filter = vec1.broadcast((long)(vec1.length() - index));\n+                VectorMask<Long> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Long> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2196,5 +2202,10 @@\n-        LongVector iotaVector = (LongVector) iotaShuffle().toBitsVector();\n-        LongVector filter = broadcast((long)(length() - origin));\n-        VectorMask<Long> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Long> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        LongVector that = (LongVector) vspecies().zero();\n+        return (LongVector)VectorSupport.sliceOp(origin, getClass(), long.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                LongVector iotaVector = (LongVector) vec1.iotaShuffle().toBitsVector();\n+                LongVector filter = vec1.broadcast((long)(vec1.length() - index));\n+                VectorMask<Long> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Long> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2308,0 +2308,1 @@\n+\n@@ -2311,1 +2312,2 @@\n-    ShortVector sliceTemplate(int origin, Vector<Short> v1) {\n+    <V extends Vector<Short>>\n+    ShortVector sliceTemplate(int origin, V v1) {\n@@ -2315,5 +2317,9 @@\n-        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n-        ShortVector filter = broadcast((short)(length() - origin));\n-        VectorMask<Short> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Short> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (ShortVector)VectorSupport.sliceOp(origin, getClass(), short.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                ShortVector iotaVector = (ShortVector) vec1.iotaShuffle().toBitsVector();\n+                ShortVector filter = vec1.broadcast((short)(vec1.length() - index));\n+                VectorMask<Short> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Short> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2346,5 +2352,10 @@\n-        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n-        ShortVector filter = broadcast((short)(length() - origin));\n-        VectorMask<Short> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Short> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        ShortVector that = (ShortVector) vspecies().zero();\n+        return (ShortVector)VectorSupport.sliceOp(origin, getClass(), short.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                ShortVector iotaVector = (ShortVector) vec1.iotaShuffle().toBitsVector();\n+                ShortVector filter = vec1.broadcast((short)(vec1.length() - index));\n+                VectorMask<Short> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Short> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2720,0 +2720,1 @@\n+\n@@ -2723,1 +2724,2 @@\n-    $abstractvectortype$ sliceTemplate(int origin, Vector<$Boxtype$> v1) {\n+    <V extends Vector<$Boxtype$>>\n+    $abstractvectortype$ sliceTemplate(int origin, V v1) {\n@@ -2727,1 +2729,3 @@\n-        $Bitstype$Vector iotaVector = ($Bitstype$Vector) iotaShuffle().toBitsVector();\n+        return ($abstractvectortype$)VectorSupport.sliceOp(origin, getClass(), $type$.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                $Bitstype$Vector iotaVector = ($Bitstype$Vector) vec1.iotaShuffle().toBitsVector();\n@@ -2729,2 +2733,3 @@\n-        $Bitstype$Vector filter = $Bitstype$Vector.broadcast(($Bitstype$Vector.$Bitstype$Species) vspecies().asIntegral(), ($bitstype$)(length() - origin));\n-        VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n+                $Bitstype$Vector filter = $Bitstype$Vector.broadcast(($Bitstype$Vector.$Bitstype$Species) vec1.vspecies().asIntegral(),\n+                                                                     ($bitstype$)(vec1.length() - index));\n+                VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n@@ -2732,2 +2737,2 @@\n-        $abstractvectortype$ filter = broadcast(($type$)(length() - origin));\n-        VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                $abstractvectortype$ filter = vec1.broadcast(($type$)(vec1.length() - index));\n+                VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n@@ -2735,2 +2740,4 @@\n-        AbstractShuffle<$Boxtype$> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+                AbstractShuffle<$Boxtype$> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2763,1 +2770,4 @@\n-        $Bitstype$Vector iotaVector = ($Bitstype$Vector) iotaShuffle().toBitsVector();\n+        $abstractvectortype$ that = ($abstractvectortype$) vspecies().zero();\n+        return ($abstractvectortype$)VectorSupport.sliceOp(origin, getClass(), $type$.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                $Bitstype$Vector iotaVector = ($Bitstype$Vector) vec1.iotaShuffle().toBitsVector();\n@@ -2765,2 +2775,3 @@\n-        $Bitstype$Vector filter = $Bitstype$Vector.broadcast(($Bitstype$Vector.$Bitstype$Species) vspecies().asIntegral(), ($bitstype$)(length() - origin));\n-        VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n+                $Bitstype$Vector filter = $Bitstype$Vector.broadcast(($Bitstype$Vector.$Bitstype$Species) vec1.vspecies().asIntegral(),\n+                                                                     ($bitstype$)(vec1.length() - index));\n+                VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n@@ -2768,2 +2779,2 @@\n-        $abstractvectortype$ filter = broadcast(($type$)(length() - origin));\n-        VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                $abstractvectortype$ filter = vec1.broadcast(($type$)(vec1.length() - index));\n+                VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n@@ -2771,2 +2782,4 @@\n-        AbstractShuffle<$Boxtype$> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+                AbstractShuffle<$Boxtype$> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2243,0 +2243,20 @@\n+    public static final String VECTOR_SLICE_B = VECTOR_PREFIX + \"VECTOR_SLICE_B\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_SLICE_B, \"VectorSlice\", TYPE_BYTE);\n+    }\n+\n+    public static final String VECTOR_SLICE_S = VECTOR_PREFIX + \"VECTOR_SLICE_S\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_SLICE_S, \"VectorSlice\", TYPE_SHORT);\n+    }\n+\n+    public static final String VECTOR_SLICE_I = VECTOR_PREFIX + \"VECTOR_SLICE_I\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_SLICE_I, \"VectorSlice\", TYPE_INT);\n+    }\n+\n+    public static final String VECTOR_SLICE_L = VECTOR_PREFIX + \"VECTOR_SLICE_L\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_SLICE_L, \"VectorSlice\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8303762\n+* @summary Optimize vector slice operation with constant index using VPALIGNR instruction\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xbatch -XX:TieredStopAtLevel=3 compiler.vectorapi.TestSliceOptValueTransforms\n+*\/\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import static compiler.lib.generators.Generators.G;\n+\n+public class TestSliceOptValueTransforms {\n+    public static final int SIZE = 1024;\n+\n+    public static final VectorSpecies<Byte> BSP = ByteVector.SPECIES_PREFERRED;\n+    public static final VectorSpecies<Short> SSP = ShortVector.SPECIES_PREFERRED;\n+    public static final VectorSpecies<Integer> ISP = IntVector.SPECIES_PREFERRED;\n+    public static final VectorSpecies<Long> LSP = LongVector.SPECIES_PREFERRED;\n+\n+    public static byte [] bsrc1;\n+    public static byte [] bsrc2;\n+    public static byte [] bdst;\n+\n+    public static short [] ssrc1;\n+    public static short [] ssrc2;\n+    public static short [] sdst;\n+\n+    public static int [] isrc1;\n+    public static int [] isrc2;\n+    public static int [] idst;\n+\n+    public static long [] lsrc1;\n+    public static long [] lsrc2;\n+    public static long [] ldst;\n+\n+    public TestSliceOptValueTransforms() {\n+        bsrc1 = new byte[SIZE];\n+        bsrc2 = new byte[SIZE];\n+        bdst  = new byte[SIZE];\n+\n+        ssrc1 = new short[SIZE];\n+        ssrc2 = new short[SIZE];\n+        sdst  = new short[SIZE];\n+\n+        isrc1 = new int[SIZE];\n+        isrc2 = new int[SIZE];\n+        idst  = new int[SIZE];\n+\n+        lsrc1 = new long[SIZE];\n+        lsrc2 = new long[SIZE];\n+        ldst  = new long[SIZE];\n+\n+        G.fill(G.ints(), isrc1);\n+        G.fill(G.ints(), isrc2);\n+        G.fill(G.longs(), lsrc1);\n+        G.fill(G.longs(), lsrc2);\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            bsrc1[i] = (byte)(isrc1[i]);\n+            bsrc2[i] = (byte)(isrc2[i]);\n+\n+            ssrc1[i] = (short)(isrc1[i]);\n+            ssrc2[i] = (short)(isrc2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_B}, applyIfCPUFeatureAnd = {\"avx2\", \"true\"})\n+    public void testZeroSliceIndexByte() {\n+        for (int i = 0; i < BSP.loopBound(SIZE); i += BSP.length()) {\n+            ByteVector.fromArray(BSP, bsrc1, i)\n+                      .slice(0, ByteVector.fromArray(BSP, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_B}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testMaxSliceIndexByte() {\n+        for (int i = 0; i < BSP.loopBound(SIZE); i += BSP.length()) {\n+            ByteVector.fromArray(BSP, bsrc1, i)\n+                      .slice(BSP.length(), ByteVector.fromArray(BSP, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE_B, \" >0 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testConstantSliceIndexByte() {\n+        for (int i = 0; i < BSP.loopBound(SIZE); i += BSP.length()) {\n+            ByteVector.fromArray(BSP, bsrc1, i)\n+                      .slice(1, ByteVector.fromArray(BSP, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index16B_reg\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"avx2\", \"true\"})\n+    public void test16BSliceIndexByte() {\n+        for (int i = 0; i < BSP.loopBound(SIZE); i += BSP.length()) {\n+            ByteVector.fromArray(BSP, bsrc1, i)\n+                      .slice(16, ByteVector.fromArray(BSP, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index_multiple4_reg_evex\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public void testMultipleOf4BSliceIndexByte() {\n+        for (int i = 0; i < BSP.loopBound(SIZE); i += BSP.length()) {\n+            ByteVector.fromArray(BSP, bsrc1, i)\n+                      .slice(8, ByteVector.fromArray(BSP, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_S}, applyIfCPUFeatureAnd = {\"avx2\", \"true\"})\n+    public void testZeroSliceIndexShort() {\n+        for (int i = 0; i < SSP.loopBound(SIZE); i += SSP.length()) {\n+            ShortVector.fromArray(SSP, ssrc1, i)\n+                       .slice(0, ShortVector.fromArray(SSP, ssrc2, i))\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_S}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testMaxSliceIndexShort() {\n+        for (int i = 0; i < SSP.loopBound(SIZE); i += SSP.length()) {\n+            ShortVector.fromArray(SSP, ssrc1, i)\n+                       .slice(SSP.length(), ShortVector.fromArray(SSP, ssrc2, i))\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE_S, \" >0 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testConstantSliceIndexShort() {\n+        for (int i = 0; i < SSP.loopBound(SIZE); i += SSP.length()) {\n+            ShortVector.fromArray(SSP, ssrc1, i)\n+                       .slice(1, ShortVector.fromArray(SSP, ssrc2, i))\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index16B_reg\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"avx2\", \"true\"})\n+    public void test16BSliceIndexShort() {\n+        for (int i = 0; i < SSP.loopBound(SIZE); i += SSP.length()) {\n+            ShortVector.fromArray(SSP, ssrc1, i)\n+                       .slice(8, ShortVector.fromArray(SSP, ssrc2, i))\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index_multiple4_reg_evex\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public void testMultipleOf4BSliceIndexShort() {\n+        for (int i = 0; i < SSP.loopBound(SIZE); i += SSP.length()) {\n+            ShortVector.fromArray(SSP, ssrc1, i)\n+                       .slice(4, ShortVector.fromArray(SSP, ssrc2, i))\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_I}, applyIfCPUFeatureAnd = {\"avx2\", \"true\"})\n+    public void testZeroSliceIndexInt() {\n+        for (int i = 0; i < ISP.loopBound(SIZE); i += ISP.length()) {\n+            IntVector.fromArray(ISP, isrc1, i)\n+                     .slice(0, IntVector.fromArray(ISP, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_I}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testMaxSliceIndexInt() {\n+        for (int i = 0; i < ISP.loopBound(SIZE); i += ISP.length()) {\n+            IntVector.fromArray(ISP, isrc1, i)\n+                     .slice(ISP.length(), IntVector.fromArray(ISP, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE_I, \" >0 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testConstantSliceIndexInt() {\n+        for (int i = 0; i < ISP.loopBound(SIZE); i += ISP.length()) {\n+            IntVector.fromArray(ISP, isrc1, i)\n+                     .slice(1, IntVector.fromArray(ISP, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index16B_reg\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"avx2\", \"true\"})\n+    public void test16BSliceIndexInt() {\n+        for (int i = 0; i < ISP.loopBound(SIZE); i += ISP.length()) {\n+            IntVector.fromArray(ISP, isrc1, i)\n+                     .slice(4, IntVector.fromArray(ISP, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index_multiple4_reg_evex\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public void testMultipleOf4BSliceIndexInt() {\n+        for (int i = 0; i < ISP.loopBound(SIZE); i += ISP.length()) {\n+            IntVector.fromArray(ISP, isrc1, i)\n+                     .slice(4, IntVector.fromArray(ISP, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_L}, applyIfCPUFeatureAnd = {\"avx2\", \"true\"})\n+    public void testZeroSliceIndexLong() {\n+        for (int i = 0; i < LSP.loopBound(SIZE); i += LSP.length()) {\n+            LongVector.fromArray(LSP, lsrc1, i)\n+                      .slice(0, LongVector.fromArray(LSP, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_L}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testMaxSliceIndexLong() {\n+        for (int i = 0; i < LSP.loopBound(SIZE); i += LSP.length()) {\n+            LongVector.fromArray(LSP, lsrc1, i)\n+                      .slice(LSP.length(), LongVector.fromArray(LSP, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE_L, \" >0 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testConstantSliceIndexLong() {\n+        for (int i = 0; i < LSP.loopBound(SIZE); i += LSP.length()) {\n+            LongVector.fromArray(LSP, lsrc1, i)\n+                      .slice(1, LongVector.fromArray(LSP, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index16B_reg\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"avx2\", \"true\"})\n+    public void test16BSliceIndexLong() {\n+        for (int i = 0; i < LSP.loopBound(SIZE); i += LSP.length()) {\n+            LongVector.fromArray(LSP, lsrc1, i)\n+                      .slice(2, LongVector.fromArray(LSP, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index_multiple4_reg_evex\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public void testMultipleOf4BSliceIndexLong() {\n+        for (int i = 0; i < LSP.loopBound(SIZE); i += LSP.length()) {\n+            LongVector.fromArray(LSP, lsrc1, i)\n+                      .slice(2, LongVector.fromArray(LSP, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestSliceOptValueTransforms.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -788,1 +788,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgs = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorSliceBenchmark {\n+    @Param({\"1024\", \"2047\", \"4096\"})\n+    int size;\n+\n+    byte [] bsrc1;\n+    byte [] bsrc2;\n+    byte [] bdst;\n+\n+    short [] ssrc1;\n+    short [] ssrc2;\n+    short [] sdst;\n+\n+    int [] isrc1;\n+    int [] isrc2;\n+    int [] idst;\n+\n+    long [] lsrc1;\n+    long [] lsrc2;\n+    long [] ldst;\n+\n+    static final VectorSpecies<Byte> bspecies    = ByteVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Short> sspecies   = ShortVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Integer> ispecies = IntVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Long> lspecies    = LongVector.SPECIES_PREFERRED;\n+\n+    static final int B_SLICE_IDX1 = bspecies.length() \/ 2;\n+    static final int B_SLICE_IDX2 = bspecies.length() \/ 4;\n+\n+    static final int S_SLICE_IDX1 = sspecies.length() \/ 2;\n+    static final int S_SLICE_IDX2 = sspecies.length() \/ 4;\n+\n+    static final int I_SLICE_IDX1 = ispecies.length() \/ 2;\n+    static final int I_SLICE_IDX2 = ispecies.length() \/ 4;\n+\n+    static final int L_SLICE_IDX1 = lspecies.length() \/ 2;\n+    static final int L_SLICE_IDX2 = lspecies.length() \/ 4;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(2048);\n+\n+        bsrc1 = new byte[size];\n+        bsrc2 = new byte[size];\n+        bdst  = new byte[size];\n+\n+        ssrc1 = new short[size];\n+        ssrc2 = new short[size];\n+        sdst  = new short[size];\n+\n+        isrc1 = new int[size];\n+        isrc2 = new int[size];\n+        idst  = new int[size];\n+\n+        lsrc1 = new long[size];\n+        lsrc2 = new long[size];\n+        ldst  = new long[size];\n+\n+        for (int i = 0; i < size; i++) {\n+            bsrc1[i] = (byte)r.nextInt(size);\n+            bsrc2[i] = (byte)r.nextInt(size);\n+\n+            ssrc1[i] = (short)r.nextInt(size);\n+            ssrc2[i] = (short)r.nextInt(size);\n+\n+            isrc1[i] = r.nextInt(size);\n+            isrc2[i] = r.nextInt(size);\n+\n+            lsrc1[i] = r.nextLong(size);\n+            lsrc2[i] = r.nextLong(size);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteVectorSliceWithConstantIndex1() {\n+        for (int i = 0; i < bspecies.loopBound(bdst.length); i += bspecies.length()) {\n+            ByteVector.fromArray(bspecies, bsrc1, i)\n+                      .slice(B_SLICE_IDX1, ByteVector.fromArray(bspecies, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteVectorSliceWithConstantIndex2() {\n+        for (int i = 0; i < bspecies.loopBound(bdst.length); i += bspecies.length()) {\n+            ByteVector.fromArray(bspecies, bsrc1, i)\n+                      .slice(B_SLICE_IDX2, ByteVector.fromArray(bspecies, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteVectorSliceWithVariableIndex() {\n+        for (int i = 0; i < bspecies.loopBound(bdst.length); i += bspecies.length()) {\n+            ByteVector.fromArray(bspecies, bsrc1, i)\n+                      .slice(i & (bspecies.length() - 1), ByteVector.fromArray(bspecies, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortVectorSliceWithConstantIndex1() {\n+        for (int i = 0; i < sspecies.loopBound(sdst.length); i += bspecies.length()) {\n+            ShortVector.fromArray(sspecies, ssrc1, i)\n+                      .slice(S_SLICE_IDX1, ShortVector.fromArray(sspecies, ssrc2, i))\n+                      .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortVectorSliceWithConstantIndex2() {\n+        for (int i = 0; i < sspecies.loopBound(sdst.length); i += bspecies.length()) {\n+            ShortVector.fromArray(sspecies, ssrc1, i)\n+                      .slice(S_SLICE_IDX2, ShortVector.fromArray(sspecies, ssrc2, i))\n+                      .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortVectorSliceWithVariableIndex() {\n+        for (int i = 0; i < sspecies.loopBound(sdst.length); i += bspecies.length()) {\n+            ShortVector.fromArray(sspecies, ssrc1, i)\n+                      .slice(i & (sspecies.length() - 1), ShortVector.fromArray(sspecies, ssrc2, i))\n+                      .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVectorSliceWithConstantIndex1() {\n+        for (int i = 0; i < ispecies.loopBound(idst.length); i += ispecies.length()) {\n+            IntVector.fromArray(ispecies, isrc1, i)\n+                      .slice(I_SLICE_IDX1, IntVector.fromArray(ispecies, isrc2, i))\n+                      .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVectorSliceWithConstantIndex2() {\n+        for (int i = 0; i < ispecies.loopBound(idst.length); i += ispecies.length()) {\n+            IntVector.fromArray(ispecies, isrc1, i)\n+                     .slice(I_SLICE_IDX2, IntVector.fromArray(ispecies, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVectorSliceWithVariableIndex() {\n+        for (int i = 0; i < ispecies.loopBound(idst.length); i += ispecies.length()) {\n+            IntVector.fromArray(ispecies, isrc1, i)\n+                      .slice(i & (ispecies.length() - 1), IntVector.fromArray(ispecies, isrc2, i))\n+                      .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVectorSliceWithConstantIndex1() {\n+        for (int i = 0; i < lspecies.loopBound(ldst.length); i += lspecies.length()) {\n+            LongVector.fromArray(lspecies, lsrc1, i)\n+                      .slice(L_SLICE_IDX1, LongVector.fromArray(lspecies, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVectorSliceWithConstantIndex2() {\n+        for (int i = 0; i < lspecies.loopBound(ldst.length); i += lspecies.length()) {\n+            LongVector.fromArray(lspecies, lsrc1, i)\n+                      .slice(L_SLICE_IDX2, LongVector.fromArray(lspecies, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVectorSliceWithVariableIndex() {\n+        for (int i = 0; i < lspecies.loopBound(ldst.length); i += lspecies.length()) {\n+            LongVector.fromArray(lspecies, lsrc1, i)\n+                      .slice(i & (lspecies.length() - 1), LongVector.fromArray(lspecies, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorSliceBenchmark.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"}]}