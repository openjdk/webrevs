{"files":[{"patch":"@@ -6611,4 +6611,2 @@\n-  assert(vector_len == AVX_128bit? VM_Version::supports_avx() :\n-         vector_len == AVX_256bit? VM_Version::supports_avx2() :\n-         vector_len == AVX_512bit? VM_Version::supports_avx512bw() :\n-         0, \"\");\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n@@ -6622,0 +6620,1 @@\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7118,1 +7118,1 @@\n-   if (origin <= 16) {\n+   if (origin < 16) {\n@@ -7159,1 +7159,1 @@\n-  if (origin <= 16) {\n+  if (origin < 16) {\n@@ -7187,1 +7187,1 @@\n-   } else if (origin > 16 && origin <= 32) {\n+   } else if (origin > 16 && origin < 32) {\n@@ -7201,1 +7201,1 @@\n-   } else if (origin > 32 && origin <= 48) {\n+   } else if (origin > 32 && origin < 48) {\n@@ -7226,1 +7226,1 @@\n-     assert(origin > 48 && origin <= 64, \"\");\n+     assert(origin > 48 && origin < 64, \"\");\n@@ -7234,1 +7234,1 @@\n-  if (VM_Version::supports_avx512vl() || vlen_enc == Assembler::AVX_512bit) {\n+  if (VM_Version::supports_avx512vlbw()) {\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1730,0 +1730,3 @@\n+      if (size_in_bits == 512 && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n@@ -10779,0 +10782,14 @@\n+instruct vector_slice_const_origin_GT16B_index16B_reg(vec dst, vec src1, vec src2, immI origin)\n+%{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 && !VM_Version::supports_avx512vlbw() && n->in(2)->get_int() == 16);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  format %{ \"vector_slice_const_origin $dst, $origin, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    \/\/ src1 = [v2, v1], src2 = [v4, v3]\n+    \/\/ dst = [v3, v2]\n+    __ vperm2i128($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, 0x21);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -10781,1 +10798,1 @@\n-  predicate(Matcher::vector_length_in_bytes(n) > 16 && !VM_Version::supports_avx512vlbw());\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 && !VM_Version::supports_avx512vlbw() && n->in(2)->get_int() != 16);\n@@ -10792,0 +10809,13 @@\n+instruct vector_slice_const_origin_GT16B_index_multiple4_reg_evex(vec dst, vec src1, vec src2, immI origin)\n+%{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 && VM_Version::supports_avx512vlbw() && (n->in(2)->get_int() & 0x3) == 0);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  format %{ \"vector_slice_const_origin $dst, $origin, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int normalized_origin = $origin$$constant >> 2;\n+    __ evalignd($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, normalized_origin, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -10794,1 +10824,1 @@\n-  predicate(Matcher::vector_length_in_bytes(n) > 16 && VM_Version::supports_avx512vlbw());\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 && VM_Version::supports_avx512vlbw() && (n->in(2)->get_int() & 0x3) != 0);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1675,1 +1675,1 @@\n-  const TypeInt*     origin         = gvn().type(argument(0))->isa_int();\n+  const TypeInt*     origin       = gvn().type(argument(0))->isa_int();\n@@ -1703,1 +1703,1 @@\n-  if (!Matcher::supports_vector_slice_with_non_constant_index(num_elem, elem_bt) && !origin->is_con()) {\n+  if (Matcher::supports_vector_slice_with_non_constant_index(num_elem, elem_bt) || !origin->is_con()) {\n@@ -1709,1 +1709,1 @@\n-    log_if_needed(\"  ** not supported: arity=2 op=slice vlen=%d etype=%s ismask=useload\/none\",\n+    log_if_needed(\"  ** not supported: arity=2 op=slice vlen=%d etype=%s\",\n@@ -1723,0 +1723,1 @@\n+  \/\/ Defining origin in terms of number of bytes to make it type agnostic value.\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2406,0 +2406,15 @@\n+\n+Node* VectorSliceNode::Identity(PhaseGVN* phase) {\n+  if (origin()->is_Con()) {\n+    jint index = origin()->get_int();\n+    uint vlen = vect_type()->length_in_bytes();\n+    if (vlen == (uint)index) {\n+      return vec2();\n+    }\n+    if (index == 0) {\n+      return vec1();\n+    }\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1730,0 +1730,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2243,0 +2243,20 @@\n+    public static final String VECTOR_SLICE_B = VECTOR_PREFIX + \"VECTOR_SLICE_B\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_SLICE_B, \"VectorSlice\", TYPE_BYTE);\n+    }\n+\n+    public static final String VECTOR_SLICE_S = VECTOR_PREFIX + \"VECTOR_SLICE_S\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_SLICE_S, \"VectorSlice\", TYPE_SHORT);\n+    }\n+\n+    public static final String VECTOR_SLICE_I = VECTOR_PREFIX + \"VECTOR_SLICE_I\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_SLICE_I, \"VectorSlice\", TYPE_INT);\n+    }\n+\n+    public static final String VECTOR_SLICE_L = VECTOR_PREFIX + \"VECTOR_SLICE_L\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_SLICE_L, \"VectorSlice\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8303762\n+* @summary Optimize vector slice operation with constant index using VPALIGNR instruction\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xbatch -XX:TieredStopAtLevel=3 compiler.vectorapi.TestSliceOptValueTransforms\n+*\/\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import static compiler.lib.generators.Generators.G;\n+\n+public class TestSliceOptValueTransforms {\n+    public static final int SIZE = 1024;\n+\n+    public static final VectorSpecies<Byte> BSP = ByteVector.SPECIES_PREFERRED;\n+    public static final VectorSpecies<Short> SSP = ShortVector.SPECIES_PREFERRED;\n+    public static final VectorSpecies<Integer> ISP = IntVector.SPECIES_PREFERRED;\n+    public static final VectorSpecies<Long> LSP = LongVector.SPECIES_PREFERRED;\n+\n+    public static byte [] bsrc1;\n+    public static byte [] bsrc2;\n+    public static byte [] bdst;\n+\n+    public static short [] ssrc1;\n+    public static short [] ssrc2;\n+    public static short [] sdst;\n+\n+    public static int [] isrc1;\n+    public static int [] isrc2;\n+    public static int [] idst;\n+\n+    public static long [] lsrc1;\n+    public static long [] lsrc2;\n+    public static long [] ldst;\n+\n+    public TestSliceOptValueTransforms() {\n+        bsrc1 = new byte[SIZE];\n+        bsrc2 = new byte[SIZE];\n+        bdst  = new byte[SIZE];\n+\n+        ssrc1 = new short[SIZE];\n+        ssrc2 = new short[SIZE];\n+        sdst  = new short[SIZE];\n+\n+        isrc1 = new int[SIZE];\n+        isrc2 = new int[SIZE];\n+        idst  = new int[SIZE];\n+\n+        lsrc1 = new long[SIZE];\n+        lsrc2 = new long[SIZE];\n+        ldst  = new long[SIZE];\n+\n+        G.fill(G.ints(), isrc1);\n+        G.fill(G.ints(), isrc2);\n+        G.fill(G.longs(), lsrc1);\n+        G.fill(G.longs(), lsrc2);\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            bsrc1[i] = (byte)(isrc1[i]);\n+            bsrc2[i] = (byte)(isrc2[i]);\n+\n+            ssrc1[i] = (short)(isrc1[i]);\n+            ssrc2[i] = (short)(isrc2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_B}, applyIfCPUFeatureAnd = {\"avx2\", \"true\"})\n+    public void testZeroSliceIndexByte() {\n+        for (int i = 0; i < BSP.loopBound(SIZE); i += BSP.length()) {\n+            ByteVector.fromArray(BSP, bsrc1, i)\n+                      .slice(0, ByteVector.fromArray(BSP, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_B}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testMaxSliceIndexByte() {\n+        for (int i = 0; i < BSP.loopBound(SIZE); i += BSP.length()) {\n+            ByteVector.fromArray(BSP, bsrc1, i)\n+                      .slice(BSP.length(), ByteVector.fromArray(BSP, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE_B, \" >0 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testConstantSliceIndexByte() {\n+        for (int i = 0; i < BSP.loopBound(SIZE); i += BSP.length()) {\n+            ByteVector.fromArray(BSP, bsrc1, i)\n+                      .slice(1, ByteVector.fromArray(BSP, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index16B_reg\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"avx2\", \"true\"})\n+    public void test16BSliceIndexByte() {\n+        for (int i = 0; i < BSP.loopBound(SIZE); i += BSP.length()) {\n+            ByteVector.fromArray(BSP, bsrc1, i)\n+                      .slice(16, ByteVector.fromArray(BSP, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index_multiple4_reg_evex\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public void testMultipleOf4BSliceIndexByte() {\n+        for (int i = 0; i < BSP.loopBound(SIZE); i += BSP.length()) {\n+            ByteVector.fromArray(BSP, bsrc1, i)\n+                      .slice(8, ByteVector.fromArray(BSP, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_S}, applyIfCPUFeatureAnd = {\"avx2\", \"true\"})\n+    public void testZeroSliceIndexShort() {\n+        for (int i = 0; i < SSP.loopBound(SIZE); i += SSP.length()) {\n+            ShortVector.fromArray(SSP, ssrc1, i)\n+                       .slice(0, ShortVector.fromArray(SSP, ssrc2, i))\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_S}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testMaxSliceIndexShort() {\n+        for (int i = 0; i < SSP.loopBound(SIZE); i += SSP.length()) {\n+            ShortVector.fromArray(SSP, ssrc1, i)\n+                       .slice(SSP.length(), ShortVector.fromArray(SSP, ssrc2, i))\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE_S, \" >0 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testConstantSliceIndexShort() {\n+        for (int i = 0; i < SSP.loopBound(SIZE); i += SSP.length()) {\n+            ShortVector.fromArray(SSP, ssrc1, i)\n+                       .slice(1, ShortVector.fromArray(SSP, ssrc2, i))\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index16B_reg\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"avx2\", \"true\"})\n+    public void test16BSliceIndexShort() {\n+        for (int i = 0; i < SSP.loopBound(SIZE); i += SSP.length()) {\n+            ShortVector.fromArray(SSP, ssrc1, i)\n+                       .slice(8, ShortVector.fromArray(SSP, ssrc2, i))\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index_multiple4_reg_evex\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public void testMultipleOf4BSliceIndexShort() {\n+        for (int i = 0; i < SSP.loopBound(SIZE); i += SSP.length()) {\n+            ShortVector.fromArray(SSP, ssrc1, i)\n+                       .slice(4, ShortVector.fromArray(SSP, ssrc2, i))\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_I}, applyIfCPUFeatureAnd = {\"avx2\", \"true\"})\n+    public void testZeroSliceIndexInt() {\n+        for (int i = 0; i < ISP.loopBound(SIZE); i += ISP.length()) {\n+            IntVector.fromArray(ISP, isrc1, i)\n+                     .slice(0, IntVector.fromArray(ISP, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_I}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testMaxSliceIndexInt() {\n+        for (int i = 0; i < ISP.loopBound(SIZE); i += ISP.length()) {\n+            IntVector.fromArray(ISP, isrc1, i)\n+                     .slice(ISP.length(), IntVector.fromArray(ISP, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE_I, \" >0 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testConstantSliceIndexInt() {\n+        for (int i = 0; i < ISP.loopBound(SIZE); i += ISP.length()) {\n+            IntVector.fromArray(ISP, isrc1, i)\n+                     .slice(1, IntVector.fromArray(ISP, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index16B_reg\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"avx2\", \"true\"})\n+    public void test16BSliceIndexInt() {\n+        for (int i = 0; i < ISP.loopBound(SIZE); i += ISP.length()) {\n+            IntVector.fromArray(ISP, isrc1, i)\n+                     .slice(4, IntVector.fromArray(ISP, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index_multiple4_reg_evex\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public void testMultipleOf4BSliceIndexInt() {\n+        for (int i = 0; i < ISP.loopBound(SIZE); i += ISP.length()) {\n+            IntVector.fromArray(ISP, isrc1, i)\n+                     .slice(4, IntVector.fromArray(ISP, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_L}, applyIfCPUFeatureAnd = {\"avx2\", \"true\"})\n+    public void testZeroSliceIndexLong() {\n+        for (int i = 0; i < LSP.loopBound(SIZE); i += LSP.length()) {\n+            LongVector.fromArray(LSP, lsrc1, i)\n+                      .slice(0, LongVector.fromArray(LSP, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_SLICE_L}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testMaxSliceIndexLong() {\n+        for (int i = 0; i < LSP.loopBound(SIZE); i += LSP.length()) {\n+            LongVector.fromArray(LSP, lsrc1, i)\n+                      .slice(LSP.length(), LongVector.fromArray(LSP, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE_L, \" >0 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testConstantSliceIndexLong() {\n+        for (int i = 0; i < LSP.loopBound(SIZE); i += LSP.length()) {\n+            LongVector.fromArray(LSP, lsrc1, i)\n+                      .slice(1, LongVector.fromArray(LSP, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index16B_reg\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"avx2\", \"true\"})\n+    public void test16BSliceIndexLong() {\n+        for (int i = 0; i < LSP.loopBound(SIZE); i += LSP.length()) {\n+            LongVector.fromArray(LSP, lsrc1, i)\n+                      .slice(2, LongVector.fromArray(LSP, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"vector_slice_const_origin_GT16B_index_multiple4_reg_evex\", \" >0 \"},\n+        phase = {CompilePhase.MATCHING}, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public void testMultipleOf4BSliceIndexLong() {\n+        for (int i = 0; i < LSP.loopBound(SIZE); i += LSP.length()) {\n+            LongVector.fromArray(LSP, lsrc1, i)\n+                      .slice(2, LongVector.fromArray(LSP, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestSliceOptValueTransforms.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -788,1 +788,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}