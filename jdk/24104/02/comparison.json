{"files":[{"patch":"@@ -153,0 +153,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -146,0 +146,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -155,0 +155,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -152,0 +152,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -149,0 +149,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6613,0 +6613,1 @@\n+         vector_len == AVX_512bit? VM_Version::supports_avx512bw() :\n@@ -6619,0 +6620,8 @@\n+void Assembler::evalignd(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x3, (0xC0 | encode), imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2170,0 +2170,1 @@\n+  void evalignd(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7115,0 +7115,127 @@\n+void C2_MacroAssembler::vector_slice_32B_op(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                            XMMRegister xtmp, int origin, int vlen_enc) {\n+   assert(vlen_enc == Assembler::AVX_256bit, \"\");\n+   if (origin <= 16) {\n+     \/\/ ALIGNR instruction concatenates the corresponding 128 bit\n+     \/\/ lanes of two source vectors and then performs the right\n+     \/\/ shift operation over intermediate value. Thus source vectors\n+     \/\/ lanes needs to shuffled to a format consumable by ALIGNR.\n+     \/\/ i.e.\n+     \/\/ Initial source vectors\n+     \/\/         0...256            0...256\n+     \/\/ src1 = [v1 v2]   and src2= [v3  v4]\n+     \/\/ Formatted source vectors when SHIFT < 16 bytes\n+     \/\/         0...256            0...256\n+     \/\/ src1 = [v1  v2] and src2 = [v2  v3]\n+     \/\/ Higher 128bit lane of src2 will not impact result, which will be\n+     \/\/ sliced from lower and higher 128 bit lane of src1 and lower 128 bit\n+     \/\/ lane of src2.\n+     \/\/ i.e.\n+     \/\/ Result lanes\n+     \/\/ res[127:0]   = {src1[255:128] , src1[127:0]}    >> SHIFT\n+     \/\/ res[255:128] = {src2[127:0]   , src1[255:128]}  >> SHIFT\n+     vperm2i128(xtmp, src1, src2, 0x21);\n+     vpalignr(dst, xtmp, src1, origin, Assembler::AVX_256bit);\n+   } else {\n+     assert(origin > 16 && origin <= 32, \"\");\n+     \/\/ Similarly, when SHIFT >= 16 bytes, lower 128bit lane of\n+     \/\/ src1 will not impact result, which will be sliced from\n+     \/\/ higher 128 bit lane of src1 and lower and upper 128 bit\n+     \/\/ lanes of src2.\n+     \/\/ Thus, two source vector should have following format\n+     \/\/         0...256            0...256\n+     \/\/ src1 = [v2  v3] and src2 = [v3  v4]\n+     \/\/ Result lanes\n+     \/\/ res[127:0]   = {src2[127:0]   , src1[255:127]}  >> SHIFT\n+     \/\/ res[255:128] = {src2[255:128] , src2[127:0]}    >> SHIFT\n+     vperm2i128(xtmp, src1, src2, 0x21);\n+     vpalignr(dst, src2, xtmp, origin - 16, Assembler::AVX_256bit);\n+   }\n+}\n+\n+\n+void C2_MacroAssembler::vector_slice_64B_op(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                            XMMRegister xtmp, int origin, int vlen_enc) {\n+  if (origin <= 16) {\n+    \/\/ Initial source vectors\n+    \/\/        0.........512            0.........512\n+    \/\/ src1 = [v1 v2 v3 v4] and src2 = [v5 v6 v7 v8]\n+    \/\/ where v* represents 128 bit wide vector lanes.\n+    \/\/ When SHIFT <= 16 result will be sliced out from src1 and\n+    \/\/ lowest 128 bit vector lane\n+    \/\/ of src2.\n+    \/\/ ALIGNR will consider following source vector lanes pairs\n+    \/\/ spread across two source vectors in order to compute 128 bit\n+    \/\/ lanes of result vector.\n+    \/\/ res[127:0]   = {src1[255:128], src1[127:0]}\n+    \/\/ res[255:128] = {src1[383:256], src1[255:128]}\n+    \/\/ res[383:256] = {src1[511:384], src1[383:256]}\n+    \/\/ res[511:384] = {src2[127:0],   src1[511:384]}\n+    \/\/\n+    \/\/ ALIGNR concatenates corresponding lanes across source vectors\n+    \/\/ before right shifting the intermediate result. Therefore, source\n+    \/\/ vector lanes should be shuffled to have following format\n+    \/\/ src1 = {v1, v2, v3, v4} and src2 = {v2, v3, v4, v5}\n+    \/\/\n+    \/\/                       |-------------|\n+    \/\/                 |-----|--------|    |\n+    \/\/ alignr ->  [v1 v2 v3 v4] [v2 v3 v4 v5]\n+    \/\/            |_____|________|    |\n+    \/\/                  |_____________|\n+     evalignd(xtmp, src2, src1, 4, vlen_enc);\n+     vpalignr(dst, xtmp, src1, origin, vlen_enc);\n+   } else if (origin > 16 && origin <= 32) {\n+    \/\/ Similarly, for SHIFT between 16 and 32 bytes\n+    \/\/ result will be sliced out of src1 and lower\n+    \/\/ two 128 bit lanes of src2.\n+    \/\/ i.e.\n+    \/\/ res[127:0]   = {src1[383:256], src1[255:128]}\n+    \/\/ res[255:128] = {src1[511:384], src1[383:256]}\n+    \/\/ res[383:256] = {src2[127:0],   src1[511:384]}\n+    \/\/ res[511:384] = {src2[255:128], src2[127:0]}\n+    \/\/ Thus, source vector lanes should have following format.\n+    \/\/ src1 = {v2, v3, v4, v5} and src2 = {v3, v4, v5, v6}\n+     evalignd(xtmp, src2, src1, 4, vlen_enc);\n+     evalignd(dst, src2, src1, 8, vlen_enc);\n+     vpalignr(dst, dst, xtmp, origin - 16, vlen_enc);\n+   } else if (origin > 32 && origin <= 48) {\n+    \/\/ For SHIFT between 32 and 48 bytes\n+    \/\/ result will be sliced out of src1 and lower\n+    \/\/ four 128 bit lanes of src2.\n+    \/\/ i.e.\n+    \/\/ res[127:0]   = {src1[511:384], src1[383:255]}\n+    \/\/ res[255:128] = {src2[127:0],   src1[511:384]}\n+    \/\/ res[383:256] = {src2[255:128], src2[127:0]}\n+    \/\/ res[511:384] = {src2[383:256], src2[255:128]}\n+    \/\/ Thus, source vector lanes should have following format.\n+    \/\/ src1 = {v3, v4, v5, v6} and src2 = {v4, v5, v6, v7}\n+     evalignd(xtmp, src2, src1, 8, vlen_enc);\n+     evalignd(dst, src2, src1, 12, vlen_enc);\n+     vpalignr(dst, dst, xtmp, origin - 32, vlen_enc);\n+   } else {\n+    \/\/ Finally, for SHIFT greater than 48 bytes\n+    \/\/ result will be sliced out of upper 128 bit lane of src1 and\n+    \/\/ src2.\n+    \/\/ i.e.\n+    \/\/ res[127:0]   = {src2[127:0],   src1[511:383]}\n+    \/\/ res[255:128] = {src2[255:127], src2[127:0]}\n+    \/\/ res[383:256] = {src2[383:256], src2[255:128]}\n+    \/\/ res[511:384] = {src2[511:384], src2[383:256]}\n+    \/\/ Thus, source vector lanes should have following format.\n+    \/\/ src1 = {v4, v5, v6, v7} and src2 = {v5, v6, v7, v8}\n+     assert(origin > 48 && origin <= 64, \"\");\n+     evalignd(xtmp, src2, src1, 12, vlen_enc);\n+     vpalignr(dst, src2, xtmp, origin - 48, vlen_enc);\n+   }\n+}\n+\n+void C2_MacroAssembler::vector_slice_op(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                        XMMRegister xtmp, int origin, int vlen_enc) {\n+  if (VM_Version::supports_avx512vl() || vlen_enc == Assembler::AVX_512bit) {\n+    vector_slice_64B_op(dst, src1, src2, xtmp, origin, vlen_enc);\n+  } else {\n+    assert(vlen_enc == Assembler::AVX_256bit, \"\");\n+    vector_slice_32B_op(dst, src1, src2, xtmp, origin, vlen_enc);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":127,"deletions":0,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -573,0 +573,6 @@\n+  void vector_slice_32B_op(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp, int origin, int vlen_enc);\n+\n+  void vector_slice_64B_op(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp, int origin, int vlen_enc);\n+\n+  void vector_slice_op(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp, int origin, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,0 +144,5 @@\n+  \/\/ Does the CPU supports vector slice from non-constant index?\n+  static constexpr bool supports_vector_slice_with_non_constant_index(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1726,0 +1726,5 @@\n+    case Op_VectorSlice:\n+      if (UseAVX < 1 || size_in_bits < 128) {\n+        return false;\n+      }\n+      break;\n@@ -10762,0 +10767,37 @@\n+instruct vector_slice_const_origin_LT16B_reg(vec dst, vec src1, vec src2, immI origin)\n+%{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  format %{ \"vector_slice_const_origin $dst, $origin, $src1, $src2 \\t\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpalignr($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, $origin$$constant, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_slice_const_origin_GT16B_reg(vec dst, vec src1, vec src2, immI origin, vec xtmp)\n+%{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 && !VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  effect(TEMP xtmp);\n+  format %{ \"vector_slice_const_origin $dst, $origin, $src1, $src2 \\t!using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_slice_op($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp$$XMMRegister, $origin$$constant, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_slice_const_origin_GT16B_reg_evex(vec dst, vec src1, vec src2, immI origin, vec xtmp)\n+%{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 && VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"vector_slice_const_origin $dst, $origin, $src1, $src2 \\t!using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_slice_op($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp$$XMMRegister, $origin$$constant, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -4366,1 +4366,1 @@\n-    \"VectorUCastB2X\", \"VectorUCastS2X\", \"VectorUCastI2X\",\n+    \"VectorUCastB2X\", \"VectorUCastS2X\", \"VectorUCastI2X\", \"VectorSlice\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1170,0 +1170,12 @@\n+  do_intrinsic(_VectorSlice, jdk_internal_vm_vector_VectorSupport, vector_slice_name, vector_slice_sig, F_S)                                   \\\n+   do_signature(vector_slice_sig, \"(I\"                                                                                                         \\\n+                                   \"Ljava\/lang\/Class;\"                                                                                         \\\n+                                   \"Ljava\/lang\/Class;\"                                                                                         \\\n+                                   \"I\"                                                                                                         \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                             \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                             \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSliceOp;)\"                                                     \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                     \\\n+   do_name(vector_slice_name, \"sliceOp\")                                                                                                         \\\n+                                                                                                                                               \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -844,0 +844,1 @@\n+  case vmIntrinsics::_VectorSlice:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -444,0 +444,25 @@\n+class LateInlineVectorCallGenerator : public LateInlineCallGenerator {\n+ protected:\n+ CallGenerator* _inline_cg;\n+\n+ public:\n+  LateInlineVectorCallGenerator(ciMethod* method, CallGenerator* intrinsic_cg, CallGenerator* inline_cg) :\n+    LateInlineCallGenerator(method, intrinsic_cg) , _inline_cg(inline_cg) {}\n+\n+  CallGenerator* inline_cg2() const { return _inline_cg; }\n+  bool inline_fallback();\n+  virtual bool is_vector_late_inline() const { return true; }\n+};\n+\n+bool LateInlineVectorCallGenerator::inline_fallback() {\n+  switch (method()->intrinsic_id()) {\n+    case vmIntrinsics::_VectorSlice: return true;\n+    default : return false;\n+  }\n+}\n+\n+CallGenerator* CallGenerator::for_vector_late_inline(ciMethod* m, CallGenerator* intrinsic_cg, CallGenerator* inline_cg) {\n+  return new LateInlineVectorCallGenerator(m, intrinsic_cg, inline_cg);\n+}\n+\n+\n@@ -676,0 +701,8 @@\n+    \/\/ Attempt inlining fallback implementation in case of\n+    \/\/ intrinsification failure.\n+    if (new_jvms == nullptr && is_vector_late_inline()) {\n+      LateInlineVectorCallGenerator* late_inline_vec_cg =  static_cast<LateInlineVectorCallGenerator*>(this);\n+      if (late_inline_vec_cg->inline_fallback()) {\n+        new_jvms = late_inline_vec_cg->inline_cg2()->generate(jvms);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  virtual bool      is_vector_late_inline() const  { return false; }\n@@ -144,0 +145,1 @@\n+  static CallGenerator* for_vector_late_inline(ciMethod* m, CallGenerator* intrinsic_cg, CallGenerator* inline_cg);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -524,0 +524,1 @@\n+macro(VectorSlice)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -167,1 +167,3 @@\n-        return CallGenerator::for_late_inline(callee, cg);\n+        float expected_uses = jvms->method()->scale_count(site_count, prof_factor);\n+        CallGenerator* inline_cg = CallGenerator::for_inline(callee, expected_uses);\n+        return CallGenerator::for_vector_late_inline(callee, cg, inline_cg);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -776,0 +776,2 @@\n+  case vmIntrinsics::_VectorSlice:\n+    return inline_vector_slice();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -414,0 +414,1 @@\n+  bool inline_vector_slice();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2512,0 +2512,1 @@\n+    case Op_VectorSlice:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1663,0 +1663,69 @@\n+\n+\/\/ public interface VectorSliceOp<V extends Vector<?>> {\n+\/\/     VectorPayload apply(int origin, V v1, V v2);\n+\/\/ }\n+\/\/\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  E>\n+\/\/ VectorPayload sliceOp(int origin,\n+\/\/                       Class<? extends V> vClass, Class<E> eClass, int length, V v1, V v2,\n+\/\/                       VectorSliceOp<V> defaultImpl)\n+bool LibraryCallKit::inline_vector_slice() {\n+  const TypeInt*     origin         = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n+\n+  if (origin == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {\n+    return false; \/\/ dead code\n+  }\n+  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()]);\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+  if (!is_klass_initialized(vector_klass)) {\n+    log_if_needed(\"  ** klass argument not initialized\");\n+    return false;\n+  }\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = elem_type->basic_type();\n+\n+  if (!Matcher::supports_vector_slice_with_non_constant_index(num_elem, elem_bt) && !origin->is_con()) {\n+    log_if_needed(\"  ** vector slice from non-constant index not supported\");\n+    return false;\n+  }\n+\n+  if (!arch_supports_vector(Op_VectorSlice, num_elem, elem_bt, VecMaskNotUsed)) {\n+    log_if_needed(\"  ** not supported: arity=2 op=slice vlen=%d etype=%s ismask=useload\/none\",\n+                    num_elem, type2name(elem_bt));\n+    return false; \/\/ not supported\n+  }\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  Node* v1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  Node* v2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  if (v1 == nullptr || v2 == nullptr) {\n+    return false; \/\/ operand unboxing failed\n+  }\n+\n+  Node* origin_node = gvn().intcon(origin->get_con() * type2aelembytes(elem_bt));\n+  const TypeVect* vector_type = TypeVect::make(elem_bt, num_elem);\n+  Node* operation = gvn().transform(new VectorSliceNode(v1, v2, origin_node, vector_type));\n+  Node* box = box_vector(operation, vbox_type, elem_bt, num_elem);\n+  set_result(box);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1720,0 +1720,13 @@\n+class VectorSliceNode : public VectorNode {\n+ public:\n+  VectorSliceNode(Node* vec1, Node* vec2, Node* origin, const TypeVect* vt)\n+    : VectorNode(vec1, vec2, origin, vt) {\n+  }\n+\n+  virtual int Opcode() const;\n+  Node* vec1() const { return in(1); }\n+  Node* vec2() const { return in(2); }\n+  Node* origin() const { return in(3); }\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -761,0 +761,14 @@\n+    public interface VectorSliceOp<V extends Vector<E>, E> {\n+        V apply(int origin, V v1, V v2);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     E>\n+    V sliceOp(int origin, Class<?> vClass, Class<E> eClass, int length, V v1, V v2,\n+              VectorSliceOp<V, E> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(origin, v1, v2);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2307,0 +2307,1 @@\n+\n@@ -2310,1 +2311,2 @@\n-    ByteVector sliceTemplate(int origin, Vector<Byte> v1) {\n+    <V extends Vector<Byte>>\n+    ByteVector sliceTemplate(int origin, V v1) {\n@@ -2314,5 +2316,9 @@\n-        ByteVector iotaVector = (ByteVector) iotaShuffle().toBitsVector();\n-        ByteVector filter = broadcast((byte)(length() - origin));\n-        VectorMask<Byte> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Byte> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (ByteVector)VectorSupport.sliceOp(origin, getClass(), byte.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                ByteVector iotaVector = (ByteVector) vec1.iotaShuffle().toBitsVector();\n+                ByteVector filter = vec1.broadcast((byte)(vec1.length() - index));\n+                VectorMask<Byte> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Byte> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2345,5 +2351,10 @@\n-        ByteVector iotaVector = (ByteVector) iotaShuffle().toBitsVector();\n-        ByteVector filter = broadcast((byte)(length() - origin));\n-        VectorMask<Byte> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Byte> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        ByteVector that = (ByteVector) vspecies().zero();\n+        return (ByteVector)VectorSupport.sliceOp(origin, getClass(), byte.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                ByteVector iotaVector = (ByteVector) vec1.iotaShuffle().toBitsVector();\n+                ByteVector filter = vec1.broadcast((byte)(vec1.length() - index));\n+                VectorMask<Byte> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Byte> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2161,0 +2161,1 @@\n+\n@@ -2164,1 +2165,2 @@\n-    DoubleVector sliceTemplate(int origin, Vector<Double> v1) {\n+    <V extends Vector<Double>>\n+    DoubleVector sliceTemplate(int origin, V v1) {\n@@ -2168,5 +2170,10 @@\n-        LongVector iotaVector = (LongVector) iotaShuffle().toBitsVector();\n-        LongVector filter = LongVector.broadcast((LongVector.LongSpecies) vspecies().asIntegral(), (long)(length() - origin));\n-        VectorMask<Double> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n-        AbstractShuffle<Double> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (DoubleVector)VectorSupport.sliceOp(origin, getClass(), double.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                LongVector iotaVector = (LongVector) vec1.iotaShuffle().toBitsVector();\n+                LongVector filter = LongVector.broadcast((LongVector.LongSpecies) vec1.vspecies().asIntegral(),\n+                                                                     (long)(vec1.length() - index));\n+                VectorMask<Double> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n+                AbstractShuffle<Double> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2199,5 +2206,11 @@\n-        LongVector iotaVector = (LongVector) iotaShuffle().toBitsVector();\n-        LongVector filter = LongVector.broadcast((LongVector.LongSpecies) vspecies().asIntegral(), (long)(length() - origin));\n-        VectorMask<Double> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n-        AbstractShuffle<Double> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        DoubleVector that = (DoubleVector) vspecies().zero();\n+        return (DoubleVector)VectorSupport.sliceOp(origin, getClass(), double.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                LongVector iotaVector = (LongVector) vec1.iotaShuffle().toBitsVector();\n+                LongVector filter = LongVector.broadcast((LongVector.LongSpecies) vec1.vspecies().asIntegral(),\n+                                                                     (long)(vec1.length() - index));\n+                VectorMask<Double> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n+                AbstractShuffle<Double> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2173,0 +2173,1 @@\n+\n@@ -2176,1 +2177,2 @@\n-    FloatVector sliceTemplate(int origin, Vector<Float> v1) {\n+    <V extends Vector<Float>>\n+    FloatVector sliceTemplate(int origin, V v1) {\n@@ -2180,5 +2182,10 @@\n-        IntVector iotaVector = (IntVector) iotaShuffle().toBitsVector();\n-        IntVector filter = IntVector.broadcast((IntVector.IntSpecies) vspecies().asIntegral(), (int)(length() - origin));\n-        VectorMask<Float> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n-        AbstractShuffle<Float> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (FloatVector)VectorSupport.sliceOp(origin, getClass(), float.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                IntVector iotaVector = (IntVector) vec1.iotaShuffle().toBitsVector();\n+                IntVector filter = IntVector.broadcast((IntVector.IntSpecies) vec1.vspecies().asIntegral(),\n+                                                                     (int)(vec1.length() - index));\n+                VectorMask<Float> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n+                AbstractShuffle<Float> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2211,5 +2218,11 @@\n-        IntVector iotaVector = (IntVector) iotaShuffle().toBitsVector();\n-        IntVector filter = IntVector.broadcast((IntVector.IntSpecies) vspecies().asIntegral(), (int)(length() - origin));\n-        VectorMask<Float> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n-        AbstractShuffle<Float> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        FloatVector that = (FloatVector) vspecies().zero();\n+        return (FloatVector)VectorSupport.sliceOp(origin, getClass(), float.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                IntVector iotaVector = (IntVector) vec1.iotaShuffle().toBitsVector();\n+                IntVector filter = IntVector.broadcast((IntVector.IntSpecies) vec1.vspecies().asIntegral(),\n+                                                                     (int)(vec1.length() - index));\n+                VectorMask<Float> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n+                AbstractShuffle<Float> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2292,0 +2292,1 @@\n+\n@@ -2295,1 +2296,2 @@\n-    IntVector sliceTemplate(int origin, Vector<Integer> v1) {\n+    <V extends Vector<Integer>>\n+    IntVector sliceTemplate(int origin, V v1) {\n@@ -2299,5 +2301,9 @@\n-        IntVector iotaVector = (IntVector) iotaShuffle().toBitsVector();\n-        IntVector filter = broadcast((int)(length() - origin));\n-        VectorMask<Integer> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Integer> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (IntVector)VectorSupport.sliceOp(origin, getClass(), int.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                IntVector iotaVector = (IntVector) vec1.iotaShuffle().toBitsVector();\n+                IntVector filter = vec1.broadcast((int)(vec1.length() - index));\n+                VectorMask<Integer> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Integer> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2330,5 +2336,10 @@\n-        IntVector iotaVector = (IntVector) iotaShuffle().toBitsVector();\n-        IntVector filter = broadcast((int)(length() - origin));\n-        VectorMask<Integer> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Integer> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        IntVector that = (IntVector) vspecies().zero();\n+        return (IntVector)VectorSupport.sliceOp(origin, getClass(), int.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                IntVector iotaVector = (IntVector) vec1.iotaShuffle().toBitsVector();\n+                IntVector filter = vec1.broadcast((int)(vec1.length() - index));\n+                VectorMask<Integer> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Integer> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2158,0 +2158,1 @@\n+\n@@ -2161,1 +2162,2 @@\n-    LongVector sliceTemplate(int origin, Vector<Long> v1) {\n+    <V extends Vector<Long>>\n+    LongVector sliceTemplate(int origin, V v1) {\n@@ -2165,5 +2167,9 @@\n-        LongVector iotaVector = (LongVector) iotaShuffle().toBitsVector();\n-        LongVector filter = broadcast((long)(length() - origin));\n-        VectorMask<Long> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Long> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (LongVector)VectorSupport.sliceOp(origin, getClass(), long.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                LongVector iotaVector = (LongVector) vec1.iotaShuffle().toBitsVector();\n+                LongVector filter = vec1.broadcast((long)(vec1.length() - index));\n+                VectorMask<Long> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Long> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2196,5 +2202,10 @@\n-        LongVector iotaVector = (LongVector) iotaShuffle().toBitsVector();\n-        LongVector filter = broadcast((long)(length() - origin));\n-        VectorMask<Long> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Long> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        LongVector that = (LongVector) vspecies().zero();\n+        return (LongVector)VectorSupport.sliceOp(origin, getClass(), long.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                LongVector iotaVector = (LongVector) vec1.iotaShuffle().toBitsVector();\n+                LongVector filter = vec1.broadcast((long)(vec1.length() - index));\n+                VectorMask<Long> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Long> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2308,0 +2308,1 @@\n+\n@@ -2311,1 +2312,2 @@\n-    ShortVector sliceTemplate(int origin, Vector<Short> v1) {\n+    <V extends Vector<Short>>\n+    ShortVector sliceTemplate(int origin, V v1) {\n@@ -2315,5 +2317,9 @@\n-        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n-        ShortVector filter = broadcast((short)(length() - origin));\n-        VectorMask<Short> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Short> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        return (ShortVector)VectorSupport.sliceOp(origin, getClass(), short.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                ShortVector iotaVector = (ShortVector) vec1.iotaShuffle().toBitsVector();\n+                ShortVector filter = vec1.broadcast((short)(vec1.length() - index));\n+                VectorMask<Short> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Short> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2346,5 +2352,10 @@\n-        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n-        ShortVector filter = broadcast((short)(length() - origin));\n-        VectorMask<Short> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n-        AbstractShuffle<Short> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+        ShortVector that = (ShortVector) vspecies().zero();\n+        return (ShortVector)VectorSupport.sliceOp(origin, getClass(), short.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                ShortVector iotaVector = (ShortVector) vec1.iotaShuffle().toBitsVector();\n+                ShortVector filter = vec1.broadcast((short)(vec1.length() - index));\n+                VectorMask<Short> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                AbstractShuffle<Short> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2720,0 +2720,1 @@\n+\n@@ -2723,1 +2724,2 @@\n-    $abstractvectortype$ sliceTemplate(int origin, Vector<$Boxtype$> v1) {\n+    <V extends Vector<$Boxtype$>>\n+    $abstractvectortype$ sliceTemplate(int origin, V v1) {\n@@ -2727,1 +2729,3 @@\n-        $Bitstype$Vector iotaVector = ($Bitstype$Vector) iotaShuffle().toBitsVector();\n+        return ($abstractvectortype$)VectorSupport.sliceOp(origin, getClass(), $type$.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                $Bitstype$Vector iotaVector = ($Bitstype$Vector) vec1.iotaShuffle().toBitsVector();\n@@ -2729,2 +2733,3 @@\n-        $Bitstype$Vector filter = $Bitstype$Vector.broadcast(($Bitstype$Vector.$Bitstype$Species) vspecies().asIntegral(), ($bitstype$)(length() - origin));\n-        VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n+                $Bitstype$Vector filter = $Bitstype$Vector.broadcast(($Bitstype$Vector.$Bitstype$Species) vec1.vspecies().asIntegral(),\n+                                                                     ($bitstype$)(vec1.length() - index));\n+                VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n@@ -2732,2 +2737,2 @@\n-        $abstractvectortype$ filter = broadcast(($type$)(length() - origin));\n-        VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                $abstractvectortype$ filter = vec1.broadcast(($type$)(vec1.length() - index));\n+                VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n@@ -2735,2 +2740,4 @@\n-        AbstractShuffle<$Boxtype$> iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+                AbstractShuffle<$Boxtype$> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.rearrange(iota).blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n@@ -2763,1 +2770,4 @@\n-        $Bitstype$Vector iotaVector = ($Bitstype$Vector) iotaShuffle().toBitsVector();\n+        $abstractvectortype$ that = ($abstractvectortype$) vspecies().zero();\n+        return ($abstractvectortype$)VectorSupport.sliceOp(origin, getClass(), $type$.class, length(), this, that,\n+            (index, vec1, vec2) ->  {\n+                $Bitstype$Vector iotaVector = ($Bitstype$Vector) vec1.iotaShuffle().toBitsVector();\n@@ -2765,2 +2775,3 @@\n-        $Bitstype$Vector filter = $Bitstype$Vector.broadcast(($Bitstype$Vector.$Bitstype$Species) vspecies().asIntegral(), ($bitstype$)(length() - origin));\n-        VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n+                $Bitstype$Vector filter = $Bitstype$Vector.broadcast(($Bitstype$Vector.$Bitstype$Species) vec1.vspecies().asIntegral(),\n+                                                                     ($bitstype$)(vec1.length() - index));\n+                VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vec1.vspecies());\n@@ -2768,2 +2779,2 @@\n-        $abstractvectortype$ filter = broadcast(($type$)(length() - origin));\n-        VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n+                $abstractvectortype$ filter = vec1.broadcast(($type$)(vec1.length() - index));\n+                VectorMask<$Boxtype$> blendMask = iotaVector.compare(VectorOperators.LT, filter);\n@@ -2771,2 +2782,4 @@\n-        AbstractShuffle<$Boxtype$> iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+                AbstractShuffle<$Boxtype$> iota = vec1.iotaShuffle(index, 1, true);\n+                return vec2.blend(vec1.rearrange(iota), blendMask);\n+            }\n+        );\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgs = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorSliceBenchmark {\n+    @Param({\"1024\", \"2047\", \"4096\"})\n+    int size;\n+\n+    byte [] bsrc1;\n+    byte [] bsrc2;\n+    byte [] bdst;\n+\n+    short [] ssrc1;\n+    short [] ssrc2;\n+    short [] sdst;\n+\n+    int [] isrc1;\n+    int [] isrc2;\n+    int [] idst;\n+\n+    long [] lsrc1;\n+    long [] lsrc2;\n+    long [] ldst;\n+\n+    static final VectorSpecies<Byte> bspecies    = ByteVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Short> sspecies   = ShortVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Integer> ispecies = IntVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Long> lspecies    = LongVector.SPECIES_PREFERRED;\n+\n+    static final int B_SLICE_IDX1 = bspecies.length() \/ 2;\n+    static final int B_SLICE_IDX2 = bspecies.length() \/ 4;\n+\n+    static final int S_SLICE_IDX1 = sspecies.length() \/ 2;\n+    static final int S_SLICE_IDX2 = sspecies.length() \/ 4;\n+\n+    static final int I_SLICE_IDX1 = ispecies.length() \/ 2;\n+    static final int I_SLICE_IDX2 = ispecies.length() \/ 4;\n+\n+    static final int L_SLICE_IDX1 = lspecies.length() \/ 2;\n+    static final int L_SLICE_IDX2 = lspecies.length() \/ 4;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(2048);\n+\n+        bsrc1 = new byte[size];\n+        bsrc2 = new byte[size];\n+        bdst  = new byte[size];\n+\n+        ssrc1 = new short[size];\n+        ssrc2 = new short[size];\n+        sdst  = new short[size];\n+\n+        isrc1 = new int[size];\n+        isrc2 = new int[size];\n+        idst  = new int[size];\n+\n+        lsrc1 = new long[size];\n+        lsrc2 = new long[size];\n+        ldst  = new long[size];\n+\n+        for (int i = 0; i < size; i++) {\n+            bsrc1[i] = (byte)r.nextInt(size);\n+            bsrc2[i] = (byte)r.nextInt(size);\n+\n+            ssrc1[i] = (short)r.nextInt(size);\n+            ssrc2[i] = (short)r.nextInt(size);\n+\n+            isrc1[i] = r.nextInt(size);\n+            isrc2[i] = r.nextInt(size);\n+\n+            lsrc1[i] = r.nextLong(size);\n+            lsrc2[i] = r.nextLong(size);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteVectorSliceWithConstantIndex1() {\n+        for (int i = 0; i < bspecies.loopBound(bdst.length); i += bspecies.length()) {\n+            ByteVector.fromArray(bspecies, bsrc1, i)\n+                      .slice(B_SLICE_IDX1, ByteVector.fromArray(bspecies, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteVectorSliceWithConstantIndex2() {\n+        for (int i = 0; i < bspecies.loopBound(bdst.length); i += bspecies.length()) {\n+            ByteVector.fromArray(bspecies, bsrc1, i)\n+                      .slice(B_SLICE_IDX2, ByteVector.fromArray(bspecies, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteVectorSliceWithVariableIndex() {\n+        for (int i = 0; i < bspecies.loopBound(bdst.length); i += bspecies.length()) {\n+            ByteVector.fromArray(bspecies, bsrc1, i)\n+                      .slice(i & (bspecies.length() - 1), ByteVector.fromArray(bspecies, bsrc2, i))\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortVectorSliceWithConstantIndex1() {\n+        for (int i = 0; i < sspecies.loopBound(sdst.length); i += bspecies.length()) {\n+            ShortVector.fromArray(sspecies, ssrc1, i)\n+                      .slice(S_SLICE_IDX1, ShortVector.fromArray(sspecies, ssrc2, i))\n+                      .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortVectorSliceWithConstantIndex2() {\n+        for (int i = 0; i < sspecies.loopBound(sdst.length); i += bspecies.length()) {\n+            ShortVector.fromArray(sspecies, ssrc1, i)\n+                      .slice(S_SLICE_IDX2, ShortVector.fromArray(sspecies, ssrc2, i))\n+                      .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortVectorSliceWithVariableIndex() {\n+        for (int i = 0; i < sspecies.loopBound(sdst.length); i += bspecies.length()) {\n+            ShortVector.fromArray(sspecies, ssrc1, i)\n+                      .slice(i & (sspecies.length() - 1), ShortVector.fromArray(sspecies, ssrc2, i))\n+                      .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVectorSliceWithConstantIndex1() {\n+        for (int i = 0; i < ispecies.loopBound(idst.length); i += ispecies.length()) {\n+            IntVector.fromArray(ispecies, isrc1, i)\n+                      .slice(I_SLICE_IDX1, IntVector.fromArray(ispecies, isrc2, i))\n+                      .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVectorSliceWithConstantIndex2() {\n+        for (int i = 0; i < ispecies.loopBound(idst.length); i += ispecies.length()) {\n+            IntVector.fromArray(ispecies, isrc1, i)\n+                     .slice(I_SLICE_IDX2, IntVector.fromArray(ispecies, isrc2, i))\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVectorSliceWithVariableIndex() {\n+        for (int i = 0; i < ispecies.loopBound(idst.length); i += ispecies.length()) {\n+            IntVector.fromArray(ispecies, isrc1, i)\n+                      .slice(i & (ispecies.length() - 1), IntVector.fromArray(ispecies, isrc2, i))\n+                      .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVectorSliceWithConstantIndex1() {\n+        for (int i = 0; i < lspecies.loopBound(ldst.length); i += lspecies.length()) {\n+            LongVector.fromArray(lspecies, lsrc1, i)\n+                      .slice(L_SLICE_IDX1, LongVector.fromArray(lspecies, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVectorSliceWithConstantIndex2() {\n+        for (int i = 0; i < lspecies.loopBound(ldst.length); i += lspecies.length()) {\n+            LongVector.fromArray(lspecies, lsrc1, i)\n+                      .slice(L_SLICE_IDX2, LongVector.fromArray(lspecies, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVectorSliceWithVariableIndex() {\n+        for (int i = 0; i < lspecies.loopBound(ldst.length); i += lspecies.length()) {\n+            LongVector.fromArray(lspecies, lsrc1, i)\n+                      .slice(i & (lspecies.length() - 1), LongVector.fromArray(lspecies, lsrc2, i))\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorSliceBenchmark.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"}]}