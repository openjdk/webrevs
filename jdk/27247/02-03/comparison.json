{"files":[{"patch":"@@ -62,0 +62,1 @@\n+import java.util.ArrayList;\n@@ -762,0 +763,2 @@\n+        private final Map<Pair<Type, Type>, Boolean> isSubtypeCache = new HashMap<>();\n+\n@@ -805,0 +808,6 @@\n+            \/\/A backtracking record of the original patterns (in value) that\n+            \/\/were used to produce the pattern in the key.\n+            \/\/Note that there may be multiple equivalent patterns in the key\n+            \/\/that originate in different sets of different original patterns,\n+            \/\/hence using identity map, to get the exact source patterns\n+            \/\/on which the resulting pattern is based:\n@@ -841,0 +850,2 @@\n+            } finally {\n+                isSubtypeCache.clear();\n@@ -897,1 +908,0 @@\n-                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n@@ -899,1 +909,1 @@\n-                            Type clazzErasure = types.erasure(clazz.type);\n+                            Type clazzType = clazz.type;\n@@ -901,2 +911,1 @@\n-                                                        .map(types::erasure)\n-                                                        .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                                                        .noneMatch(c -> isSubtypeErasure(clazzType, c))) {\n@@ -926,2 +935,2 @@\n-                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n-                                                                types.erasure(perm.type))) {\n+                                            if (isSubtypeErasure(currentPermitted.type,\n+                                                                 perm.type)) {\n@@ -932,2 +941,2 @@\n-                                        if (types.isSubtype(types.erasure(perm.type),\n-                                                            types.erasure(bpOther.type))) {\n+                                        if (isSubtypeErasure(perm.type,\n+                                                             bpOther.type)) {\n@@ -1057,3 +1066,1 @@\n-                            NEXT_PATTERN: for (int nextCandidate = 0;\n-                                               nextCandidate < candidatesArr.length;\n-                                               nextCandidate++) {\n+                            for (int nextCandidate = 0; nextCandidate < candidatesArr.length; nextCandidate++) {\n@@ -1065,38 +1072,3 @@\n-                                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                                    ACCEPT: for (int i = 0; i < rpOne.nested.length; i++) {\n-                                        if (i != mismatchingCandidate) {\n-                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                                if (useHashes) {\n-                                                    continue NEXT_PATTERN;\n-                                                }\n-                                                \/\/when not using hashes,\n-                                                \/\/check if rpOne.nested[i] is\n-                                                \/\/a subtype of rpOther.nested[i]:\n-                                                if (!(rpOther.nested[i] instanceof BindingPattern bpOther)) {\n-                                                    continue NEXT_PATTERN;\n-                                                }\n-                                                if (rpOne.nested[i] instanceof BindingPattern bpOne) {\n-                                                    if (!types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n-                                                        continue NEXT_PATTERN;\n-                                                    }\n-                                                } else if (rpOne.nested[i] instanceof RecordPattern nestedRPOne) {\n-                                                    Set<PatternDescription> pendingReplacedPatterns = new HashSet<>(replaces.getOrDefault(rpOther.nested[i], Set.of()));\n-\n-                                                    while (!pendingReplacedPatterns.isEmpty()) {\n-                                                        PatternDescription currentReplaced = pendingReplacedPatterns.iterator().next();\n-\n-                                                        pendingReplacedPatterns.remove(currentReplaced);\n-\n-                                                        if (nestedRPOne.equals(currentReplaced)) {\n-                                                            continue ACCEPT;\n-                                                        }\n-\n-                                                        pendingReplacedPatterns.addAll(replaces.getOrDefault(currentReplaced, Set.of()));\n-                                                    }\n-                                                    continue NEXT_PATTERN;\n-                                                } else {\n-                                                    continue NEXT_PATTERN;\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n+\n+                                if (rpOne.recordType.tsym == rpOther.recordType.tsym &&\n+                                    nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, replaces, useHashes)) {\n@@ -1144,0 +1116,65 @@\n+        \/* Returns true if all nested components of existing and candidate are\n+         * equivalent (if useHashes == true), or \"substitutable\" (if useHashes == false).\n+         * A candidate pattern is \"substitutable\" if it is a binding pattern, and:\n+         * - it's type is a supertype of the existing pattern's type\n+         * - it was produced by a reduction from a record pattern that is equivalent to\n+         *   the existing pattern\n+         *\/\n+        private boolean nestedComponentsEquivalent(RecordPattern existing,\n+                                                   RecordPattern candidate,\n+                                                   int mismatchingCandidate,\n+                                                   Map<PatternDescription, Set<PatternDescription>> replaces,\n+                                                   boolean useHashes) {\n+            NEXT_NESTED:\n+            for (int i = 0; i < existing.nested.length; i++) {\n+                if (i != mismatchingCandidate) {\n+                    if (!existing.nested[i].equals(candidate.nested[i])) {\n+                        if (useHashes) {\n+                            return false;\n+                        }\n+                        \/\/when not using hashes,\n+                        \/\/check if rpOne.nested[i] is\n+                        \/\/a subtype of rpOther.nested[i]:\n+                        if (!(candidate.nested[i] instanceof BindingPattern nestedCandidate)) {\n+                            return false;\n+                        }\n+                        if (existing.nested[i] instanceof BindingPattern nestedExisting) {\n+                            if (!isSubtypeErasure(nestedExisting.type, nestedCandidate.type)) {\n+                                return false;\n+                            }\n+                        } else if (existing.nested[i] instanceof RecordPattern nestedExisting) {\n+                            java.util.List<PatternDescription> pendingReplacedPatterns =\n+                                    new ArrayList<>(replaces.getOrDefault(nestedCandidate, Set.of()));\n+\n+                            while (!pendingReplacedPatterns.isEmpty()) {\n+                                PatternDescription currentReplaced = pendingReplacedPatterns.removeLast();\n+\n+                                if (nestedExisting.equals(currentReplaced)) {\n+                                    \/\/candidate.nested[i] is substitutable for existing.nested[i]\n+                                    \/\/continue with the next nested pattern:\n+                                    continue NEXT_NESTED;\n+                                }\n+\n+                                pendingReplacedPatterns.addAll(replaces.getOrDefault(currentReplaced, Set.of()));\n+                            }\n+\n+                            return false;\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        \/*The same as types.isSubtype(types.erasure(t), types.erasure(s)), but cached.\n+        *\/\n+        private boolean isSubtypeErasure(Type t, Type s) {\n+            Pair<Type, Type> key = Pair.of(t, s);\n+\n+            return isSubtypeCache.computeIfAbsent(key, _ ->\n+                    types.isSubtype(types.erasure(t), types.erasure(s)));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":86,"deletions":49,"binary":false,"changes":135,"status":"modified"}]}