{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.util.ArrayList;\n@@ -63,0 +64,1 @@\n+    private final Map<Pair<Type, Type>, Boolean> isSubtypeCache = new HashMap<>();\n@@ -123,0 +125,1 @@\n+        Set<Set<PatternDescription>> seenFallback = new HashSet<>();\n@@ -144,1 +147,1 @@\n-                    repeat = useHashes;\n+                    repeat = useHashes && seenFallback.add(updatedPatterns);\n@@ -157,0 +160,2 @@\n+        } finally {\n+            isSubtypeCache.clear();\n@@ -213,1 +218,0 @@\n-                        ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n@@ -215,1 +219,1 @@\n-                        Type clazzErasure = types.erasure(clazz.type);\n+                        Type clazzType = clazz.type;\n@@ -217,2 +221,1 @@\n-                                                    .map(types::erasure)\n-                                                    .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                                                    .noneMatch(c -> isSubtypeErasure(clazzType, c))) {\n@@ -242,2 +245,2 @@\n-                                        if (types.isSubtype(types.erasure(currentPermitted.type),\n-                                                            types.erasure(perm.type))) {\n+                                        if (isSubtypeErasure(currentPermitted.type,\n+                                                             perm.type)) {\n@@ -248,2 +251,2 @@\n-                                    if (types.isSubtype(types.erasure(perm.type),\n-                                                        types.erasure(bpOther.type))) {\n+                                    if (isSubtypeErasure(perm.type,\n+                                                         bpOther.type)) {\n@@ -372,3 +375,1 @@\n-                        NEXT_PATTERN: for (int nextCandidate = 0;\n-                                           nextCandidate < candidatesArr.length;\n-                                           nextCandidate++) {\n+                        for (int nextCandidate = 0; nextCandidate < candidatesArr.length; nextCandidate++) {\n@@ -380,16 +381,3 @@\n-                            if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                                for (int i = 0; i < rpOne.nested.length; i++) {\n-                                    if (i != mismatchingCandidate) {\n-                                        if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                            if (useHashes ||\n-                                                \/\/when not using hashes,\n-                                                \/\/check if rpOne.nested[i] is\n-                                                \/\/a subtype of rpOther.nested[i]:\n-                                                !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n-                                                !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n-                                                !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n-                                                continue NEXT_PATTERN;\n-                                            }\n-                                        }\n-                                    }\n-                                }\n+\n+                            if (rpOne.recordType.tsym == rpOther.recordType.tsym &&\n+                                nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, useHashes)) {\n@@ -416,1 +404,1 @@\n-                                current.add(new RecordPattern(rpOne.recordType(),\n+                                RecordPattern nue = new RecordPattern(rpOne.recordType(),\n@@ -418,1 +406,3 @@\n-                                                                newNested));\n+                                                                newNested,\n+                                                                new HashSet<>(join));\n+                                current.add(nue);\n@@ -435,0 +425,64 @@\n+    \/* Returns true if all nested components of existing and candidate are\n+     * equivalent (if useHashes == true), or \"substitutable\" (if useHashes == false).\n+     * A candidate pattern is \"substitutable\" if it is a binding pattern, and:\n+     * - it's type is a supertype of the existing pattern's type\n+     * - it was produced by a reduction from a record pattern that is equivalent to\n+     *   the existing pattern\n+     *\/\n+    private boolean nestedComponentsEquivalent(RecordPattern existing,\n+                                               RecordPattern candidate,\n+                                               int mismatchingCandidate,\n+                                               boolean useHashes) {\n+        NEXT_NESTED:\n+        for (int i = 0; i < existing.nested.length; i++) {\n+            if (i != mismatchingCandidate) {\n+                if (!existing.nested[i].equals(candidate.nested[i])) {\n+                    if (useHashes) {\n+                        return false;\n+                    }\n+                    \/\/when not using hashes,\n+                    \/\/check if rpOne.nested[i] is\n+                    \/\/a subtype of rpOther.nested[i]:\n+                    if (!(candidate.nested[i] instanceof BindingPattern nestedCandidate)) {\n+                        return false;\n+                    }\n+                    if (existing.nested[i] instanceof BindingPattern nestedExisting) {\n+                        if (!isSubtypeErasure(nestedExisting.type, nestedCandidate.type)) {\n+                            return false;\n+                        }\n+                    } else if (existing.nested[i] instanceof RecordPattern nestedExisting) {\n+                        java.util.List<PatternDescription> pendingReplacedPatterns =\n+                                new ArrayList<>(nestedCandidate.sourcePatterns());\n+\n+                        while (!pendingReplacedPatterns.isEmpty()) {\n+                            PatternDescription currentReplaced = pendingReplacedPatterns.removeLast();\n+\n+                            if (nestedExisting.equals(currentReplaced)) {\n+                                \/\/candidate.nested[i] is substitutable for existing.nested[i]\n+                                \/\/continue with the next nested pattern:\n+                                continue NEXT_NESTED;\n+                            }\n+\n+                            pendingReplacedPatterns.addAll(currentReplaced.sourcePatterns());\n+                        }\n+\n+                        return false;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    \/*The same as types.isSubtype(types.erasure(t), types.erasure(s)), but cached.\n+    *\/\n+    private boolean isSubtypeErasure(Type t, Type s) {\n+        Pair<Type, Type> key = Pair.of(t, s);\n+\n+        return isSubtypeCache.computeIfAbsent(key, _ ->\n+                types.isSubtype(types.erasure(t), types.erasure(s)));\n+    }\n+\n@@ -478,1 +532,2 @@\n-                return new BindingPattern(rpOne.recordType);\n+                PatternDescription pd = new BindingPattern(rpOne.recordType, Set.of(pattern));\n+                return pd;\n@@ -480,1 +535,2 @@\n-                return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+                PatternDescription pd = new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns, Set.of(pattern));\n+                return pd;\n@@ -515,1 +571,3 @@\n-    sealed interface PatternDescription { }\n+    sealed interface PatternDescription {\n+        public Set<PatternDescription> sourcePatterns();\n+    }\n@@ -550,1 +608,6 @@\n-    record BindingPattern(Type type) implements PatternDescription {\n+    record BindingPattern(Type type, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n+\n+        public BindingPattern(Type type) {\n+            this(type, Set.of());\n+        }\n+\n@@ -565,1 +628,1 @@\n-    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription[] nested, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n@@ -568,1 +631,5 @@\n-            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+            this(recordType, fullComponentTypes, nested, Set.of());\n+        }\n+\n+        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested, Set<PatternDescription> sourcePatterns) {\n+            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested, sourcePatterns);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":103,"deletions":36,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368\n+ * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368 8364991\n@@ -1639,1 +1639,2 @@\n-        variants.remove((int) (Math.random() * variants.size()));\n+        int removed = (int) (Math.random() * variants.size());\n+        variants.remove(removed);\n@@ -1642,1 +1643,1 @@\n-        System.err.println(\"analyzing:\");\n+        System.err.println(\"analyzing (removed: \" + removed + \"):\");\n@@ -2185,0 +2186,174 @@\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPaths(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2 _) -> 0; \/\/functionally equivalent to: Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _))\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root<Base> r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2 _) -> 0; \/\/functionally equivalent to: Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _))\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root<T>(T b1, T b2, T b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPathsSimplified(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test1(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   private int test2(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2 _,     R2(R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test1(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   private int test2(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2 _,     R2(R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2<T>(T b1) implements Base {}\n+                   record Root<T>(T b2, T b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testBindingPatternDoesNotStandInPlaceOfRecordPatterns(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R2 _, R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\",\n+               \"Test.java:4:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2 _, R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2<T>(T b) implements Base {}\n+                   record Root<T>(T b2, T b3) {}\n+               }\n+               \"\"\",\n+               \"Test.java:4:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":179,"deletions":4,"binary":false,"changes":183,"status":"modified"}]}