{"files":[{"patch":"@@ -62,0 +62,1 @@\n+import java.util.ArrayList;\n@@ -63,0 +64,1 @@\n+import java.util.IdentityHashMap;\n@@ -761,0 +763,2 @@\n+        private final Map<Pair<Type, Type>, Boolean> isSubtypeCache = new HashMap<>();\n+\n@@ -804,0 +808,8 @@\n+            \/\/A backtracking record of the original patterns (in value) that\n+            \/\/were used to produce the pattern in the key.\n+            \/\/Note that there may be multiple equivalent patterns in the key\n+            \/\/that originate in different sets of different original patterns,\n+            \/\/hence using identity map, to get the exact source patterns\n+            \/\/on which the resulting pattern is based:\n+            Map<PatternDescription, Set<PatternDescription>> replaces = new IdentityHashMap<>();\n+            Set<Set<PatternDescription>> seenFallback = new HashSet<>();\n@@ -810,2 +822,2 @@\n-                    updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n-                    updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                    updatedPatterns = reduceNestedPatterns(updatedPatterns, replaces, useHashes);\n+                    updatedPatterns = reduceRecordPatterns(updatedPatterns, replaces);\n@@ -825,1 +837,1 @@\n-                        repeat = useHashes;\n+                        repeat = useHashes && seenFallback.add(updatedPatterns);\n@@ -838,0 +850,2 @@\n+            } finally {\n+                isSubtypeCache.clear();\n@@ -894,1 +908,0 @@\n-                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n@@ -896,1 +909,1 @@\n-                            Type clazzErasure = types.erasure(clazz.type);\n+                            Type clazzType = clazz.type;\n@@ -898,2 +911,1 @@\n-                                                        .map(types::erasure)\n-                                                        .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                                                        .noneMatch(c -> isSubtypeErasure(clazzType, c))) {\n@@ -923,2 +935,2 @@\n-                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n-                                                                types.erasure(perm.type))) {\n+                                            if (isSubtypeErasure(currentPermitted.type,\n+                                                                 perm.type)) {\n@@ -929,2 +941,2 @@\n-                                        if (types.isSubtype(types.erasure(perm.type),\n-                                                            types.erasure(bpOther.type))) {\n+                                        if (isSubtypeErasure(perm.type,\n+                                                             bpOther.type)) {\n@@ -1011,0 +1023,1 @@\n+                                                             Map<PatternDescription, Set<PatternDescription>> replaces,\n@@ -1053,3 +1066,1 @@\n-                            NEXT_PATTERN: for (int nextCandidate = 0;\n-                                               nextCandidate < candidatesArr.length;\n-                                               nextCandidate++) {\n+                            for (int nextCandidate = 0; nextCandidate < candidatesArr.length; nextCandidate++) {\n@@ -1061,16 +1072,3 @@\n-                                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                                    for (int i = 0; i < rpOne.nested.length; i++) {\n-                                        if (i != mismatchingCandidate) {\n-                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                                if (useHashes ||\n-                                                    \/\/when not using hashes,\n-                                                    \/\/check if rpOne.nested[i] is\n-                                                    \/\/a subtype of rpOther.nested[i]:\n-                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n-                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n-                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n-                                                    continue NEXT_PATTERN;\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n+\n+                                if (rpOne.recordType.tsym == rpOther.recordType.tsym &&\n+                                    nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, replaces, useHashes)) {\n@@ -1082,1 +1080,1 @@\n-                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n+                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, replaces, useHashes);\n@@ -1084,1 +1082,1 @@\n-                            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                            updatedPatterns = reduceRecordPatterns(updatedPatterns, replaces);\n@@ -1097,1 +1095,1 @@\n-                                    current.add(new RecordPattern(rpOne.recordType(),\n+                                    RecordPattern nue = new RecordPattern(rpOne.recordType(),\n@@ -1099,1 +1097,3 @@\n-                                                                    newNested));\n+                                                                    newNested);\n+                                    current.add(nue);\n+                                    replaces.put(nue, new HashSet<>(join));\n@@ -1116,0 +1116,65 @@\n+        \/* Returns true if all nested components of existing and candidate are\n+         * equivalent (if useHashes == true), or \"substitutable\" (if useHashes == false).\n+         * A candidate pattern is \"substitutable\" if it is a binding pattern, and:\n+         * - it's type is a supertype of the existing pattern's type\n+         * - it was produced by a reduction from a record pattern that is equivalent to\n+         *   the existing pattern\n+         *\/\n+        private boolean nestedComponentsEquivalent(RecordPattern existing,\n+                                                   RecordPattern candidate,\n+                                                   int mismatchingCandidate,\n+                                                   Map<PatternDescription, Set<PatternDescription>> replaces,\n+                                                   boolean useHashes) {\n+            NEXT_NESTED:\n+            for (int i = 0; i < existing.nested.length; i++) {\n+                if (i != mismatchingCandidate) {\n+                    if (!existing.nested[i].equals(candidate.nested[i])) {\n+                        if (useHashes) {\n+                            return false;\n+                        }\n+                        \/\/when not using hashes,\n+                        \/\/check if rpOne.nested[i] is\n+                        \/\/a subtype of rpOther.nested[i]:\n+                        if (!(candidate.nested[i] instanceof BindingPattern nestedCandidate)) {\n+                            return false;\n+                        }\n+                        if (existing.nested[i] instanceof BindingPattern nestedExisting) {\n+                            if (!isSubtypeErasure(nestedExisting.type, nestedCandidate.type)) {\n+                                return false;\n+                            }\n+                        } else if (existing.nested[i] instanceof RecordPattern nestedExisting) {\n+                            java.util.List<PatternDescription> pendingReplacedPatterns =\n+                                    new ArrayList<>(replaces.getOrDefault(nestedCandidate, Set.of()));\n+\n+                            while (!pendingReplacedPatterns.isEmpty()) {\n+                                PatternDescription currentReplaced = pendingReplacedPatterns.removeLast();\n+\n+                                if (nestedExisting.equals(currentReplaced)) {\n+                                    \/\/candidate.nested[i] is substitutable for existing.nested[i]\n+                                    \/\/continue with the next nested pattern:\n+                                    continue NEXT_NESTED;\n+                                }\n+\n+                                pendingReplacedPatterns.addAll(replaces.getOrDefault(currentReplaced, Set.of()));\n+                            }\n+\n+                            return false;\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        \/*The same as types.isSubtype(types.erasure(t), types.erasure(s)), but cached.\n+        *\/\n+        private boolean isSubtypeErasure(Type t, Type s) {\n+            Pair<Type, Type> key = Pair.of(t, s);\n+\n+            return isSubtypeCache.computeIfAbsent(key, _ ->\n+                    types.isSubtype(types.erasure(t), types.erasure(s)));\n+        }\n+\n@@ -1121,1 +1186,1 @@\n-        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns, Map<PatternDescription, Set<PatternDescription>> replaces) {\n@@ -1126,1 +1191,1 @@\n-                    PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n+                    PatternDescription reducedPattern = reduceRecordPattern(rpOne, replaces);\n@@ -1138,1 +1203,1 @@\n-        private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n+        private PatternDescription reduceRecordPattern(PatternDescription pattern, Map<PatternDescription, Set<PatternDescription>> replaces) {\n@@ -1148,1 +1213,1 @@\n-                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n+                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i], replaces);\n@@ -1159,1 +1224,3 @@\n-                    return new BindingPattern(rpOne.recordType);\n+                    PatternDescription pd = new BindingPattern(rpOne.recordType);\n+                    replaces.put(pd, Set.of(pattern));\n+                    return pd;\n@@ -1161,1 +1228,3 @@\n-                    return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+                    PatternDescription pd = new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+                    replaces.put(pd, Set.of(pattern));\n+                    return pd;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":109,"deletions":40,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368\n+ * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368 8364991\n@@ -1639,1 +1639,2 @@\n-        variants.remove((int) (Math.random() * variants.size()));\n+        int removed = (int) (Math.random() * variants.size());\n+        variants.remove(removed);\n@@ -1642,1 +1643,1 @@\n-        System.err.println(\"analyzing:\");\n+        System.err.println(\"analyzing (removed: \" + removed + \"):\");\n@@ -2185,0 +2186,174 @@\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPaths(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2 _) -> 0; \/\/functionally equivalent to: Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _))\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root<Base> r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2 _) -> 0; \/\/functionally equivalent to: Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _))\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root<T>(T b1, T b2, T b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPathsSimplified(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test1(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   private int test2(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2 _,     R2(R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test1(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   private int test2(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2 _,     R2(R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2<T>(T b1) implements Base {}\n+                   record Root<T>(T b2, T b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testBindingPatternDoesNotStandInPlaceOfRecordPatterns(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R2 _, R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\",\n+               \"Test.java:4:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2 _, R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2<T>(T b) implements Base {}\n+                   record Root<T>(T b2, T b3) {}\n+               }\n+               \"\"\",\n+               \"Test.java:4:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":179,"deletions":4,"binary":false,"changes":183,"status":"modified"}]}