{"files":[{"patch":"@@ -63,0 +63,1 @@\n+import java.util.IdentityHashMap;\n@@ -804,0 +805,2 @@\n+            Map<PatternDescription, Set<PatternDescription>> replaces = new IdentityHashMap<>();\n+            Set<Set<PatternDescription>> seenFallback = new HashSet<>();\n@@ -810,2 +813,2 @@\n-                    updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n-                    updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                    updatedPatterns = reduceNestedPatterns(updatedPatterns, replaces, useHashes);\n+                    updatedPatterns = reduceRecordPatterns(updatedPatterns, replaces);\n@@ -825,1 +828,1 @@\n-                        repeat = useHashes;\n+                        repeat = useHashes && seenFallback.add(updatedPatterns);\n@@ -1011,0 +1014,1 @@\n+                                                             Map<PatternDescription, Set<PatternDescription>> replaces,\n@@ -1062,1 +1066,1 @@\n-                                    for (int i = 0; i < rpOne.nested.length; i++) {\n+                                    ACCEPT: for (int i = 0; i < rpOne.nested.length; i++) {\n@@ -1065,7 +1069,33 @@\n-                                                if (useHashes ||\n-                                                    \/\/when not using hashes,\n-                                                    \/\/check if rpOne.nested[i] is\n-                                                    \/\/a subtype of rpOther.nested[i]:\n-                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n-                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n-                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n+                                                if (useHashes) {\n+                                                    continue NEXT_PATTERN;\n+                                                }\n+                                                \/\/when not using hashes,\n+                                                \/\/check if rpOne.nested[i] is\n+                                                \/\/a subtype of rpOther.nested[i]:\n+                                                if (!(rpOther.nested[i] instanceof BindingPattern bpOther)) {\n+                                                    continue NEXT_PATTERN;\n+                                                }\n+                                                if (rpOne.nested[i] instanceof BindingPattern bpOne) {\n+                                                    if (!types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n+                                                        continue NEXT_PATTERN;\n+                                                    }\n+                                                } else if (rpOne.nested[i] instanceof RecordPattern nestedRPOne) {\n+                                                    boolean foundMatchingReplaced = false;\n+                                                    Set<PatternDescription> pendingReplacedPatterns = new HashSet<>(replaces.getOrDefault(rpOther.nested[i], Set.of()));\n+\n+                                                    while (!pendingReplacedPatterns.isEmpty()) {\n+                                                        PatternDescription currentReplaced = pendingReplacedPatterns.iterator().next();\n+\n+                                                        pendingReplacedPatterns.remove(currentReplaced);\n+\n+                                                        if (nestedRPOne.equals(currentReplaced)) {\n+                                                            foundMatchingReplaced = true;\n+                                                            break;\n+                                                        }\n+\n+                                                        pendingReplacedPatterns.addAll(replaces.getOrDefault(currentReplaced, Set.of()));\n+                                                    }\n+                                                    if (!foundMatchingReplaced) {\n+                                                        continue NEXT_PATTERN;\n+                                                    }\n+                                                } else {\n@@ -1082,1 +1112,1 @@\n-                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n+                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, replaces, useHashes);\n@@ -1084,1 +1114,1 @@\n-                            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                            updatedPatterns = reduceRecordPatterns(updatedPatterns, replaces);\n@@ -1097,1 +1127,1 @@\n-                                    current.add(new RecordPattern(rpOne.recordType(),\n+                                    RecordPattern nue = new RecordPattern(rpOne.recordType(),\n@@ -1099,1 +1129,3 @@\n-                                                                    newNested));\n+                                                                    newNested);\n+                                    current.add(nue);\n+                                    replaces.put(nue, new HashSet<>(join));\n@@ -1121,1 +1153,1 @@\n-        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns, Map<PatternDescription, Set<PatternDescription>> replaces) {\n@@ -1126,1 +1158,1 @@\n-                    PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n+                    PatternDescription reducedPattern = reduceRecordPattern(rpOne, replaces);\n@@ -1138,1 +1170,1 @@\n-        private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n+        private PatternDescription reduceRecordPattern(PatternDescription pattern, Map<PatternDescription, Set<PatternDescription>> replaces) {\n@@ -1148,1 +1180,1 @@\n-                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n+                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i], replaces);\n@@ -1159,1 +1191,3 @@\n-                    return new BindingPattern(rpOne.recordType);\n+                    PatternDescription pd = new BindingPattern(rpOne.recordType);\n+                    replaces.put(pd, Set.of(pattern));\n+                    return pd;\n@@ -1161,1 +1195,3 @@\n-                    return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+                    PatternDescription pd = new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+                    replaces.put(pd, Set.of(pattern));\n+                    return pd;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":57,"deletions":21,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368\n+ * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368 8364991\n@@ -1639,1 +1639,2 @@\n-        variants.remove((int) (Math.random() * variants.size()));\n+        int removed = (int) (Math.random() * variants.size());\n+        variants.remove(removed);\n@@ -1642,1 +1643,1 @@\n-        System.err.println(\"analyzing:\");\n+        System.err.println(\"analyzing (removed: \" + removed + \"):\");\n@@ -2185,0 +2186,93 @@\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPaths(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2 _) -> 0; \/\/functionally equivalent to: Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _))\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPathsSimplified(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test1(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   private int test2(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2 _,     R2(R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testBindingPatternDoesNotStandInPlaceOfRecordPatterns(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R2 _, R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\",\n+               \"Test.java:4:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":98,"deletions":4,"binary":false,"changes":102,"status":"modified"}]}