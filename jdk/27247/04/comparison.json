{"files":[{"patch":"@@ -62,0 +62,1 @@\n+import java.util.ArrayList;\n@@ -63,0 +64,1 @@\n+import java.util.IdentityHashMap;\n@@ -761,0 +763,2 @@\n+        private final Map<Pair<Type, Type>, Boolean> isSubtypeCache = new HashMap<>();\n+\n@@ -804,0 +808,1 @@\n+            Set<Set<PatternDescription>> seenFallback = new HashSet<>();\n@@ -825,1 +830,1 @@\n-                        repeat = useHashes;\n+                        repeat = useHashes && seenFallback.add(updatedPatterns);\n@@ -838,0 +843,2 @@\n+            } finally {\n+                isSubtypeCache.clear();\n@@ -894,1 +901,0 @@\n-                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n@@ -896,1 +902,1 @@\n-                            Type clazzErasure = types.erasure(clazz.type);\n+                            Type clazzType = clazz.type;\n@@ -898,2 +904,1 @@\n-                                                        .map(types::erasure)\n-                                                        .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                                                        .noneMatch(c -> isSubtypeErasure(clazzType, c))) {\n@@ -923,2 +928,2 @@\n-                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n-                                                                types.erasure(perm.type))) {\n+                                            if (isSubtypeErasure(currentPermitted.type,\n+                                                                 perm.type)) {\n@@ -929,2 +934,2 @@\n-                                        if (types.isSubtype(types.erasure(perm.type),\n-                                                            types.erasure(bpOther.type))) {\n+                                        if (isSubtypeErasure(perm.type,\n+                                                             bpOther.type)) {\n@@ -1053,3 +1058,1 @@\n-                            NEXT_PATTERN: for (int nextCandidate = 0;\n-                                               nextCandidate < candidatesArr.length;\n-                                               nextCandidate++) {\n+                            for (int nextCandidate = 0; nextCandidate < candidatesArr.length; nextCandidate++) {\n@@ -1061,16 +1064,3 @@\n-                                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                                    for (int i = 0; i < rpOne.nested.length; i++) {\n-                                        if (i != mismatchingCandidate) {\n-                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                                if (useHashes ||\n-                                                    \/\/when not using hashes,\n-                                                    \/\/check if rpOne.nested[i] is\n-                                                    \/\/a subtype of rpOther.nested[i]:\n-                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n-                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n-                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n-                                                    continue NEXT_PATTERN;\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n+\n+                                if (rpOne.recordType.tsym == rpOther.recordType.tsym &&\n+                                    nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, useHashes)) {\n@@ -1097,1 +1087,1 @@\n-                                    current.add(new RecordPattern(rpOne.recordType(),\n+                                    RecordPattern nue = new RecordPattern(rpOne.recordType(),\n@@ -1099,1 +1089,3 @@\n-                                                                    newNested));\n+                                                                    newNested,\n+                                                                    new HashSet<>(join));\n+                                    current.add(nue);\n@@ -1116,0 +1108,64 @@\n+        \/* Returns true if all nested components of existing and candidate are\n+         * equivalent (if useHashes == true), or \"substitutable\" (if useHashes == false).\n+         * A candidate pattern is \"substitutable\" if it is a binding pattern, and:\n+         * - it's type is a supertype of the existing pattern's type\n+         * - it was produced by a reduction from a record pattern that is equivalent to\n+         *   the existing pattern\n+         *\/\n+        private boolean nestedComponentsEquivalent(RecordPattern existing,\n+                                                   RecordPattern candidate,\n+                                                   int mismatchingCandidate,\n+                                                   boolean useHashes) {\n+            NEXT_NESTED:\n+            for (int i = 0; i < existing.nested.length; i++) {\n+                if (i != mismatchingCandidate) {\n+                    if (!existing.nested[i].equals(candidate.nested[i])) {\n+                        if (useHashes) {\n+                            return false;\n+                        }\n+                        \/\/when not using hashes,\n+                        \/\/check if rpOne.nested[i] is\n+                        \/\/a subtype of rpOther.nested[i]:\n+                        if (!(candidate.nested[i] instanceof BindingPattern nestedCandidate)) {\n+                            return false;\n+                        }\n+                        if (existing.nested[i] instanceof BindingPattern nestedExisting) {\n+                            if (!isSubtypeErasure(nestedExisting.type, nestedCandidate.type)) {\n+                                return false;\n+                            }\n+                        } else if (existing.nested[i] instanceof RecordPattern nestedExisting) {\n+                            java.util.List<PatternDescription> pendingReplacedPatterns =\n+                                    new ArrayList<>(nestedCandidate.sourcePatterns());\n+\n+                            while (!pendingReplacedPatterns.isEmpty()) {\n+                                PatternDescription currentReplaced = pendingReplacedPatterns.removeLast();\n+\n+                                if (nestedExisting.equals(currentReplaced)) {\n+                                    \/\/candidate.nested[i] is substitutable for existing.nested[i]\n+                                    \/\/continue with the next nested pattern:\n+                                    continue NEXT_NESTED;\n+                                }\n+\n+                                pendingReplacedPatterns.addAll(currentReplaced.sourcePatterns());\n+                            }\n+\n+                            return false;\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        \/*The same as types.isSubtype(types.erasure(t), types.erasure(s)), but cached.\n+        *\/\n+        private boolean isSubtypeErasure(Type t, Type s) {\n+            Pair<Type, Type> key = Pair.of(t, s);\n+\n+            return isSubtypeCache.computeIfAbsent(key, _ ->\n+                    types.isSubtype(types.erasure(t), types.erasure(s)));\n+        }\n+\n@@ -1159,1 +1215,2 @@\n-                    return new BindingPattern(rpOne.recordType);\n+                    PatternDescription pd = new BindingPattern(rpOne.recordType, Set.of(pattern));\n+                    return pd;\n@@ -1161,1 +1218,2 @@\n-                    return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+                    PatternDescription pd = new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns, Set.of(pattern));\n+                    return pd;\n@@ -3476,1 +3534,3 @@\n-    sealed interface PatternDescription { }\n+    sealed interface PatternDescription {\n+        public Set<PatternDescription> sourcePatterns();\n+    }\n@@ -3511,1 +3571,6 @@\n-    record BindingPattern(Type type) implements PatternDescription {\n+    record BindingPattern(Type type, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n+\n+        public BindingPattern(Type type) {\n+            this(type, Set.of());\n+        }\n+\n@@ -3526,1 +3591,1 @@\n-    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription[] nested, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n@@ -3529,1 +3594,5 @@\n-            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+            this(recordType, fullComponentTypes, nested, Set.of());\n+        }\n+\n+        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested, Set<PatternDescription> sourcePatterns) {\n+            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested, sourcePatterns);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":105,"deletions":36,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368\n+ * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368 8364991\n@@ -1639,1 +1639,2 @@\n-        variants.remove((int) (Math.random() * variants.size()));\n+        int removed = (int) (Math.random() * variants.size());\n+        variants.remove(removed);\n@@ -1642,1 +1643,1 @@\n-        System.err.println(\"analyzing:\");\n+        System.err.println(\"analyzing (removed: \" + removed + \"):\");\n@@ -2185,0 +2186,174 @@\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPaths(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2 _) -> 0; \/\/functionally equivalent to: Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _))\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root<Base> r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2 _) -> 0; \/\/functionally equivalent to: Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _))\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root<T>(T b1, T b2, T b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPathsSimplified(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test1(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   private int test2(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2 _,     R2(R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test1(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   private int test2(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2 _,     R2(R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2<T>(T b1) implements Base {}\n+                   record Root<T>(T b2, T b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testBindingPatternDoesNotStandInPlaceOfRecordPatterns(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R2 _, R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\",\n+               \"Test.java:4:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2 _, R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2<T>(T b) implements Base {}\n+                   record Root<T>(T b2, T b3) {}\n+               }\n+               \"\"\",\n+               \"Test.java:4:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":179,"deletions":4,"binary":false,"changes":183,"status":"modified"}]}