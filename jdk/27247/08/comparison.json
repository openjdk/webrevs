{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.util.ArrayList;\n@@ -63,0 +64,1 @@\n+    private final Map<Pair<Type, Type>, Boolean> isSubtypeCache = new HashMap<>();\n@@ -123,0 +125,1 @@\n+        Set<Set<PatternDescription>> seenFallback = new HashSet<>();\n@@ -144,1 +147,1 @@\n-                    repeat = useHashes;\n+                    repeat = useHashes && seenFallback.add(updatedPatterns);\n@@ -157,0 +160,2 @@\n+        } finally {\n+            isSubtypeCache.clear();\n@@ -214,1 +219,1 @@\n-                        Type clazzErasure = types.erasure(clazz.type);\n+                        Type clazzType = clazz.type;\n@@ -216,2 +221,1 @@\n-                                                    .map(types::erasure)\n-                                                    .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                                                    .noneMatch(c -> isSubtypeErasure(clazzType, c))) {\n@@ -241,2 +245,2 @@\n-                                pendingPermitted.removeIf(pending -> types.isSubtype(types.erasure(pending.type),\n-                                                                                     types.erasure(bpOther.type)));\n+                                pendingPermitted.removeIf(pending -> isSubtypeErasure(pending.type,\n+                                                                                      bpOther.type));\n@@ -249,4 +253,4 @@\n-                                                                .filter(perm -> types.isSubtype(types.erasure(perm.type),\n-                                                                                                types.erasure(bpOther.type)))\n-                                                                .filter(perm -> types.isSubtype(types.erasure(perm.type),\n-                                                                                                types.erasure(pending.type)))\n+                                                                .filter(perm -> isSubtypeErasure(perm.type,\n+                                                                                                 bpOther.type))\n+                                                                .filter(perm -> isSubtypeErasure(perm.type,\n+                                                                                                 pending.type))\n@@ -377,3 +381,1 @@\n-                        NEXT_PATTERN: for (int nextCandidate = 0;\n-                                           nextCandidate < candidatesArr.length;\n-                                           nextCandidate++) {\n+                        for (int nextCandidate = 0; nextCandidate < candidatesArr.length; nextCandidate++) {\n@@ -385,16 +387,3 @@\n-                            if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                                for (int i = 0; i < rpOne.nested.length; i++) {\n-                                    if (i != mismatchingCandidate) {\n-                                        if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                            if (useHashes ||\n-                                                \/\/when not using hashes,\n-                                                \/\/check if rpOne.nested[i] is\n-                                                \/\/a subtype of rpOther.nested[i]:\n-                                                !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n-                                                !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n-                                                !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n-                                                continue NEXT_PATTERN;\n-                                            }\n-                                        }\n-                                    }\n-                                }\n+\n+                            if (rpOne.recordType.tsym == rpOther.recordType.tsym &&\n+                                nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, useHashes)) {\n@@ -421,1 +410,1 @@\n-                                current.add(new RecordPattern(rpOne.recordType(),\n+                                RecordPattern nue = new RecordPattern(rpOne.recordType(),\n@@ -423,1 +412,3 @@\n-                                                                newNested));\n+                                                                newNested,\n+                                                                new HashSet<>(join));\n+                                current.add(nue);\n@@ -440,0 +431,64 @@\n+    \/* Returns true if all nested components of existing and candidate are\n+     * equivalent (if useHashes == true), or \"substitutable\" (if useHashes == false).\n+     * A candidate pattern is \"substitutable\" if it is a binding pattern, and:\n+     * - it's type is a supertype of the existing pattern's type\n+     * - it was produced by a reduction from a record pattern that is equivalent to\n+     *   the existing pattern\n+     *\/\n+    private boolean nestedComponentsEquivalent(RecordPattern existing,\n+                                               RecordPattern candidate,\n+                                               int mismatchingCandidate,\n+                                               boolean useHashes) {\n+        NEXT_NESTED:\n+        for (int i = 0; i < existing.nested.length; i++) {\n+            if (i != mismatchingCandidate) {\n+                if (!existing.nested[i].equals(candidate.nested[i])) {\n+                    if (useHashes) {\n+                        return false;\n+                    }\n+                    \/\/when not using hashes,\n+                    \/\/check if rpOne.nested[i] is\n+                    \/\/a subtype of rpOther.nested[i]:\n+                    if (!(candidate.nested[i] instanceof BindingPattern nestedCandidate)) {\n+                        return false;\n+                    }\n+                    if (existing.nested[i] instanceof BindingPattern nestedExisting) {\n+                        if (!isSubtypeErasure(nestedExisting.type, nestedCandidate.type)) {\n+                            return false;\n+                        }\n+                    } else if (existing.nested[i] instanceof RecordPattern nestedExisting) {\n+                        java.util.List<PatternDescription> pendingReplacedPatterns =\n+                                new ArrayList<>(nestedCandidate.sourcePatterns());\n+\n+                        while (!pendingReplacedPatterns.isEmpty()) {\n+                            PatternDescription currentReplaced = pendingReplacedPatterns.removeLast();\n+\n+                            if (nestedExisting.equals(currentReplaced)) {\n+                                \/\/candidate.nested[i] is substitutable for existing.nested[i]\n+                                \/\/continue with the next nested pattern:\n+                                continue NEXT_NESTED;\n+                            }\n+\n+                            pendingReplacedPatterns.addAll(currentReplaced.sourcePatterns());\n+                        }\n+\n+                        return false;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    \/*The same as types.isSubtype(types.erasure(t), types.erasure(s)), but cached.\n+    *\/\n+    private boolean isSubtypeErasure(Type t, Type s) {\n+        Pair<Type, Type> key = Pair.of(t, s);\n+\n+        return isSubtypeCache.computeIfAbsent(key, _ ->\n+                types.isSubtype(types.erasure(t), types.erasure(s)));\n+    }\n+\n@@ -483,1 +538,2 @@\n-                return new BindingPattern(rpOne.recordType);\n+                PatternDescription pd = new BindingPattern(rpOne.recordType, Set.of(pattern));\n+                return pd;\n@@ -485,1 +541,2 @@\n-                return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+                PatternDescription pd = new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns, Set.of(pattern));\n+                return pd;\n@@ -520,1 +577,3 @@\n-    sealed interface PatternDescription { }\n+    sealed interface PatternDescription {\n+        public Set<PatternDescription> sourcePatterns();\n+    }\n@@ -555,1 +614,6 @@\n-    record BindingPattern(Type type) implements PatternDescription {\n+    record BindingPattern(Type type, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n+\n+        public BindingPattern(Type type) {\n+            this(type, Set.of());\n+        }\n+\n@@ -570,1 +634,1 @@\n-    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription[] nested, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n@@ -573,1 +637,5 @@\n-            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+            this(recordType, fullComponentTypes, nested, Set.of());\n+        }\n+\n+        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested, Set<PatternDescription> sourcePatterns) {\n+            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested, sourcePatterns);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":105,"deletions":37,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368 8366968\n+ * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368 8366968 8364991\n@@ -43,0 +43,1 @@\n+import java.util.LinkedHashSet;\n@@ -1546,1 +1547,1 @@\n-        Set<String> variants = new HashSet<>();\n+        Set<String> variants = new LinkedHashSet<>();\n@@ -1639,1 +1640,2 @@\n-        variants.remove((int) (Math.random() * variants.size()));\n+        int removed = (int) (Math.random() * variants.size());\n+        variants.remove(removed);\n@@ -1642,1 +1644,1 @@\n-        System.err.println(\"analyzing:\");\n+        System.err.println(\"analyzing (removed: \" + removed + \"):\");\n@@ -2311,0 +2313,174 @@\n+               \"1 error\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPaths(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2 _) -> 0; \/\/functionally equivalent to: Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _))\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root<Base> r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2 _) -> 0; \/\/functionally equivalent to: Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _))\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root<T>(T b1, T b2, T b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPathsSimplified(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test1(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   private int test2(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2 _,     R2(R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test1(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   private int test2(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2 _,     R2(R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2<T>(T b1) implements Base {}\n+                   record Root<T>(T b2, T b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testBindingPatternDoesNotStandInPlaceOfRecordPatterns(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R2 _, R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\",\n+               \"Test.java:4:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root<R2<Base>> r) {\n+                       return switch (r) {\n+                           case Root(R2 _, R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2<T>(T b) implements Base {}\n+                   record Root<T>(T b2, T b3) {}\n+               }\n+               \"\"\",\n+               \"Test.java:4:16: compiler.err.not.exhaustive\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":180,"deletions":4,"binary":false,"changes":184,"status":"modified"}]}