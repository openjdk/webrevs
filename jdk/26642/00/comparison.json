{"files":[{"patch":"@@ -93,1 +93,4 @@\n-  Compile::pd_compiler2_init();\n+  \/\/ If there was an error generating the blob then UseCompiler will\n+  \/\/ have been unset and we need to skip the remaining initialization\n+  if (UseCompiler) {\n+    Compile::pd_compiler2_init();\n@@ -95,1 +98,1 @@\n-  CompilerThread* thread = CompilerThread::current();\n+    CompilerThread* thread = CompilerThread::current();\n@@ -97,2 +100,5 @@\n-  HandleMark handle_mark(thread);\n-  return OptoRuntime::generate(thread->env());\n+    HandleMark handle_mark(thread);\n+    return OptoRuntime::generate(thread->env());\n+  } else {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -184,0 +184,11 @@\n+    \/\/ The compiler blob may be created late by a C2 compiler thread\n+    \/\/ rather than during normal initialization by the initial thread.\n+    \/\/ In that case we can tolerate an allocation failure because the\n+    \/\/ compiler will have been shut down and we have no need of the\n+    \/\/ blob.\n+    if (Thread::current()->is_Compiler_thread()) {\n+      assert(blob_id == BlobId::stubgen_compiler_id, \"sanity\");\n+      assert(DelayCompilerStubsGeneration, \"sanity\");\n+      log_warning(stubs)(\"Ignoring failed allocation of blob %s under compiler thread\", StubInfo::name(blob_id));\n+      return nullptr;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}