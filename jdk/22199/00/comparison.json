{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +46,13 @@\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+AlignVector\");\n@@ -66,0 +79,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -73,0 +87,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                  UseCompactObjectHeaders=true\n+            \/\/ I_adr = base + 16 + 4*i  ->  i % 2 = 0         B_adr = base + 12 + 4*i  ->  i % 2 = 1\n+            \/\/ N_adr = base      + 4*i  ->  i % 2 = 0         N_adr = base      + 4*i  ->  i % 2 = 0\n+            \/\/ -> vectorize                                   -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCastX2NotProcessedIGVN.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\");\n+        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n@@ -403,0 +411,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -408,0 +417,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n+            \/\/ -> vectorize                                         -> no vectorization\n@@ -416,0 +429,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -421,0 +435,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n+            \/\/ -> vectorize                                         -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -53,1 +53,13 @@\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+AlignVector\");\n@@ -156,2 +168,1 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -165,0 +176,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                  UseCompactObjectHeaders=true\n+            \/\/ B_adr = base + 16 + 8*i  ->  always            B_adr = base + 12 + 8*i  ->  never\n+            \/\/ L_adr = base + 16 + 8*i  ->  always            L_adr = base + 16 + 8*i  ->  always\n+            \/\/ -> vectorize                                   -> no vectorization\n@@ -170,2 +186,1 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -178,0 +193,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                  UseCompactObjectHeaders=true\n+            \/\/ B_adr = base + 16 + 8*i  ->  always            B_adr = base + 12 + 8*i  ->  never\n+            \/\/ L_adr = base + 16 + 8*i  ->  always            L_adr = base + 16 + 8*i  ->  always\n+            \/\/ -> vectorize                                   -> no vectorization\n@@ -183,2 +203,0 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n@@ -190,0 +208,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                  UseCompactObjectHeaders=true\n+            \/\/ B_adr = base + 64 + 8*i  ->  always            B_adr = base + 64 + 8*i  ->  always\n+            \/\/ L_adr = base + 16 + 8*i  ->  always            L_adr = base + 16 + 8*i  ->  always\n+            \/\/ -> vectorize                                   -> vectorize\n@@ -195,2 +218,0 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n@@ -204,0 +225,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                  UseCompactObjectHeaders=true\n+            \/\/ B_adr = base + 64 + 8*i  ->  always            B_adr = base + 64 + 8*i  ->  always\n+            \/\/ L_adr = base + 16 + 8*i  ->  always            L_adr = base + 16 + 8*i  ->  always\n+            \/\/ -> vectorize                                   -> vectorize\n@@ -217,0 +243,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -224,0 +251,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n+            \/\/ B_adr = base + 16 + 8*(i-1)  ->  always            B_adr = base + 12 + 8*(i-1)  ->  never\n+            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n+            \/\/ -> vectorize                                       -> no vectorization\n@@ -229,0 +261,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -235,0 +268,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n+            \/\/ B_adr = base + 16 + 8*(i-1)  ->  always            B_adr = base + 12 + 8*(i-1)  ->  never\n+            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n+            \/\/ -> vectorize                                       -> no vectorization\n@@ -246,2 +284,1 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -255,0 +292,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n+            \/\/ B_adr = base + 16 + 8*(i+1)  ->  always            B_adr = base + 12 + 8*(i+1)  ->  never\n+            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n+            \/\/ -> vectorize                                       -> no vectorization\n@@ -260,2 +302,1 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -268,0 +309,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n+            \/\/ B_adr = base + 16 + 8*(i+1)  ->  always            B_adr = base + 12 + 8*(i+1)  ->  never\n+            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n+            \/\/ -> vectorize                                       -> no vectorization\n@@ -313,2 +359,1 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -322,0 +367,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n+            \/\/ B_adr = base + 16 + 8*(i+x)  ->  always            B_adr = base + 12 + 8*(i+x)  ->  never\n+            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n+            \/\/ -> vectorize                                       -> no vectorization\n@@ -327,2 +377,1 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -335,0 +384,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                      UseCompactObjectHeaders=true\n+            \/\/ B_adr = base + 16 + 8*(i+x)  ->  always            B_adr = base + 12 + 8*(i+x)  ->  never\n+            \/\/ L_adr = base + 16 + 8*i      ->  always            L_adr = base + 16 + 8*i      ->  always\n+            \/\/ -> vectorize                                       -> no vectorization\n@@ -347,2 +401,1 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -356,0 +409,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                    UseCompactObjectHeaders=true\n+            \/\/ src_adr = base + 16 + 8*i  ->  always            src_adr = base + 12 + 8*i  ->  never\n+            \/\/ dst_adr = base + 16 + 8*i  ->  always            dst_adr = base + 12 + 8*i  ->  never\n+            \/\/ -> vectorize                                     -> no vectorization\n@@ -361,2 +419,1 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -369,0 +426,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                    UseCompactObjectHeaders=true\n+            \/\/ src_adr = base + 16 + 8*i  ->  always            src_adr = base + 12 + 8*i  ->  never\n+            \/\/ dst_adr = base + 16 + 8*i  ->  always            dst_adr = base + 12 + 8*i  ->  never\n+            \/\/ -> vectorize                                     -> no vectorization\n@@ -380,2 +442,1 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -389,0 +450,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n+            \/\/ src_adr = base + 16 + 8*i      ->  always            src_adr = base + 12 + 8*i      ->  never\n+            \/\/ dst_adr = base + 16 + 8*(i-1)  ->  always            dst_adr = base + 12 + 8*(i-1)  ->  never\n+            \/\/ -> vectorize                                         -> no vectorization\n@@ -394,2 +460,1 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -402,0 +467,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n+            \/\/ src_adr = base + 16 + 8*i      ->  always            src_adr = base + 12 + 8*i      ->  never\n+            \/\/ dst_adr = base + 16 + 8*(i-1)  ->  always            dst_adr = base + 12 + 8*(i-1)  ->  never\n+            \/\/ -> vectorize                                         -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":95,"deletions":25,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n- * @requires (os.simpleArch == \"x64\") | (os.simpleArch == \"aarch64\")\n@@ -45,1 +44,13 @@\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+AlignVector\");\n@@ -55,2 +66,3 @@\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" })\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -63,0 +75,4 @@\n+            \/\/ For UseCompactObjectHeaders and AlignVector, we must 8-byte align all vector loads\/stores.\n+            \/\/ But the long-stores to the byte-array are never aligned:\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -70,1 +86,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationNotRun.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -63,0 +63,18 @@\n+\/*\n+ * @test id=NoAlignVector-COH\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestAlignVector NoAlignVector-COH\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector-COH\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestAlignVector VerifyAlignVector-COH\n+ *\/\n+\n@@ -99,3 +117,5 @@\n-            case \"NoAlignVector\"     -> { framework.addFlags(\"-XX:-AlignVector\"); }\n-            case \"AlignVector\"       -> { framework.addFlags(\"-XX:+AlignVector\"); }\n-            case \"VerifyAlignVector\" -> { framework.addFlags(\"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n+            case \"NoAlignVector\"         -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"AlignVector\"           -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"VerifyAlignVector\"     -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n+            case \"NoAlignVector-COH\"     -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"VerifyAlignVector-COH\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n@@ -120,1 +140,2 @@\n-        tests.put(\"test1\",       () -> { return test1(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test1a\",      () -> { return test1a(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test1b\",      () -> { return test1b(aB.clone(), bB.clone(), mB); });\n@@ -135,0 +156,1 @@\n+        tests.put(\"test10e\",     () -> { return test10e(aS.clone(), bS.clone(), mS); });\n@@ -204,1 +226,2 @@\n-                 \"test1\",\n+                 \"test1a\",\n+                 \"test1b\",\n@@ -217,0 +240,1 @@\n+                 \"test10e\",\n@@ -407,1 +431,3 @@\n-        applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n+        \/\/ UNSAFE.ARRAY_BYTE_BASE_OFFSET = 16, but with compact object headers UNSAFE.ARRAY_BYTE_BASE_OFFSET=12.\n+        \/\/ If AlignVector=true, we need the offset to be 8-byte aligned, else the vectors are filtered out.\n@@ -410,1 +436,1 @@\n-    static Object[] test1(byte[] a, byte[] b, byte mask) {\n+    static Object[] test1a(byte[] a, byte[] b, byte mask) {\n@@ -412,2 +438,24 @@\n-            \/\/ Safe to vectorize with AlignVector\n-            b[i+0] = (byte)(a[i+0] & mask); \/\/ offset 0, align 0\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0 + iter*8\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+            b[i+7] = (byte)(a[i+7] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"true\", \"AlignVector\", \"false\"},\n+        \/\/ UNSAFE.ARRAY_BYTE_BASE_OFFSET = 16, but with compact object headers UNSAFE.ARRAY_BYTE_BASE_OFFSET=12.\n+        \/\/ If AlignVector=true, we need the offset to be 8-byte aligned, else the vectors are filtered out.\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test1b(byte[] a, byte[] b, byte mask) {\n+        for (int i = 4; i < RANGE-8; i+=8) {\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4 + iter*8\n@@ -717,0 +765,2 @@\n+        \/\/ UNSAFE.ARRAY_BYTE_BASE_OFFSET = 16, but with compact object headers UNSAFE.ARRAY_BYTE_BASE_OFFSET=12.\n+        \/\/ If AlignVector=true, we need the offset to be 8-byte aligned, else the vectors are filtered out.\n@@ -721,1 +771,21 @@\n-            \/\/ init + offset -> aligned\n+            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*(3 + 13) + iter*16\n+            b[i+0+3] = (short)(a[i+0+3] & mask);\n+            b[i+1+3] = (short)(a[i+1+3] & mask);\n+            b[i+2+3] = (short)(a[i+2+3] & mask);\n+            b[i+3+3] = (short)(a[i+3+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=16\", \"UseCompactObjectHeaders\", \"true\"},\n+        \/\/ UNSAFE.ARRAY_BYTE_BASE_OFFSET = 16, but with compact object headers UNSAFE.ARRAY_BYTE_BASE_OFFSET=12.\n+        \/\/ If AlignVector=true, we need the offset to be 8-byte aligned, else the vectors are filtered out.\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test10e(short[] a, short[] b, short mask) {\n+        for (int i = 11; i < RANGE-16; i+=8) {\n+            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*(3 + 11) + iter*16\n@@ -1011,1 +1081,1 @@\n-        applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1016,0 +1086,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1017,0 +1089,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET  + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1018,0 +1092,9 @@\n+            \/\/ For AlignVector, all adr must be 8-byte aligned. Let's see for which iteration this can hold:\n+            \/\/ If UseCompactObjectHeaders=false:\n+            \/\/   a: 0, 8, 16, 24, 32, ...\n+            \/\/   b: 0, 2,  4,  6,  8, ...\n+            \/\/   -> Ok, aligns every 8th iteration.\n+            \/\/ If UseCompactObjectHeaders=true:\n+            \/\/   a: 4, 12, 20, 28, 36, ...\n+            \/\/   b: 1,  3,  5,  7,  9, ...\n+            \/\/   -> we can never align both vectors!\n@@ -1028,1 +1111,1 @@\n-        applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1033,0 +1116,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1034,0 +1119,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1035,0 +1122,9 @@\n+            \/\/ For AlignVector, all adr must be 8-byte aligned. Let's see for which iteration this can hold:\n+            \/\/ If UseCompactObjectHeaders=false:\n+            \/\/   a: iter % 2 == 0\n+            \/\/   b: iter % 4 == 0\n+            \/\/   -> Ok, aligns every 4th iteration.\n+            \/\/ If UseCompactObjectHeaders=true:\n+            \/\/   a: iter % 2 = 1\n+            \/\/   b: iter % 4 = 2\n+            \/\/   -> we can never align both vectors!\n@@ -1049,1 +1145,1 @@\n-        applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1054,0 +1150,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1055,0 +1153,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1056,0 +1156,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1057,0 +1159,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_LONG_BASE_OFFSET + 8*iter\n+            \/\/              = 16 (always)\n@@ -1058,0 +1162,4 @@\n+            \/\/ If AlignVector and UseCompactObjectHeaders, and we want all adr 8-byte aligned:\n+            \/\/   a: iter % 8 = 4\n+            \/\/   c: iter % 2 = 1\n+            \/\/   -> can never align both vectors!\n@@ -1085,1 +1193,1 @@\n-        applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1090,0 +1198,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4 + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1091,0 +1201,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1 + 1*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1092,0 +1204,4 @@\n+            \/\/ If AlignVector and UseCompactObjectHeaders, and we want all adr 8-byte aligned:\n+            \/\/   a: iter % 2 = 0\n+            \/\/   b: iter % 8 = 3\n+            \/\/   -> can never align both vectors!\n@@ -1102,1 +1218,1 @@\n-        applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1107,0 +1223,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4 + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1108,0 +1226,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2 + 2*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1109,0 +1229,4 @@\n+            \/\/ If AlignVector and UseCompactObjectHeaders, and we want all adr 8-byte aligned:\n+            \/\/   a: iter % 2 = 0\n+            \/\/   b: iter % 4 = 1\n+            \/\/   -> can never align both vectors!\n@@ -1123,1 +1247,1 @@\n-        applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -1128,0 +1252,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1 + 1*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1129,0 +1255,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2 + 2*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1130,0 +1258,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4 + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n@@ -1131,0 +1261,2 @@\n+            \/\/ adr = base + UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 + 8*iter\n+            \/\/              = 16 (always)\n@@ -1132,0 +1264,4 @@\n+            \/\/ If AlignVector and UseCompactObjectHeaders, and we want all adr 8-byte aligned:\n+            \/\/   a: iter % 8 = 3\n+            \/\/   c: iter % 2 = 0\n+            \/\/   -> can never align both vectors!\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":152,"deletions":16,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -32,1 +32,4 @@\n- * @run driver compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency\n+ * @run driver compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency nCOH_nAV\n+ * @run driver compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency nCOH_yAV\n+ * @run driver compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency yCOH_nAV\n+ * @run driver compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency yCOH_yAV\n@@ -75,5 +78,14 @@\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency::test*\",\n-                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency::verify\",\n-                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency::init\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:LoopUnrollLimit=1000\");\n+        TestFramework framework = new TestFramework(TestIndependentPacksWithCyclicDependency.class);\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency::test*\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency::verify\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency::init\",\n+                           \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:LoopUnrollLimit=1000\");\n+        switch (args[0]) {\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n@@ -121,0 +133,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -130,0 +143,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -146,0 +163,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -155,0 +173,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -170,0 +192,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -179,0 +202,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -195,0 +222,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -206,0 +234,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -272,0 +304,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -290,0 +323,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -80,2 +80,4 @@\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaers\");\n@@ -166,1 +168,1 @@\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -172,1 +174,1 @@\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -179,0 +181,7 @@\n+            \/\/ Hand-unrolling can mess with AlignVector and UseCompactObjectHeaders.\n+            \/\/ We need all addresses 8-byte aligned.\n+            \/\/\n+            \/\/ out:\n+            \/\/   adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n+            \/\/                = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ -> never aligned!\n@@ -186,1 +195,1 @@\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -192,1 +201,1 @@\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -199,0 +208,7 @@\n+            \/\/ Hand-unrolling can mess with AlignVector and UseCompactObjectHeaders.\n+            \/\/ We need all addresses 8-byte aligned.\n+            \/\/\n+            \/\/ out:\n+            \/\/   adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n+            \/\/                = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ -> never aligned!\n@@ -206,1 +222,1 @@\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -212,1 +228,1 @@\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -219,0 +235,7 @@\n+            \/\/ Hand-unrolling can mess with AlignVector and UseCompactObjectHeaders.\n+            \/\/ We need all addresses 8-byte aligned.\n+            \/\/\n+            \/\/ out:\n+            \/\/   adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n+            \/\/                = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ -> never aligned!\n@@ -226,1 +249,1 @@\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -232,1 +255,1 @@\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -239,0 +262,7 @@\n+            \/\/ Hand-unrolling can mess with AlignVector and UseCompactObjectHeaders.\n+            \/\/ We need all addresses 8-byte aligned.\n+            \/\/\n+            \/\/ out:\n+            \/\/   adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n+            \/\/                = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ -> never aligned!\n@@ -246,1 +276,1 @@\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -252,1 +282,1 @@\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\" },\n@@ -259,0 +289,7 @@\n+            \/\/ Hand-unrolling can mess with AlignVector and UseCompactObjectHeaders.\n+            \/\/ We need all addresses 8-byte aligned.\n+            \/\/\n+            \/\/ out:\n+            \/\/   adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n+            \/\/                = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ -> never aligned!\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":49,"deletions":12,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -33,1 +33,4 @@\n- * @run driver compiler.loopopts.superword.TestScheduleReordersScalarMemops\n+ * @run driver compiler.loopopts.superword.TestScheduleReordersScalarMemops nCOH_nAV\n+ * @run driver compiler.loopopts.superword.TestScheduleReordersScalarMemops nCOH_yAV\n+ * @run driver compiler.loopopts.superword.TestScheduleReordersScalarMemops yCOH_nAV\n+ * @run driver compiler.loopopts.superword.TestScheduleReordersScalarMemops yCOH_yAV\n@@ -53,6 +56,15 @@\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestScheduleReordersScalarMemops::test*\",\n-                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestScheduleReordersScalarMemops::verify\",\n-                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestScheduleReordersScalarMemops::init\",\n-                                   \"-XX:-TieredCompilation\", \"-Xbatch\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:LoopUnrollLimit=1000\");\n+        TestFramework framework = new TestFramework(TestScheduleReordersScalarMemops.class);\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestScheduleReordersScalarMemops::test*\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestScheduleReordersScalarMemops::verify\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestScheduleReordersScalarMemops::init\",\n+                           \"-XX:-TieredCompilation\", \"-Xbatch\",\n+                           \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:LoopUnrollLimit=1000\");\n+        switch (args[0]) {\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n@@ -82,0 +94,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -106,0 +119,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -122,0 +139,1 @@\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -131,0 +149,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i   ->  always            adr = base + 12 + 8*i   ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestScheduleReordersScalarMemops.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -40,1 +40,4 @@\n- * @run driver compiler.loopopts.superword.TestSplitPacks\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_nAV\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_yAV\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_nAV\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_yAV\n@@ -73,1 +76,10 @@\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:LoopUnrollLimit=1000\");\n+        TestFramework framework = new TestFramework(TestSplitPacks.class);\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:LoopUnrollLimit=1000\");\n+        switch (args[0]) {\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n@@ -269,1 +281,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -294,0 +314,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -304,1 +328,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -317,0 +349,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -327,1 +363,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -340,0 +384,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -350,1 +398,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -363,0 +419,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -373,1 +433,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -386,0 +454,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -396,1 +468,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -423,0 +503,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -433,1 +517,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -460,0 +552,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -470,1 +566,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -497,0 +601,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -507,1 +615,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -534,0 +650,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -541,1 +661,6 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -554,1 +679,5 @@\n-          short a0 = a[i+0]; \/\/ required for alignment \/ offsets, technical limitation.\n+            short a0 = a[i+0]; \/\/ required for alignment \/ offsets, technical limitation.\n+\n+            short a1 = a[i+1]; \/\/ adjacent to 4-pack, but need to be split off\n+            short a2 = a[i+2];\n+            short a3 = a[i+3];\n@@ -556,3 +685,4 @@\n-          short a1 = a[i+1]; \/\/ adjacent to 4-pack, but need to be split off\n-          short a2 = a[i+2];\n-          short a3 = a[i+3];\n+            short a4 = a[i+4]; \/\/ 4-pack\n+            short a5 = a[i+5];\n+            short a6 = a[i+6];\n+            short a7 = a[i+7];\n@@ -560,4 +690,0 @@\n-          short a4 = a[i+4]; \/\/ 4-pack\n-          short a5 = a[i+5];\n-          short a6 = a[i+6];\n-          short a7 = a[i+7];\n@@ -565,0 +691,1 @@\n+            b[i+0] = a0; \/\/ required for alignment \/ offsets, technical limitation.\n@@ -566,1 +693,1 @@\n-          b[i+0] = a0; \/\/ required for alignment \/ offsets, technical limitation.\n+            sum += a1 + a2 + a3; \/\/ not packed\n@@ -568,1 +695,1 @@\n-          sum += a1 + a2 + a3; \/\/ not packed\n+            b[i+3] = val; \/\/ adjacent to 4-pack but needs to be split off\n@@ -570,1 +697,4 @@\n-          b[i+3] = val; \/\/ adjacent to 4-pack but needs to be split off\n+            b[i+4] = a4; \/\/ 4-pack\n+            b[i+5] = a5;\n+            b[i+6] = a6;\n+            b[i+7] = a7;\n@@ -572,4 +702,1 @@\n-          b[i+4] = a4; \/\/ 4-pack\n-          b[i+5] = a5;\n-          b[i+6] = a6;\n-          b[i+7] = a7;\n+            b[i+8] = val; \/\/ adjacent to 4-pack but needs to be split off\n@@ -577,1 +704,4 @@\n-          b[i+8] = val; \/\/ adjacent to 4-pack but needs to be split off\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8 + 32*i  ->  always        adr = base + 12 + 8 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -721,1 +851,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,   IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.MUL_VI,          IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VI,          IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.ADD_VI,          IRNode.VECTOR_SIZE_4, \"> 0\", \/\/ reduction moved out of loop\n+                  IRNode.ADD_REDUCTION_V,                       \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -737,0 +875,4 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 32*i  ->  always            adr = base + 12 + 32*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSplitPacks.java","additions":171,"deletions":29,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -42,1 +42,4 @@\n-        TestFramework.run();\n+        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n@@ -64,0 +67,1 @@\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -91,0 +95,5 @@\n+\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i  ->  always             adr = base + 12 + 8*i  ->  never\n+            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,4 @@\n- * @run driver compiler.vectorization.TestFloatConversionsVector\n+ * @run driver compiler.vectorization.TestFloatConversionsVector nCOH_nAV\n+ * @run driver compiler.vectorization.TestFloatConversionsVector nCOH_yAV\n+ * @run driver compiler.vectorization.TestFloatConversionsVector yCOH_nAV\n+ * @run driver compiler.vectorization.TestFloatConversionsVector yCOH_yAV\n@@ -47,2 +50,10 @@\n-        TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n-                                   \"-XX:CompileThresholdScaling=0.3\");\n+        TestFramework framework = new TestFramework(TestFloatConversionsVector.class);\n+        framework.addFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\");\n+        switch (args[0]) {\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n@@ -54,2 +65,3 @@\n-                  applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"},\n-                  applyIfCPUFeatureOr = {\"f16c\", \"true\", \"avx512f\", \"true\", \"zvfh\", \"true\", \"asimd\", \"true\", \"sve\", \"true\"})\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"},\n+        applyIfCPUFeatureOr = {\"f16c\", \"true\", \"avx512f\", \"true\", \"zvfh\", \"true\", \"asimd\", \"true\", \"sve\", \"true\"})\n@@ -59,0 +71,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ F_adr = base + 16 + 4*i   ->  i % 2 = 0       F_adr = base + 12 + 4*i   ->  i % 2 = 1\n+            \/\/ S_adr = base + 16 + 2*i   ->  i % 4 = 0       S_adr = base + 12 + 2*i   ->  i % 4 = 2\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -117,2 +134,3 @@\n-                  applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"},\n-                  applyIfCPUFeatureOr = {\"f16c\", \"true\", \"avx512f\", \"true\", \"zvfh\", \"true\", \"asimd\", \"true\", \"sve\", \"true\"})\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"},\n+        applyIfCPUFeatureOr = {\"f16c\", \"true\", \"avx512f\", \"true\", \"zvfh\", \"true\", \"asimd\", \"true\", \"sve\", \"true\"})\n@@ -122,0 +140,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ F_adr = base + 16 + 4*i   ->  i % 2 = 0       F_adr = base + 12 + 4*i   ->  i % 2 = 1\n+            \/\/ S_adr = base + 16 + 2*i   ->  i % 4 = 0       S_adr = base + 12 + 2*i   ->  i % 4 = 2\n+            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +33,2 @@\n+ * @requires vm.compiler2.enabled\n+ *\n@@ -33,0 +36,1 @@\n+ *\n@@ -36,1 +40,1 @@\n- *                   compiler.vectorization.runner.ArrayTypeConvertTest\n+ *                   compiler.vectorization.runner.ArrayTypeConvertTest nCOH_nAV\n@@ -38,1 +42,14 @@\n- * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.ArrayTypeConvertTest nCOH_yAV\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.ArrayTypeConvertTest yCOH_nAV\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.ArrayTypeConvertTest yCOH_yAV\n@@ -45,0 +62,4 @@\n+\/\/ Explanation about AlignVector: we require 8-byte alignment of all addresses.\n+\/\/ But the array base offset changes with UseCompactObjectHeaders.\n+\/\/ This means it affects the alignment constraints.\n+\n@@ -47,0 +68,12 @@\n+    \/\/ We must pass the flags directly to the test-VM, and not the driver vm in the @run above.\n+    @Override\n+    protected String[] testVMFlags(String[] args) {\n+        return switch (args[0]) {\n+            case \"nCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"nCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            case \"yCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"yCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+    }\n+\n@@ -78,0 +111,2 @@\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n@@ -87,0 +122,2 @@\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n@@ -96,0 +133,2 @@\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n@@ -106,0 +145,2 @@\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n@@ -115,0 +156,2 @@\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n@@ -124,0 +167,2 @@\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n@@ -180,0 +225,1 @@\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -185,0 +231,7 @@\n+            \/\/ AlignVector=true requires that all vector load\/store are 8-byte aligned.\n+            \/\/ F_adr = base + UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4*i\n+            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 2 = 0\n+            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 2 = 1\n+            \/\/ S_adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*i\n+            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 4 = 0  -> can align both\n+            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 4 = 2  -> cannot align both\n@@ -202,0 +255,2 @@\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n@@ -211,0 +266,2 @@\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n@@ -267,0 +324,1 @@\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -272,0 +330,7 @@\n+            \/\/ AlignVector=true requires that all vector load\/store are 8-byte aligned.\n+            \/\/ F_adr = base + UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4*i\n+            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 2 = 0\n+            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 2 = 1\n+            \/\/ S_adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*i\n+            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 4 = 0  -> can align both\n+            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 4 = 2  -> cannot align both\n@@ -278,0 +343,1 @@\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n@@ -283,0 +349,7 @@\n+            \/\/ AlignVector=true requires that all vector load\/store are 8-byte aligned.\n+            \/\/ F_adr = base + UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4*i\n+            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 2 = 0\n+            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 2 = 1\n+            \/\/ S_adr = base + UNSAFE.ARRAY_SHORT_BASE_OFFSET + 2*i\n+            \/\/                = 16 (UseCompactObjectHeaders=false)    -> i % 4 = 0  -> can align both\n+            \/\/                = 12 (UseCompactObjectHeaders=true )    -> i % 4 = 2  -> cannot align both\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":75,"deletions":2,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+ * @requires vm.compiler2.enabled\n+ *\n@@ -34,0 +36,1 @@\n+ *\n@@ -37,1 +40,1 @@\n- *                   compiler.vectorization.runner.LoopCombinedOpTest\n+ *                   compiler.vectorization.runner.LoopCombinedOpTest nCOH_nAV\n@@ -39,1 +42,14 @@\n- * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopCombinedOpTest nCOH_yAV\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopCombinedOpTest yCOH_nAV\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopCombinedOpTest yCOH_yAV\n@@ -50,0 +66,12 @@\n+    \/\/ We must pass the flags directly to the test-VM, and not the driver vm in the @run above.\n+    @Override\n+    protected String[] testVMFlags(String[] args) {\n+        return switch (args[0]) {\n+            case \"nCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"nCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            case \"yCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"yCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+    }\n+\n@@ -87,1 +115,2 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -98,1 +127,2 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -109,1 +139,2 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -120,1 +151,2 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -131,1 +163,2 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -142,1 +175,2 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -160,1 +194,2 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -175,1 +210,4 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -182,0 +220,17 @@\n+            \/\/ We have a mix of int and short loads\/stores.\n+            \/\/ With UseCompactObjectHeaders and AlignVector,\n+            \/\/ we must 8-byte align all vector loads\/stores.\n+            \/\/\n+            \/\/ int:\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: iter % 2 = 0\n+            \/\/ If UseCompactObjectHeaders=true:  iter % 2 = 1\n+            \/\/\n+            \/\/ byte:\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: iter % 8 = 0\n+            \/\/ If UseCompactObjectHeaders=true:  iter % 8 = 4\n+            \/\/\n+            \/\/ -> we cannot align both if UseCompactObjectHeaders=true.\n@@ -188,1 +243,4 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_ANY, \"> 0\",\n+                  IRNode.LOAD_VECTOR_L,                         \"> 0\"})\n@@ -197,0 +255,17 @@\n+            \/\/ We have a mix of int and short loads\/stores.\n+            \/\/ With UseCompactObjectHeaders and AlignVector,\n+            \/\/ we must 8-byte align all vector loads\/stores.\n+            \/\/\n+            \/\/ int:\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: iter % 2 = 0\n+            \/\/ If UseCompactObjectHeaders=true:  iter % 2 = 1\n+            \/\/\n+            \/\/ byte:\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: iter % 8 = 0\n+            \/\/ If UseCompactObjectHeaders=true:  iter % 8 = 4\n+            \/\/\n+            \/\/ -> we cannot align both if UseCompactObjectHeaders=true.\n@@ -203,1 +278,3 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_ANY, \"> 0\",\n+                  IRNode.LOAD_VECTOR_L,                         \"> 0\"})\n@@ -216,1 +293,4 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -223,0 +303,17 @@\n+            \/\/ We have a mix of int and short loads\/stores.\n+            \/\/ With UseCompactObjectHeaders and AlignVector,\n+            \/\/ we must 8-byte align all vector loads\/stores.\n+            \/\/\n+            \/\/ int:\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: iter % 2 = 0\n+            \/\/ If UseCompactObjectHeaders=true:  iter % 2 = 1\n+            \/\/\n+            \/\/ byte:\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: iter % 8 = 0\n+            \/\/ If UseCompactObjectHeaders=true:  iter % 8 = 4\n+            \/\/\n+            \/\/ -> we cannot align both if UseCompactObjectHeaders=true.\n@@ -228,4 +325,5 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -238,0 +336,17 @@\n+            \/\/ We have a mix of int and short loads\/stores.\n+            \/\/ With UseCompactObjectHeaders and AlignVector,\n+            \/\/ we must 8-byte align all vector loads\/stores.\n+            \/\/\n+            \/\/ int:\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: iter % 2 = 0\n+            \/\/ If UseCompactObjectHeaders=true:  iter % 2 = 1\n+            \/\/\n+            \/\/ byte:\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: iter % 8 = 0\n+            \/\/ If UseCompactObjectHeaders=true:  iter % 8 = 4\n+            \/\/\n+            \/\/ -> we cannot align both if UseCompactObjectHeaders=true.\n@@ -243,4 +358,5 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n-        \/\/ This test fails with compact headers, but only with UseSSE<=3.\n-        applyIf = { \"UseCompactObjectHeaders\", \"false\" },\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -253,0 +369,1 @@\n+            \/\/ same argument as in multipleOpsWith2DifferentTypesAndInvariant.\n@@ -259,1 +376,4 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n@@ -267,0 +387,17 @@\n+            \/\/ We have a mix of int and short loads\/stores.\n+            \/\/ With UseCompactObjectHeaders and AlignVector,\n+            \/\/ we must 8-byte align all vector loads\/stores.\n+            \/\/\n+            \/\/ int:\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 4*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: iter % 2 = 0\n+            \/\/ If UseCompactObjectHeaders=true:  iter % 2 = 1\n+            \/\/\n+            \/\/ byte:\n+            \/\/ adr = base + UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: iter % 8 = 0\n+            \/\/ If UseCompactObjectHeaders=true:  iter % 8 = 4\n+            \/\/\n+            \/\/ -> we cannot align both if UseCompactObjectHeaders=true.\n@@ -272,0 +409,1 @@\n+    \/\/ POPULATE_INDEX seems to mess with vectorization, see JDK-8332878.\n@@ -281,0 +419,1 @@\n+    \/\/ POPULATE_INDEX seems to mess with vectorization, see JDK-8332878.\n@@ -290,0 +429,1 @@\n+    \/\/ POPULATE_INDEX seems to mess with vectorization, see JDK-8332878.\n@@ -299,0 +439,1 @@\n+    \/\/ POPULATE_INDEX seems to mess with vectorization, see JDK-8332878.\n@@ -309,0 +450,1 @@\n+        applyIfOr = { \"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n@@ -315,0 +457,9 @@\n+            \/\/ Hand-unrolling can mess with alignment!\n+            \/\/\n+            \/\/ With UseCompactObjectHeaders and AlignVector,\n+            \/\/ we must 8-byte align all vector loads\/stores.\n+            \/\/\n+            \/\/ adr = base + UNSAFE.ARRAY_INT_BASE_OFFSET + 8*iter\n+            \/\/              = 16 (or 12 if UseCompactObjectHeaders=true)\n+            \/\/ If UseCompactObjectHeaders=false: 16 divisible by 8 -> vectorize\n+            \/\/ If UseCompactObjectHeaders=true:  12 not divisibly by 8 -> not vectorize\n@@ -321,1 +472,2 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":175,"deletions":23,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    protected void run() {\n+    protected void run(String[] args) {\n@@ -71,0 +71,1 @@\n+        irTest.addFlags(testVMFlags(args));\n@@ -74,0 +75,5 @@\n+    \/\/ Override this to add extra flags.\n+    protected String[] testVMFlags(String[] args) {\n+        return new String[0]; \/\/ by default no extra flags\n+    }\n+\n@@ -194,1 +200,1 @@\n-        testObj.run();\n+        testObj.run(args);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=16\", \"AlignVector\", \"false\"},\n@@ -209,1 +209,1 @@\n-        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=16\", \"AlignVector\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/IRExample.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}