{"files":[{"patch":"@@ -39,1 +39,1 @@\n-abstract class Cleaner extends WeakReference<Object> {\n+public abstract class Cleaner extends WeakReference<Object> {\n@@ -110,1 +110,1 @@\n-    static void clean() {\n+    public static void clean() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/Cleaner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;\n@@ -456,6 +455,14 @@\n-    private static HotSpotJVMCIBackendFactory findFactory(String architecture) {\n-        Iterable<HotSpotJVMCIBackendFactory> factories = getHotSpotJVMCIBackendFactories();\n-        assert factories != null : \"sanity\";\n-        for (HotSpotJVMCIBackendFactory factory : factories) {\n-            if (factory.getArchitecture().equalsIgnoreCase(architecture)) {\n-                return factory;\n+    \/**\n+     * The backend factory for the JVMCI shared library.\n+     *\/\n+    private static final HotSpotJVMCIBackendFactory backendFactory;\n+    static {\n+        String arch = HotSpotVMConfig.getHostArchitectureName();\n+        HotSpotJVMCIBackendFactory selected = null;\n+        for (HotSpotJVMCIBackendFactory factory : ServiceLoader.load(HotSpotJVMCIBackendFactory.class)) {\n+            if (factory.getArchitecture().equalsIgnoreCase(arch)) {\n+                if (selected != null) {\n+                    throw new JVMCIError(\"Multiple factories available for %s: %s and %s\",\n+                        arch, selected, factory);\n+                }\n+                selected = factory;\n@@ -464,10 +471,2 @@\n-\n-        throw new JVMCIError(\"No JVMCI runtime available for the %s architecture\", architecture);\n-    }\n-\n-    private static volatile List<HotSpotJVMCIBackendFactory> cachedHotSpotJVMCIBackendFactories;\n-\n-    @SuppressFBWarnings(value = \"LI_LAZY_INIT_UPDATE_STATIC\", justification = \"not sure about this\")\n-    private static Iterable<HotSpotJVMCIBackendFactory> getHotSpotJVMCIBackendFactories() {\n-        if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {\n-            return cachedHotSpotJVMCIBackendFactories;\n+        if (selected == null) {\n+            throw new JVMCIError(\"No JVMCI runtime available for the %s architecture\", arch);\n@@ -475,8 +474,1 @@\n-        Iterable<HotSpotJVMCIBackendFactory> result = ServiceLoader.load(HotSpotJVMCIBackendFactory.class, ClassLoader.getSystemClassLoader());\n-        if (IS_BUILDING_NATIVE_IMAGE) {\n-            cachedHotSpotJVMCIBackendFactories = new ArrayList<>();\n-            for (HotSpotJVMCIBackendFactory factory : result) {\n-                cachedHotSpotJVMCIBackendFactories.add(factory);\n-            }\n-        }\n-        return result;\n+        backendFactory = selected;\n@@ -590,9 +582,2 @@\n-        String hostArchitecture = config.getHostArchitectureName();\n-\n-        HotSpotJVMCIBackendFactory factory;\n-        try (InitTimer t = timer(\"find factory:\", hostArchitecture)) {\n-            factory = findFactory(hostArchitecture);\n-        }\n-\n-        try (InitTimer t = timer(\"create JVMCI backend:\", hostArchitecture)) {\n-            hostBackend = registerBackend(factory.createJVMCIBackend(this, null));\n+        try (InitTimer t = timer(\"create JVMCI backend:\", backendFactory.getArchitecture())) {\n+            hostBackend = registerBackend(backendFactory.createJVMCIBackend(this, null));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":19,"deletions":34,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    String getHostArchitectureName() {\n+    static String getHostArchitectureName() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;\n-\n@@ -74,18 +72,6 @@\n-    private static volatile List<JVMCIServiceLocator> cachedLocators;\n-\n-    private static Iterable<JVMCIServiceLocator> getJVMCIServiceLocators() {\n-        Iterable<JVMCIServiceLocator> result = cachedLocators;\n-        if (result != null) {\n-            return result;\n-        }\n-        result = ServiceLoader.load(JVMCIServiceLocator.class, ClassLoader.getSystemClassLoader());\n-        if (IS_BUILDING_NATIVE_IMAGE) {\n-            ArrayList<JVMCIServiceLocator> l = new ArrayList<>();\n-            for (JVMCIServiceLocator locator : result) {\n-                l.add(locator);\n-            }\n-            l.trimToSize();\n-            cachedLocators = l;\n-            return l;\n-        }\n-        return result;\n+    \/**\n+     * The available set of locators.\n+     *\/\n+    private static final List<JVMCIServiceLocator> locators = new ArrayList<>();\n+    static {\n+        ServiceLoader.load(JVMCIServiceLocator.class).forEach(locators::add);\n@@ -109,1 +95,1 @@\n-        for (JVMCIServiceLocator access : getJVMCIServiceLocators()) {\n+        for (JVMCIServiceLocator access : locators) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/services\/JVMCIServiceLocator.java","additions":7,"deletions":21,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.util.ArrayList;\n-import java.util.Formatter;\n@@ -31,1 +29,0 @@\n-import java.util.ServiceLoader;\n@@ -47,7 +44,0 @@\n-    \/**\n-     * Guards code that should be run when building an JVMCI shared library but should be excluded\n-     * from (being compiled into) the library. Such code must be directly guarded by an {@code if}\n-     * statement on this field - the guard cannot be behind a method call.\n-     *\/\n-    public static final boolean IS_BUILDING_NATIVE_IMAGE = Boolean.parseBoolean(VM.getSavedProperty(\"jdk.vm.ci.services.aot\"));\n-\n@@ -134,28 +124,0 @@\n-    private static final Map<Class<?>, List<?>> servicesCache = IS_BUILDING_NATIVE_IMAGE ? new HashMap<>() : null;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <S> Iterable<S> load0(Class<S> service) {\n-        if (IS_IN_NATIVE_IMAGE || IS_BUILDING_NATIVE_IMAGE) {\n-            List<?> list = servicesCache.get(service);\n-            if (list != null) {\n-                return (Iterable<S>) list;\n-            }\n-            if (IS_IN_NATIVE_IMAGE) {\n-                throw new InternalError(String.format(\"No %s providers found when building native image\", service.getName()));\n-            }\n-        }\n-\n-        Iterable<S> providers = ServiceLoader.load(service, ClassLoader.getSystemClassLoader());\n-        if (IS_BUILDING_NATIVE_IMAGE) {\n-            synchronized (servicesCache) {\n-                ArrayList<S> providersList = new ArrayList<>();\n-                for (S provider : providers) {\n-                    providersList.add(provider);\n-                }\n-                servicesCache.put(service, providersList);\n-                providers = providersList;\n-            }\n-        }\n-        return providers;\n-    }\n-\n@@ -178,51 +140,0 @@\n-    \/**\n-     * Gets an {@link Iterable} of the JVMCI providers available for a given service.\n-     *\n-     * @throws SecurityException if a security manager is present and it denies <tt>\n-     *             {@link RuntimePermission}(\"jvmci\")<\/tt>\n-     *\/\n-    public static <S> Iterable<S> load(Class<S> service) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JVMCIPermission());\n-        }\n-        return load0(service);\n-    }\n-\n-    \/**\n-     * Gets the JVMCI provider for a given service for which at most one provider must be available.\n-     *\n-     * @param service the service whose provider is being requested\n-     * @param required specifies if an {@link InternalError} should be thrown if no provider of\n-     *            {@code service} is available\n-     * @throws SecurityException if a security manager is present and it denies <tt>\n-     *             {@link RuntimePermission}(\"jvmci\")<\/tt>\n-     *\/\n-    public static <S> S loadSingle(Class<S> service, boolean required) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JVMCIPermission());\n-        }\n-        Iterable<S> providers = load0(service);\n-\n-        S singleProvider = null;\n-        for (S provider : providers) {\n-            if (singleProvider != null) {\n-                throw new InternalError(String.format(\"Multiple %s providers found: %s, %s\", service.getName(), singleProvider.getClass().getName(), provider.getClass().getName()));\n-            }\n-            singleProvider = provider;\n-        }\n-        if (singleProvider == null && required) {\n-            String javaHome = Services.getSavedProperty(\"java.home\");\n-            String vmName = Services.getSavedProperty(\"java.vm.name\");\n-            Formatter errorMessage = new Formatter();\n-            errorMessage.format(\"The VM does not expose required service %s.%n\", service.getName());\n-            errorMessage.format(\"Currently used Java home directory is %s.%n\", javaHome);\n-            errorMessage.format(\"Currently used VM configuration is: %s\", vmName);\n-            throw new UnsupportedOperationException(errorMessage.toString());\n-        }\n-        return singleProvider;\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/services\/Services.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -34,5 +34,7 @@\n-    public static void main(String args[]) {\n-        try {\n-            HotSpotJVMCIRuntime.runtime(); \/\/ let's trigger that lazy jvmci init\n-        } catch (Error e) {\n-            System.out.println(GOT_INTERNAL_ERROR);\n+    public static class Main {\n+        public static void main(String args[]) {\n+            try {\n+                HotSpotJVMCIRuntime.runtime(); \/\/ let's trigger that lazy jvmci init\n+            } catch (Error e) {\n+                System.out.println(GOT_INTERNAL_ERROR);\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/events\/JvmciShutdownEventListener.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    private final static String[] MESSAGE = new String[]{\n+    private final static String[] MESSAGE = {\n@@ -60,1 +60,1 @@\n-    private final static String[] ERROR_MESSAGE = new String[]{\n+    private final static String[] ERROR_MESSAGE = {\n@@ -71,1 +71,1 @@\n-                JvmciShutdownEventListener.class.getName()\n+                JvmciShutdownEventListener.Main.class.getName()\n@@ -79,1 +79,1 @@\n-                JvmciShutdownEventListener.class.getName()\n+                JvmciShutdownEventListener.Main.class.getName()\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/events\/JvmciShutdownEventTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}