{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import java.util.stream.Stream;\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+\n@@ -878,1 +883,0 @@\n-\n@@ -881,0 +885,42 @@\n+    \/**\n+     * Delegates all Collection methods to the provided non-sequenced map view,\n+     * except add() and addAll(), which throw UOE. This provides the common\n+     * implementation of each of the sequenced views of the SequencedMap.\n+     * Each view implementation is a subclass that provides an instance of the\n+     * non-sequenced view as a delegate and an implementation of reversed().\n+     * Each view also inherits the default implementations for the sequenced\n+     * methods from SequencedCollection or SequencedSet.\n+     * <p>\n+     * Ideally this would be a private class within SequencedMap, but private\n+     * classes aren't permitted within interfaces.\n+     *\n+     * @param <E> the view's element type\n+     *\/\n+    \/* non-public *\/ static class ViewCollection<E> implements Collection<E> {\n+        UnsupportedOperationException uoe() { return new UnsupportedOperationException(); }\n+        final Collection<E> view;\n+\n+        ViewCollection(Collection<E> view) { this.view = view; }\n+\n+        public boolean add(E t) { throw uoe(); }\n+        public boolean addAll(Collection<? extends E> c) { throw uoe(); }\n+        public void clear() { view.clear(); }\n+        public boolean contains(Object o) { return view.contains(o); }\n+        public boolean containsAll(Collection<?> c) { return view.containsAll(c); }\n+        public boolean equals(Object o) { return view.equals(o); }\n+        public void forEach(Consumer<? super E> c) { view.forEach(c); }\n+        public int hashCode() { return view.hashCode(); }\n+        public boolean isEmpty() { return view.isEmpty(); }\n+        public Iterator<E> iterator() { return view.iterator(); }\n+        public Stream<E> parallelStream() { return view.parallelStream(); }\n+        public boolean remove(Object o) { return view.remove(o); }\n+        public boolean removeAll(Collection<?> c) { return view.removeAll(c); }\n+        public boolean removeIf(Predicate<? super E> filter) { return view.removeIf(filter); }\n+        public boolean retainAll(Collection<?> c) { return view.retainAll(c); }\n+        public int size() { return view.size(); }\n+        public Spliterator<E> spliterator() { return view.spliterator(); }\n+        public Stream<E> stream() { return view.stream(); }\n+        public Object[] toArray() { return view.toArray(); }\n+        public <T> T[] toArray(IntFunction<T[]> generator) { return view.toArray(generator); }\n+        public <T> T[] toArray(T[] a) { return view.toArray(a); }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -77,3 +77,2 @@\n- * <p>This class and its iterator implement all of the\n- * <em>optional<\/em> methods of the {@link Collection} and {@link\n- * Iterator} interfaces.\n+ * <p>This class and its iterator implement all of the <em>optional<\/em> methods of the\n+ * {@link Collection}, {@link SequencedCollection}, and {@link Iterator} interfaces.\n","filename":"src\/java.base\/share\/classes\/java\/util\/ArrayDeque.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,0 +431,23 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public E getFirst() {\n+        if (size == 0) {\n+            throw new NoSuchElementException();\n+        } else {\n+            return elementData(0);\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public E getLast() {\n+        int sz = size;\n+        if (sz == 0) {\n+            throw new NoSuchElementException();\n+        } else {\n+            return elementData(sz - 1);\n+        }\n+    }\n+\n@@ -494,0 +517,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public void addFirst(E element) {\n+        add(0, element);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public void addLast(E element) {\n+        add(element);\n+    }\n+\n@@ -513,0 +550,30 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public E removeFirst() {\n+        if (size == 0) {\n+            throw new NoSuchElementException();\n+        } else {\n+            Object[] es = elementData;\n+            @SuppressWarnings(\"unchecked\") E oldValue = (E) es[0];\n+            fastRemove(es, 0);\n+            return oldValue;\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public E removeLast() {\n+        int sz = size;\n+        if (sz == 0) {\n+            throw new NoSuchElementException();\n+        } else {\n+            Object[] es = elementData;\n+            sz--;\n+            @SuppressWarnings(\"unchecked\") E oldValue = (E) es[sz];\n+            fastRemove(es, sz);\n+            return oldValue;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ArrayList.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -124,2 +124,3 @@\n- * {@link NavigableSet#subSet NavigableSet.subSet}, or\n- * {@link Map#entrySet Map.entrySet}.\n+ * {@link NavigableSet#subSet NavigableSet.subSet},\n+ * {@link Map#entrySet Map.entrySet}, or\n+ * {@link SequencedCollection#reversed SequencedCollection.reversed}.\n@@ -205,1 +206,2 @@\n- * collections. In particular, many <a href=\"#view\">view collections<\/a> are not serializable.\n+ * collections. In particular, many <a href=\"#view\">view collections<\/a> are not serializable,\n+ * even if the original collection is serializable.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collection.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -372,0 +372,5 @@\n+     * @apiNote\n+     * This method mutates the specified list in-place. To obtain a\n+     * reversed-ordered view of a list without mutating it, use the\n+     * {@link List#reversed List.reversed} method.\n+     *\n@@ -375,0 +380,1 @@\n+     * @see    List#reversed List.reversed\n@@ -1133,0 +1139,81 @@\n+    \/**\n+     * Returns an <a href=\"Collection.html#unmodview\">unmodifiable view<\/a> of the\n+     * specified {@code SequencedCollection}. Query operations on the returned collection\n+     * \"read through\" to the specified collection, and attempts to modify the returned\n+     * collection, whether direct or via its iterator, result in an\n+     * {@code UnsupportedOperationException}.<p>\n+     *\n+     * The returned collection does <i>not<\/i> pass the {@code hashCode} and\n+     * {@code equals} operations through to the backing collection, but relies on\n+     * {@code Object}'s {@code equals} and {@code hashCode} methods.  This\n+     * is necessary to preserve the contracts of these operations in the case\n+     * that the backing collection is a set or a list.<p>\n+     *\n+     * The returned collection will be serializable if the specified collection\n+     * is serializable.\n+     *\n+     * @implNote This method may return its argument if the argument is already unmodifiable.\n+     * @param  <T> the class of the objects in the collection\n+     * @param  c the collection for which an unmodifiable view is to be\n+     *         returned.\n+     * @return an unmodifiable view of the specified collection.\n+     * @since 21\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> SequencedCollection<T> unmodifiableSequencedCollection(SequencedCollection<? extends T> c) {\n+        if (c.getClass() == UnmodifiableSequencedCollection.class) {\n+            return (SequencedCollection<T>) c;\n+        }\n+        return new UnmodifiableSequencedCollection<>(c);\n+    }\n+\n+    \/**\n+     * @serial include\n+     *\/\n+    static class UnmodifiableSequencedCollection<E> extends UnmodifiableCollection<E>\n+            implements SequencedCollection<E>, Serializable {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = -6060065079711684830L;\n+\n+        UnmodifiableSequencedCollection(SequencedCollection<? extends E> c) {\n+            super(c);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private SequencedCollection<E> rc() {\n+            return (SequencedCollection<E>) c;\n+        }\n+\n+        \/\/ Even though this wrapper class is serializable, the reversed view is effectively\n+        \/\/ not serializable because it points to the reversed collection view, which usually isn't\n+        \/\/ serializable.\n+        public SequencedCollection<E> reversed() {\n+            return new UnmodifiableSequencedCollection<>(rc().reversed());\n+        }\n+\n+        public void addFirst(E e) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public void addLast(E e) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public E getFirst() {\n+            return rc().getFirst();\n+        }\n+\n+        public E getLast() {\n+            return rc().getLast();\n+        }\n+\n+        public E removeFirst() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public E removeLast() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n@@ -1169,0 +1256,50 @@\n+    \/**\n+     * Returns an <a href=\"Collection.html#unmodview\">unmodifiable view<\/a> of the\n+     * specified {@code SequencedSet}. Query operations on the returned set\n+     * \"read through\" to the specified set, and attempts to modify the returned\n+     * set, whether direct or via its iterator, result in an\n+     * {@code UnsupportedOperationException}.<p>\n+     *\n+     * The returned set will be serializable if the specified set\n+     * is serializable.\n+     *\n+     * @implNote This method may return its argument if the argument is already unmodifiable.\n+     * @param  <T> the class of the objects in the set\n+     * @param  s the set for which an unmodifiable view is to be returned.\n+     * @return an unmodifiable view of the specified sequenced set.\n+     * @since 21\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> SequencedSet<T> unmodifiableSequencedSet(SequencedSet<? extends T> s) {\n+        \/\/ Not checking for subclasses because of heap pollution and information leakage.\n+        if (s.getClass() == UnmodifiableSequencedSet.class) {\n+            return (SequencedSet<T>) s;\n+        }\n+        return new UnmodifiableSequencedSet<>(s);\n+    }\n+\n+    \/**\n+     * @serial include\n+     *\/\n+    static class UnmodifiableSequencedSet<E> extends UnmodifiableSequencedCollection<E>\n+                                             implements SequencedSet<E>, Serializable {\n+        @java.io.Serial\n+        private static final long serialVersionUID = -2153469532349793522L;\n+\n+        UnmodifiableSequencedSet(SequencedSet<? extends E> s)    {super(s);}\n+        public boolean equals(Object o)                          {return o == this || c.equals(o);}\n+        public int hashCode()                                    {return c.hashCode();}\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private SequencedSet<E> ss() {\n+            return (SequencedSet<E>) c;\n+        }\n+\n+        \/\/ Even though this wrapper class is serializable, the reversed view is effectively\n+        \/\/ not serializable because it points to the reversed set view, which usually isn't\n+        \/\/ serializable.\n+        public SequencedSet<E> reversed() {\n+            return new UnmodifiableSequencedSet<>(ss().reversed());\n+        }\n+    }\n+\n@@ -1507,1 +1644,1 @@\n-        private final Map<? extends K, ? extends V> m;\n+        final Map<? extends K, ? extends V> m;\n@@ -1831,0 +1968,66 @@\n+    \/**\n+     * Returns an <a href=\"Collection.html#unmodview\">unmodifiable view<\/a> of the\n+     * specified {@code SequencedMap}. Query operations on the returned map\n+     * \"read through\" to the specified map, and attempts to modify the returned\n+     * map, whether direct or via its collection views, result in an\n+     * {@code UnsupportedOperationException}.<p>\n+     *\n+     * The returned map will be serializable if the specified map\n+     * is serializable.\n+     *\n+     * @implNote This method may return its argument if the argument is already unmodifiable.\n+     * @param <K> the class of the map keys\n+     * @param <V> the class of the map values\n+     * @param  m the map for which an unmodifiable view is to be returned.\n+     * @return an unmodifiable view of the specified map.\n+     * @since 21\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K,V> SequencedMap<K,V> unmodifiableSequencedMap(SequencedMap<? extends K, ? extends V> m) {\n+        \/\/ Not checking for subclasses because of heap pollution and information leakage.\n+        if (m.getClass() == UnmodifiableSequencedMap.class) {\n+            return (SequencedMap<K,V>) m;\n+        }\n+        return new UnmodifiableSequencedMap<>(m);\n+    }\n+\n+    \/**\n+     * @serial include\n+     *\/\n+    private static class UnmodifiableSequencedMap<K,V> extends UnmodifiableMap<K,V> implements SequencedMap<K,V>, Serializable {\n+        @java.io.Serial\n+        private static final long serialVersionUID = -8171676257373950636L;\n+\n+        UnmodifiableSequencedMap(Map<? extends K, ? extends V> m) {\n+            super(m);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private SequencedMap<K, V> sm() {\n+            return (SequencedMap<K, V>) m;\n+        }\n+\n+        \/\/ Even though this wrapper class is serializable, the reversed view is effectively\n+        \/\/ not serializable because it points to the reversed map view, which usually isn't\n+        \/\/ serializable.\n+        public SequencedMap<K, V> reversed() {\n+            return new UnmodifiableSequencedMap<>(sm().reversed());\n+        }\n+\n+        public Entry<K, V> pollFirstEntry() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Entry<K, V> pollLastEntry() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public V putFirst(K k, V v) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public V putLast(K k, V v) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n@@ -5329,0 +5532,8 @@\n+     * @apiNote\n+     * This method returns a {@code Comparator} that is suitable for sorting\n+     * elements in reverse order. To obtain a reverse-ordered <i>view<\/i> of a\n+     * sequenced collection, use the {@link SequencedCollection#reversed\n+     * SequencedCollection.reversed} method. Or, to obtain a reverse-ordered\n+     * <i>view<\/i> of a sequenced map, use the {@link SequencedMap#reversed\n+     * SequencedMap.reversed} method.\n+     *\n@@ -5375,0 +5586,8 @@\n+     * @apiNote\n+     * This method returns a {@code Comparator} that is suitable for sorting\n+     * elements in reverse order. To obtain a reverse-ordered <i>view<\/i> of a\n+     * sequenced collection, use the {@link SequencedCollection#reversed\n+     * SequencedCollection.reversed} method. Or, to obtain a reverse-ordered\n+     * <i>view<\/i> of a sequenced map, use the {@link SequencedMap#reversed\n+     * SequencedMap.reversed} method.\n+     *\n@@ -5685,0 +5904,2 @@\n+        if (! map.isEmpty())\n+            throw new IllegalArgumentException(\"Map is non-empty\");\n@@ -5695,1 +5916,1 @@\n-        private final Map<E, Boolean> m;  \/\/ The backing map\n+        final Map<E, Boolean> m;          \/\/ The backing map\n@@ -5699,2 +5920,0 @@\n-            if (!map.isEmpty())\n-                throw new IllegalArgumentException(\"Map is non-empty\");\n@@ -5749,0 +5968,85 @@\n+\n+        @java.io.Serial\n+        private void readObjectNoData() throws java.io.ObjectStreamException {\n+            throw new java.io.InvalidObjectException(\"missing SetFromMap data\");\n+        }\n+    }\n+\n+    \/**\n+     * Returns a sequenced set backed by the specified map.  The resulting set displays\n+     * the same ordering, concurrency, and performance characteristics as the\n+     * backing map. In essence, this factory method provides a {@link SequencedSet}\n+     * implementation corresponding to any {@link SequencedMap} implementation.\n+     *\n+     * <p>Each method invocation on the set returned by this method results in\n+     * exactly one method invocation on the backing map or its {@code keySet}\n+     * view, with one exception.  The {@code addAll} method is implemented\n+     * as a sequence of {@code put} invocations on the backing map.\n+     *\n+     * <p>The specified map must be empty at the time this method is invoked,\n+     * and should not be accessed directly after this method returns.  These\n+     * conditions are ensured if the map is created empty, passed directly\n+     * to this method, and no reference to the map is retained.\n+     *\n+     * @apiNote\n+     * The following example code creates a {@code SequencedSet} from a\n+     * {@code LinkedHashMap}. This differs from a {@code LinkedHashSet}\n+     * in that the map's {@code removeEldestEntry} is overridden to provide\n+     * an eviction policy, which is not possible with a {@code LinkedHashSet}.\n+     *\n+     * <pre>{@code\n+     *     SequencedSet<String> set = Collections.newSequencedSetFromMap(\n+     *         new LinkedHashMap<String, Boolean>() {\n+     *             protected boolean removeEldestEntry(Map.Entry<String, Boolean> e) {\n+     *                 return this.size() > 5;\n+     *             }\n+     *        });\n+     * }<\/pre>\n+     *\n+     * @param <E> the class of the map keys and of the objects in the\n+     *        returned set\n+     * @param map the backing map\n+     * @return the set backed by the map\n+     * @throws IllegalArgumentException if {@code map} is not empty\n+     * @since 21\n+     *\/\n+    public static <E> SequencedSet<E> newSequencedSetFromMap(SequencedMap<E, Boolean> map) {\n+        if (! map.isEmpty())\n+            throw new IllegalArgumentException(\"Map is non-empty\");\n+        return new SequencedSetFromMap<>(map);\n+    }\n+\n+    \/**\n+     * @serial include\n+     *\/\n+    private static class SequencedSetFromMap<E> extends SetFromMap<E> implements SequencedSet<E> {\n+        private final E nsee(Map.Entry<E, Boolean> e) {\n+            if (e == null) {\n+                throw new NoSuchElementException();\n+            } else {\n+                return e.getKey();\n+            }\n+        }\n+\n+        private final SequencedMap<E, Boolean> map() {\n+            return (SequencedMap<E, Boolean>) super.m;\n+        }\n+\n+        SequencedSetFromMap(SequencedMap<E, Boolean> map) {\n+            super(map);\n+        }\n+\n+        \/\/ Even though this wrapper class is serializable, the reversed view is effectively\n+        \/\/ not serializable because it points to the reversed map view, which usually isn't\n+        \/\/ serializable.\n+        public SequencedSet<E> reversed() { return new SequencedSetFromMap<>(map().reversed()); }\n+\n+        public void addFirst(E e) { map().putFirst(e, Boolean.TRUE); }\n+        public void addLast(E e)  { map().putLast(e, Boolean.TRUE); }\n+        public E getFirst()       { return nsee(map().firstEntry()); }\n+        public E getLast()        { return nsee(map().lastEntry()); }\n+        public E removeFirst()    { return nsee(map().pollFirstEntry()); }\n+        public E removeLast()     { return nsee(map().pollLastEntry()); }\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = -3943479744841433802L;\n@@ -5764,0 +6068,5 @@\n+     * @apiNote\n+     * This method provides a view that inverts the sense of certain operations,\n+     * but it doesn't reverse the encounter order. To obtain a reversed-ordered\n+     * view, use the {@link Deque#reversed Deque::reversed} method.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":313,"deletions":4,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-public interface Deque<E> extends Queue<E> {\n+public interface Deque<E> extends Queue<E>, SequencedCollection<E> {\n@@ -616,0 +616,13 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec\n+     * The implementation in this class returns an instance of a reverse-ordered\n+     * Deque that delegates its operations to this Deque.\n+     *\n+     * @return a reverse-ordered view of this collection, as a {@code Deque}\n+     * @since 21\n+     *\/\n+    default Deque<E> reversed() {\n+        return ReverseOrderDequeView.of(this);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Deque.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    private transient HashMap<E,Object> map;\n+    transient HashMap<E,Object> map;\n@@ -100,1 +100,1 @@\n-    private static final Object PRESENT = new Object();\n+    static final Object PRESENT = new Object();\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -334,0 +334,5 @@\n+        @Override\n+        public List<E> reversed() {\n+            return ReverseOrderListView.of(this, false);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.function.Function;\n@@ -35,3 +36,3 @@\n- * with predictable iteration order.  This implementation differs from\n- * {@code HashMap} in that it maintains a doubly-linked list running through\n- * all of its entries.  This linked list defines the iteration ordering,\n+ * with well-defined encounter order.  This implementation differs from\n+ * {@code HashMap} in that it maintains a doubly-linked list running through all of\n+ * its entries.  This linked list defines the encounter order (the order of iteration),\n@@ -39,3 +40,3 @@\n- * (<i>insertion-order<\/i>).  Note that insertion order is not affected\n- * if a key is <i>re-inserted<\/i> into the map.  (A key {@code k} is\n- * reinserted into a map {@code m} if {@code m.put(k, v)} is invoked when\n+ * (<i>insertion-order<\/i>).  Note that encounter order is not affected\n+ * if a key is <i>re-inserted<\/i> into the map with the {@code put} method. (A key\n+ * {@code k} is reinserted into a map {@code m} if {@code m.put(k, v)} is invoked when\n@@ -43,1 +44,2 @@\n- * the invocation.)\n+ * the invocation.) The encounter order of existing keys can be changed by using\n+ * the {@link #putFirst putFirst} and {@link #putLast putLast} methods.\n@@ -79,1 +81,4 @@\n- * are added to the map.\n+ * are added to the map. Alternatively, since the \"eldest\" entry is the first\n+ * entry in encounter order, programs can inspect and remove stale mappings through\n+ * use of the {@link #firstEntry firstEntry} and {@link #pollFirstEntry pollFirstEntry}\n+ * methods.\n@@ -81,2 +86,2 @@\n- * <p>This class provides all of the optional {@code Map} operations, and\n- * permits null elements.  Like {@code HashMap}, it provides constant-time\n+ * <p>This class provides all of the optional {@code Map} and {@code SequencedMap} operations,\n+ * and it permits null elements.  Like {@code HashMap}, it provides constant-time\n@@ -165,1 +170,1 @@\n-    implements Map<K,V>\n+    implements SequencedMap<K,V>\n@@ -223,4 +228,3 @@\n-    private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {\n-        LinkedHashMap.Entry<K,V> last = tail;\n-        tail = p;\n-        if (last == null)\n+    private void linkNodeAtEnd(LinkedHashMap.Entry<K,V> p) {\n+        if (putMode == PUT_FIRST) {\n+            LinkedHashMap.Entry<K,V> first = head;\n@@ -228,3 +232,15 @@\n-        else {\n-            p.before = last;\n-            last.after = p;\n+            if (first == null)\n+                tail = p;\n+            else {\n+                p.after = first;\n+                first.before = p;\n+            }\n+        } else {\n+            LinkedHashMap.Entry<K,V> last = tail;\n+            tail = p;\n+            if (last == null)\n+                head = p;\n+            else {\n+                p.before = last;\n+                last.after = p;\n+            }\n@@ -259,1 +275,1 @@\n-        linkNodeLast(p);\n+        linkNodeAtEnd(p);\n@@ -273,1 +289,1 @@\n-        linkNodeLast(p);\n+        linkNodeAtEnd(p);\n@@ -306,1 +322,7 @@\n-    void afterNodeAccess(Node<K,V> e) { \/\/ move node to last\n+    static final int PUT_NORM = 0;\n+    static final int PUT_FIRST = 1;\n+    static final int PUT_LAST = 2;\n+    int putMode = PUT_NORM;\n+\n+    \/\/ Called after update, but not after insertion\n+    void afterNodeAccess(Node<K,V> e) {\n@@ -308,1 +330,3 @@\n-        if (accessOrder && (last = tail) != e) {\n+        LinkedHashMap.Entry<K,V> first;\n+        if ((putMode == PUT_LAST || (putMode == PUT_NORM && accessOrder)) && (last = tail) != e) {\n+            \/\/ move node to last\n@@ -328,0 +352,55 @@\n+        } else if (putMode == PUT_FIRST && (first = head) != e) {\n+            \/\/ move node to first\n+            LinkedHashMap.Entry<K,V> p =\n+                (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n+            p.before = null;\n+            if (a == null)\n+                tail = b;\n+            else\n+                a.before = b;\n+            if (b != null)\n+                b.after = a;\n+            else\n+                first = a;\n+            if (first == null)\n+                tail = p;\n+            else {\n+                p.after = first;\n+                first.before = p;\n+            }\n+            head = p;\n+            ++modCount;\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * If this map already contains a mapping for this key, the mapping is relocated if necessary\n+     * so that it is first in encounter order.\n+     *\n+     * @since 21\n+     *\/\n+    public V putFirst(K k, V v) {\n+        try {\n+            putMode = PUT_FIRST;\n+            return this.put(k, v);\n+        } finally {\n+            putMode = PUT_NORM;\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * If this map already contains a mapping for this key, the mapping is relocated if necessary\n+     * so that it is last in encounter order.\n+     *\n+     * @since 21\n+     *\/\n+    public V putLast(K k, V v) {\n+        try {\n+            putMode = PUT_LAST;\n+            return this.put(k, v);\n+        } finally {\n+            putMode = PUT_NORM;\n@@ -522,2 +601,3 @@\n-     * Returns a {@link Set} view of the keys contained in this map.\n-     * The set is backed by the map, so changes to the map are\n+     * Returns a {@link Set} view of the keys contained in this map. The encounter\n+     * order of the keys in the view matches the encounter order of mappings of\n+     * this map. The set is backed by the map, so changes to the map are\n@@ -540,0 +620,13 @@\n+        return sequencedKeySet();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * The returned view has the same characteristics as specified for the view\n+     * returned by the {@link #keySet keySet} method.\n+     *\n+     * @return {@inheritDoc}\n+     * @since 21\n+     *\/\n+    public SequencedSet<K> sequencedKeySet() {\n@@ -541,3 +634,8 @@\n-        if (ks == null) {\n-            ks = new LinkedKeySet();\n-            keySet = ks;\n+        if (ks instanceof SequencedSet<K> sks) {\n+            return sks;\n+        } else if (ks == null) {\n+            SequencedSet<K> sks = new LinkedKeySet(false);\n+            keySet = sks;\n+            return sks;\n+        } else {\n+            return new LinkedKeySet(false);\n@@ -545,1 +643,0 @@\n-        return ks;\n@@ -548,1 +645,7 @@\n-    @Override\n+    static <K1,V1> Node<K1,V1> nsee(Node<K1,V1> node) {\n+        if (node == null)\n+            throw new NoSuchElementException();\n+        else\n+            return node;\n+    }\n+\n@@ -550,0 +653,4 @@\n+        return keysToArray(a, false);\n+    }\n+\n+    final <T> T[] keysToArray(T[] a, boolean reversed) {\n@@ -552,2 +659,8 @@\n-        for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after) {\n-            r[idx++] = e.key;\n+        if (reversed) {\n+            for (LinkedHashMap.Entry<K,V> e = tail; e != null; e = e.before) {\n+                r[idx++] = e.key;\n+            }\n+        } else {\n+            for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after) {\n+                r[idx++] = e.key;\n+            }\n@@ -558,2 +671,1 @@\n-    @Override\n-    final <T> T[] valuesToArray(T[] a) {\n+    final <T> T[] valuesToArray(T[] a, boolean reversed) {\n@@ -562,2 +674,8 @@\n-        for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after) {\n-            r[idx++] = e.value;\n+        if (reversed) {\n+            for (LinkedHashMap.Entry<K,V> e = tail; e != null; e = e.before) {\n+                r[idx++] = e.value;\n+            }\n+        } else {\n+            for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after) {\n+                r[idx++] = e.value;\n+            }\n@@ -568,1 +686,3 @@\n-    final class LinkedKeySet extends AbstractSet<K> {\n+    final class LinkedKeySet extends AbstractSet<K> implements SequencedSet<K> {\n+        final boolean reversed;\n+        LinkedKeySet(boolean reversed)          { this.reversed = reversed; }\n@@ -572,1 +692,1 @@\n-            return new LinkedKeyIterator();\n+            return new LinkedKeyIterator(reversed);\n@@ -585,1 +705,1 @@\n-            return keysToArray(new Object[size]);\n+            return keysToArray(new Object[size], reversed);\n@@ -589,1 +709,1 @@\n-            return keysToArray(prepareArray(a));\n+            return keysToArray(prepareArray(a), reversed);\n@@ -596,2 +716,7 @@\n-            for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)\n-                action.accept(e.key);\n+            if (reversed) {\n+                for (LinkedHashMap.Entry<K,V> e = tail; e != null; e = e.before)\n+                    action.accept(e.key);\n+            } else {\n+                for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)\n+                    action.accept(e.key);\n+            }\n@@ -601,0 +726,21 @@\n+        public final void addFirst(K k) { throw new UnsupportedOperationException(); }\n+        public final void addLast(K k) { throw new UnsupportedOperationException(); }\n+        public final K getFirst() { return nsee(reversed ? tail : head).key; }\n+        public final K getLast() { return nsee(reversed ? head : tail).key; }\n+        public final K removeFirst() {\n+            var node = nsee(reversed ? tail : head);\n+            removeNode(node.hash, node.key, null, false, false);\n+            return node.key;\n+        }\n+        public final K removeLast() {\n+            var node = nsee(reversed ? head : tail);\n+            removeNode(node.hash, node.key, null, false, false);\n+            return node.key;\n+        }\n+        public SequencedSet<K> reversed() {\n+            if (reversed) {\n+                return LinkedHashMap.this.sequencedKeySet();\n+            } else {\n+                return new LinkedKeySet(true);\n+            }\n+        }\n@@ -604,2 +750,3 @@\n-     * Returns a {@link Collection} view of the values contained in this map.\n-     * The collection is backed by the map, so changes to the map are\n+     * Returns a {@link Collection} view of the values contained in this map. The\n+     * encounter order of values in the view matches the encounter order of entries in\n+     * this map. The collection is backed by the map, so changes to the map are\n@@ -622,0 +769,13 @@\n+        return sequencedValues();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * The returned view has the same characteristics as specified for the view\n+     * returned by the {@link #values values} method.\n+     *\n+     * @return {@inheritDoc}\n+     * @since 21\n+     *\/\n+    public SequencedCollection<V> sequencedValues() {\n@@ -623,3 +783,8 @@\n-        if (vs == null) {\n-            vs = new LinkedValues();\n-            values = vs;\n+        if (vs instanceof SequencedCollection<V> svs) {\n+            return svs;\n+        } else if (vs == null) {\n+            SequencedCollection<V> svs = new LinkedValues(false);\n+            values = svs;\n+            return svs;\n+        } else {\n+            return new LinkedValues(false);\n@@ -627,1 +792,0 @@\n-        return vs;\n@@ -630,1 +794,3 @@\n-    final class LinkedValues extends AbstractCollection<V> {\n+    final class LinkedValues extends AbstractCollection<V> implements SequencedCollection<V> {\n+        final boolean reversed;\n+        LinkedValues(boolean reversed)          { this.reversed = reversed; }\n@@ -634,1 +800,1 @@\n-            return new LinkedValueIterator();\n+            return new LinkedValueIterator(reversed);\n@@ -643,1 +809,1 @@\n-            return valuesToArray(new Object[size]);\n+            return valuesToArray(new Object[size], reversed);\n@@ -647,1 +813,1 @@\n-            return valuesToArray(prepareArray(a));\n+            return valuesToArray(prepareArray(a), reversed);\n@@ -654,2 +820,7 @@\n-            for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)\n-                action.accept(e.value);\n+            if (reversed) {\n+                for (LinkedHashMap.Entry<K,V> e = tail; e != null; e = e.before)\n+                    action.accept(e.value);\n+            } else {\n+                for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)\n+                    action.accept(e.value);\n+            }\n@@ -659,0 +830,21 @@\n+        public final void addFirst(V v) { throw new UnsupportedOperationException(); }\n+        public final void addLast(V v) { throw new UnsupportedOperationException(); }\n+        public final V getFirst() { return nsee(reversed ? tail : head).value; }\n+        public final V getLast() { return nsee(reversed ? head : tail).value; }\n+        public final V removeFirst() {\n+            var node = nsee(reversed ? tail : head);\n+            removeNode(node.hash, node.key, null, false, false);\n+            return node.value;\n+        }\n+        public final V removeLast() {\n+            var node = nsee(reversed ? head : tail);\n+            removeNode(node.hash, node.key, null, false, false);\n+            return node.value;\n+        }\n+        public SequencedCollection<V> reversed() {\n+            if (reversed) {\n+                return LinkedHashMap.this.sequencedValues();\n+            } else {\n+                return new LinkedValues(true);\n+            }\n+        }\n@@ -662,1 +854,2 @@\n-     * Returns a {@link Set} view of the mappings contained in this map.\n+     * Returns a {@link Set} view of the mappings contained in this map. The encounter\n+     * order of the view matches the encounter order of entries of this map.\n@@ -681,2 +874,1 @@\n-        Set<Map.Entry<K,V>> es;\n-        return (es = entrySet) == null ? (entrySet = new LinkedEntrySet()) : es;\n+        return sequencedEntrySet();\n@@ -685,1 +877,26 @@\n-    final class LinkedEntrySet extends AbstractSet<Map.Entry<K,V>> {\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * The returned view has the same characteristics as specified for the view\n+     * returned by the {@link #entrySet entrySet} method.\n+     *\n+     * @return {@inheritDoc}\n+     * @since 21\n+     *\/\n+    public SequencedSet<Map.Entry<K, V>> sequencedEntrySet() {\n+        Set<Map.Entry<K, V>> es = entrySet;\n+        if (es instanceof SequencedSet<Map.Entry<K, V>> ses) {\n+            return ses;\n+        } else if (es == null) {\n+            SequencedSet<Map.Entry<K, V>> ses = new LinkedEntrySet(false);\n+            entrySet = ses;\n+            return ses;\n+        } else {\n+            return new LinkedEntrySet(false);\n+        }\n+    }\n+\n+    final class LinkedEntrySet extends AbstractSet<Map.Entry<K,V>>\n+        implements SequencedSet<Map.Entry<K,V>> {\n+        final boolean reversed;\n+        LinkedEntrySet(boolean reversed)        { this.reversed = reversed; }\n@@ -689,1 +906,1 @@\n-            return new LinkedEntryIterator();\n+            return new LinkedEntryIterator(reversed);\n@@ -715,2 +932,7 @@\n-            for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)\n-                action.accept(e);\n+            if (reversed) {\n+                for (LinkedHashMap.Entry<K,V> e = tail; e != null; e = e.before)\n+                    action.accept(e);\n+            } else {\n+                for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)\n+                    action.accept(e);\n+            }\n@@ -720,0 +942,27 @@\n+        final Node<K,V> nsee(Node<K,V> e) {\n+            if (e == null)\n+                throw new NoSuchElementException();\n+            else\n+                return e;\n+        }\n+        public final void addFirst(Map.Entry<K,V> e) { throw new UnsupportedOperationException(); }\n+        public final void addLast(Map.Entry<K,V> e) { throw new UnsupportedOperationException(); }\n+        public final Map.Entry<K,V> getFirst() { return nsee(reversed ? tail : head); }\n+        public final Map.Entry<K,V> getLast() { return nsee(reversed ? head : tail); }\n+        public final Map.Entry<K,V> removeFirst() {\n+            var node = nsee(reversed ? tail : head);\n+            removeNode(node.hash, node.key, null, false, false);\n+            return node;\n+        }\n+        public final Map.Entry<K,V> removeLast() {\n+            var node = nsee(reversed ? head : tail);\n+            removeNode(node.hash, node.key, null, false, false);\n+            return node;\n+        }\n+        public SequencedSet<Map.Entry<K,V>> reversed() {\n+            if (reversed) {\n+                return LinkedHashMap.this.sequencedEntrySet();\n+            } else {\n+                return new LinkedEntrySet(true);\n+            }\n+        }\n@@ -750,0 +999,1 @@\n+        boolean reversed;\n@@ -751,2 +1001,3 @@\n-        LinkedHashIterator() {\n-            next = head;\n+        LinkedHashIterator(boolean reversed) {\n+            this.reversed = reversed;\n+            next = reversed ? tail : head;\n@@ -768,1 +1019,1 @@\n-            next = e.after;\n+            next = reversed ? e.before : e.after;\n@@ -786,0 +1037,1 @@\n+        LinkedKeyIterator(boolean reversed) { super(reversed); }\n@@ -791,0 +1043,1 @@\n+        LinkedValueIterator(boolean reversed) { super(reversed); }\n@@ -796,0 +1049,1 @@\n+        LinkedEntryIterator(boolean reversed) { super(reversed); }\n@@ -819,0 +1073,177 @@\n+    \/\/ Reversed View\n+\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * Modifications to the reversed view and its map views are permitted and will be\n+     * propagated to this map. In addition, modifications to this map will be visible\n+     * in the reversed view and its map views.\n+     *\n+     * @return {@inheritDoc}\n+     * @since 21\n+     *\/\n+    public SequencedMap<K, V> reversed() {\n+        return new ReversedLinkedHashMapView<>(this);\n+    }\n+\n+    static class ReversedLinkedHashMapView<K, V> extends AbstractMap<K, V>\n+                                                 implements SequencedMap<K, V> {\n+        final LinkedHashMap<K, V> base;\n+\n+        ReversedLinkedHashMapView(LinkedHashMap<K, V> lhm) {\n+            base = lhm;\n+        }\n+\n+        \/\/ Object\n+        \/\/ inherit toString() from AbstractMap; it depends on entrySet()\n+\n+        public boolean equals(Object o) {\n+            return base.equals(o);\n+        }\n+\n+        public int hashCode() {\n+            return base.hashCode();\n+        }\n+\n+        \/\/ Map\n+\n+        public int size() {\n+            return base.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return base.isEmpty();\n+        }\n+\n+        public boolean containsKey(Object key) {\n+            return base.containsKey(key);\n+        }\n+\n+        public boolean containsValue(Object value) {\n+            return base.containsValue(value);\n+        }\n+\n+        public V get(Object key) {\n+            return base.get(key);\n+        }\n+\n+        public V put(K key, V value) {\n+            return base.put(key, value);\n+        }\n+\n+        public V remove(Object key) {\n+            return base.remove(key);\n+        }\n+\n+        public void putAll(Map<? extends K, ? extends V> m) {\n+            for (var e : m.entrySet()) {\n+                if (base.containsKey(e.getKey())) {\n+                    base.put(e.getKey(), e.getValue());\n+                } else {\n+                    base.putFirst(e.getKey(), e.getValue());\n+                }\n+            }\n+        }\n+\n+        public void clear() {\n+            base.clear();\n+        }\n+\n+        public Set<K> keySet() {\n+            return base.sequencedKeySet().reversed();\n+        }\n+\n+        public Collection<V> values() {\n+            return base.sequencedValues().reversed();\n+        }\n+\n+        public Set<Entry<K, V>> entrySet() {\n+            return base.sequencedEntrySet().reversed();\n+        }\n+\n+        public V getOrDefault(Object key, V defaultValue) {\n+            return base.getOrDefault(key, defaultValue);\n+        }\n+\n+        public void forEach(BiConsumer<? super K, ? super V> action) {\n+            if (action == null)\n+                throw new NullPointerException();\n+            int mc = base.modCount;\n+            for (LinkedHashMap.Entry<K,V> e = base.tail; e != null; e = e.before)\n+                action.accept(e.key, e.value);\n+            if (base.modCount != mc)\n+                throw new ConcurrentModificationException();\n+        }\n+\n+        public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n+            if (function == null)\n+                throw new NullPointerException();\n+            int mc = base.modCount;\n+            for (LinkedHashMap.Entry<K,V> e = base.tail; e != null; e = e.before)\n+                e.value = function.apply(e.key, e.value);\n+            if (base.modCount != mc)\n+                throw new ConcurrentModificationException();\n+        }\n+\n+        public V putIfAbsent(K key, V value) {\n+            return base.putIfAbsent(key, value);\n+        }\n+\n+        public boolean remove(Object key, Object value) {\n+            return base.remove(key, value);\n+        }\n+\n+        public boolean replace(K key, V oldValue, V newValue) {\n+            return base.replace(key, oldValue, newValue);\n+        }\n+\n+        public V replace(K key, V value) {\n+            return base.replace(key, value);\n+        }\n+\n+        public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n+            return base.computeIfAbsent(key, mappingFunction);\n+        }\n+\n+        public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+            return base.computeIfPresent(key, remappingFunction);\n+        }\n+\n+        public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+            return base.compute(key, remappingFunction);\n+        }\n+\n+        public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n+            return base.merge(key, value, remappingFunction);\n+        }\n+\n+        \/\/ SequencedMap\n+\n+        public SequencedMap<K, V> reversed() {\n+            return base;\n+        }\n+\n+        public Entry<K, V> firstEntry() {\n+            return base.lastEntry();\n+        }\n+\n+        public Entry<K, V> lastEntry() {\n+            return base.firstEntry();\n+        }\n+\n+        public Entry<K, V> pollFirstEntry() {\n+            return base.pollLastEntry();\n+        }\n+\n+        public Entry<K, V> pollLastEntry() {\n+            return base.pollFirstEntry();\n+        }\n+\n+        public V putFirst(K k, V v) {\n+            return base.putLast(k, v);\n+        }\n+\n+        public V putLast(K k, V v) {\n+            return base.putFirst(k, v);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashMap.java","additions":495,"deletions":64,"binary":false,"changes":559,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * with predictable iteration order.  This implementation differs from\n+ * with well-defined encounter order.  This implementation differs from\n@@ -32,7 +32,8 @@\n- * all of its entries.  This linked list defines the iteration ordering,\n- * which is the order in which elements were inserted into the set\n- * (<i>insertion-order<\/i>).  Note that insertion order is <i>not<\/i> affected\n- * if an element is <i>re-inserted<\/i> into the set.  (An element {@code e}\n- * is reinserted into a set {@code s} if {@code s.add(e)} is invoked when\n- * {@code s.contains(e)} would return {@code true} immediately prior to\n- * the invocation.)\n+ * all of its entries.  This linked list defines the encounter order (iteration\n+ * order), which is the order in which elements were inserted into the set\n+ * (<i>insertion-order<\/i>). Note that encounter order is <i>not<\/i> affected\n+ * if an element is <i>re-inserted<\/i> into the set with the {@code add} method.\n+ * (An element {@code e} is reinserted into a set {@code s} if {@code s.add(e)} is\n+ * invoked when {@code s.contains(e)} would return {@code true} immediately prior to\n+ * the invocation.) The encounter order of elements already in the set can be changed\n+ * by using the {@link #addFirst addFirst} and {@link #addLast addLast} methods.\n@@ -56,2 +57,2 @@\n- * <p>This class provides all of the optional {@code Set} operations, and\n- * permits null elements.  Like {@code HashSet}, it provides constant-time\n+ * <p>This class provides all of the optional {@link Set} and {@link SequencedSet}\n+ * operations, and it permits null elements. Like {@code HashSet}, it provides constant-time\n@@ -120,1 +121,1 @@\n-    implements Set<E>, Cloneable, java.io.Serializable {\n+    implements SequencedSet<E>, Cloneable, java.io.Serializable {\n@@ -224,0 +225,94 @@\n+    @SuppressWarnings(\"unchecked\")\n+    LinkedHashMap<E, Object> map() {\n+        return (LinkedHashMap<E, Object>) map;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * If this set already contains the element, it is relocated if necessary so that it is\n+     * first in encounter order.\n+     *\n+     * @since 21\n+     *\/\n+    public void addFirst(E e) {\n+        map().putFirst(e, PRESENT);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * If this set already contains the element, it is relocated if necessary so that it is\n+     * last in encounter order.\n+     *\n+     * @since 21\n+     *\/\n+    public void addLast(E e) {\n+        map().putLast(e, PRESENT);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    public E getFirst() {\n+        return map().sequencedKeySet().getFirst();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    public E getLast() {\n+        return map().sequencedKeySet().getLast();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 21\n+     *\/\n+    public E removeFirst() {\n+        return map().sequencedKeySet().removeFirst();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    public E removeLast() {\n+        return map().sequencedKeySet().removeLast();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * Modifications to the reversed view are permitted and will be propagated to this set.\n+     * In addition, modifications to this set will be visible in the reversed view.\n+     *\n+     * @return {@inheritDoc}\n+     * @since 21\n+     *\/\n+    public SequencedSet<E> reversed() {\n+        class ReverseLinkedHashSetView extends AbstractSet<E> implements SequencedSet<E> {\n+            public int size()                  { return LinkedHashSet.this.size(); }\n+            public Iterator<E> iterator()      { return map().sequencedKeySet().reversed().iterator(); }\n+            public void addFirst(E e)          { LinkedHashSet.this.addLast(e); }\n+            public void addLast(E e)           { LinkedHashSet.this.addFirst(e); }\n+            public E getFirst()                { return LinkedHashSet.this.getLast(); }\n+            public E getLast()                 { return LinkedHashSet.this.getFirst(); }\n+            public E removeFirst()             { return LinkedHashSet.this.removeLast(); }\n+            public E removeLast()              { return LinkedHashSet.this.removeFirst(); }\n+            public SequencedSet<E> reversed()  { return LinkedHashSet.this; }\n+            public Object[] toArray() { return map().keysToArray(new Object[map.size()], true); }\n+            public <T> T[] toArray(T[] a) { return map().keysToArray(map.prepareArray(a), true); }\n+\n+            public boolean add(E e) {\n+                boolean present = LinkedHashSet.this.contains(e);\n+                LinkedHashSet.this.addFirst(e);\n+                return ! present;\n+            }\n+        }\n+\n+        return new ReverseLinkedHashSetView();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashSet.java","additions":107,"deletions":12,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n@@ -29,0 +32,4 @@\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Stream;\n@@ -1269,0 +1276,263 @@\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * Modifications to the reversed view are permitted and will be propagated to this list.\n+     * In addition, modifications to this list will be visible in the reversed view.\n+     *\n+     * @return {@inheritDoc}\n+     * @since 21\n+     *\/\n+    public LinkedList<E> reversed() {\n+        return new ReverseOrderLinkedListView<>(this, super.reversed(), Deque.super.reversed());\n+    }\n+\n+    \/\/ all operations are delegated to the reverse-ordered views.\n+    \/\/ TODO audit all overridden methods\n+    @SuppressWarnings(\"serial\")\n+    static class ReverseOrderLinkedListView<E> extends LinkedList<E> implements java.io.Externalizable {\n+        final LinkedList<E> list;\n+        final List<E> rlist;\n+        final Deque<E> rdeque;\n+\n+        ReverseOrderLinkedListView(LinkedList<E> list, List<E> rlist, Deque<E> rdeque) {\n+            this.list = list;\n+            this.rlist = rlist;\n+            this.rdeque = rdeque;\n+        }\n+\n+        public String toString() {\n+            return rlist.toString();\n+        }\n+\n+        public boolean retainAll(Collection<?> c) {\n+            return rlist.retainAll(c);\n+        }\n+\n+        public boolean removeAll(Collection<?> c) {\n+            return rlist.removeAll(c);\n+        }\n+\n+        public boolean containsAll(Collection<?> c) {\n+            return rlist.containsAll(c);\n+        }\n+\n+        public boolean isEmpty() {\n+            return rlist.isEmpty();\n+        }\n+\n+        public Stream<E> parallelStream() {\n+            return rlist.parallelStream();\n+        }\n+\n+        public Stream<E> stream() {\n+            return rlist.stream();\n+        }\n+\n+        public boolean removeIf(Predicate<? super E> filter) {\n+            return rlist.removeIf(filter);\n+        }\n+\n+        public <T> T[] toArray(IntFunction<T[]> generator) {\n+            return rlist.toArray(generator);\n+        }\n+\n+        public void forEach(Consumer<? super E> action) {\n+            rlist.forEach(action);\n+        }\n+\n+        public Iterator<E> iterator() {\n+            return rlist.iterator();\n+        }\n+\n+        public int hashCode() {\n+            return rlist.hashCode();\n+        }\n+\n+        public boolean equals(Object o) {\n+            return rlist.equals(o);\n+        }\n+\n+        public List<E> subList(int fromIndex, int toIndex) {\n+            return rlist.subList(fromIndex, toIndex);\n+        }\n+\n+        public ListIterator<E> listIterator() {\n+            return rlist.listIterator();\n+        }\n+\n+        public void sort(Comparator<? super E> c) {\n+            rlist.sort(c);\n+        }\n+\n+        public void replaceAll(UnaryOperator<E> operator) {\n+            rlist.replaceAll(operator);\n+        }\n+\n+        public LinkedList<E> reversed() {\n+            return list;\n+        }\n+\n+        public Spliterator<E> spliterator() {\n+            return rlist.spliterator();\n+        }\n+\n+        public <T> T[] toArray(T[] a) {\n+            return rlist.toArray(a);\n+        }\n+\n+        public Object[] toArray() {\n+            return rlist.toArray();\n+        }\n+\n+        public Iterator<E> descendingIterator() {\n+            return rdeque.descendingIterator();\n+        }\n+\n+        public ListIterator<E> listIterator(int index) {\n+            return rlist.listIterator(index);\n+        }\n+\n+        public boolean removeLastOccurrence(Object o) {\n+            return rdeque.removeLastOccurrence(o);\n+        }\n+\n+        public boolean removeFirstOccurrence(Object o) {\n+            return rdeque.removeFirstOccurrence(o);\n+        }\n+\n+        public E pop() {\n+            return rdeque.pop();\n+        }\n+\n+        public void push(E e) {\n+            rdeque.push(e);\n+        }\n+\n+        public E pollLast() {\n+            return rdeque.pollLast();\n+        }\n+\n+        public E pollFirst() {\n+            return rdeque.pollFirst();\n+        }\n+\n+        public E peekLast() {\n+            return rdeque.peekLast();\n+        }\n+\n+        public E peekFirst() {\n+            return rdeque.peekFirst();\n+        }\n+\n+        public boolean offerLast(E e) {\n+            return rdeque.offerLast(e);\n+        }\n+\n+        public boolean offerFirst(E e) {\n+            return rdeque.offerFirst(e);\n+        }\n+\n+        public boolean offer(E e) {\n+            return rdeque.offer(e);\n+        }\n+\n+        public E remove() {\n+            return rdeque.remove();\n+        }\n+\n+        public E poll() {\n+            return rdeque.poll();\n+        }\n+\n+        public E element() {\n+            return rdeque.element();\n+        }\n+\n+        public E peek() {\n+            return rdeque.peek();\n+        }\n+\n+        public int lastIndexOf(Object o) {\n+            return rlist.lastIndexOf(o);\n+        }\n+\n+        public int indexOf(Object o) {\n+            return rlist.indexOf(o);\n+        }\n+\n+        public E remove(int index) {\n+            return rlist.remove(index);\n+        }\n+\n+        public void add(int index, E element) {\n+            rlist.add(index, element);\n+        }\n+\n+        public E set(int index, E element) {\n+            return rlist.set(index, element);\n+        }\n+\n+        public E get(int index) {\n+            return rlist.get(index);\n+        }\n+\n+        public void clear() {\n+            rlist.clear();\n+        }\n+\n+        public boolean addAll(int index, Collection<? extends E> c) {\n+            return rlist.addAll(index, c);\n+        }\n+\n+        public boolean addAll(Collection<? extends E> c) {\n+            return rlist.addAll(c);\n+        }\n+\n+        public boolean remove(Object o) {\n+            return rlist.remove(o);\n+        }\n+\n+        public boolean add(E e) {\n+            return rlist.add(e);\n+        }\n+\n+        public int size() {\n+            return rlist.size();\n+        }\n+\n+        public boolean contains(Object o) {\n+            return rlist.contains(o);\n+        }\n+\n+        public void addLast(E e) {\n+            rdeque.addLast(e);\n+        }\n+\n+        public void addFirst(E e) {\n+            rdeque.addFirst(e);\n+        }\n+\n+        public E removeLast() {\n+            return rdeque.removeLast();\n+        }\n+\n+        public E removeFirst() {\n+            return rdeque.removeFirst();\n+        }\n+\n+        public E getLast() {\n+            return rdeque.getLast();\n+        }\n+\n+        public E getFirst() {\n+            return rdeque.getFirst();\n+        }\n+\n+        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+            throw new java.io.InvalidObjectException(\"not serializable\");\n+        }\n+\n+        public void writeExternal(ObjectOutput out) throws IOException {\n+            throw new java.io.InvalidObjectException(\"not serializable\");\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedList.java","additions":271,"deletions":1,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,4 +31,3 @@\n- * An ordered collection (also known as a <i>sequence<\/i>).  The user of this\n- * interface has precise control over where in the list each element is\n- * inserted.  The user can access elements by their integer index (position in\n- * the list), and search for elements in the list.<p>\n+ * An ordered collection, where the user has precise control over where in the\n+ * list each element is inserted.  The user can access elements by their integer\n+ * index (position in the list), and search for elements in the list.<p>\n@@ -142,1 +141,1 @@\n-public interface List<E> extends Collection<E> {\n+public interface List<E> extends SequencedCollection<E> {\n@@ -784,0 +783,70 @@\n+    \/\/ ========== SequencedCollection ==========\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    default void addFirst(E e) { this.add(0, e); }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    default void addLast(E e) { this.add(e); }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    default E getFirst() {\n+        if (this.isEmpty())\n+            throw new NoSuchElementException();\n+        return this.get(0);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    default E getLast() {\n+        if (this.isEmpty())\n+            throw new NoSuchElementException();\n+        return this.get(this.size()-1);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    default E removeFirst() {\n+        if (this.isEmpty())\n+            throw new NoSuchElementException();\n+        return this.remove(0);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    default E removeLast() {\n+        if (this.isEmpty())\n+            throw new NoSuchElementException();\n+        return this.remove(this.size()-1);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec\n+     * The implementation in this class returns an instance of a reverse-ordered\n+     * List that delegates its operations to this List.\n+     *\n+     * @return a reverse-ordered view of this collection, as a {@code List}\n+     * @since 21\n+     *\/\n+    default List<E> reversed() {\n+        return ReverseOrderListView.of(this, true); \/\/ we must assume it's modifiable\n+    }\n+\n+    \/\/ ========== static methods ==========\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":75,"deletions":6,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -432,0 +432,14 @@\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec\n+     * The implementation in this class returns the result of calling the\n+     * {@link #descendingMap descendingMap} method.\n+     *\n+     * @return a reverse-ordered view of this map, as a {@code NavigableMap}\n+     * @since 21\n+     *\/\n+    default NavigableMap<K, V> reversed() {\n+        return this.descendingMap();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/NavigableMap.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -323,0 +323,16 @@\n+\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * This method is equivalent to {@link #descendingSet descendingSet}.\n+     *\n+     * @implSpec\n+     * The implementation in this class returns the result of calling the\n+     * {@code descendingSet} method.\n+     *\n+     * @return a reverse-ordered view of this collection, as a {@code NavigableSet}\n+     * @since 21\n+     *\/\n+    default NavigableSet<E> reversed() {\n+        return this.descendingSet();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/NavigableSet.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import jdk.internal.util.ArraysSupport;\n+\n+\/**\n+ * Provides a reverse-ordered view of any Deque. Not serializable.\n+ *\/\n+class ReverseOrderDequeView<E> implements Deque<E> {\n+    final Deque<E> base;\n+\n+    ReverseOrderDequeView(Deque<E> deque) {\n+        base = deque;\n+    }\n+\n+    public static <T> Deque<T> of(Deque<T> deque) {\n+        if (deque instanceof ReverseOrderDequeView) {\n+            return ((ReverseOrderDequeView<T>)deque).base;\n+        } else {\n+            return new ReverseOrderDequeView<>(deque);\n+        }\n+    }\n+\n+    \/\/ ========== Iterable ==========\n+\n+    public void forEach(Consumer<? super E> action) {\n+        for (E e : this)\n+            action.accept(e);\n+    }\n+\n+    public Iterator<E> iterator() {\n+        return base.descendingIterator();\n+    }\n+\n+    public Spliterator<E> spliterator() {\n+        return Spliterators.spliteratorUnknownSize(base.descendingIterator(), 0);\n+    }\n+\n+    \/\/ ========== Collection ==========\n+\n+    public boolean add(E e) {\n+        base.addFirst(e);\n+        return true;\n+    }\n+\n+    public boolean addAll(Collection<? extends E> c) {\n+        boolean modified = false;\n+        for (E e : c) {\n+            base.addFirst(e);\n+            modified = true;\n+        }\n+        return modified;\n+    }\n+\n+    public void clear() {\n+        base.clear();\n+    }\n+\n+    public boolean contains(Object o) {\n+        return base.contains(o);\n+    }\n+\n+    public boolean containsAll(Collection<?> c) {\n+        return base.containsAll(c);\n+    }\n+\n+    public boolean isEmpty() {\n+        return base.isEmpty();\n+    }\n+\n+    public Stream<E> parallelStream() {\n+        return StreamSupport.stream(spliterator(), true);\n+    }\n+\n+    \/\/ copied from AbstractCollection\n+    public boolean remove(Object o) {\n+        Iterator<E> it = iterator();\n+        if (o==null) {\n+            while (it.hasNext()) {\n+                if (it.next()==null) {\n+                    it.remove();\n+                    return true;\n+                }\n+            }\n+        } else {\n+            while (it.hasNext()) {\n+                if (o.equals(it.next())) {\n+                    it.remove();\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ copied from AbstractCollection\n+    public boolean removeAll(Collection<?> c) {\n+        Objects.requireNonNull(c);\n+        boolean modified = false;\n+        Iterator<?> it = iterator();\n+        while (it.hasNext()) {\n+            if (c.contains(it.next())) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    \/\/ copied from AbstractCollection\n+    public boolean retainAll(Collection<?> c) {\n+        Objects.requireNonNull(c);\n+        boolean modified = false;\n+        Iterator<E> it = iterator();\n+        while (it.hasNext()) {\n+            if (!c.contains(it.next())) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    public int size() {\n+        return base.size();\n+    }\n+\n+    public Stream<E> stream() {\n+        return StreamSupport.stream(spliterator(), false);\n+    }\n+\n+    public Object[] toArray() {\n+        return ArraysSupport.reverse(base.toArray());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] a) {\n+        \/\/ TODO can probably optimize this\n+        return toArray(i -> (T[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), i));\n+    }\n+\n+    public <T> T[] toArray(IntFunction<T[]> generator) {\n+        return ArraysSupport.reverse(base.toArray(generator));\n+    }\n+\n+    \/\/ copied from AbstractCollection\n+    public String toString() {\n+        Iterator<E> it = iterator();\n+        if (! it.hasNext())\n+            return \"[]\";\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (;;) {\n+            E e = it.next();\n+            sb.append(e == this ? \"(this Collection)\" : e);\n+            if (! it.hasNext())\n+                return sb.append(']').toString();\n+            sb.append(',').append(' ');\n+        }\n+    }\n+\n+    \/\/ ========== Deque and Queue ==========\n+\n+    public void addFirst(E e) {\n+        base.addLast(e);\n+    }\n+\n+    public void addLast(E e) {\n+        base.addFirst(e);\n+    }\n+\n+    public Iterator<E> descendingIterator() {\n+        return base.iterator();\n+    }\n+\n+    public E element() {\n+        return base.getLast();\n+    }\n+\n+    public E getFirst() {\n+        return base.getLast();\n+    }\n+\n+    public E getLast() {\n+        return base.getFirst();\n+    }\n+\n+    public boolean offer(E e) {\n+        return base.offerFirst(e);\n+    }\n+\n+    public boolean offerFirst(E e) {\n+        return base.offerLast(e);\n+    }\n+\n+    public boolean offerLast(E e) {\n+        return base.offerFirst(e);\n+    }\n+\n+    public E peek() {\n+        return base.peekLast();\n+    }\n+\n+    public E peekFirst() {\n+        return base.peekLast();\n+    }\n+\n+    public E peekLast() {\n+        return base.peekFirst();\n+    }\n+\n+    public E poll() {\n+        return base.pollLast();\n+    }\n+\n+    public E pollFirst() {\n+        return base.pollLast();\n+    }\n+\n+    public E pollLast() {\n+        return base.pollFirst();\n+    }\n+\n+    public E pop() {\n+        return base.removeLast();\n+    }\n+\n+    public void push(E e) {\n+        base.addLast(e);\n+    }\n+\n+    public E remove() {\n+        return base.removeLast();\n+    }\n+\n+    public E removeFirst() {\n+        return base.removeLast();\n+    }\n+\n+    public E removeLast() {\n+        return base.removeFirst();\n+    }\n+\n+    public boolean removeFirstOccurrence(Object o) {\n+        return base.removeLastOccurrence(o);\n+    }\n+\n+    public boolean removeLastOccurrence(Object o) {\n+        return base.removeFirstOccurrence(o);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderDequeView.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -0,0 +1,381 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import jdk.internal.util.ArraysSupport;\n+\n+\/**\n+ * Provides a reverse-ordered view of a List. Not serializable.\n+ *\/\n+class ReverseOrderListView<E> implements List<E> {\n+\n+    final List<E> base;\n+    final boolean modifiable;\n+\n+    public static <T> List<T> of(List<T> list, boolean modifiable) {\n+        if (list instanceof ReverseOrderListView) {\n+            return ((ReverseOrderListView<T>)list).base;\n+        } else if (list instanceof RandomAccess) {\n+            return new ReverseOrderListView.Rand<>(list, modifiable);\n+        } else {\n+            return new ReverseOrderListView<>(list, modifiable);\n+        }\n+    }\n+\n+    static class Rand<E> extends ReverseOrderListView<E> implements RandomAccess {\n+        Rand(List<E> list, boolean modifiable) {\n+            super(list, modifiable);\n+        }\n+    }\n+\n+    ReverseOrderListView(List<E> list, boolean modifiable) {\n+        this.base = list;\n+        this.modifiable = modifiable;\n+    }\n+\n+    \/**\n+     * Throws if this list is unmodifiable. This should be called from every mutator\n+     * method. For bulk ops (addAll, removeAll, etc.) this throws unconditionally.\n+     * In contrast, if the base list inherits a bulk op implementation from AbstractList,\n+     * it might not throw if no actual mutation would be attempted (e.g., addAll on an\n+     * empty collection). Arguably calling this is unnecessary for individual ops,\n+     * for which the base list should always throw, but it's easier to verify the right\n+     * behavior if every mutator of this class always checks.\n+     *\/\n+    void checkModifiable() {\n+        if (! modifiable)\n+            throw new UnsupportedOperationException();\n+    }\n+\n+    class DescendingIterator implements Iterator<E> {\n+        final ListIterator<E> it = base.listIterator(base.size());\n+        public boolean hasNext() { return it.hasPrevious(); }\n+        public E next() { return it.previous(); }\n+        public void remove() {\n+            checkModifiable();\n+            it.remove();\n+            \/\/ TODO - make sure ListIterator is positioned correctly afterward\n+        }\n+    }\n+\n+    class DescendingListIterator implements ListIterator<E> {\n+        final ListIterator<E> it;\n+\n+        DescendingListIterator(int size, int pos) {\n+            if (pos < 0 || pos > size)\n+                throw new IndexOutOfBoundsException();\n+            it = base.listIterator(size - pos);\n+        }\n+\n+        public boolean hasNext() {\n+            return it.hasPrevious();\n+        }\n+\n+        public E next() {\n+            return it.previous();\n+        }\n+\n+        public boolean hasPrevious() {\n+            return it.hasNext();\n+        }\n+\n+        public E previous() {\n+            return it.next();\n+        }\n+\n+        public int nextIndex() {\n+            return base.size() - it.nextIndex();\n+        }\n+\n+        public int previousIndex() {\n+            return nextIndex() - 1;\n+        }\n+\n+        public void remove() {\n+            checkModifiable();\n+            it.remove();\n+        }\n+\n+        public void set(E e) {\n+            checkModifiable();\n+            it.set(e);\n+        }\n+\n+        public void add(E e) {\n+            checkModifiable();\n+            it.add(e);\n+            it.previous();\n+        }\n+    }\n+\n+    \/\/ ========== Iterable ==========\n+\n+    public void forEach(Consumer<? super E> action) {\n+        for (E e : this)\n+            action.accept(e);\n+    }\n+\n+    public Iterator<E> iterator() {\n+        return new DescendingIterator();\n+    }\n+\n+    public Spliterator<E> spliterator() {\n+        \/\/ TODO can probably improve this\n+        return Spliterators.spliteratorUnknownSize(new DescendingIterator(), 0);\n+    }\n+\n+    \/\/ ========== Collection ==========\n+\n+    public boolean add(E e) {\n+        checkModifiable();\n+        base.add(0, e);\n+        return true;\n+    }\n+\n+    public boolean addAll(Collection<? extends E> c) {\n+        checkModifiable();\n+        boolean modified = false;\n+        for (E e : c) {\n+            base.add(0, e);\n+            modified = true;\n+        }\n+        return modified;\n+    }\n+\n+    public void clear() {\n+        checkModifiable();\n+        base.clear();\n+    }\n+\n+    public boolean contains(Object o) {\n+        return base.contains(o);\n+    }\n+\n+    public boolean containsAll(Collection<?> c) {\n+        return base.containsAll(c);\n+    }\n+\n+    \/\/ copied from AbstractList\n+    public boolean equals(Object o) {\n+        if (o == this)\n+            return true;\n+        if (!(o instanceof List))\n+            return false;\n+\n+        ListIterator<E> e1 = listIterator();\n+        ListIterator<?> e2 = ((List<?>) o).listIterator();\n+        while (e1.hasNext() && e2.hasNext()) {\n+            E o1 = e1.next();\n+            Object o2 = e2.next();\n+            if (!(o1==null ? o2==null : o1.equals(o2)))\n+                return false;\n+        }\n+        return !(e1.hasNext() || e2.hasNext());\n+    }\n+\n+    \/\/ copied from AbstractList\n+    public int hashCode() {\n+        int hashCode = 1;\n+        for (E e : this)\n+            hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());\n+        return hashCode;\n+    }\n+\n+    public boolean isEmpty() {\n+        return base.isEmpty();\n+    }\n+\n+    public Stream<E> parallelStream() {\n+        return StreamSupport.stream(spliterator(), true);\n+    }\n+\n+    \/\/ copied from AbstractCollection\n+    public boolean remove(Object o) {\n+        checkModifiable();\n+        Iterator<E> it = iterator();\n+        if (o==null) {\n+            while (it.hasNext()) {\n+                if (it.next()==null) {\n+                    it.remove();\n+                    return true;\n+                }\n+            }\n+        } else {\n+            while (it.hasNext()) {\n+                if (o.equals(it.next())) {\n+                    it.remove();\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ copied from AbstractCollection\n+    public boolean removeAll(Collection<?> c) {\n+        checkModifiable();\n+        Objects.requireNonNull(c);\n+        boolean modified = false;\n+        Iterator<?> it = iterator();\n+        while (it.hasNext()) {\n+            if (c.contains(it.next())) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    \/\/ copied from AbstractCollection\n+    public boolean retainAll(Collection<?> c) {\n+        checkModifiable();\n+        Objects.requireNonNull(c);\n+        boolean modified = false;\n+        Iterator<E> it = iterator();\n+        while (it.hasNext()) {\n+            if (!c.contains(it.next())) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    public int size() {\n+        return base.size();\n+    }\n+\n+    public Stream<E> stream() {\n+        return StreamSupport.stream(spliterator(), false);\n+    }\n+\n+    public Object[] toArray() {\n+        return ArraysSupport.reverse(base.toArray());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] a) {\n+        \/\/ TODO can probably optimize this\n+        return toArray(i -> (T[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), i));\n+    }\n+\n+    public <T> T[] toArray(IntFunction<T[]> generator) {\n+        return ArraysSupport.reverse(base.toArray(generator));\n+    }\n+\n+    \/\/ copied from AbstractCollection\n+    public String toString() {\n+        Iterator<E> it = iterator();\n+        if (! it.hasNext())\n+            return \"[]\";\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (;;) {\n+            E e = it.next();\n+            sb.append(e == this ? \"(this Collection)\" : e);\n+            if (! it.hasNext())\n+                return sb.append(']').toString();\n+            sb.append(',').append(' ');\n+        }\n+    }\n+\n+    \/\/ ========== List ==========\n+\n+    public void add(int index, E element) {\n+        checkModifiable();\n+        base.add(base.size() - index, element);\n+    }\n+\n+    public boolean addAll(int index, Collection<? extends E> c) {\n+        checkModifiable();\n+        boolean modified = false;\n+        int i = base.size() - index;\n+        for (E e : c) {\n+            base.add(i, e);\n+            modified = true;\n+        }\n+        return modified;\n+    }\n+\n+    public E get(int i) {\n+        return base.get(base.size() - i - 1);\n+    }\n+\n+    public int indexOf(Object o) {\n+        int i = base.lastIndexOf(o);\n+        return i == -1 ? -1 : base.size() - i - 1;\n+    }\n+\n+    public int lastIndexOf(Object o) {\n+        int i = base.indexOf(o);\n+        return i == -1 ? -1 : base.size() - i - 1;\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return new DescendingListIterator(base.size(), 0);\n+    }\n+\n+    public ListIterator<E> listIterator(int index) {\n+        return new DescendingListIterator(base.size(), index);\n+    }\n+\n+    public E remove(int index) {\n+        checkModifiable();\n+        return base.remove(base.size() - index - 1);\n+    }\n+\n+    public boolean removeIf(Predicate<? super E> filter) {\n+        checkModifiable();\n+        return base.removeIf(filter);\n+    }\n+\n+    public void replaceAll(UnaryOperator<E> operator) {\n+        checkModifiable();\n+        base.replaceAll(operator);\n+    }\n+\n+    public void sort(Comparator<? super E> c) {\n+        checkModifiable();\n+        base.sort(Collections.reverseOrder(c));\n+    }\n+\n+    public E set(int index, E element) {\n+        checkModifiable();\n+        return base.set(base.size() - index - 1, element);\n+    }\n+\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        int size = base.size();\n+        return new ReverseOrderListView<>(base.subList(size - toIndex, size - fromIndex), modifiable);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderListView.java","additions":381,"deletions":0,"binary":false,"changes":381,"status":"added"},{"patch":"@@ -0,0 +1,464 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+\/**\n+ * Provides a reversed-ordered view of a SortedMap. Not serializable.\n+ *\n+ * TODO: copy in equals and hashCode from AbstractMap\n+ *\/\n+class ReverseOrderSortedMapView<K, V> extends AbstractMap<K, V> implements SortedMap<K, V> {\n+    final SortedMap<K, V> base;\n+    final Comparator<? super K> cmp;\n+\n+    ReverseOrderSortedMapView(SortedMap<K, V> map) {\n+        base = map;\n+        cmp = Collections.reverseOrder(map.comparator());\n+    }\n+\n+    public static <K, V> SortedMap<K, V> of(SortedMap<K, V> map) {\n+        if (map instanceof ReverseOrderSortedMapView) {\n+            return ((ReverseOrderSortedMapView<K, V>)map).base;\n+        } else {\n+            return new ReverseOrderSortedMapView<>(map);\n+        }\n+    }\n+\n+    \/\/ ========== Object ==========\n+\n+    \/\/ equals: inherited from AbstractMap\n+\n+    \/\/ hashCode: inherited from AbstractMap\n+\n+    public String toString() {\n+        return toString(this, descendingEntryIterator(base));\n+    }\n+\n+    \/\/ ========== Map ==========\n+\n+    public void clear() {\n+        base.clear();\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        return base.containsKey(key);\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        return base.containsValue(value);\n+    }\n+\n+    public V get(Object key) {\n+        return base.get(key);\n+    }\n+\n+    public boolean isEmpty() {\n+        return base.isEmpty();\n+    }\n+\n+    public V put(K key, V value) {\n+        return base.put(key, value);\n+    }\n+\n+    public void putAll(Map<? extends K, ? extends V> m) {\n+        base.putAll(m);\n+    }\n+\n+    public V remove(Object key) {\n+        return base.remove(key);\n+    }\n+\n+    public int size() {\n+        return base.size();\n+    }\n+\n+    public Set<K> keySet() {\n+        return new AbstractSet<>() {\n+            \/\/ inherit add(), which throws UOE\n+            public Iterator<K> iterator() { return descendingKeyIterator(base); }\n+            public int size() { return base.size(); }\n+        };\n+    }\n+\n+    public Collection<V> values() {\n+        return new AbstractCollection<>() {\n+            \/\/ inherit add(), which throws UOE\n+            public Iterator<V> iterator() { return descendingValueIterator(base); }\n+            public int size() { return base.size(); }\n+        };\n+    }\n+\n+    public Set<Entry<K, V>> entrySet() {\n+        return new AbstractSet<>() {\n+            \/\/ inherit add(), which throws UOE\n+            public Iterator<Entry<K, V>> iterator() { return descendingEntryIterator(base); }\n+            public int size() { return base.size(); }\n+        };\n+    }\n+\n+    \/\/ ========== SequencedMap ==========\n+\n+    public SortedMap<K, V> reversed() {\n+        return base;\n+    }\n+\n+    public K firstKey() {\n+        return base.lastKey();\n+    }\n+\n+    public K lastKey() {\n+        return base.firstKey();\n+    }\n+\n+    public Map.Entry<K, V> firstEntry() {\n+        return base.lastEntry();\n+    }\n+\n+    public Map.Entry<K, V> lastEntry() {\n+        return base.firstEntry();\n+    }\n+\n+    public Map.Entry<K,V> pollFirstEntry() {\n+        return base.pollLastEntry();\n+    }\n+\n+    public Map.Entry<K,V> pollLastEntry() {\n+        return base.pollFirstEntry();\n+    }\n+\n+    public V putFirst(K k, V v) {\n+        return base.putLast(k, v);\n+    }\n+\n+    public V putLast(K k, V v) {\n+        return base.putFirst(k, v);\n+    }\n+\n+    \/\/ ========== SortedMap ==========\n+\n+    public Comparator<? super K> comparator() {\n+        return cmp;\n+    }\n+\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        if (cmp.compare(fromKey, toKey) <= 0) {\n+            return new Submap(fromKey, toKey);\n+        } else {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    public SortedMap<K, V> headMap(K toKey) {\n+        return new Submap(null, toKey);\n+    }\n+\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        return new Submap(fromKey, null);\n+    }\n+\n+    \/\/ ========== Infrastructure ==========\n+\n+    static <K, V> Iterator<K> descendingKeyIterator(SortedMap<K, V> map) {\n+        return new Iterator<>() {\n+            SortedMap<K, V> root = map;\n+            SortedMap<K, V> view = map;\n+            K prev = null;\n+\n+            public boolean hasNext() {\n+                return ! view.isEmpty();\n+            }\n+\n+            public K next() {\n+                if (view.isEmpty())\n+                    throw new NoSuchElementException();\n+                K k = prev = view.lastKey();\n+                view = root.headMap(k);\n+                return k;\n+            }\n+\n+            public void remove() {\n+                if (prev == null) {\n+                    throw new IllegalStateException();\n+                } else {\n+                    root.remove(prev);\n+                    prev = null;\n+                }\n+            }\n+        };\n+    }\n+\n+    static <K, V> Iterator<V> descendingValueIterator(SortedMap<K, V> map) {\n+        return new Iterator<>() {\n+            Iterator<K> keyIterator = descendingKeyIterator(map);\n+\n+            public boolean hasNext() {\n+                return keyIterator.hasNext();\n+            }\n+\n+            public V next() {\n+                return map.get(keyIterator.next());\n+            }\n+\n+            public void remove() {\n+                keyIterator.remove();\n+            }\n+        };\n+    }\n+\n+    static <K, V> Iterator<Map.Entry<K, V>> descendingEntryIterator(SortedMap<K, V> map) {\n+        return new Iterator<>() {\n+            Iterator<K> keyIterator = descendingKeyIterator(map);\n+\n+            public boolean hasNext() {\n+                return keyIterator.hasNext();\n+            }\n+\n+            public Map.Entry<K, V> next() {\n+                K key = keyIterator.next();\n+                return new ViewEntry<>(map, key, map.get(key));\n+            }\n+\n+            public void remove() {\n+                keyIterator.remove();\n+            }\n+        };\n+    }\n+\n+    static class ViewEntry<K, V> implements Map.Entry<K, V> {\n+        final Map<K, V> map;\n+        final K key;\n+        final V value;\n+\n+        ViewEntry(Map<K, V> map, K key, V value) {\n+            this.map = map;\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+        public K getKey()             { return key; }\n+        public V getValue()           { return value; }\n+        public V setValue(V newValue) { return map.put(key, newValue); }\n+\n+        public boolean equals(Object o) {\n+            return o instanceof Map.Entry<?, ?> e\n+                    && Objects.equals(key, e.getKey())\n+                    && Objects.equals(value, e.getValue());\n+        }\n+\n+        public int hashCode() {\n+            return Objects.hashCode(key) ^ Objects.hashCode(value);\n+        }\n+\n+        public String toString() {\n+            return key + \"=\" + value;\n+        }\n+    }\n+\n+    \/\/ copied and modified from AbstractMap\n+    static <K, V> String toString(Map<K, V> thisMap, Iterator<Entry<K,V>> i) {\n+        if (! i.hasNext())\n+            return \"{}\";\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('{');\n+        for (;;) {\n+            Entry<K,V> e = i.next();\n+            K key = e.getKey();\n+            V value = e.getValue();\n+            sb.append(key   == thisMap ? \"(this Map)\" : key);\n+            sb.append('=');\n+            sb.append(value == thisMap ? \"(this Map)\" : value);\n+            if (! i.hasNext())\n+                return sb.append('}').toString();\n+            sb.append(',').append(' ');\n+        }\n+    }\n+\n+    \/**\n+     * Used for various submap views. We can't use the base SortedMap's subMap,\n+     * because of the asymmetry between from-inclusive and to-exclusive.\n+     *\/\n+    class Submap extends AbstractMap<K, V> implements SortedMap<K, V> {\n+        final K head; \/\/ head key, or negative infinity if null\n+        final K tail; \/\/ tail key, or positive infinity if null\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Submap(K head, K tail) {\n+            this.head = head;\n+            this.tail = tail;\n+        }\n+\n+        \/\/ returns whether e is above the head, inclusive\n+        boolean aboveHead(K k) {\n+            return head == null || cmp.compare(k, head) >= 0;\n+        }\n+\n+        \/\/ returns whether e is below the tail, exclusive\n+        boolean belowTail(K k) {\n+            return tail == null || cmp.compare(k, tail) < 0;\n+        }\n+\n+        Iterator<Entry<K, V>> entryIterator() {\n+            return new Iterator<>() {\n+                Entry<K, V> cache = null;\n+                K prevKey = null;\n+                boolean dead = false;\n+                Iterator<Entry<K, V>> it = descendingEntryIterator(base);\n+\n+                public boolean hasNext() {\n+                    if (dead)\n+                        return false;\n+\n+                    if (cache != null)\n+                        return true;\n+\n+                    while (it.hasNext()) {\n+                        Entry<K, V> e = it.next();\n+\n+                        if (! aboveHead(e.getKey()))\n+                            continue;\n+\n+                        if (! belowTail(e.getKey())) {\n+                            dead = true;\n+                            return false;\n+                        }\n+\n+                        cache = e;\n+                        return true;\n+                    }\n+\n+                    return false;\n+                }\n+\n+                public Entry<K, V> next() {\n+                    if (hasNext()) {\n+                        Entry<K, V> e = cache;\n+                        cache = null;\n+                        prevKey = e.getKey();\n+                        return e;\n+                    } else {\n+                        throw new NoSuchElementException();\n+                    }\n+                }\n+\n+                public void remove() {\n+                    if (prevKey == null) {\n+                        throw new IllegalStateException();\n+                    } else {\n+                        base.remove(prevKey);\n+                    }\n+                }\n+            };\n+        }\n+\n+        \/\/ equals: inherited from AbstractMap\n+\n+        \/\/ hashCode: inherited from AbstractMap\n+\n+        public String toString() {\n+            return ReverseOrderSortedMapView.toString(this, entryIterator());\n+        }\n+\n+        public Set<Entry<K, V>> entrySet() {\n+            return new AbstractSet<>() {\n+                public Iterator<Entry<K, V>> iterator() {\n+                    return entryIterator();\n+                }\n+\n+                public int size() {\n+                    int sz = 0;\n+                    for (var it = entryIterator(); it.hasNext();) {\n+                        it.next();\n+                        sz++;\n+                    }\n+                    return sz;\n+                }\n+            };\n+        }\n+\n+        public V put(K key, V value) {\n+            if (aboveHead(key) && belowTail(key))\n+                return base.put(key, value);\n+            else\n+                throw new IllegalArgumentException();\n+        }\n+\n+        public V remove(Object o) {\n+            @SuppressWarnings(\"unchecked\")\n+            K key = (K) o;\n+            if (aboveHead(key) && belowTail(key))\n+                return base.remove(o);\n+            else\n+                return null;\n+        }\n+\n+        public int size() {\n+            return entrySet().size();\n+        }\n+\n+        public Comparator<? super K> comparator() {\n+            return cmp;\n+        }\n+\n+        public K firstKey() {\n+            return this.entryIterator().next().getKey();\n+        }\n+\n+        public K lastKey() {\n+            var it = this.entryIterator();\n+            if (! it.hasNext())\n+                throw new NoSuchElementException();\n+            var last = it.next();\n+            while (it.hasNext())\n+                last = it.next();\n+            return last.getKey();\n+        }\n+\n+        public SortedMap<K, V> subMap(K from, K to) {\n+            if (aboveHead(from) && belowTail(from) &&\n+                aboveHead(to) && belowTail(to) &&\n+                cmp.compare(from, to) <= 0) {\n+                return new Submap(from, to);\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        public SortedMap<K, V> headMap(K to) {\n+            if (aboveHead(to) && belowTail(to))\n+                return new Submap(head, to);\n+            else\n+                throw new IllegalArgumentException();\n+        }\n+\n+        public SortedMap<K, V> tailMap(K from) {\n+            if (aboveHead(from) && belowTail(from))\n+                return new Submap(from, tail);\n+            else\n+                throw new IllegalArgumentException();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderSortedMapView.java","additions":464,"deletions":0,"binary":false,"changes":464,"status":"added"},{"patch":"@@ -0,0 +1,374 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import jdk.internal.util.ArraysSupport;\n+\n+\/**\n+ * Provides a reversed-ordered view of a SortedSet. Not serializable.\n+ *\/\n+class ReverseOrderSortedSetView<E> implements SortedSet<E> {\n+    final SortedSet<E> base;\n+    final Comparator<? super E> comp;\n+\n+    ReverseOrderSortedSetView(SortedSet<E> set) {\n+        base = set;\n+        comp = Collections.reverseOrder(set.comparator());\n+    }\n+\n+    public static <T> SortedSet<T> of(SortedSet<T> set) {\n+        if (set instanceof ReverseOrderSortedSetView) {\n+            return ((ReverseOrderSortedSetView<T>)set).base;\n+        } else {\n+            return new ReverseOrderSortedSetView<>(set);\n+        }\n+    }\n+\n+    \/\/ ========== Object ==========\n+\n+    \/\/ copied from AbstractSet\n+    public boolean equals(Object o) {\n+        if (o == this)\n+            return true;\n+\n+        if (!(o instanceof Set))\n+            return false;\n+        Collection<?> c = (Collection<?>) o;\n+        if (c.size() != size())\n+            return false;\n+        try {\n+            return containsAll(c);\n+        } catch (ClassCastException | NullPointerException unused) {\n+            return false;\n+        }\n+    }\n+\n+    \/\/ copied from AbstractSet\n+    public int hashCode() {\n+        int h = 0;\n+        Iterator<E> i = iterator();\n+        while (i.hasNext()) {\n+            E obj = i.next();\n+            if (obj != null)\n+                h += obj.hashCode();\n+        }\n+        return h;\n+    }\n+\n+    \/\/ copied from AbstractCollection\n+    public String toString() {\n+        Iterator<E> it = iterator();\n+        if (! it.hasNext())\n+            return \"[]\";\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (;;) {\n+            E e = it.next();\n+            sb.append(e == this ? \"(this Collection)\" : e);\n+            if (! it.hasNext())\n+                return sb.append(']').toString();\n+            sb.append(',').append(' ');\n+        }\n+    }\n+\n+    \/\/ ========== Iterable ==========\n+\n+    public void forEach(Consumer<? super E> action) {\n+        for (E e : this)\n+            action.accept(e);\n+    }\n+\n+    public Iterator<E> iterator() {\n+        return descendingIterator(base);\n+    }\n+\n+    public Spliterator<E> spliterator() {\n+        return Spliterators.spliteratorUnknownSize(descendingIterator(base), 0);\n+    }\n+\n+    \/\/ ========== Collection ==========\n+\n+    public boolean add(E e) {\n+        base.add(e);\n+        return true;\n+    }\n+\n+    public boolean addAll(Collection<? extends E> c) {\n+        return base.addAll(c);\n+    }\n+\n+    public void clear() {\n+        base.clear();\n+    }\n+\n+    public boolean contains(Object o) {\n+        return base.contains(o);\n+    }\n+\n+    public boolean containsAll(Collection<?> c) {\n+        return base.containsAll(c);\n+    }\n+\n+    public boolean isEmpty() {\n+        return base.isEmpty();\n+    }\n+\n+    public Stream<E> parallelStream() {\n+        return StreamSupport.stream(spliterator(), true);\n+    }\n+\n+    public boolean remove(Object o) {\n+        return base.remove(o);\n+    }\n+\n+    public boolean removeAll(Collection<?> c) {\n+        return base.removeAll(c);\n+    }\n+\n+    \/\/ copied from AbstractCollection\n+    public boolean retainAll(Collection<?> c) {\n+        return base.retainAll(c);\n+    }\n+\n+    public int size() {\n+        return base.size();\n+    }\n+\n+    public Stream<E> stream() {\n+        return StreamSupport.stream(spliterator(), false);\n+    }\n+\n+    public Object[] toArray() {\n+        return ArraysSupport.reverse(base.toArray());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] a) {\n+        \/\/ TODO can probably optimize this\n+        return toArray(i -> (T[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), i));\n+    }\n+\n+    public <T> T[] toArray(IntFunction<T[]> generator) {\n+        return ArraysSupport.reverse(base.toArray(generator));\n+    }\n+\n+    \/\/ ========== SortedSet ==========\n+\n+    public Comparator<? super E> comparator() {\n+        return comp;\n+    }\n+\n+    public E first() { return base.last(); }\n+\n+    public E last() { return base.first(); }\n+\n+    public SortedSet<E> headSet(E to) {\n+        return new Subset(null, to);\n+    }\n+\n+    public SortedSet<E> subSet(E from, E to) {\n+        return new Subset(from, to);\n+    }\n+\n+    public SortedSet<E> tailSet(E from) {\n+        return new Subset(from, null);\n+    }\n+\n+    \/\/ ========== Infrastructure ==========\n+\n+    static <T> Iterator<T> descendingIterator(SortedSet<T> set) {\n+        return new Iterator<>() {\n+            SortedSet<T> root = set;\n+            SortedSet<T> view = set;\n+            T prev = null;\n+\n+            public boolean hasNext() {\n+                return ! view.isEmpty();\n+            }\n+\n+            public T next() {\n+                if (view.isEmpty())\n+                    throw new NoSuchElementException();\n+                T t = prev = view.last();\n+                view = root.headSet(t);\n+                return t;\n+            }\n+\n+            public void remove() {\n+                if (prev == null) {\n+                    throw new IllegalStateException();\n+                } else {\n+                    root.remove(prev);\n+                    prev = null;\n+                }\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Used for various subset views. We can't use the base SortedSet's subset,\n+     * because of the asymmetry between from-inclusive and to-exclusive.\n+     *\/\n+    class Subset extends AbstractSet<E> implements SortedSet<E> {\n+        final E head; \/\/ head element, or negative infinity if null\n+        final E tail; \/\/ tail element, or positive infinity if null\n+        final Comparator<E> cmp;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Subset(E head, E tail) {\n+            this.head = head;\n+            this.tail = tail;\n+            Comparator<E> c = (Comparator<E>) ReverseOrderSortedSetView.this.comparator();\n+            if (c == null)\n+                c = (Comparator<E>) Comparator.naturalOrder();\n+            cmp = c;\n+        }\n+\n+        \/\/ returns whether e is above the head, inclusive\n+        boolean aboveHead(E e) {\n+            return head == null || cmp.compare(e, head) >= 0;\n+        }\n+\n+        \/\/ returns whether e is below the tail, exclusive\n+        boolean belowTail(E e) {\n+            return tail == null || cmp.compare(e, tail) < 0;\n+        }\n+\n+        public Iterator<E> iterator() {\n+            return new Iterator<>() {\n+                E cache = null;\n+                boolean dead = false;\n+                Iterator<E> it = descendingIterator(base);\n+\n+                public boolean hasNext() {\n+                    if (dead)\n+                        return false;\n+\n+                    if (cache != null)\n+                        return true;\n+\n+                    while (it.hasNext()) {\n+                        E e = it.next();\n+\n+                        if (! aboveHead(e))\n+                            continue;\n+\n+                        if (! belowTail(e)) {\n+                            dead = true;\n+                            return false;\n+                        }\n+\n+                        cache = e;\n+                        return true;\n+                    }\n+\n+                    return false;\n+                }\n+\n+                public E next() {\n+                    if (hasNext()) {\n+                        E e = cache;\n+                        cache = null;\n+                        return e;\n+                    } else {\n+                        throw new NoSuchElementException();\n+                    }\n+                }\n+            };\n+        }\n+\n+        public boolean add(E e) {\n+            if (aboveHead(e) && belowTail(e))\n+                return base.add(e);\n+            else\n+                throw new IllegalArgumentException();\n+        }\n+\n+        public boolean remove(Object o) {\n+            @SuppressWarnings(\"unchecked\")\n+            E e = (E) o;\n+            if (aboveHead(e) && belowTail(e))\n+                return base.remove(o);\n+            else\n+                return false;\n+        }\n+\n+        public int size() {\n+            int sz = 0;\n+            for (E e : this)\n+                sz++;\n+            return sz;\n+        }\n+\n+        public Comparator<? super E> comparator() {\n+            return ReverseOrderSortedSetView.this.comparator();\n+        }\n+\n+        public E first() {\n+            return this.iterator().next();\n+        }\n+\n+        public E last() {\n+            var it = this.iterator();\n+            if (! it.hasNext())\n+                throw new NoSuchElementException();\n+            E last = it.next();\n+            while (it.hasNext())\n+                last = it.next();\n+            return last;\n+        }\n+\n+        public SortedSet<E> subSet(E from, E to) {\n+            if (aboveHead(from) && belowTail(from) &&\n+                aboveHead(to) && belowTail(to) &&\n+                cmp.compare(from, to) <= 0) {\n+                return ReverseOrderSortedSetView.this.new Subset(from, to);\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        public SortedSet<E> headSet(E to) {\n+            if (aboveHead(to) && belowTail(to))\n+                return ReverseOrderSortedSetView.this.new Subset(head, to);\n+            else\n+                throw new IllegalArgumentException();\n+        }\n+\n+        public SortedSet<E> tailSet(E from) {\n+            if (aboveHead(from) && belowTail(from))\n+                return ReverseOrderSortedSetView.this.new Subset(null, tail);\n+            else\n+                throw new IllegalArgumentException();\n+        }\n+\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderSortedSetView.java","additions":374,"deletions":0,"binary":false,"changes":374,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+\/**\n+ * A collection that has a well-defined encounter order, that supports operations at\n+ * both ends, and that is reversible. The elements of a sequenced collection have an\n+ * <i>encounter order<\/i>, where conceptually the elements have a linear arrangement\n+ * from the first element to the last element. Given any two elements, one element is\n+ * either before (closer to the first element) or after (closer to the last element)\n+ * the other element.\n+ * <p>\n+ * (Note that this definition does not imply anything about physical positioning\n+ * of elements, such as their locations in a computer's memory.)\n+ * <p>\n+ * Several methods inherited from the {@link Collection} interface are required to operate\n+ * on elements according to this collection's encounter order. For instance, the\n+ * {@link Collection#iterator iterator} method provides elements starting from the first element,\n+ * proceeding through successive elements, until the last element. Other methods that are\n+ * required to operate on elements in encounter order include the following:\n+ * {@link Iterable#forEach forEach}, {@link Collection#parallelStream parallelStream},\n+ * {@link Collection#spliterator spliterator}, {@link Collection#stream stream},\n+ * and all overloads of the {@link Collection#toArray toArray} method.\n+ * <p>\n+ * This interface provides methods to add elements, to retrieve elements, and to remove\n+ * elements at either end of the collection.\n+ * <p>\n+ * This interface also defines the {@link #reversed reversed} method, which provides\n+ * a reverse-ordered <a href=\"Collection.html#view\">view<\/a> of this collection.\n+ * In the reverse-ordered view, the concepts of first and last are inverted, as are\n+ * the concepts of successor and predecessor. The first element of this collection is\n+ * the last element of the reverse-ordered view, and vice-versa. The successor of some\n+ * element in this collection is its predecessor in the reversed view, and vice-versa. All\n+ * methods that respect the encounter order of the collection operate as if the encounter order\n+ * is inverted. For instance, the {@link #iterator} method of the reversed view reports the\n+ * elements in order from the last element of this collection to the first. The availability of\n+ * the {@code reversed} method, and its impact on the ordering semantics of all applicable\n+ * methods, allow convenient iteration, searching, copying, and streaming of the elements of\n+ * this collection in either forward order or reverse order.\n+ * <p>\n+ * This class is a member of the\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/package-summary.html#CollectionsFramework\">\n+ * Java Collections Framework<\/a>.\n+ *\n+ * @apiNote\n+ * This interface does not impose any requirements on the {@code equals} and {@code hashCode}\n+ * methods, because requirements imposed by sub-interfaces {@link List} and {@link SequencedSet}\n+ * (which inherits requirements from {@link Set}) would be in conflict. See the specifications for\n+ * {@link Collection#equals Collection.equals} and {@link Collection#hashCode Collection.hashCode}\n+ * for further information.\n+ *\n+ * @param <E> the type of elements in this collection\n+ * @since 21\n+ *\/\n+public interface SequencedCollection<E> extends Collection<E> {\n+    \/**\n+     * Returns a reverse-ordered <a href=\"Collection.html#view\">view<\/a> of this collection.\n+     * The encounter order of elements in the returned view is the inverse of the encounter\n+     * order of elements in this collection. The reverse ordering affects all order-sensitive\n+     * operations, including those on the view collections of the returned view. If the collection\n+     * implementation permits modifications to this view, the modifications \"write through\" to the\n+     * underlying collection. Changes to the underlying collection might or might not be visible\n+     * in this reversed view, depending upon the implementation.\n+     *\n+     * @return a reverse-ordered view of this collection\n+     *\/\n+    SequencedCollection<E> reversed();\n+\n+    \/**\n+     * Adds an element as the first element of this collection (optional operation).\n+     * After this operation completes normally, the given element will be a member of\n+     * this collection, and it will be the first element in encounter order.\n+     *\n+     * @implSpec\n+     * The implementation in this class always throws {@code UnsupportedOperationException}.\n+     *\n+     * @param e the element to be added\n+     * @throws NullPointerException if the specified element is null and this\n+     *         collection does not permit null elements\n+     * @throws UnsupportedOperationException if this collection implementation\n+     *         does not support this operation\n+     *\/\n+    default void addFirst(E e) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Adds an element as the last element of this collection (optional operation).\n+     * After this operation completes normally, the given element will be a member of\n+     * this collection, and it will be the last element in encounter order.\n+     *\n+     * @implSpec\n+     * The implementation in this class always throws {@code UnsupportedOperationException}.\n+     *\n+     * @param e the element to be added.\n+     * @throws NullPointerException if the specified element is null and this\n+     *         collection does not permit null elements\n+     * @throws UnsupportedOperationException if this collection implementation\n+     *         does not support this operation\n+     *\/\n+    default void addLast(E e) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Gets the first element of this collection.\n+     *\n+     * @implSpec\n+     * The implementation in this class obtains an iterator of this collection, and\n+     * then it obtains an element by calling the iterator's {@code next} method. Any\n+     * {@code NoSuchElementException} thrown is propagated. Otherwise, it returns\n+     * the element.\n+     *\n+     * @return the retrieved element\n+     * @throws NoSuchElementException if this collection is empty\n+     *\/\n+    default E getFirst() {\n+        return this.iterator().next();\n+    }\n+\n+    \/**\n+     * Gets the last element of this collection.\n+     *\n+     * @implSpec\n+     * The implementation in this class obtains an iterator of the reversed view\n+     * of this collection, and then it obtains an element by calling the iterator's\n+     * {@code next} method. Any {@code NoSuchElementException} thrown is propagated.\n+     * Otherwise, it returns the element.\n+     *\n+     * @return the retrieved element\n+     * @throws NoSuchElementException if this collection is empty\n+     *\/\n+    default E getLast() {\n+        return this.reversed().iterator().next();\n+    }\n+\n+    \/**\n+     * Removes and returns the first element of this collection (optional operation).\n+     *\n+     * @implSpec\n+     * The implementation in this class obtains an iterator of this collection, and then\n+     * it obtains an element by calling the iterator's {@code next} method. Any\n+     * {@code NoSuchElementException} thrown is propagated. It then calls the iterator's\n+     * {@code remove} method. Any {@code UnsupportedOperationException} thrown is propagated.\n+     * Then, it returns the element.\n+     *\n+     * @return the removed element\n+     * @throws NoSuchElementException if this collection is empty\n+     * @throws UnsupportedOperationException if this collection implementation\n+     *         does not support this operation\n+     *\/\n+    default E removeFirst() {\n+        var it = this.iterator();\n+        E e = it.next();\n+        it.remove();\n+        return e;\n+    }\n+\n+    \/**\n+     * Removes and returns the last element of this collection (optional operation).\n+     *\n+     * @implSpec\n+     * The implementation in this class obtains an iterator of the reversed view of this\n+     * collection, and then it obtains an element by calling the iterator's {@code next} method.\n+     * Any {@code NoSuchElementException} thrown is propagated. It then calls the iterator's\n+     * {@code remove} method. Any {@code UnsupportedOperationException} thrown is propagated.\n+     * Then, it returns the element.\n+     *\n+     * @return the removed element\n+     * @throws NoSuchElementException if this collection is empty\n+     * @throws UnsupportedOperationException if this collection implementation\n+     *         does not support this operation\n+     *\/\n+    default E removeLast() {\n+        var it = this.reversed().iterator();\n+        E e = it.next();\n+        it.remove();\n+        return e;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/SequencedCollection.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,333 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+\/**\n+ * A Map that has a well-defined encounter order, that supports operations at both\n+ * ends, and that is reversible. The <i>encounter order<\/i> of a {@code SequencedMap}\n+ * is similar to that of the elements of a {@link SequencedCollection}, but the ordering\n+ * applies to mappings instead of individual elements.\n+ * <p>\n+ * The bulk operations on this map, including the {@link #forEach forEach} and the\n+ * {@link #replaceAll replaceAll} methods, operate on this map's mappings in\n+ * encounter order.\n+ * <p>\n+ * The view collections provided by the\n+ * {@link #keySet keySet},\n+ * {@link #values values},\n+ * {@link #entrySet entrySet},\n+ * {@link #sequencedKeySet sequencedKeySet},\n+ * {@link #sequencedValues sequencedValues},\n+ * and\n+ * {@link #sequencedEntrySet sequencedEntrySet} methods all reflect the encounter order\n+ * of this map. Even though the return values of the\n+ * {@link #keySet keySet},\n+ * {@link #values values}, and\n+ * {@link #entrySet entrySet} methods are not sequenced <i>types<\/i>, the elements\n+ * in those view collections do reflect the encounter order of this map. Thus, the\n+ * iterators returned by the statements\n+ * <pre>{@code\n+ *     var it1 = sequencedMap.entrySet().iterator();\n+ *     var it2 = sequencedMap.sequencedEntrySet().iterator();\n+ * }<\/pre>\n+ * both provide the mappings of {@code sequencedMap} in that map's encounter order.\n+ * <p>\n+ * This interface provides methods to add mappings, to retrieve mappings, and to remove\n+ * mappings at either end of the map's encounter order.\n+ * <p>\n+ * This interface also defines the {@link #reversed} method, which provides a\n+ * reverse-ordered <a href=\"Collection.html#view\">view<\/a> of this map.\n+ * In the reverse-ordered view, the concepts of first and last are inverted, as\n+ * are the concepts of successor and predecessor. The first mapping of this map\n+ * is the last mapping of the reverse-ordered view, and vice-versa. The successor of some\n+ * mapping in this map is its predecessor in the reversed view, and vice-versa. All\n+ * methods that respect the encounter order of the map operate as if the encounter order\n+ * is inverted. For instance, the {@link #forEach forEach} method of the reversed view reports\n+ * the mappings in order from the last mapping of this map to the first. In addition, all of\n+ * the view collections of the reversed view also reflect the inverse of this map's\n+ * encounter order. For example,\n+ * <pre>{@code\n+ *     var itr = sequencedMap.reversed().entrySet().iterator();\n+ * }<\/pre>\n+ * provides the mappings of this map in the inverse of the encounter order, that is, from\n+ * the last mapping to the first mapping. The availability of the {@code reversed} method,\n+ * and its impact on the ordering semantics of all applicable methods and views, allow convenient\n+ * iteration, searching, copying, and streaming of this map's mappings in either forward order or\n+ * reverse order.\n+ * <p>\n+ * A map's reverse-ordered view is generally not serializable, even if the original\n+ * map is serializable.\n+ * <p>\n+ * The {@link Map.Entry} instances obtained by iterating the {@link #entrySet} view, the\n+ * {@link #sequencedEntrySet} view, and its reverse-ordered view, maintain a connection to the\n+ * underlying map. This connection is guaranteed only during the iteration. It is unspecified\n+ * whether the connection is maintained outside of the iteration. If the underlying map permits\n+ * it, calling an Entry's {@link Map.Entry#setValue setValue} method will modify the value of the\n+ * underlying mapping. It is, however, unspecified whether modifications to the value in the\n+ * underlying mapping are visible in the {@code Entry} instance.\n+ * <p>\n+ * The methods\n+ * {@link #firstEntry},\n+ * {@link #lastEntry},\n+ * {@link #pollFirstEntry}, and\n+ * {@link #pollLastEntry}\n+ * return {@link Map.Entry} instances that represent snapshots of mappings as\n+ * of the time of the call. They do <em>not<\/em> support mutation of the\n+ * underlying map via the optional {@link Map.Entry#setValue setValue} method.\n+ * <p>\n+ * Depending upon the implementation, the {@code Entry} instances returned by other\n+ * means might or might not be connected to the underlying map. For example, consider\n+ * an {@code Entry} obtained in the following manner:\n+ * <pre>{@code\n+ *     var entry = sequencedMap.sequencedEntrySet().getFirst();\n+ * }<\/pre>\n+ * It is not specified by this interface whether the {@code setValue} method of the\n+ * {@code Entry} thus obtained will update a mapping in the underlying map, or whether\n+ * it will throw an exception, or whether changes to the underlying map are visible in\n+ * that {@code Entry}.\n+ * <p>\n+ * This interface has the same requirements on the {@code equals} and {@code hashCode}\n+ * methods as defined by {@link Map#equals Map.equals} and {@link Map#hashCode Map.hashCode}.\n+ * Thus, a {@code Map} and a {@code SequencedMap} will compare equals if and only\n+ * if they have equal mappings, irrespective of ordering.\n+ * <p>\n+ * This class is a member of the\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/package-summary.html#CollectionsFramework\">\n+ * Java Collections Framework<\/a>.\n+ *\n+ * @param <K> the type of keys maintained by this map\n+ * @param <V> the type of mapped values\n+ * @since 21\n+ *\/\n+public interface SequencedMap<K, V> extends Map<K, V> {\n+    \/**\n+     * Returns a reverse-ordered <a href=\"Collection.html#view\">view<\/a> of this map.\n+     * The encounter order of elements in the returned view is the inverse of the encounter\n+     * order of elements in this map. The reverse ordering affects all order-sensitive operations,\n+     * including those on the view collections of the returned view. If the implementation permits\n+     * modifications to this view, the modifications \"write through\" to the underlying map.\n+     * Changes to the underlying map might or might not be visible in this reversed view,\n+     * depending upon the implementation.\n+     *\n+     * @return a reverse-ordered view of this map\n+     *\/\n+    SequencedMap<K, V> reversed();\n+\n+    \/**\n+     * Returns the first key-value mapping in this map,\n+     * or {@code null} if the map is empty.\n+     *\n+     * @implSpec\n+     * The implementation in this class obtains the iterator of this map's entrySet.\n+     * If the iterator has an element, it returns an unmodifiable copy of that element.\n+     * Otherwise, it returns null.\n+     *\n+     * @return the first key-value mapping,\n+     *         or {@code null} if this map is empty\n+     *\/\n+    default Map.Entry<K,V> firstEntry() {\n+        var it = entrySet().iterator();\n+        return it.hasNext() ? Map.Entry.copyOf(it.next()) : null;\n+    }\n+\n+    \/**\n+     * Returns the last key-value mapping in this map,\n+     * or {@code null} if the map is empty.\n+     *\n+     * @implSpec\n+     * The implementation in this class obtains the iterator of the entrySet of this map's\n+     * reversed view. If the iterator has an element, it returns an unmodifiable copy of\n+     * that element. Otherwise, it returns null.\n+     *\n+     * @return the last key-value mapping,\n+     *         or {@code null} if this map is empty\n+     *\/\n+    default Map.Entry<K,V> lastEntry() {\n+        var it = reversed().entrySet().iterator();\n+        return it.hasNext() ? Map.Entry.copyOf(it.next()) : null;\n+    }\n+\n+    \/**\n+     * Removes and returns the first key-value mapping in this map,\n+     * or {@code null} if the map is empty (optional operation).\n+     *\n+     * @implSpec\n+     * The implementation in this class obtains the iterator of this map's entrySet.\n+     * If the iterator has an element, it calls {@code remove} on the iterator and\n+     * then returns an unmodifiable copy of that element. Otherwise, it returns null.\n+     *\n+     * @return the removed first entry of this map,\n+     *         or {@code null} if this map is empty\n+     * @throws UnsupportedOperationException if this collection implementation does not\n+     *         support this operation\n+     *\/\n+    default Map.Entry<K,V> pollFirstEntry() {\n+        var it = entrySet().iterator();\n+        if (it.hasNext()) {\n+            var entry = Map.Entry.copyOf(it.next());\n+            it.remove();\n+            return entry;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Removes and returns the last key-value mapping in this map,\n+     * or {@code null} if the map is empty (optional operation).\n+     *\n+     * @implSpec\n+     * The implementation in this class obtains the iterator of the entrySet of this map's\n+     * reversed view. If the iterator has an element, it calls {@code remove} on the iterator\n+     * and then returns an unmodifiable copy of that element. Otherwise, it returns null.\n+     *\n+     * @return the removed last entry of this map,\n+     *         or {@code null} if this map is empty\n+     * @throws UnsupportedOperationException if this collection implementation does not\n+     *         support this operation\n+     *\/\n+    default Map.Entry<K,V> pollLastEntry() {\n+        var it = reversed().entrySet().iterator();\n+        if (it.hasNext()) {\n+            var entry = Map.Entry.copyOf(it.next());\n+            it.remove();\n+            return entry;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Inserts the given mapping into the map if it is not already present, or replaces the\n+     * value of a mapping if it is already present (optional operation). After this operation\n+     * completes normally, the given mapping will be present in this map, and it will be the\n+     * first mapping in this map's encounter order.\n+     *\n+     * @implSpec The implementation in this class always throws\n+     * {@code UnsupportedOperationException}.\n+     *\n+     * @param k the key\n+     * @param v the value\n+     * @return the value previously associated with k, or null if none\n+     * @throws UnsupportedOperationException if this collection implementation does not\n+     *         support this operation\n+     *\/\n+    default V putFirst(K k, V v) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Inserts the given mapping into the map if it is not already present, or replaces the\n+     * value of a mapping if it is already present (optional operation). After this operation\n+     * completes normally, the given mapping will be present in this map, and it will be the\n+     * last mapping in this map's encounter order.\n+     *\n+     * @implSpec The implementation in this class always throws\n+     * {@code UnsupportedOperationException}.\n+     *\n+     * @param k the key\n+     * @param v the value\n+     * @return the value previously associated with k, or null if none\n+     * @throws UnsupportedOperationException if this collection implementation does not\n+     *         support this operation\n+     *\/\n+    default V putLast(K k, V v) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Returns a {@link SequencedSet} view of this map's keySet.\n+     *\n+     * @implSpec\n+     * The implementation of this method in this class returns a {@code SequencedSet}\n+     * implementation that delegates all operations either to this map or to this map's\n+     * {@link #keySet}, except for its {@link SequencedSet#reversed reversed} method,\n+     * which instead returns the result of calling {@code sequencedKeySet} on this map's\n+     * reverse-ordered view.\n+     *\n+     * @return a SequencedSet view of this map's keySet\n+     *\/\n+    default SequencedSet<K> sequencedKeySet() {\n+        class SeqKeySet extends AbstractMap.ViewCollection<K> implements SequencedSet<K> {\n+            SeqKeySet() {\n+                super(SequencedMap.this.keySet());\n+            }\n+            public SequencedSet<K> reversed() {\n+                return SequencedMap.this.reversed().sequencedKeySet();\n+            }\n+        }\n+        return new SeqKeySet();\n+    }\n+\n+    \/**\n+     * Returns a {@link SequencedCollection} view of this map's values collection.\n+     *\n+     * @implSpec\n+     * The implementation of this method in this class returns a {@code SequencedCollection}\n+     * implementation that delegates all operations either to this map or to this map's\n+     * {@link #values} collection, except for its {@link SequencedCollection#reversed reversed}\n+     * method, which instead returns the result of calling {@code sequencedValues} on this map's\n+     * reverse-ordered view.\n+     *\n+     * @return a SequencedCollection view of this map's values collection\n+     *\/\n+    default SequencedCollection<V> sequencedValues() {\n+        class SeqValues extends AbstractMap.ViewCollection<V> implements SequencedCollection<V> {\n+            SeqValues() {\n+                super(SequencedMap.this.values());\n+            }\n+            public SequencedCollection<V> reversed() {\n+                return SequencedMap.this.reversed().sequencedValues();\n+            }\n+        }\n+        return new SeqValues();\n+    }\n+\n+    \/**\n+     * Returns a {@link SequencedSet} view of this map's entrySet.\n+     *\n+     * @implSpec\n+     * The implementation of this method in this class returns a {@code SequencedSet}\n+     * implementation that delegates all operations either to this map or to this map's\n+     * {@link #entrySet}, except for its {@link SequencedSet#reversed reversed} method,\n+     * which instead returns the result of calling {@code sequencedEntrySet} on this map's\n+     * reverse-ordered view.\n+     *\n+     * @return a SequencedSet view of this map's entrySet\n+     *\/\n+    default SequencedSet<Map.Entry<K, V>> sequencedEntrySet() {\n+        class SeqEntrySet extends AbstractMap.ViewCollection<Map.Entry<K, V>>\n+                implements SequencedSet<Map.Entry<K, V>> {\n+            SeqEntrySet() {\n+                super(SequencedMap.this.entrySet());\n+            }\n+            public SequencedSet<Map.Entry<K, V>> reversed() {\n+                return SequencedMap.this.reversed().sequencedEntrySet();\n+            }\n+        }\n+        return new SeqEntrySet();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/SequencedMap.java","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+\/**\n+ * A collection that is both a {@link SequencedCollection} and a {@link Set}. As such, it can be\n+ * thought of as either as a {@code Set} that also has a well-defined encounter order, or as a\n+ * {@code SequencedCollection} that also has unique elements.\n+ * <p>\n+ * This interface has the same requirements on the {@code equals} and {@code hashCode}\n+ * methods as defined by {@link Set#equals Set.equals} and {@link Set#hashCode Set.hashCode}.\n+ * Thus, a {@code Set} and a {@code SequencedSet} will compare equals if and only\n+ * if they have equal elements, irrespective of ordering.\n+ * <p>\n+ * {@code SequencedSet} defines the {@link #reversed} method, which provides a\n+ * reverse-ordered <a href=\"Collection.html#view\">view<\/a> of this set. The only difference\n+ * from the {@link SequencedCollection#reversed SequencedCollection.reversed} method is\n+ * that the return type of {@code SequencedSet.reversed} is {@code SequencedSet}.\n+ * <p>\n+ * This class is a member of the\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/package-summary.html#CollectionsFramework\">\n+ * Java Collections Framework<\/a>.\n+ *\n+ * @param <E> the type of elements in this sequenced set\n+ * @since 21\n+ *\/\n+public interface SequencedSet<E> extends SequencedCollection<E>, Set<E> {\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @return a reverse-ordered view of this collection, as a {@code SequencedSet}\n+     *\/\n+    SequencedSet<E> reversed();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/SequencedSet.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-public interface SortedMap<K,V> extends Map<K,V> {\n+public interface SortedMap<K,V> extends SequencedMap<K,V> {\n@@ -284,0 +284,44 @@\n+\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * map's comparison method determines the position of mappings, so explicit positioning\n+     * is not supported.\n+     *\n+     * @implSpec\n+     * The implementation in this class always throws {@code UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+     default V putFirst(K k, V v) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * map's comparison method determines the position of mappings, so explicit positioning\n+     * is not supported.\n+     *\n+     * @implSpec\n+     * The implementation in this class always throws {@code UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+    default V putLast(K k, V v) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec\n+     * The implementation in this class returns an instance of a reverse-ordered\n+     * SortedMap that delegates its operations to this SortedMap.\n+     *\n+     * @return a reverse-ordered view of this map, as a {@code SortedMap}\n+     * @since 21\n+     *\/\n+    default SortedMap<K, V> reversed() {\n+        return ReverseOrderSortedMapView.of(this);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/SortedMap.java","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-public interface SortedSet<E> extends Set<E> {\n+public interface SortedSet<E> extends Set<E>, SequencedSet<E> {\n@@ -264,0 +264,74 @@\n+\n+    \/\/ ========== SequencedCollection ==========\n+\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * set's comparison method determines the position of elements, so explicit positioning\n+     * is not supported.\n+     *\n+     * @implSpec\n+     * The implementation in this class always throws {@code UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+    default void addFirst(E e) { throw new UnsupportedOperationException(); }\n+\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * set's comparison method determines the position of elements, so explicit positioning\n+     * is not supported.\n+     *\n+     * @implSpec\n+     * The implementation in this class always throws {@code UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+    default void addLast(E e) { throw new UnsupportedOperationException(); }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    default E getFirst() { return this.first(); }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    default E getLast() { return this.last(); }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    default E removeFirst() {\n+        E e = this.first();\n+        this.remove(e);\n+        return e;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 21\n+     *\/\n+    default E removeLast() {\n+        E e = this.last();\n+        this.remove(e);\n+        return e;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec\n+     * The implementation in this class returns an instance of a reverse-ordered\n+     * SortedSet that delegates its operations to this SortedSet.\n+     *\n+     * @return a reverse-ordered view of this collection, as a {@code SortedSet}\n+     * @since 21\n+     *\/\n+    default SortedSet<E> reversed() {\n+        return ReverseOrderSortedSetView.of(this);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/SortedSet.java","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,4 @@\n+ * <p>The {@link #putFirst putFirst} and {@link #putLast putLast} methods of this class\n+ * throw {@code UnsupportedOperationException}. The encounter order of mappings is determined\n+ * by the comparison method; therefore, explicit positioning is not supported.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/util\/TreeMap.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,4 @@\n+ * <p>The {@link #addFirst addFirst} and {@link #addLast addLast} methods of this class\n+ * throw {@code UnsupportedOperationException}. The encounter order of elements is determined\n+ * by the comparison method; therefore, explicit positioning is not supported.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/util\/TreeSet.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Collections;\n@@ -53,0 +54,1 @@\n+import java.util.function.IntFunction;\n@@ -55,0 +57,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -56,0 +60,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -401,0 +406,22 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public E getFirst() {\n+        Object[] es = getArray();\n+        if (es.length == 0)\n+            throw new NoSuchElementException();\n+        else\n+            return elementAt(es, 0);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public E getLast() {\n+        Object[] es = getArray();\n+        if (es.length == 0)\n+            throw new NoSuchElementException();\n+        else\n+            return elementAt(es, es.length - 1);\n+    }\n+\n@@ -467,0 +494,16 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public void addFirst(E e) {\n+        add(0, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public void addLast(E e) {\n+        synchronized (lock) {\n+            add(getArray().length, e);\n+        }\n+    }\n+\n@@ -494,0 +537,25 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public E removeFirst() {\n+        synchronized (lock) {\n+            if (getArray().length == 0)\n+                throw new NoSuchElementException();\n+            else\n+                return remove(0);\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public E removeLast() {\n+        synchronized (lock) {\n+            int size = getArray().length;\n+            if (size == 0)\n+                throw new NoSuchElementException();\n+            else\n+                return remove(size - 1);\n+        }\n+    }\n+\n@@ -1361,0 +1429,18 @@\n+        public E getFirst() {\n+            synchronized (lock) {\n+                if (size == 0)\n+                    throw new NoSuchElementException();\n+                else\n+                    return get(0);\n+            }\n+        }\n+\n+        public E getLast() {\n+            synchronized (lock) {\n+                if (size == 0)\n+                    throw new NoSuchElementException();\n+                else\n+                    return get(size - 1);\n+            }\n+        }\n+\n@@ -1388,0 +1474,10 @@\n+        public void addFirst(E e) {\n+            add(0, e);\n+        }\n+\n+        public void addLast(E e) {\n+            synchronized (lock) {\n+                add(size, e);\n+            }\n+        }\n+\n@@ -1429,0 +1525,18 @@\n+        public E removeFirst() {\n+            synchronized (lock) {\n+                if (size == 0)\n+                    throw new NoSuchElementException();\n+                else\n+                    return remove(0);\n+            }\n+        }\n+\n+        public E removeLast() {\n+            synchronized (lock) {\n+                if (size == 0)\n+                    throw new NoSuchElementException();\n+                else\n+                    return remove(size - 1);\n+            }\n+        }\n+\n@@ -1527,0 +1641,3 @@\n+        public List<E> reversed() {\n+            return new Reversed<>(this, lock);\n+        }\n@@ -1592,0 +1709,357 @@\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * Modifications to the reversed view are permitted and will be propagated\n+     * to this list. In addition, modifications to this list will be visible\n+     * in the reversed view. Sublists and iterators of the reversed view have\n+     * the same restrictions as those of this list.\n+     *\/\n+    public List<E> reversed() {\n+        return new Reversed<>(this, lock);\n+    }\n+\n+    \/**\n+     * Reversed view for CopyOnWriteArrayList and its sublists.\n+     *\/\n+    private static class Reversed<E> implements List<E>, RandomAccess {\n+        final List<E> base;\n+        final Object lock;\n+\n+        Reversed(List<E> base, Object lock) {\n+            this.base = base;\n+            this.lock = lock;\n+        }\n+\n+        class DescendingIterator implements Iterator<E> {\n+            final ListIterator<E> it;\n+            DescendingIterator() {\n+                synchronized (lock) {\n+                    it = base.listIterator(base.size());\n+                }\n+            }\n+            public boolean hasNext() { return it.hasPrevious(); }\n+            public E next() { return it.previous(); }\n+            public void remove() { it.remove(); }\n+        }\n+\n+        class DescendingListIterator implements ListIterator<E> {\n+            final ListIterator<E> it;\n+            final int size; \/\/ iterator holds a snapshot of the array so this is constant\n+\n+            DescendingListIterator(int pos) {\n+                synchronized (lock) {\n+                    size = base.size();\n+                    if (pos < 0 || pos > size)\n+                        throw new IndexOutOfBoundsException();\n+                    it = base.listIterator(size - pos);\n+                }\n+            }\n+\n+            public boolean hasNext() {\n+                return it.hasPrevious();\n+            }\n+\n+            public E next() {\n+                return it.previous();\n+            }\n+\n+            public boolean hasPrevious() {\n+                return it.hasNext();\n+            }\n+\n+            public E previous() {\n+                return it.next();\n+            }\n+\n+            public int nextIndex() {\n+                return size - it.nextIndex();\n+            }\n+\n+            public int previousIndex() {\n+                return nextIndex() - 1;\n+            }\n+\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            public void set(E e) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            public void add(E e) {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        \/\/ ========== Iterable ==========\n+\n+        public void forEach(Consumer<? super E> action) {\n+            for (E e : this)\n+                action.accept(e);\n+        }\n+\n+        public Iterator<E> iterator() {\n+            return new DescendingIterator();\n+        }\n+\n+        public Spliterator<E> spliterator() {\n+            \/\/ TODO can probably improve this\n+            return Spliterators.spliteratorUnknownSize(new DescendingIterator(), 0);\n+        }\n+\n+        \/\/ ========== Collection ==========\n+\n+        public boolean add(E e) {\n+            base.add(0, e);\n+            return true;\n+        }\n+\n+        public boolean addAll(Collection<? extends E> c) {\n+            @SuppressWarnings(\"unchecked\")\n+            E[] es = (E[]) c.toArray();\n+            if (es.length > 0) {\n+                ArraysSupport.reverse(es);\n+                base.addAll(0, Arrays.asList(es));\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        public void clear() {\n+            base.clear();\n+        }\n+\n+        public boolean contains(Object o) {\n+            return base.contains(o);\n+        }\n+\n+        public boolean containsAll(Collection<?> c) {\n+            return base.containsAll(c);\n+        }\n+\n+        \/\/ copied from AbstractList\n+        public boolean equals(Object o) {\n+            if (o == this)\n+                return true;\n+            if (!(o instanceof List))\n+                return false;\n+\n+            ListIterator<E> e1 = listIterator();\n+            ListIterator<?> e2 = ((List<?>) o).listIterator();\n+            while (e1.hasNext() && e2.hasNext()) {\n+                E o1 = e1.next();\n+                Object o2 = e2.next();\n+                if (!(o1==null ? o2==null : o1.equals(o2)))\n+                    return false;\n+            }\n+            return !(e1.hasNext() || e2.hasNext());\n+        }\n+\n+        \/\/ copied from AbstractList\n+        public int hashCode() {\n+            int hashCode = 1;\n+            for (E e : this)\n+                hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());\n+            return hashCode;\n+        }\n+\n+        public boolean isEmpty() {\n+            return base.isEmpty();\n+        }\n+\n+        public Stream<E> parallelStream() {\n+            return StreamSupport.stream(spliterator(), true);\n+        }\n+\n+        public boolean remove(Object o) {\n+            synchronized (lock) {\n+                int index = indexOf(o);\n+                if (index == -1)\n+                    return false;\n+                remove(index);\n+                return true;\n+            }\n+        }\n+\n+        public boolean removeAll(Collection<?> c) {\n+            return base.removeAll(c);\n+        }\n+\n+        public boolean retainAll(Collection<?> c) {\n+            return base.retainAll(c);\n+        }\n+\n+        public int size() {\n+            return base.size();\n+        }\n+\n+        public Stream<E> stream() {\n+            return StreamSupport.stream(spliterator(), false);\n+        }\n+\n+        public Object[] toArray() {\n+            return ArraysSupport.reverse(base.toArray());\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] a) {\n+            \/\/ TODO optimize this\n+            return toArray(i -> (T[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), i));\n+        }\n+\n+        public <T> T[] toArray(IntFunction<T[]> generator) {\n+            return ArraysSupport.reverse(base.toArray(generator));\n+        }\n+\n+        \/\/ copied from AbstractCollection\n+        public String toString() {\n+            Iterator<E> it = iterator();\n+            if (! it.hasNext())\n+                return \"[]\";\n+\n+            StringBuilder sb = new StringBuilder();\n+            sb.append('[');\n+            for (;;) {\n+                E e = it.next();\n+                sb.append(e == this ? \"(this Collection)\" : e);\n+                if (! it.hasNext())\n+                    return sb.append(']').toString();\n+                sb.append(',').append(' ');\n+            }\n+        }\n+\n+        \/\/ ========== List ==========\n+\n+        public void add(int index, E element) {\n+            synchronized (lock) {\n+                base.add(base.size() - index, element);\n+            }\n+        }\n+\n+        public void addFirst(E e) {\n+            base.add(e);\n+        }\n+\n+        public void addLast(E e) {\n+            base.add(0, e);\n+        }\n+\n+        public boolean addAll(int index, Collection<? extends E> c) {\n+            @SuppressWarnings(\"unchecked\")\n+            E[] es = (E[]) c.toArray();\n+            if (es.length > 0) {\n+                ArraysSupport.reverse(es);\n+                synchronized (lock) {\n+                    base.addAll(base.size() - index, Arrays.asList(es));\n+                }\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        public E get(int i) {\n+            synchronized (lock) {\n+                return base.get(base.size() - i - 1);\n+            }\n+        }\n+\n+        public E getFirst() {\n+            synchronized (lock) {\n+                int size = base.size();\n+                if (size == 0)\n+                    throw new NoSuchElementException();\n+                else\n+                    return base.get(size - 1);\n+            }\n+        }\n+\n+        public E getLast() {\n+            synchronized (lock) {\n+                if (base.size() == 0)\n+                    throw new NoSuchElementException();\n+                else\n+                    return base.get(0);\n+            }\n+        }\n+\n+        public int indexOf(Object o) {\n+            synchronized (lock) {\n+                int i = base.lastIndexOf(o);\n+                return i == -1 ? -1 : base.size() - i - 1;\n+            }\n+        }\n+\n+        public int lastIndexOf(Object o) {\n+            synchronized (lock) {\n+                int i = base.indexOf(o);\n+                return i == -1 ? -1 : base.size() - i - 1;\n+            }\n+        }\n+\n+        public ListIterator<E> listIterator() {\n+            return new DescendingListIterator(0);\n+        }\n+\n+        public ListIterator<E> listIterator(int index) {\n+            return new DescendingListIterator(index);\n+        }\n+\n+        public E remove(int index) {\n+            synchronized (lock) {\n+                return base.remove(base.size() - index - 1);\n+            }\n+        }\n+\n+        public E removeFirst() {\n+            synchronized (lock) {\n+                int size = base.size();\n+                if (size == 0)\n+                    throw new NoSuchElementException();\n+                else\n+                    return base.remove(size - 1);\n+            }\n+        }\n+\n+        public E removeLast() {\n+            synchronized (lock) {\n+                if (base.size() == 0)\n+                    throw new NoSuchElementException();\n+                else\n+                    return base.remove(0);\n+            }\n+        }\n+\n+        public boolean removeIf(Predicate<? super E> filter) {\n+            return base.removeIf(filter);\n+        }\n+\n+        public void replaceAll(UnaryOperator<E> operator) {\n+            base.replaceAll(operator);\n+        }\n+\n+        public void sort(Comparator<? super E> c) {\n+            base.sort(Collections.reverseOrder(c));\n+        }\n+\n+        public E set(int index, E element) {\n+            synchronized (lock) {\n+                return base.set(base.size() - index - 1, element);\n+            }\n+        }\n+\n+        public List<E> subList(int fromIndex, int toIndex) {\n+            synchronized (lock) {\n+                int size = base.size();\n+                var sub = base.subList(size - toIndex, size - fromIndex);\n+                return new Reversed<>(sub, lock);\n+            }\n+        }\n+\n+        public List<E> reversed() {\n+            return base;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArrayList.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"modified"},{"patch":"@@ -758,0 +758,17 @@\n+\n+    \/**\n+     * Reverses the elements of an array in-place.\n+     *\n+     * @param <T> the array component type\n+     * @param a the array to be reversed\n+     * @return the reversed array, always the same array as the argument\n+     *\/\n+    public static <T> T[] reverse(T[] a) {\n+        int limit = a.length \/ 2;\n+        for (int i = 0, j = a.length - 1; i < limit; i++, j--) {\n+            T t = a[i];\n+            a[i] = a[j];\n+            a[j] = t;\n+        }\n+        return a;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ArraysSupport.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+    java\/util\/SequencedCollection \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-        testImmutableSet(unmodifiableSet(new HashSet<>(Arrays.asList(1,2,3))));\n+        testImmutableSet(unmodifiableSet(new HashSet<>(Arrays.asList(1,2,3))), 99);\n@@ -143,0 +143,4 @@\n+        testImmutableSeqColl(unmodifiableSequencedCollection(Arrays.asList(1,2,3)), 99);\n+        testImmutableSeqColl(unmodifiableSequencedSet(new LinkedHashSet<>(Arrays.asList(1,2,3))), 99);\n+        var lhm = new LinkedHashMap<Integer,Integer>(); lhm.put(1,2); lhm.put(3, 4);\n+        testImmutableSeqMap(unmodifiableSequencedMap(lhm));\n@@ -172,1 +176,1 @@\n-        testImmutableSet(emptySet);\n+        testImmutableSet(emptySet, 99);\n@@ -197,1 +201,1 @@\n-        testImmutableSet(singletonSet);\n+        testImmutableSet(singletonSet, 99);\n@@ -325,1 +329,1 @@\n-            testImmutableSet(set);\n+            testImmutableSet(set, 99);\n@@ -331,1 +335,1 @@\n-        testImmutableSet(setCopy);\n+        testImmutableSet(setCopy, 99);\n@@ -338,1 +342,1 @@\n-        testImmutableSet(setCollected);\n+        testImmutableSet(setCollected, 99);\n@@ -465,1 +469,1 @@\n-    private static void testImmutableCollection(final Collection<Integer> c) {\n+    private static <T> void testImmutableCollection(final Collection<T> c, T t) {\n@@ -467,2 +471,2 @@\n-               () -> c.add(99),\n-               () -> c.addAll(singleton(99)));\n+               () -> c.add(t),\n+               () -> c.addAll(singleton(t)));\n@@ -470,1 +474,1 @@\n-            final Integer first = c.iterator().next();\n+            final T first = c.iterator().next();\n@@ -479,2 +483,24 @@\n-    private static void testImmutableSet(final Set<Integer> c) {\n-        testImmutableCollection(c);\n+    private static <T> void testImmutableSeqColl(final SequencedCollection<T> c, T t) {\n+        SequencedCollection<T> r = c.reversed();\n+        testImmutableCollection(c, t);\n+        testImmutableCollection(r, t);\n+        THROWS(UnsupportedOperationException.class,\n+               () -> c.addFirst(t),\n+               () -> c.addLast(t),\n+               () -> r.addFirst(t),\n+               () -> r.addLast(t));\n+        if (! c.isEmpty()) {\n+            THROWS(UnsupportedOperationException.class,\n+                   () -> c.removeFirst(),\n+                   () -> c.removeLast(),\n+                   () -> r.removeFirst(),\n+                   () -> r.removeLast());\n+        }\n+    }\n+\n+    private static <T> void testImmutableSet(final Set<T> c, T t) {\n+        testImmutableCollection(c, t);\n+    }\n+\n+    private static <T> void testImmutableSeqSet(final SequencedSet<T> c, T t) {\n+        testImmutableSeqColl(c, t);\n@@ -485,1 +511,2 @@\n-        testImmutableCollection(c);\n+        testImmutableCollection(c, 42);\n+        testImmutableSeqColl(c, 42);\n@@ -609,0 +636,9 @@\n+    private static void testImmutableMapEntry(final Map.Entry<Integer,Integer> me) {\n+        Integer key = me.getKey();\n+        Integer val = me.getValue();\n+        THROWS(UnsupportedOperationException.class,\n+               () -> me.setValue(3));\n+        equal(key, me.getKey());\n+        equal(val, me.getValue());\n+    }\n+\n@@ -618,4 +654,17 @@\n-            final Map.Entry<Integer,Integer> me\n-                = m.entrySet().iterator().next();\n-            Integer key = me.getKey();\n-            Integer val = me.getValue();\n+            testImmutableMapEntry(m.entrySet().iterator().next());\n+        }\n+        testImmutableSet(m.keySet(), 99);\n+        testImmutableCollection(m.values(), 99);\n+        testImmutableSet(m.entrySet(), Map.entry(42, 43));\n+    }\n+\n+    private static void testImmutableSeqMap(final SequencedMap<Integer,Integer> m) {\n+        SequencedMap<Integer,Integer> r = m.reversed();\n+        testImmutableMap(m);\n+        testImmutableMap(r);\n+        THROWS(UnsupportedOperationException.class,\n+               () -> m.putFirst(0, 0),\n+               () -> m.putLast(0, 0),\n+               () -> r.putFirst(0, 0),\n+               () -> r.putLast(0, 0));\n+        if (! m.isEmpty()) {\n@@ -623,3 +672,8 @@\n-                   () -> me.setValue(3));\n-            equal(key, me.getKey());\n-            equal(val, me.getValue());\n+                   () -> m.pollFirstEntry(),\n+                   () -> m.pollLastEntry(),\n+                   () -> r.pollFirstEntry(),\n+                   () -> r.pollLastEntry());\n+            testImmutableMapEntry(m.sequencedEntrySet().getFirst());\n+            testImmutableMapEntry(r.sequencedEntrySet().getFirst());\n+            testImmutableMapEntry(m.sequencedEntrySet().reversed().getFirst());\n+            testImmutableMapEntry(r.sequencedEntrySet().reversed().getFirst());\n@@ -627,3 +681,6 @@\n-        testImmutableSet(m.keySet());\n-        testImmutableCollection(m.values());\n-        \/\/testImmutableSet(m.entrySet());\n+        testImmutableSeqSet(m.sequencedKeySet(), 99);\n+        testImmutableSeqColl(m.sequencedValues(), 99);\n+        testImmutableSeqSet(m.sequencedEntrySet(), Map.entry(42, 43));\n+        testImmutableSeqSet(r.sequencedKeySet(), 99);\n+        testImmutableSeqColl(r.sequencedValues(), 99);\n+        testImmutableSeqSet(r.sequencedEntrySet(), Map.entry(42, 43));\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":81,"deletions":24,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.Objects;\n@@ -43,1 +42,1 @@\n-import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n@@ -69,0 +68,1 @@\n+        cases.add(new Object[] { Collections.unmodifiableSequencedCollection(seedList) });\n@@ -72,0 +72,1 @@\n+        cases.add(new Object[] { Collections.unmodifiableSequencedSet(seedSet) });\n@@ -80,0 +81,18 @@\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).entrySet() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).keySet() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).values() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().entrySet() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().keySet() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().values() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedEntrySet() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedKeySet() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedValues() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedEntrySet().reversed() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedKeySet().reversed() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedValues().reversed() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedEntrySet() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedKeySet() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedValues() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedEntrySet().reversed() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedKeySet().reversed() });\n+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedValues().reversed() });\n@@ -139,0 +158,1 @@\n+        var notOverridden = new ArrayList<Method>();\n@@ -141,2 +161,3 @@\n-            \/\/ default had been override\n-            assertFalse(m2.isDefault(), cls.getCanonicalName());\n+            if (m2.isDefault()) {\n+                notOverridden.add(m);\n+            }\n@@ -144,0 +165,1 @@\n+        assertTrue(notOverridden.isEmpty(), cls.getName() + \" does not override \" + notOverridden);\n","filename":"test\/jdk\/java\/util\/Collections\/Wrappers.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,834 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertSame;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug     8266571\n+ * @summary Basic tests for SequencedCollection\n+ * @modules java.base\/java.util:open\n+ * @build   SimpleDeque SimpleList SimpleSortedSet\n+ * @run     testng Basic\n+ *\/\n+\n+\/\/ TODO test that remove(obj) with duplicates removes the right element\n+\n+public class Basic {\n+\n+    \/\/ ========== Data Providers ==========\n+\n+    static final List<String> ORIGINAL = List.of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\");\n+\n+    static List<String> cklist(List<String> contents) {\n+        return Collections.checkedList(contents, String.class);\n+    }\n+\n+    static NavigableSet<String> cknav(NavigableSet<String> set) {\n+        return Collections.checkedNavigableSet(set, String.class);\n+    }\n+\n+    static SortedSet<String> cksorted(SortedSet<String> set) {\n+        return Collections.checkedSortedSet(set, String.class);\n+    }\n+\n+    static SequencedSet<String> setFromMap(List<String> contents) {\n+        var lhm = new LinkedHashMap<String, Boolean>();\n+        var ss = Collections.newSequencedSetFromMap(lhm);\n+        ss.addAll(contents);\n+        return ss;\n+    }\n+\n+    static SequencedCollection<String> ucoll(SequencedCollection<String> coll) {\n+        return Collections.unmodifiableSequencedCollection(coll);\n+    }\n+\n+    static SequencedCollection<String> ulist(List<String> list) {\n+        return Collections.unmodifiableList(list);\n+    }\n+\n+    static NavigableSet<String> unav(NavigableSet<String> set) {\n+        return Collections.unmodifiableNavigableSet(set);\n+    }\n+\n+    static SequencedSet<String> uset(SequencedSet<String> set) {\n+        return Collections.unmodifiableSequencedSet(set);\n+    }\n+\n+    static SortedSet<String> usorted(SortedSet<String> set) {\n+        return Collections.unmodifiableSortedSet(set);\n+    }\n+\n+    static <T> List<T> copyReversed(List<T> list) {\n+        var r = new ArrayList<T>(list);\n+        Collections.reverse(r);\n+        return r;\n+    }\n+\n+    @DataProvider(name=\"all\")\n+    public Iterator<Object[]> all() {\n+        var result = new ArrayList<Object[]>();\n+        populated().forEachRemaining(result::add);\n+        empties().forEachRemaining(result::add);\n+        return result.iterator();\n+    }\n+\n+    @DataProvider(name=\"populated\")\n+    public Iterator<Object[]> populated() {\n+        return Arrays.asList(\n+            new Object[] { \"ArrayDeque\", new ArrayDeque<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"ArrayList\", new ArrayList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"AsList\", Arrays.asList(ORIGINAL.toArray()), ORIGINAL },\n+            new Object[] { \"COWAL\", new CopyOnWriteArrayList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"LinkedHashSet\", new LinkedHashSet<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"LinkedList\", new LinkedList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"ListOf\", ORIGINAL, ORIGINAL },\n+            new Object[] { \"SetFromMap\", setFromMap(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SimpleDeque\", new SimpleDeque<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SimpleList\", new SimpleList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SimpleSortedSet\", new SimpleSortedSet<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"TreeSet\", new TreeSet<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"UnmodColl\", ucoll(new ArrayList<>(ORIGINAL)), ORIGINAL },\n+            new Object[] { \"UnmodSet\", uset(new LinkedHashSet<>(ORIGINAL)), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"empties\")\n+    public Iterator<Object[]> empties() {\n+        return Arrays.asList(\n+            new Object[] { \"ArrayDeque\", new ArrayDeque<>(), List.of() },\n+            new Object[] { \"ArrayList\", new ArrayList<>(), List.of() },\n+            new Object[] { \"AsList\", Arrays.asList(new String[0]), List.of() },\n+            new Object[] { \"COWAL\", new CopyOnWriteArrayList<>(), List.of() },\n+            new Object[] { \"EmptyList\", Collections.emptyList(), List.of() },\n+            new Object[] { \"EmptyNavigableSet\", Collections.emptyNavigableSet(), List.of() },\n+            new Object[] { \"EmptySortedSet\", Collections.emptySortedSet(), List.of() },\n+            new Object[] { \"LinkedHashSet\", new LinkedHashSet<>(), List.of() },\n+            new Object[] { \"LinkedList\", new LinkedList<>(), List.of() },\n+            new Object[] { \"ListOf\", List.of(), List.of() },\n+            new Object[] { \"SetFromMap\", setFromMap(List.of()), List.of() },\n+            new Object[] { \"SimpleDeque\", new SimpleDeque<>(), List.of() },\n+            new Object[] { \"SimpleList\", new SimpleList<>(), List.of() },\n+            new Object[] { \"SimpleSortedSet\", new SimpleSortedSet<>(), List.of() },\n+            new Object[] { \"TreeSet\", new TreeSet<>(), List.of() },\n+            new Object[] { \"UnmodColl\", ucoll(new ArrayList<>()), List.of() },\n+            new Object[] { \"UnmodSet\", uset(new LinkedHashSet<>()), List.of() }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"adds\")\n+    public Iterator<Object[]> adds() {\n+        return Arrays.asList(\n+            new Object[] { \"ArrayDeque\", new ArrayDeque<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"ArrayList\", new ArrayList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"COWAL\", new CopyOnWriteArrayList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"LinkedHashSet\", new LinkedHashSet<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"LinkedList\", new LinkedList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SetFromMap\", setFromMap(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SimpleDeque\", new SimpleDeque<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SimpleList\", new SimpleList<>(ORIGINAL), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"removes\")\n+    public Iterator<Object[]> removes() {\n+        return Arrays.asList(\n+            new Object[] { \"ArrayDeque\", new ArrayDeque<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"ArrayList\", new ArrayList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"COWAL\", new CopyOnWriteArrayList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"LinkedHashSet\", new LinkedHashSet<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"LinkedList\", new LinkedList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SetFromMap\", setFromMap(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SimpleDeque\", new SimpleDeque<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SimpleList\", new SimpleList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SimpleSortedSet\", new SimpleSortedSet<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"TreeSet\", new TreeSet<>(ORIGINAL), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"emptyRemoves\")\n+    public Iterator<Object[]> emptyRemoves() {\n+        return Arrays.asList(\n+            new Object[] { \"ArrayDeque\", new ArrayDeque<>(), List.of() },\n+            new Object[] { \"ArrayList\", new ArrayList<>(), List.of() },\n+            new Object[] { \"COWAL\", new CopyOnWriteArrayList<>(), List.of() },\n+            new Object[] { \"LinkedHashSet\", new LinkedHashSet<>(), List.of() },\n+            new Object[] { \"LinkedList\", new LinkedList<>(), List.of() },\n+            new Object[] { \"SetFromMap\", setFromMap(List.of()), List.of() },\n+            new Object[] { \"SimpleDeque\", new SimpleDeque<>(), List.of() },\n+            new Object[] { \"SimpleList\", new SimpleList<>(), List.of() },\n+            new Object[] { \"SimpleSortedSet\", new SimpleSortedSet<>(), List.of() },\n+            new Object[] { \"TreeSet\", new TreeSet<>(), List.of() }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"serializable\")\n+    public Iterator<Object[]> serializable() {\n+        return Arrays.asList(\n+            new Object[] { \"ArrayDeque\", new ArrayDeque<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"ArrayList\", new ArrayList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"AsList\", Arrays.asList(ORIGINAL.toArray()), ORIGINAL },\n+            new Object[] { \"COWAL\", new CopyOnWriteArrayList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"LinkedHashSet\", new LinkedHashSet<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"LinkedList\", new LinkedList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"ListOf\", ORIGINAL, ORIGINAL },\n+            new Object[] { \"SetFromMap\", setFromMap(ORIGINAL), ORIGINAL },\n+            new Object[] { \"TreeSet\", new TreeSet<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"UnmodColl\", ucoll(new ArrayList<>(ORIGINAL)), ORIGINAL },\n+            new Object[] { \"UnmodSet\", uset(new LinkedHashSet<>(ORIGINAL)), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"notSerializable\")\n+    public Iterator<Object[]> notSerializable() {\n+        return Arrays.asList(\n+            new Object[] { \"ArrayDeque\", new ArrayDeque<>(ORIGINAL).reversed() },\n+            new Object[] { \"ArrayList\", new ArrayList<>(ORIGINAL).reversed() },\n+            new Object[] { \"AsList\", Arrays.asList(ORIGINAL.toArray()).reversed() },\n+            new Object[] { \"COWAL\", new CopyOnWriteArrayList<>(ORIGINAL).reversed() },\n+            new Object[] { \"LinkedHashSet\", new LinkedHashSet<>(ORIGINAL).reversed() },\n+            new Object[] { \"LinkedList\", new LinkedList<>(ORIGINAL).reversed() },\n+            new Object[] { \"ListOf\", ORIGINAL.reversed() },\n+            new Object[] { \"SetFromMap\", setFromMap(ORIGINAL).reversed() },\n+            new Object[] { \"UnmodColl\", ucoll(new ArrayList<>(ORIGINAL)).reversed() },\n+            new Object[] { \"UnmodSet\", uset(new LinkedHashSet<>(ORIGINAL)).reversed() }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"doubleReverse\")\n+    public Iterator<Object[]> doubleReverse() {\n+        return Arrays.asList(\n+            new Object[] { \"ArrayDeque\", new ArrayDeque<>(ORIGINAL) },\n+            new Object[] { \"ArrayList\", new ArrayList<>(ORIGINAL) },\n+            new Object[] { \"AsList\", Arrays.asList(ORIGINAL.toArray()) },\n+            new Object[] { \"COWAL\", new CopyOnWriteArrayList<>(ORIGINAL) },\n+            new Object[] { \"LinkedHashSet\", new LinkedHashSet<>(ORIGINAL) },\n+            new Object[] { \"LinkedList\", new LinkedList<>(ORIGINAL) },\n+            new Object[] { \"ListOf\", ORIGINAL },\n+            new Object[] { \"SimpleDeque\", new SimpleDeque<>(ORIGINAL) },\n+            new Object[] { \"SimpleList\", new SimpleList<>(ORIGINAL) },\n+            new Object[] { \"SimpleSortedSet\", new SimpleSortedSet<>(ORIGINAL) }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"unmodifiable\")\n+    public Iterator<Object[]> unmodifiable() {\n+        return Arrays.asList(\n+            new Object[] { \"ListOf\", ORIGINAL, ORIGINAL },\n+            new Object[] { \"ListOfSub\", ORIGINAL.subList(1, 3), ORIGINAL.subList(1, 3) },\n+            new Object[] { \"SingleList\", Collections.singletonList(\"a\"), List.of(\"a\") },\n+            new Object[] { \"UnmodColl\", ucoll(new ArrayList<>(ORIGINAL)), ORIGINAL },\n+            new Object[] { \"UnmodList\", ulist(new ArrayList<>(ORIGINAL)), ORIGINAL },\n+            new Object[] { \"UnmodNav\", unav(new TreeSet<>(ORIGINAL)), ORIGINAL },\n+            new Object[] { \"UnmodSet\", uset(new LinkedHashSet<>(ORIGINAL)), ORIGINAL },\n+            new Object[] { \"UnmodSorted\", usorted(new TreeSet<>(ORIGINAL)), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"checkedList\")\n+    public Iterator<Object[]> checkedList() {\n+        return Arrays.<Object[]>asList(\n+            new Object[] { \"ChkList\", cklist(new ArrayList<>(ORIGINAL)), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"checkedNavSet\")\n+    public Iterator<Object[]> checkedNavSet() {\n+        return Arrays.<Object[]>asList(\n+            new Object[] { \"ChkNav\", cknav(new TreeSet<>(ORIGINAL)), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"checkedSortedSet\")\n+    public Iterator<Object[]> checkedSortedSet() {\n+        return Arrays.<Object[]>asList(\n+            new Object[] { \"ChkSorted\", cksorted(new TreeSet<>(ORIGINAL)), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    \/\/ mode bit tests for subList testing\n+\n+    boolean reverseList(int mode) { return (mode & 1) != 0; }\n+    boolean reverseSub(int mode)  { return (mode & 2) != 0; }\n+    boolean isReversed(int mode) { return reverseList(mode) ^ reverseSub(mode); }\n+\n+    List<String> applyMode(int mode, List<String> base) {\n+        var list = reverseList(mode) ? base.reversed() : base;\n+        var sub = list.subList(2, 5);\n+        return reverseSub(mode) ? sub.reversed() : sub;\n+    }\n+\n+    \/**\n+     * Generate cases for testing subLists. For each different List implementation, generate 4\n+     * cases from the two bits of the testing mode int value:\n+     *\n+     *  (bit 1) if true, the List is reversed\n+     *  (bit 2) if true, the subList is reversed\n+     *\n+     * @return the generated cases\n+     *\/\n+    @DataProvider(name=\"subListMods\")\n+    public Iterator<Object[]> subListMods() {\n+        var cases = new ArrayList<Object[]>();\n+        for (int mode = 0; mode < 4; mode++) {\n+            cases.addAll(Arrays.asList(\n+                new Object[] { \"ArrayList\", mode, new ArrayList<>(ORIGINAL), ORIGINAL },\n+                new Object[] { \"COWAL\", mode, new CopyOnWriteArrayList<>(ORIGINAL), ORIGINAL },\n+                new Object[] { \"LinkedList\", mode, new LinkedList<>(ORIGINAL), ORIGINAL },\n+                new Object[] { \"SimpleList\", mode, new SimpleList<>(ORIGINAL), ORIGINAL }\n+            ));\n+        }\n+        return cases.iterator();\n+    }\n+\n+    @DataProvider(name=\"iteratorMods\")\n+    public Iterator<Object[]> iteratorMods() {\n+        var cases = new ArrayList<Object[]>();\n+        for (boolean rev : List.of(false, true)) {\n+            cases.addAll(Arrays.asList(\n+                new Object[] { \"ArrayList\", rev, new ArrayList<>(ORIGINAL), ORIGINAL },\n+                new Object[] { \"LinkedList\", rev, new LinkedList<>(ORIGINAL), ORIGINAL },\n+                new Object[] { \"SimpleList\", rev, new SimpleList<>(ORIGINAL), ORIGINAL }\n+            ));\n+        }\n+        return cases.iterator();\n+    }\n+\n+    @DataProvider(name=\"subListIteratorMods\")\n+    public Iterator<Object[]> subListIteratorMods() {\n+        var cases = new ArrayList<Object[]>();\n+        for (int mode = 0; mode < 4; mode++) {\n+            cases.addAll(Arrays.asList(\n+                new Object[] { \"ArrayList\", mode, new ArrayList<>(ORIGINAL), ORIGINAL },\n+                new Object[] { \"LinkedList\", mode, new LinkedList<>(ORIGINAL), ORIGINAL },\n+                new Object[] { \"SimpleList\", mode, new SimpleList<>(ORIGINAL), ORIGINAL }\n+            ));\n+        }\n+        return cases.iterator();\n+    }\n+\n+    \/\/ ========== Assertions ==========\n+\n+    \/**\n+     * Basic checks over the contents of a SequencedCollection,\n+     * compared to a reference List, in one direction.\n+     *\n+     * @param seq the SequencedCollection under test\n+     * @param ref the reference List\n+     *\/\n+    public void checkContents1(SequencedCollection<String> seq, List<String> ref) {\n+        var list1 = new ArrayList<String>();\n+        for (var s : seq)\n+            list1.add(s);\n+        assertEquals(list1, ref);\n+\n+        var list2 = new ArrayList<String>();\n+        seq.forEach(list2::add);\n+        assertEquals(list2, ref);\n+\n+        var list3 = Arrays.asList(seq.toArray());\n+        assertEquals(list3, ref);\n+\n+        var list4 = Arrays.asList(seq.toArray(new String[0]));\n+        assertEquals(list4, ref);\n+\n+        var list5 = Arrays.asList(seq.toArray(String[]::new));\n+        assertEquals(list5, ref);\n+\n+        var list6 = seq.stream().toList();\n+        assertEquals(list6, ref);\n+\n+        var list7 = seq.parallelStream().toList();\n+        assertEquals(list7, ref);\n+\n+        assertEquals(seq.size(), ref.size());\n+        assertEquals(seq.isEmpty(), ref.isEmpty());\n+\n+        for (var s : ref) {\n+            assertTrue(seq.contains(s));\n+        }\n+    }\n+\n+    \/**\n+     * Check the contents of a SequencedCollection against a reference List,\n+     * in both directions.\n+     *\n+     * @param seq the SequencedCollection under test\n+     * @param ref the reference List\n+     *\/\n+    public void checkContents(SequencedCollection<String> seq, List<String> ref) {\n+        checkContents1(seq, ref);\n+\n+        var rref = copyReversed(ref);\n+        var rseq = seq.reversed();\n+        checkContents1(rseq, rref);\n+\n+        var rrseq = rseq.reversed();\n+        checkContents1(rrseq, ref);\n+    }\n+\n+    \/**\n+     * Check that modification operations will throw UnsupportedOperationException,\n+     * in one direction.\n+     *\n+     * @param seq the SequencedCollection under test\n+     *\/\n+    public void checkUnmodifiable1(SequencedCollection<String> seq) {\n+        final var UOE = UnsupportedOperationException.class;\n+\n+        assertThrows(UOE, () -> seq.add(\"x\"));\n+        assertThrows(UOE, () -> seq.clear());\n+        assertThrows(UOE, () -> { var it = seq.iterator(); it.next(); it.remove(); });\n+        assertThrows(UOE, () -> seq.removeIf(x -> true));\n+\n+        assertThrows(UOE, () -> seq.addFirst(\"x\"));\n+        assertThrows(UOE, () -> seq.addLast(\"x\"));\n+        assertThrows(UOE, () -> seq.removeFirst());\n+        assertThrows(UOE, () -> seq.removeLast());\n+\n+\/\/ TODO these ops should throw unconditionally, but they don't in some implementations\n+     \/\/ assertThrows(UOE, () -> seq.addAll(List.of()));\n+     \/\/ assertThrows(UOE, () -> seq.remove(\"x\"));\n+     \/\/ assertThrows(UOE, () -> seq.removeAll(List.of()));\n+     \/\/ assertThrows(UOE, () -> seq.removeIf(x -> false));\n+     \/\/ assertThrows(UOE, () -> seq.retainAll(seq));\n+        assertThrows(UOE, () -> seq.addAll(seq));\n+        assertThrows(UOE, () -> seq.remove(seq.iterator().next()));\n+        assertThrows(UOE, () -> seq.removeAll(seq));\n+        assertThrows(UOE, () -> seq.retainAll(List.of()));\n+    }\n+\n+    \/**\n+     * Check that modification operations will throw UnsupportedOperationException,\n+     * in both directions.\n+     *\n+     * @param seq the SequencedCollection under test\n+     *\/\n+    public void checkUnmodifiable(SequencedCollection<String> seq) {\n+        checkUnmodifiable1(seq);\n+        checkUnmodifiable1(seq.reversed());\n+    }\n+\n+    static final Class<? extends Throwable> CCE = ClassCastException.class;\n+\n+    public void checkCheckedList(List<String> list) {\n+        List<Object> objList = (List<Object>)(List)list;\n+        assertThrows(CCE, () -> { objList.addFirst(new Object()); });\n+        assertThrows(CCE, () -> { objList.addLast(new Object()); });\n+        assertThrows(CCE, () -> { objList.reversed().addFirst(new Object()); });\n+        assertThrows(CCE, () -> { objList.reversed().addLast(new Object()); });\n+    }\n+\n+    public void checkCheckedNavSet(NavigableSet<String> set) {\n+        NavigableSet<Object> objSet = (NavigableSet<Object>)(NavigableSet)set;\n+        assertThrows(CCE, () -> { objSet.add(new Object()); });\n+        assertThrows(CCE, () -> { objSet.reversed().add(new Object()); });\n+    }\n+\n+    public void checkCheckedSortedSet(SortedSet<String> set) {\n+        SortedSet<Object> objSet = (SortedSet<Object>)(SortedSet)set;\n+        assertThrows(CCE, () -> { objSet.add(new Object()); });\n+        assertThrows(CCE, () -> { objSet.reversed().add(new Object()); });\n+    }\n+\n+    \/\/ ========== Tests ==========\n+\n+    @Test(dataProvider=\"all\")\n+    public void testFundamentals(String label, SequencedCollection<String> seq, List<String> ref) {\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"populated\")\n+    public void testGetFirst(String label, SequencedCollection<String> seq, List<String> ref) {\n+        assertEquals(seq.getFirst(), ref.get(0));\n+        assertEquals(seq.reversed().getFirst(), ref.get(ref.size() - 1));\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"populated\")\n+    public void testGetLast(String label, SequencedCollection<String> seq, List<String> ref) {\n+        assertEquals(seq.getLast(), ref.get(ref.size() - 1));\n+        assertEquals(seq.reversed().getLast(), ref.get(0));\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"empties\")\n+    public void testEmptyGetFirst(String label, SequencedCollection<String> seq, List<String> ref) {\n+        assertThrows(NoSuchElementException.class, () -> seq.getFirst());\n+        assertThrows(NoSuchElementException.class, () -> seq.reversed().getFirst());\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"empties\")\n+    public void testEmptyGetLast(String label, SequencedCollection<String> seq, List<String> ref) {\n+        assertThrows(NoSuchElementException.class, () -> seq.getLast());\n+        assertThrows(NoSuchElementException.class, () -> seq.reversed().getLast());\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"adds\")\n+    public void testAddFirst(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(0, \"x\");\n+        seq.addFirst(\"x\");\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"adds\")\n+    public void testAddFirstRev(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(\"x\");\n+        seq.reversed().addFirst(\"x\");\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"adds\")\n+    public void testAddLast(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(\"x\");\n+        seq.addLast(\"x\");\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"adds\")\n+    public void testAddLastRev(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(0, \"x\");\n+        seq.reversed().addLast(\"x\");\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"removes\")\n+    public void testRemoveFirst(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var exp = ref.remove(0);\n+        var act = seq.removeFirst();\n+        assertEquals(act, exp);\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"removes\")\n+    public void testRemoveFirstRev(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var exp = ref.remove(ref.size() - 1);\n+        var act = seq.reversed().removeFirst();\n+        assertEquals(act, exp);\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"removes\")\n+    public void testRemoveLast(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var exp = ref.remove(ref.size() - 1);\n+        var act = seq.removeLast();\n+        assertEquals(act, exp);\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"removes\")\n+    public void testRemoveLastRev(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var exp = ref.remove(0);\n+        var act = seq.reversed().removeLast();\n+        assertEquals(act, exp);\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"emptyRemoves\")\n+    public void testEmptyRemoveFirst(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        assertThrows(NoSuchElementException.class, () -> seq.removeFirst());\n+        assertThrows(NoSuchElementException.class, () -> seq.reversed().removeFirst());\n+        checkContents(seq, baseref);\n+    }\n+\n+    @Test(dataProvider=\"emptyRemoves\")\n+    public void testEmptyRemoveLast(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        assertThrows(NoSuchElementException.class, () -> seq.removeLast());\n+        assertThrows(NoSuchElementException.class, () -> seq.reversed().removeLast());\n+        checkContents(seq, baseref);\n+    }\n+\n+    @Test(dataProvider=\"serializable\")\n+    public void testSerializable(String label, SequencedCollection<String> seq, List<String> ref)\n+        throws ClassNotFoundException, IOException\n+    {\n+        var baos = new ByteArrayOutputStream();\n+        try (var oos = new ObjectOutputStream(baos)) {\n+            oos.writeObject(seq);\n+        }\n+\n+        try (var bais = new ByteArrayInputStream(baos.toByteArray());\n+             var ois = new ObjectInputStream(bais)) {\n+            var seq2 = (SequencedCollection<String>) ois.readObject();\n+            checkContents(seq2, ref);\n+        }\n+    }\n+\n+    @Test(dataProvider=\"notSerializable\")\n+    public void testNotSerializable(String label, SequencedCollection<String> seq)\n+        throws ClassNotFoundException, IOException\n+    {\n+        var baos = new ByteArrayOutputStream();\n+        try (var oos = new ObjectOutputStream(baos)) {\n+            assertThrows(ObjectStreamException.class, () -> oos.writeObject(seq));\n+        }\n+    }\n+\n+    @Test(dataProvider=\"doubleReverse\")\n+    public void testDoubleReverse(String label, SequencedCollection<String> seq) {\n+        var rrseq = seq.reversed().reversed();\n+        assertSame(rrseq, seq);\n+    }\n+\n+    @Test(dataProvider=\"unmodifiable\")\n+    public void testUnmodifiable(String label, SequencedCollection<String> seq, List<String> ref) {\n+        checkUnmodifiable(seq);\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"checkedList\")\n+    public void testCheckedList(String label, List<String> list, List<String> ref) {\n+        checkCheckedList(list);\n+        checkContents(list, ref);\n+    }\n+\n+    @Test(dataProvider=\"checkedNavSet\")\n+    public void testCheckedNavSet(String label, NavigableSet<String> set, List<String> ref) {\n+        checkCheckedNavSet(set);\n+        checkContents(set, ref);\n+    }\n+\n+    @Test(dataProvider=\"checkedSortedSet\")\n+    public void testCheckedSortedSet(String label, SortedSet<String> set, List<String> ref) {\n+        checkCheckedSortedSet(set);\n+        checkContents(set, ref);\n+    }\n+\n+    \/\/ Indexes for subList modification tests:\n+    \/\/ 0  1  2  3  4  5  6\n+    \/\/ a, b, c, d, e, f, g\n+    \/\/       c, d, e\n+\n+    @Test(dataProvider=\"subListMods\")\n+    public void testSubListGet(String label, int mode, List<String> list, List<String> base) {\n+        var sub = applyMode(mode, list);\n+        assertEquals(sub.getFirst(), isReversed(mode) ? \"e\" : \"c\");\n+        assertEquals(sub.getLast(),  isReversed(mode) ? \"c\" : \"e\");\n+    }\n+\n+    @Test(dataProvider=\"subListMods\")\n+    public void testSubListAddFirst(String label, int mode, List<String> list, List<String> base) {\n+        var refList = new ArrayList<>(base);\n+        var sub = applyMode(mode, list);\n+        var refSub = new ArrayList<>(sub);\n+\n+        refList.add(isReversed(mode) ? 5 : 2, \"x\");\n+        sub.addFirst(\"x\");\n+        refSub.add(0, \"x\");\n+\n+        checkContents(sub, refSub);\n+        checkContents(list, refList);\n+    }\n+\n+    @Test(dataProvider=\"subListMods\")\n+    public void testSubListAddLast(String label, int mode, List<String> list, List<String> base) {\n+        var refList = new ArrayList<>(base);\n+        var sub = applyMode(mode, list);\n+        var refSub = new ArrayList<>(sub);\n+\n+        refList.add(isReversed(mode) ? 2 : 5, \"x\");\n+        sub.addLast(\"x\");\n+        refSub.add(\"x\");\n+\n+        checkContents(sub, refSub);\n+        checkContents(list, refList);\n+    }\n+\n+    @Test(dataProvider=\"subListMods\")\n+    public void testSubListRemoveFirst(String label, int mode, List<String> list, List<String> base) {\n+        var refList = new ArrayList<>(base);\n+        var sub = applyMode(mode, list);\n+        var refSub = new ArrayList<>(sub);\n+\n+        refList.remove(isReversed(mode) ? 4 : 2);\n+        var act = sub.removeFirst();\n+        var exp = refSub.remove(0);\n+\n+        assertEquals(act, exp);\n+        checkContents(sub, refSub);\n+        checkContents(list, refList);\n+    }\n+\n+    @Test(dataProvider=\"subListMods\")\n+    public void testSubListRemoveLast(String label, int mode, List<String> list, List<String> base) {\n+        var refList = new ArrayList<>(base);\n+        var sub = applyMode(mode, list);\n+        var refSub = new ArrayList<>(sub);\n+\n+        refList.remove(isReversed(mode) ? 2 : 4);\n+        var act = sub.removeLast();\n+        var exp = refSub.remove(refSub.size() - 1);\n+\n+        assertEquals(act, exp);\n+        checkContents(sub, refSub);\n+        checkContents(list, refList);\n+    }\n+\n+    @Test(dataProvider=\"subListMods\")\n+    public void testSubListAddAllFirst(String label, int mode, List<String> list, List<String> base) {\n+        var refList = new ArrayList<>(base);\n+        var sub = applyMode(mode, list);\n+        var refSub = new ArrayList<>(sub);\n+\n+        if (isReversed(mode))\n+            refList.addAll(5, List.of(\"y\", \"x\"));\n+        else\n+            refList.addAll(2, List.of(\"x\", \"y\"));\n+        sub.addAll(0, List.of(\"x\", \"y\"));\n+        refSub.addAll(0, List.of(\"x\", \"y\"));\n+\n+        checkContents(sub, refSub);\n+        checkContents(list, refList);\n+    }\n+\n+    @Test(dataProvider=\"subListMods\")\n+    public void testSubListAddAllLast(String label, int mode, List<String> list, List<String> base) {\n+        var refList = new ArrayList<>(base);\n+        var sub = applyMode(mode, list);\n+        var refSub = new ArrayList<>(sub);\n+\n+        if (isReversed(mode))\n+            refList.addAll(2, List.of(\"y\", \"x\"));\n+        else\n+            refList.addAll(5, List.of(\"x\", \"y\"));\n+        sub.addAll(List.of(\"x\", \"y\"));\n+        refSub.addAll(List.of(\"x\", \"y\"));\n+\n+        checkContents(sub, refSub);\n+        checkContents(list, refList);\n+    }\n+\n+    @Test(dataProvider=\"iteratorMods\")\n+    public void testListIteratorAdd(String label, boolean rev, List<String> list, List<String> base) {\n+        var ref = new ArrayList<>(base);\n+        var it = (rev ? list.reversed() : list).listIterator();\n+\n+        ref.add(rev ? 5 : 2, \"x\");\n+        it.next();\n+        it.next();\n+        it.add(\"x\");\n+\n+        assertEquals(it.next(), rev ? \"e\" : \"c\");\n+        checkContents(list, ref);\n+    }\n+\n+    @Test(dataProvider=\"iteratorMods\")\n+    public void testListIteratorSet(String label, boolean rev, List<String> list, List<String> base) {\n+        var ref = new ArrayList<>(base);\n+        var it = (rev ? list.reversed() : list).listIterator();\n+\n+        ref.set(rev ? 5 : 1, \"x\");\n+        it.next();\n+        it.next();\n+        it.set(\"x\");\n+\n+        assertEquals(it.next(), rev ? \"e\" : \"c\");\n+        checkContents(list, ref);\n+    }\n+\n+    @Test(dataProvider=\"iteratorMods\")\n+    public void testListIteratorRemove(String label, boolean rev, List<String> list, List<String> base) {\n+        var ref = new ArrayList<>(base);\n+        var it = (rev ? list.reversed() : list).listIterator();\n+\n+        ref.remove(rev ? 5 : 1);\n+        it.next();\n+        it.next();\n+        it.remove();\n+\n+        assertEquals(it.next(), rev ? \"e\" : \"c\");\n+        checkContents(list, ref);\n+    }\n+\n+    \/\/ SubList ListIterator modification tests.\n+\n+    @Test(dataProvider=\"subListIteratorMods\")\n+    public void testSubListIteratorAdd(String label, int mode, List<String> list, List<String> base) {\n+        var refList = new ArrayList<>(base);\n+        var sub = applyMode(mode, list);\n+        var refSub = new ArrayList<>(sub);\n+\n+        var it = sub.listIterator();\n+        it.next();\n+        it.add(\"x\");\n+        refList.add(isReversed(mode) ? 4 : 3, \"x\");\n+        refSub.add(1, \"x\");\n+\n+        assertEquals(it.next(), \"d\");\n+        checkContents(sub, refSub);\n+        checkContents(list, refList);\n+    }\n+\n+    @Test(dataProvider=\"subListIteratorMods\")\n+    public void testSubListIteratorSet(String label, int mode, List<String> list, List<String> base) {\n+        var refList = new ArrayList<>(base);\n+        var sub = applyMode(mode, list);\n+        var refSub = new ArrayList<>(sub);\n+\n+        var it = sub.listIterator();\n+        it.next();\n+        it.set(\"x\");\n+        refList.set(isReversed(mode) ? 4 : 2, \"x\");\n+        refSub.set(0, \"x\");\n+\n+        assertEquals(it.next(), \"d\");\n+        checkContents(sub, refSub);\n+        checkContents(list, refList);\n+    }\n+\n+    @Test(dataProvider=\"subListIteratorMods\")\n+    public void testSubListIteratorRemove(String label, int mode, List<String> list, List<String> base) {\n+        var refList = new ArrayList<>(base);\n+        var sub = applyMode(mode, list);\n+        var refSub = new ArrayList<>(sub);\n+\n+        var it = sub.listIterator();\n+        it.next();\n+        it.remove();\n+        refList.remove(isReversed(mode) ? 4 : 2);\n+        refSub.remove(0);\n+\n+        assertEquals(it.next(), \"d\");\n+        checkContents(sub, refSub);\n+        checkContents(list, refList);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/Basic.java","additions":834,"deletions":0,"binary":false,"changes":834,"status":"added"},{"patch":"@@ -0,0 +1,836 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertSame;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug     8266571\n+ * @summary Basic tests for SequencedMap\n+ * @modules java.base\/java.util:open\n+ * @build   SimpleSortedMap\n+ * @run     testng BasicMap\n+ *\/\n+\n+public class BasicMap {\n+\n+    \/\/ ========== Data Providers ==========\n+\n+    static final Class<? extends Throwable> CCE  = ClassCastException.class;\n+    static final Class<? extends Throwable> NSEE = NoSuchElementException.class;\n+    static final Class<? extends Throwable> UOE  = UnsupportedOperationException.class;\n+\n+    static final List<Map.Entry<String, Integer>> ORIGINAL =\n+        List.of(Map.entry(\"a\", 1),\n+                Map.entry(\"b\", 2),\n+                Map.entry(\"c\", 3),\n+                Map.entry(\"d\", 4),\n+                Map.entry(\"e\", 5));\n+\n+    static <M extends SequencedMap<String, Integer>>\n+    M load(M map, List<Map.Entry<String, Integer>> mappings) {\n+        for (var e : mappings)\n+            map.put(e.getKey(), e.getValue());\n+        return map;\n+    }\n+\n+    static NavigableMap<String, Integer> cknav(NavigableMap<String, Integer> map) {\n+        return Collections.checkedNavigableMap(map, String.class, Integer.class);\n+    }\n+\n+    static SortedMap<String, Integer> cksorted(SortedMap<String, Integer> map) {\n+        return Collections.checkedSortedMap(map, String.class, Integer.class);\n+    }\n+\n+    static SequencedMap<String, Integer> umap(SequencedMap<String, Integer> map) {\n+        return Collections.unmodifiableSequencedMap(map);\n+    }\n+\n+    static SortedMap<String, Integer> usorted(SortedMap<String, Integer> map) {\n+        return Collections.unmodifiableSortedMap(map);\n+    }\n+\n+    static NavigableMap<String, Integer> unav(NavigableMap<String, Integer> map) {\n+        return Collections.unmodifiableNavigableMap(map);\n+    }\n+\n+    @DataProvider(name=\"all\")\n+    public Iterator<Object[]> all() {\n+        var result = new ArrayList<Object[]>();\n+        populated().forEachRemaining(result::add);\n+        empties().forEachRemaining(result::add);\n+        return result.iterator();\n+    }\n+\n+    @DataProvider(name=\"populated\")\n+    public Iterator<Object[]> populated() {\n+        return Arrays.asList(\n+            new Object[] { \"LinkedHashMap\", load(new LinkedHashMap<>(), ORIGINAL), ORIGINAL },\n+            new Object[] { \"SimpleSortedMap\", load(new SimpleSortedMap<>(), ORIGINAL), ORIGINAL },\n+            new Object[] { \"TreeMap\", load(new TreeMap<>(), ORIGINAL), ORIGINAL },\n+            new Object[] { \"UnmodMap\", umap(load(new LinkedHashMap<>(), ORIGINAL)), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"empties\")\n+    public Iterator<Object[]> empties() {\n+        return Arrays.asList(\n+            new Object[] { \"EmptyNavigableMap\", Collections.emptyNavigableMap(), List.of() },\n+            new Object[] { \"EmptySortedMap\", Collections.emptySortedMap(), List.of() },\n+            new Object[] { \"LinkedHashMap\", new LinkedHashMap<>(), List.of() },\n+            new Object[] { \"SimpleSortedMap\", new SimpleSortedMap<>(), List.of() },\n+            new Object[] { \"TreeMap\", new TreeMap<>(), List.of() },\n+            new Object[] { \"UnmodMap\", umap(new LinkedHashMap<>()), List.of() }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"polls\")\n+    public Iterator<Object[]> polls() {\n+        return Arrays.asList(\n+            new Object[] { \"LinkedHashMap\", load(new LinkedHashMap<>(), ORIGINAL), ORIGINAL },\n+            new Object[] { \"SimpleSortedMap\", load(new SimpleSortedMap<>(), ORIGINAL), ORIGINAL },\n+            new Object[] { \"TreeMap\", load(new TreeMap<>(), ORIGINAL), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"emptyPolls\")\n+    public Iterator<Object[]> emptyPolls() {\n+        return Arrays.asList(\n+            new Object[] { \"LinkedHashMap\", new LinkedHashMap<>(), List.of() },\n+            new Object[] { \"SimpleSortedMap\", new SimpleSortedMap<>(), List.of() },\n+            new Object[] { \"TreeMap\", new TreeMap<>(), List.of() }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"puts\")\n+    public Iterator<Object[]> puts() {\n+        return Arrays.<Object[]>asList(\n+            new Object[] { \"LinkedHashMap\", load(new LinkedHashMap<>(), ORIGINAL), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"putThrows\")\n+    public Iterator<Object[]> putThrows() {\n+        return Arrays.asList(\n+            new Object[] { \"SimpleSortedMap\", load(new SimpleSortedMap<>(), ORIGINAL), ORIGINAL },\n+            new Object[] { \"TreeMap\", load(new TreeMap<>(), ORIGINAL), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"serializable\")\n+    public Iterator<Object[]> serializable() {\n+        return Arrays.asList(\n+            new Object[] { \"LinkedHashMap\", load(new LinkedHashMap<>(), ORIGINAL), ORIGINAL },\n+            new Object[] { \"TreeMap\", load(new TreeMap<>(), ORIGINAL), ORIGINAL },\n+            new Object[] { \"UnmodMap\", umap(load(new LinkedHashMap<>(), ORIGINAL)), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"notSerializable\")\n+    public Iterator<Object[]> notSerializable() {\n+        return Arrays.asList(\n+            new Object[] { \"LinkedHashMap\", load(new LinkedHashMap<>(), ORIGINAL).reversed() },\n+            new Object[] { \"UnmodMap\", umap(load(new LinkedHashMap<>(), ORIGINAL)).reversed() }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"doubleReverse\")\n+    public Iterator<Object[]> doubleReverse() {\n+        return Arrays.<Object[]>asList(\n+            new Object[] { \"LinkedHashMap\", load(new LinkedHashMap<>(), ORIGINAL) }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"unmodifiable\")\n+    public Iterator<Object[]> unmodifible() {\n+        return Arrays.<Object[]>asList(\n+            new Object[] { \"UnmodMap\", umap(load(new LinkedHashMap<>(), ORIGINAL)), ORIGINAL },\n+            new Object[] { \"UnmodNav\", unav(load(new TreeMap<>(), ORIGINAL)), ORIGINAL },\n+            new Object[] { \"UnmodSorted\", usorted(load(new TreeMap<>(), ORIGINAL)), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    @DataProvider(name=\"checked\")\n+    public Iterator<Object[]> checked() {\n+        return Arrays.<Object[]>asList(\n+            new Object[] { \"ChkNav\", cknav(load(new TreeMap<>(), ORIGINAL)), ORIGINAL },\n+            new Object[] { \"ChkSorted\", cksorted(load(new TreeMap<>(), ORIGINAL)), ORIGINAL }\n+        ).iterator();\n+    }\n+\n+    \/\/ mode bit tests\n+\n+    boolean reverseMap(int mode)  { return (mode & 1) != 0; }\n+    boolean reverseView(int mode) { return (mode & 2) != 0; }\n+    boolean callLast(int mode)    { return (mode & 4) != 0; }\n+\n+    boolean refLast(int mode) { return reverseMap(mode) ^ reverseView(mode) ^ callLast(mode); }\n+\n+    \/**\n+     * Generate cases for testing the removeFirst and removeLast methods of map views. For each\n+     * different map implementation, generate 8 cases from the three bits of the testing mode\n+     * int value:\n+     *\n+     *  (bit 1) if true, the backing map is reversed\n+     *  (bit 2) if true, the view is reversed\n+     *  (bit 4) if true, the last element of the view is to be removed, otherwise the first\n+     *\n+     * The three bits XORed together (by refLast(), above) indicate (if true) the last\n+     * or (if false) the first element of the reference entry list is to be removed.\n+     *\n+     * @return the generated cases\n+     *\/\n+    @DataProvider(name=\"viewRemoves\")\n+    public Iterator<Object[]> viewRemoves() {\n+        var cases = new ArrayList<Object[]>();\n+        for (int mode = 0; mode < 8; mode++) {\n+            cases.addAll(Arrays.asList(\n+                new Object[] { \"LinkedHashMap\", mode, load(new LinkedHashMap<>(), ORIGINAL), ORIGINAL },\n+                new Object[] { \"SimpleSortedMap\", mode, load(new SimpleSortedMap<>(), ORIGINAL), ORIGINAL },\n+                new Object[] { \"TreeMap\", mode, load(new TreeMap<>(), ORIGINAL), ORIGINAL }\n+            ));\n+        }\n+        return cases.iterator();\n+    }\n+\n+    @DataProvider(name=\"emptyViewRemoves\")\n+    public Iterator<Object[]> emptyViewRemoves() {\n+        var cases = new ArrayList<Object[]>();\n+        for (int mode = 0; mode < 8; mode++) {\n+            cases.addAll(Arrays.asList(\n+                new Object[] { \"LinkedHashMap\", mode, new LinkedHashMap<>(), List.of() },\n+                new Object[] { \"SimpleSortedMap\", mode, new SimpleSortedMap<>(), List.of() },\n+                new Object[] { \"TreeMap\", mode, new TreeMap<>(), List.of() }\n+            ));\n+        }\n+        return cases.iterator();\n+    }\n+\n+    @DataProvider(name=\"viewAddThrows\")\n+    public Iterator<Object[]> viewAddThrows() {\n+        var cases = new ArrayList<Object[]>();\n+        for (int mode = 0; mode < 8; mode++) {\n+            cases.addAll(Arrays.asList(\n+                new Object[] { \"LinkedHashMap\", mode, load(new LinkedHashMap<>(), ORIGINAL), ORIGINAL },\n+                new Object[] { \"SimpleSortedMap\", mode, load(new SimpleSortedMap<>(), ORIGINAL), ORIGINAL },\n+                new Object[] { \"TreeMap\", mode, load(new TreeMap<>(), ORIGINAL), ORIGINAL }\n+            ));\n+        }\n+        return cases.iterator();\n+    }\n+\n+    \/\/ ========== Assertions ==========\n+\n+    \/**\n+     * Basic checks over the contents of a SequencedMap, compared to a reference List of entries,\n+     * in one direction.\n+     *\n+     * @param map the SequencedMap under test\n+     * @param ref the reference list of entries\n+     *\/\n+    public void checkContents1(SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        var list1 = new ArrayList<Map.Entry<String, Integer>>();\n+        map.forEach((k, v) -> list1.add(Map.entry(k, v)));\n+        assertEquals(list1, ref);\n+\n+        assertEquals(map.size(), ref.size());\n+        assertEquals(map.isEmpty(), ref.isEmpty());\n+\n+        for (var e : ref) {\n+            assertTrue(map.containsKey(e.getKey()));\n+            assertTrue(map.containsValue(e.getValue()));\n+            assertEquals(map.get(e.getKey()), e.getValue());\n+        }\n+    }\n+\n+    public void checkContents(SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        checkContents1(map, ref);\n+\n+        var rref = new ArrayList<>(ref);\n+        Collections.reverse(rref);\n+        var rmap = map.reversed();\n+        checkContents1(rmap, rref);\n+\n+        var rrmap = rmap.reversed();\n+        checkContents1(rrmap, ref);\n+    }\n+\n+    \/**\n+     * Check the entrySet, keySet, or values view of a SequencedMap in one direction. The view\n+     * collection is ordered even though the collection type is not sequenced.\n+     *\n+     * @param <T> the element type of the view\n+     * @param mapView the actual map view\n+     * @param expElements list of the expected elements\n+     *\/\n+    public <T> void checkView1(Collection<T> mapView, List<T> expElements) {\n+        var list1 = new ArrayList<T>();\n+        for (var k : mapView)\n+            list1.add(k);\n+        assertEquals(list1, expElements);\n+\n+        var list2 = new ArrayList<T>();\n+        mapView.forEach(list2::add);\n+        assertEquals(list2, expElements);\n+\n+        var list3 = Arrays.asList(mapView.toArray());\n+        assertEquals(list3, expElements);\n+\n+        var list4 = Arrays.asList(mapView.toArray(new Object[0]));\n+        assertEquals(list4, expElements);\n+\n+        var list5 = Arrays.asList(mapView.toArray(Object[]::new));\n+        assertEquals(list5, expElements);\n+\n+        var list6 = mapView.stream().toList();\n+        assertEquals(list6, expElements);\n+\n+        var list7 = mapView.parallelStream().toList();\n+        assertEquals(list7, expElements);\n+\n+        assertEquals(mapView.size(), expElements.size());\n+        assertEquals(mapView.isEmpty(), expElements.isEmpty());\n+\n+        for (var k : expElements) {\n+            assertTrue(mapView.contains(k));\n+        }\n+\n+        var it = mapView.iterator();\n+        if (expElements.isEmpty()) {\n+            assertFalse(it.hasNext());\n+        } else {\n+            assertTrue(it.hasNext());\n+            assertEquals(it.next(), expElements.get(0));\n+        }\n+    }\n+\n+    \/**\n+     * Check the sequenced entrySet, keySet, or values view of a SequencedMap in one direction.\n+     *\n+     * @param <T> the element type of the view\n+     * @param mapView the actual map view\n+     * @param expElements list of the expected elements\n+     *\/\n+    public <T> void checkSeqView1(SequencedCollection<T> mapView, List<T> expElements) {\n+        checkView1(mapView, expElements);\n+\n+        if (expElements.isEmpty()) {\n+            assertThrows(NoSuchElementException.class, () -> mapView.getFirst());\n+            assertThrows(NoSuchElementException.class, () -> mapView.getLast());\n+        } else {\n+            assertEquals(mapView.getFirst(), expElements.get(0));\n+            assertEquals(mapView.getLast(), expElements.get(expElements.size() - 1));\n+        }\n+    }\n+\n+    \/**\n+     * Check the keySet and sequencedKeySet views of a map. It's possible to unify this with\n+     * the corresponding checks for values and entrySet views, but doing this adds a bunch\n+     * of generics and method references that tend to obscure more than they help.\n+     *\n+     * @param map the SequencedMap under test\n+     * @param refEntries expected contents of the map\n+     *\/\n+    public void checkKeySet(SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> refEntries) {\n+        List<String> refKeys = refEntries.stream().map(Map.Entry::getKey).toList();\n+        List<String> rrefKeys = new ArrayList<>(refKeys);\n+        Collections.reverse(rrefKeys);\n+        SequencedMap<String, Integer> rmap = map.reversed();\n+\n+        checkView1(map.keySet(), refKeys);\n+        checkSeqView1(map.sequencedKeySet(), refKeys);\n+        checkSeqView1(map.sequencedKeySet().reversed(), rrefKeys);\n+\n+        checkView1(rmap.keySet(), rrefKeys);\n+        checkSeqView1(rmap.sequencedKeySet(), rrefKeys);\n+        checkSeqView1(rmap.sequencedKeySet().reversed(), refKeys);\n+\n+        checkView1(rmap.reversed().keySet(), refKeys);\n+        checkSeqView1(rmap.reversed().sequencedKeySet(), refKeys);\n+        checkSeqView1(rmap.reversed().sequencedKeySet().reversed(), rrefKeys);\n+    }\n+\n+    \/**\n+     * Check the values and sequencedValues views of a map.\n+     *\n+     * @param map the SequencedMap under test\n+     * @param refEntries expected contents of the map\n+     *\/\n+    public void checkValues(SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> refEntries) {\n+        List<Integer> refValues = refEntries.stream().map(Map.Entry::getValue).toList();\n+        List<Integer> rrefValues = new ArrayList<>(refValues);\n+        Collections.reverse(rrefValues);\n+        SequencedMap<String, Integer> rmap = map.reversed();\n+\n+        checkView1(map.values(), refValues);\n+        checkSeqView1(map.sequencedValues(), refValues);\n+        checkSeqView1(map.sequencedValues().reversed(), rrefValues);\n+\n+        checkView1(rmap.values(), rrefValues);\n+        checkSeqView1(rmap.sequencedValues(), rrefValues);\n+        checkSeqView1(rmap.sequencedValues().reversed(), refValues);\n+\n+        checkView1(rmap.reversed().values(), refValues);\n+        checkSeqView1(rmap.reversed().sequencedValues(), refValues);\n+        checkSeqView1(rmap.reversed().sequencedValues().reversed(), rrefValues);\n+    }\n+\n+    \/**\n+     * Check the entrySet and sequencedEntrySet views of a map.\n+     *\n+     * @param map the SequencedMap under test\n+     * @param refEntries expected contents of the map\n+     *\/\n+    public void checkEntrySet(SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> refEntries) {\n+        List<Map.Entry<String, Integer>> rref = new ArrayList<>(refEntries);\n+        Collections.reverse(rref);\n+        SequencedMap<String, Integer> rmap = map.reversed();\n+\n+        checkView1(map.entrySet(), refEntries);\n+        checkSeqView1(map.sequencedEntrySet(), refEntries);\n+        checkSeqView1(map.sequencedEntrySet().reversed(), rref);\n+\n+        checkView1(rmap.entrySet(), rref);\n+        checkSeqView1(rmap.sequencedEntrySet(), rref);\n+        checkSeqView1(rmap.sequencedEntrySet().reversed(), refEntries);\n+\n+        checkView1(rmap.reversed().entrySet(), refEntries);\n+        checkSeqView1(rmap.reversed().sequencedEntrySet(), refEntries);\n+        checkSeqView1(rmap.reversed().sequencedEntrySet().reversed(), rref);\n+    }\n+\n+    \/**\n+     * Test attempted modifications to unmodifiable map views. The only mutating operation\n+     * map views can support is removal.\n+     *\n+     * @param <T> element type of the map view\n+     * @param view the map view\n+     *\/\n+    public <T> void checkUnmodifiableView(Collection<T> view) {\n+        assertThrows(UOE, () -> view.clear());\n+        assertThrows(UOE, () -> { var it = view.iterator(); it.next(); it.remove(); });\n+        assertThrows(UOE, () -> { var t = view.iterator().next(); view.remove(t); });\n+\n+\/\/ TODO these ops should throw unconditionally, but they don't in some implementations\n+     \/\/ assertThrows(UOE, () -> view.removeAll(List.of()));\n+     \/\/ assertThrows(UOE, () -> view.removeIf(x -> false));\n+     \/\/ assertThrows(UOE, () -> view.retainAll(view));\n+        assertThrows(UOE, () -> view.removeAll(view));\n+        assertThrows(UOE, () -> view.removeIf(x -> true));\n+        assertThrows(UOE, () -> view.retainAll(List.of()));\n+    }\n+\n+    \/**\n+     * Test removal methods on unmodifiable sequenced map views.\n+     *\n+     * @param <T> element type of the map view\n+     * @param view the map view\n+     *\/\n+    public <T> void checkUnmodifiableSeqView(SequencedCollection<T> view) {\n+        checkUnmodifiableView(view);\n+        assertThrows(UOE, () -> view.removeFirst());\n+        assertThrows(UOE, () -> view.removeLast());\n+\n+        var rview = view.reversed();\n+        checkUnmodifiableView(rview);\n+        assertThrows(UOE, () -> rview.removeFirst());\n+        assertThrows(UOE, () -> rview.removeLast());\n+    }\n+\n+    public void checkUnmodifiableEntry(SequencedMap<String, Integer> map) {\n+        assertThrows(UOE, () -> { map.firstEntry().setValue(99); });\n+        assertThrows(UOE, () -> { map.lastEntry().setValue(99); });\n+        assertThrows(UOE, () -> { map.sequencedEntrySet().getFirst().setValue(99); });\n+        assertThrows(UOE, () -> { map.sequencedEntrySet().getLast().setValue(99); });\n+        assertThrows(UOE, () -> { map.sequencedEntrySet().reversed().getFirst().setValue(99); });\n+        assertThrows(UOE, () -> { map.sequencedEntrySet().reversed().getLast().setValue(99); });\n+    }\n+\n+    public void checkUnmodifiable1(SequencedMap<String, Integer> map) {\n+        assertThrows(UOE, () -> map.putFirst(\"x\", 99));\n+        assertThrows(UOE, () -> map.putLast(\"x\", 99));\n+        assertThrows(UOE, () -> { map.pollFirstEntry(); });\n+        assertThrows(UOE, () -> { map.pollLastEntry(); });\n+\n+        checkUnmodifiableEntry(map);\n+        checkUnmodifiableView(map.keySet());\n+        checkUnmodifiableView(map.values());\n+        checkUnmodifiableView(map.entrySet());\n+        checkUnmodifiableSeqView(map.sequencedKeySet());\n+        checkUnmodifiableSeqView(map.sequencedValues());\n+        checkUnmodifiableSeqView(map.sequencedEntrySet());\n+    }\n+\n+    public void checkUnmodifiable(SequencedMap<String, Integer> map) {\n+        checkUnmodifiable1(map);\n+        checkUnmodifiable1(map.reversed());\n+    }\n+\n+    \/\/ The putFirst\/putLast operations aren't tested here, because the only instances of\n+    \/\/ checked, sequenced maps are SortedMap and NavigableMap, which don't support them.\n+    public void checkChecked(SequencedMap<String, Integer> map) {\n+        SequencedMap<Object, Object> objMap = (SequencedMap<Object, Object>)(SequencedMap)map;\n+        assertThrows(CCE, () -> { objMap.put(new Object(), 99); });\n+        assertThrows(CCE, () -> { objMap.put(\"x\", new Object()); });\n+        assertThrows(CCE, () -> { objMap.sequencedEntrySet().getFirst().setValue(new Object()); });\n+        assertThrows(CCE, () -> { objMap.sequencedEntrySet().reversed().getFirst().setValue(new Object()); });\n+        assertThrows(CCE, () -> { objMap.reversed().put(new Object(), 99); });\n+        assertThrows(CCE, () -> { objMap.reversed().put(\"x\", new Object()); });\n+        assertThrows(CCE, () -> { objMap.reversed().sequencedEntrySet().getFirst().setValue(new Object()); });\n+        assertThrows(CCE, () -> { objMap.reversed().sequencedEntrySet().reversed().getFirst().setValue(new Object()); });\n+    }\n+\n+    \/\/ ========== Tests ==========\n+\n+    @Test(dataProvider=\"all\")\n+    public void testFundamentals(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        checkContents(map, ref);\n+        checkEntrySet(map, ref);\n+        checkKeySet(map, ref);\n+        checkValues(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"populated\")\n+    public void testFirstEntry(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        assertEquals(map.firstEntry(), ref.get(0));\n+        assertEquals(map.reversed().firstEntry(), ref.get(ref.size() - 1));\n+        assertThrows(UOE, () -> { map.firstEntry().setValue(99); });\n+        assertThrows(UOE, () -> { map.reversed().firstEntry().setValue(99); });\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"populated\")\n+    public void testLastEntry(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        assertEquals(map.lastEntry(), ref.get(ref.size() - 1));\n+        assertEquals(map.reversed().lastEntry(), ref.get(0));\n+        assertThrows(UOE, () -> { map.lastEntry().setValue(99); });\n+        assertThrows(UOE, () -> { map.reversed().lastEntry().setValue(99); });\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"empties\")\n+    public void testEmptyFirstEntry(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        assertNull(map.firstEntry());\n+        assertNull(map.reversed().firstEntry());\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"empties\")\n+    public void testEmptyLastEntry(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        assertNull(map.lastEntry());\n+        assertNull(map.reversed().lastEntry());\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"puts\")\n+    public void testPutFirst(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(0, Map.entry(\"x\", 99));\n+        map.putFirst(\"x\", 99);\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"puts\")\n+    public void testPutFirstRev(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(Map.entry(\"x\", 99));\n+        map.reversed().putFirst(\"x\", 99);\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"puts\")\n+    public void testPutLast(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(Map.entry(\"x\", 99));\n+        map.putLast(\"x\", 99);\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"puts\")\n+    public void testPutLastRev(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(0, Map.entry(\"x\", 99));\n+        map.reversed().putLast(\"x\", 99);\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"putThrows\")\n+    public void testPutThrows(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        assertThrows(UOE, () -> map.putFirst(\"x\", 99));\n+        assertThrows(UOE, () -> map.putLast(\"x\", 99));\n+        assertThrows(UOE, () -> map.reversed().putFirst(\"x\", 99));\n+        assertThrows(UOE, () -> map.reversed().putLast(\"x\", 99));\n+        checkContents(map, baseref);\n+    }\n+\n+    @Test(dataProvider=\"polls\")\n+    public void testPollFirst(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var act = map.pollFirstEntry();\n+        assertEquals(act, ref.remove(0));\n+        assertThrows(UOE, () -> { act.setValue(99); });\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"polls\")\n+    public void testPollFirstRev(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var act = map.reversed().pollFirstEntry();\n+        assertEquals(act, ref.remove(ref.size() - 1));\n+        assertThrows(UOE, () -> { act.setValue(99); });\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"polls\")\n+    public void testPollLast(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var act = map.pollLastEntry();\n+        assertEquals(act, ref.remove(ref.size() - 1));\n+        assertThrows(UOE, () -> { act.setValue(99); });\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"polls\")\n+    public void testPollLastRev(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var act = map.reversed().pollLastEntry();\n+        assertEquals(act, ref.remove(0));\n+        assertThrows(UOE, () -> { act.setValue(99); });\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"emptyPolls\")\n+    public void testEmptyPollFirst(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        assertNull(map.pollFirstEntry());\n+        assertNull(map.reversed().pollFirstEntry());\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"emptyPolls\")\n+    public void testEmptyPollLast(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        assertNull(map.pollLastEntry());\n+        assertNull(map.reversed().pollLastEntry());\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"serializable\")\n+    public void testSerializable(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref)\n+        throws ClassNotFoundException, IOException\n+    {\n+        var baos = new ByteArrayOutputStream();\n+        try (var oos = new ObjectOutputStream(baos)) {\n+            oos.writeObject(map);\n+        }\n+\n+        try (var bais = new ByteArrayInputStream(baos.toByteArray());\n+             var ois = new ObjectInputStream(bais)) {\n+            var map2 = (SequencedMap<String, Integer>) ois.readObject();\n+            checkContents(map2, ref);\n+        }\n+    }\n+\n+    @Test(dataProvider=\"notSerializable\")\n+    public void testNotSerializable(String label, SequencedMap<String, Integer> map)\n+        throws ClassNotFoundException, IOException\n+    {\n+        var baos = new ByteArrayOutputStream();\n+        try (var oos = new ObjectOutputStream(baos)) {\n+            assertThrows(ObjectStreamException.class, () -> oos.writeObject(map));\n+        }\n+    }\n+\n+    @Test(dataProvider=\"doubleReverse\")\n+    public void testDoubleReverse(String label, SequencedMap<String, Integer> map) {\n+        var rrmap = map.reversed().reversed();\n+        assertSame(rrmap, map);\n+    }\n+\n+    @Test(dataProvider=\"unmodifiable\")\n+    public void testUnmodifiable(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        checkUnmodifiable(map);\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"checked\")\n+    public void testChecked(String label, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> ref) {\n+        checkChecked(map);\n+        checkContents(map, ref);\n+    }\n+\n+    \/**\n+     * Test that a removal from the sequenedKeySet view is properly reflected in the original\n+     * backing map. The mode value indicates whether the backing map is reversed, whether the\n+     * sequencedKeySet view is reversed, and whether the removeFirst or removeLast is called\n+     * on the view. See the viewRemoves() dataProvider for details.\n+     *\n+     * @param label the implementation label\n+     * @param mode reversed and first\/last modes\n+     * @param map the original map instance\n+     * @param baseref reference contents of the original map\n+     *\/\n+    @Test(dataProvider=\"viewRemoves\")\n+    public void testKeySetRemoves(String label,\n+                                  int mode,\n+                                  SequencedMap<String, Integer> map,\n+                                  List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var exp = (refLast(mode) ? ref.remove(ref.size() - 1) : ref.remove(0)).getKey();\n+        var tempmap = reverseMap(mode) ? map.reversed() : map;\n+        var keySet = reverseView(mode) ? tempmap.sequencedKeySet().reversed() : tempmap.sequencedKeySet();\n+        var act = callLast(mode) ? keySet.removeLast() : keySet.removeFirst();\n+        assertEquals(act, exp);\n+        checkContents(map, ref);\n+    }\n+\n+    \/\/ As above, but for the sequencedValues view.\n+    @Test(dataProvider=\"viewRemoves\")\n+    public void testValuesRemoves(String label,\n+                                  int mode,\n+                                  SequencedMap<String, Integer> map,\n+                                  List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var exp = (refLast(mode) ? ref.remove(ref.size() - 1) : ref.remove(0)).getValue();\n+        var tempmap = reverseMap(mode) ? map.reversed() : map;\n+        var values = reverseView(mode) ? tempmap.sequencedValues().reversed() : tempmap.sequencedValues();\n+        var act = callLast(mode) ? values.removeLast() : values.removeFirst();\n+        assertEquals(act, exp);\n+        checkContents(map, ref);\n+    }\n+\n+    \/\/ As above, but for the sequencedEntrySet view.\n+    @Test(dataProvider=\"viewRemoves\")\n+    public void testEntrySetRemoves(String label,\n+                                    int mode,\n+                                    SequencedMap<String, Integer> map,\n+                                    List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        var exp = refLast(mode) ? ref.remove(ref.size() - 1) : ref.remove(0);\n+        var tempmap = reverseMap(mode) ? map.reversed() : map;\n+        var entrySet = reverseView(mode) ? tempmap.sequencedEntrySet().reversed() : tempmap.sequencedEntrySet();\n+        var act = callLast(mode) ? entrySet.removeLast() : entrySet.removeFirst();\n+        assertEquals(act, exp);\n+        checkContents(map, ref);\n+    }\n+\n+    \/\/ As above, but for the sequencedKeySet of an empty map.\n+    @Test(dataProvider=\"emptyViewRemoves\")\n+    public void testEmptyKeySetRemoves(String label,\n+                                       int mode,\n+                                       SequencedMap<String, Integer> map,\n+                                       List<Map.Entry<String, Integer>> baseref) {\n+        var tempmap = reverseMap(mode) ? map.reversed() : map;\n+        var keySet = reverseView(mode) ? tempmap.sequencedKeySet().reversed() : tempmap.sequencedKeySet();\n+        if (callLast(mode))\n+            assertThrows(NSEE, () -> keySet.removeLast());\n+        else\n+            assertThrows(NSEE, () -> keySet.removeFirst());\n+        checkContents(map, baseref);\n+\n+    }\n+\n+    \/\/ As above, but for the sequencedValues view.\n+    @Test(dataProvider=\"emptyViewRemoves\")\n+    public void testEmptyValuesRemoves(String label,\n+                                       int mode,\n+                                       SequencedMap<String, Integer> map,\n+                                       List<Map.Entry<String, Integer>> baseref) {\n+        var tempmap = reverseMap(mode) ? map.reversed() : map;\n+        var values = reverseView(mode) ? tempmap.sequencedValues().reversed() : tempmap.sequencedValues();\n+        if (callLast(mode))\n+            assertThrows(NSEE, () -> values.removeLast());\n+        else\n+            assertThrows(NSEE, () -> values.removeFirst());\n+        checkContents(map, baseref);\n+    }\n+\n+    \/\/ As above, but for the sequencedEntrySet view.\n+    @Test(dataProvider=\"emptyViewRemoves\")\n+    public void testEmptyEntrySetRemoves(String label,\n+                                         int mode,\n+                                         SequencedMap<String, Integer> map,\n+                                         List<Map.Entry<String, Integer>> baseref) {\n+        var tempmap = reverseMap(mode) ? map.reversed() : map;\n+        var entrySet = reverseView(mode) ? tempmap.sequencedEntrySet().reversed() : tempmap.sequencedEntrySet();\n+        if (callLast(mode))\n+            assertThrows(NSEE, () -> entrySet.removeLast());\n+        else\n+            assertThrows(NSEE, () -> entrySet.removeFirst());\n+        checkContents(map, baseref);\n+    }\n+\n+    \/\/ Test that addFirst\/addLast on the sequencedKeySetView throw UnsupportedOperationException.\n+    @Test(dataProvider=\"viewAddThrows\")\n+    public void testKeySetAddThrows(String label,\n+                                    int mode,\n+                                    SequencedMap<String, Integer> map,\n+                                    List<Map.Entry<String, Integer>> baseref) {\n+        var tempmap = reverseMap(mode) ? map.reversed() : map;\n+        var keySet = reverseView(mode) ? tempmap.sequencedKeySet().reversed() : tempmap.sequencedKeySet();\n+        if (callLast(mode))\n+            assertThrows(UOE, () -> keySet.addLast(\"x\"));\n+        else\n+            assertThrows(UOE, () -> keySet.addFirst(\"x\"));\n+        checkContents(map, baseref);\n+    }\n+\n+    \/\/ As above, but for the sequencedValues view.\n+    @Test(dataProvider=\"viewAddThrows\")\n+    public void testValuesAddThrows(String label,\n+                                    int mode,\n+                                    SequencedMap<String, Integer> map,\n+                                    List<Map.Entry<String, Integer>> baseref) {\n+        var tempmap = reverseMap(mode) ? map.reversed() : map;\n+        var values = reverseView(mode) ? tempmap.sequencedValues().reversed() : tempmap.sequencedValues();\n+        if (callLast(mode))\n+            assertThrows(UOE, () -> values.addLast(99));\n+        else\n+            assertThrows(UOE, () -> values.addFirst(99));\n+        checkContents(map, baseref);\n+    }\n+\n+    \/\/ As above, but for the sequencedEntrySet view.\n+    @Test(dataProvider=\"viewAddThrows\")\n+    public void testEntrySetAddThrows(String label,\n+                                      int mode,\n+                                      SequencedMap<String, Integer> map,\n+                                      List<Map.Entry<String, Integer>> baseref) {\n+        var tempmap = reverseMap(mode) ? map.reversed() : map;\n+        var entrySet = reverseView(mode) ? tempmap.sequencedEntrySet().reversed() : tempmap.sequencedEntrySet();\n+        if (callLast(mode))\n+            assertThrows(UOE, () -> entrySet.addLast(Map.entry(\"x\", 99)));\n+        else\n+            assertThrows(UOE, () -> entrySet.addFirst(Map.entry(\"x\", 99)));\n+        checkContents(map, baseref);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/BasicMap.java","additions":836,"deletions":0,"binary":false,"changes":836,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.*;\n+\n+\/**\n+ * A complete Deque implementation that inherits the reversed() method\n+ * from SequencedCollection. Useful for testing ReverseOrderDequeView.\n+ * Underlying implementation provided by ArrayDeque.\n+ *\/\n+public class SimpleDeque<E> implements Deque<E> {\n+\n+    final Deque<E> deque;\n+\n+    public SimpleDeque() {\n+        deque = new ArrayDeque<>();\n+    }\n+\n+    public SimpleDeque(Collection<? extends E> c) {\n+        deque = new ArrayDeque<>(c);\n+    }\n+\n+    \/\/ ========== Object ==========\n+\n+    public boolean equals(Object o) {\n+        return deque.equals(o);\n+    }\n+\n+    public int hashCode() {\n+        return deque.hashCode();\n+    }\n+\n+    public String toString() {\n+        return deque.toString();\n+    }\n+\n+    \/\/ ========== Collection ==========\n+\n+    public boolean add(E e) {\n+        return deque.add(e);\n+    }\n+\n+    public boolean addAll(Collection<? extends E> c) {\n+        return deque.addAll(c);\n+    }\n+\n+    public void clear() {\n+        deque.clear();\n+    }\n+\n+    public boolean contains(Object o) {\n+        return deque.contains(o);\n+    }\n+\n+    public boolean containsAll(Collection<?> c) {\n+        return deque.containsAll(c);\n+    }\n+\n+    public boolean isEmpty() {\n+        return deque.isEmpty();\n+    }\n+\n+    public Iterator<E> iterator() {\n+        return deque.iterator();\n+    }\n+\n+    public boolean remove(Object o) {\n+        return deque.remove(o);\n+    }\n+\n+    public boolean removeAll(Collection<?> c) {\n+        return deque.removeAll(c);\n+    }\n+\n+    public boolean retainAll(Collection<?> c) {\n+        return deque.retainAll(c);\n+    }\n+\n+    public int size() {\n+        return deque.size();\n+    }\n+\n+    public Object[] toArray() {\n+        return deque.toArray();\n+    }\n+\n+    public <T> T[] toArray(T[] a) {\n+        return deque.toArray(a);\n+    }\n+\n+    \/\/ ========== Deque ==========\n+\n+    public void addFirst(E e) {\n+        deque.addFirst(e);\n+    }\n+\n+    public void addLast(E e) {\n+        deque.addLast(e);\n+    }\n+\n+    public boolean offerFirst(E e) {\n+        return deque.offerFirst(e);\n+    }\n+\n+    public boolean offerLast(E e) {\n+        return deque.offerLast(e);\n+    }\n+\n+    public E removeFirst() {\n+        return deque.removeFirst();\n+    }\n+\n+    public E removeLast() {\n+        return deque.removeLast();\n+    }\n+\n+    public E pollFirst() {\n+        return deque.pollFirst();\n+    }\n+\n+    public E pollLast() {\n+        return deque.pollLast();\n+    }\n+\n+    public E getFirst() {\n+        return deque.getFirst();\n+    }\n+\n+    public E getLast() {\n+        return deque.getLast();\n+    }\n+\n+    public E peekFirst() {\n+        return deque.peekFirst();\n+    }\n+\n+    public E peekLast() {\n+        return deque.peekLast();\n+    }\n+\n+    public boolean removeFirstOccurrence(Object o) {\n+        return deque.removeFirstOccurrence(o);\n+    }\n+\n+    public boolean removeLastOccurrence(Object o) {\n+        return deque.removeLastOccurrence(o);\n+    }\n+\n+    public boolean offer(E e) {\n+        return deque.offer(e);\n+    }\n+\n+    public E remove() {\n+        return deque.remove();\n+    }\n+\n+    public E poll() {\n+        return deque.poll();\n+    }\n+\n+    public E element() {\n+        return deque.element();\n+    }\n+\n+    public E peek() {\n+        return deque.peek();\n+    }\n+\n+    public void push(E e) {\n+        deque.push(e);\n+    }\n+\n+    public E pop() {\n+        return deque.pop();\n+    }\n+\n+    public Iterator<E> descendingIterator() {\n+        return deque.descendingIterator();\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/SimpleDeque.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.*;\n+\n+\/**\n+ * A complete List implementation that inherits the reversed() method\n+ * from List. Useful for testing ReverseOrderListView.\n+ * Underlying implementation provided by ArrayList.\n+ *\/\n+public class SimpleList<E> implements List<E> {\n+\n+    final List<E> list;\n+\n+    public SimpleList() {\n+        list = new ArrayList<>();\n+    }\n+\n+    public SimpleList(Collection<? extends E> c) {\n+        list = new ArrayList<>(c);\n+    }\n+\n+    \/\/ ========== Object ==========\n+\n+    public boolean equals(Object o) {\n+        return list.equals(o);\n+    }\n+\n+    public int hashCode() {\n+        return list.hashCode();\n+    }\n+\n+    public String toString() {\n+        return list.toString();\n+    }\n+\n+    \/\/ ========== Collection ==========\n+\n+    public boolean add(E e) {\n+        return list.add(e);\n+    }\n+\n+    public boolean addAll(Collection<? extends E> c) {\n+        return list.addAll(c);\n+    }\n+\n+    public void clear() {\n+        list.clear();\n+    }\n+\n+    public boolean contains(Object o) {\n+        return list.contains(o);\n+    }\n+\n+    public boolean containsAll(Collection<?> c) {\n+        return list.containsAll(c);\n+    }\n+\n+    public boolean isEmpty() {\n+        return list.isEmpty();\n+    }\n+\n+    public Iterator<E> iterator() {\n+        return list.iterator();\n+    }\n+\n+    public boolean remove(Object o) {\n+        return list.remove(o);\n+    }\n+\n+    public boolean removeAll(Collection<?> c) {\n+        return list.removeAll(c);\n+    }\n+\n+    public boolean retainAll(Collection<?> c) {\n+        return list.retainAll(c);\n+    }\n+\n+    public int size() {\n+        return list.size();\n+    }\n+\n+    public Object[] toArray() {\n+        return list.toArray();\n+    }\n+\n+    public <T> T[] toArray(T[] a) {\n+        return list.toArray(a);\n+    }\n+\n+    \/\/ ========== List ==========\n+\n+    public void add(int index, E element) {\n+        list.add(index, element);\n+    }\n+\n+    public boolean addAll(int index, Collection<? extends E> c) {\n+        return list.addAll(index, c);\n+    }\n+\n+    public E get(int index) {\n+        return list.get(index);\n+    }\n+\n+    public int indexOf(Object o) {\n+        return list.indexOf(o);\n+    }\n+\n+    public int lastIndexOf(Object o) {\n+        return list.lastIndexOf(o);\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return list.listIterator();\n+    }\n+\n+    public ListIterator<E> listIterator(int index) {\n+        return list.listIterator(index);\n+    }\n+\n+    public E remove(int index) {\n+        return list.remove(index);\n+    }\n+\n+    public E set(int index, E element) {\n+        return list.set(index, element);\n+    }\n+\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        return list.subList(fromIndex, toIndex);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/SimpleList.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.*;\n+\n+\/**\n+ * A SortedMap implementation that does not implement NavigableMap. Useful for\n+ * testing ReverseOrderSortedMapView. Underlying implementation provided by TreeMap.\n+ *\/\n+public class SimpleSortedMap<K,V> implements SortedMap<K,V> {\n+    final SortedMap<K,V> map;\n+\n+    public SimpleSortedMap() {\n+        map = new TreeMap<>();\n+    }\n+\n+    public SimpleSortedMap(Comparator<? super K> comparator) {\n+        map = new TreeMap<>(comparator);\n+    }\n+\n+    public SimpleSortedMap(Map<? extends K,? extends V> m) {\n+        map = new TreeMap<>(m);\n+    }\n+\n+    \/\/ ========== Object ==========\n+\n+    public boolean equals(Object o) {\n+        return map.equals(o);\n+    }\n+\n+    public int hashCode() {\n+        return map.hashCode();\n+    }\n+\n+    public String toString() {\n+        return map.toString();\n+    }\n+\n+    \/\/ ========== Map ==========\n+\n+    public void clear() {\n+        map.clear();\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        return map.containsKey(key);\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        return map.containsValue(value);\n+    }\n+\n+    public Set<Map.Entry<K,V>> entrySet() {\n+        return map.entrySet();\n+    }\n+\n+    public V get(Object key) {\n+        return map.get(key);\n+    }\n+\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    public Set<K> keySet() {\n+        return map.keySet();\n+    }\n+\n+    public V put(K key, V value) {\n+        return map.put(key, value);\n+    }\n+\n+    public void putAll(Map<? extends K,? extends V> m) {\n+        map.putAll(m);\n+    }\n+\n+    public V remove(Object key) {\n+        return map.remove(key);\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    public Collection<V> values() {\n+        return map.values();\n+    }\n+\n+    \/\/ ========== SortedMap ==========\n+\n+    public Comparator<? super K> comparator() {\n+        return map.comparator();\n+    }\n+\n+    public K firstKey() {\n+        return map.firstKey();\n+    }\n+\n+    public SortedMap<K,V> headMap(K toKey) {\n+        return map.headMap(toKey);\n+    }\n+\n+    public K lastKey() {\n+        return map.lastKey();\n+    }\n+\n+    public SortedMap<K,V> subMap(K fromKey, K toKey) {\n+        return map.subMap(fromKey, toKey);\n+    }\n+\n+    public SortedMap<K,V> tailMap(K fromKey) {\n+        return map.tailMap(fromKey);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/SimpleSortedMap.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.*;\n+\n+\/**\n+ * A SortedSet implementation that does not implement NavigableSet. Useful for\n+ * testing ReverseOrderSortedSetView. Underlying implementation provided by TreeSet.\n+ *\/\n+public class SimpleSortedSet<E> implements SortedSet<E> {\n+\n+    final SortedSet<E> set;\n+\n+    public SimpleSortedSet() {\n+        set = new TreeSet<E>();\n+    }\n+\n+    public SimpleSortedSet(Collection<? extends E> c) {\n+        set = new TreeSet<>(c);\n+    }\n+\n+    public SimpleSortedSet(Comparator<? super E> comparator) {\n+        set = new TreeSet<>(comparator);\n+    }\n+\n+    \/\/ ========== Object ==========\n+\n+    public boolean equals(Object o) {\n+        return set.equals(o);\n+    }\n+\n+    public int hashCode() {\n+        return set.hashCode();\n+    }\n+\n+    public String toString() {\n+        return set.toString();\n+    }\n+\n+    \/\/ ========== Collection ==========\n+\n+    public boolean add(E e) {\n+        return set.add(e);\n+    }\n+\n+    public boolean addAll(Collection<? extends E> c) {\n+        return set.addAll(c);\n+    }\n+\n+    public void clear() {\n+        set.clear();\n+    }\n+\n+    public boolean contains(Object o) {\n+        return set.contains(o);\n+    }\n+\n+    public boolean containsAll(Collection<?> c) {\n+        return set.containsAll(c);\n+    }\n+\n+    public boolean isEmpty() {\n+        return set.isEmpty();\n+    }\n+\n+    public Iterator<E> iterator() {\n+        return set.iterator();\n+    }\n+\n+    public boolean remove(Object o) {\n+        return set.remove(o);\n+    }\n+\n+    public boolean removeAll(Collection<?> c) {\n+        return set.removeAll(c);\n+    }\n+\n+    public boolean retainAll(Collection<?> c) {\n+        return set.retainAll(c);\n+    }\n+\n+    public int size() {\n+        return set.size();\n+    }\n+\n+    public Object[] toArray() {\n+        return set.toArray();\n+    }\n+\n+    public <T> T[] toArray(T[] a) {\n+        return set.toArray(a);\n+    }\n+\n+    \/\/ ========== SortedSet ==========\n+\n+    public Comparator<? super E> comparator() {\n+        return set.comparator();\n+    }\n+\n+    public E first() {\n+        return set.first();\n+    }\n+\n+    public SortedSet<E> headSet(E toElement) {\n+        return set.headSet(toElement);\n+    }\n+\n+    public E last() {\n+        return set.last();\n+    }\n+\n+    public SortedSet<E> subSet(E fromElement, E toElement) {\n+        return set.subSet(fromElement, toElement);\n+    }\n+\n+    public SortedSet<E> tailSet(E fromElement) {\n+        return set.tailSet(fromElement);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/SimpleSortedSet.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266571\n+ * @modules java.base\/jdk.internal.util\n+ * @run testng Reverse\n+ * @summary Tests for ArraysSupport.reverse\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertSame;\n+\n+import java.util.Arrays;\n+import jdk.internal.util.ArraysSupport;\n+\n+public class Reverse {\n+    @DataProvider(name = \"data\")\n+    public Object[][] data() {\n+        return new Object[][][] {\n+            \/\/ pairs of actual, expected\n+            {\n+                { },\n+                { }\n+            }, {\n+                { \"a\" },\n+                { \"a\" }\n+            }, {\n+                { \"a\", \"b\" },\n+                { \"b\", \"a\" }\n+            }, {\n+                { \"a\", \"b\", \"c\" },\n+                { \"c\", \"b\", \"a\" }\n+            }, {\n+                { \"a\", \"b\", \"c\", \"d\" },\n+                { \"d\", \"c\", \"b\", \"a\" }\n+            }, {\n+                { \"a\", \"b\", \"c\", \"d\", \"e\" },\n+                { \"e\", \"d\", \"c\", \"b\", \"a\" }\n+            }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"data\")\n+    public void testReverse(Object[] actual, Object[] expected) {\n+        Object[] r = ArraysSupport.reverse(actual);\n+        assertSame(r, actual);\n+        assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            assertEquals(actual[i], expected[i],\n+                \"mismatch: actual=\" + Arrays.asList(actual) +\n+                \" expected=\" + Arrays.asList(expected) + \" at index \" + i);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/util\/ArraysSupport\/Reverse.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-        check(numParseTypeElements, \"#parseTypeElements\", 158);\n+        check(numParseTypeElements, \"#parseTypeElements\", 180);\n","filename":"test\/langtools\/tools\/javac\/api\/TestJavacTaskScanner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-        \"java.util.Collection\"\n+        \"java.util.SequencedCollection\"\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/type\/BoundsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}