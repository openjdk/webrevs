{"files":[{"patch":"@@ -32,0 +32,1 @@\n+class SerializeClosure;\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/classFileParser.hpp\"\n+#include \"classfile\/classFileStream.hpp\"\n+#include \"classfile\/classLoadInfo.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"jfr\/instrumentation\/jfrClassTransformer.hpp\"\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"prims\/jvmtiRedefineClasses.hpp\"\n+#include \"prims\/jvmtiThreadState.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+static void log_pending_exception(oop throwable) {\n+  assert(throwable != nullptr, \"invariant\");\n+  oop msg = java_lang_Throwable::message(throwable);\n+  if (msg != nullptr) {\n+    char* text = java_lang_String::as_utf8_string(msg);\n+    if (text != nullptr) {\n+      log_error(jfr, system) (\"%s\", text);\n+    }\n+  }\n+}\n+\n+\/\/ On initial class load.\n+void JfrClassTransformer::cache_class_file_data(InstanceKlass* new_ik, const ClassFileStream* new_stream, const JavaThread* thread) {\n+  assert(new_ik != nullptr, \"invariant\");\n+  assert(new_stream != nullptr, \"invariant\");\n+  assert(thread != nullptr, \"invariant\");\n+  assert(!thread->has_pending_exception(), \"invariant\");\n+  if (!JfrOptionSet::allow_retransforms()) {\n+    return;\n+  }\n+  const jint stream_len = new_stream->length();\n+  JvmtiCachedClassFileData* p =\n+    (JvmtiCachedClassFileData*)NEW_C_HEAP_ARRAY_RETURN_NULL(u1, offset_of(JvmtiCachedClassFileData, data) + stream_len, mtInternal);\n+  if (p == nullptr) {\n+    log_error(jfr, system)(\"Allocation using C_HEAP_ARRAY for %zu bytes failed in JfrEventClassTransformer::cache_class_file_data\",\n+      static_cast<size_t>(offset_of(JvmtiCachedClassFileData, data) + stream_len));\n+    return;\n+  }\n+  p->length = stream_len;\n+  memcpy(p->data, new_stream->buffer(), stream_len);\n+  new_ik->set_cached_class_file(p);\n+}\n+\n+InstanceKlass* JfrClassTransformer::create_instance_klass(InstanceKlass*& ik, ClassFileStream* stream, bool is_initial_load, JavaThread* thread) {\n+  if (stream == nullptr) {\n+    if (is_initial_load) {\n+      log_error(jfr, system)(\"JfrClassTransformer: unable to create ClassFileStream for %s\", ik->external_name());\n+    }\n+    return nullptr;\n+  }\n+  InstanceKlass* const new_ik = create_new_instance_klass(ik, stream, thread);\n+  if (new_ik == nullptr) {\n+    if (is_initial_load) {\n+      log_error(jfr, system)(\"JfrClassTransformer: unable to create InstanceKlass for %s\", ik->external_name());\n+    }\n+  }\n+  return new_ik;\n+}\n+\n+void JfrClassTransformer::copy_traceid(const InstanceKlass* ik, const InstanceKlass* new_ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(new_ik != nullptr, \"invariant\");\n+  new_ik->set_trace_id(ik->trace_id());\n+  assert(TRACE_ID(ik) == TRACE_ID(new_ik), \"invariant\");\n+}\n+\n+InstanceKlass* JfrClassTransformer::create_new_instance_klass(InstanceKlass* ik, ClassFileStream* stream, TRAPS) {\n+  assert(stream != nullptr, \"invariant\");\n+  ResourceMark rm(THREAD);\n+  ClassLoaderData* const cld = ik->class_loader_data();\n+  Handle pd(THREAD, ik->protection_domain());\n+  Symbol* const class_name = ik->name();\n+  const char* const klass_name = class_name != nullptr ? class_name->as_C_string() : \"\";\n+  ClassLoadInfo cl_info(pd);\n+  ClassFileParser new_parser(stream,\n+                             class_name,\n+                             cld,\n+                             &cl_info,\n+                             ClassFileParser::INTERNAL, \/\/ internal visibility\n+                             THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    log_pending_exception(PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    return nullptr;\n+  }\n+  const ClassInstanceInfo* cl_inst_info = cl_info.class_hidden_info_ptr();\n+  InstanceKlass* const new_ik = new_parser.create_instance_klass(false, *cl_inst_info, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    log_pending_exception(PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    return nullptr;\n+  }\n+  assert(new_ik != nullptr, \"invariant\");\n+  assert(new_ik->name() != nullptr, \"invariant\");\n+  assert(strncmp(ik->name()->as_C_string(), new_ik->name()->as_C_string(), strlen(ik->name()->as_C_string())) == 0, \"invariant\");\n+  return new_ik;\n+}\n+\n+\/\/ Redefining \/ retransforming?\n+const Klass* JfrClassTransformer::find_existing_klass(const InstanceKlass* ik, JavaThread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(thread != nullptr, \"invariant\");\n+  JvmtiThreadState* const state = thread->jvmti_thread_state();\n+  if (state == nullptr) {\n+    return nullptr;\n+  }\n+  return state != nullptr ? klass_being_redefined(ik, state) : nullptr;\n+}\n+\n+const Klass* JfrClassTransformer::klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(state != nullptr, \"invariant\");\n+  const GrowableArray<Klass*>* const redef_klasses = state->get_classes_being_redefined();\n+  if (redef_klasses == nullptr || redef_klasses->is_empty()) {\n+    return nullptr;\n+  }\n+  for (int i = 0; i < redef_klasses->length(); ++i) {\n+    const Klass* const existing_klass = redef_klasses->at(i);\n+    assert(existing_klass != nullptr, \"invariant\");\n+    if (ik->name() == existing_klass->name() && ik->class_loader_data() == existing_klass->class_loader_data()) {\n+      \/\/ 'ik' is a scratch klass. Return the klass being redefined.\n+      return existing_klass;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+\/\/ On redefine \/ retransform, in case an agent modified the class, the original bytes are cached onto the scratch klass.\n+void JfrClassTransformer::transfer_cached_class_file_data(InstanceKlass* ik, InstanceKlass* new_ik, const ClassFileParser& parser, JavaThread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(new_ik != nullptr, \"invariant\");\n+  JvmtiCachedClassFileData* const p = ik->get_cached_class_file();\n+  if (p != nullptr) {\n+    new_ik->set_cached_class_file(p);\n+    ik->set_cached_class_file(nullptr);\n+    return;\n+  }\n+  \/\/ No cached classfile indicates that no agent modified the klass.\n+  \/\/ This means that the parser is holding the original bytes. Hence, we cache it onto the scratch klass.\n+  const ClassFileStream* const stream = parser.clone_stream();\n+  cache_class_file_data(new_ik, stream, thread);\n+}\n+\n+void JfrClassTransformer::rewrite_klass_pointer(InstanceKlass*& ik, InstanceKlass* new_ik, ClassFileParser& parser, const JavaThread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(new_ik != nullptr, \"invariant\");\n+  assert(thread != nullptr, \"invariant\");\n+  assert(TRACE_ID(ik) == TRACE_ID(new_ik), \"invariant\");\n+  assert(!thread->has_pending_exception(), \"invariant\");\n+  \/\/ Assign original InstanceKlass* back onto \"its\" parser object for proper destruction.\n+  parser.set_klass_to_deallocate(ik);\n+  \/\/ Finally rewrite the original pointer to the newly created InstanceKlass.\n+  ik = new_ik;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrClassTransformer.cpp","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_INSTRUMENTATION_JFRCLASSTRANSFORMER_HPP\n+#define SHARE_JFR_INSTRUMENTATION_JFRCLASSTRANSFORMER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+class ClassFileParser;\n+class ClassFileStream;\n+class InstanceKlass;\n+\n+\/*\n+ * Contains common functionality used by method and event instrumentation.\n+ *\/\n+class JfrClassTransformer : AllStatic {\n+ private:\n+  static InstanceKlass* create_new_instance_klass(InstanceKlass* ik, ClassFileStream* stream, TRAPS);\n+  static const Klass* klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state);\n+\n+ public:\n+  static const Klass* find_existing_klass(const InstanceKlass* ik, JavaThread* thread);\n+  static InstanceKlass* create_instance_klass(InstanceKlass*& ik, ClassFileStream* stream, bool is_initial_load, JavaThread* thread);\n+  static void copy_traceid(const InstanceKlass* ik, const InstanceKlass* new_ik);\n+  static void transfer_cached_class_file_data(InstanceKlass* ik, InstanceKlass* new_ik, const ClassFileParser& parser, JavaThread* thread);\n+  static void rewrite_klass_pointer(InstanceKlass*& ik, InstanceKlass* new_ik, ClassFileParser& parser, const JavaThread* thread);\n+  static void cache_class_file_data(InstanceKlass* new_ik, const ClassFileStream* new_stream, const JavaThread* thread);\n+};\n+\n+#endif \/\/ SHARE_JFR_INSTRUMENTATION_JFRCLASSTRANSFORMER_HPP\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrClassTransformer.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"classfile\/classLoadInfo.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"classfile\/verificationType.hpp\"\n@@ -35,1 +33,1 @@\n-#include \"jvm.h\"\n+#include \"jfr\/instrumentation\/jfrClassTransformer.hpp\"\n@@ -40,1 +38,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -42,0 +39,2 @@\n+#include \"jfr\/support\/jfrAnnotationElementIterator.hpp\"\n+#include \"jfr\/support\/jfrAnnotationIterator.hpp\"\n@@ -43,1 +42,0 @@\n-#include \"jfr\/utilities\/jfrBigEndian.hpp\"\n@@ -45,0 +43,1 @@\n+#include \"jvm.h\"\n@@ -49,1 +48,0 @@\n-#include \"oops\/constMethod.hpp\"\n@@ -53,2 +51,0 @@\n-#include \"prims\/jvmtiRedefineClasses.hpp\"\n-#include \"prims\/jvmtiThreadState.hpp\"\n@@ -58,1 +54,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -61,1 +56,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -169,37 +163,6 @@\n-\/*\n-  Annotation layout.\n-\n-  enum {  \/\/ initial annotation layout\n-    atype_off = 0,      \/\/ utf8 such as 'Ljava\/lang\/annotation\/Retention;'\n-    count_off = 2,      \/\/ u2   such as 1 (one value)\n-    member_off = 4,     \/\/ utf8 such as 'value'\n-    tag_off = 6,        \/\/ u1   such as 'c' (type) or 'e' (enum)\n-    e_tag_val = 'e',\n-    e_type_off = 7,   \/\/ utf8 such as 'Ljava\/lang\/annotation\/RetentionPolicy;'\n-    e_con_off = 9,    \/\/ utf8 payload, such as 'SOURCE', 'CLASS', 'RUNTIME'\n-    e_size = 11,     \/\/ end of 'e' annotation\n-    c_tag_val = 'c',    \/\/ payload is type\n-    c_con_off = 7,    \/\/ utf8 payload, such as 'I'\n-    c_size = 9,       \/\/ end of 'c' annotation\n-    s_tag_val = 's',    \/\/ payload is String\n-    s_con_off = 7,    \/\/ utf8 payload, such as 'Ljava\/lang\/String;'\n-    s_size = 9,\n-    min_size = 6        \/\/ smallest possible size (zero members)\n-  };\n-*\/\n-\n-static int skip_annotation_value(const address, int, int); \/\/ fwd decl\n-\n-\/\/ Skip an annotation.  Return >=limit if there is any problem.\n-static int next_annotation_index(const address buffer, int limit, int index) {\n-  assert(buffer != nullptr, \"invariant\");\n-  index += 2;  \/\/ skip atype\n-  if ((index += 2) >= limit) {\n-    return limit;\n-  }\n-  int nof_members = JfrBigEndian::read<int, u2>(buffer + index - 2);\n-  while (--nof_members >= 0 && index < limit) {\n-    index += 2; \/\/ skip member\n-    index = skip_annotation_value(buffer, limit, index);\n-  }\n-  return index;\n+static JfrAnnotationElementIterator elements_iterator(const InstanceKlass* ik, const JfrAnnotationIterator& it) {\n+  const address buffer = it.buffer();\n+  int current = it.current();\n+  int next = it.next();\n+  assert(current < next, \"invariant\");\n+  return JfrAnnotationElementIterator(ik, buffer + current, next - current);\n@@ -208,163 +171,0 @@\n-\/\/ Skip an annotation value.  Return >=limit if there is any problem.\n-static int skip_annotation_value(const address buffer, int limit, int index) {\n-  assert(buffer != nullptr, \"invariant\");\n-  \/\/ value := switch (tag:u1) {\n-  \/\/   case B, C, I, S, Z, D, F, J, c: con:u2;\n-  \/\/   case e: e_class:u2 e_name:u2;\n-  \/\/   case s: s_con:u2;\n-  \/\/   case [: do(nval:u2) {value};\n-  \/\/   case @: annotation;\n-  \/\/   case s: s_con:u2;\n-  \/\/ }\n-  if ((index += 1) >= limit) {\n-    return limit;\n-  }\n-  const u1 tag = buffer[index - 1];\n-  switch (tag) {\n-    case 'B':\n-    case 'C':\n-    case 'I':\n-    case 'S':\n-    case 'Z':\n-    case 'D':\n-    case 'F':\n-    case 'J':\n-    case 'c':\n-    case 's':\n-      index += 2;  \/\/ skip con or s_con\n-      break;\n-    case 'e':\n-      index += 4;  \/\/ skip e_class, e_name\n-      break;\n-    case '[':\n-      {\n-        if ((index += 2) >= limit) {\n-          return limit;\n-        }\n-        int nof_values = JfrBigEndian::read<int, u2>(buffer + index - 2);\n-        while (--nof_values >= 0 && index < limit) {\n-          index = skip_annotation_value(buffer, limit, index);\n-        }\n-      }\n-      break;\n-    case '@':\n-      index = next_annotation_index(buffer, limit, index);\n-      break;\n-    default:\n-      return limit;  \/\/  bad tag byte\n-  }\n-  return index;\n-}\n-\n-static constexpr const int number_of_elements_offset = 2;\n-static constexpr const int element_name_offset = number_of_elements_offset + 2;\n-static constexpr const int element_name_size = 2;\n-static constexpr const int value_type_relative_offset = 2;\n-static constexpr const int value_relative_offset = value_type_relative_offset + 1;\n-\n-\/\/ see JVMS - 4.7.16. The RuntimeVisibleAnnotations Attribute\n-\n-class AnnotationElementIterator : public StackObj {\n- private:\n-  const InstanceKlass* _ik;\n-  const address _buffer;\n-  const int _limit; \/\/ length of annotation\n-  mutable int _current; \/\/ element\n-  mutable int _next; \/\/ element\n-\n-  int value_index() const {\n-    return JfrBigEndian::read<int, u2>(_buffer + _current + value_relative_offset);\n-  }\n-\n- public:\n-  AnnotationElementIterator(const InstanceKlass* ik, address buffer, int limit) : _ik(ik),\n-                                                                                  _buffer(buffer),\n-                                                                                  _limit(limit),\n-                                                                                  _current(element_name_offset),\n-                                                                                  _next(element_name_offset) {\n-    assert(_buffer != nullptr, \"invariant\");\n-    assert(_next == element_name_offset, \"invariant\");\n-    assert(_current == element_name_offset, \"invariant\");\n-  }\n-\n-  bool has_next() const {\n-    return _next < _limit;\n-  }\n-\n-  void move_to_next() const {\n-    assert(has_next(), \"invariant\");\n-    _current = _next;\n-    if (_next < _limit) {\n-      _next = skip_annotation_value(_buffer, _limit, _next + element_name_size);\n-    }\n-    assert(_next <= _limit, \"invariant\");\n-    assert(_current <= _limit, \"invariant\");\n-  }\n-\n-  int number_of_elements() const {\n-    return JfrBigEndian::read<int, u2>(_buffer + number_of_elements_offset);\n-  }\n-\n-  const Symbol* name() const {\n-    assert(_current < _next, \"invariant\");\n-    return _ik->constants()->symbol_at(JfrBigEndian::read<int, u2>(_buffer + _current));\n-  }\n-\n-  char value_type() const {\n-    return JfrBigEndian::read<char, u1>(_buffer + _current + value_type_relative_offset);\n-  }\n-\n-  jint read_int() const {\n-    return _ik->constants()->int_at(value_index());\n-  }\n-\n-  bool read_bool() const {\n-    return read_int() != 0;\n-  }\n-};\n-\n-class AnnotationIterator : public StackObj {\n- private:\n-  const InstanceKlass* _ik;\n-  \/\/ ensure _limit field is declared before _buffer\n-  int _limit; \/\/ length of annotations array\n-  const address _buffer;\n-  mutable int _current; \/\/ annotation\n-  mutable int _next; \/\/ annotation\n-\n- public:\n-  AnnotationIterator(const InstanceKlass* ik, AnnotationArray* ar) : _ik(ik),\n-                                                                     _limit(ar != nullptr ? ar->length() : 0),\n-                                                                     _buffer(_limit > 2 ? ar->adr_at(2) : nullptr),\n-                                                                     _current(0),\n-                                                                     _next(0) {\n-    if (_limit >= 2) {\n-      _limit -= 2; \/\/ subtract sizeof(u2) number of annotations field\n-    }\n-  }\n-  bool has_next() const {\n-    return _next < _limit;\n-  }\n-\n-  void move_to_next() const {\n-    assert(has_next(), \"invariant\");\n-    _current = _next;\n-    if (_next < _limit) {\n-      _next = next_annotation_index(_buffer, _limit, _next);\n-    }\n-    assert(_next <= _limit, \"invariant\");\n-    assert(_current <= _limit, \"invariant\");\n-  }\n-\n-  const AnnotationElementIterator elements() const {\n-    assert(_current < _next, \"invariant\");\n-    return AnnotationElementIterator(_ik, _buffer + _current, _next - _current);\n-  }\n-\n-  const Symbol* type() const {\n-    assert(_buffer != nullptr, \"invariant\");\n-    assert(_current < _limit, \"invariant\");\n-    return _ik->constants()->symbol_at(JfrBigEndian::read<int, u2>(_buffer + _current));\n-  }\n-};\n-\n@@ -378,2 +178,1 @@\n-\n-  const AnnotationIterator annotation_iterator(ik, class_annotations);\n+  const JfrAnnotationIterator annotation_iterator(ik, class_annotations);\n@@ -387,1 +186,1 @@\n-      const AnnotationElementIterator element_iterator = annotation_iterator.elements();\n+      JfrAnnotationElementIterator element_iterator = elements_iterator(ik, annotation_iterator);\n@@ -1552,51 +1351,0 @@\n-\/\/ On initial class load.\n-static void cache_class_file_data(InstanceKlass* new_ik, const ClassFileStream* new_stream, const JavaThread* thread) {\n-  assert(new_ik != nullptr, \"invariant\");\n-  assert(new_stream != nullptr, \"invariant\");\n-  assert(thread != nullptr, \"invariant\");\n-  assert(!thread->has_pending_exception(), \"invariant\");\n-  if (!JfrOptionSet::allow_retransforms()) {\n-    return;\n-  }\n-  const jint stream_len = new_stream->length();\n-  JvmtiCachedClassFileData* p =\n-    (JvmtiCachedClassFileData*)NEW_C_HEAP_ARRAY_RETURN_NULL(u1, offset_of(JvmtiCachedClassFileData, data) + stream_len, mtInternal);\n-  if (p == nullptr) {\n-    log_error(jfr, system)(\"Allocation using C_HEAP_ARRAY for %zu bytes failed in JfrEventClassTransformer::cache_class_file_data\",\n-      static_cast<size_t>(offset_of(JvmtiCachedClassFileData, data) + stream_len));\n-    return;\n-  }\n-  p->length = stream_len;\n-  memcpy(p->data, new_stream->buffer(), stream_len);\n-  new_ik->set_cached_class_file(p);\n-}\n-\n-\/\/ On redefine \/ retransform, in case an agent modified the class, the original bytes are cached onto the scratch klass.\n-static void transfer_cached_class_file_data(InstanceKlass* ik, InstanceKlass* new_ik, const ClassFileParser& parser, JavaThread* thread) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(new_ik != nullptr, \"invariant\");\n-  JvmtiCachedClassFileData* const p = ik->get_cached_class_file();\n-  if (p != nullptr) {\n-    new_ik->set_cached_class_file(p);\n-    ik->set_cached_class_file(nullptr);\n-    return;\n-  }\n-  \/\/ No cached classfile indicates that no agent modified the klass.\n-  \/\/ This means that the parser is holding the original bytes. Hence, we cache it onto the scratch klass.\n-  const ClassFileStream* const stream = parser.clone_stream();\n-  cache_class_file_data(new_ik, stream, thread);\n-}\n-\n-static void rewrite_klass_pointer(InstanceKlass*& ik, InstanceKlass* new_ik, ClassFileParser& parser, const JavaThread* thread) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(new_ik != nullptr, \"invariant\");\n-  assert(thread != nullptr, \"invariant\");\n-  assert(IS_EVENT_OR_HOST_KLASS(new_ik), \"invariant\");\n-  assert(TRACE_ID(ik) == TRACE_ID(new_ik), \"invariant\");\n-  assert(!thread->has_pending_exception(), \"invariant\");\n-  \/\/ Assign original InstanceKlass* back onto \"its\" parser object for proper destruction.\n-  parser.set_klass_to_deallocate(ik);\n-  \/\/ Finally rewrite the original pointer to the newly created InstanceKlass.\n-  ik = new_ik;\n-}\n-\n@@ -1655,81 +1403,0 @@\n-static void copy_traceid(const InstanceKlass* ik, const InstanceKlass* new_ik) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(new_ik != nullptr, \"invariant\");\n-  new_ik->set_trace_id(ik->trace_id());\n-  assert(TRACE_ID(ik) == TRACE_ID(new_ik), \"invariant\");\n-}\n-\n-static const Klass* klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(state != nullptr, \"invariant\");\n-  const GrowableArray<Klass*>* const redef_klasses = state->get_classes_being_redefined();\n-  if (redef_klasses == nullptr || redef_klasses->is_empty()) {\n-    return nullptr;\n-  }\n-  for (int i = 0; i < redef_klasses->length(); ++i) {\n-    const Klass* const existing_klass = redef_klasses->at(i);\n-    assert(existing_klass != nullptr, \"invariant\");\n-    if (ik->name() == existing_klass->name() && ik->class_loader_data() == existing_klass->class_loader_data()) {\n-      \/\/ 'ik' is a scratch klass. Return the klass being redefined.\n-      return existing_klass;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-\/\/ Redefining \/ retransforming?\n-static const Klass* find_existing_klass(const InstanceKlass* ik, JavaThread* thread) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(thread != nullptr, \"invariant\");\n-  JvmtiThreadState* const state = thread->jvmti_thread_state();\n-  return state != nullptr ? klass_being_redefined(ik, state) : nullptr;\n-}\n-\n-static InstanceKlass* create_new_instance_klass(InstanceKlass* ik, ClassFileStream* stream, TRAPS) {\n-  assert(stream != nullptr, \"invariant\");\n-  ResourceMark rm(THREAD);\n-  ClassLoaderData* const cld = ik->class_loader_data();\n-  Handle pd(THREAD, ik->protection_domain());\n-  Symbol* const class_name = ik->name();\n-  const char* const klass_name = class_name != nullptr ? class_name->as_C_string() : \"\";\n-  ClassLoadInfo cl_info(pd);\n-  ClassFileParser new_parser(stream,\n-                             class_name,\n-                             cld,\n-                             &cl_info,\n-                             ClassFileParser::INTERNAL, \/\/ internal visibility\n-                             THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    log_pending_exception(PENDING_EXCEPTION);\n-    CLEAR_PENDING_EXCEPTION;\n-    return nullptr;\n-  }\n-  const ClassInstanceInfo* cl_inst_info = cl_info.class_hidden_info_ptr();\n-  InstanceKlass* const new_ik = new_parser.create_instance_klass(false, *cl_inst_info, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    log_pending_exception(PENDING_EXCEPTION);\n-    CLEAR_PENDING_EXCEPTION;\n-    return nullptr;\n-  }\n-  assert(new_ik != nullptr, \"invariant\");\n-  assert(new_ik->name() != nullptr, \"invariant\");\n-  assert(strncmp(ik->name()->as_C_string(), new_ik->name()->as_C_string(), strlen(ik->name()->as_C_string())) == 0, \"invariant\");\n-  return new_ik;\n-}\n-\n-static InstanceKlass* create_instance_klass(InstanceKlass*& ik, ClassFileStream* stream, bool is_initial_load, JavaThread* thread) {\n-  if (stream == nullptr) {\n-    if (is_initial_load) {\n-      log_error(jfr, system)(\"JfrEventClassTransformer: unable to create ClassFileStream for %s\", ik->external_name());\n-    }\n-    return nullptr;\n-  }\n-  InstanceKlass* const new_ik = create_new_instance_klass(ik, stream, thread);\n-  if (new_ik == nullptr) {\n-    if (is_initial_load) {\n-      log_error(jfr, system)(\"JfrEventClassTransformer: unable to create InstanceKlass for %s\", ik->external_name());\n-    }\n-  }\n-  return new_ik;\n-}\n-\n@@ -1740,1 +1407,1 @@\n-  const Klass* const existing_klass = find_existing_klass(ik, thread);\n+  const Klass* const existing_klass = JfrClassTransformer::find_existing_klass(ik, thread);\n@@ -1748,1 +1415,1 @@\n-  InstanceKlass* const new_ik = create_instance_klass(ik, stream, existing_klass == nullptr, thread);\n+  InstanceKlass* const new_ik = JfrClassTransformer::create_instance_klass(ik, stream, existing_klass == nullptr, thread);\n@@ -1753,1 +1420,1 @@\n-    transfer_cached_class_file_data(ik, new_ik, parser, thread);\n+    JfrClassTransformer::transfer_cached_class_file_data(ik, new_ik, parser, thread);\n@@ -1755,1 +1422,1 @@\n-    cache_class_file_data(new_ik, stream, thread);\n+    JfrClassTransformer::cache_class_file_data(new_ik, stream, thread);\n@@ -1760,2 +1427,2 @@\n-  copy_traceid(ik, new_ik);\n-  rewrite_klass_pointer(ik, new_ik, parser, thread);\n+  JfrClassTransformer::copy_traceid(ik, new_ik);\n+  JfrClassTransformer::rewrite_klass_pointer(ik, new_ik, parser, thread);\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":18,"deletions":351,"binary":false,"changes":369,"status":"modified"},{"patch":"@@ -81,13 +81,0 @@\n-  if (class_being_redefined == nullptr) {\n-    return;\n-  }\n-  JavaThread* jt = JavaThread::thread_from_jni_environment(jni_env);\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));;\n-  ThreadInVMfromNative tvmfn(jt);\n-  JfrUpcalls::on_retransform(JfrTraceId::load_raw(class_being_redefined),\n-                             class_being_redefined,\n-                             class_data_len,\n-                             class_data,\n-                             new_class_data_len,\n-                             new_class_data,\n-                             jt);\n@@ -178,0 +165,4 @@\n+  retransform_classes(env, classes, classes_count, THREAD);\n+}\n+\n+void JfrJvmtiAgent::retransform_classes(JNIEnv* env, jclass* classes, jint classes_count, TRAPS) {\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrJvmtiAgent.cpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+  static void retransform_classes(JNIEnv* env, jclass* classes, jint classes_count, TRAPS) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrJvmtiAgent.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"jfr\/instrumentation\/jfrEventClassTransformer.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"jfr\/support\/jfrKlassExtension.hpp\"\n@@ -36,0 +38,4 @@\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -74,0 +80,16 @@\n+void Jfr::on_klass_creation(InstanceKlass*& ik, ClassFileParser& parser, TRAPS) {\n+  if (IS_EVENT_OR_HOST_KLASS(ik)) {\n+    JfrEventClassTransformer::on_klass_creation(ik, parser, THREAD);\n+    return;\n+  }\n+  if (JfrMethodTracer::in_use()) {\n+    JfrMethodTracer::on_klass_creation(ik, parser, THREAD);\n+  }\n+}\n+\n+void Jfr::on_klass_redefinition(const InstanceKlass* ik, Thread* thread) {\n+  assert(JfrMethodTracer::in_use(), \"invariant\");\n+  JfrMethodTracer::on_klass_redefinition(ik, thread);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class ClassFileParser;\n@@ -38,0 +39,1 @@\n+class InstanceKlass;\n@@ -61,0 +63,2 @@\n+  static void on_klass_creation(InstanceKlass*& ik, ClassFileParser& parser, TRAPS);\n+  static void on_klass_redefinition(const InstanceKlass* ik, Thread* thread);\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -932,0 +933,13 @@\n+\n+jlongArray JfrJavaSupport::create_long_array(GrowableArray<jlong>* array, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  assert(array != nullptr, \"invariant\");\n+  assert(array->is_nonempty(), \"invariant\");\n+  const int length = array->length();\n+  assert(length > 0, \"invariant\");\n+  typeArrayOop obj = oopFactory::new_typeArray(T_LONG, length, CHECK_NULL);\n+  ArrayAccess<>::arraycopy_from_native(&array->first(), obj, typeArrayOopDesc::element_offset<jlong>(0), length);\n+  array->clear();\n+  return static_cast<jlongArray>(JfrJavaSupport::local_jni_handle(obj, THREAD));\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+template <typename E> class GrowableArray;\n@@ -91,0 +92,1 @@\n+  static jlongArray create_long_array(GrowableArray<jlong>* array, TRAPS);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n@@ -440,0 +441,10 @@\n+\n+JVM_ENTRY_NO_ENV(jlongArray, jfr_set_method_trace_filters(JNIEnv* env, jclass jvm, jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modifications))\n+  return JfrMethodTracer::set_filters(env, classes, methods, annotations, modifications, thread);\n+JVM_END\n+\n+JVM_ENTRY_NO_ENV(jlongArray, jfr_drain_stale_method_tracer_ids(JNIEnv* env, jclass jvm))\n+  return JfrMethodTracer::drain_stale_class_ids(thread);\n+JVM_END\n+\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,0 +172,4 @@\n+jlongArray JNICALL jfr_set_method_trace_filters(JNIEnv* env, jclass jvm, jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modifications);\n+\n+jlongArray JNICALL jfr_drain_stale_method_tracer_ids(JNIEnv* env, jclass);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,1 +104,3 @@\n-      (char*)\"isProduct\", (char*)\"()Z\", (void*)jfr_is_product\n+      (char*)\"isProduct\", (char*)\"()Z\", (void*)jfr_is_product,\n+      (char*)\"setMethodTraceFilters\", (char*)\"([Ljava\/lang\/String;[Ljava\/lang\/String;[Ljava\/lang\/String;[I)[J\", (void*)jfr_set_method_trace_filters,\n+      (char*)\"drainStaleMethodTracerIds\", (char*)\"()[J\", (void*)jfr_drain_stale_method_tracer_ids,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/classFileStream.hpp\"\n@@ -26,0 +27,1 @@\n+#include \"classfile\/moduleEntry.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n@@ -39,0 +42,2 @@\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -50,0 +55,4 @@\n+static Symbol* on_method_trace_sym = nullptr;\n+static Symbol* on_method_trace_sig_sym = nullptr;\n+static Symbol* publish_method_timers_for_klass_sym = nullptr;\n+static Symbol* publish_method_timers_for_klass_sig_sym = nullptr;\n@@ -62,1 +71,5 @@\n-    initialized = unhide_internal_types_sig_sym != nullptr;\n+    on_method_trace_sym = SymbolTable::new_permanent_symbol(\"onMethodTrace\");\n+    on_method_trace_sig_sym = SymbolTable::new_permanent_symbol(\"(Ljava\/lang\/Module;Ljava\/lang\/ClassLoader;Ljava\/lang\/String;[B[J[Ljava\/lang\/String;[Ljava\/lang\/String;[I)[B\");\n+    publish_method_timers_for_klass_sym = SymbolTable::new_permanent_symbol(\"publishMethodTimersForClass\");\n+    publish_method_timers_for_klass_sig_sym = SymbolTable::new_permanent_symbol(\"(J)V\");\n+    initialized = publish_method_timers_for_klass_sig_sym != nullptr;\n@@ -210,0 +223,100 @@\n+\n+\/\/ Caller needs ResourceMark\n+ClassFileStream* JfrUpcalls::on_method_trace(InstanceKlass* ik, const ClassFileStream* stream, GrowableArray<JfrTracedMethod>* methods, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  assert(stream != nullptr, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n+  assert(methods->is_nonempty(), \"invariant\");\n+  initialize(THREAD);\n+  Klass* klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, CHECK_NULL);\n+  assert(klass != nullptr, \"invariant\");\n+\n+  HandleMark hm(THREAD);\n+\n+  ModuleEntry* module_entry = ik->module();\n+  oop module = nullptr;\n+  if (module_entry != nullptr) {\n+    module = module_entry->module();\n+  }\n+  instanceHandle module_handle(THREAD, (instanceOop)module);\n+\n+  \/\/ ClassLoader\n+  oop class_loader = ik->class_loader();\n+  instanceHandle class_loader_handle(THREAD, (instanceOop)class_loader);\n+\n+  \/\/ String class name\n+  Handle class_name_h = java_lang_String::create_from_symbol(ik->name(), CHECK_NULL);\n+\n+  \/\/ new byte[]\n+  int size = stream->length();\n+  typeArrayOop bytecode_array = oopFactory::new_byteArray(size, CHECK_NULL);\n+  typeArrayHandle h_bytecode_array(THREAD, bytecode_array);\n+\n+  \/\/ Copy ClassFileStream bytes to byte[]\n+  const jbyte* src = reinterpret_cast<const jbyte*>(stream->buffer());\n+  ArrayAccess<>::arraycopy_from_native(src, bytecode_array, typeArrayOopDesc::element_offset<jbyte>(0), size);\n+\n+  int method_count = methods->length();\n+\n+  \/\/ new long[method_count]\n+  typeArrayOop id_array = oopFactory::new_longArray(method_count, CHECK_NULL);\n+  typeArrayHandle h_id_array(THREAD, id_array);\n+\n+  \/\/ new String[method_count]\n+  objArrayOop name_array = oopFactory::new_objArray(vmClasses::String_klass(), method_count, CHECK_NULL);\n+  objArrayHandle h_name_array(THREAD, name_array);\n+\n+  \/\/ new String[method_count]\n+  objArrayOop signature_array = oopFactory::new_objArray(vmClasses::String_klass(), method_count, CHECK_NULL);\n+  objArrayHandle h_signature_array(THREAD, signature_array);\n+\n+   \/\/ new int[method_count]\n+  typeArrayOop modification_array = oopFactory::new_intArray(method_count, CHECK_NULL);\n+  typeArrayHandle h_modification_array(THREAD, modification_array);\n+\n+  \/\/ Fill in arrays\n+  for (int i = 0; i < method_count; i++) {\n+    JfrTracedMethod method = methods->at(i);\n+    h_id_array->long_at_put(i, method.id());\n+    Handle name = java_lang_String::create_from_symbol(method.name(), CHECK_NULL);\n+    h_name_array->obj_at_put(i, name());\n+    Handle signature = java_lang_String::create_from_symbol(method.signature(), CHECK_NULL);\n+    h_signature_array->obj_at_put(i, signature());\n+    h_modification_array->int_at_put(i, method.modification());\n+  }\n+\n+  \/\/ Call JVMUpcalls::onMethodTrace(byte[], long[] , String[], String[], int[])\n+  JavaCallArguments args;\n+  JavaValue result(T_OBJECT);\n+  args.push_oop(module_handle);\n+  args.push_oop(class_loader_handle);\n+  args.push_oop(class_name_h);\n+  args.push_oop(h_bytecode_array);\n+  args.push_oop(h_id_array);\n+  args.push_oop(h_name_array);\n+  args.push_oop(h_signature_array);\n+  args.push_oop(h_modification_array);\n+  JavaCalls::call_static(&result, klass, on_method_trace_sym, on_method_trace_sig_sym, &args, CHECK_NULL);\n+\n+  oop return_object = result.get_oop();\n+  if (return_object != nullptr) {\n+    assert(return_object->is_typeArray(), \"invariant\");\n+    assert(TypeArrayKlass::cast(return_object->klass())->element_type() == T_BYTE, \"invariant\");\n+    typeArrayOop byte_array = typeArrayOop(return_object);\n+    int length = byte_array->length();\n+    u1* buffer = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, u1, length);\n+    ArrayAccess<>::arraycopy_to_native<>(byte_array, typeArrayOopDesc::element_offset<jbyte>(0), buffer, length);\n+    return new ClassFileStream(buffer, length, stream->source(), stream->from_boot_loader_modules_image());\n+  }\n+  return nullptr;\n+}\n+\n+void JfrUpcalls::publish_method_timers_for_klass(traceid klass_id, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  Klass* const klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, CHECK);\n+  assert(klass != nullptr, \"invariant\");\n+  JavaCallArguments args;\n+  JavaValue result(T_VOID);\n+  args.push_long(static_cast<jlong>(klass_id));\n+  JavaCalls::call_static(&result, klass, publish_method_timers_for_klass_sym, publish_method_timers_for_klass_sig_sym, &args, CHECK);\n+}\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":114,"deletions":1,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n@@ -30,0 +31,1 @@\n+\n@@ -32,0 +34,3 @@\n+class ClassFileStream;\n+class InstanceKlass;\n+class JfrTracedMethod;\n@@ -33,0 +38,1 @@\n+template <typename E> class GrowableArray;\n@@ -58,0 +64,7 @@\n+  \/\/ Caller needs ResourceMark\n+  static ClassFileStream* on_method_trace(InstanceKlass* ik, const ClassFileStream* stream,\n+                                          GrowableArray<JfrTracedMethod>* methods,\n+                                          TRAPS);\n+\n+  static void publish_method_timers_for_klass(traceid klass_id, TRAPS);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1291,0 +1291,10 @@\n+\n+  <Event name=\"MethodTrace\" category=\"Java Application\" label=\"Method Trace\" thread=\"true\" stackTrace=\"true\" startTime=\"true\">\n+    <Field type=\"Method\" name=\"method\" label=\"Method\" \/>\n+  <\/Event>\n+\n+  <Event name=\"MethodTiming\" category=\"Java Application\" label=\"Method Timing\" thread=\"false\" stackTrace=\"false\" startTime=\"false\" period=\"everyChunk\">\n+    <Field type=\"Method\" name=\"method\" label=\"Method\" \/>\n+    <Field type=\"long\" name=\"invocations\" label=\"Invocations\" description = \"The number of times the method was invoked\"\/>\n+    <Field type=\"Tickspan\" name=\"average\" label=\"Average\" description=\"An approximation of the wall-clock time it took for the method to execute\"\/>\n+  <\/Event>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -324,0 +324,4 @@\n+TRACE_REQUEST_FUNC(MethodTiming) {\n+  \/\/ Emitted in Java, but defined in native to have Method type field.\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+#include \"jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n@@ -483,0 +485,54 @@\n+static void do_method_tracer_klasses() {\n+  assert(JfrTraceIdEpoch::has_method_tracer_changed_tag_state(), \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(_subsystem_callback != nullptr, \"invariant\");\n+  GrowableArray<JfrInstrumentedClass>* const instrumented = JfrMethodTracer::instrumented_classes();\n+  assert(instrumented != nullptr, \"invariant\");\n+  assert(instrumented->length() > 0, \"invariant\");\n+  for (int i = 0; i < instrumented->length(); ++i) {\n+    JfrInstrumentedClass& jic = instrumented->at(i);\n+    if (jic.unloaded()) {\n+      continue;\n+    }\n+    if (JfrKlassUnloading::is_unloaded(jic.trace_id(), previous_epoch())) {\n+      jic.set_unloaded(true);\n+      continue;\n+    }\n+    assert(jic.trace_id() == JfrTraceId::load_raw(jic.instance_klass()), \"invariant\");\n+    assert(HAS_STICKY_BIT(jic.instance_klass()), \"invariant\");\n+    if (current_epoch()) {\n+      JfrTraceId::load(jic.instance_klass()); \/\/ enqueue klass for this epoch\n+    } else {\n+      _subsystem_callback->do_artifact(jic.instance_klass()); \/\/ process directly\n+    }\n+  }\n+  JfrTraceIdEpoch::reset_method_tracer_tag_state();\n+}\n+\n+static void clear_method_tracer_klasses() {\n+  assert_locked_or_safepoint (ClassLoaderDataGraph_lock);\n+  assert(previous_epoch(), \"invariant\");\n+  GrowableArray<JfrInstrumentedClass>* const instrumented = JfrMethodTracer::instrumented_classes();\n+  assert(instrumented != nullptr, \"invariant\");\n+  const int length = instrumented->length();\n+  if (length != 0 && !JfrTraceIdEpoch::has_method_tracer_changed_tag_state()) {\n+    \/\/ Turn the tag state back on for next chunk.\n+    JfrTraceIdEpoch::set_method_tracer_tag_state();\n+  }\n+  bool trim = false;\n+  for (int i = 0; i < length; ++i) {\n+    JfrInstrumentedClass& jic = instrumented->at(i);\n+    if (jic.unloaded()) {\n+      trim = true;\n+      continue;\n+    }\n+    if (JfrKlassUnloading::is_unloaded(jic.trace_id(), true)) {\n+      jic.set_unloaded(true);\n+      trim = true;\n+    }\n+  }\n+  if (trim) {\n+    JfrMethodTracer::trim_instrumented_classes();\n+  }\n+}\n+\n@@ -507,1 +563,1 @@\n-    \/\/ Only write the primitive classes once per chunk.\n+    \/\/ Only write the primitive and method tracer classes once per chunk.\n@@ -510,0 +566,4 @@\n+  if (JfrTraceIdEpoch::has_method_tracer_changed_tag_state()) {\n+    do_method_tracer_klasses();\n+  }\n+\n@@ -1209,0 +1269,1 @@\n+    clear_method_tracer_klasses();\n@@ -1259,0 +1320,1 @@\n+  JfrMethodTracer::clear_instrumented_classes();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":63,"deletions":1,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,3 @@\n-    CLEAR_PREVIOUS_EPOCH_METHOD_FLAG(method);\n+    if (METHOD_FLAG_USED_PREVIOUS_EPOCH_BIT(method)) {\n+      CLEAR_PREVIOUS_EPOCH_METHOD_FLAG(method);\n+    }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,1 @@\n+  static traceid load_previous_epoch(const Klass* klass);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,5 @@\n-  return JfrTraceIdLoadBarrier::load_leakp_previuos_epoch(klass, method);\n+  return JfrTraceIdLoadBarrier::load_leakp_previous_epoch(klass, method);\n+}\n+\n+inline traceid JfrTraceId::load_previous_epoch(const Klass* klass) {\n+  return JfrTraceIdLoadBarrier::load_previous_epoch(klass);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/mutex.hpp\"\n@@ -38,0 +40,1 @@\n+bool JfrTraceIdEpoch::_method_tracer_state = false;\n@@ -62,0 +65,18 @@\n+\n+bool JfrTraceIdEpoch::is_synchronizing() {\n+  return Atomic::load_acquire(&_synchronizing);\n+}\n+\n+void JfrTraceIdEpoch::set_method_tracer_tag_state() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  Atomic::store(&_method_tracer_state, true);\n+}\n+\n+void JfrTraceIdEpoch::reset_method_tracer_tag_state() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  Atomic::store(&_method_tracer_state, false);\n+}\n+\n+bool JfrTraceIdEpoch::has_method_tracer_changed_tag_state() {\n+  return Atomic::load(&_method_tracer_state);\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -60,0 +59,1 @@\n+  static bool _method_tracer_state;\n@@ -95,3 +95,1 @@\n-  static bool is_synchronizing() {\n-    return Atomic::load_acquire(&_synchronizing);\n-  }\n+  static bool is_synchronizing();\n@@ -124,1 +122,1 @@\n-    return _tag_state.is_signaled_with_reset();\n+    return _tag_state.is_signaled_with_reset() || has_method_tracer_changed_tag_state();\n@@ -138,0 +136,4 @@\n+\n+  static void set_method_tracer_tag_state();\n+  static void reset_method_tracer_tag_state();\n+  static bool has_method_tracer_changed_tag_state();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,1 @@\n+  friend class JfrTraceTagging;\n@@ -86,0 +87,1 @@\n+  static traceid load_previous_epoch(const Klass* klass);\n@@ -92,2 +94,1 @@\n-  static traceid load_leakp_previuos_epoch(const Klass* klass, const Method* method); \/\/ leak profiler\n-  static void do_klasses(void f(Klass*), bool previous_epoch = false);\n+  static traceid load_leakp_previous_epoch(const Klass* klass, const Method* method); \/\/ leak profiler\n@@ -96,0 +97,1 @@\n+  static void do_klasses(void f(Klass*), bool previous_epoch = false);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-inline traceid JfrTraceIdLoadBarrier::load_leakp_previuos_epoch(const Klass* klass, const Method* method) {\n+inline traceid JfrTraceIdLoadBarrier::load_leakp_previous_epoch(const Klass* klass, const Method* method) {\n@@ -181,3 +181,0 @@\n-    \/\/ the method is already logically tagged, just like the klass,\n-    \/\/ but because of redefinition, the latest Method*\n-    \/\/ representation might not have a reified tag.\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+#define TIMING_BIT                                LEAKP_BIT \/\/ Alias\n@@ -58,0 +59,2 @@\n+#define STICKY_META_BIT                           (BIT << 5)\n+#define STICKY_BIT                                (STICKY_META_BIT << META_SHIFT)\n@@ -61,1 +64,1 @@\n-#define META_BITS                                 (SERIALIZED_BIT | TRANSIENT_BIT | LEAKP_BIT | EPOCH_1_CLEARED_BIT | EPOCH_0_CLEARED_BIT)\n+#define META_BITS                                 (STICKY_BIT | SERIALIZED_BIT | TRANSIENT_BIT | LEAKP_BIT | EPOCH_1_CLEARED_BIT | EPOCH_0_CLEARED_BIT)\n@@ -93,1 +96,1 @@\n-#define USED_THIS_EPOCH(ptr)                      (TRACE_ID_PREDICATE(ptr, (TRANSIENT_BIT | THIS_EPOCH_BIT)))\n+#define USED_THIS_EPOCH(ptr)                      (TRACE_ID_PREDICATE(ptr, (STICKY_BIT | TRANSIENT_BIT | THIS_EPOCH_BIT)))\n@@ -95,3 +98,3 @@\n-#define USED_PREVIOUS_EPOCH(ptr)                  (TRACE_ID_PREDICATE(ptr, (TRANSIENT_BIT | PREVIOUS_EPOCH_BIT)))\n-#define USED_ANY_EPOCH(ptr)                       (TRACE_ID_PREDICATE(ptr, (TRANSIENT_BIT | EPOCH_1_BIT | EPOCH_0_BIT)))\n-#define METHOD_USED_THIS_EPOCH(kls)               (TRACE_ID_PREDICATE(kls, (THIS_EPOCH_METHOD_BIT)))\n+#define USED_PREVIOUS_EPOCH(ptr)                  (TRACE_ID_PREDICATE(ptr, (STICKY_BIT | TRANSIENT_BIT | PREVIOUS_EPOCH_BIT)))\n+#define USED_ANY_EPOCH(ptr)                       (TRACE_ID_PREDICATE(ptr, (STICKY_BIT | TRANSIENT_BIT | EPOCH_1_BIT | EPOCH_0_BIT)))\n+#define METHOD_USED_THIS_EPOCH(kls)               (TRACE_ID_PREDICATE(kls, (STICKY_BIT | THIS_EPOCH_METHOD_BIT)))\n@@ -99,1 +102,1 @@\n-#define METHOD_USED_PREVIOUS_EPOCH(kls)           (TRACE_ID_PREDICATE(kls, (PREVIOUS_EPOCH_METHOD_BIT)))\n+#define METHOD_USED_PREVIOUS_EPOCH(kls)           (TRACE_ID_PREDICATE(kls, (STICKY_BIT | PREVIOUS_EPOCH_METHOD_BIT)))\n@@ -104,1 +107,1 @@\n-#define METHOD_FLAG_USED_THIS_EPOCH(method)       (METHOD_FLAG_PREDICATE(method, (TRANSIENT_BIT | THIS_EPOCH_BIT)))\n+#define METHOD_FLAG_USED_THIS_EPOCH(method)       (METHOD_FLAG_PREDICATE(method, (STICKY_BIT | TRANSIENT_BIT | THIS_EPOCH_BIT)))\n@@ -106,1 +109,2 @@\n-#define METHOD_FLAG_USED_PREVIOUS_EPOCH(method)   (METHOD_FLAG_PREDICATE(method, (TRANSIENT_BIT | PREVIOUS_EPOCH_BIT)))\n+#define METHOD_FLAG_USED_PREVIOUS_EPOCH(method)   (METHOD_FLAG_PREDICATE(method, (STICKY_BIT | TRANSIENT_BIT | PREVIOUS_EPOCH_BIT)))\n+#define METHOD_FLAG_USED_PREVIOUS_EPOCH_BIT(method) (METHOD_FLAG_PREDICATE(method, (PREVIOUS_EPOCH_BIT)))\n@@ -134,0 +138,1 @@\n+#define SET_TIMING_BIT(ptr)                       (SET_LEAKP(ptr))\n@@ -135,0 +140,1 @@\n+#define HAS_TIMING_BIT(ptr)                       (IS_LEAKP(ptr))\n@@ -136,0 +142,1 @@\n+#define HAS_NOT_TIMING_BIT(ptr)                   (IS_NOT_LEAKP(ptr))\n@@ -139,0 +146,2 @@\n+#define IS_SERIALIZED(ptr)                        (TRACE_ID_PREDICATE(ptr, SERIALIZED_BIT))\n+#define IS_NOT_SERIALIZED(ptr)                    (!(IS_SERIALIZED(ptr)))\n@@ -140,0 +149,3 @@\n+#define HAS_STICKY_BIT(ptr)                       (TRACE_ID_PREDICATE(ptr, STICKY_BIT))\n+#define HAS_NOT_STICKY_BIT(ptr)                   (!(HAS_STICKY_BIT(ptr)))\n+#define SET_STICKY_BIT(ptr)                       (TRACE_ID_META_TAG(ptr, STICKY_META_BIT))\n@@ -142,2 +154,0 @@\n-#define IS_SERIALIZED(ptr)                        (TRACE_ID_PREDICATE(ptr, SERIALIZED_BIT))\n-#define IS_NOT_SERIALIZED(ptr)                    (!(IS_SERIALIZED(ptr)))\n@@ -153,0 +163,3 @@\n+#define SET_METHOD_STICKY_BIT(method)             (METHOD_META_TAG(method, STICKY_META_BIT))\n+#define METHOD_HAS_STICKY_BIT(method)             (METHOD_FLAG_PREDICATE(method, STICKY_BIT))\n+#define METHOD_HAS_NOT_STICKY_BIT(method)         (!(METHOD_HAS_STICKY_BIT(method)))\n@@ -162,0 +175,1 @@\n+#define CLEAR_TIMING_BIT(ptr)                     (CLEAR_LEAKP(ptr))\n@@ -163,0 +177,2 @@\n+#define CLEAR_STICKY_BIT(ptr)                     (TRACE_ID_META_MASK_CLEAR(ptr, (~(STICKY_META_BIT))))\n+#define CLEAR_STICKY_BIT_METHOD(method)           (METHOD_META_MASK_CLEAR(method, (~(STICKY_META_BIT))))\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+* Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"jfr\/support\/jfrAnnotationElementIterator.hpp\"\n+#include \"jfr\/support\/jfrAnnotationIterator.hpp\"\n+#include \"jfr\/utilities\/jfrBigEndian.hpp\"\n+#include \"oops\/constantPool.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/symbol.hpp\"\n+\n+\/*\n+ Annotation layout.\n+\n+ enum {  \/\/ initial annotation layout\n+   atype_off = 0,    \/\/ utf8 such as 'Ljava\/lang\/annotation\/Retention;'\n+   count_off = 2,    \/\/ u2   such as 1 (one value)\n+   member_off = 4,   \/\/ utf8 such as 'value'\n+   tag_off = 6,      \/\/ u1   such as 'c' (type) or 'e' (enum)\n+   e_tag_val = 'e',\n+   e_type_off = 7,   \/\/ utf8 such as 'Ljava\/lang\/annotation\/RetentionPolicy;'\n+   e_con_off = 9,    \/\/ utf8 payload, such as 'SOURCE', 'CLASS', 'RUNTIME'\n+   e_size = 11,      \/\/ end of 'e' annotation\n+   c_tag_val = 'c',  \/\/ payload is type\n+   c_con_off = 7,    \/\/ utf8 payload, such as 'I'\n+   c_size = 9,       \/\/ end of 'c' annotation\n+   s_tag_val = 's',  \/\/ payload is String\n+   s_con_off = 7,    \/\/ utf8 payload, such as 'Ljava\/lang\/String;'\n+   s_size = 9,\n+   min_size = 6      \/\/ smallest possible size (zero members)\n+ };\n+\n+ See JVMS - 4.7.16. The RuntimeVisibleAnnotations Attribute\n+\n+*\/\n+\n+static constexpr const int number_of_elements_offset = 2;\n+static constexpr const int element_name_offset = number_of_elements_offset + 2;\n+static constexpr const int element_name_size = 2;\n+static constexpr const int value_type_relative_offset = 2;\n+static constexpr const int value_relative_offset = value_type_relative_offset + 1;\n+\n+JfrAnnotationElementIterator::JfrAnnotationElementIterator(const InstanceKlass* ik, address buffer, int limit) :\n+  _ik(ik),\n+  _buffer(buffer),\n+  _limit(limit),\n+  _current(element_name_offset),\n+  _next(element_name_offset) {\n+  assert(_buffer != nullptr, \"invariant\");\n+  assert(_next == element_name_offset, \"invariant\"); assert(_current == element_name_offset, \"invariant\");\n+}\n+\n+int JfrAnnotationElementIterator::value_index() const {\n+  return JfrBigEndian::read<int, u2>(_buffer + _current + value_relative_offset);\n+}\n+\n+bool JfrAnnotationElementIterator::has_next() const {\n+  return _next < _limit;\n+}\n+\n+void JfrAnnotationElementIterator::move_to_next() const {\n+  assert(has_next(), \"invariant\");\n+  _current = _next;\n+  if (_next < _limit) {\n+    _next = JfrAnnotationIterator::skip_annotation_value(_buffer, _limit, _next + element_name_size);\n+  }\n+  assert(_next <= _limit, \"invariant\"); assert(_current <= _limit, \"invariant\");\n+}\n+\n+int JfrAnnotationElementIterator::number_of_elements() const {\n+  return JfrBigEndian::read<int, u2>(_buffer + number_of_elements_offset);\n+}\n+\n+const Symbol* JfrAnnotationElementIterator::name() const {\n+  assert(_current < _next, \"invariant\");\n+  return _ik->constants()->symbol_at(JfrBigEndian::read<int, u2>(_buffer + _current));\n+}\n+\n+char JfrAnnotationElementIterator::value_type() const {\n+  return JfrBigEndian::read<char, u1>(_buffer + _current + value_type_relative_offset);\n+}\n+\n+jint JfrAnnotationElementIterator::read_int() const {\n+  return _ik->constants()->int_at(value_index());\n+}\n+\n+bool JfrAnnotationElementIterator::read_bool() const {\n+  return read_int() != 0;\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAnnotationElementIterator.cpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+* Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRANNOTATIONELEMENTITERATOR_HPP\n+#define SHARE_JFR_SUPPORT_JFRANNOTATIONELEMENTITERATOR_HPP\n+\n+#include \"jni.h\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"memory\/allocation.hpp\"\n+\n+class InstanceKlass;\n+class Symbol;\n+\n+class JfrAnnotationElementIterator : public StackObj {\n+ private:\n+  const InstanceKlass* _ik;\n+  const address _buffer;\n+  const int _limit; \/\/ length of annotation\n+  mutable int _current; \/\/ element\n+  mutable int _next; \/\/ element\n+  int value_index() const;\n+\n+ public:\n+  JfrAnnotationElementIterator(const InstanceKlass* ik, address buffer, int limit);\n+  bool has_next() const;\n+  void move_to_next() const;\n+  int number_of_elements() const;\n+  bool read_bool() const;\n+  jint read_int() const;\n+  char value_type() const;\n+  const Symbol* name() const;\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRANNOTATIONELEMENTITERATOR_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAnnotationElementIterator.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+* Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"jfr\/support\/jfrAnnotationIterator.hpp\"\n+#include \"jfr\/utilities\/jfrBigEndian.hpp\"\n+#include \"oops\/constantPool.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/symbol.hpp\"\n+\n+JfrAnnotationIterator::JfrAnnotationIterator(const InstanceKlass* ik, AnnotationArray* ar) :\n+ _ik(ik),\n+ _limit(ar != nullptr ? ar->length() : 0),\n+ _buffer(_limit > 2 ? ar->adr_at(2) : nullptr),\n+ _current(0),\n+ _next(0) {\n+  if (_limit >= 2) {\n+    _limit -= 2; \/\/ subtract sizeof(u2) number of annotations field\n+  }\n+}\n+\n+bool JfrAnnotationIterator::has_next() const {\n+  return _next < _limit;\n+}\n+\n+void JfrAnnotationIterator::move_to_next() const {\n+  assert(has_next(), \"invariant\");\n+  _current = _next;\n+  if (_next < _limit) {\n+    _next = next_annotation_index(_buffer, _limit, _next);\n+  }\n+  assert(_next <= _limit, \"invariant\");\n+  assert(_current <= _limit, \"invariant\");\n+}\n+\n+const Symbol* JfrAnnotationIterator::type() const {\n+  assert(_buffer != nullptr, \"invariant\");\n+  assert(_current < _limit, \"invariant\");\n+  return _ik->constants()->symbol_at(JfrBigEndian::read<int, u2>(_buffer + _current));\n+}\n+\n+address JfrAnnotationIterator::buffer() const {\n+  return _buffer;\n+}\n+\n+int JfrAnnotationIterator::current() const {\n+  return _current;\n+}\n+\n+int JfrAnnotationIterator::next() const {\n+  return _next;\n+}\n+\n+\/\/ Skip an annotation.  Return >=limit if there is any problem.\n+int JfrAnnotationIterator::next_annotation_index(const address buffer, int limit, int index) {\n+  assert(buffer != nullptr, \"invariant\");\n+  index += 2;  \/\/ skip atype\n+  if ((index += 2) >= limit) {\n+    return limit;\n+  }\n+  int nof_members = JfrBigEndian::read<int, u2>(buffer + index - 2);\n+  while (--nof_members >= 0 && index < limit) {\n+    index += 2; \/\/ skip member\n+    index = skip_annotation_value(buffer, limit, index);\n+  }\n+  return index;\n+}\n+\n+\/\/ Skip an annotation value.  Return >=limit if there is any problem.\n+int JfrAnnotationIterator::skip_annotation_value(const address buffer, int limit, int index) {\n+  assert(buffer != nullptr, \"invariant\");\n+  \/\/ value := switch (tag:u1) {\n+  \/\/   case B, C, I, S, Z, D, F, J, c: con:u2;\n+  \/\/   case e: e_class:u2 e_name:u2;\n+  \/\/   case s: s_con:u2;\n+  \/\/   case [: do(nval:u2) {value};\n+  \/\/   case @: annotation;\n+  \/\/   case s: s_con:u2;\n+  \/\/ }\n+  if ((index += 1) >= limit) {\n+    return limit;\n+  }\n+  const u1 tag = buffer[index - 1];\n+  switch (tag) {\n+    case 'B':\n+    case 'C':\n+    case 'I':\n+    case 'S':\n+    case 'Z':\n+    case 'D':\n+    case 'F':\n+    case 'J':\n+    case 'c':\n+    case 's':\n+      index += 2;  \/\/ skip con or s_con\n+      break;\n+    case 'e':\n+      index += 4;  \/\/ skip e_class, e_name\n+      break;\n+    case '[':\n+      {\n+        if ((index += 2) >= limit) {\n+          return limit;\n+        }\n+        int nof_values = JfrBigEndian::read<int, u2>(buffer + index - 2);\n+        while (--nof_values >= 0 && index < limit) {\n+          index = skip_annotation_value(buffer, limit, index);\n+        }\n+      }\n+      break;\n+    case '@':\n+      index = next_annotation_index(buffer, limit, index);\n+      break;\n+    default:\n+      return limit;  \/\/  bad tag byte\n+  }\n+  return index;\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAnnotationIterator.cpp","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+* Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRANNOTATIONITERATOR_HPP\n+#define SHARE_JFR_SUPPORT_JFRANNOTATIONITERATOR_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/annotations.hpp\"\n+\n+class Symbol;\n+class InstanceKlass;\n+\n+class JfrAnnotationIterator: public StackObj {\n+ friend class JfrAnnotationElementIterator;\n+ private:\n+  const InstanceKlass* _ik;\n+  \/\/ ensure _limit field is declared before _buffer\n+  int _limit; \/\/ length of annotations array\n+  const address _buffer;\n+  mutable int _current; \/\/ annotation\n+  mutable int _next; \/\/ annotation\n+  static int skip_annotation_value(const address buffer, int limit, int index);\n+  static int next_annotation_index(const address buffer, int limit, int index);\n+\n+ public:\n+  JfrAnnotationIterator(const InstanceKlass* ik, AnnotationArray* ar);\n+  bool has_next() const;\n+  void move_to_next() const;\n+  const Symbol* type() const;\n+  address buffer() const;\n+  int current() const;\n+  int next() const;\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRANNOTATIONITERATOR_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAnnotationIterator.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"jfr\/instrumentation\/jfrEventClassTransformer.hpp\"\n+#include \"jfr\/jfr.hpp\"\n@@ -40,0 +40,1 @@\n+#define EVENT_STICKY_BIT       8192\n@@ -42,1 +43,3 @@\n-#define ON_KLASS_CREATION(k, p, t) if (IS_EVENT_OR_HOST_KLASS(k)) JfrEventClassTransformer::on_klass_creation(k, p, t)\n+#define KLASS_HAS_STICKY_BIT(ptr) (((ptr)->trace_id() & STICKY_BIT) != 0)\n+#define ON_KLASS_REDEFINITION(k, t) if (KLASS_HAS_STICKY_BIT(k)) Jfr::on_klass_redefinition(k, t)\n+#define ON_KLASS_CREATION(k, p, t) Jfr::on_klass_creation(k, p, t)\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassExtension.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrClassFilterClosure.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilter.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ Previous_filter can be set to null if there is no instrumentation to remove.\n+JfrFilterClassClosure::JfrFilterClassClosure(const JfrFilter* previous_filter, const JfrFilter* new_filter, JavaThread* thread) :\n+  _previous_filter(previous_filter),\n+  _new_filter(new_filter),\n+  _thread(thread),\n+  _classes_to_modify(new (mtTracing) GrowableArray<jclass>(32, mtTracing)) {\n+}\n+\n+JfrFilterClassClosure::~JfrFilterClassClosure() {\n+  \/\/ Contents of _classes_to_modify are local JNI handles\n+  \/\/ which will be reclaimed by other means.\n+  delete _classes_to_modify;\n+}\n+\n+void JfrFilterClassClosure::do_klass(Klass* k) {\n+  assert(k != nullptr, \"invariant\");\n+  if (k->is_instance_klass()) {\n+    const InstanceKlass* const ik = InstanceKlass::cast(k);\n+    if (match(ik)) {\n+      assert(ik->is_loader_alive(), \"invariant\");\n+      _classes_to_modify->append(((jclass)JfrJavaSupport::local_jni_handle(ik->java_mirror(), _thread)));\n+    }\n+  }\n+}\n+\n+GrowableArray<jclass>* JfrFilterClassClosure::classes_to_modify() const {\n+  assert(_classes_to_modify != nullptr, \"invariant\");\n+  return _classes_to_modify;\n+}\n+\n+bool JfrFilterClassClosure::match(const InstanceKlass* ik) const {\n+  if (_previous_filter != nullptr) {\n+    if (_previous_filter->can_instrument_class(ik) && _previous_filter->match(ik)) {\n+      return true;\n+    }\n+  }\n+  return _new_filter->can_instrument_class(ik) && _new_filter->match(ik);\n+}\n+\n+void JfrFilterClassClosure::iterate_all_classes() {\n+  ClassLoaderDataGraph::loaded_classes_do_keepalive(this);\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrClassFilterClosure.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTERCLASSCLOSURE_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTERCLASSCLOSURE_HPP\n+\n+#include \"jni.h\"\n+#include \"memory\/iterator.hpp\"\n+\n+class JavaThread;\n+class JfrFilter;\n+class Klass;\n+template<typename T> class GrowableArray;\n+\n+\/\/\n+\/\/ Class that collects classes that should be retransformed,\n+\/\/ either for adding instrumentation (new_filter) or removing\n+\/\/ old instrumentation (previous_filter).\n+\/\/\n+class JfrFilterClassClosure : public KlassClosure {\n+ private:\n+  const JfrFilter* const _previous_filter;\n+  const JfrFilter* const _new_filter;\n+  JavaThread*            _thread;\n+  GrowableArray<jclass>* _classes_to_modify;\n+\n+  bool match(const InstanceKlass* klass) const;\n+ public:\n+  JfrFilterClassClosure(const JfrFilter* previous_filter, const JfrFilter* new_filter, JavaThread* thread);\n+  ~JfrFilterClassClosure();\n+  void do_klass(Klass* k);\n+  void iterate_all_classes();\n+  \/\/ Returned array is destroyed with the closure.\n+  GrowableArray<jclass>* classes_to_modify() const;\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTERCLASSCLOSURE_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrClassFilterClosure.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/support\/jfrAnnotationIterator.hpp\"\n+#include \"jfr\/support\/jfrJdkJfrEvent.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilter.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logMessage.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/method.inline.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+\n+JfrFilter::JfrFilter(Symbol** class_names,\n+                     Symbol** method_names,\n+                     Symbol** annotation_names,\n+                     int* modifications,\n+                     int count) :\n+  _class_names(class_names),\n+  _method_names(method_names),\n+  _annotation_names(annotation_names),\n+  _modifications(modifications),\n+  _count(count) {\n+}\n+\n+int JfrFilter::combine_bits(int a, int b) {\n+  if (a == -1) {\n+    return b;\n+  }\n+  if (b == -1) {\n+    return a;\n+  }\n+  return a | b;\n+}\n+\n+bool JfrFilter::can_instrument_module(const ModuleEntry* module) const {\n+  if (module == nullptr) {\n+    return true;\n+  }\n+  Symbol* name = module->name();\n+  if (name == nullptr) {\n+    return true;\n+  }\n+  if (name->equals(\"jdk.jfr\", 7)) {\n+    return false;\n+  }\n+  if (name->equals(\"jdk.proxy1\", 10)) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool JfrFilter::can_instrument_class(const InstanceKlass* ik) const {\n+  assert(ik != nullptr, \"invariant\");\n+  if (ik->is_hidden()) {\n+    return false;\n+  }\n+  if (JdkJfrEvent::is_a(ik)) {\n+    return false;\n+  }\n+  if (ik == vmClasses::Continuation_klass()) {\n+    return false;\n+  }\n+  return can_instrument_module(ik->module());\n+}\n+\n+\/\/ can_intrument(InstanceKlass*) is not called in this method\n+\/\/ to avoid executing the same code for every method in a class\n+bool JfrFilter::can_instrument_method(const Method* method) const {\n+  assert(method != nullptr, \"invariant\");\n+  if (method->is_abstract()) {\n+    return false;\n+  }\n+  if (method->is_synthetic()) {\n+    return false;\n+  }\n+  if (method->is_native()) {\n+    return false;\n+  }\n+  if (method->is_compiled_lambda_form()) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+int JfrFilter::method_modifications(const Method* method) const {\n+  assert(method != nullptr, \"invariant\");\n+  InstanceKlass* klass = method->method_holder();\n+  int result = -1;\n+  for (int i = 0; i < _count; i++) {\n+    Symbol* annotation_name = _annotation_names[i];\n+    if (annotation_name != nullptr) {\n+      if (match_annotations(klass, method->annotations(), annotation_name, false)) {\n+        result = combine_bits(result, _modifications[i]);\n+      }\n+    } else {\n+      Symbol* class_name = _class_names[i];\n+      if (class_name == nullptr || klass->name() == class_name) {\n+        Symbol* method_name = _method_names[i];\n+        if (method_name == nullptr || (method->name() == method_name && can_instrument_method(method))) {\n+          result = combine_bits(result, _modifications[i]);\n+        }\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+int JfrFilter::class_modifications(const InstanceKlass* ik, bool log) const {\n+  assert(ik != nullptr, \"invariant\");\n+  AnnotationArray* class_annotations = ik->class_annotations();\n+  if (class_annotations == nullptr) {\n+    return -1;\n+  }\n+  int result = -1;\n+  for (int i = 0; i < _count; i++) {\n+    const Symbol* annotation_filter = _annotation_names[i];\n+    if (annotation_filter != nullptr && match_annotations(ik, class_annotations, annotation_filter, log)) {\n+      result = combine_bits(result, _modifications[i]);\n+      if (log && log_is_enabled(Trace, methodtrace)) {\n+        ResourceMark rm;\n+        log_trace(jfr, methodtrace)(\"Class_modifications: %s bits = %d\", ik->external_name(), result);\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+bool JfrFilter::match(const InstanceKlass* ik) const {\n+  assert(ik != nullptr, \"invariant\");\n+  if (class_modifications(ik, false) != -1) {\n+    return true;\n+  }\n+  const Array<Method*>* methods = ik->methods();\n+  const int method_count = methods->length();\n+  for (int i = 0; i < method_count; i++) {\n+    if (method_modifications(methods->at(i)) != -1) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool JfrFilter::match_annotations(const InstanceKlass* ik, AnnotationArray* annotations, const Symbol* symbol, bool log) const {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(symbol != nullptr, \"invariant\");\n+  if (annotations == nullptr) {\n+    return false;\n+  }\n+  JfrAnnotationIterator it(ik, annotations);\n+  while (it.has_next()) {\n+    it.move_to_next();\n+    const Symbol* current = it.type();\n+    bool equal = current == symbol;\n+    if (log && log_is_enabled(Trace, methodtrace)) {\n+      ResourceMark rm;\n+      log_trace(jfr, methodtrace)(\n+        \"match_annotations: Class %s has annotation %s %s\",\n+        ik->external_name(),\n+        current->as_C_string(),\n+        (equal ? \"true\" : \"false\")\n+      );\n+    }\n+    if (current == symbol) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void JfrFilter::log(const char* caption) const {\n+  assert(caption != nullptr, \"invariant\");\n+  LogMessage(jfr,methodtrace) msg;\n+  msg.debug(\"%s = {\", caption);\n+  for (int i = 0; i < _count; i++) {\n+    const Symbol* m = _method_names[i];\n+    const Symbol* c = _class_names[i];\n+    const Symbol* a = _annotation_names[i];\n+    if (a != nullptr) {\n+      char annotation_buffer[100];\n+      a->as_klass_external_name(annotation_buffer, 100);\n+      size_t length = strlen(annotation_buffer);\n+      if (length > 2) {\n+        annotation_buffer[length - 1] = '\\0'; \/\/ remove trailing ';'\n+        msg.debug(\" @%s\", annotation_buffer + 1); \/\/ Skip 'L'\n+      }\n+    } else {\n+      char class_buffer[100];\n+      if (c != nullptr) {\n+        c->as_C_string(class_buffer, 100);\n+      } else {\n+        class_buffer[0] = '\\0';\n+      }\n+      if (m != nullptr) {\n+        char method_buffer[100];\n+        m->as_klass_external_name(method_buffer, 100);\n+        msg.debug(\" %s::%s\", class_buffer, method_buffer);\n+      } else {\n+        msg.debug(\" %s\", class_buffer);\n+      }\n+    }\n+  }\n+  msg.debug(\"}\");\n+}\n+\n+JfrFilter* JfrFilter::from(jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modification_array, TRAPS) {\n+  assert(classes != nullptr, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n+  assert(annotations != nullptr, \"invariant\");\n+  assert(modification_array != nullptr, \"invariant\");\n+\n+  intptr_t class_size = 0;\n+  Symbol** class_names = JfrJavaSupport::symbol_array(classes, THREAD, &class_size, true);\n+  assert(class_names != nullptr, \"invariant\");\n+\n+  intptr_t method_size = 0;\n+  Symbol** method_names = JfrJavaSupport::symbol_array(methods, THREAD, &method_size, true);\n+  assert(method_names != nullptr, \"invariant\");\n+\n+  intptr_t annotation_size = 0;\n+  Symbol** annotation_names = JfrJavaSupport::symbol_array(annotations, THREAD, &annotation_size, true);\n+  assert(annotation_names != nullptr, \"invariant\");\n+\n+  ResourceMark rm(THREAD);\n+  typeArrayOop ta = typeArrayOop(JfrJavaSupport::resolve_non_null(modification_array));\n+  typeArrayHandle modification_tah(THREAD, ta);\n+  int modification_size = modification_tah->length();\n+  int* modifications = NEW_C_HEAP_ARRAY(int, modification_size, mtTracing);\n+  for (int i = 0; i < modification_size; i++) {\n+    modifications[i] = modification_tah->int_at(i);\n+  }\n+  if (class_size != method_size || class_size != annotation_size ||\n+      class_size != modification_size) {\n+    FREE_C_HEAP_ARRAY(Symbol*, class_names);\n+    FREE_C_HEAP_ARRAY(Symbol*, method_names);\n+    FREE_C_HEAP_ARRAY(Symbol*, annotation_names);\n+    FREE_C_HEAP_ARRAY(int, modifications);\n+    JfrJavaSupport::throw_internal_error(\"Method array sizes don't match\", THREAD);\n+    return nullptr;\n+  }\n+  return new JfrFilter(class_names, method_names, annotation_names, modifications, modification_size);\n+}\n+\n+JfrFilter::~JfrFilter() {\n+  for (int i = 0; i < _count; i++) {\n+    Symbol::maybe_decrement_refcount(_class_names[i]);\n+    Symbol::maybe_decrement_refcount(_method_names[i]);\n+    Symbol::maybe_decrement_refcount(_annotation_names[i]);\n+  }\n+  FREE_C_HEAP_ARRAY(Symbol*, _class_names);\n+  FREE_C_HEAP_ARRAY(Symbol*, _method_names);\n+  FREE_C_HEAP_ARRAY(Symbol*, _annotation_names);\n+  FREE_C_HEAP_ARRAY(int, _modifications);\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilter.cpp","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTER_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTER_HPP\n+\n+#include \"jni.h\"\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/annotations.hpp\"\n+\n+class InstanceKlass;\n+class Method;\n+class ModuleEntry;\n+class Symbol;\n+\n+\/\/\n+\/\/ Class that holds the configured filters.\n+\/\/\n+\/\/ For information on how they are configured,\n+\/\/ see jdk.jfr.internal.JVM::setMethodTraceFilters(...).\n+\/\/\n+class JfrFilter : public CHeapObj<mtTracing> {\n+ private:\n+  Symbol** _class_names;\n+  Symbol** _method_names;\n+  Symbol** _annotation_names;\n+  int*     _modifications;\n+  int      _count;\n+\n+  JfrFilter(Symbol** class_names,\n+            Symbol** method_names,\n+            Symbol** annotation_names,\n+            int* modifications,\n+            int count);\n+ public:\n+  static JfrFilter* from(jobjectArray classses,\n+                         jobjectArray methods,\n+                         jobjectArray annotations,\n+                         jintArray modifications, TRAPS);\n+  static int combine_bits(int a, int b);\n+  ~JfrFilter();\n+  bool can_instrument_method(const Method* m) const;\n+  bool can_instrument_class(const InstanceKlass* m) const;\n+  bool can_instrument_module(const ModuleEntry* ik) const;\n+  int class_modifications(const InstanceKlass* klass, bool log) const;\n+  int method_modifications(const Method* method) const;\n+  bool match(const InstanceKlass* klass) const;\n+  bool match_annotations(const InstanceKlass* klass, AnnotationArray* annotation, const Symbol* symbol, bool log) const;\n+  \/\/ Requires ResourceMark\n+  void log(const char* caption) const;\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTER_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilter.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRINSTRUMENTEDCLASS_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRINSTRUMENTEDCLASS_HPP\n+\n+class InstanceKlass;\n+\n+\/\/\n+\/\/ Class that holds classes that are currently being instrumented and\n+\/\/ if the have been unloaded.\n+\/\/\n+class JfrInstrumentedClass {\n+ private:\n+  traceid              _trace_id;\n+  const InstanceKlass* _instance_klass;\n+  bool                 _unloaded;\n+\n+ public:\n+  JfrInstrumentedClass(traceid trace_id = 0, const InstanceKlass* instance_klass = nullptr, bool unloaded = false) :\n+    _trace_id(trace_id), _instance_klass(instance_klass), _unloaded(unloaded) {\n+  }\n+\n+  const InstanceKlass* instance_klass() const {\n+    return _instance_klass;\n+  }\n+\n+  traceid trace_id() const {\n+    return _trace_id;\n+  }\n+\n+  jlong trace_id_as_jlong() const {\n+    return static_cast<jlong>(_trace_id);\n+  }\n+\n+  void set_unloaded(bool unloaded) {\n+    _unloaded = unloaded;\n+  }\n+\n+  bool unloaded() const {\n+    return _unloaded;\n+  }\n+\n+  bool operator==(const JfrInstrumentedClass& rhs) {\n+    return _trace_id == rhs._trace_id;\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRINSTRUMENTEDCLASS_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilter.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrMethodProcessor.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+JfrMethodProcessor::JfrMethodProcessor(const InstanceKlass* ik) :\n+  _klass(ik),\n+  _methods(nullptr),\n+  _has_timing(false),\n+  _log(log_is_enabled(Debug, jfr, methodtrace)) {\n+  assert(ik != nullptr, \"invariant\");\n+}\n+\n+static inline bool is_timing(int modification) {\n+  return modification == -1 ? false : (modification & 1) != 0;\n+}\n+\n+static inline bool is_tracing(int modification) {\n+  return modification == -1 ? false : (modification & 2) != 0;\n+}\n+\n+static void log(const Method* method, traceid id, int previous_modification, int new_modification) {\n+  assert(method != nullptr, \"invariant\");\n+  const char* tracing = \"\";\n+  const char* timing = \"\";\n+  if (is_tracing(previous_modification) != is_tracing(new_modification)) {\n+    tracing = is_tracing(new_modification) ? \"+tracing \" : \"-tracing\";\n+  }\n+  if (is_timing(previous_modification) != is_timing(new_modification)) {\n+    tracing = is_timing(new_modification) ? \"+timing \" : \"-timing\";\n+  }\n+  stringStream param_stream;\n+  method->signature()->print_as_signature_external_parameters(&param_stream);\n+  const char* param_string = param_stream.as_string();\n+\n+  stringStream ss;\n+  ss.print(\"%s\", method->method_holder()->external_name());\n+  ss.print(\"::\");\n+  ss.print(\"%s\", method->name()->as_C_string());\n+  ss.print(\"(\");\n+  if (strlen(param_string) < 30) {\n+    ss.print(\"%s\", param_string);\n+  } else {\n+    ss.print(\"...\");\n+  }\n+  ss.print(\")\");\n+  log_debug(jfr, methodtrace)(\"Modify bytecode: %s %s%s (Method ID:\" UINT64_FORMAT \")\", ss.as_string(), tracing, timing, id);\n+}\n+\n+void JfrMethodProcessor::process(const JfrFilter* previous_filter, const JfrFilter* filter) {\n+  assert(filter != nullptr, \"invariant\");\n+  if (!filter->can_instrument_class(_klass)) {\n+    return;\n+  }\n+  const bool has_previous_filter = previous_filter != nullptr;\n+  const int class_modifications = filter->class_modifications(_klass, false);\n+  const int previous_class_modifications = has_previous_filter ? previous_filter->class_modifications(_klass, false) : -1;\n+  const Array<Method*>* const methods = _klass->methods();\n+  const int method_count = methods->length();\n+  for (int i = 0; i < method_count; i++) {\n+    const Method* const m = methods->at(i);\n+    assert(m != nullptr, \"invariant\");\n+    if (filter->can_instrument_method(m)) {\n+      int new_modification = filter->method_modifications(m);\n+      new_modification = JfrFilter::combine_bits(class_modifications, new_modification);\n+      int previous_modification = class_modifications;\n+      if (has_previous_filter) {\n+        previous_modification = JfrFilter::combine_bits(previous_modification, previous_filter->method_modifications(m));\n+      }\n+      const int previous_and_new = JfrFilter::combine_bits(previous_modification, new_modification);\n+      if (previous_and_new != -1) {\n+        \/\/ Allocate lazy, most classes will not match a filter\n+        if (_methods == nullptr) {\n+          _methods = new GrowableArray<JfrTracedMethod>();\n+        }\n+        set_timing(new_modification);\n+        int modification = new_modification == -1 ? 0 : new_modification;\n+        JfrTracedMethod traced_method(_klass, m, modification, i);\n+        _methods->append(traced_method);\n+        if (_log) {\n+          log(m, traced_method.id(), previous_modification, new_modification);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void JfrMethodProcessor::set_timing(int modification) {\n+  if (_has_timing) {\n+    return;\n+  }\n+  if (modification > 0 && (modification & 1)) {\n+    _has_timing = true;\n+  }\n+}\n+\n+void JfrMethodProcessor::update_methods(const InstanceKlass* ik) {\n+ assert(ik != nullptr, \"invariant\");\n+ assert(_methods != nullptr, \"invariant\");\n+ for (int i = 0; i < _methods->length(); ++i) {\n+     _methods->at(i).set_method_from_klass(ik);\n+   }\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodProcessor.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODPROCESSOR_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODPROCESSOR_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class InstanceKlass;\n+class JfrFilter;\n+class JfrTracedMethod;\n+template <typename> class GrowableArray;\n+\n+\/\/\n+\/\/ Class responsible for determining which methods in an InstanceKlass\n+\/\/ that should be instrumented and tagged.\n+\/\/\n+class JfrMethodProcessor: public StackObj {\n+ private:\n+  const InstanceKlass* const      _klass;\n+  GrowableArray<JfrTracedMethod>* _methods;\n+  bool                            _has_timing;\n+  bool                            _log;\n+\n+  void set_timing(int modification);\n+ public:\n+  JfrMethodProcessor(const InstanceKlass* klass);\n+  void process(const JfrFilter* previous_filter, const JfrFilter* filter);\n+\n+  bool has_methods() const {\n+    return _methods != nullptr;\n+  }\n+\n+  const GrowableArray<JfrTracedMethod>* methods() const {\n+    return _methods;\n+  }\n+\n+  GrowableArray<JfrTracedMethod>* methods() {\n+    return _methods;\n+  }\n+\n+  void update_methods(const InstanceKlass* ik);\n+\n+  bool has_timing() const {\n+    return _has_timing;\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODPROCESSOR_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodProcessor.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,327 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/classFileParser.hpp\"\n+#include \"classfile\/classFileStream.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/modules.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"jfr\/instrumentation\/jfrClassTransformer.hpp\"\n+#include \"jfr\/instrumentation\/jfrJvmtiAgent.hpp\"\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/jni\/jfrUpcalls.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n+#include \"jfr\/support\/jfrKlassUnloading.hpp\"\n+#include \"jfr\/support\/methodtracer\/\/jfrTracedMethod.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrClassFilterClosure.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilter.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrMethodProcessor.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrTraceTagging.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+const JfrFilter*                     JfrMethodTracer::_filter = nullptr;\n+const JfrFilter*                     JfrMethodTracer::_previous_filter = nullptr;\n+ModuleEntry*                         JfrMethodTracer::_jdk_jfr_module = nullptr;\n+GrowableArray<JfrInstrumentedClass>* JfrMethodTracer::_instrumented_classes = nullptr;\n+GrowableArray<jlong>*                JfrMethodTracer::_unloaded_class_ids = nullptr;\n+\n+static inline void log_add(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  if (log_is_enabled(Debug, jfr, methodtrace)) {\n+    ResourceMark rm;\n+    log_debug(jfr, methodtrace)(\"Adding class %s to instrumented list\", ik->external_name());\n+  }\n+}\n+\n+\/\/ Quick and unlocked check to see if the Method Tracer has been activated.\n+\/\/ This is flipped to not null the first time a filter is set and will stay non-null forever.\n+bool JfrMethodTracer::in_use() {\n+  return _filter != nullptr;\n+}\n+\n+jlongArray JfrMethodTracer::set_filters(JNIEnv* env, jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modifications, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+\n+  const JfrFilter* const new_filter = JfrFilter::from(classes, methods, annotations, modifications, THREAD);\n+  if (new_filter == nullptr) {\n+    return nullptr;\n+  }\n+  const JfrFilter* const previous_filter = current_filter();\n+  JfrFilterClassClosure filter_class_closure(previous_filter, new_filter, THREAD);\n+  {\n+    MutexLocker lock(ClassLoaderDataGraph_lock);\n+    filter_class_closure.iterate_all_classes();\n+    JfrTraceTagging::clear(instrumented_classes());\n+  }\n+\n+  set_filters(previous_filter, new_filter);\n+  retransform(env, filter_class_closure.classes_to_modify(), THREAD);\n+  set_filters(nullptr, new_filter);\n+  delete previous_filter;\n+\n+  ResourceMark rm(THREAD);\n+  GrowableArray<jlong>* to_be_published = collect_new_timing_entries();\n+  if (to_be_published->is_nonempty()) {\n+    return JfrJavaSupport::create_long_array(to_be_published, THREAD);\n+  }\n+  return nullptr;\n+}\n+\n+GrowableArray<jlong>* JfrMethodTracer::collect_new_timing_entries() {\n+  GrowableArray<jlong>* result = new GrowableArray<jlong>(256);\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+  GrowableArray<JfrInstrumentedClass>* instrumented = instrumented_classes();\n+  assert(instrumented != nullptr, \"invariant\");\n+  const int length = instrumented->length();\n+  if (length == 0) {\n+    return result;\n+  }\n+  JfrKlassUnloading::sort(true);\n+  for (int i = 0; i < length; i++) {\n+    const JfrInstrumentedClass& jic = instrumented->at(i);\n+    traceid trace_id = jic.trace_id();\n+    if (!JfrKlassUnloading::is_unloaded(trace_id)) {\n+      const InstanceKlass* ik = jic.instance_klass();\n+      assert(HAS_STICKY_BIT(ik), \"invariant\");\n+      if (HAS_TIMING_BIT(ik)) {\n+        CLEAR_TIMING_BIT(ik);\n+        assert(HAS_NOT_TIMING_BIT(ik), \"invariant\");\n+        result->append(trace_id);\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+void JfrMethodTracer::retransform(JNIEnv* env, GrowableArray<jclass>* class_array, TRAPS) {\n+  assert(class_array != nullptr, \"invariant\");\n+  int class_count = class_array->length();\n+  if (class_count > 0) {\n+    ResourceMark rm(THREAD);\n+    ThreadToNativeFromVM state(THREAD);\n+    jclass* classes = NEW_C_HEAP_ARRAY(jclass, class_count, mtTracing);\n+    for (int i = 0; i < class_count; i++) {\n+      classes[i] = class_array->at(i);\n+    }\n+    JfrJvmtiAgent::retransform_classes(env, classes, class_count, THREAD);\n+    FREE_C_HEAP_ARRAY(jclass, classes);\n+  }\n+}\n+\n+void JfrMethodTracer::set_filters(const JfrFilter* previous_filter, const JfrFilter* new_filter) {\n+  MutexLocker lock(JfrMethodTracer_lock, Mutex::_no_safepoint_check_flag);\n+  _previous_filter = previous_filter;\n+  if (_filter != new_filter) {\n+    _filter = new_filter;\n+    _filter->log(\"Current filter\");\n+  }\n+}\n+\n+const JfrFilter* JfrMethodTracer::current_filter() {\n+  MutexLocker lock(JfrMethodTracer_lock, Mutex::_no_safepoint_check_flag);\n+  return _filter;\n+}\n+\n+void JfrMethodTracer::on_klass_creation(InstanceKlass*& ik, ClassFileParser& parser, TRAPS) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(in_use(), \"invariant\");\n+  \/\/ 1. Is the ik the initial load, i.e.the first InstanceKlass, or a scratch klass, denoting a redefine \/ retransform?\n+  const Klass* const existing_klass = JfrClassTransformer::find_existing_klass(ik, THREAD);\n+  const bool is_redefine = existing_klass != nullptr;\n+\n+  \/\/ 2. Test the ik and its methods against the installed filters.\n+  JfrMethodProcessor mp(is_redefine ? InstanceKlass::cast(existing_klass) : ik);\n+  {\n+    MutexLocker lock(JfrMethodTracer_lock, Mutex::_no_safepoint_check_flag);\n+    mp.process(_previous_filter, _filter);\n+  }\n+  if (!mp.has_methods()) {\n+    return;\n+  }\n+\n+  \/\/ 3. We matched one or more filters. Now construct a new InstanceKlass with instrumented methods in accordance with matches.\n+  ResourceMark rm(THREAD);\n+  const ClassFileStream* clone = parser.clone_stream();\n+  ClassFileStream* const result = JfrUpcalls::on_method_trace(ik, clone, mp.methods(), THREAD);\n+  if (result != nullptr) {\n+    InstanceKlass* const new_ik = JfrClassTransformer::create_instance_klass(ik, result, !is_redefine, THREAD);\n+    if (new_ik != nullptr) {\n+      JfrClassTransformer::copy_traceid(ik, new_ik); \/\/ copy existing traceid\n+      if (is_redefine) {\n+        \/\/ Keep the original cached class file data from the existing class.\n+        JfrClassTransformer::transfer_cached_class_file_data(ik, new_ik, parser, THREAD);\n+        JfrClassTransformer::rewrite_klass_pointer(ik, new_ik, parser, THREAD); \/\/ The ik is modified to point to new_ik here.\n+        \/\/ By setting the sticky bit on the existng klass, we receive a callback into on_klass_redefinition (see below)\n+        \/\/ when our new methods are installed into the existing klass during retransformation \/ redefinition.\n+        const InstanceKlass* existing_ik = InstanceKlass::cast(existing_klass);\n+        mp.update_methods(existing_ik);\n+        existing_ik->module()->add_read(jdk_jfr_module());\n+        JfrTraceTagging::install_sticky_bit_for_retransform_klass(existing_ik, mp.methods(), mp.has_timing());\n+      } else {\n+        \/\/ Initial class load.\n+        JfrClassTransformer::cache_class_file_data(new_ik, clone, THREAD); \/\/ save the initial class file bytes (clone stream)\n+        JfrClassTransformer::rewrite_klass_pointer(ik, new_ik, parser, THREAD); \/\/ The ik is modified to point to new_ik here.\n+        \/\/ The initial class load can be installed into the instrumented class list directly.\n+        mp.update_methods(ik);\n+        add_instrumented_class(ik, mp.methods());\n+        if (mp.has_timing()) {\n+          JfrUpcalls::publish_method_timers_for_klass(JfrTraceId::load_raw(ik), THREAD);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ At this point we have installed our retransformed methods into the original klass, which is ik.\n+\/\/ jvmtiRedefineClassses::redefine_single_class() has finished so we are still at a safepoint.\n+\/\/ If the original klass is not already in the list, add it and also dynamically tag all\n+\/\/ artifacts that have the sticky bit set.\n+void JfrMethodTracer::on_klass_redefinition(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invarint\");\n+  assert(ik->has_been_redefined(), \"invariant\");\n+  assert(HAS_STICKY_BIT(ik), \"invariant\");\n+  assert(in_use(), \"invariant\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  if (!JfrRecorder::is_recording()) {\n+    JfrTraceTagging::clear_sticky_bit(ik, false);\n+    return;\n+  }\n+  GrowableArray<JfrInstrumentedClass>* const instrumented = instrumented_classes();\n+  JfrInstrumentedClass jic(JfrTraceId::load_raw(ik), ik, false);\n+\n+  assert(instrumented != nullptr, \"invariant\");\n+  if (instrumented->find(jic) == -1) { \/\/ not already existing\n+    const int idx = instrumented_classes()->append(jic);\n+    if (idx == 0) {\n+      assert(!JfrTraceIdEpoch::has_method_tracer_changed_tag_state(), \"invariant\");\n+      JfrTraceIdEpoch::set_method_tracer_tag_state();\n+    }\n+    JfrTraceTagging::set_dynamic_tag_for_sticky_bit(ik);\n+    log_add(ik);\n+  }\n+}\n+\n+#ifdef ASSERT\n+static bool in_instrumented_list(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  const GrowableArray<JfrInstrumentedClass>* const instrumented = JfrMethodTracer::instrumented_classes();\n+  assert(instrumented != nullptr, \"invariant\");\n+  const JfrInstrumentedClass jic(JfrTraceId::load_raw(ik), ik, false);\n+  return instrumented->find(jic) != -1;\n+}\n+#endif\n+\n+void JfrMethodTracer::add_instrumented_class(InstanceKlass* ik, GrowableArray<JfrTracedMethod>* methods) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+  assert(methods->is_nonempty(), \"invariant\");\n+  ik->module()->add_read(jdk_jfr_module());\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+  assert(!in_instrumented_list(ik), \"invariant\");\n+  JfrTraceTagging::set_dynamic_tag(ik, methods);\n+  JfrTraceTagging::set_sticky_bit(ik, methods);\n+  JfrInstrumentedClass jik(JfrTraceId::load_raw(ik), ik, false);\n+  const int idx = instrumented_classes()->append(jik);\n+  if (idx == 0) {\n+    JfrTraceIdEpoch::set_method_tracer_tag_state();\n+  }\n+  assert(in_instrumented_list(ik), \"invariant\");\n+  log_add(ik);\n+}\n+\n+GrowableArray<JfrInstrumentedClass>* JfrMethodTracer::instrumented_classes() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  if (_instrumented_classes == nullptr) {\n+    _instrumented_classes = new (mtTracing) GrowableArray<JfrInstrumentedClass>(10, mtTracing);\n+    _unloaded_class_ids = new (mtTracing) GrowableArray<jlong>(10, mtTracing);\n+  }\n+  return _instrumented_classes;\n+}\n+\n+jlongArray JfrMethodTracer::drain_stale_class_ids(TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD);)\n+  if (!in_use()) {\n+    return nullptr;\n+  }\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+  if (_unloaded_class_ids == nullptr || _unloaded_class_ids->is_empty()) {\n+    return nullptr;\n+  }\n+  return JfrJavaSupport::create_long_array(_unloaded_class_ids, THREAD);\n+}\n+\n+ModuleEntry* JfrMethodTracer::jdk_jfr_module() {\n+  if (_jdk_jfr_module == nullptr) {\n+    MutexLocker ml(Module_lock);\n+    ModuleEntryTable* table = Modules::get_module_entry_table(Handle());\n+    Symbol* jfr_module_name = SymbolTable::probe(\"jdk.jfr\", 7);\n+    assert(jfr_module_name != nullptr, \"jdk.jfr name could not be found\");\n+    _jdk_jfr_module = table->lookup_only(jfr_module_name);\n+    assert(_jdk_jfr_module != nullptr, \"jdk.jfr module could not be found\");\n+  }\n+  return _jdk_jfr_module;\n+}\n+\n+\/\/ Invoked from JfrTypeSet\n+\n+void JfrMethodTracer::clear_instrumented_classes() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(!JfrRecorder::is_recording(), \"invariant\");\n+  if (_instrumented_classes != nullptr) {\n+    JfrTraceTagging::clear(_instrumented_classes, false);\n+  }\n+}\n+\n+void JfrMethodTracer::trim_instrumented_classes() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(JfrTraceIdEpoch::has_method_tracer_changed_tag_state(), \"invariant\");\n+  GrowableArray<JfrInstrumentedClass>* trimmed_classes = new (mtTracing) GrowableArray<JfrInstrumentedClass>(10, mtTracing);\n+  for (int i = 0; i < _instrumented_classes->length(); i++) {\n+    const JfrInstrumentedClass& jic = _instrumented_classes->at(i);\n+    if (jic.unloaded()) {\n+      _unloaded_class_ids->append(jic.trace_id_as_jlong());\n+    } else {\n+      trimmed_classes->append(jic);\n+    }\n+  }\n+  delete _instrumented_classes;\n+  _instrumented_classes = trimmed_classes;\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodTracer.cpp","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODTRACER_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODTRACER_HPP\n+\n+#include \"jni.h\"\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+class ClassFileParser;\n+class InstanceKlass;\n+class JavaThread;\n+class JfrFilter;\n+class JfrInstrumentedClass;\n+class JfrMethodProcessor;\n+class JfrTracedMethod;\n+class ModuleEntry;\n+\n+template <typename E> class GrowableArray;\n+\n+\/\/\n+\/\/ Class responsible for holding filters, collecting methods to\n+\/\/ be instrumented and calling Java to create the appropriate bytecode.\n+\/\/\/\n+class JfrMethodTracer: AllStatic {\n+ private:\n+  static const JfrFilter*                     _filter;               \/\/ Guarded by JfrMethodTracer_lock\n+  static const JfrFilter*                     _previous_filter;      \/\/ Guarded by JfrMethodTracer_lock\n+  static ModuleEntry*                         _jdk_jfr_module;       \/\/ Guarded by Module_lock\n+  static GrowableArray<JfrInstrumentedClass>* _instrumented_classes; \/\/ Guarded by ClassLoaderDataGraph_lock\n+  static GrowableArray<jlong>*                _unloaded_class_ids;   \/\/ Guarded by ClassLoaderDataGraph_lock\n+\n+  static GrowableArray<jlong>* collect_new_timing_entries();\n+  static ModuleEntry* jdk_jfr_module();\n+  static void retransform(JNIEnv* env, GrowableArray<jclass>* class_array, TRAPS);\n+  static void set_filters(const JfrFilter* previous_filter, const JfrFilter* filter);\n+  static const JfrFilter* current_filter();\n+ public:\n+  static bool in_use();\n+  static jlongArray set_filters(JNIEnv* env, jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modifications, TRAPS);\n+  static void on_klass_creation(InstanceKlass*& ik, ClassFileParser& parser, TRAPS);\n+  static void on_klass_redefinition(const InstanceKlass* ik, Thread* thread);\n+  static GrowableArray<JfrInstrumentedClass>* instrumented_classes();\n+  static void add_instrumented_class(InstanceKlass* ik, GrowableArray<JfrTracedMethod>* methods);\n+  static void clear_instrumented_classes();\n+  static jlongArray drain_stale_class_ids(TRAPS);\n+  static void trim_instrumented_classes();\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODTRACER_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodTracer.hpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdBits.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp\"\n+#include \"jfr\/support\/jfrKlassUnloading.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrTraceTagging.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/method.hpp\"\n+\n+void JfrTraceTagging::set_dynamic_tag(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+\n+  tag_dynamic(methods);\n+  tag_dynamic(ik);\n+}\n+\n+void JfrTraceTagging::set_dynamic_tag_for_sticky_bit(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+  assert(HAS_STICKY_BIT(ik), \"invariant\");\n+\n+  const int length = ik->methods()->length();\n+  for (int i = 0; i < length; ++i) {\n+    const Method* const m = ik->methods()->at(i);\n+    if (METHOD_HAS_STICKY_BIT(m)) {\n+      tag_dynamic(m);\n+    }\n+  }\n+  tag_dynamic(ik);\n+}\n+\n+void JfrTraceTagging::install_sticky_bit_for_retransform_klass(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods, bool timing) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+\n+  tag_sticky(methods);\n+  tag_sticky(ik);\n+  if (timing) {\n+    tag_timing(ik);\n+  }\n+}\n+\n+void JfrTraceTagging::set_sticky_bit(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+\n+  tag_sticky(methods);\n+  tag_sticky(ik);\n+}\n+\n+void JfrTraceTagging::clear_sticky_bit(const InstanceKlass* ik, bool dynamic_tag) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+  assert(HAS_STICKY_BIT(ik), \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+\n+  const Array<Method*>* const methods = ik->methods();\n+  assert(methods != nullptr, \"invariant\");\n+  const int length = methods->length();\n+  for (int i = 0; i < length; ++i) {\n+    const Method* const m = methods->at(i);\n+    if (METHOD_HAS_STICKY_BIT(m)) {\n+      if (dynamic_tag) {\n+        tag_dynamic(m);\n+      }\n+      CLEAR_STICKY_BIT_METHOD(m);\n+      assert(METHOD_HAS_NOT_STICKY_BIT(m), \"invariant\");\n+    }\n+  }\n+  if (dynamic_tag) {\n+    tag_dynamic(ik);\n+  }\n+  CLEAR_STICKY_BIT(ik);\n+  assert(HAS_NOT_STICKY_BIT(ik), \"invariant\");\n+  if (HAS_TIMING_BIT(ik)) {\n+    CLEAR_TIMING_BIT(ik);\n+  }\n+  assert(HAS_NOT_TIMING_BIT(ik), \"invariant\");\n+}\n+\n+void JfrTraceTagging::clear(GrowableArray<JfrInstrumentedClass>* instrumented, bool dynamic_tag) {\n+  assert(instrumented != nullptr, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+\n+  if (instrumented->is_empty()) {\n+    assert(!JfrTraceIdEpoch::has_method_tracer_changed_tag_state(), \"invariant\");\n+    return;\n+  }\n+  JfrTraceIdEpoch::reset_method_tracer_tag_state();\n+  JfrKlassUnloading::sort(true);\n+  const int length = instrumented->length();\n+  assert(length > 0, \"invariant\");\n+  for (int i = 0; i < length; ++i) {\n+    if (!JfrKlassUnloading::is_unloaded(instrumented->at(i).trace_id(), true)) {\n+      const InstanceKlass* ik = instrumented->at(i).instance_klass();\n+      assert(instrumented->at(i).trace_id() == JfrTraceId::load_raw(ik), \"invariant\");\n+      clear_sticky_bit(ik, dynamic_tag);\n+      if (log_is_enabled(Debug, jfr, methodtrace)) {\n+        ResourceMark rm;\n+        log_debug(jfr, methodtrace)(\"Removing class %s from instrumented list\", ik->external_name());\n+      }\n+    }\n+  }\n+  instrumented->clear();\n+}\n+\n+\/\/ PRIVATE METHODS\n+\n+void JfrTraceTagging::tag_dynamic(const InstanceKlass* ik) {\n+  JfrTraceIdLoadBarrier::load_barrier(ik);\n+}\n+\n+void JfrTraceTagging::tag_dynamic(const GrowableArray<JfrTracedMethod>* methods) {\n+  for (int i = 0; i < methods->length(); ++i) {\n+    tag_dynamic(methods->at(i).method());\n+  }\n+}\n+\n+void JfrTraceTagging::tag_dynamic(const Method* method) {\n+  JfrTraceId::load_no_enqueue(method);\n+}\n+\n+void JfrTraceTagging::tag_sticky(const InstanceKlass* ik) {\n+  assert(HAS_NOT_STICKY_BIT(ik), \"invariant\");\n+  SET_STICKY_BIT(ik);\n+  assert(HAS_STICKY_BIT(ik), \"invariant\");\n+}\n+\n+void JfrTraceTagging::tag_sticky(const GrowableArray<JfrTracedMethod>* methods) {\n+  for (int i = 0; i < methods->length(); ++i) {\n+    tag_sticky(methods->at(i).method());\n+  }\n+}\n+\n+void JfrTraceTagging::tag_sticky(const Method* method) {\n+  assert(METHOD_HAS_NOT_STICKY_BIT(method), \"invariant\");\n+  SET_METHOD_STICKY_BIT(method);\n+  assert(METHOD_HAS_STICKY_BIT(method), \"invariant\");\n+}\n+\n+void JfrTraceTagging::tag_timing(const InstanceKlass* ik) {\n+  assert(HAS_NOT_TIMING_BIT(ik), \"invariant\");\n+  SET_TIMING_BIT(ik);\n+  assert(HAS_TIMING_BIT(ik), \"invariant\");\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrTraceTagging.cpp","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACETAGGING_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACETAGGING_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+\n+class InstanceKlass;\n+class JfrInstrumentedClass;\n+class JfrMethodProcessor;\n+class Method;\n+template <typename E> class GrowableArray;\n+\n+\/\/\n+\/\/ Class responsible for setting setting sticky, epoch, and timing bits.\n+\/\/\/\n+class JfrTraceTagging : AllStatic {\n+ private:\n+  static void tag_dynamic(const InstanceKlass* ik);\n+  static void tag_dynamic(const GrowableArray<JfrTracedMethod>* methods);\n+  static void tag_dynamic(const Method* method);\n+  static void tag_sticky(const InstanceKlass* ik);\n+  static void tag_sticky(const Method* method);\n+  static void tag_sticky(const GrowableArray<JfrTracedMethod>* methods);\n+  static void tag_timing(const InstanceKlass* ik);\n+ public:\n+  static void set_dynamic_tag(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n+  static void set_dynamic_tag_for_sticky_bit(const InstanceKlass* ik);\n+  static void install_sticky_bit_for_retransform_klass(const InstanceKlass* existing_klass, const GrowableArray<JfrTracedMethod>* methods, bool timing);\n+  static void set_sticky_bit(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n+  static void clear_sticky_bit(const InstanceKlass* ik, bool dynamic_tag = true);\n+  static void clear(GrowableArray<JfrInstrumentedClass>* instrumented, bool dynamic_tag = true);\n+};\n+\n+#endif \/* SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACETAGGING_HPP *\/\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrTraceTagging.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACEDMETHOD_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACEDMETHOD_HPP\n+\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+class InstanceKlass;\n+class Method;\n+\n+\/\/\n+\/\/ Method that has been filtered out for tracing, may or may not yet be\n+\/\/ instrumented.\n+\/\/\n+class JfrTracedMethod {\n+ private:\n+  traceid       _id;\n+  const Symbol* _name;\n+  const Symbol* _signature;\n+  const Method* _method;\n+  int32_t       _modification;\n+  int32_t       _methods_array_index;\n+\n+ public:\n+  JfrTracedMethod(const InstanceKlass* ik, const Method* method, int32_t modification, int32_t methods_array_index) :\n+      _id(method_id(ik, method)), _name(method->name()), _signature(method->signature()), _method(nullptr), _modification(modification), _methods_array_index(methods_array_index) {\n+    assert(_method == nullptr, \"invariant\");\n+  }\n+\n+  JfrTracedMethod() :\n+      _id(0), _name(nullptr), _signature(nullptr), _method(nullptr), _modification(0), _methods_array_index(0) {\n+  }\n+\n+  traceid id() const {\n+    return _id;\n+  }\n+\n+  const Symbol* name() const {\n+    return _name;\n+  }\n+\n+  const Symbol* signature() const {\n+    return _signature;\n+  }\n+\n+  const Method* method() const {\n+    assert(_method != nullptr, \"Traced method must be set before it can be used\");\n+    return _method;\n+  }\n+\n+  void set_method_from_klass(const InstanceKlass* ik) {\n+    Array<Method*>* ik_methods = ik->methods();\n+    assert(ik_methods != nullptr, \"invariant\");\n+    _method = ik_methods->at(_methods_array_index);\n+  }\n+\n+  int32_t modification() const {\n+    return _modification;\n+  }\n+\n+  static traceid method_id(const InstanceKlass* ik, const Method* m) {\n+    assert(ik != nullptr, \"invariant\");\n+    assert(m != nullptr, \"invariant\");\n+    return METHOD_ID(ik, m);\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACEDMETHOD_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrTracedMethod.hpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,2 @@\n-  JFR_LOG_TAG(jfr, start)\n+  JFR_LOG_TAG(jfr, start) \\\n+  JFR_LOG_TAG(jfr, methodtrace)\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLogTagSets.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,1 @@\n+  LOG_TAG(methodtrace) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4397,0 +4397,2 @@\n+  JFR_ONLY(ON_KLASS_REDEFINITION(the_class, current);)\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,0 +119,2 @@\n+Monitor* JfrMethodTracer_lock         = nullptr;\n+\n@@ -279,0 +281,1 @@\n+  MUTEX_DEFN(JfrMethodTracer_lock            , PaddedMonitor, nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+extern Monitor* JfrMethodTracer_lock;            \/\/ protects JFR method tracing data structures\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Timespan;\n+import jdk.jfr.internal.RemoveFields;\n+\n+@Name(\"jdk.MethodTiming\")\n+@Label(\"Method Timing\")\n+@Category({ \"Java Virtual Machine\", \"Method Tracing\" })\n+@RemoveFields({ \"duration\", \"eventThread\", \"stackTrace\" })\n+public final class MethodTimingEvent extends AbstractJDKEvent {\n+\n+    @Label(\"Method\")\n+    public long method;\n+\n+    @Label(\"Invocations\")\n+    public long invocations;\n+\n+    @Label(\"Average Time\")\n+    @Timespan\n+    public long average;\n+\n+    public static void commit(long start, long method, long invocations, long average) {\n+        \/\/ Generated by JFR\n+    }\n+\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0;\n+    }\n+\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/MethodTimingEvent.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.StackTrace;\n+\n+@Name(\"jdk.MethodTrace\")\n+@Label(\"Method Trace\")\n+@Category({ \"Java Virtual Machine\", \"Method Tracing\" })\n+@StackTrace(true)\n+public final class MethodTraceEvent extends AbstractJDKEvent {\n+\n+    @Label(\"Method\")\n+    private long method;\n+\n+    public static void commit(long start, long duration, long method) {\n+        \/\/ Generated by JFR\n+    }\n+\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0;\n+    }\n+\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/MethodTraceEvent.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.jfr.internal.settings.MethodSetting;\n@@ -56,0 +57,1 @@\n+import jdk.jfr.internal.tracing.Modification;\n@@ -73,0 +75,1 @@\n+    private static final Type TYPE_METHOD_FILTER = TypeLibrary.createType(MethodSetting.class);\n@@ -98,0 +101,4 @@\n+        if (eventType.getModification() != Modification.NONE) {\n+            addControl(\"filter\", defineMethodFilter(eventType, eventType.getModification()));\n+        }\n+\n@@ -338,0 +345,6 @@\n+    private Control defineMethodFilter(PlatformEventType type, Modification modification) {\n+        String def = \"\";\n+        type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_METHOD_FILTER, \"filter\", def, Collections.emptyList()));\n+        return new Control(new MethodSetting(type, modification, def), def);\n+    }\n+\n@@ -342,1 +355,6 @@\n-                return;\n+            } else {\n+                String v = nc.control.getDefaultValue();\n+                \/\/ Avoids slow retransformation during shutdown\n+                if (v != null && PlatformRecorder.isInShutDown()) {\n+                    nc.control.setValue(v);\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.jfr.events.MethodTimingEvent;\n+import jdk.jfr.events.MethodTraceEvent;\n@@ -46,0 +48,2 @@\n+import jdk.jfr.internal.tracing.PlatformTracer;\n+import jdk.jfr.tracing.MethodTracer;\n@@ -76,0 +80,2 @@\n+        MethodTraceEvent.class,\n+        MethodTimingEvent.class\n@@ -86,0 +92,1 @@\n+    private static final Runnable emitMethodTiming = JDKEvents::emitMethodTiming;\n@@ -99,0 +106,1 @@\n+                PeriodicEvents.addJavaEvent(MethodTimingEvent.class, emitMethodTiming);\n@@ -203,0 +211,1 @@\n+        PeriodicEvents.removeEvent(emitMethodTiming);\n@@ -227,0 +236,6 @@\n+\n+    private static void emitMethodTiming() {\n+        if (MethodTimingEvent.enabled()) {\n+            PlatformTracer.emitTiming();\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JDKEvents.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -685,0 +685,65 @@\n+\n+    \/**\n+    * Sets method tracing filters.\n+     *\n+     * A filter can be a class, a method, or an annotation.\n+     *\n+     * For example, the following three filters:\n+     * <ul>\n+     * <li>Method timing on all methods in class com.foo.Bar<\/li>\n+     * <li>Method tracing on the method com.foo.Bar::baz<\/li>\n+     * <li>Method timing and tracing on all methods or classes with the annotation @com.foo.Foo<\/li>\n+     * <\/ul>\n+     * can be set using the following code:\n+     * <pre>\n+     * String[] classes = new String[3];\n+     * classes[0] = \"com\/foo\/Bar\";\n+     * classes[1] = \"com\/foo\/Bar\";\n+     * classes[2] = null;\n+     *\n+     * String[] methods = new String[3];\n+     * methods[0] = null;\n+     * methods[1] = \"baz\";\n+     * methods[2] = null;\n+     *\n+     * String[] annotations = new String[3];\n+     * annotations[0] = null;\n+     * annotations[1] = null;\n+     * annotations[2] = \"com\/foo\/Foo\";\n+     *\n+     * int[] modifications = new int[3];\n+     * modifications[0] = 1; \/\/ filter should apply to timing\n+     * modifications[1] = 2; \/\/ filter should apply to tracing\n+     * modifications[2] = 1 | 2; \/\/ filter should apply to both timing and tracing\n+     *\n+     * JVM.setMethodTraceFilters(classes, methods, annotations, modifications);\n+     * <\/pre>\n+     * The filter will be applied to currently and future loaded classes.\n+     * <p>\n+     * If a method is overloaded, the filter matches against all methods. It's not possible\n+     * to match specific method parameters or annotation values.\n+     * <p>\n+     * Only one type of a filter - class, method, or annotation - can be used per array index.\n+     * <p>\n+     * If the filter is matched, JVMUpcalls::onMethodTrace will be invoked with\n+     * the bytecode. If a filter is replaced, and method no longer requires instrumentation,\n+     * the method will also be called with modification = 0;\n+     *\n+     * @param classes, not {@code null}, array of class names\n+     * @param methods, not {@code null}, array of method names\n+     * @param annotations, not {@code null}, array of annotation names\n+     * @param modifications, not {@code null}, array of modification flags\n+     * @return the published IDs, or null if no classes has been published.\n+     *\/\n+    public static native long[] setMethodTraceFilters(\n+        String[] classes,\n+        String[] methods,\n+        String[] annotations,\n+        int[] modification);\n+\n+    \/**\n+     * Returns IDs for method-traced classes that have been unloaded.\n+     *\n+     * @return the unloaded IDs, or null if no unloading has occurred.\n+     *\/\n+    public static native long[] drainStaleMethodTracerIds();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":66,"deletions":1,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\n@@ -32,0 +31,2 @@\n+import jdk.jfr.internal.tracing.PlatformTracer;\n+\n@@ -160,0 +161,31 @@\n+\n+    \/**\n+     * Called by the JVM to update method tracing instrumentation.\n+     * <p>\n+     * @param module the module the class belongs to\n+     * @param classLoader the class loader the class is being loaded for\n+     * @param className the internal class name, i.e. java\/lang\/String.\n+     * @param bytecode the bytecode to modify\n+     * @param methodIds the method IDs\n+     * @param names constant pool indices of method names\n+     * @param signatures constant pool indices of method signatures\n+     * @param modifications integer mask describing the modification\n+     *\n+     * @return the instrumented bytecode, or null if the class can't or shouldn't be modified.\n+     *\/\n+    public static byte[] onMethodTrace(Module module, ClassLoader classLoader, String className,\n+                                       byte[] bytecode, long[] methodIds, String[] names, String[] signatures,\n+                                       int[] modifications) {\n+        return PlatformTracer.onMethodTrace(module, classLoader, className,\n+                                            bytecode, methodIds, names, signatures,\n+                                            modifications);\n+    }\n+\n+    \/**\n+     * Called by the JVM to publish a class ID that can safely be used by the Method Timing event.\n+     * <p>\n+     * @param classId the methods to be published\n+     *\/\n+    public static void publishMethodTimersForClass(long classId) {\n+        PlatformTracer.publishClass(classId);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,5 @@\n-    JFR_START(15);\n+    JFR_START(15),\n+    \/**\n+     *  Covers usage of MethodTiming and MethodTrace events\n+     *\/\n+    JFR_METHODTRACE(16);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/LogTag.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -222,1 +222,0 @@\n-                    pEventType.setAnnotations(nativeType.getAnnotationElements());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import jdk.jfr.internal.tracing.Modification;\n+\n@@ -75,1 +77,1 @@\n-        this.isMethodSampling = isJVM && (name.equals(Type.EVENT_NAME_PREFIX + \"ExecutionSample\") || name.equals(Type.EVENT_NAME_PREFIX + \"NativeMethodSample\"));\n+        this.isMethodSampling = determineMethodSampling();\n@@ -77,1 +79,1 @@\n-        this.stackTraceOffset = stackTraceOffset(name, isJDK);\n+        this.stackTraceOffset = determineStackTraceOffset();\n@@ -80,2 +82,2 @@\n-    private static boolean isExceptionEvent(String name) {\n-        switch (name) {\n+    private boolean isExceptionEvent() {\n+        switch (getName()) {\n@@ -89,2 +91,2 @@\n-    private static boolean isUsingConfiguration(String name) {\n-        switch (name) {\n+    private boolean isStaticCommit() {\n+        switch (getName()) {\n@@ -101,1 +103,1 @@\n-    private static int stackTraceOffset(String name, boolean isJDK) {\n+    private int determineStackTraceOffset() {\n@@ -103,1 +105,2 @@\n-            if (isExceptionEvent(name)) {\n+            \/\/ Order matters\n+            if (isExceptionEvent()) {\n@@ -106,1 +109,4 @@\n-            if (isUsingConfiguration(name)) {\n+            if (getModification() == Modification.TRACING) {\n+                return 5;\n+            }\n+            if (isStaticCommit()) {\n@@ -113,0 +119,22 @@\n+    private boolean determineMethodSampling() {\n+        if (!isJVM) {\n+            return false;\n+        }\n+        switch (getName()) {\n+            case Type.EVENT_NAME_PREFIX + \"ExecutionSample\":\n+            case Type.EVENT_NAME_PREFIX + \"NativeMethodSample\":\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    public Modification getModification() {\n+        switch (getName()) {\n+            case Type.EVENT_NAME_PREFIX + \"MethodTrace\":\n+                return Modification.TRACING;\n+            case Type.EVENT_NAME_PREFIX + \"MethodTiming\":\n+                return Modification.TIMING;\n+        }\n+        return Modification.NONE;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static jdk.jfr.internal.LogLevel.ERROR;\n@@ -62,1 +61,1 @@\n-\n+    private static volatile boolean inShutdown;\n@@ -70,1 +69,0 @@\n-    private boolean inShutdown;\n@@ -153,2 +151,2 @@\n-    synchronized void setInShutDown() {\n-        this.inShutdown = true;\n+    static void setInShutDown() {\n+        inShutdown = true;\n@@ -157,2 +155,2 @@\n-    synchronized boolean isInShutDown() {\n-        return this.inShutdown;\n+    static boolean isInShutDown() {\n+        return inShutdown;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-                boolean reportOnExit = recorder.isInShutDown() && !reports.isEmpty();\n+                boolean reportOnExit = PlatformRecorder.isInShutDown() && !reports.isEmpty();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+    private static final String TRACING_PACKAGE_NAME = \"jdk.jfr.tracing\";\n@@ -65,0 +66,4 @@\n+    public static void addTracingExport() {\n+        Modules.addExports(JFR_MODULE, TRACING_PACKAGE_NAME);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        recorder.setInShutDown();\n+        PlatformRecorder.setInShutDown();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ShutdownHook.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,2 @@\n+    public int precision = -1;\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Field.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-            return ValueFormatter.formatDuration(d);\n+            return ValueFormatter.formatDuration(d, field.precision);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FieldFormatter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.function.BiConsumer;\n@@ -283,0 +284,5 @@\n+                \/\/ This option is experimental and may not work properly\n+                \/\/ with rounding and truncation.\n+                if (text.startsWith(\"ms-precision:\")) {\n+                    yield millisPrecision(text.substring(\"ms-precision:\".length()));\n+                }\n@@ -309,0 +315,12 @@\n+    private Consumer<Field> millisPrecision(String digits) throws ParseException {\n+        try {\n+            int d = Integer.parseInt(digits);\n+            if (d < 0) {\n+                throw new ParseException(\"Expected 'precision:' to be at least 0' \", position());\n+            }\n+            return field -> field.precision = d;\n+        } catch (NumberFormatException nfe) {\n+            throw new ParseException(\"Not valid number for 'precision:' \" + digits, position());\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryParser.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-; Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+; Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -449,0 +449,13 @@\n+[application.method-timing]\n+label = \"Method Timing\"\n+table = \"COLUMN 'Timed Method', 'Invocations', 'Average Time'\n+         FORMAT none, none, ms-precision:6\n+         SELECT LAST_BATCH(method) AS M, LAST_BATCH(invocations), LAST_BATCH(average)\n+         FROM jdk.MethodTiming GROUP BY method ORDER BY average\"\n+\n+[application.method-calls]\n+label = \"Method Calls\"\n+table = \"COLUMN 'Traced Method', 'Caller', 'Invocations'\n+         SELECT method as M, stackTrace.topFrame.method AS S, COUNT(*) AS C\n+         FROM jdk.MethodTrace GROUP BY M, S ORDER BY C DESC\"\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.settings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.TreeSet;\n+\n+import jdk.jfr.SettingControl;\n+import jdk.jfr.internal.PlatformEventType;\n+\n+\/**\n+ * Base class for settings that consists of semicolon-separated filters.\n+ *\/\n+public abstract class FilterSetting extends SettingControl {\n+    private final List<String> activeFilters = new ArrayList<>();\n+    private final PlatformEventType eventType;\n+    private final String defaultValue;\n+    private String value;\n+\n+    public FilterSetting(PlatformEventType eventType, String defaultValue) {\n+        this.eventType = Objects.requireNonNull(eventType);\n+        this.defaultValue = defaultValue;\n+    }\n+\n+    protected abstract void apply(PlatformEventType eventType, List<String> text);\n+\n+    protected abstract boolean isValid(String text);\n+\n+    @Override\n+    public final String combine(Set<String> settingValues) {\n+        List<String> filters = normalize(settingValues);\n+        if (!filters.isEmpty()) {\n+            return format(filters);\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Override\n+    public final void setValue(String settingValue) {\n+        List<String> filters = normalize(Set.of(settingValue));\n+        if (activeFilters.equals(filters)) {\n+            return;\n+        }\n+        apply(eventType, filters);\n+        this.value = settingValue;\n+        this.activeFilters.clear();\n+        this.activeFilters.addAll(filters);\n+    }\n+\n+    @Override\n+    public final String getValue() {\n+        return value;\n+    }\n+\n+    \/\/ Split, trim, sort and remove duplicates filters.\n+    private List<String> normalize(Set<String> settingValues) {\n+        Set<String> filters = new TreeSet<>();\n+        for (String value : settingValues) {\n+            for (String filter : value.split(\";\")) {\n+                filter = filter.strip();\n+                if (!filter.isEmpty() && !filter.isBlank() && isValid(filter)) {\n+                    filters.add(filter);\n+                }\n+            }\n+        }\n+        return new ArrayList<>(filters);\n+    }\n+\n+    private static String format(List<String> filters) {\n+        StringJoiner sj = new StringJoiner(\";\");\n+        filters.forEach(sj::add);\n+        return sj.toString();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/FilterSetting.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.settings;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.MetadataDefinition;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.PlatformEventType;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.tracing.Modification;\n+import jdk.jfr.internal.tracing.PlatformTracer;\n+\n+@MetadataDefinition\n+@Label(\"Filter\")\n+@Description(\"Methods to be filtered\")\n+@Name(Type.SETTINGS_PREFIX + \"Filter\")\n+public final class MethodSetting extends FilterSetting {\n+    private final Modification modification;\n+    private static volatile boolean initialized;\n+\n+    public MethodSetting(PlatformEventType eventType, Modification modification, String defaultValue) {\n+        super(eventType, defaultValue);\n+        this.modification = modification;\n+    }\n+\n+    public boolean isValid(String text) {\n+        return PlatformTracer.isValidFilter(text);\n+    }\n+\n+    @Override\n+    protected void apply(PlatformEventType eventType, List<String> filters) {\n+        if (!initialized) {\n+            PlatformTracer.initialize();\n+            initialized = true;\n+        }\n+        PlatformTracer.setFilters(modification, filters);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/MethodSetting.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+\/\/ \/\/ The JVM will skip all classes in the jdk.jfr module, so it's not added here.\n+public final class ExcludeList {\n+    private static final String[] EXCLUDED_CLASSES = {\n+        \/\/ Used by MethodTiming event to accumulate invocations.\n+        \"java\/util\/concurrent\/atomic\/AtomicLong\",\n+        \/\/ Used by EventWriter\n+        \"sun\/misc\/Unsafe\",\n+        \"jdk\/internal\/misc\/Unsafe;\",\n+    };\n+\n+    private static final String[] EXCLUDED_PREFIX = {\n+        \/\/ Used by MethodTiming event to store invocations, including inner classes.\n+        \"java\/util\/concurrent\/ConcurrentHashMap\",\n+        \/\/ Can't trigger <clinit> of these classes during PlatformTracer::onMethodTrace(...)\n+        \"jdk\/internal\/\", \/\/ jdk\/internal\/classfile, jdk\/internal\/loader and jdk\/internal\/foreign\n+        \"java\/lang\/classfile\/\"\n+    };\n+\n+    private static final String[] EXCLUDED_METHODS = {\n+        \/\/ Long used by MethodTiming event when looking up entry for timing entry\n+        \"java.lang.Long::<init>\",\n+        \"java.lang.Long::valueOf\",\n+        \"java.lang.Number::<init>\"\n+    };\n+\n+    public static boolean containsMethod(String methodName) {\n+        for (String method : EXCLUDED_METHODS) {\n+            if (method.equals(methodName)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static boolean containsClass(String className) {\n+        for (String clazz: EXCLUDED_CLASSES) {\n+            if (clazz.equals(className)) {\n+                return true;\n+            }\n+        }\n+        for (String prefix : EXCLUDED_PREFIX) {\n+            if (className.startsWith(prefix)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/ExcludeList.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import jdk.internal.module.Checks;\n+\n+\/**\n+ * Class that represents the filter a user can specify for the MethodTrace and\n+ * MethodTiming event.\n+ *\/\n+record Filter(String className, String methodName, String annotationName, Modification modification) {\n+\n+    static Filter of(String filter, Modification modification) {\n+        if (filter.startsWith(\"@\")) {\n+            return ofAnnotation(filter, modification);\n+        }\n+        if (filter.contains(\"::\")) {\n+            return ofMethod(filter, modification);\n+        }\n+        return ofClass(filter, modification);\n+    }\n+\n+    private static Filter ofAnnotation(String filter, Modification modification) {\n+        String annotation = filter.substring(1);\n+        if (Checks.isClassName(annotation)) {\n+            return new Filter(null, null, annotation, modification);\n+        }\n+        return null;\n+    }\n+\n+    private static Filter ofMethod(String filter, Modification modification) {\n+        int index = filter.indexOf(\"::\");\n+        String classPart = filter.substring(0, index);\n+        String methodPart = filter.substring(index + 2);\n+        if (methodPart.isEmpty()) {\n+            \/\/ Don't allow \"foo.Bar::\". User should specify \"foo.Bar\".\n+            return null;\n+        }\n+\n+        if (isMethod(methodPart)) {\n+            \/\/ Method name only, i.e. \"::baz\"\n+            if (classPart.isEmpty()) {\n+                return new Filter(null, methodPart, null, modification);\n+            }\n+            \/\/ Fully qualified method name, i.e. \"foo.Bar::baz\"\n+            if (isValidClassName(classPart)) {\n+                return new Filter(classPart, methodPart, null, modification);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static boolean isMethod(String methodName) {\n+        if (methodName.equals(\"<clinit>\") || methodName.equals(\"<init>\")) {\n+            return true;\n+        }\n+        return Checks.isJavaIdentifier(methodName);\n+    }\n+\n+    private static Filter ofClass(String filter, Modification modification) {\n+        if (isValidClassName(filter)) {\n+            return new Filter(filter, null, null, modification);\n+        }\n+        return null;\n+    }\n+\n+    private static boolean isValidClassName(String text) {\n+        return Checks.isClassName(text);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Filter.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFile.ClassHierarchyResolverOption;\n+import java.lang.classfile.ClassFile.Option;\n+import java.lang.classfile.ClassHierarchyResolver;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+\n+\/**\n+ * Class that adds bytecode instrumentation for a class.\n+ *\/\n+final class Instrumentation {\n+    private final Map<String, Method> modificationMap = new LinkedHashMap<>();\n+    private final String className;\n+    private final Module module;\n+    private final ClassLoader classLoader;\n+    private final byte[] bytecode;\n+\n+    public Instrumentation(Module module, ClassLoader classLoader, String internalClassName, byte[] bytecode) {\n+        this.className = internalClassName.replace(\"\/\", \".\");\n+        this.module = module;\n+        this.classLoader = classLoader;\n+        this.bytecode = bytecode;\n+    }\n+\n+    public void addMethod(long methodId, String name, String signature, int modification) {\n+        modificationMap.put(name + signature, new Method(methodId, Modification.valueOf(modification), className + \"::\" + name));\n+    }\n+\n+    public List<Method> getMethods() {\n+        return new ArrayList<>(modificationMap.values());\n+    }\n+\n+    public byte[] generateBytecode() {\n+        boolean[] modified = new boolean[1];\n+        ClassFile classFile = ClassFile.of(resolverOption(module));\n+        ClassModel classModel = classFile.parse(bytecode);\n+        byte[] generated = classFile.build(classModel.thisClass().asSymbol(), classBuilder -> {\n+            for (var ce : classModel) {\n+                if (modifyClassElement(classBuilder, ce)) {\n+                    modified[0] = true;\n+                } else {\n+                    classBuilder.with(ce);\n+                }\n+            }\n+        });\n+        return modified[0] ? generated : null;\n+    }\n+\n+    private Option resolverOption(Module module) {\n+        return ClassHierarchyResolverOption.of(resolver(module));\n+    }\n+\n+    private ClassHierarchyResolver resolver(Module module) {\n+        if (module.getClassLoader() == null) {\n+            return ClassHierarchyResolver.ofResourceParsing(ClassLoader.getSystemClassLoader());\n+        } else {\n+            return ClassHierarchyResolver.ofResourceParsing(module.getClassLoader());\n+        }\n+    }\n+\n+    private boolean modifyClassElement(ClassBuilder classBuilder, ClassElement ce) {\n+        if (ce instanceof MethodModel mm) {\n+            String method = mm.methodName().stringValue();\n+            String signature = mm.methodType().stringValue();\n+            String full = method + signature;\n+            Method tm = modificationMap.get(full);\n+            if (tm != null) {\n+                Modification m = tm.modification();\n+                if (m.tracing() || m.timing()) {\n+                    return modifyMethod(classBuilder, mm, tm);\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean modifyMethod(ClassBuilder classBuilder, MethodModel m, Method method) {\n+        var code = m.code();\n+        if (code.isPresent()) {\n+            if (classLoader == null && ExcludeList.containsMethod(method.name())) {\n+                String msg = \"Risk of recursion, skipping bytecode generation of \" + method.name();\n+                Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, msg);\n+                return false;\n+            }\n+            MethodTransform s = MethodTransform.ofStateful(\n+                () -> MethodTransform.transformingCode(new Transform(method))\n+            );\n+            classBuilder.transformMethod(m, s);\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Instrumentation.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+\n+\/**\n+ * Class that holds information about an instrumented method.\n+ *\/\n+record Method(long methodId, Modification modification, String name) {\n+    @Override\n+    public String toString() {\n+        return name + \" ID:\" + String.format(\"0x%08X\", methodId) + \" timing:\" + modification.timing() + \" tracing:\" + modification.tracing();\n+    }\n+\n+    public long classId() {\n+        return methodId() >> 16;\n+    }\n+\n+    public void log(String msg) {\n+        if (Logger.shouldLog(LogTag.JFR_METHODTRACE, LogLevel.INFO)) {\n+            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.INFO, msg + \" for \" + this);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Method.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+\/**\n+ * Class that holds the type of instrumentation that can be applied to a method.\n+ *\/\n+public record Modification(boolean timing, boolean tracing) {\n+    public static final Modification TIMING = new Modification(true, false);\n+    public static final Modification TRACING = new Modification(false, true);\n+    public static final Modification NONE = new Modification(false, false);\n+\n+    static Modification valueOf(int traceType) {\n+        return new Modification((traceType & 1) != 0, (traceType & 2) != 0);\n+    }\n+\n+    int toInt() {\n+        return (timing ? 1 : 0) + (tracing ? 2 : 0);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Modification.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import jdk.jfr.events.MethodTimingEvent;\n+import jdk.jfr.internal.JVM;\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+import jdk.jfr.internal.MetadataRepository;\n+import jdk.jfr.internal.SecuritySupport;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.util.Bytecode;\n+import jdk.jfr.tracing.MethodTracer;\n+\n+\/**\n+ * Class that contains the Method Tracer implementation.\n+ * <p>\n+ * By placing the implementation in jdk.jfr.internal.tracing package instead of\n+ * the jdk.jfr.tracing package fewer internals are exposed to the application.\n+ *\/\n+public final class PlatformTracer {\n+    private static final ConcurrentHashMap<Long, TimedMethod> timedMethods = new ConcurrentHashMap<>();\n+    private static final ConcurrentHashMap<Long, TimedClass> timedClasses = new ConcurrentHashMap<>();\n+\n+    private static List<Filter> traceFilters = List.of();\n+    private static List<Filter> timingFilters = List.of();\n+    private static TimedMethod OBJECT;\n+\n+    public static byte[] onMethodTrace(Module module, ClassLoader classLoader, String className,\n+                                       byte[] oldBytecode, long[] ids, String[] names, String[] signatures,\n+                                       int[] modifications) {\n+        if (classLoader == null && ExcludeList.containsClass(className)) {\n+            log(LogLevel.DEBUG, \"Risk of recursion, skipping bytecode generation\", module, className);\n+            return null;\n+        }\n+        try {\n+            Instrumentation instrumentation = new Instrumentation(module, classLoader, className, oldBytecode);\n+            for (int i = 0; i < ids.length; i++) {\n+                instrumentation.addMethod(ids[i], names[i], signatures[i], modifications[i]);\n+            }\n+            byte[] bytecode = instrumentation.generateBytecode();\n+            for (Method method : instrumentation.getMethods()) {\n+                updateTiming(method);\n+            }\n+            return bytecode; \/\/ Returns null if bytecode was not modified.\n+        } catch (ClassCircularityError cce) {\n+            log(LogLevel.WARN, \"Class circularity error, skipping instrumentation\", module, className);\n+            return null;\n+        } catch (Throwable t) {\n+            log(LogLevel.WARN, \"Unexpected error \" + t.getMessage() + \". Skipping instrumentation\", module, className);\n+            return null;\n+        }\n+    }\n+\n+    private static void updateTiming(Method method) {\n+        boolean isTiming = method.modification().timing();\n+        Long classId = method.classId();\n+\n+        if (!timedMethods.containsKey(method.methodId())) {\n+            if (isTiming) {\n+                \/\/ Timing started\n+                TimedClass timedClass = timedClasses.computeIfAbsent(classId, id -> new TimedClass());\n+                TimedMethod entry = timedClass.add(method);\n+                timedMethods.put(method.methodId(), entry);\n+                if (\"java.lang.Object::<init>\".equals(method.name())) {\n+                    OBJECT = entry;\n+                }\n+                method.log(\"Timing entry added\");\n+            }\n+            return;\n+        }\n+        if (!isTiming) {\n+            TimedClass timedClass = timedClasses.get(classId);\n+            if (timedClass != null) {\n+                timedClass.remove(method);\n+            }\n+            timedMethods.remove(method.methodId());\n+            method.log(\"Timing entry removed\");\n+        }\n+    }\n+\n+    private static void log(LogLevel level, String message, Module module, String className) {\n+        if (!Logger.shouldLog(LogTag.JFR_METHODTRACE, level)) {\n+            return;\n+        }\n+        StringBuilder s = new StringBuilder();\n+        s.append(message);\n+        s.append(\" for \");\n+        s.append(className.replace(\"\/\", \".\"));\n+        s.append(\" in module \");\n+        s.append(module.getName());\n+        s.append(\" and class loader \" + module.getClassLoader());\n+        Logger.log(LogTag.JFR_METHODTRACE, level, s.toString());\n+    }\n+\n+    public static void emitTiming() {\n+        \/\/ Metadata lock prevents rotation while emitting events.\n+        synchronized (MetadataRepository.getInstance()) {\n+            removeClasses(JVM.drainStaleMethodTracerIds());\n+            long timestamp = MethodTimingEvent.timestamp();\n+            for (var tc : timedClasses.values()) {\n+                tc.emit(timestamp);\n+            }\n+        }\n+    }\n+\n+    public static void addObjectTiming(long duration) {\n+        OBJECT.invocations().getAndIncrement();\n+        OBJECT.time().addAndGet(duration);\n+    }\n+\n+    public static void addTiming(long id, long duration) {\n+        TimedMethod entry = timedMethods.get(id);\n+        if (entry != null) {\n+            entry.invocations().getAndIncrement();\n+            entry.time().addAndGet(duration);\n+        }\n+    }\n+\n+    public static boolean isValidFilter(String text) {\n+        return Filter.of(text, null) != null;\n+    }\n+\n+    public static void setFilters(Modification modification, List<String> filters) {\n+        publishClasses(applyFilter(modification, filters));\n+    }\n+\n+    private static long[] applyFilter(Modification modification, List<String> filters) {\n+        boolean hadFilters = hasFilters();\n+        if (modification.tracing()) {\n+            traceFilters = makeFilters(filters, modification);\n+        }\n+        if (modification.timing()) {\n+            timingFilters = makeFilters(filters, modification);\n+        }\n+        if (hadFilters || hasFilters()) {\n+            int size = filterCount();\n+            List<Filter> allFilters = new ArrayList<>(size);\n+            allFilters.addAll(traceFilters);\n+            allFilters.addAll(timingFilters);\n+            String[] classes = new String[size];\n+            String[] methods = new String[size];\n+            String[] annotations = new String[size];\n+            int[] modifications = new int[size];\n+            for (int index = 0; index < size; index++) {\n+                Filter filter = allFilters.get(index);\n+                classes[index] = Bytecode.internalName(filter.className());\n+                methods[index] = filter.methodName();\n+                annotations[index] = Bytecode.descriptorName(filter.annotationName());\n+                modifications[index] = filter.modification().toInt();\n+            }\n+            return JVM.setMethodTraceFilters(classes, methods, annotations, modifications);\n+        }\n+        return null;\n+    }\n+\n+    private static void removeClasses(long[] classIds) {\n+        if (classIds == null) {\n+            return;\n+        }\n+        for (int i = 0; i < classIds.length; i++) {\n+            TimedClass timedClass = timedClasses.remove(classIds[i]);\n+            if (timedClass != null) {\n+                for (TimedMethod tm : timedClass.methods()) {\n+                    timedMethods.remove(tm.method().methodId());\n+                    tm.method().log(\"Timing entry unloaded\");\n+                }\n+                if (Logger.shouldLog(LogTag.JFR_METHODTRACE, LogLevel.INFO)) {\n+                    Logger.log(LogTag.JFR_METHODTRACE, LogLevel.INFO, \"Timing entry unloaded for class \" + classIds[i]);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void publishClasses(long[] classIds) {\n+        if (classIds == null) {\n+            return;\n+        }\n+        for (int i = 0; i < classIds.length; i++) {\n+            publishClass(classIds[i]);\n+        }\n+    }\n+\n+    public static void publishClass(long classId) {\n+        TimedClass timedClass = timedClasses.get(classId);\n+        \/\/ The class may be null if a class is drained\/unloaded before\n+        \/\/ it is being published by setFilter().\n+        if (timedClass != null) {\n+            timedClass.publish();\n+        }\n+    }\n+\n+    private static boolean hasFilters() {\n+        return filterCount() > 0;\n+    }\n+\n+    private static int filterCount() {\n+        return traceFilters.size() + timingFilters.size();\n+    }\n+\n+    private static List<Filter> makeFilters(List<String> filterTexts, Modification modification) {\n+        List<Filter> filters = new ArrayList<>(filterTexts.size());\n+        for (String filterText : filterTexts) {\n+            Filter filter = Filter.of(filterText, modification);\n+            if (filter != null) {\n+                filters.add(filter);\n+            }\n+        }\n+        return filters;\n+    }\n+\n+    private synchronized static void reset() {\n+        timedMethods.clear();\n+        timedClasses.clear();\n+    }\n+\n+    \/\/ This method has three purposes:\n+    \/\/\n+    \/\/ 1) Load classes before instrumentation to avoid recursion in class\n+    \/\/ initializers when onMethodTrace(...) is called by the JVM.\n+    \/\/\n+    \/\/ 2) Warm up methods used by the PlatformTracer class to reduce the observer\n+    \/\/ effect later.\n+    \/\/\n+    \/\/ 3) Export the jdk.jfr.tracing package to all other modules.\n+    \/\/\n+    \/\/ This method takes 1-10 milliseconds to run and is only executed once,\n+    \/\/ provided a user has specified a non-empty filter for the MethodTrace or\n+    \/\/ MethodTiming event.\n+    public static void initialize() {\n+        try {\n+            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.INFO, \"Method tracer initialization started.\");\n+            Thread current = Thread.currentThread();\n+            JVM.exclude(current);\n+            long classId = Type.getKnownType(String.class).getId();\n+            long methodId = classId << 16 + 983059;\n+            ClassLoader cl = null;\n+            String className = \" java\/lang\/String\";\n+            Module m = String.class.getModule();\n+            var is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"java\/lang\/String.class\");\n+            byte[] oldBytecode = is.readAllBytes();\n+            is.close();\n+            long[] ids = { methodId };\n+            String[] names = { \"<clinit>\" };\n+            String[] signatures = { \"()V\" };\n+            int[] modifications = { 3 };\n+            byte[] bytes = onMethodTrace(m, cl, className, oldBytecode, ids, names, signatures, modifications);\n+            if (bytes == null) {\n+                throw new Exception(\"Could not generate bytecode\");\n+            }\n+            publishClass(classId);\n+            for (int id = 0; id < 25_000; id++) {\n+                MethodTracer.timing(MethodTracer.timestamp(), methodId);\n+                MethodTracer.trace(MethodTracer.timestamp(), methodId);\n+                MethodTracer.traceTiming(MethodTracer.timestamp(), methodId);\n+            }\n+            reset();\n+            JVM.include(current);\n+            SecuritySupport.addTracingExport();\n+            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.INFO, \"Method tracer initialization complete.\");\n+        } catch (Exception e) {\n+            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.WARN, \"Method tracer initialization failed. \" + e.getMessage());\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/PlatformTracer.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Collection;\n+\n+import jdk.jfr.events.MethodTimingEvent;\n+\n+\/**\n+ * Holds timed method for a class. Used when publishing method ids.\n+ *\/\n+public final class TimedClass {\n+    private final ConcurrentHashMap<Long, TimedMethod> methods = new ConcurrentHashMap<>();\n+\n+    public TimedMethod add(Method method) {\n+        return methods.computeIfAbsent(method.methodId(), id -> new TimedMethod(method));\n+    }\n+\n+    public void remove(Method method) {\n+        methods.remove(method.methodId());\n+    }\n+\n+    public void publish() {\n+        for (TimedMethod t : methods.values()) {\n+            t.published().set(true);\n+            t.method().log(\"Timing entry published\");\n+        }\n+    }\n+\n+    Collection<TimedMethod> methods() {\n+        return methods.values();\n+    }\n+\n+    public void emit(long timestamp) {\n+        for (var tm : methods.values()) {\n+            if (tm.published().get()) {\n+                long methodId = tm.method().methodId();\n+                long invocations = tm.invocations().get();\n+                long time = tm.time().get();\n+                long average = invocations == 0 ? Long.MIN_VALUE : time \/ invocations;\n+                MethodTimingEvent.commit(timestamp, methodId, invocations, average);\n+                tm.method().log(\"Emitted event\");\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/TimedClass.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\/**\n+ * Record class that holds invocation measurements used by the MethodTiming\n+ * event.\n+ * <p>\n+ * Fields in record classes are truly final so might help to have a record here.\n+ *\/\n+record TimedMethod(AtomicLong invocations, AtomicLong time, Method method, AtomicBoolean published) {\n+    TimedMethod(Method method) {\n+        this(new AtomicLong(), new AtomicLong(), method, new AtomicBoolean());\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/TimedMethod.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.instruction.ReturnInstruction;\n+import java.lang.classfile.instruction.ThrowInstruction;\n+import java.lang.constant.ClassDesc;\n+\n+import jdk.jfr.internal.util.Bytecode;\n+import jdk.jfr.internal.util.Bytecode.MethodDesc;\n+import jdk.jfr.tracing.MethodTracer;\n+\n+\/**\n+ * Class that transforms the bytecode of a method so it can call the appropriate\n+ * methods in the jdk.jfr.tracing.MethodTracer class.\n+ * <p>\n+ * The method ID is determined by native code.\n+ *\/\n+final class Transform implements CodeTransform {\n+    private static final ClassDesc METHOD_TRACER_CLASS = ClassDesc.of(MethodTracer.class.getName());\n+    private static final MethodDesc TRACE_METHOD = MethodDesc.of(\"trace\", \"(JJ)V\");\n+    private static final MethodDesc TIMING_METHOD = MethodDesc.of(\"timing\", \"(JJ)V\");\n+    private static final MethodDesc TRACE_TIMING_METHOD = MethodDesc.of(\"traceTiming\", \"(JJ)V\");\n+    private static final MethodDesc TIMESTAMP_METHOD = MethodDesc.of(\"timestamp\", \"()J\");\n+\n+    private final Method method;\n+    private int timestampSlot = -1;\n+\n+    Transform(Method method) {\n+        this.method = method;\n+    }\n+\n+    @Override\n+    public final void accept(CodeBuilder builder, CodeElement element) {\n+        if (timestampSlot == -1) {\n+            timestampSlot = invokeTimestamp(builder);\n+            builder.lstore(timestampSlot);\n+        }\n+        if (element instanceof ReturnInstruction || element instanceof ThrowInstruction) {\n+            builder.lload(timestampSlot);\n+            builder.ldc(method.methodId());\n+            Modification modification = method.modification();\n+            boolean objectInit = method.name().equals(\"java.lang.Object::<init>\");\n+            String suffix = objectInit ? \"ObjectInit\" : \"\";\n+            if (modification.timing()) {\n+                if (modification.tracing()) {\n+                    invokeTraceTiming(builder, suffix);\n+                } else {\n+                    invokeTiming(builder, suffix);\n+                }\n+            } else {\n+                if (modification.tracing()) {\n+                    invokeTrace(builder, suffix);\n+                }\n+            }\n+        }\n+        builder.with(element);\n+    }\n+\n+    public static void invokeTiming(CodeBuilder builder, String suffix) {\n+        builder.invokestatic(METHOD_TRACER_CLASS, TIMING_METHOD.name() + suffix, TIMING_METHOD.descriptor());\n+    }\n+\n+    public static void invokeTrace(CodeBuilder builder, String suffix) {\n+        builder.invokestatic(METHOD_TRACER_CLASS, TRACE_METHOD.name() + suffix, TRACE_METHOD.descriptor());\n+    }\n+\n+    public static void invokeTraceTiming(CodeBuilder builder, String suffix) {\n+        builder.invokestatic(METHOD_TRACER_CLASS, TRACE_TIMING_METHOD.name() + suffix, TRACE_TIMING_METHOD.descriptor());\n+    }\n+\n+    public static int invokeTimestamp(CodeBuilder builder) {\n+        Bytecode.invokestatic(builder, METHOD_TRACER_CLASS, TIMESTAMP_METHOD);\n+        return builder.allocateLocal(TypeKind.LONG);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Transform.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,0 +97,8 @@\n+    public static String internalName(String className) {\n+        return className != null ? className.replace(\".\", \"\/\") : null;\n+    }\n+\n+    public static String descriptorName(String className) {\n+        return className != null ? (\"L\" + internalName(className) + \";\") : null;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Bytecode.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -462,0 +462,6 @@\n+\n+    public static boolean isAssertionEnabled() {\n+        boolean enabled = false;\n+        assert enabled = true;\n+        return enabled;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,0 +113,4 @@\n+        return formatDuration(d, -1);\n+    }\n+\n+    public static String formatDuration(Duration d, int precision) {\n@@ -117,1 +121,1 @@\n-            return \"-\" + formatPositiveDuration(roundedDuration.abs());\n+            return \"-\" + formatPositiveDuration(roundedDuration.abs(), precision);\n@@ -119,1 +123,1 @@\n-            return formatPositiveDuration(roundedDuration);\n+            return formatPositiveDuration(roundedDuration, precision);\n@@ -123,1 +127,1 @@\n-    private static String formatPositiveDuration(Duration d){\n+    public static String formatPositiveDuration(Duration d, int precision) {\n@@ -126,0 +130,3 @@\n+            if (precision == -1) {\n+                precision = 6;\n+            }\n@@ -127,1 +134,1 @@\n-            return String.format(\"%.6f ms\", outputMs);\n+            return String.format(\"%.\" + precision + \"f ms\", outputMs);\n@@ -130,2 +137,4 @@\n-            int valueLength = countLength(d.toNanosPart());\n-            int outputDigit = NANO_SIGNIFICANT_FIGURES - valueLength;\n+            if (precision == -1) {\n+                int valueLength = countLength(d.toNanosPart());\n+                precision = NANO_SIGNIFICANT_FIGURES - valueLength;\n+            }\n@@ -133,1 +142,1 @@\n-            return String.format(\"%.\" + outputDigit + \"f ms\", outputMs);\n+            return String.format(\"%.\" + precision + \"f ms\", outputMs);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueFormatter.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.tracing;\n+\n+import jdk.jfr.events.MethodTimingEvent;\n+import jdk.jfr.events.MethodTraceEvent;\n+import jdk.jfr.internal.JVM;\n+import jdk.jfr.internal.tracing.PlatformTracer;\n+\n+\/**\n+ * This class serves as the frontend for method tracing capabilities. The\n+ * jdk.jfr.tracing package is exported to all modules when the first method\n+ * tracing filter is applied.\n+ * <p>\n+ * A malicious user could craft bytecode that invoke these methods with an\n+ * invalid method ID, resulting in an event where the method field is\n+ * incorrect or {@code null}. This is considered acceptable.\n+ *\/\n+public final class MethodTracer {\n+\n+    private MethodTracer() {\n+    }\n+\n+    public static long timestamp() {\n+        return JVM.counterTime();\n+    }\n+\n+    public static void traceObjectInit(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTraceEvent.enabled() && JVM.getEventWriter() != null) {\n+            MethodTraceEvent.commit(startTime, duration, methodId);\n+        }\n+    }\n+\n+    public static void timingObjectInit(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTimingEvent.enabled()) {\n+            PlatformTracer.addObjectTiming(duration);\n+        }\n+    }\n+\n+    public static void traceTimingObjectInit(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTraceEvent.enabled() && JVM.getEventWriter() != null) {\n+            MethodTraceEvent.commit(startTime, duration, methodId);\n+        }\n+        if (MethodTimingEvent.enabled()) {\n+            PlatformTracer.addObjectTiming(duration);\n+        }\n+    }\n+\n+    public static void trace(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTraceEvent.enabled()) {\n+            MethodTraceEvent.commit(startTime, duration, methodId);\n+        }\n+    }\n+\n+    public static void timing(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTimingEvent.enabled()) {\n+            PlatformTracer.addTiming(methodId, duration);\n+        }\n+    }\n+\n+    public static void traceTiming(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTimingEvent.enabled()) {\n+            PlatformTracer.addTiming(methodId, duration);\n+        }\n+        if (MethodTraceEvent.enabled()) {\n+            MethodTraceEvent.commit(startTime, duration, methodId);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/tracing\/MethodTracer.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -209,0 +209,13 @@\n+    <event name=\"jdk.MethodTrace\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"filter\" control=\"method-trace\"><\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.MethodTiming\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"filter\" control=\"method-timing\"><\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n@@ -1159,0 +1172,4 @@\n+      <text name=\"method-timing\" label=\"Method Timing\" contentType=\"text\"><\/text>\n+\n+      <text name=\"method-trace\" label=\"Method Trace\" contentType=\"text\"><\/text>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -209,0 +209,13 @@\n+    <event name=\"jdk.MethodTrace\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"filter\" control=\"method-trace\"><\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.MethodTiming\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"filter\" control=\"method-timing\"><\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n@@ -1158,0 +1171,4 @@\n+      <text name=\"method-timing\" label=\"Method Timing\" contentType=\"text\"><\/text>\n+\n+      <text name=\"method-trace\" label=\"Method Trace\" contentType=\"text\"><\/text>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,2 @@\n-        new SettingTest(\"throttle\", \"off\", \"jdk.ObjectAllocationSample\", List.of(\"off\", \"100\/s\", \"10\/ms\"))\n+        new SettingTest(\"throttle\", \"off\", \"jdk.ObjectAllocationSample\", List.of(\"off\", \"100\/s\", \"10\/ms\")),\n+        new SettingTest(\"filter\", \"\", \"jdk.MethodTrace\", List.of(\"\", \"foo.bar::Baz\", \"com.example.Test;foo.bar::Baz\"))\n","filename":"test\/jdk\/jdk\/jfr\/api\/settings\/TestSettingControl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.TYPE;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ TYPE, METHOD })\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Apple {\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/Apple.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.TYPE;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ TYPE, METHOD })\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Banana {\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/Banana.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+public final class Car implements Runnable {\n+\n+    public void run() {\n+        System.out.println(\"Car is running. Class loader name \" + this.getClass().getClassLoader().getName());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/Car.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+public final class StaticInitializer {\n+    public static String TRIGGERED;\n+    static {\n+        System.out.println(\"Executing StaticInitializer::<clinit>\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/StaticInitializer.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that <clinit> can be instrumented.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.event.tracing.StaticInitializer\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestClinit\n+ **\/\n+public class TestClinit {\n+    private static final String PACKAGE_NAME = TestClinit.class.getPackageName();\n+    private static final String CLINIT_CLASS_NAME = PACKAGE_NAME + \".StaticInitializer\";\n+    private static final String CLINIT_METHOD_NAME = CLINIT_CLASS_NAME + \"::<clinit>\";\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"jdk.MethodTrace\")\n+             .with(\"filter\", CLINIT_CLASS_NAME);\n+            r.enable(\"jdk.MethodTiming\")\n+             .with(\"filter\", CLINIT_METHOD_NAME)\n+             .with(\"period\", \"endChunk\");\n+\n+            r.start();\n+            StaticInitializer.TRIGGERED = \"true\";\n+            r.stop();\n+\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.assertEventCount(events, 2);\n+\n+            RecordedEvent traceEvent = Events.getFirst(events, \"jdk.MethodTrace\");\n+            Events.assertTopFrame(traceEvent, TestClinit.class.getName(), \"main\");\n+            assertClinitMethod(traceEvent);\n+\n+            RecordedEvent timingEvent = Events.getFirst(events, \"jdk.MethodTiming\");\n+            assertClinitMethod(timingEvent);\n+        }\n+    }\n+\n+    private static void assertClinitMethod(RecordedEvent event) throws Exception {\n+        RecordedMethod method = event.getValue(\"method\");\n+        if (!method.getName().equals(\"<clinit>\")) {\n+            System.out.println(event);\n+            throw new Exception(\"Expected <clinit>, was \" + method.getName());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestClinit.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.event.tracing.Apple;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that the union of annotation-based, class-based and\n+ *          method-based filters can be used simultaneously.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.event.tracing.Apple\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestCombinedFilters\n+ **\/\n+public class TestCombinedFilters {\n+    private static final String APPLE_ANNOTATION = Apple.class.getName();\n+    private static final String TRACE_EVENT = \"jdk.MethodTrace\";\n+    private static final String TIMING_EVENT = \"jdk.MethodTiming\";\n+    private static final String FOO_CLASS = Foo.class.getName();\n+\n+    public static class Foo {\n+        @Apple\n+        static void bar() {\n+            System.out.println(\"Executing Foo:bar\");\n+        }\n+\n+        static void baz() {\n+            System.out.println(\"Executing Foo:baz\");\n+        }\n+\n+        static void qux() {\n+            System.out.println(\"Executing Foo:qux\");\n+        }\n+    }\n+\n+    record TestEvent(String event, String type, String method) {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        String traceFilter = \"@\" + APPLE_ANNOTATION + \";\" + FOO_CLASS + \"::bar\";\n+        String timingFilter = Foo.class.getName();\n+        try (Recording r = new Recording()) {\n+            r.enable(TRACE_EVENT).with(\"filter\", traceFilter);\n+            r.enable(TIMING_EVENT).with(\"filter\", timingFilter).with(\"period\", \"endChunk\");\n+            for (var entry : r.getSettings().entrySet()) {\n+                System.out.println(entry.getKey() + \"=\" + entry.getValue());\n+            }\n+            r.start();\n+            Foo.bar();\n+            Foo.baz();\n+            Foo.qux();\n+            r.stop();\n+            var list = List.of(new TestEvent(TRACE_EVENT, FOO_CLASS, \"bar\"),\n+                               new TestEvent(TIMING_EVENT, FOO_CLASS, \"<init>\"),\n+                               new TestEvent(TIMING_EVENT, FOO_CLASS, \"bar\"),\n+                               new TestEvent(TIMING_EVENT, FOO_CLASS, \"baz\"),\n+                               new TestEvent(TIMING_EVENT, FOO_CLASS, \"qux\"));\n+            List<TestEvent> expected = new ArrayList<>(list);\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+            }\n+            Events.hasEvents(events);\n+            for (RecordedEvent e : events) {\n+                RecordedMethod method = e.getValue(\"method\");\n+                String className = method.getType().getName();\n+                String eventTypeName = e.getEventType().getName();\n+                TestEvent testEvent = new TestEvent(eventTypeName, className, method.getName());\n+                if (!expected.remove(testEvent)) {\n+                    throw new Exception(\"Unexpected event \" + testEvent);\n+                }\n+            }\n+            if (!expected.isEmpty()) {\n+                throw new Exception(\"Missing events \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestCombinedFilters.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that class filters work as expected.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestFilterClass\n+ **\/\n+public class TestFilterClass {\n+    private static final String THIS_CLASS = TestFilterClass.class.getName();\n+    private static final String EVENT_NAME = \"jdk.MethodTrace\";\n+\n+    interface Interface {\n+        void foo();\n+\n+        void bar();\n+\n+        public static void baz() {\n+            System.out.println(\"Executing Interface::baz\");\n+        }\n+    }\n+\n+    static class Implementation implements Interface {\n+        public void foo() {\n+            System.out.println(\"Executing Implementation::foo\");\n+        }\n+\n+        @Override\n+        public void bar() {\n+            throw new Error(\"Should not happen\");\n+        }\n+    }\n+\n+    enum Enum {\n+        VALUE;\n+\n+        public void bar() {\n+            System.out.println(\"Executing Enum::bar\");\n+        }\n+    }\n+\n+    record Record(int value) {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME)\n+             .with(\"filter\", THIS_CLASS + \"$Implementation;\" +\n+                             THIS_CLASS + \"$Interface;\" +\n+                             THIS_CLASS + \"$Enum;\" +\n+                             THIS_CLASS + \"$Record\");\n+            r.start();\n+            Interface.baz();\n+            new Implementation().foo();\n+            Enum.VALUE.bar();\n+            new Record(4711).value();\n+            r.stop();\n+            var list = new ArrayList<>(List.of(THIS_CLASS + \"$Interface::baz\", THIS_CLASS + \"$Implementation::<init>\", THIS_CLASS + \"$Implementation::foo\", THIS_CLASS + \"$Enum::<clinit>\",\n+                    THIS_CLASS + \"$Enum::<init>\", THIS_CLASS + \"$Enum::bar\", THIS_CLASS + \"$Record::<init>\", THIS_CLASS + \"$Record::value\"));\n+            var events = Events.fromRecording(r);\n+            System.out.println(list);\n+            Events.hasEvents(events);\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+                RecordedMethod method = event.getValue(\"method\");\n+                String name = method.getType().getName() + \"::\" + method.getName();\n+                if (!list.remove(name)) {\n+                    throw new Exception(\"Unexpected method '\" + name + \"' in event\");\n+                }\n+            }\n+            if (!list.isEmpty()) {\n+                throw new Exception(\"Expected events for the methods \" + list);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestFilterClass.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+\n+import jdk.jfr.event.tracing.Apple;\n+import jdk.jfr.event.tracing.Banana;\n+\n+\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+import java.lang.annotation.Target;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+\n+\/**\n+ * @test\n+ * @summary Tests class-annotation-based filtering.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm\n+ *    -Xlog:jfr+methodtrace=trace\n+ *    jdk.jfr.event.tracing.TestFilterClassAnnotation\n+ *\/\n+\n+\/\/ @Banana and Apple tests multiple annotations and that the target is not the first annotation\n+@Banana\n+@Apple\n+public class TestFilterClassAnnotation {\n+    private static final String EVENT_NAME = \"jdk.MethodTrace\";\n+\n+    \/\/ Class Foo tests inner and interface classes\n+    @Apple\n+    interface Foo {\n+        \/\/ Method duck() tests that static methods in interfaces can be instrumented\n+        private static void duck() {\n+            System.out.println(\"Executing method: duck()\");\n+        }\n+\n+        \/\/ Method eggplant() tests that abstract method doesn't interfere in the\n+        \/\/ instrumentation\n+        void eggplant();\n+    }\n+\n+    \/\/ Method ant() tests that the same method annotation as the class doesn't\n+    \/\/ interfere\n+    @Apple\n+    private static void ant() {\n+        System.out.println(\"Executing method: ant()\");\n+    }\n+\n+    \/\/ Method bear() tests that other method annotation doesn't interfere\n+    @Banana\n+    private static void bear() {\n+        System.out.println(\"Executing method: bear()\");\n+    }\n+\n+    \/\/ Method cat() tests that a method in an annotated class is instrumented\n+    private static void cat() {\n+        System.out.println(\"Executing method: cat()\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME)\n+             .with(\"filter\", \"@\" + Apple.class.getName());\n+            r.start();\n+            ant();\n+            bear();\n+            cat();\n+            Foo.duck();\n+            r.stop();\n+\n+            var set = new HashSet<>(Set.of(\"ant\", \"bear\", \"cat\", \"duck\"));\n+            var events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            for (RecordedEvent e : events) {\n+                System.out.println(e);\n+                RecordedMethod method = e.getValue(\"method\");\n+                if (!set.remove(method.getName())) {\n+                    throw new Exception(\"Unexpected method '\" + method.getName() + \"' in event\");\n+                }\n+                RecordedFrame topFrame = e.getStackTrace().getFrames().get(0);\n+                String topMethod = topFrame.getMethod().getName();\n+                if (!topMethod.equals(\"main\")) {\n+                    throw new Exception(\"Expected method to be called from main\");\n+                }\n+            }\n+            if (!set.isEmpty()) {\n+                throw new Exception(\"Expected events for the methods \" + set);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestFilterClassAnnotation.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that a method filter (e.g., class::method) works as expected.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestFilterMethod\n+ *\/\n+public class TestFilterMethod {\n+    private static final String THIS_CLASS = TestFilterMethod.class.getName();\n+    private static final String EVENT_NAME = \"jdk.MethodTrace\";\n+\n+    \/\/ Tests implicit constructor\n+    static public class SomeClass {\n+        public void override() {\n+            throw new Error(\"Should not happen\");\n+        }\n+    }\n+\n+    \/\/ Tests explicit constructor\n+    static public class OtherClass extends SomeClass {\n+        public OtherClass() {\n+            System.out.println(\"Executing Otherclass::Otherclass()\");\n+        }\n+    }\n+\n+    \/\/ Tests method override\n+    static public class SomeSubclass extends SomeClass {\n+        public void override() {\n+            System.out.println(\"Executing SomeSubclass::override()\");\n+        }\n+    }\n+\n+    \/\/ Tests method in enum\n+    enum Enum {\n+        VALUE;\n+\n+        static void enumMethod() {\n+            System.out.println(\"Executing Enum:enumMethod\");\n+        }\n+    }\n+\n+    \/\/ Tests method in interface\n+    interface Interface {\n+        public static void staticMethod() {\n+            System.out.println(\"Executing Interface::staticMethod\");\n+        }\n+\n+        public void instanceMethod();\n+    }\n+\n+    static class Implementation implements Interface {\n+        @Override\n+        public void instanceMethod() {\n+        }\n+    }\n+\n+    \/\/ Tests normal method\n+    public static void overload() {\n+        System.out.println(\"Executing overload()\");\n+    }\n+\n+    \/\/ Tests overloaded method\n+    public static void overload(int value) {\n+        System.out.println(\"Executing overload(\" + value + \")\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME)\n+             .with(\"filter\", THIS_CLASS + \"$SomeSubclass::override;\" +\n+                             THIS_CLASS + \"$OtherClass::<init>;\" +\n+                             THIS_CLASS + \"::overload;\" +\n+                             THIS_CLASS + \"$Enum::enumMethod;\" +\n+                             THIS_CLASS + \"$Interface::staticMethod;\" +\n+                             THIS_CLASS + \"$Implementation::instanceMethod\");\n+            r.start();\n+            new SomeSubclass().override();\n+            new OtherClass();\n+            overload();\n+            overload(1);\n+            Enum.enumMethod();\n+            Interface.staticMethod();\n+            new Implementation().instanceMethod();\n+            r.stop();\n+\n+            var set = new ArrayList<>(List.of(\n+                \"<init>\", \/\/ OtherClass:<init>\n+                \"override\",\n+                \"overload\", \/\/ overload()\n+                \"overload\", \/\/ overload(int)\n+                \"enumMethod\",\n+                \"staticMethod\",\n+                \"instanceMethod\"));\n+            var events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+                RecordedMethod m = event.getValue(\"method\");\n+                if (!set.remove(m.getName())) {\n+                    throw new Exception(\"Unexpected method '\" + m.getName() + \"' in event\");\n+                }\n+                RecordedFrame topFrame = event.getStackTrace().getFrames().get(0);\n+                String topMethod = topFrame.getMethod().getName();\n+                if (!topMethod.equals(\"main\")) {\n+                    throw new Exception(\"Expected method to be called from main\");\n+                }\n+            }\n+            if (!set.isEmpty()) {\n+                throw new Exception(\"Expected events for the methods \" + set);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestFilterMethod.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.TYPE;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.event.tracing.Apple;\n+import jdk.jfr.event.tracing.Banana;\n+import jdk.jfr.event.tracing.TestFilterMethodAnnotation.Foo;\n+\n+\/**\n+ * @test\n+ * @summary Tests method-annotation-based filtering.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestFilterMethodAnnotation\n+ *\/\n+public class TestFilterMethodAnnotation {\n+\n+    static String EVENT_NAME = \"jdk.MethodTrace\";\n+\n+    \/\/ Tests that abstract method is ignored\n+    static abstract class Foo {\n+        @Apple\n+        abstract void baz();\n+    }\n+\n+    \/\/ Tests tracing of an inner class\n+    static class Bar extends Foo {\n+        @Override\n+        \/\/ Tests method override\n+        @Apple\n+        void baz() {\n+            System.out.println(\"Executing Bar::baz()\");\n+        }\n+\n+        @Apple\n+        void qux() {\n+            System.out.println(\"Executing Bar::qux()\");\n+        }\n+    }\n+\n+    \/\/ Tests tracing of method with multiple annotations and the target not being\n+    \/\/ first\n+    @Banana\n+    @Apple\n+    private static void ant() {\n+        System.out.println(\"Executing method: ant()\");\n+    }\n+\n+    \/\/ Tests that overloaded method with the same name is not traced\n+    private static void ant(int i) {\n+        System.out.println(\"Executing method: apple(\" + i + \")\");\n+    }\n+\n+    \/\/ Tests that non-annotated method is not traced\n+    private static void bear() {\n+        System.out.println(\"Executing method: bear()\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME)\n+             .with(\"filter\", \"@\" + Apple.class.getName());\n+            r.start();\n+            ant();\n+            ant(4711);\n+            bear();\n+            Bar bar = new Bar();\n+            bar.baz();\n+            bar.qux();\n+            r.stop();\n+            var set = new HashSet<>(Set.of(\"ant\", \"baz\", \"qux\"));\n+            var events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+                RecordedMethod method = event.getValue(\"method\");\n+                String methodName = method.getName();\n+                if (!set.remove(methodName)) {\n+                    throw new Exception(\"Unexpected method \" + methodName + \"() in event\");\n+                }\n+                RecordedFrame topFrame = event.getStackTrace().getFrames().get(0);\n+                if (!topFrame.getMethod().getName().equals(\"main\")) {\n+                    throw new Exception(\"Expected method to be called from main\");\n+                }\n+            }\n+            if (!set.isEmpty()) {\n+                throw new Exception(\"Expected events for the methods \" + set);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestFilterMethodAnnotation.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests that methods are instrumented correctly.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm\n+ *           -Xlog:jfr+methodtrace=debug\n+ *           jdk.jfr.event.tracing.TestInstrumentation\n+ **\/\n+public class TestInstrumentation {\n+    private static Object nullObject;\n+\n+    public static void main(String... args) throws Exception {\n+        List<RecordedEvent> traceEvents = new CopyOnWriteArrayList<>();\n+        List<RecordedEvent> timingEvents = new CopyOnWriteArrayList<>();\n+        try (RecordingStream r = new RecordingStream()) {\n+            r.setReuse(false);\n+            String filter = TestInstrumentation.class.getName();\n+            r.enable(\"jdk.MethodTrace\")\n+             .with(\"filter\", filter);\n+            r.enable(\"jdk.MethodTiming\")\n+             .with(\"filter\", filter)\n+             .with(\"period\", \"endChunk\");\n+            r.onEvent(\"jdk.MethodTrace\", traceEvents::add);\n+            r.onEvent(\"jdk.MethodTiming\", timingEvents::add);\n+            r.startAsync();\n+            try {\n+                whileTrue();\n+            } catch (NullPointerException npe) {\n+                \/\/ As expected\n+            }\n+            recursive(3);\n+            switchExpression(0);\n+            switchExpression(1);\n+            switchExpression(2);\n+            multipleReturns();\n+            multipleReturns();\n+            multipleReturns();\n+            multipleReturns();\n+            multipleReturns();\n+            try {\n+                exception();\n+            } catch (Exception e) {\n+            }\n+            try {\n+                deepException();\n+            } catch (Exception e) {\n+            }\n+            r.stop();\n+        }\n+        verifyTracing(traceEvents);\n+        verifyTiming(timingEvents);\n+    }\n+\n+    private static void verifyTracing(List<RecordedEvent> events) throws Exception {\n+        Map<String, Long> map = buildMethodMap(events, false);\n+        printMap(\"Tracing:\", map);\n+        assertMethod(map, \"exception\", 2);\n+        assertMethod(map, \"switchExpression\", 3);\n+        assertMethod(map, \"recursive\", 4);\n+        assertMethod(map, \"multipleReturns\", 5);\n+        if (!map.isEmpty()) {\n+            throw new Exception(\"Found unexpected methods \" + map.keySet());\n+        }\n+    }\n+\n+    private static void verifyTiming(List<RecordedEvent> events) throws Exception {\n+        Map<String, Long> map = buildMethodMap(events, true);\n+        printMap(\"Timing:\", map);\n+        assertMethod(map, \"exception\", 2);\n+        assertMethod(map, \"switchExpression\", 3);\n+        assertMethod(map, \"recursive\", 4);\n+        assertMethod(map, \"multipleReturns\", 5);\n+        for (var entry : map.entrySet()) {\n+            long invocations = entry.getValue();\n+            if (invocations != 0L) {\n+                throw new Exception(\"Unexpected \" + invocations + \" invocations for method \" + entry.getKey());\n+            }\n+        }\n+    }\n+\n+    private static void printMap(String caption, Map<String, Long> map) {\n+        System.out.println(caption);\n+        for (var entry : map.entrySet()) {\n+            System.out.println(entry.getKey() + \" = \" + entry.getValue());\n+        }\n+        System.out.println();\n+    }\n+\n+    private static void assertMethod(Map<String, Long> map, String method, long value) throws Exception {\n+        if (!map.containsKey(method)) {\n+            throw new Exception(\"Missing method \" + method);\n+        }\n+        if (!map.get(method).equals(value)) {\n+            throw new Exception(\"Expected value \" + value + \" for method \" + method);\n+        }\n+        map.remove(method);\n+    }\n+\n+    private static Map<String, Long> buildMethodMap(List<RecordedEvent> events, boolean invocations) {\n+        Map<String, Long> map = new HashMap<>();\n+        for (RecordedEvent e : events) {\n+            RecordedMethod m = e.getValue(\"method\");\n+            String name = m.getName();\n+            long add = invocations ? e.getLong(\"invocations\") : 1;\n+            map.compute(name, (key, value) -> (value == null) ? add : value + add);\n+        }\n+        return map;\n+    }\n+\n+    public static void whileTrue() {\n+        while (true) {\n+            nullObject.toString();\n+        }\n+    }\n+\n+    public static void recursive(int depth) {\n+        if (depth > 0) {\n+            recursive(depth - 1);\n+        } else {\n+            return;\n+        }\n+    }\n+\n+    public static String switchExpression(int value) {\n+        return switch (value) {\n+        case 0 -> \"zero\";\n+        case 1 -> \"one\";\n+        default -> \"number\";\n+        };\n+    }\n+\n+    public static void multipleReturns() {\n+        Random r = new Random();\n+        int v = r.nextInt(5);\n+        if (v == 0) {\n+            return;\n+        }\n+        switch (v) {\n+        case 1:\n+            return;\n+        case 2:\n+            return;\n+        }\n+        return;\n+    }\n+\n+    public static void exception() throws Exception {\n+        throw new Exception(\"\");\n+    }\n+\n+    public static void deepException() throws Exception {\n+        exception();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestInstrumentation.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.Event;\n+import jdk.jfr.StackTrace;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Basic test of the MethodTiming event.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.tracing.TestMethodTiming\n+ **\/\n+public class TestMethodTiming {\n+    private static final String EVENT_NAME = \"jdk.MethodTiming\";\n+\n+    @StackTrace(false)\n+    static class TimeMeasureEvent extends Event {\n+        public String id;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        testCount();\n+        testDuration();\n+    }\n+\n+    private static void testDuration() throws Exception {\n+        try (Recording r = new Recording()) {\n+            String filter = TestMethodTiming.class.getName() + \"::takeNap\";\n+            r.enable(EVENT_NAME).with(\"period\", \"endChunk\").with(\"filter\", filter);\n+            r.start();\n+\n+            TimeMeasureEvent maxEvent = new TimeMeasureEvent();\n+            maxEvent.id = \"max\";\n+            maxEvent.begin();\n+            takeNap();\n+            maxEvent.commit();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            for (var e : events) {\n+                System.out.println(e);\n+            }\n+            if (events.size() != 3) {\n+                throw new Exception(\"Expected three events: TimeMeasureEvent::id=max, TimeMeasureEventid=min and MethodTiming::method=takeNap()\");\n+            }\n+            RecordedEvent max = findWitdId(events, \"max\");\n+            RecordedEvent min = findWitdId(events, \"min\");\n+\n+            events.remove(min);\n+            events.remove(max);\n+            Duration minDuration = min.getDuration();\n+            Duration maxDuration = max.getDuration();\n+            RecordedEvent timingEvent = events.get(0);\n+            Duration d = timingEvent.getDuration(\"average\");\n+            if (d.compareTo(min.getDuration()) < 0) {\n+                throw new Exception(\"Expected duration to be at least \" + minDuration + \", was \" + d);\n+            }\n+            if (d.compareTo(max.getDuration()) > 0) {\n+                throw new Exception(\"Expected duration to be at most \" + maxDuration + \", was \" + d);\n+            }\n+            RecordedMethod method = timingEvent.getValue(\"method\");\n+            String methodName = method.getType().getName() + \"::\" + method.getName() + \" \" + method.getDescriptor();\n+            String expected = TestMethodTiming.class.getName() + \"::takeNap ()V\";\n+            if (!methodName.equals(expected)) {\n+                System.out.println(expected);\n+                throw new Exception(\"Expected method \" + expected + \" in event, but was \" +methodName);\n+            }\n+            if (timingEvent.getLong(\"invocations\") != 1) {\n+                throw new Exception(\"Expected one invocation\");\n+            }\n+        }\n+    }\n+\n+    private static RecordedEvent findWitdId(List<RecordedEvent> events, String id) throws Exception {\n+        for (RecordedEvent event : events) {\n+            if (event.hasField(\"id\")) {\n+                if (event.getString(\"id\").equals(id)) {\n+                    return event;\n+                }\n+            }\n+        }\n+        throw new Exception(\"Could not find event with ID \" + id);\n+    }\n+\n+    private static void takeNap() throws Exception {\n+        TimeMeasureEvent minEvent = new TimeMeasureEvent();\n+        minEvent.begin();\n+        minEvent.id = \"min\";\n+        Thread.sleep(10);\n+        minEvent.commit();\n+    }\n+\n+    private static void testCount() throws Exception {\n+        long invocations = 100_000;\n+        try (Recording r = new Recording()) {\n+            zebra();\n+            String filter = TestMethodTiming.class.getName() + \"::zebra\";\n+            r.enable(EVENT_NAME).with(\"period\", \"endChunk\").with(\"filter\", filter);\n+            r.start();\n+            for (int i = 0; i < invocations; i++) {\n+                zebra();\n+            }\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            for (RecordedEvent event : events) {\n+                Events.assertField(event, \"invocations\").equal(invocations);\n+            }\n+        }\n+    }\n+\n+    private static void zebra() {\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestMethodTiming.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.StackTrace;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Basic test of the MethodTrace event.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestMethodTrace\n+ **\/\n+public class TestMethodTrace {\n+    private static final String EVENT_NAME = \"jdk.MethodTrace\";\n+    private static final String CLASS_NAME = TestMethodTrace.class.getName();\n+\n+    @StackTrace(false)\n+    private static class OuterMeasurement extends Event {\n+    }\n+\n+    @StackTrace(false)\n+    private static class InnerMeasurement extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        AtomicReference<RecordedEvent> o = new AtomicReference<>();\n+        AtomicReference<RecordedEvent> i = new AtomicReference<>();\n+        AtomicReference<RecordedEvent> e = new AtomicReference<>();\n+        try (RecordingStream s = new RecordingStream()) {\n+            s.enable(EVENT_NAME).with(\"filter\", CLASS_NAME + \"::bar\");\n+            s.onEvent(EVENT_NAME, e::set);\n+            s.onEvent(OuterMeasurement.class.getName(), o::set);\n+            s.onEvent(InnerMeasurement.class.getName(), i::set);\n+            s.startAsync();\n+            foo();\n+            s.stop();\n+        }\n+        RecordedEvent event = e.get();\n+        RecordedEvent outer = o.get();\n+        RecordedEvent inner = i.get();\n+        System.out.println(event);\n+\n+        System.out.println(\"Outer start          : \" + outer.getStartTime());\n+        System.out.println(\"  Method Trace start : \" + event.getStartTime());\n+        System.out.println(\"   Inner start       : \" + inner.getStartTime());\n+        System.out.println(\"   Inner end         : \" + inner.getEndTime());\n+        System.out.println(\"  Method Trace end   : \" + event.getEndTime());\n+        System.out.println(\"Outer end            : \" + outer.getEndTime());\n+\n+        if (event.getStartTime().isBefore(outer.getStartTime())) {\n+            throw new Exception(\"Too early start time\");\n+        }\n+        if (event.getStartTime().isAfter(inner.getStartTime())) {\n+            throw new Exception(\"Too late start time\");\n+        }\n+        if (event.getEndTime().isBefore(inner.getEndTime())) {\n+            throw new Exception(\"Too early end time\");\n+        }\n+        if (event.getEndTime().isAfter(outer.getEndTime())) {\n+            throw new Exception(\"Too late end time\");\n+        }\n+        RecordedMethod method = event.getValue(\"method\");\n+        if (!method.getName().equals(\"bar\")) {\n+            throw new Exception(\"Expected method too be bar()\");\n+        }\n+        RecordedMethod topMethod = event.getStackTrace().getFrames().get(0).getMethod();\n+        if (!topMethod.getName().equals(\"foo\")) {\n+            throw new Exception(\"Expected top frame too be foo()\");\n+        }\n+    }\n+\n+    private static void foo() {\n+        OuterMeasurement event = new OuterMeasurement();\n+        event.begin();\n+        bar();\n+        event.commit();\n+    }\n+\n+    private static void bar() {\n+        InnerMeasurement event = new InnerMeasurement();\n+        event.begin();\n+        event.commit();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestMethodTrace.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.EventNames;\n+\/**\n+ * @test\n+ * @summary Tests that method tracing can be used with multiple recordings.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm\n+ *           -Xlog:jfr+methodtrace=debug\n+ *           jdk.jfr.event.tracing.TestMultipleRecordings\n+ **\/\n+public class TestMultipleRecordings {\n+    private static final String METHOD_TRACE = \"jdk.MethodTrace\";\n+    private static final String METHOD_TIMING = \"jdk.MethodTiming\";\n+    private static final String CLASS_NAME = TestMultipleRecordings.class.getName();\n+\n+    public static void main(String... args) throws Exception {\n+        testNestedMethodTrace();\n+        testNestedMethodTiming();\n+    }\n+\n+    private static void testNestedMethodTiming() throws Exception {\n+        List<RecordedEvent> outerEvents = new ArrayList<>();\n+        List<RecordedEvent> innerEvents = new ArrayList<>();\n+\n+        runNested(METHOD_TIMING, outerEvents, innerEvents);\n+        var outerBatches = groupByEndTime(outerEvents);\n+        System.out.println(\"Number of outer batches: \" + outerBatches.size());\n+        \/\/ Outer started\n+        assertTimingBatch(\"outer: started\", outerBatches.get(0), Map.of(\"foo\", 0, \"baz\", 0));\n+        assertTimingBatch(\"outer: initial to bestarted\", outerBatches.get(1), Map.of(\"foo\", 1, \"baz\", 1));\n+        \/\/ Inner started\n+        assertTimingBatch(\"outer: inner started\", outerBatches.get(2), Map.of(\"foo\", 1, \"baz\", 1, \"bar\", 0));\n+        assertTimingBatch(\"outer: inner ended\", outerBatches.get(3), Map.of(\"foo\", 2, \"baz\", 2, \"bar\", 1));\n+        \/\/ Inner stopped\n+        assertTimingBatch(\"outer: only outer\", outerBatches.get(4), Map.of(\"foo\", 2, \"baz\", 2));\n+        assertTimingBatch(\"outer: ending\", outerBatches.get(5), Map.of(\"foo\", 3, \"baz\", 3));\n+        \/\/ Outer stopped\n+\n+        var innerBatches = groupByEndTime(innerEvents);\n+        System.out.println(\"Number of inner batches: \" + innerBatches.size());\n+        assertTimingBatch(\"inner: started\", innerBatches.get(0), Map.of(\"foo\", 1, \"baz\", 1, \"bar\", 0));\n+        assertTimingBatch(\"inner: ended\", innerBatches.get(1), Map.of(\"foo\", 2, \"baz\", 2, \"bar\", 1));\n+    }\n+\n+    private static void assertTimingBatch(String batchName, List<RecordedEvent> events, Map<String, Integer> expected) throws Exception {\n+        Map<String, Integer> map = new HashMap<>();\n+        for (RecordedEvent e : events) {\n+            RecordedMethod m = e.getValue(\"method\");\n+            String name = m.getName();\n+            int invocations = (int) e.getLong(\"invocations\");\n+            map.put(name, invocations);\n+        }\n+        if (!map.equals(expected)) {\n+            printBatch(\"Expected:\", expected);\n+            printBatch(\"Was:\", map);\n+            throw new Exception(\"Batch '\" + batchName + \"' not as expected\");\n+        }\n+    }\n+\n+    private static void printBatch(String name, Map<String, Integer> batch) {\n+        System.out.println(name);\n+        for (var entry : batch.entrySet()) {\n+            System.out.println(entry.getKey() + \" = \" + entry.getValue());\n+        }\n+    }\n+\n+    private static List<List<RecordedEvent>> groupByEndTime(List<RecordedEvent> events) {\n+        var listList = new ArrayList<List<RecordedEvent>>();\n+        List<RecordedEvent> list = null;\n+        Instant last = null;\n+        while (!events.isEmpty()) {\n+            RecordedEvent event = removeEarliest(events);\n+            Instant timestamp = event.getEndTime();\n+            if (last == null || !timestamp.equals(last)) {\n+                list = new ArrayList<RecordedEvent>();\n+                listList.add(list);\n+            }\n+            list.add(event);\n+            last = event.getEndTime();\n+        }\n+        return listList;\n+    }\n+\n+    private static RecordedEvent removeEarliest(List<RecordedEvent> events) {\n+        RecordedEvent earliest = null;\n+        for (RecordedEvent event : events) {\n+            if (earliest == null || event.getEndTime().isBefore(earliest.getEndTime())) {\n+                earliest = event;\n+            }\n+        }\n+        events.remove(earliest);\n+        return earliest;\n+    }\n+\n+    private static void testNestedMethodTrace() throws Exception {\n+        List<RecordedEvent> outerEvents = new ArrayList<>();\n+        List<RecordedEvent> innerEvents = new ArrayList<>();\n+\n+        runNested(METHOD_TRACE, outerEvents, innerEvents);\n+\n+        assertMethodTraceEvents(outerEvents, \"Outer\", \"foo\", 3);\n+        assertMethodTraceEvents(outerEvents, \"Outer\", \"bar\", 1);\n+        assertMethodTraceEvents(outerEvents, \"Outer\", \"baz\", 3);\n+        assertMethodTraceEvents(innerEvents, \"Inner\", \"foo\", 1);\n+        assertMethodTraceEvents(innerEvents, \"Inner\", \"bar\", 1);\n+        assertMethodTraceEvents(innerEvents, \"Inner\", \"baz\", 1);\n+    }\n+\n+    private static void runNested(String eventName, List<RecordedEvent> outerEvents, List<RecordedEvent> innerEvents)\n+            throws IOException {\n+        try (Recording outer = new Recording()) {\n+            outer.enable(eventName).with(\"filter\",\n+               CLASS_NAME + \"::foo;\" +\n+               CLASS_NAME + \"::baz\");\n+            outer.start();\n+            foo();\n+            bar();\n+            baz();\n+            nap();\n+            try (Recording inner = new Recording()) {\n+                inner.enable(eventName).with(\"filter\",\n+                    CLASS_NAME + \"::foo;\" +\n+                    CLASS_NAME + \"::bar\");\n+                inner.start();\n+                foo();\n+                bar();\n+                baz();\n+                inner.stop();\n+                innerEvents.addAll(Events.fromRecording(inner));\n+                nap();\n+            }\n+            foo();\n+            bar();\n+            baz();\n+            nap();\n+            outer.stop();\n+            outerEvents.addAll(Events.fromRecording(outer));\n+        }\n+    }\n+\n+    \/\/ Ensure that periodic events at endChunk get a different\n+    \/\/ timestamp than periodic events at beginChunk\n+    private static void nap() {\n+        Instant time = Instant.now();\n+        do {\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException e) {\n+                \/\/ ignore\n+            }\n+        } while (time.plus(Duration.ofMillis(10)).isAfter(Instant.now()));\n+    }\n+\n+    private static void assertMethodTraceEvents(List<RecordedEvent> events, String context, String methodName, int expected) throws Exception {\n+        int actual = 0;\n+        for (RecordedEvent event : events) {\n+            RecordedMethod method = event.getValue(\"method\");\n+            if (method.getName().equals(methodName)) {\n+                actual++;\n+            }\n+        }\n+        if (actual != expected) {\n+            System.out.println(context);\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+            }\n+            throw new Exception(context + \": expected \" + expected + \" events for method \" + methodName + \", got actual \" + actual);\n+        }\n+    }\n+\n+    private static void foo() {\n+        System.out.println(\"Executing: foo()\");\n+    }\n+\n+    private static void bar() {\n+        System.out.println(\"Executing: bar()\");\n+    }\n+\n+    private static void baz() {\n+        System.out.println(\"Executing: baz()\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestMultipleRecordings.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests that tracing and timing work when using multiple threads.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm\n+ *           -Xlog:jfr+methodtrace=trace\n+ *           jdk.jfr.event.tracing.TestMultipleThreads\n+ **\/\n+public class TestMultipleThreads {\n+    private static final String METHOD_PREFIX = TestMultipleThreads.class.getName() + \"::method\";\n+    private static final String TRACE_EVENT = \"jdk.MethodTrace\";\n+    private static final String TIMING_EVENT = \"jdk.MethodTiming\";\n+    private static int METHOD_COUNT = 5;\n+    private static int THREAD_COUNT = 5;\n+    private static int INVOCATIONS_PER_THREAD = 25_000; \/\/ Low enough to fit one chunk\n+    private static int INVOCATIONS_PER_METHOD = THREAD_COUNT * INVOCATIONS_PER_THREAD \/ METHOD_COUNT;\n+\n+    public static class TestThread extends Thread {\n+        public void run() {\n+            for (int i = 0; i < INVOCATIONS_PER_THREAD; i++) {\n+                switch (i % METHOD_COUNT) {\n+                case 0 -> method0();\n+                case 1 -> method1();\n+                case 2 -> method2();\n+                case 3 -> method3();\n+                case 4 -> method4();\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        List<RecordedEvent> traceEvents = new ArrayList<>();\n+        List<RecordedEvent> timingEvents = new ArrayList<>();\n+        try (RecordingStream r = new RecordingStream()) {\n+            r.enable(TRACE_EVENT).with(\"filter\",\n+                METHOD_PREFIX + \"0;\" +\n+                METHOD_PREFIX + \"2;\");\n+            r.enable(TIMING_EVENT).with(\"filter\",\n+                METHOD_PREFIX + \"0;\" +\n+                METHOD_PREFIX + \"1;\" +\n+                METHOD_PREFIX + \"2;\" +\n+                METHOD_PREFIX + \"3;\" +\n+                METHOD_PREFIX + \"4;\")\n+             .with(\"period\", \"endChunk\");\n+            List<TestThread> threads = new ArrayList<>();\n+            for (int i = 0; i < THREAD_COUNT; i++) {\n+                threads.add(new TestThread());\n+            }\n+            r.setReuse(false);\n+            r.onEvent(TRACE_EVENT, traceEvents::add);\n+            r.onEvent(TIMING_EVENT, timingEvents::add);\n+            r.startAsync();\n+            for (TestThread t : threads) {\n+                t.start();\n+            }\n+            for (TestThread t : threads) {\n+                t.join();\n+            }\n+            r.stop();\n+            verifyTraceEvents(traceEvents);\n+            for (RecordedEvent event : timingEvents) {\n+                System.out.println(event);\n+            }\n+            verifyTimingEvents(timingEvents);\n+        }\n+    }\n+\n+    private static void verifyTimingEvents(List<RecordedEvent> events) throws Exception {\n+        for (RecordedEvent e : events) {\n+            long invocations = e.getLong(\"invocations\");\n+            if (invocations != INVOCATIONS_PER_METHOD) {\n+                RecordedMethod method = e.getValue(\"method\");\n+                String msg = \"Expected \" + INVOCATIONS_PER_METHOD + \" invocations for \";\n+                msg += method.getName() + \", but got \" + invocations;\n+                throw new Exception(msg);\n+            }\n+        }\n+        if (events.size() != METHOD_COUNT) {\n+            throw new Exception(\"Expected \" + METHOD_COUNT + \" timing events, one per method\");\n+        }\n+    }\n+\n+    private static void verifyTraceEvents(List<RecordedEvent> events) throws Exception {\n+        int expected = 2 * INVOCATIONS_PER_METHOD;\n+        if (events.size() != expected) {\n+            throw new Exception(\"Expected \" + expected + \" event, but got \" + events.size());\n+        }\n+    }\n+\n+    private static void method0() {\n+    }\n+\n+    private static void method1() {\n+    }\n+\n+    private static void method2() {\n+    }\n+\n+    private static void method3() {\n+    }\n+\n+    private static void method4() {\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestMultipleThreads.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.jfr.FlightRecorder;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @summary Tests that restricted classes cannot be timed or traced.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.tracing.TestRestrictedClasses\n+ **\/\n+public class TestRestrictedClasses {\n+\n+    public static void main(String... args) throws Exception {\n+        testJdkJfr();\n+        testConcurrentHashMap();\n+        testConcurrentHashMapNode();\n+        testAtomicLong();\n+    }\n+\n+    private static void testJdkJfr() throws Exception {\n+        testDebug(FlightRecorder.class.getName(), null);\n+    }\n+\n+    private static void testConcurrentHashMapNode() throws Exception {\n+        testDebug(ConcurrentHashMap.class.getName() + \"$Node\", \"Risk of recursion, skipping bytecode generation for java.util.concurrent.ConcurrentHashMap$Node\");\n+    }\n+\n+    private static void testConcurrentHashMap() throws Exception {\n+        testDebug(ConcurrentHashMap.class.getName(), \"Risk of recursion, skipping bytecode generation for java.util.concurrent.ConcurrentHashMap\");\n+    }\n+\n+    private static void testAtomicLong() throws Exception {\n+        testDebug(AtomicLong.class.getName(), \"Risk of recursion, skipping bytecode generation for java.util.concurrent.atomic.AtomicLong\");\n+    }\n+\n+    private static void testDebug(String clazz, String expected) throws Exception {\n+        List<String> cmds = new ArrayList<>();\n+        cmds.add(\"-Xlog:jfr+methodtrace=debug\");\n+        cmds.add(\"-XX:StartFlightRecording:method-trace=\" + clazz);\n+        cmds.add(\"-version\");\n+        OutputAnalyzer out = ProcessTools.executeTestJava(cmds);\n+        out.shouldHaveExitValue(0);\n+        if (expected != null) {\n+            out.shouldContain(expected);\n+        }\n+        \/\/ Check that bytecode was not generated\n+        out.shouldNotMatch(\"Bytecode generation\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestRestrictedClasses.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests that filters can be applied to classes across multiple class loaders and that\n+ *          method tracing works after class unloading.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.event.tracing.Car\n+ * @run main\/othervm -XX:-DisableExplicitGC -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestWithClassLoaders\n+ **\/\n+public class TestWithClassLoaders {\n+    private static final String METHOD_TRACE = \"jdk.MethodTrace\";\n+    private static final String METHOD_TIMING = \"jdk.MethodTiming\";\n+    private static final String CLASS_NAME = \"jdk.jfr.event.tracing.Car\";\n+\n+    public static void main(String... args) throws Exception {\n+        var traceEvents = new CopyOnWriteArrayList<RecordedEvent>();\n+        var timingEvents = new CopyOnWriteArrayList<RecordedEvent>();\n+        try (var r = new RecordingStream()) {\n+            Runnable beforeCar = createCar(\"before\");\n+            r.setReuse(false);\n+            r.enable(METHOD_TRACE)\n+             .with(\"filter\", CLASS_NAME + \"::run\");\n+            r.enable(METHOD_TIMING)\n+             .with(\"filter\", CLASS_NAME + \"::run\").with(\"period\", \"endChunk\");\n+            r.onEvent(METHOD_TRACE, traceEvents::add);\n+            r.onEvent(METHOD_TIMING, timingEvents::add);\n+            r.startAsync();\n+            Runnable duringCar = createCar(\"during\");\n+            Runnable garbageCar = createCar(\"garbage\");\n+            beforeCar.run();\n+            duringCar.run();\n+            garbageCar.run();\n+            garbageCar = null;\n+            System.gc();\n+            System.gc();\n+            r.stop();\n+            System.out.println(\"Method Trace events:\");\n+            System.out.println(traceEvents);\n+            if (traceEvents.size() != 3) {\n+                throw new Exception(\"Expected 3 Method Trace events, one for each class loader\");\n+            }\n+            for (RecordedEvent event : traceEvents) {\n+                RecordedMethod method = event.getValue(\"method\");\n+                String methodName = method.getName();\n+                if (!methodName.equals(\"run\")) {\n+                    throw new Exception(\"Expected method name to be 'run'\");\n+                }\n+            }\n+            System.out.println(\"Method Timing events:\");\n+            System.out.println(timingEvents);\n+            if (timingEvents.size() != 3) {\n+                throw new Exception(\"Expected 3 Method Timing events, one for each class loader\");\n+            }\n+            int totalInvocations = 0;\n+            for (RecordedEvent event : timingEvents) {\n+                totalInvocations += event.getLong(\"invocations\");\n+            }\n+            if (totalInvocations != 3) {\n+                throw new Exception(\"Expected three invocations in total, was \" + totalInvocations);\n+            }\n+        }\n+    }\n+\n+    public static Runnable createCar(String name) throws Exception {\n+        byte[] bytes = loadCarBytes();\n+        ClassLoader parent = TestWithClassLoaders.class.getClassLoader();\n+        CarLoader loader = new CarLoader(name, bytes, parent);\n+        Class<?> clazz = loader.loadClass(CLASS_NAME);\n+        Object instance = clazz.getConstructor().newInstance();\n+        return (Runnable) instance;\n+    }\n+\n+    private static byte[] loadCarBytes() throws IOException {\n+        String location = \"\/\" + CLASS_NAME.replaceAll(\"\\\\.\", \"\/\").concat(\".class\");\n+        try (var is = TestWithClassLoaders.class.getResourceAsStream(location)) {\n+            return is.readAllBytes();\n+        }\n+    }\n+\n+    public static class CarLoader extends ClassLoader {\n+        private final byte[] bytes;\n+\n+        public CarLoader(String name, byte[] bytes, ClassLoader parent) {\n+            super(name, parent);\n+            this.bytes = bytes;\n+        }\n+\n+        protected Class<?> loadClass(String className, boolean resolve) throws ClassNotFoundException {\n+            Class<?> clazz = findLoadedClass(className);\n+            if (clazz == null && className.equals(CLASS_NAME)) {\n+                clazz = defineClass(className, bytes, 0, bytes.length);\n+            } else {\n+                clazz = super.loadClass(className, resolve);\n+            }\n+            if (resolve) {\n+                resolveClass(clazz);\n+            }\n+            return clazz;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestWithClassLoaders.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.jfr.Recording;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests applying filters to methods in both exported and unexported packages\n+ *          of a named module.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.tracing.TestWithModules\n+ **\/\n+public class TestWithModules {\n+\n+    \/** Directory structure:\n+         |-src\n+           |-application\n+           | |-Main.java\n+           |-module\n+             |-module-info.java\n+             |-test\n+               |-exported\n+               | |- Exported.java\n+               |-unexported\n+                 |- UnExported.java\n+    **\/\n+    private static String MODULE_INFO =\n+    \"\"\"\n+    module test.exported {\n+       exports test.exported;\n+    }\n+    \"\"\";\n+\n+    private static String EXPORTED_CLASS =\n+    \"\"\"\n+    package test.exported;\n+\n+    import test.unexported.Unexported;\n+\n+    public class Exported {\n+       public static void run() {\n+          System.out.println(\"Exported::run executed!\");\n+          Unexported.run();\n+       }\n+    }\n+    \"\"\";\n+\n+    private static String UNEXPORTED_CLASS =\n+    \"\"\"\n+    package test.unexported;\n+\n+    public class Unexported {\n+       public static void run() {\n+          System.out.println(\"Unexported::run executed!\");\n+       }\n+    }\n+    \"\"\";\n+\n+    private static String MAIN_CLASS =\n+    \"\"\"\n+    import test.exported.Exported;\n+    import jdk.jfr.Recording;\n+    import java.nio.file.Path;\n+\n+    public class Main {\n+       public static void main(String... args) throws Exception {\n+          Path file = Path.of(args[0]);\n+          boolean before = args[1].equals(\"run-before\");\n+          System.out.println(\"Main before=\" + before);\n+          try(Recording r = new Recording()) {\n+            if (before) {\n+              \/\/ Load class before JFR starts\n+              Exported.run();\n+            }\n+            r.enable(\"jdk.MethodTrace\").with(\"filter\", \"test.unexported.Unexported::run\");\n+            r.enable(\"jdk.MethodTiming\").with(\"filter\", \"test.unexported.Unexported::run\").with(\"period\", \"endChunk\");\n+            r.start();\n+            System.out.println(\"About to run with instrumented\");\n+            Exported.run();\n+            r.stop();\n+            r.dump(file);\n+            System.out.println(\"Dump written \" + file);\n+          }\n+       }\n+    }\n+    \"\"\";\n+\n+    public static void main(String... args) throws Exception {\n+        Path src = Path.of(\"src\").toAbsolutePath();\n+        Path modulePath = materializeModule(src);\n+        Path mainFile = materializeMain(src);\n+        Path output = Files.createDirectory(Path.of(\"output\").toAbsolutePath());\n+        List<Path> srcFiles = Files.walk(modulePath).filter(Files::isRegularFile).toList();\n+        List<String> arguments = new ArrayList<>();\n+        arguments.add(\"-d\");\n+        arguments.add(output.toString());\n+        for (Path p : srcFiles) {\n+            arguments.add(p.toAbsolutePath().toString());\n+        }\n+        if (!compile(arguments)) {\n+            throw new Exception(\"Could not compile classes\");\n+        }\n+        testClassloadBefore(mainFile, output);\n+        testClassloadDuring(mainFile, output);\n+    }\n+\n+    private static Path materializeMain(Path src) throws IOException {\n+        Path srcApplication = Files.createDirectories(src.resolve(\"application\"));\n+        Path mainFile = srcApplication.resolve(\"Main.java\");\n+        Files.writeString(mainFile, MAIN_CLASS);\n+        return mainFile;\n+    }\n+\n+    private static void testClassloadBefore(Path mainFile, Path modulePath) throws Exception {\n+        Path file = Path.of(\"before.jfr\").toAbsolutePath();\n+        execute(file, mainFile, modulePath, true);\n+        verifyRecording(\"already loaded class\", file);\n+    }\n+\n+    private static void testClassloadDuring(Path mainFile, Path modulePath) throws Exception {\n+        Path file = Path.of(\"during.jfr\").toAbsolutePath();\n+        execute(file, mainFile, modulePath, false);\n+        verifyRecording(\"loading of class\", file);\n+    }\n+\n+    private static void verifyRecording(String title, Path file) throws Exception {\n+        List<RecordedEvent> traceEvents = new ArrayList<>();\n+        List<RecordedEvent> timingEvents = new ArrayList<>();\n+        System.out.println(\"********* Verifying \" + title + \" ********\");\n+        try (EventStream s = EventStream.openFile(file)) {\n+            s.setReuse(false);\n+            s.onEvent(\"jdk.MethodTrace\", traceEvents::add);\n+            s.onEvent(\"jdk.MethodTiming\", timingEvents::add);\n+            s.onEvent(System.out::println);\n+            s.start();\n+        }\n+        assertMethod(traceEvents, \"test.unexported.Unexported\", \"run\");\n+        assertMethod(timingEvents, \"test.unexported.Unexported\", \"run\");\n+        assertMethodTimingCount(timingEvents.get(0), 1);\n+    }\n+\n+    private static void assertMethodTimingCount(RecordedEvent event, int expected) throws Exception {\n+        long invocations = event.getLong(\"invocations\");\n+        if (invocations != expected) {\n+            throw new Exception(\"Expected invocations to be \" + expected + \", but was \" + invocations);\n+        }\n+    }\n+\n+    private static void assertMethod(List<RecordedEvent> events, String className, String methodName) throws Exception {\n+        for (RecordedEvent event : events) {\n+            RecordedMethod method = event.getValue(\"method\");\n+            if (method.getName().equals(methodName) && method.getType().getName().equals(className)) {\n+                return;\n+            }\n+        }\n+        throw new Exception(\"Expected method named \" + className + \"::\" + methodName);\n+    }\n+\n+    private static void execute(Path jfrFile, Path mainFile, Path modulePath, boolean before) throws Exception {\n+        String[] c = new String[7];\n+        c[0] = \"--module-path\";\n+        c[1] = modulePath.toString();\n+        c[2] = \"--add-modules\";\n+        c[3] = \"test.exported\";\n+        c[4] = mainFile.toString();\n+        c[5] = jfrFile.toString();\n+        c[6] = before ? \"run-before\" : \"not-run-before\";\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(c);\n+        oa.waitFor();\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    private static Path materializeModule(Path src) throws IOException {\n+        Path srcModule = Files.createDirectories(src.resolve(\"module\"));\n+        Path moduleFile = srcModule.resolve(\"module-info.java\");\n+        Files.writeString(moduleFile, MODULE_INFO);\n+\n+        Path exported = Files.createDirectories(srcModule.resolve(\"test\").resolve(\"exported\"));\n+        Path exportedJava = exported.resolve(\"Exported.java\");\n+        Files.writeString(exportedJava, EXPORTED_CLASS);\n+\n+        Path unexported = Files.createDirectories(srcModule.resolve(\"test\").resolve(\"unexported\"));\n+        Path unexportedJava = unexported.resolve(\"Unexported.java\");\n+        Files.writeString(unexportedJava, UNEXPORTED_CLASS);\n+\n+        return srcModule;\n+    }\n+\n+    private static boolean compile(List<String> arguments) {\n+        Optional<ToolProvider> tp = ToolProvider.findFirst(\"javac\");\n+        if (tp.isEmpty()) {\n+            return false;\n+        }\n+        var tool = tp.get();\n+        String[] options = arguments.toArray(String[]::new);\n+        int ret = tool.run(System.out, System.err, options);\n+        return ret == 0;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestWithModules.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,2 @@\n+    public static final String MethodTiming = PREFIX + \"MethodTiming\";\n+    public static final String MethodTrace = PREFIX + \"MethodTrace\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -364,0 +364,10 @@\n+    public static RecordedEvent getFirst(List<RecordedEvent> events, String name) throws Exception {\n+        for (RecordedEvent event : events) {\n+            if (event.getEventType().getName().equals(name)) {\n+                return event;\n+            }\n+        }\n+        Asserts.fail(\"Missing event \" + name + \" in recording \" + events.toString());\n+        return null;\n+    }\n+\n@@ -373,0 +383,6 @@\n+    public static void assertEventCount(List<RecordedEvent> events, int count) throws Exception {\n+        if (events.size() != count) {\n+            throw new Exception(\"Expected \" + count + \" events, found \" + events.size());\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/Events.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}