{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-  print_hex_dump(st, pc - 32, pc + 32, sizeof(char));\n+  print_hex_dump(st, pc - 32, pc + 32, sizeof(char), false);\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1276,1 +1276,1 @@\n-      os::print_hex_dump(&lsh, base, top, unitsize, 32, requested_base);\n+      os::print_hex_dump(&lsh, base, top, unitsize, true, 32, requested_base);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2024, Red Hat, Inc. All rights reserved.\n@@ -49,1 +49,1 @@\n-    os::print_hex_dump(&ss, start, end, 4);\n+    os::print_hex_dump(&ss, start, end, 4, true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    os::print_hex_dump(tty, (address)n, (address)n + sizeof(Node), 1);\n+    os::print_hex_dump(tty, (address)n, (address)n + sizeof(Node), 1, true);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    os::print_hex_dump(st, from1, to1, 1);\n+    os::print_hex_dump(st, from1, to1, 1, true);\n@@ -61,1 +61,1 @@\n-    os::print_hex_dump(st, from2, to2, 1);\n+    os::print_hex_dump(st, from2, to2, 1, true);\n@@ -64,1 +64,1 @@\n-    os::print_hex_dump(st, from1, to2, 1);\n+    os::print_hex_dump(st, from1, to2, 1, true);\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -944,1 +944,1 @@\n-ATTRIBUTE_NO_ASAN static bool read_safely_from(intptr_t* p, intptr_t* result) {\n+ATTRIBUTE_NO_ASAN static bool read_safely_from(const uint8_t* p, uintptr_t* result) {\n@@ -946,1 +946,1 @@\n-  intptr_t i = SafeFetchN(p, errval);\n+  intptr_t i = SafeFetchN((intptr_t*)p, errval);\n@@ -948,1 +948,1 @@\n-    i = SafeFetchN(p, ~errval);\n+    i = SafeFetchN((intptr_t*)p, ~errval);\n@@ -953,1 +953,1 @@\n-  (*result) = i;\n+  (*result) = (uintptr_t)i;\n@@ -957,1 +957,15 @@\n-static void print_hex_location(outputStream* st, address p, int unitsize) {\n+\/\/ Helper for os::print_hex_dump\n+static void print_ascii_form(stringStream& ascii_form, uint64_t value, int unitsize) {\n+  union {\n+    uint64_t v;\n+    uint8_t c[sizeof(v)];\n+  } u = { value };\n+  for (int i = 0; i < unitsize; i ++) {\n+    const int idx = LITTLE_ENDIAN_ONLY(i) BIG_ENDIAN_ONLY(sizeof(u.v) - 1 - i);\n+    const uint8_t c = u.c[idx];\n+    ascii_form.put(isprint(c) && isascii(c) ? c : '_');\n+  }\n+}\n+\n+\/\/ Helper for os::print_hex_dump\n+static void print_hex_location(outputStream* st, const uint8_t* p, int unitsize, stringStream& ascii_form) {\n@@ -959,1 +973,1 @@\n-  address pa = align_down(p, sizeof(intptr_t));\n+  const uint8_t* pa = align_down(p, sizeof(intptr_t));\n@@ -963,3 +977,3 @@\n-    intptr_t i1, i2;\n-    if (read_safely_from((intptr_t*)pa, &i1) &&\n-        read_safely_from((intptr_t*)pa + 1, &i2)) {\n+    uintptr_t i1 = 0, i2 = 0;\n+    if (read_safely_from(pa, &i1) &&\n+        read_safely_from(pa + sizeof(uintptr_t), &i2)) {\n@@ -970,0 +984,1 @@\n+      print_ascii_form(ascii_form, value, unitsize);\n@@ -976,2 +991,2 @@\n-  intptr_t i = 0;\n-  if (read_safely_from((intptr_t*)pa, &i)) {\n+  uintptr_t i = 0;\n+  if (read_safely_from(pa, &i)) {\n@@ -987,1 +1002,1 @@\n-    intptr_t value = bitfield(i, bitoffset, bitfieldsize);\n+    uintptr_t value = bitfield(i, bitoffset, bitfieldsize);\n@@ -994,0 +1009,1 @@\n+    print_ascii_form(ascii_form, value, unitsize);\n@@ -1004,2 +1020,3 @@\n-void os::print_hex_dump(outputStream* st, address start, address end, int unitsize,\n-                        int bytes_per_line, address logical_start) {\n+void os::print_hex_dump(outputStream* st, const uint8_t* start, const uint8_t* end, int unitsize,\n+                        bool print_ascii, int bytes_per_line, const uint8_t* logical_start) {\n+  constexpr int max_bytes_per_line = 64;\n@@ -1007,0 +1024,2 @@\n+  assert(bytes_per_line > 0 && bytes_per_line <= max_bytes_per_line &&\n+         is_power_of_2(bytes_per_line), \"invalid bytes_per_line\");\n@@ -1013,1 +1032,1 @@\n-  int cols_per_line = bytes_per_line \/ unitsize;\n+  const int cols_per_line = bytes_per_line \/ unitsize;\n@@ -1015,2 +1034,4 @@\n-  address p = start;\n-  address logical_p = logical_start;\n+  const uint8_t* p = start;\n+  const uint8_t* logical_p = logical_start;\n+\n+  stringStream ascii_form;\n@@ -1019,1 +1040,0 @@\n-  st->print(PTR_FORMAT \":   \", p2i(logical_p));\n@@ -1021,1 +1041,4 @@\n-    print_hex_location(st, p, unitsize);\n+    if (cols == 0) {\n+      st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+    }\n+    print_hex_location(st, p, unitsize, ascii_form);\n@@ -1025,2 +1048,5 @@\n-    if (cols >= cols_per_line && p < end) {\n-       cols = 0;\n+    if (cols >= cols_per_line) {\n+       if (print_ascii && !ascii_form.is_empty()) {\n+         st->print(\"   %s\", ascii_form.base());\n+       }\n+       ascii_form.reset();\n@@ -1028,1 +1054,1 @@\n-       st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+       cols = 0;\n@@ -1033,1 +1059,11 @@\n-  st->cr();\n+\n+  if (cols > 0) { \/\/ did not print a full line\n+    if (print_ascii) {\n+      \/\/ indent last ascii part to match that of full lines\n+      const int size_of_printed_unit = unitsize * 2;\n+      const int space_left = (cols_per_line - cols) * (size_of_printed_unit + 1);\n+      st->sp(space_left);\n+      st->print(\"  %s\", ascii_form.base());\n+    }\n+    st->cr();\n+  }\n@@ -1046,1 +1082,1 @@\n-  print_hex_dump(st, sp, sp + 512, sizeof(intptr_t));\n+  print_hex_dump(st, sp, sp + 512, sizeof(intptr_t), true);\n@@ -1051,1 +1087,1 @@\n-  print_hex_dump(st, pc - 256, pc + 256, unitsize);\n+  print_hex_dump(st, pc - 256, pc + 256, unitsize, false);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":61,"deletions":25,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -858,4 +858,4 @@\n-  static void print_hex_dump(outputStream* st, address start, address end, int unitsize,\n-                             int bytes_per_line, address logical_start);\n-  static void print_hex_dump(outputStream* st, address start, address end, int unitsize) {\n-    print_hex_dump(st, start, end, unitsize, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n+  static void print_hex_dump(outputStream* st, const uint8_t* start, const uint8_t* end, int unitsize, bool print_ascii,\n+                             int bytes_per_line, const uint8_t* logical_start);\n+  static void print_hex_dump(outputStream* st, const uint8_t* start, const uint8_t* end, int unitsize, bool print_ascii = true) {\n+    print_hex_dump(st, start, end, unitsize, print_ascii, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -270,0 +270,1 @@\n+  bool is_empty() const { return _buffer[0] == '\\0'; }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -170,2 +170,3 @@\n-static void do_test_print_hex_dump(address addr, size_t len, int unitsize, const char* expected) {\n-  char buf[256];\n+static void do_test_print_hex_dump(const uint8_t* from, const uint8_t* to, int unitsize, int bytes_per_line,\n+                                   const uint8_t* logical_start, const char* expected) {\n+  char buf[2048];\n@@ -174,4 +175,2 @@\n-  os::print_hex_dump(&ss, addr, addr + len, unitsize);\n-  \/\/ tty->print_cr(\"expected: %s\", expected);\n-  \/\/ tty->print_cr(\"result: %s\", buf);\n-  EXPECT_THAT(buf, HasSubstr(expected));\n+  os::print_hex_dump(&ss, from, to, unitsize, true, bytes_per_line, logical_start);\n+  EXPECT_STREQ(buf, expected);\n@@ -181,6 +180,5 @@\n-  const char* pattern [4] = {\n-#ifdef VM_LITTLE_ENDIAN\n-    \"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\",\n-    \"0100 0302 0504 0706 0908 0b0a 0d0c 0f0e\",\n-    \"03020100 07060504 0b0a0908 0f0e0d0c\",\n-    \"0706050403020100 0f0e0d0c0b0a0908\"\n+\n+#ifdef _LP64\n+#define ADDRESS1 \"0x0000aaaaaaaaaa00\"\n+#define ADDRESS2 \"0x0000aaaaaaaaaa20\"\n+#define ADDRESS3 \"0x0000aaaaaaaaaa40\"\n@@ -188,4 +186,3 @@\n-    \"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\",\n-    \"0001 0203 0405 0607 0809 0a0b 0c0d 0e0f\",\n-    \"00010203 04050607 08090a0b 0c0d0e0f\",\n-    \"0001020304050607 08090a0b0c0d0e0f\"\n+#define ADDRESS1 \"0xaaaaaa00\"\n+#define ADDRESS2 \"0xaaaaaa20\"\n+#define ADDRESS3 \"0xaaaaaa40\"\n@@ -193,1 +190,0 @@\n-  };\n@@ -195,6 +191,15 @@\n-  const char* pattern_not_readable [4] = {\n-    \"?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\",\n-    \"???? ???? ???? ???? ???? ???? ???? ????\",\n-    \"???????? ???????? ???????? ????????\",\n-    \"???????????????? ????????????????\"\n-  };\n+#define ASCII_1  \"____#_jdk\/internal\/loader\/Native\"\n+#define ASCII_2  \"Libraries_______\"\n+\n+#define PAT_1 ADDRESS1 \":   ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\\n\" \\\n+              ADDRESS2 \":   ff ff e0 dc 23 00 6a 64 6b 2f 69 6e 74 65 72 6e 61 6c 2f 6c 6f 61 64 65 72 2f 4e 61 74 69 76 65   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c 69 62 72 61 72 69 65 73 00 00 00 00 00 00 00                                                   \" ASCII_2 \"\\n\"\n+\n+#ifdef VM_LITTLE_ENDIAN\n+#define PAT_2 ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              ADDRESS2 \":   ffff dce0 0023 646a 2f6b 6e69 6574 6e72 6c61 6c2f 616f 6564 2f72 614e 6974 6576   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   694c 7262 7261 6569 0073 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n+\n+#define PAT_4 ADDRESS1 \":   ???????? ???????? ???????? ???????? ???????? ???????? ???????? ????????\\n\" \\\n+              ADDRESS2 \":   dce0ffff 646a0023 6e692f6b 6e726574 6c2f6c61 6564616f 614e2f72 65766974   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   7262694c 65697261 00000073 00000000                                       \" ASCII_2 \"\\n\"\n@@ -202,4 +207,3 @@\n-  \/\/ On AIX, zero page is readable.\n-  address unreadable =\n-#ifdef AIX\n-    (address) 0xFFFFFFFFFFFF0000ULL;\n+#define PAT_8 ADDRESS1 \":   ???????????????? ???????????????? ???????????????? ????????????????\\n\" \\\n+              ADDRESS2 \":   646a0023dce0ffff 6e7265746e692f6b 6564616f6c2f6c61 65766974614e2f72   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   656972617262694c 0000000000000073                                     \" ASCII_2 \"\\n\"\n@@ -207,3 +211,3 @@\n-    (address) 0\n-#endif\n-    ;\n+#define PAT_2 ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              ADDRESS2 \":   ffff e0dc 2300 6a64 6b2f 696e 7465 726e 616c 2f6c 6f61 6465 722f 4e61 7469 7665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c69 6272 6172 6965 7300 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n@@ -211,14 +215,7 @@\n-  ResourceMark rm;\n-  char buf[64];\n-  stringStream ss(buf, sizeof(buf));\n-  outputStream* out = &ss;\n-\/\/  outputStream* out = tty; \/\/ enable for printout\n-\n-  \/\/ Test dumping unreadable memory\n-  \/\/ Exclude test for Windows for now, since it needs SEH handling to work which cannot be\n-  \/\/ guaranteed when we call directly into VM code. (see JDK-8220220)\n-#ifndef _WIN32\n-  do_test_print_hex_dump(unreadable, 100, 1, pattern_not_readable[0]);\n-  do_test_print_hex_dump(unreadable, 100, 2, pattern_not_readable[1]);\n-  do_test_print_hex_dump(unreadable, 100, 4, pattern_not_readable[2]);\n-  do_test_print_hex_dump(unreadable, 100, 8, pattern_not_readable[3]);\n+#define PAT_4 ADDRESS1 \":   ???????? ???????? ???????? ???????? ???????? ???????? ???????? ????????\\n\" \\\n+              ADDRESS2 \":   ffffe0dc 23006a64 6b2f696e 7465726e 616c2f6c 6f616465 722f4e61 74697665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c696272 61726965 73000000 00000000                                       \" ASCII_2 \"\\n\"\n+\n+#define PAT_8 ADDRESS1 \":   ???????????????? ???????????????? ???????????????? ????????????????\\n\" \\\n+              ADDRESS2 \":   ffffe0dc23006a64 6b2f696e7465726e 616c2f6c6f616465 722f4e6174697665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c69627261726965 7300000000000000                                     \" ASCII_2 \"\\n\"\n@@ -227,5 +224,18 @@\n-  \/\/ Test dumping readable memory\n-  address arr = (address)os::malloc(100, mtInternal);\n-  for (u1 c = 0; c < 100; c++) {\n-    arr[c] = c;\n-  }\n+  constexpr uint8_t bytes[] = {\n+    0xff, 0xff, 0xe0, 0xdc, 0x23, 0x00, 0x6a, 0x64, 0x6b, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e,\n+    0x61, 0x6c, 0x2f, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x72, 0x2f, 0x4e, 0x61, 0x74, 0x69, 0x76, 0x65,\n+    0x4c, 0x69, 0x62, 0x72, 0x61, 0x72, 0x69, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+  };\n+\n+  \/\/ two pages, first one protected.\n+  const size_t ps = os::vm_page_size();\n+  char* two_pages = os::reserve_memory(ps * 2, false, mtTest);\n+  os::commit_memory(two_pages, ps * 2, false);\n+  os::protect_memory(two_pages, ps, os::MEM_PROT_NONE, true);\n+\n+  memcpy(two_pages + ps, bytes, sizeof(bytes));\n+\n+  \/\/ print\n+  const uint8_t* const from = (const uint8_t*) two_pages + ps - 32;\n+  const uint8_t* const to = (const uint8_t*) from + 32 + sizeof(bytes);\n+  const uint8_t* const logical_start = (const uint8_t*) LP64_ONLY(0xAAAAAAAAAA00ULL) NOT_LP64(0xAAAAAA00ULL);\n@@ -233,5 +243,4 @@\n-  \/\/ properly aligned\n-  do_test_print_hex_dump(arr, 100, 1, pattern[0]);\n-  do_test_print_hex_dump(arr, 100, 2, pattern[1]);\n-  do_test_print_hex_dump(arr, 100, 4, pattern[2]);\n-  do_test_print_hex_dump(arr, 100, 8, pattern[3]);\n+  do_test_print_hex_dump(from, to, 1, 32, logical_start, PAT_1);\n+  do_test_print_hex_dump(from, to, 2, 32, logical_start, PAT_2);\n+  do_test_print_hex_dump(from, to, 4, 32, logical_start, PAT_4);\n+  do_test_print_hex_dump(from, to, 8, 32, logical_start, PAT_8);\n@@ -239,4 +248,4 @@\n-  \/\/ Not properly aligned. Should automatically down-align by unitsize\n-  do_test_print_hex_dump(arr + 1, 100, 2, pattern[1]);\n-  do_test_print_hex_dump(arr + 1, 100, 4, pattern[2]);\n-  do_test_print_hex_dump(arr + 1, 100, 8, pattern[3]);\n+  \/\/ unaligned printing, should align to next lower unitsize\n+  do_test_print_hex_dump(from + 1, to, 2, 32, logical_start, PAT_2);\n+  do_test_print_hex_dump(from + 1, to, 4, 32, logical_start, PAT_4);\n+  do_test_print_hex_dump(from + 1, to, 8, 32, logical_start, PAT_8);\n@@ -244,1 +253,1 @@\n-  os::free(arr);\n+  os::release_memory(two_pages, ps * 2);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":68,"deletions":59,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                            (address)(align_up(end, 0x10) + 0x10), 1);\n+                            (address)(align_up(end, 0x10) + 0x10), 1, true);\n","filename":"test\/hotspot\/gtest\/testutils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}