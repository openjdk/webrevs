{"files":[{"patch":"@@ -175,2 +175,1 @@\n-  \/\/ Return the first marked address in the range [addr, limit), or limit\n-  \/\/ if none found.\n+  \/\/ Return the first marked address in the range [addr, limit), or limit if none found.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-                                                    HeapWord* tams, const size_t last_relevant_card_index) const {\n+                                                    HeapWord* tams, HeapWord* end_range_of_interest) const {\n@@ -250,0 +250,9 @@\n+  HeapWord* right = MIN2(region->top(), end_range_of_interest);\n+  HeapWord* end_of_search_next = MIN2(right, tams);\n+  size_t last_relevant_card_index = _rs->card_index_for_addr(end_range_of_interest);\n+  if (_rs->addr_for_card_index(last_relevant_card_index) == end_range_of_interest) {\n+    last_relevant_card_index--;\n+  }\n+  assert(card_index <= last_relevant_card_index, \"sanity: card_index: %zu, last_relevant: %zu, left: \" PTR_FORMAT\n+         \", end_of_range: \" PTR_FORMAT, card_index, last_relevant_card_index, p2i(left), p2i(end_range_of_interest));\n+\n@@ -265,2 +274,2 @@\n-      HeapWord* prev = ctx->get_prev_marked_addr(region->bottom(), left);\n-      if (prev <= left) {\n+      HeapWord* prev = ctx->get_prev_marked_addr(region->bottom(), left - 1);\n+      if (prev < left) {\n@@ -278,1 +287,0 @@\n-    HeapWord* right = MIN3(region->top(), tams, _rs->addr_for_card_index(last_relevant_card_index + 1));\n@@ -280,2 +288,2 @@\n-    HeapWord* next = ctx->get_next_marked_addr(left, right);\n-#ifdef ASSERT\n+    HeapWord* next = ctx->get_next_marked_addr(left, end_of_search_next);\n+    \/\/ If end_of_search_next < right, we may return tams here, which is \"marked\" by default\n@@ -289,1 +297,0 @@\n-#endif\n@@ -325,0 +332,1 @@\n+      assert(p < right, \"Result must precede right\");\n@@ -330,0 +338,1 @@\n+        assert(left + get_first_start(card_index) < right, \"Result must precede right\");\n@@ -340,0 +349,2 @@\n+        assert(_rs->addr_for_card_index(following_card_index) + get_first_start(following_card_index),\n+               \"Result must precede right\");\n@@ -380,2 +391,2 @@\n-  guarantee(p <= left, \"p should start at or before left end of card\");\n-  guarantee(p + obj->size() > left, \"obj should end after left end of card\");\n+  assert(p <= left, \"p should start at or before left end of card\");\n+  assert(p + obj->size() > left, \"obj should end after left end of card\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -667,4 +667,3 @@\n-  \/\/ The last_relevant_card_index represents an upper bound on how far we look in the forward direction\n-  \/\/ for the first object in the heap that intersects or follows this card.  If there are no live objects\n-  \/\/ found within the range of cards identified by [card_index, last_relevant_card_index], this function\n-  \/\/ returns nullptr.\n+  \/\/ The end_range_of_interest pointer argument represents an upper bound on how far we look in the forward direction\n+  \/\/ for the first object in the heap that intersects or follows this card.  If there are no live objects found at\n+  \/\/ an address less than end_range_of_interest returns nullptr.\n@@ -680,1 +679,1 @@\n-                               HeapWord* tams, const size_t last_relevant_card_index) const;\n+                               HeapWord* tams, HeapWord* end_range_of_interest) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-                                                               ClosureType* cl, bool use_write_table, uint worker_id) {\n+                                                ClosureType* cl, bool use_write_table, uint worker_id) {\n@@ -70,0 +70,5 @@\n+#undef KELVIN_SCRUTINY\n+#ifdef KELVIN_SCRUTINY\n+  log_info(gc)(\"end_addr (%zx) is MIN2(%zx, %zx)\", p2i(end_addr), p2i(end_of_range),\n+               p2i((HeapWord*)start_addr + (count * ShenandoahCardCluster::CardsPerCluster * CardTable::card_size_in_words())));\n+#endif\n@@ -73,0 +78,4 @@\n+#ifdef KELVIN_SCRUTINY\n+  log_info(gc)(\"whole_cards: %zu span %zu words out of needed span %zu words\",\n+               whole_cards, whole_cards * CardTable::card_size_in_words(), end_addr - start_addr);\n+#endif\n@@ -74,0 +83,3 @@\n+#ifdef KELVIN_SCRUTINY\n+  log_info(gc)(\"end_card_index: %zu, next_card_addr: %zx\", end_card_index, p2i(_rs->addr_for_card_index(end_card_index + 1)));\n+#endif\n@@ -177,2 +189,4 @@\n-      HeapWord* p = _scc->first_object_start(dirty_l, ctx, tams, dirty_r);\n-      assert((p == nullptr) || (p < right), \"No first object found is denoted by nullptr\");\n+      HeapWord* p = _scc->first_object_start(dirty_l, ctx, tams, right);\n+      assert((p == nullptr) || (p < right), \"No first object found is denoted by nullptr, p: \"\n+             PTR_FORMAT \", right: \" PTR_FORMAT \", end_addr: \" PTR_FORMAT \", next card addr: \" PTR_FORMAT,\n+             p2i(p), p2i(right), p2i(end_addr), p2i(_rs->addr_for_card_index(dirty_r + 1)));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"}]}