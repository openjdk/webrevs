{"files":[{"patch":"@@ -60,0 +60,20 @@\n+HeapWord* ShenandoahMarkBitMap::get_prev_marked_addr(const HeapWord* limit,\n+                                                     const HeapWord* addr) const {\n+#ifdef ASSERT\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahHeapRegion* r = heap->heap_region_containing(addr);\n+  ShenandoahMarkingContext* ctx = heap->marking_context();\n+  HeapWord* tams = ctx->top_at_mark_start(r);\n+  assert(limit != nullptr, \"limit must not be null\");\n+  assert(limit >= r->bottom(), \"limit must be more than bottom\");\n+  assert(addr <= tams, \"addr must be less than TAMS\");\n+#endif\n+\n+  \/\/ Round addr down to a possible object boundary to be safe.\n+  size_t const addr_offset = address_to_index(align_down(addr, HeapWordSize << LogMinObjAlignment));\n+  size_t const limit_offset = address_to_index(limit);\n+  size_t const last_offset = get_prev_one_offset(limit_offset, addr_offset);\n+\n+  \/\/ cast required to remove const-ness of the value pointed to.  We won't modify that object, but my caller might.\n+  return (last_offset > addr_offset)? (HeapWord*) addr + 1: index_to_address(last_offset);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -122,1 +122,8 @@\n-  inline idx_t get_next_one_offset (idx_t l_index, idx_t r_index) const;\n+  \/\/ Helper for get_prev_{zero,one}_bit variants.\n+  \/\/ - flip designates whether searching for 1s or 0s.  Must be one of\n+  \/\/   find_{zeros,ones}_flip.\n+  \/\/ - aligned_left is true if l_index is a priori on a bm_word_t boundary.\n+  template<bm_word_t flip, bool aligned_left>\n+  inline idx_t get_prev_bit_impl(idx_t l_index, idx_t r_index) const;\n+\n+  inline idx_t get_next_one_offset(idx_t l_index, idx_t r_index) const;\n@@ -124,1 +131,4 @@\n-  void clear_large_range (idx_t beg, idx_t end);\n+  \/\/ Search for last one in the range [l_index, r_index).  Return r_index if not found.\n+  inline idx_t get_prev_one_offset(idx_t l_index, idx_t r_index) const;\n+\n+  void clear_large_range(idx_t beg, idx_t end);\n@@ -165,3 +175,2 @@\n-  \/\/ Return the address corresponding to the next marked bit at or after\n-  \/\/ \"addr\", and before \"limit\", if \"limit\" is non-null.  If there is no\n-  \/\/ such bit, returns \"limit\" if that is non-null, or else \"endWord()\".\n+  \/\/ Return the first marked address in the range [addr, limit), or limit\n+  \/\/ if none found.\n@@ -171,0 +180,4 @@\n+  \/\/ Return the last marked address in the range [limit, addr], or addr+1 if none found.\n+  HeapWord* get_prev_marked_addr(const HeapWord* limit,\n+                                 const HeapWord* addr) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/count_leading_zeros.hpp\"\n@@ -172,0 +173,85 @@\n+template<ShenandoahMarkBitMap::bm_word_t flip, bool aligned_left>\n+inline ShenandoahMarkBitMap::idx_t ShenandoahMarkBitMap::get_prev_bit_impl(idx_t l_index, idx_t r_index) const {\n+  STATIC_ASSERT(flip == find_ones_flip || flip == find_zeros_flip);\n+  verify_range(l_index, r_index);\n+  assert(!aligned_left || is_aligned(l_index, BitsPerWord), \"l_index not aligned\");\n+\n+  \/\/ The first word often contains an interesting bit, either due to\n+  \/\/ density or because of features of the calling algorithm.  So it's\n+  \/\/ important to examine that first word with a minimum of fuss,\n+  \/\/ minimizing setup time for later words that will be wasted if the\n+  \/\/ first word is indeed interesting.\n+\n+  \/\/ The benefit from aligned_left being true is relatively small.\n+  \/\/ It saves an operation in the setup for the word search loop.\n+  \/\/ It also eliminates the range check on the final result.\n+  \/\/ However, callers often have a comparison with l_index, and\n+  \/\/ inlining often allows the two comparisons to be combined; it is\n+  \/\/ important when !aligned_left that return paths either return\n+  \/\/ l_index or a value dominating a comparison with l_index.\n+  \/\/ aligned_left is still helpful when the caller doesn't have a\n+  \/\/ range check because features of the calling algorithm guarantee\n+  \/\/ an interesting bit will be present.\n+\n+  if (l_index < r_index) {\n+    \/\/ Get the word containing r_index, and shift out the high-order bits (representing objects that come after r_index)\n+    idx_t index = to_words_align_down(r_index);\n+    assert(BitsPerWord - 2 >= bit_in_word(r_index), \"sanity\");\n+    size_t shift = BitsPerWord - 2 - bit_in_word(r_index);\n+    bm_word_t cword = (map(index) ^ flip) << shift;\n+    \/\/ After this shift, the highest order bits correspond to r_index.\n+\n+    \/\/ We give special handling if either of the two most significant bits (Weak or Strong) is set.  With 64-bit\n+    \/\/ words, the mask of interest is 0xc000_0000_0000_0000.  Symbolically, this constant is represented by:\n+    const bm_word_t first_object_mask = ((bm_word_t) 0x3) << (BitsPerWord - 2);\n+    if ((cword & first_object_mask) != 0) {\n+      \/\/ The first object is similarly often interesting. When it matters\n+      \/\/ (density or features of the calling algorithm make it likely\n+      \/\/ the first bit is set), going straight to the next clause compares\n+      \/\/ poorly with doing this check first; count_leading_zeros can be\n+      \/\/ relatively expensive, plus there is the additional range check.\n+      \/\/ But when the first bit isn't set, the cost of having tested for\n+      \/\/ it is relatively small compared to the rest of the search.\n+      return r_index;\n+    } else if (cword != 0) {\n+      \/\/ Note that there are 2 bits corresponding to every index value (Weak and Strong), and every odd index value\n+      \/\/  corresponds to the same object as index-1\n+      \/\/ Flipped and shifted first word is non-zero.  If leading_zeros is 0 or 1, we return r_index (above).\n+      \/\/ if leading zeros is 2 or 3, we return (r_index - 1) or (r_index - 2), and so forth\n+      idx_t result = r_index + 1 - count_leading_zeros(cword);\n+      if (aligned_left || (result >= l_index)) return result;\n+      else {\n+        \/\/ Sentinel value means no object found within specified range.\n+        return r_index + 2;\n+      }\n+    } else {\n+      \/\/ Flipped and shifted first word is zero.  Word search through\n+      \/\/ aligned up r_index for a non-zero flipped word.\n+      idx_t limit = aligned_left\n+                    ? to_words_align_down(l_index) \/\/ Minuscule savings when aligned.\n+                    : to_words_align_up(l_index);\n+      \/\/ Unsigned index is always >= unsigned limit if limit equals zero, so test for strictly greater than before decrement.\n+      while (index-- > limit) {\n+        cword = map(index) ^ flip;\n+        if (cword != 0) {\n+          \/\/ cword hods bits:\n+          \/\/    0x03 for the object corresponding to index (and index+1)       (count_leading_zeros is 62 or 63)\n+          \/\/    0x0c for the object corresponding to index + 2 (and index+3)   (count_leading_zeros is 60 or 61)\n+          \/\/    and so on.\n+          idx_t result = bit_index(index + 1) - (count_leading_zeros(cword) + 1);\n+          if (aligned_left || (result >= l_index)) return result;\n+          else {\n+            \/\/ Sentinel value means no object found within specified range.\n+            return r_index + 2;\n+          }\n+        }\n+      }\n+      \/\/ No bits in range; return r_index+2.\n+      return r_index + 2;\n+    }\n+  }\n+  else {\n+    return r_index + 2;\n+  }\n+}\n+\n@@ -176,0 +262,4 @@\n+inline ShenandoahMarkBitMap::idx_t ShenandoahMarkBitMap::get_prev_one_offset(idx_t l_offset, idx_t r_offset) const {\n+  return get_prev_bit_impl<find_ones_flip, false>(l_offset, r_offset);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.inline.hpp","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+  \/\/ Return address of the first marked address in the range [addr,limit), or limit if no marked object found\n@@ -72,0 +73,3 @@\n+  \/\/ Return address of the last marked object in range [limit, start], returning start+1 if no marked object found\n+  inline HeapWord* get_prev_marked_addr(const HeapWord* limit, const HeapWord* start) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+inline HeapWord* ShenandoahMarkingContext::get_prev_marked_addr(const HeapWord* limit, const HeapWord* start) const {\n+  return _mark_bit_map.get_prev_marked_addr(limit, start);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,3 +140,2 @@\n-  assert(((((unsigned long long) from) & (CardTable::card_size() - 1)) == 0) &&\n-         ((((unsigned long long) to) & (CardTable::card_size() - 1)) == 0),\n-         \"reset_object_range bounds must align with card boundaries\");\n+  assert(CardTable::is_card_aligned(from) && CardTable::is_card_aligned(to),\n+         \"Must align with card boundaries\");\n@@ -237,5 +236,2 @@\n-\/\/ Given a card_index, return the starting address of the first block in the heap\n-\/\/ that straddles into this card. If this card is co-initial with an object, then\n-\/\/ this would return the first address of the range that this card covers, which is\n-\/\/ where the card's first object also begins.\n-HeapWord* ShenandoahCardCluster::block_start(const size_t card_index) const {\n+HeapWord* ShenandoahCardCluster::first_object_start(const size_t card_index, const ShenandoahMarkingContext* const ctx,\n+                                                    HeapWord* tams, const size_t last_relevant_card_index) const {\n@@ -244,0 +240,1 @@\n+  ShenandoahHeapRegion* region = ShenandoahHeap::heap()->heap_region_containing(left);\n@@ -247,1 +244,0 @@\n-  ShenandoahHeapRegion* region = ShenandoahHeap::heap()->heap_region_containing(left);\n@@ -253,0 +249,48 @@\n+\n+  \/\/ if marking context is valid and we are below tams, we use the marking bit map to find the first marked object that\n+  \/\/ intersects with this card.  If no such object exists, we return the first marked object that follows the start\n+  \/\/ of this card's memory range if such an object is found at or before last_relevant_card_index.  If there are no\n+  \/\/ marked objects in this range, we return nullptr.\n+  if ((ctx != nullptr) && (left < tams)) {\n+    if (ctx->is_marked(left)) {\n+      oop obj = cast_to_oop(left);\n+      assert(oopDesc::is_oop(obj), \"Should be an object\");\n+      return left;\n+    }\n+    \/\/ get the previous marked object, if any\n+    if (region->bottom() < left) {\n+      \/\/ In the case that this region was most recently marked as young, the fact that this region has been promoted in place\n+      \/\/ denotes that final mark (Young) has completed.  In the case that this region was most recently marked as old, the\n+      \/\/ fact that (ctx != nullptr) denotes that old marking has completed.  Otherwise, ctx would equal null.\n+      HeapWord* prev = ctx->get_prev_marked_addr(region->bottom(), left);\n+      if (prev <= left) {\n+        oop obj = cast_to_oop(prev);\n+        assert(oopDesc::is_oop(obj), \"Should be an object\");\n+        HeapWord* obj_end = prev + obj->size();\n+        if (obj_end > left) {\n+          return prev;\n+        }\n+      }\n+    }\n+    \/\/ Either prev >= left (no previous object found), or the previous object that was found ends before my card range begins.\n+    \/\/ In eiher case, find the next marked object if any on this or a following card\n+    assert(!ctx->is_marked(left), \"Was dealt with above\");\n+    HeapWord* right = MIN3(region->top(), tams, _rs->addr_for_card_index(last_relevant_card_index + 1));\n+    assert(right > left, \"We don't expect to be examining cards above the smaller of TAMS or top\");\n+    HeapWord* next = ctx->get_next_marked_addr(left, right);\n+#ifdef ASSERT\n+    if (next < right) {\n+      oop obj = cast_to_oop(next);\n+      assert(oopDesc::is_oop(obj), \"Should be an object\");\n+      return next;\n+    } else {\n+      return nullptr;\n+    }\n+#endif\n+  }\n+\n+  assert((ctx == nullptr) || (left >= tams), \"Should have returned above\");\n+\n+  \/\/ The following code assumes that all data in region at or above left holds parsable objects\n+  assert((left >= tams) || ShenandoahGenerationalHeap::heap()->old_generation()->is_parsable(),\n+         \"The code that follows expects a parsable heap\");\n@@ -254,2 +298,1 @@\n-    \/\/ This card contains a co-initial object; a fortiori, it covers\n-    \/\/ also the case of a card being the first in a region.\n+    \/\/ This card contains a co-initial object; a fortiori, it covers also the case of a card being the first in a region.\n@@ -260,2 +303,0 @@\n-  HeapWord* p = nullptr;\n-  oop obj = cast_to_oop(p);\n@@ -271,1 +312,1 @@\n-  assert(cur_index >= 0 && (cur_index <= (ssize_t)card_index), \"Error\");\n+  assert(cur_index >= 0 && (cur_index <= (ssize_t) card_index), \"Error\");\n@@ -277,1 +318,27 @@\n-  p = _rs->addr_for_card_index(cur_index) + offset;\n+  HeapWord* p = _rs->addr_for_card_index(cur_index) + offset;\n+  if ((ctx != nullptr) && (p < tams)) {\n+    if (ctx->is_marked(p)) {\n+      oop obj = cast_to_oop(p);\n+      assert(oopDesc::is_oop(obj), \"Should be an object\");\n+      assert(Klass::is_valid(obj->klass()), \"Not a valid klass ptr\");\n+      assert(p + obj->size() > left, \"This object should span start of card\");\n+      return p;\n+    } else {\n+      \/\/ Object that spans start of card is dead, so should not be scanned\n+      assert((ctx == nullptr) || (left + get_first_start(card_index) >= tams), \"Should have handled this case above\");\n+      if (starts_object(card_index)) {\n+        return left + get_first_start(card_index);\n+      } else {\n+        \/\/ Spanning object is dead and this card does not start an object, so the start object is in some card that follows\n+        size_t following_card_index = card_index;\n+        do {\n+          following_card_index++;\n+          if (following_card_index > last_relevant_card_index) {\n+            return nullptr;\n+          }\n+        } while (!starts_object(following_card_index));\n+        return _rs->addr_for_card_index(following_card_index) + get_first_start(following_card_index);\n+      }\n+    }\n+  }\n+\n@@ -282,1 +349,2 @@\n-  \/\/ 1. we ask this question only for regions in the old generation\n+  \/\/ 1. we ask this question only for regions in the old generation, and those\n+  \/\/    that are not humongous regions\n@@ -284,2 +352,2 @@\n-  \/\/    regions. Only GC will ever allocate in old regions, and then\n-  \/\/    too only during promotion\/evacuation phases. Thus there is no danger\n+  \/\/    regions walked by this code. Only GC will ever allocate in old regions,\n+  \/\/    and then too only during promotion\/evacuation phases. Thus there is no danger\n@@ -288,0 +356,2 @@\n+  \/\/    Furthermore, humongous regions (and their dirty cards) are never processed\n+  \/\/    by this code.\n@@ -292,1 +362,1 @@\n-  \/\/    during old or global collections.\n+  \/\/    during global collections during marking or update refs..\n@@ -294,1 +364,1 @@\n-  NOT_PRODUCT(obj = cast_to_oop(p);)\n+  oop obj = cast_to_oop(p);\n@@ -296,0 +366,3 @@\n+#ifdef ASSERT\n+#define WALK_FORWARD_IN_BLOCK_START true\n+#else\n@@ -297,0 +370,1 @@\n+#endif \/\/ ASSERT\n@@ -299,0 +373,5 @@\n+    obj = cast_to_oop(p);\n+    assert(oopDesc::is_oop(obj), \"Should be an object\");\n+    assert(Klass::is_valid(obj->klass()), \"Not a valid klass ptr\");\n+    \/\/ Check assumptions in previous block comment if this assert fires\n+    guarantee(false, \"Should never need forward walk in block start\");\n@@ -300,2 +379,3 @@\n-#undef WALK_FORWARD_IN_BLOCK_START \/\/ false\n-  assert(p + obj->size() > left, \"obj should end after left\");\n+#undef WALK_FORWARD_IN_BLOCK_START\n+  guarantee(p <= left, \"p should start at or before left end of card\");\n+  guarantee(p + obj->size() > left, \"obj should end after left end of card\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":102,"deletions":22,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -655,6 +655,26 @@\n-  \/\/ Given a card_index, return the starting address of the first block in the heap\n-  \/\/ that straddles into the card. If the card is co-initial with an object, then\n-  \/\/ this would return the starting address of the heap that this card covers.\n-  \/\/ Expects to be called for a card affiliated with the old generation in\n-  \/\/ generational mode.\n-  HeapWord* block_start(size_t card_index) const;\n+  \/\/ Given a card_index, return the starting address of the first live object in the heap\n+  \/\/ that intersects with or follows this card. This must be a valid, parsable object, and must\n+  \/\/ be the first such object that intersects with this card. The object may start before,\n+  \/\/ at, or after the start of the card identified by card_index, and may end in or after the card.\n+  \/\/\n+  \/\/ The tams argument represents top for the enclosing region at the start of the most recently\n+  \/\/ initiated concurrent old marking effort.  If ctx is non-null, we use the marking context to identify\n+  \/\/ marked objects below tams.  Above tams, we know that every object is marked and that the memory is\n+  \/\/ parsable (so we can add an object's size to its address to find the next object).  If ctx is null,\n+  \/\/ we use crossing maps to find where object's start, and use object sizes to walk individual objects.\n+  \/\/ The region must be parsable if ctx is null.\n+  \/\/\n+  \/\/ The last_relevant_card_index represents an upper bound on how far we look in the forward direction\n+  \/\/ for the first object in the heap that intersects or follows this card.  If there are no live objects\n+  \/\/ found within the range of cards identified by [card_index, last_relevant_card_index], this function\n+  \/\/ returns nullptr.\n+  \/\/\n+  \/\/ Expects to be called for a card in a region affiliated with the old generation of the\n+  \/\/ generational heap, otherwise behavior is undefined.\n+  \/\/\n+  \/\/ If not null, ctx holds the complete marking context of the old generation. If null,\n+  \/\/ we expect that the marking context isn't available and the crossing maps are valid.\n+  \/\/ Note that crossing maps may be invalid following class unloading and before dead\n+  \/\/ or unloaded objects have been coalesced and filled.  Coalesce and fill updates the crossing maps.\n+  HeapWord* first_object_start(size_t card_index, const ShenandoahMarkingContext* const ctx,\n+                               HeapWord* tams, const size_t last_relevant_card_index) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  const HeapWord* tams = (ctx == nullptr ? region->bottom() : ctx->top_at_mark_start(region));\n+  HeapWord* const tams = (ctx == nullptr ? region->bottom() : ctx->top_at_mark_start(region));\n@@ -170,5 +170,5 @@\n-      \/\/ NOTE: We'll not call block_start() repeatedly\n-      \/\/ on a very large object if its head card is dirty. If not,\n-      \/\/ (i.e. the head card is clean) we'll call it each time we\n-      \/\/ process a new dirty range on the object. This is always\n-      \/\/ the case for large object arrays, which are typically more\n+      \/\/ NOTE: We'll not call first_object_start() repeatedly\n+      \/\/ on a very large object, i.e. one spanning multiple cards,\n+      \/\/ if its head card is dirty. If not, (i.e. its head card is clean)\n+      \/\/ we'll call it each time we process a new dirty range on the object.\n+      \/\/ This is always the case for large object arrays, which are typically more\n@@ -176,1 +176,10 @@\n-      HeapWord* p = _scc->block_start(dirty_l);\n+      assert(ctx != nullptr || heap->old_generation()->is_parsable(), \"Error\");\n+      HeapWord* p = _scc->first_object_start(dirty_l, ctx, tams, dirty_r);\n+      assert((p == nullptr) || (p < right), \"No first object found is denoted by nullptr\");\n+      if (p == nullptr) {\n+        \/\/ There are no live objects to be scanned in this dirty range.  cur_index identifies first card in this\n+        \/\/ uninteresting dirty range.  At top of next loop iteration, we will either end the looop\n+        \/\/ (because cur_index < start_card_index) or we will begin the search for a range of clean cards.\n+        continue;\n+      }\n+\n@@ -178,0 +187,3 @@\n+      assert(oopDesc::is_oop(obj), \"Not an object at \" PTR_FORMAT \", left: \" PTR_FORMAT \", right: \" PTR_FORMAT,\n+             p2i(p), p2i(left), p2i(right));\n+      assert(ctx==nullptr || ctx->is_marked(obj), \"Error\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,571 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkBitMap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkBitMap.inline.hpp\"\n+\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n+#include <iostream>\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n+\n+#include \"memory\/memRegion.hpp\"\n+#include \"unittest.hpp\"\n+\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/vmassert_reinstall.hpp\"\n+#include \"utilities\/vmassert_uninstall.hpp\"\n+\n+\/\/ These tests will all be skipped (unless Shenandoah becomes the default\n+\/\/ collector). To execute these tests, you must enable Shenandoah, which\n+\/\/ is done with:\n+\/\/\n+\/\/ % make exploded-test TEST=\"gtest:ShenandoahOld*\" CONF=release TEST_OPTS=\"JAVA_OPTIONS=-XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational\"\n+\/\/\n+\/\/ Please note that these 'unit' tests are really integration tests and rely\n+\/\/ on the JVM being initialized. These tests manipulate the state of the\n+\/\/ collector in ways that are not compatible with a normal collection run.\n+\/\/ If these tests take longer than the minimum time between gc intervals -\n+\/\/ or, more likely, if you have them paused in a debugger longer than this\n+\/\/ interval - you can expect trouble. These tests will also not run in a build\n+\/\/ with asserts enabled because they use APIs that expect to run on a safepoint.\n+\n+#ifdef ASSERT\n+#define SKIP_IF_NOT_SHENANDOAH()           \\\n+  std::cout << \"skipped (debug build)\\n\";  \\\n+  return;\n+#else\n+#define SKIP_IF_NOT_SHENANDOAH() \\\n+    if (!UseShenandoahGC) {      \\\n+      std::cout << \"skipped\\n\";  \\\n+      return;                    \\\n+    }\n+#endif\n+\n+static bool _success;\n+static size_t _assertion_failures;\n+\n+#define MarkBitMapAssertEqual(a, b)  EXPECT_EQ((a), (b));   if ((a) != (b)) { _assertion_failures++; }\n+#define MarkBitMapAssertTrue(a)      EXPECT_TRUE((a));      if ((a) == 0)   { _assertion_failures++; }\n+\n+\n+class ShenandoahMarkBitMapTest: public ::testing::Test {\n+protected:\n+\n+  static void verify_bitmap_is_empty(HeapWord *start, size_t words_in_heap, ShenandoahMarkBitMap* mbm) {\n+    MarkBitMapAssertTrue(mbm->is_bitmap_clear_range(start, start + words_in_heap));\n+    while (words_in_heap-- > 0) {\n+      MarkBitMapAssertTrue(!mbm->is_marked(start));\n+      MarkBitMapAssertTrue(!mbm->is_marked_weak(start));\n+      MarkBitMapAssertTrue(!mbm->is_marked_strong(start));\n+      start++;\n+    }\n+  }\n+\n+  static void verify_bitmap_is_weakly_marked(ShenandoahMarkBitMap* mbm,\n+                                             HeapWord* weakly_marked_addresses[], size_t weakly_marked_objects) {\n+    for (size_t i = 0; i < weakly_marked_objects; i++) {\n+      HeapWord* obj_addr = weakly_marked_addresses[i];\n+      MarkBitMapAssertTrue(mbm->is_marked(obj_addr));\n+      MarkBitMapAssertTrue(mbm->is_marked_weak(obj_addr));\n+    }\n+  }\n+\n+  static void verify_bitmap_is_strongly_marked(ShenandoahMarkBitMap* mbm,\n+                                               HeapWord* strongly_marked_addresses[], size_t strongly_marked_objects) {\n+    for (size_t i = 0; i < strongly_marked_objects; i++) {\n+      HeapWord* obj_addr = strongly_marked_addresses[i];\n+      MarkBitMapAssertTrue(mbm->is_marked(obj_addr));\n+      MarkBitMapAssertTrue(mbm->is_marked_strong(obj_addr));\n+    }\n+  }\n+\n+  static void verify_bitmap_all(ShenandoahMarkBitMap* mbm, HeapWord* all_marked_addresses[],\n+                                bool is_weakly_marked_object[], bool is_strongly_marked_object[], size_t  all_marked_objects,\n+                                HeapWord* heap_memory, HeapWord* end_of_heap_memory) {\n+    HeapWord* last_marked_addr = &heap_memory[-1];\n+    for (size_t i = 0; i < all_marked_objects; i++) {\n+      HeapWord* obj_addr = all_marked_addresses[i];\n+      if (is_strongly_marked_object[i]) {\n+        MarkBitMapAssertTrue(mbm->is_marked(obj_addr));\n+        MarkBitMapAssertTrue(mbm->is_marked_strong(obj_addr));\n+      }\n+      if (is_weakly_marked_object[i]) {\n+        MarkBitMapAssertTrue(mbm->is_marked(obj_addr));\n+        MarkBitMapAssertTrue(mbm->is_marked_weak(obj_addr));\n+      }\n+      while (++last_marked_addr < obj_addr) {\n+        MarkBitMapAssertTrue(!mbm->is_marked(last_marked_addr));\n+        MarkBitMapAssertTrue(!mbm->is_marked_strong(last_marked_addr));\n+        MarkBitMapAssertTrue(!mbm->is_marked_weak(last_marked_addr));\n+      }\n+      last_marked_addr = obj_addr;\n+    }\n+    while (++last_marked_addr < end_of_heap_memory) {\n+      MarkBitMapAssertTrue(!mbm->is_marked(last_marked_addr));\n+      MarkBitMapAssertTrue(!mbm->is_marked_strong(last_marked_addr));\n+      MarkBitMapAssertTrue(!mbm->is_marked_weak(last_marked_addr));\n+    }\n+\n+    HeapWord* next_marked = (HeapWord*) &heap_memory[0] - 1;\n+    for (size_t i = 0; i < all_marked_objects; i++) {\n+      next_marked = mbm->get_next_marked_addr(next_marked + 1, end_of_heap_memory);\n+      MarkBitMapAssertTrue(mbm->is_marked(next_marked));\n+      MarkBitMapAssertEqual(next_marked, all_marked_addresses[i]);\n+      if (is_strongly_marked_object[i]) {\n+        MarkBitMapAssertTrue(mbm->is_marked_strong(next_marked));\n+      }\n+      if (is_weakly_marked_object[i]) {\n+        MarkBitMapAssertTrue(mbm->is_marked_weak(next_marked));\n+      }\n+    }\n+    \/\/ We expect no more marked addresses to be found.  Should return limit.\n+    HeapWord* sentinel = mbm->get_next_marked_addr(next_marked + 1, end_of_heap_memory);\n+    MarkBitMapAssertEqual(sentinel, end_of_heap_memory);\n+\n+    HeapWord* prev_marked = end_of_heap_memory + 1;\n+    for (int i = (int) all_marked_objects - 1; i >= 0; i--) {\n+      prev_marked = mbm->get_prev_marked_addr(&heap_memory[0], prev_marked - 1);\n+      MarkBitMapAssertEqual(prev_marked, all_marked_addresses[i]);\n+      MarkBitMapAssertTrue(mbm->is_marked(prev_marked));\n+      if (is_strongly_marked_object[i]) {\n+        MarkBitMapAssertTrue(mbm->is_marked_strong(prev_marked));\n+      }\n+      if (is_weakly_marked_object[i]) {\n+        MarkBitMapAssertTrue(mbm->is_marked_weak(prev_marked));\n+      }\n+    }\n+    \/\/ We expect no more marked addresses to be found.  should return prev_marked.\n+    sentinel = mbm->get_prev_marked_addr(&heap_memory[0], prev_marked - 1);\n+    MarkBitMapAssertEqual(sentinel, prev_marked);\n+  }\n+\n+public:\n+\n+  static bool run_test() {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    size_t heap_size = heap->max_capacity();\n+    size_t heap_size_words = heap_size \/ HeapWordSize;\n+    HeapWord* my_heap_memory = heap->base();\n+    HeapWord* end_of_my_heap = my_heap_memory + heap_size_words;\n+    MemRegion heap_descriptor(my_heap_memory, heap_size_words);\n+\n+    _success = false;\n+    _assertion_failures = 0;\n+\n+    size_t bitmap_page_size = UseLargePages ? os::large_page_size() : os::vm_page_size();\n+    size_t bitmap_size_orig = ShenandoahMarkBitMap::compute_size(heap_size);\n+    size_t bitmap_size = align_up(bitmap_size_orig, bitmap_page_size);\n+    size_t bitmap_word_size = (bitmap_size + HeapWordSize - 1) \/ HeapWordSize;\n+\n+    HeapWord* my_bitmap_memory = NEW_C_HEAP_ARRAY(HeapWord, bitmap_word_size, mtGC);\n+\n+    MarkBitMapAssertTrue(my_bitmap_memory != nullptr);\n+    if (my_bitmap_memory == nullptr) {\n+      std::cout <<\"Cannot run test because failed to allocate bitmap memory\\n\" << std::flush;\n+      return false;\n+    }\n+    MemRegion bitmap_descriptor(my_bitmap_memory, bitmap_size \/ HeapWordSize);\n+    ShenandoahMarkBitMap mbm(heap_descriptor, bitmap_descriptor);\n+\n+    mbm.clear_range_large(heap_descriptor);\n+    verify_bitmap_is_empty((HeapWord*) my_heap_memory, heap_size_words, &mbm);\n+\n+    HeapWord* weakly_marked_addresses[] = {\n+      (HeapWord*) &my_heap_memory[13],\n+      (HeapWord*) &my_heap_memory[14],\n+      (HeapWord*) &my_heap_memory[15],\n+      (HeapWord*) &my_heap_memory[16],\n+      (HeapWord*) &my_heap_memory[176],\n+      (HeapWord*) &my_heap_memory[240],\n+      (HeapWord*) &my_heap_memory[480],\n+      (HeapWord*) &my_heap_memory[1360],\n+      (HeapWord*) &my_heap_memory[1488],\n+      (HeapWord*) &my_heap_memory[2416],\n+      (HeapWord*) &my_heap_memory[5968],\n+      (HeapWord*) &my_heap_memory[8191],\n+      (HeapWord*) &my_heap_memory[8192],\n+      (HeapWord*) &my_heap_memory[8193]\n+    };\n+    size_t weakly_marked_objects = sizeof(weakly_marked_addresses) \/ sizeof(HeapWord*);\n+    for (size_t i = 0; i < weakly_marked_objects; i++) {\n+      mbm.mark_weak(weakly_marked_addresses[i]);\n+    }\n+    HeapWord* next_marked = (HeapWord*) &my_heap_memory[0] - 1;\n+    for (size_t i = 0; i < weakly_marked_objects; i++) {\n+      next_marked = mbm.get_next_marked_addr(next_marked + 1, end_of_my_heap);\n+      MarkBitMapAssertEqual(next_marked, weakly_marked_addresses[i]);\n+      MarkBitMapAssertTrue(mbm.is_marked(next_marked));\n+      MarkBitMapAssertTrue(mbm.is_marked_weak(next_marked));\n+      MarkBitMapAssertTrue(!mbm.is_marked_strong(next_marked));\n+    }\n+    \/\/ We expect no more marked addresses to be found.  Should return limit.\n+    HeapWord* sentinel = mbm.get_next_marked_addr(next_marked + 1, end_of_my_heap);\n+    HeapWord* heap_limit = end_of_my_heap;\n+    MarkBitMapAssertEqual(sentinel, heap_limit);\n+    HeapWord* prev_marked = end_of_my_heap + 1;;\n+    for (int i = (int) weakly_marked_objects - 1; i >= 0; i--) {\n+      \/\/ to be renamed get_prev_marked_addr()\n+      prev_marked = mbm.get_prev_marked_addr(&my_heap_memory[0], prev_marked - 1);\n+      MarkBitMapAssertEqual(prev_marked, weakly_marked_addresses[i]);\n+      MarkBitMapAssertTrue(mbm.is_marked(prev_marked));\n+      MarkBitMapAssertTrue(mbm.is_marked_weak(prev_marked));\n+      MarkBitMapAssertTrue(!mbm.is_marked_strong(prev_marked));\n+    }\n+    \/\/ We expect no more marked addresses to be found.  should return prev_marked.\n+    sentinel = mbm.get_prev_marked_addr(&my_heap_memory[0], prev_marked - 1);\n+    \/\/ MarkBitMapAssertEqual(sentinel, prev_marked);\n+    MarkBitMapAssertEqual(sentinel, prev_marked);\n+    verify_bitmap_is_weakly_marked(&mbm, weakly_marked_addresses, weakly_marked_objects);\n+\n+    HeapWord* strongly_marked_addresses[] = {\n+      (HeapWord*) &my_heap_memory[8],\n+      (HeapWord*) &my_heap_memory[24],\n+      (HeapWord*) &my_heap_memory[32],\n+      (HeapWord*) &my_heap_memory[56],\n+      (HeapWord*) &my_heap_memory[64],\n+      (HeapWord*) &my_heap_memory[168],\n+      (HeapWord*) &my_heap_memory[232],\n+      (HeapWord*) &my_heap_memory[248],\n+      (HeapWord*) &my_heap_memory[256],\n+      (HeapWord*) &my_heap_memory[257],\n+      (HeapWord*) &my_heap_memory[258],\n+      (HeapWord*) &my_heap_memory[259],\n+      (HeapWord*) &my_heap_memory[488],\n+      (HeapWord*) &my_heap_memory[1352],\n+      (HeapWord*) &my_heap_memory[1496],\n+      (HeapWord*) &my_heap_memory[2432],\n+      (HeapWord*) &my_heap_memory[5960]\n+    };\n+    size_t strongly_marked_objects = sizeof(strongly_marked_addresses) \/ sizeof(HeapWord*);\n+    for (size_t i = 0; i < strongly_marked_objects; i++) {\n+      bool upgraded = false;\n+      mbm.mark_strong(strongly_marked_addresses[i], upgraded);\n+      MarkBitMapAssertTrue(!upgraded);\n+    }\n+    verify_bitmap_is_strongly_marked(&mbm, strongly_marked_addresses, strongly_marked_objects);\n+    HeapWord* upgraded_weakly_marked_addresses[] = {\n+      (HeapWord*) &my_heap_memory[240],\n+      (HeapWord*) &my_heap_memory[1360],\n+    };\n+    size_t upgraded_weakly_marked_objects = sizeof(upgraded_weakly_marked_addresses) \/ sizeof(HeapWord *);\n+    for (size_t i = 0; i < upgraded_weakly_marked_objects; i++) {\n+      bool upgraded = false;\n+      mbm.mark_strong(upgraded_weakly_marked_addresses[i], upgraded);\n+      MarkBitMapAssertTrue(upgraded);\n+    }\n+    verify_bitmap_is_strongly_marked(&mbm, upgraded_weakly_marked_addresses, upgraded_weakly_marked_objects);\n+\n+    HeapWord* all_marked_addresses[] = {\n+      (HeapWord*) &my_heap_memory[8],        \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[13],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[14],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[15],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[16],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[24],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[32],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[56],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[64],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[168],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[176],      \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[232],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[240],      \/* weakly marked upgraded to strongly marked *\/\n+      (HeapWord*) &my_heap_memory[248],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[256],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[257],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[258],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[259],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[480],      \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[488],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[1352],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[1360],     \/* weakly marked upgraded to strongly marked *\/\n+      (HeapWord*) &my_heap_memory[1488],     \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[1496],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[2416],     \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[2432],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[5960],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[5968],     \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[8191],     \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[8192],     \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[8193]      \/* weakly marked *\/\n+    };\n+    size_t all_marked_objects = sizeof(all_marked_addresses) \/ sizeof(HeapWord*);\n+    bool is_weakly_marked_object[] = {\n+      false,\n+      true,\n+      true,\n+      true,\n+      true,\n+      false,\n+      false,\n+      false,\n+      false,\n+      false,\n+      true,\n+      false,\n+      true,\n+      false,\n+      false,\n+      false,\n+      false,\n+      false,\n+      true,\n+      false,\n+      false,\n+      true,\n+      true,\n+      false,\n+      true,\n+      false,\n+      false,\n+      true,\n+      true,\n+      true,\n+      true\n+    };\n+    bool is_strongly_marked_object[] = {\n+      true,\n+      false,\n+      false,\n+      false,\n+      false,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      false,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      false,\n+      true,\n+      true,\n+      true,\n+      false,\n+      true,\n+      false,\n+      true,\n+      true,\n+      false,\n+      false,\n+      false,\n+      false\n+    };\n+    verify_bitmap_all(&mbm, all_marked_addresses, is_weakly_marked_object, is_strongly_marked_object, all_marked_objects,\n+                      my_heap_memory, end_of_my_heap);\n+\n+    MemRegion first_clear_region(&my_heap_memory[168], &my_heap_memory[256]);\n+    mbm.clear_range_large(first_clear_region);\n+    \/\/ Five objects are no longer marked\n+    HeapWord* all_marked_addresses_after_first_clear[] = {\n+      (HeapWord*) &my_heap_memory[8],        \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[13],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[14],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[15],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[16],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[24],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[32],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[56],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[64],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[256],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[257],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[258],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[259],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[480],      \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[488],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[1352],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[1360],     \/* weakly marked upgraded to strongly marked *\/\n+      (HeapWord*) &my_heap_memory[1488],     \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[1496],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[2416],     \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[2432],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[5960],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[5968],     \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[8191],    \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[8192],    \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[8193]     \/* weakly marked *\/\n+    };\n+    size_t all_marked_objects_after_first_clear = sizeof(all_marked_addresses_after_first_clear) \/ sizeof(HeapWord*);\n+    bool is_weakly_marked_object_after_first_clear[] = {\n+      false,\n+      true,\n+      true,\n+      true,\n+      true,\n+      false,\n+      false,\n+      false,\n+      false,\n+      false,\n+      false,\n+      false,\n+      false,\n+      true,\n+      false,\n+      false,\n+      true,\n+      true,\n+      false,\n+      true,\n+      false,\n+      false,\n+      true,\n+      true,\n+      true,\n+      true\n+    };\n+    bool is_strongly_marked_object_after_first_clear[] = {\n+      true,\n+      false,\n+      false,\n+      false,\n+      false,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      false,\n+      true,\n+      true,\n+      true,\n+      false,\n+      true,\n+      false,\n+      true,\n+      true,\n+      false,\n+      false,\n+      false,\n+      false\n+    };\n+    verify_bitmap_all(&mbm, all_marked_addresses_after_first_clear,\n+                      is_weakly_marked_object_after_first_clear, is_strongly_marked_object_after_first_clear,\n+                      all_marked_objects_after_first_clear, my_heap_memory, end_of_my_heap);\n+\n+    MemRegion second_clear_region(&my_heap_memory[1360], &my_heap_memory[2416]);\n+    mbm.clear_range_large(second_clear_region);\n+    \/\/ Five objects are no longer marked\n+    HeapWord* all_marked_addresses_after_2nd_clear[] = {\n+      (HeapWord*) &my_heap_memory[8],        \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[13],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[14],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[15],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[16],       \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[24],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[32],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[56],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[64],       \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[256],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[257],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[258],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[259],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[480],      \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[488],      \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[1352],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[2416],     \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[2432],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[5960],     \/* strongly marked *\/\n+      (HeapWord*) &my_heap_memory[5968],     \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[8191],    \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[8192],    \/* weakly marked *\/\n+      (HeapWord*) &my_heap_memory[8193]     \/* weakly marked *\/\n+    };\n+    size_t all_marked_objects_after_2nd_clear = sizeof(all_marked_addresses_after_2nd_clear) \/ sizeof(HeapWord*);\n+    bool is_weakly_marked_object_after_2nd_clear[] = {\n+      false,\n+      true,\n+      true,\n+      true,\n+      true,\n+      false,\n+      false,\n+      false,\n+      false,\n+      false,\n+      false,\n+      false,\n+      false,\n+      true,\n+      false,\n+      false,\n+      true,\n+      false,\n+      false,\n+      true,\n+      true,\n+      true,\n+      true\n+    };\n+    bool is_strongly_marked_object_after_2nd_clear[] = {\n+      true,\n+      false,\n+      false,\n+      false,\n+      false,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      true,\n+      false,\n+      true,\n+      true,\n+      false,\n+      true,\n+      true,\n+      false,\n+      false,\n+      false,\n+      false\n+    };\n+    verify_bitmap_all(&mbm, all_marked_addresses_after_2nd_clear,\n+                      is_weakly_marked_object_after_2nd_clear, is_strongly_marked_object_after_2nd_clear,\n+                      all_marked_objects_after_2nd_clear, my_heap_memory, end_of_my_heap);\n+\n+    FREE_C_HEAP_ARRAY(HeapWord, my_bitmap_memory);\n+    _success = true;\n+    return true;\n+  }\n+};\n+\n+TEST_VM_F(ShenandoahMarkBitMapTest, minimum_test) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  bool result = ShenandoahMarkBitMapTest::run_test();\n+  ASSERT_EQ(result, true);\n+  ASSERT_EQ(_success, true);\n+  ASSERT_EQ(_assertion_failures, (size_t) 0);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahMarkBitMap.cpp","additions":571,"deletions":0,"binary":false,"changes":571,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-      tty->print_cr(\"skipped\");  \\\n+      std::cout << \"skipped\\n\";  \\\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -360,0 +360,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestClone.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}