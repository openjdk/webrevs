{"files":[{"patch":"@@ -31,0 +31,2 @@\n+import jdk.internal.constant.PrimitiveClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -33,4 +35,0 @@\n-import static java.lang.constant.ConstantUtils.binaryToInternal;\n-import static java.lang.constant.ConstantUtils.dropLastChar;\n-import static java.lang.constant.ConstantUtils.internalToBinary;\n-import static java.lang.constant.ConstantUtils.validateMemberName;\n@@ -39,0 +37,8 @@\n+import static jdk.internal.constant.ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n+import static jdk.internal.constant.ConstantUtils.arrayDepth;\n+import static jdk.internal.constant.ConstantUtils.binaryToInternal;\n+import static jdk.internal.constant.ConstantUtils.dropFirstAndLastChar;\n+import static jdk.internal.constant.ConstantUtils.internalToBinary;\n+import static jdk.internal.constant.ConstantUtils.validateBinaryClassName;\n+import static jdk.internal.constant.ConstantUtils.validateInternalClassName;\n+import static jdk.internal.constant.ConstantUtils.validateMemberName;\n@@ -80,1 +86,1 @@\n-        ConstantUtils.validateBinaryClassName(requireNonNull(name));\n+        validateBinaryClassName(requireNonNull(name));\n@@ -106,1 +112,1 @@\n-        ConstantUtils.validateInternalClassName(requireNonNull(name));\n+        validateInternalClassName(requireNonNull(name));\n@@ -125,1 +131,1 @@\n-        ConstantUtils.validateBinaryClassName(requireNonNull(packageName));\n+        validateBinaryClassName(packageName);\n@@ -165,1 +171,1 @@\n-               : new ReferenceClassDescImpl(descriptor);\n+               : ReferenceClassDescImpl.of(descriptor);\n@@ -178,2 +184,2 @@\n-        int depth = ConstantUtils.arrayDepth(descriptorString());\n-        if (depth >= ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+        int depth = arrayDepth(descriptorString());\n+        if (depth >= MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n@@ -182,1 +188,1 @@\n-                    ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS + \" dimensions\");\n+                    MAX_ARRAY_TYPE_DESC_DIMENSIONS + \" dimensions\");\n@@ -203,0 +209,1 @@\n+        String desc = descriptorString();\n@@ -204,1 +211,1 @@\n-            int currentDepth = ConstantUtils.arrayDepth(descriptorString());\n+            int currentDepth = arrayDepth(desc);\n@@ -206,1 +213,1 @@\n-            if (netRank > ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+            if (netRank > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n@@ -209,1 +216,1 @@\n-                                                   ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n+                                                   MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n@@ -214,1 +221,4 @@\n-        return ClassDesc.ofDescriptor(\"[\".repeat(rank) + descriptorString());\n+        if (desc.length() == 1 && desc.charAt(0) == 'V') {\n+            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %sV\", \"[\".repeat(rank)));\n+        }\n+        return ReferenceClassDescImpl.ofValidated(\"[\".repeat(rank) + descriptorString());\n@@ -238,1 +248,4 @@\n-        return ClassDesc.ofDescriptor(dropLastChar(descriptorString()) + \"$\" + nestedName + \";\");\n+        String desc = descriptorString();\n+        StringBuilder sb = new StringBuilder(desc.length() + nestedName.length() + 1);\n+        sb.append(desc, 0, desc.length() - 1).append('$').append(nestedName).append(';');\n+        return ReferenceClassDescImpl.ofValidated(sb.toString());\n@@ -302,1 +315,9 @@\n-        return isArray() ? ClassDesc.ofDescriptor(descriptorString().substring(1)) : null;\n+        if (isArray()) {\n+            String desc = descriptorString();\n+            if (desc.length() == 2) {\n+                return Wrapper.forBasicType(desc.charAt(1)).classDescriptor();\n+            } else {\n+                return ReferenceClassDescImpl.ofValidated(desc.substring(1));\n+            }\n+        }\n+        return null;\n@@ -315,1 +336,1 @@\n-        String className = internalToBinary(ConstantUtils.dropFirstAndLastChar(descriptorString()));\n+        String className = internalToBinary(dropFirstAndLastChar(descriptorString()));\n@@ -339,1 +360,1 @@\n-            int depth = ConstantUtils.arrayDepth(descriptorString());\n+            int depth = arrayDepth(descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":40,"deletions":19,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.internal.constant.PrimitiveClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n+\n@@ -67,1 +70,1 @@\n-    public static final ClassDesc CD_Object = new ReferenceClassDescImpl(\"Ljava\/lang\/Object;\");\n+    public static final ClassDesc CD_Object = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Object;\");\n@@ -70,1 +73,1 @@\n-    public static final ClassDesc CD_String = new ReferenceClassDescImpl(\"Ljava\/lang\/String;\");\n+    public static final ClassDesc CD_String = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/String;\");\n@@ -73,1 +76,1 @@\n-    public static final ClassDesc CD_Class = new ReferenceClassDescImpl(\"Ljava\/lang\/Class;\");\n+    public static final ClassDesc CD_Class = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Class;\");\n@@ -76,1 +79,1 @@\n-    public static final ClassDesc CD_Number = new ReferenceClassDescImpl(\"Ljava\/lang\/Number;\");\n+    public static final ClassDesc CD_Number = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Number;\");\n@@ -79,1 +82,1 @@\n-    public static final ClassDesc CD_Integer = new ReferenceClassDescImpl(\"Ljava\/lang\/Integer;\");\n+    public static final ClassDesc CD_Integer = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Integer;\");\n@@ -82,1 +85,1 @@\n-    public static final ClassDesc CD_Long = new ReferenceClassDescImpl(\"Ljava\/lang\/Long;\");\n+    public static final ClassDesc CD_Long = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Long;\");\n@@ -85,1 +88,1 @@\n-    public static final ClassDesc CD_Float = new ReferenceClassDescImpl(\"Ljava\/lang\/Float;\");\n+    public static final ClassDesc CD_Float = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Float;\");\n@@ -88,1 +91,1 @@\n-    public static final ClassDesc CD_Double = new ReferenceClassDescImpl(\"Ljava\/lang\/Double;\");\n+    public static final ClassDesc CD_Double = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Double;\");\n@@ -91,1 +94,1 @@\n-    public static final ClassDesc CD_Short = new ReferenceClassDescImpl(\"Ljava\/lang\/Short;\");\n+    public static final ClassDesc CD_Short = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Short;\");\n@@ -94,1 +97,1 @@\n-    public static final ClassDesc CD_Byte = new ReferenceClassDescImpl(\"Ljava\/lang\/Byte;\");\n+    public static final ClassDesc CD_Byte = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Byte;\");\n@@ -97,1 +100,1 @@\n-    public static final ClassDesc CD_Character = new ReferenceClassDescImpl(\"Ljava\/lang\/Character;\");\n+    public static final ClassDesc CD_Character = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Character;\");\n@@ -100,1 +103,1 @@\n-    public static final ClassDesc CD_Boolean = new ReferenceClassDescImpl(\"Ljava\/lang\/Boolean;\");\n+    public static final ClassDesc CD_Boolean = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Boolean;\");\n@@ -103,1 +106,1 @@\n-    public static final ClassDesc CD_Void = new ReferenceClassDescImpl(\"Ljava\/lang\/Void;\");\n+    public static final ClassDesc CD_Void = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Void;\");\n@@ -106,1 +109,1 @@\n-    public static final ClassDesc CD_Throwable = new ReferenceClassDescImpl(\"Ljava\/lang\/Throwable;\");\n+    public static final ClassDesc CD_Throwable = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Throwable;\");\n@@ -109,1 +112,1 @@\n-    public static final ClassDesc CD_Exception = new ReferenceClassDescImpl(\"Ljava\/lang\/Exception;\");\n+    public static final ClassDesc CD_Exception = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Exception;\");\n@@ -112,1 +115,1 @@\n-    public static final ClassDesc CD_Enum = new ReferenceClassDescImpl(\"Ljava\/lang\/Enum;\");\n+    public static final ClassDesc CD_Enum = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Enum;\");\n@@ -115,1 +118,1 @@\n-    public static final ClassDesc CD_VarHandle = new ReferenceClassDescImpl(\"Ljava\/lang\/invoke\/VarHandle;\");\n+    public static final ClassDesc CD_VarHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle;\");\n@@ -118,1 +121,1 @@\n-    public static final ClassDesc CD_MethodHandles = new ReferenceClassDescImpl(\"Ljava\/lang\/invoke\/MethodHandles;\");\n+    public static final ClassDesc CD_MethodHandles = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles;\");\n@@ -121,1 +124,1 @@\n-    public static final ClassDesc CD_MethodHandles_Lookup = new ReferenceClassDescImpl(\"Ljava\/lang\/invoke\/MethodHandles$Lookup;\");\n+    public static final ClassDesc CD_MethodHandles_Lookup = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles$Lookup;\");\n@@ -124,1 +127,1 @@\n-    public static final ClassDesc CD_MethodHandle = new ReferenceClassDescImpl(\"Ljava\/lang\/invoke\/MethodHandle;\");\n+    public static final ClassDesc CD_MethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandle;\");\n@@ -127,1 +130,1 @@\n-    public static final ClassDesc CD_MethodType = new ReferenceClassDescImpl(\"Ljava\/lang\/invoke\/MethodType;\");\n+    public static final ClassDesc CD_MethodType = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodType;\");\n@@ -130,1 +133,1 @@\n-    public static final ClassDesc CD_CallSite = new ReferenceClassDescImpl(\"Ljava\/lang\/invoke\/CallSite;\");\n+    public static final ClassDesc CD_CallSite = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/CallSite;\");\n@@ -133,1 +136,1 @@\n-    public static final ClassDesc CD_Collection = new ReferenceClassDescImpl(\"Ljava\/util\/Collection;\");\n+    public static final ClassDesc CD_Collection = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Collection;\");\n@@ -136,1 +139,1 @@\n-    public static final ClassDesc CD_List = new ReferenceClassDescImpl(\"Ljava\/util\/List;\");\n+    public static final ClassDesc CD_List = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/List;\");\n@@ -139,1 +142,1 @@\n-    public static final ClassDesc CD_Set = new ReferenceClassDescImpl(\"Ljava\/util\/Set;\");\n+    public static final ClassDesc CD_Set = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Set;\");\n@@ -142,1 +145,1 @@\n-    public static final ClassDesc CD_Map = new ReferenceClassDescImpl(\"Ljava\/util\/Map;\");\n+    public static final ClassDesc CD_Map = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Map;\");\n@@ -145,1 +148,1 @@\n-    public static final ClassDesc CD_ConstantDesc = new ReferenceClassDescImpl(\"Ljava\/lang\/constant\/ConstantDesc;\");\n+    public static final ClassDesc CD_ConstantDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ConstantDesc;\");\n@@ -148,1 +151,1 @@\n-    public static final ClassDesc CD_ClassDesc = new ReferenceClassDescImpl(\"Ljava\/lang\/constant\/ClassDesc;\");\n+    public static final ClassDesc CD_ClassDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ClassDesc;\");\n@@ -151,1 +154,1 @@\n-    public static final ClassDesc CD_EnumDesc = new ReferenceClassDescImpl(\"Ljava\/lang\/Enum$EnumDesc;\");\n+    public static final ClassDesc CD_EnumDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Enum$EnumDesc;\");\n@@ -154,1 +157,1 @@\n-    public static final ClassDesc CD_MethodTypeDesc = new ReferenceClassDescImpl(\"Ljava\/lang\/constant\/MethodTypeDesc;\");\n+    public static final ClassDesc CD_MethodTypeDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodTypeDesc;\");\n@@ -157,1 +160,1 @@\n-    public static final ClassDesc CD_MethodHandleDesc = new ReferenceClassDescImpl(\"Ljava\/lang\/constant\/MethodHandleDesc;\");\n+    public static final ClassDesc CD_MethodHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodHandleDesc;\");\n@@ -160,1 +163,1 @@\n-    public static final ClassDesc CD_DirectMethodHandleDesc = new ReferenceClassDescImpl(\"Ljava\/lang\/constant\/DirectMethodHandleDesc;\");\n+    public static final ClassDesc CD_DirectMethodHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc;\");\n@@ -163,1 +166,1 @@\n-    public static final ClassDesc CD_VarHandleDesc = new ReferenceClassDescImpl(\"Ljava\/lang\/invoke\/VarHandle$VarHandleDesc;\");\n+    public static final ClassDesc CD_VarHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle$VarHandleDesc;\");\n@@ -166,1 +169,1 @@\n-    public static final ClassDesc CD_MethodHandleDesc_Kind = new ReferenceClassDescImpl(\"Ljava\/lang\/constant\/DirectMethodHandleDesc$Kind;\");\n+    public static final ClassDesc CD_MethodHandleDesc_Kind = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc$Kind;\");\n@@ -169,1 +172,1 @@\n-    public static final ClassDesc CD_DynamicConstantDesc = new ReferenceClassDescImpl(\"Ljava\/lang\/constant\/DynamicConstantDesc;\");\n+    public static final ClassDesc CD_DynamicConstantDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicConstantDesc;\");\n@@ -172,1 +175,1 @@\n-    public static final ClassDesc CD_DynamicCallSiteDesc = new ReferenceClassDescImpl(\"Ljava\/lang\/constant\/DynamicCallSiteDesc;\");\n+    public static final ClassDesc CD_DynamicCallSiteDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicCallSiteDesc;\");\n@@ -175,1 +178,1 @@\n-    public static final ClassDesc CD_ConstantBootstraps = new ReferenceClassDescImpl(\"Ljava\/lang\/invoke\/ConstantBootstraps;\");\n+    public static final ClassDesc CD_ConstantBootstraps = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/ConstantBootstraps;\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":40,"deletions":37,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1,315 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import sun.invoke.util.Wrapper;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Set;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * Helper methods for the implementation of {@code java.lang.constant}.\n- *\/\n-class ConstantUtils {\n-    \/** an empty constant descriptor *\/\n-    public static final ConstantDesc[] EMPTY_CONSTANTDESC = new ConstantDesc[0];\n-    static final ClassDesc[] EMPTY_CLASSDESC = new ClassDesc[0];\n-    static final Constable[] EMPTY_CONSTABLE = new Constable[0];\n-    static final int MAX_ARRAY_TYPE_DESC_DIMENSIONS = 255;\n-\n-    private static final Set<String> pointyNames = Set.of(ConstantDescs.INIT_NAME, ConstantDescs.CLASS_INIT_NAME);\n-\n-    \/**\n-     * Validates the correctness of a binary class name. In particular checks for the presence of\n-     * invalid characters in the name.\n-     *\n-     * @param name the class name\n-     * @return the class name passed if valid\n-     * @throws IllegalArgumentException if the class name is invalid\n-     *\/\n-    static String validateBinaryClassName(String name) {\n-        for (int i=0; i<name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == ';' || ch == '[' || ch == '\/')\n-                throw new IllegalArgumentException(\"Invalid class name: \" + name);\n-        }\n-        return name;\n-    }\n-\n-    \/**\n-      * Validates the correctness of an internal class name.\n-      * In particular checks for the presence of invalid characters in the name.\n-      *\n-      * @param name the class name\n-      * @return the class name passed if valid\n-      * @throws IllegalArgumentException if the class name is invalid\n-      *\/\n-     static String validateInternalClassName(String name) {\n-         for (int i=0; i<name.length(); i++) {\n-             char ch = name.charAt(i);\n-             if (ch == ';' || ch == '[' || ch == '.')\n-                 throw new IllegalArgumentException(\"Invalid class name: \" + name);\n-         }\n-         return name;\n-     }\n-\n-    \/**\n-     * Validates the correctness of a binary package name.\n-     * In particular checks for the presence of invalid characters in the name.\n-     * Empty package name is allowed.\n-     *\n-     * @param name the package name\n-     * @return the package name passed if valid\n-     * @throws IllegalArgumentException if the package name is invalid\n-     * @throws NullPointerException if the package name is {@code null}\n-     *\/\n-    public static String validateBinaryPackageName(String name) {\n-        for (int i=0; i<name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == ';' || ch == '[' || ch == '\/')\n-                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n-        }\n-        return name;\n-    }\n-\n-    \/**\n-     * Validates the correctness of an internal package name.\n-     * In particular checks for the presence of invalid characters in the name.\n-     * Empty package name is allowed.\n-     *\n-     * @param name the package name\n-     * @return the package name passed if valid\n-     * @throws IllegalArgumentException if the package name is invalid\n-     * @throws NullPointerException if the package name is {@code null}\n-     *\/\n-    public static String validateInternalPackageName(String name) {\n-        for (int i=0; i<name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == ';' || ch == '[' || ch == '.')\n-                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n-        }\n-        return name;\n-    }\n-\n-    \/**\n-     * Validates the correctness of a module name.\n-     * In particular checks for the presence of invalid characters in the name.\n-     * Empty module name is allowed.\n-     *\n-     * {@jvms 4.2.3} Module and Package Names\n-     *\n-     * @param name the module name\n-     * @return the module name passed if valid\n-     * @throws IllegalArgumentException if the module name is invalid\n-     * @throws NullPointerException if the module name is {@code null}\n-     *\/\n-    public static String validateModuleName(String name) {\n-        for (int i=name.length() - 1; i >= 0; i--) {\n-            char ch = name.charAt(i);\n-            if ((ch >= '\\u0000' && ch <= '\\u001F')\n-            || ((ch == '\\\\' || ch == ':' || ch =='@') && (i == 0 || name.charAt(--i) != '\\\\')))\n-                throw new IllegalArgumentException(\"Invalid module name: \" + name);\n-        }\n-        return name;\n-    }\n-\n-    \/**\n-     * Validates a member name\n-     *\n-     * @param name the name of the member\n-     * @return the name passed if valid\n-     * @throws IllegalArgumentException if the member name is invalid\n-     *\/\n-    public static String validateMemberName(String name, boolean method) {\n-        if (name.length() == 0)\n-            throw new IllegalArgumentException(\"zero-length member name\");\n-        for (int i=0; i<name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == '.' || ch == ';' || ch == '[' || ch == '\/')\n-                throw new IllegalArgumentException(\"Invalid member name: \" + name);\n-            if (method && (ch == '<' || ch == '>')) {\n-                if (!pointyNames.contains(name))\n-                    throw new IllegalArgumentException(\"Invalid member name: \" + name);\n-            }\n-        }\n-        return name;\n-    }\n-\n-    static void validateClassOrInterface(ClassDesc classDesc) {\n-        if (!classDesc.isClassOrInterface())\n-            throw new IllegalArgumentException(\"not a class or interface type: \" + classDesc);\n-    }\n-\n-    static int arrayDepth(String descriptorString) {\n-        int depth = 0;\n-        while (descriptorString.charAt(depth) == '[')\n-            depth++;\n-        return depth;\n-    }\n-\n-    static String binaryToInternal(String name) {\n-        return name.replace('.', '\/');\n-    }\n-\n-    static String internalToBinary(String name) {\n-        return name.replace('\/', '.');\n-    }\n-\n-    static String dropLastChar(String s) {\n-        return s.substring(0, s.length() - 1);\n-    }\n-\n-    static String dropFirstAndLastChar(String s) {\n-        return s.substring(1, s.length() - 1);\n-    }\n-\n-    \/**\n-     * Parses a method descriptor string, and return a list of field descriptor\n-     * strings, return type first, then parameter types\n-     *\n-     * @param descriptor the descriptor string\n-     * @return the list of types\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    static List<ClassDesc> parseMethodDescriptor(String descriptor) {\n-        int cur = 0, end = descriptor.length();\n-        ArrayList<ClassDesc> ptypes = new ArrayList<>();\n-        ptypes.add(null); \/\/ placeholder for return type\n-\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-\n-        ++cur;  \/\/ skip '('\n-        while (cur < end && descriptor.charAt(cur) != ')') {\n-            int len = skipOverFieldSignature(descriptor, cur, end, false);\n-            if (len == 0)\n-                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            ptypes.add(resolveClassDesc(descriptor, cur, len));\n-            cur += len;\n-        }\n-        if (cur >= end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip ')'\n-\n-        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n-        if (rLen == 0 || cur + rLen != end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ptypes.set(0, resolveClassDesc(descriptor, cur, rLen));\n-        return ptypes;\n-    }\n-\n-    private static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n-        if (len == 1) {\n-            return Wrapper.forPrimitiveType(descriptor.charAt(start)).classDescriptor();\n-        }\n-        return ClassDesc.ofDescriptor(descriptor.substring(start, start + len));\n-    }\n-\n-    private static final char JVM_SIGNATURE_ARRAY = '[';\n-    private static final char JVM_SIGNATURE_BYTE = 'B';\n-    private static final char JVM_SIGNATURE_CHAR = 'C';\n-    private static final char JVM_SIGNATURE_CLASS = 'L';\n-    private static final char JVM_SIGNATURE_ENDCLASS = ';';\n-    private static final char JVM_SIGNATURE_ENUM = 'E';\n-    private static final char JVM_SIGNATURE_FLOAT = 'F';\n-    private static final char JVM_SIGNATURE_DOUBLE = 'D';\n-    private static final char JVM_SIGNATURE_FUNC = '(';\n-    private static final char JVM_SIGNATURE_ENDFUNC = ')';\n-    private static final char JVM_SIGNATURE_INT = 'I';\n-    private static final char JVM_SIGNATURE_LONG = 'J';\n-    private static final char JVM_SIGNATURE_SHORT = 'S';\n-    private static final char JVM_SIGNATURE_VOID = 'V';\n-    private static final char JVM_SIGNATURE_BOOLEAN = 'Z';\n-\n-    \/**\n-     * Validates that the characters at [start, end) within the provided string\n-     * describe a valid field type descriptor.\n-     * @param descriptor the descriptor string\n-     * @param start the starting index into the string\n-     * @param end the ending index within the string\n-     * @param voidOK is void acceptable?\n-     * @return the length of the descriptor, or 0 if it is not a descriptor\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    @SuppressWarnings(\"fallthrough\")\n-    static int skipOverFieldSignature(String descriptor, int start, int end, boolean voidOK) {\n-        int arrayDim = 0;\n-        int index = start;\n-        while (index < end) {\n-            switch (descriptor.charAt(index)) {\n-                case JVM_SIGNATURE_VOID: if (!voidOK) { return 0; }\n-                case JVM_SIGNATURE_BOOLEAN:\n-                case JVM_SIGNATURE_BYTE:\n-                case JVM_SIGNATURE_CHAR:\n-                case JVM_SIGNATURE_SHORT:\n-                case JVM_SIGNATURE_INT:\n-                case JVM_SIGNATURE_FLOAT:\n-                case JVM_SIGNATURE_LONG:\n-                case JVM_SIGNATURE_DOUBLE:\n-                    return index - start + 1;\n-                case JVM_SIGNATURE_CLASS:\n-                    \/\/ state variable for detection of illegal states, such as:\n-                    \/\/ empty unqualified name, '\/\/', leading '\/', or trailing '\/'\n-                    boolean legal = false;\n-                    while (++index < end) {\n-                        switch (descriptor.charAt(index)) {\n-                            case ';' -> {\n-                                \/\/ illegal state on parser exit indicates empty unqualified name or trailing '\/'\n-                                return legal ? index - start + 1 : 0;\n-                            }\n-                            case '.', '[' -> {\n-                                \/\/ do not permit '.' or '['\n-                                return 0;\n-                            }\n-                            case '\/' -> {\n-                                \/\/ illegal state when received '\/' indicates '\/\/' or leading '\/'\n-                                if (!legal) return 0;\n-                                legal = false;\n-                            }\n-                            default ->\n-                                legal = true;\n-                        }\n-                    }\n-                    return 0;\n-                case JVM_SIGNATURE_ARRAY:\n-                    arrayDim++;\n-                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n-                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n-                    }\n-                    \/\/ The rest of what's there better be a legal descriptor\n-                    index++;\n-                    voidOK = false;\n-                    break;\n-                default:\n-                    return 0;\n-            }\n-        }\n-        return 0;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":0,"deletions":315,"binary":false,"changes":315,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.util.OptionalInt;\n-import java.util.stream.Stream;\n@@ -32,0 +30,1 @@\n+import jdk.internal.constant.DirectMethodHandleDescImpl;\n@@ -92,1 +91,1 @@\n-            this(refKind, false);\n+            this.refKind = refKind; this.isInterface = false;\n@@ -182,17 +181,0 @@\n-\n-        \/**\n-         * Does this {@code Kind} correspond to a virtual method invocation?\n-         *\n-         * @return if this {@code Kind} corresponds to a virtual method invocation\n-         *\/\n-        boolean isVirtualMethod() {\n-            switch (this) {\n-                case VIRTUAL:\n-                case SPECIAL:\n-                case INTERFACE_VIRTUAL:\n-                case INTERFACE_SPECIAL:\n-                    return true;\n-                default:\n-                    return false;\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDesc.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-import static java.lang.constant.ConstantUtils.EMPTY_CONSTANTDESC;\n-import static java.lang.constant.ConstantUtils.validateMemberName;\n@@ -39,0 +37,2 @@\n+import static jdk.internal.constant.ConstantUtils.EMPTY_CONSTANTDESC;\n+import static jdk.internal.constant.ConstantUtils.validateMemberName;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DynamicCallSiteDesc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,0 @@\n-import static java.lang.constant.ConstantUtils.EMPTY_CONSTANTDESC;\n-import static java.lang.constant.ConstantUtils.validateMemberName;\n@@ -46,0 +44,2 @@\n+import static jdk.internal.constant.ConstantUtils.EMPTY_CONSTANTDESC;\n+import static jdk.internal.constant.ConstantUtils.validateMemberName;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DynamicConstantDesc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import jdk.internal.constant.DirectMethodHandleDescImpl;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDesc.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.ModuleDescImpl;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ModuleDesc.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-\/*\n- * Implementation of {@code ModuleDesc}\n- * @param name must have been validated\n- *\/\n-record ModuleDescImpl(String name) implements ModuleDesc {\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"ModuleDesc[%s]\", name());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ModuleDescImpl.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.PackageDescImpl;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/PackageDesc.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-\/*\n- * Implementation of {@code PackageDesc}\n- * @param internalName must have been validated\n- *\/\n-record PackageDescImpl(String internalName) implements PackageDesc {\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"PackageDesc[%s]\", name());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/PackageDescImpl.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import sun.invoke.util.Wrapper;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for the class\n- * constant corresponding to a primitive type (e.g., {@code int.class}).\n- *\/\n-final class PrimitiveClassDescImpl\n-        extends DynamicConstantDesc<Class<?>> implements ClassDesc {\n-\n-    private final String descriptor;\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} given a descriptor string for a primitive\n-     * type.\n-     *\n-     * @param descriptor the descriptor string, which must be a one-character\n-     * string corresponding to one of the nine base types\n-     * @throws IllegalArgumentException if the descriptor string does not\n-     * describe a valid primitive type\n-     * @jvms 4.3 Descriptors\n-     *\/\n-    PrimitiveClassDescImpl(String descriptor) {\n-        super(ConstantDescs.BSM_PRIMITIVE_CLASS, requireNonNull(descriptor), ConstantDescs.CD_Class);\n-        if (descriptor.length() != 1\n-            || \"VIJCSBFDZ\".indexOf(descriptor.charAt(0)) < 0)\n-            throw new IllegalArgumentException(String.format(\"not a valid primitive type descriptor: %s\", descriptor));\n-        this.descriptor = descriptor;\n-    }\n-\n-    @Override\n-    public String descriptorString() {\n-        return descriptor;\n-    }\n-\n-    @Override\n-    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup) {\n-        return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveType();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"PrimitiveClassDesc[%s]\", displayName());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/PrimitiveClassDescImpl.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.constant.ConstantUtils.*;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n- * interface, or array type.  A {@linkplain ReferenceClassDescImpl} corresponds to a\n- * {@code Constant_Class_info} entry in the constant pool of a classfile.\n- *\/\n-final class ReferenceClassDescImpl implements ClassDesc {\n-    private final String descriptor;\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n-     * interface type or an array type.\n-     *\n-     * @param descriptor a field descriptor string for a class or interface type\n-     * @throws IllegalArgumentException if the descriptor string is not a valid\n-     * field descriptor string, or does not describe a class or interface type\n-     * @jvms 4.3.2 Field Descriptors\n-     *\/\n-    ReferenceClassDescImpl(String descriptor) {\n-        int dLen = descriptor.length();\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n-        if (len <= 1 || len != dLen)\n-            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n-        this.descriptor = descriptor;\n-    }\n-\n-    @Override\n-    public String descriptorString() {\n-        return descriptor;\n-    }\n-\n-    @Override\n-    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n-            throws ReflectiveOperationException {\n-        if (isArray()) {\n-            if (isPrimitiveArray()) {\n-                return lookup.findClass(descriptor);\n-            }\n-            \/\/ Class.forName is slow on class or interface arrays\n-            int depth = ConstantUtils.arrayDepth(descriptor);\n-            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n-            for (int i = 0; i < depth; i++)\n-                clazz = clazz.arrayType();\n-            return clazz;\n-        }\n-        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n-    }\n-\n-    \/**\n-     * Whether the descriptor is one of a primitive array, given this is\n-     * already a valid reference type descriptor.\n-     *\/\n-    private boolean isPrimitiveArray() {\n-        \/\/ All L-type descriptors must end with a semicolon; same for reference\n-        \/\/ arrays, leaving primitive arrays the only ones without a final semicolon\n-        return descriptor.charAt(descriptor.length() - 1) != ';';\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@linkplain ReferenceClassDescImpl} is\n-     * equal to another {@linkplain ReferenceClassDescImpl}.  Equality is\n-     * determined by the two class descriptors having equal class descriptor\n-     * strings.\n-     *\n-     * @param o the {@code ClassDesc} to compare to this\n-     *       {@code ClassDesc}\n-     * @return {@code true} if the specified {@code ClassDesc}\n-     *      is equal to this {@code ClassDesc}.\n-     *\/\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        ClassDesc constant = (ClassDesc) o;\n-        return descriptor.equals(constant.descriptorString());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return descriptor.hashCode();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"ClassDesc[%s]\", displayName());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ReferenceClassDescImpl.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import sun.invoke.util.Wrapper;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * Helper methods for the implementation of {@code java.lang.constant}.\n+ *\/\n+public final class ConstantUtils {\n+    \/** an empty constant descriptor *\/\n+    public static final ConstantDesc[] EMPTY_CONSTANTDESC = new ConstantDesc[0];\n+    public static final ClassDesc[] EMPTY_CLASSDESC = new ClassDesc[0];\n+    public static final int MAX_ARRAY_TYPE_DESC_DIMENSIONS = 255;\n+\n+    private static final Set<String> pointyNames = Set.of(ConstantDescs.INIT_NAME, ConstantDescs.CLASS_INIT_NAME);\n+\n+    \/** No instantiation *\/\n+    private ConstantUtils() {}\n+\n+    \/**\n+     * Validates the correctness of a binary class name. In particular checks for the presence of\n+     * invalid characters in the name.\n+     *\n+     * @param name the class name\n+     * @return the class name passed if valid\n+     * @throws IllegalArgumentException if the class name is invalid\n+     *\/\n+    public static String validateBinaryClassName(String name) {\n+        for (int i = 0; i < name.length(); i++) {\n+            char ch = name.charAt(i);\n+            if (ch == ';' || ch == '[' || ch == '\/')\n+                throw new IllegalArgumentException(\"Invalid class name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates the correctness of an internal class name.\n+     * In particular checks for the presence of invalid characters in the name.\n+     *\n+     * @param name the class name\n+     * @return the class name passed if valid\n+     * @throws IllegalArgumentException if the class name is invalid\n+     *\/\n+    public static String validateInternalClassName(String name) {\n+        for (int i = 0; i < name.length(); i++) {\n+            char ch = name.charAt(i);\n+            if (ch == ';' || ch == '[' || ch == '.')\n+                throw new IllegalArgumentException(\"Invalid class name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates the correctness of a binary package name.\n+     * In particular checks for the presence of invalid characters in the name.\n+     * Empty package name is allowed.\n+     *\n+     * @param name the package name\n+     * @return the package name passed if valid\n+     * @throws IllegalArgumentException if the package name is invalid\n+     * @throws NullPointerException if the package name is {@code null}\n+     *\/\n+    public static String validateBinaryPackageName(String name) {\n+        for (int i = 0; i < name.length(); i++) {\n+            char ch = name.charAt(i);\n+            if (ch == ';' || ch == '[' || ch == '\/')\n+                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates the correctness of an internal package name.\n+     * In particular checks for the presence of invalid characters in the name.\n+     * Empty package name is allowed.\n+     *\n+     * @param name the package name\n+     * @return the package name passed if valid\n+     * @throws IllegalArgumentException if the package name is invalid\n+     * @throws NullPointerException if the package name is {@code null}\n+     *\/\n+    public static String validateInternalPackageName(String name) {\n+        for (int i = 0; i < name.length(); i++) {\n+            char ch = name.charAt(i);\n+            if (ch == ';' || ch == '[' || ch == '.')\n+                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates the correctness of a module name.\n+     * In particular checks for the presence of invalid characters in the name.\n+     * Empty module name is allowed.\n+     *\n+     * {@jvms 4.2.3} Module and Package Names\n+     *\n+     * @param name the module name\n+     * @return the module name passed if valid\n+     * @throws IllegalArgumentException if the module name is invalid\n+     * @throws NullPointerException if the module name is {@code null}\n+     *\/\n+    public static String validateModuleName(String name) {\n+        for (int i = name.length() - 1; i >= 0; i--) {\n+            char ch = name.charAt(i);\n+            if ((ch >= '\\u0000' && ch <= '\\u001F')\n+            || ((ch == '\\\\' || ch == ':' || ch =='@') && (i == 0 || name.charAt(--i) != '\\\\')))\n+                throw new IllegalArgumentException(\"Invalid module name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates a member name\n+     *\n+     * @param name the name of the member\n+     * @return the name passed if valid\n+     * @throws IllegalArgumentException if the member name is invalid\n+     *\/\n+    public static String validateMemberName(String name, boolean method) {\n+        int len = name.length();\n+        if (len == 0)\n+            throw new IllegalArgumentException(\"zero-length member name\");\n+        for (int i = 0; i < len; i++) {\n+            char ch = name.charAt(i);\n+            if (ch == '.' || ch == ';' || ch == '[' || ch == '\/')\n+                throw new IllegalArgumentException(\"Invalid member name: \" + name);\n+            if (method && (ch == '<' || ch == '>')) {\n+                if (!pointyNames.contains(name))\n+                    throw new IllegalArgumentException(\"Invalid member name: \" + name);\n+            }\n+        }\n+        return name;\n+    }\n+\n+    public static void validateClassOrInterface(ClassDesc classDesc) {\n+        if (!classDesc.isClassOrInterface())\n+            throw new IllegalArgumentException(\"not a class or interface type: \" + classDesc);\n+    }\n+\n+    public static int arrayDepth(String descriptorString) {\n+        int depth = 0;\n+        while (descriptorString.charAt(depth) == '[')\n+            depth++;\n+        return depth;\n+    }\n+\n+    public static String binaryToInternal(String name) {\n+        return name.replace('.', '\/');\n+    }\n+\n+    public static String internalToBinary(String name) {\n+        return name.replace('\/', '.');\n+    }\n+\n+    public static String dropFirstAndLastChar(String s) {\n+        return s.substring(1, s.length() - 1);\n+    }\n+\n+    \/**\n+     * Parses a method descriptor string, and return a list of field descriptor\n+     * strings, return type first, then parameter types\n+     *\n+     * @param descriptor the descriptor string\n+     * @return the list of types\n+     * @throws IllegalArgumentException if the descriptor string is not valid\n+     *\/\n+    public static List<ClassDesc> parseMethodDescriptor(String descriptor) {\n+        int cur = 0, end = descriptor.length();\n+        ArrayList<ClassDesc> ptypes = new ArrayList<>();\n+        ptypes.add(null); \/\/ placeholder for return type\n+\n+        if (cur >= end || descriptor.charAt(cur) != '(')\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+\n+        ++cur;  \/\/ skip '('\n+        while (cur < end && descriptor.charAt(cur) != ')') {\n+            int len = skipOverFieldSignature(descriptor, cur, end, false);\n+            if (len == 0)\n+                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+            ptypes.add(resolveClassDesc(descriptor, cur, len));\n+            cur += len;\n+        }\n+        if (cur >= end)\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        ++cur;  \/\/ skip ')'\n+\n+        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n+        if (rLen == 0 || cur + rLen != end)\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        ptypes.set(0, resolveClassDesc(descriptor, cur, rLen));\n+        return ptypes;\n+    }\n+\n+    private static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n+        if (len == 1) {\n+            return Wrapper.forPrimitiveType(descriptor.charAt(start)).classDescriptor();\n+        }\n+        \/\/ Pre-verified in parseMethodDescriptor; avoid redundant verification\n+        return ReferenceClassDescImpl.ofValidated(descriptor.substring(start, start + len));\n+    }\n+\n+    private static final char JVM_SIGNATURE_ARRAY = '[';\n+    private static final char JVM_SIGNATURE_BYTE = 'B';\n+    private static final char JVM_SIGNATURE_CHAR = 'C';\n+    private static final char JVM_SIGNATURE_CLASS = 'L';\n+    private static final char JVM_SIGNATURE_ENDCLASS = ';';\n+    private static final char JVM_SIGNATURE_ENUM = 'E';\n+    private static final char JVM_SIGNATURE_FLOAT = 'F';\n+    private static final char JVM_SIGNATURE_DOUBLE = 'D';\n+    private static final char JVM_SIGNATURE_FUNC = '(';\n+    private static final char JVM_SIGNATURE_ENDFUNC = ')';\n+    private static final char JVM_SIGNATURE_INT = 'I';\n+    private static final char JVM_SIGNATURE_LONG = 'J';\n+    private static final char JVM_SIGNATURE_SHORT = 'S';\n+    private static final char JVM_SIGNATURE_VOID = 'V';\n+    private static final char JVM_SIGNATURE_BOOLEAN = 'Z';\n+\n+    \/**\n+     * Validates that the characters at [start, end) within the provided string\n+     * describe a valid field type descriptor.\n+     * @param descriptor the descriptor string\n+     * @param start the starting index into the string\n+     * @param end the ending index within the string\n+     * @param voidOK is void acceptable?\n+     * @return the length of the descriptor, or 0 if it is not a descriptor\n+     * @throws IllegalArgumentException if the descriptor string is not valid\n+     *\/\n+    @SuppressWarnings(\"fallthrough\")\n+    static int skipOverFieldSignature(String descriptor, int start, int end, boolean voidOK) {\n+        int arrayDim = 0;\n+        int index = start;\n+        while (index < end) {\n+            switch (descriptor.charAt(index)) {\n+                case JVM_SIGNATURE_VOID: if (!voidOK) { return 0; }\n+                case JVM_SIGNATURE_BOOLEAN:\n+                case JVM_SIGNATURE_BYTE:\n+                case JVM_SIGNATURE_CHAR:\n+                case JVM_SIGNATURE_SHORT:\n+                case JVM_SIGNATURE_INT:\n+                case JVM_SIGNATURE_FLOAT:\n+                case JVM_SIGNATURE_LONG:\n+                case JVM_SIGNATURE_DOUBLE:\n+                    return index - start + 1;\n+                case JVM_SIGNATURE_CLASS:\n+                    \/\/ state variable for detection of illegal states, such as:\n+                    \/\/ empty unqualified name, '\/\/', leading '\/', or trailing '\/'\n+                    boolean legal = false;\n+                    while (++index < end) {\n+                        switch (descriptor.charAt(index)) {\n+                            case ';' -> {\n+                                \/\/ illegal state on parser exit indicates empty unqualified name or trailing '\/'\n+                                return legal ? index - start + 1 : 0;\n+                            }\n+                            case '.', '[' -> {\n+                                \/\/ do not permit '.' or '['\n+                                return 0;\n+                            }\n+                            case '\/' -> {\n+                                \/\/ illegal state when received '\/' indicates '\/\/' or leading '\/'\n+                                if (!legal) return 0;\n+                                legal = false;\n+                            }\n+                            default ->\n+                                legal = true;\n+                        }\n+                    }\n+                    return 0;\n+                case JVM_SIGNATURE_ARRAY:\n+                    arrayDim++;\n+                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n+                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n+                    }\n+                    \/\/ The rest of what's there better be a legal descriptor\n+                    index++;\n+                    voidOK = false;\n+                    break;\n+                default:\n+                    return 0;\n+            }\n+        }\n+        return 0;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package java.lang.constant;\n+package jdk.internal.constant;\n@@ -27,0 +27,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -33,2 +36,0 @@\n-import static java.lang.constant.ConstantUtils.validateClassOrInterface;\n-import static java.lang.constant.ConstantUtils.validateMemberName;\n@@ -37,0 +38,2 @@\n+import static jdk.internal.constant.ConstantUtils.validateClassOrInterface;\n+import static jdk.internal.constant.ConstantUtils.validateMemberName;\n@@ -43,1 +46,1 @@\n-final class DirectMethodHandleDescImpl implements DirectMethodHandleDesc {\n+public final class DirectMethodHandleDescImpl implements DirectMethodHandleDesc {\n@@ -65,1 +68,1 @@\n-    DirectMethodHandleDescImpl(Kind kind, ClassDesc owner, String name, MethodTypeDesc type) {\n+    public DirectMethodHandleDescImpl(Kind kind, ClassDesc owner, String name, MethodTypeDesc type) {\n@@ -85,6 +88,5 @@\n-        if (kind.isVirtualMethod())\n-            this.invocationType = type.insertParameterTypes(0, owner);\n-        else if (kind == CONSTRUCTOR)\n-            this.invocationType = type.changeReturnType(owner);\n-        else\n-            this.invocationType = type;\n+        this.invocationType = switch (kind) {\n+            case VIRTUAL, SPECIAL, INTERFACE_VIRTUAL, INTERFACE_SPECIAL -> type.insertParameterTypes(0, owner);\n+            case CONSTRUCTOR -> type.changeReturnType(owner);\n+            default -> type;\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/DirectMethodHandleDescImpl.java","additions":14,"deletions":12,"binary":false,"changes":26,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDescImpl.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.constant;\n+package jdk.internal.constant;\n@@ -29,0 +29,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -44,1 +46,1 @@\n-final class MethodTypeDescImpl implements MethodTypeDesc {\n+public final class MethodTypeDescImpl implements MethodTypeDesc {\n@@ -68,1 +70,1 @@\n-    static MethodTypeDescImpl ofTrusted(ClassDesc returnType, ClassDesc[] trustedArgTypes) {\n+    public static MethodTypeDescImpl ofTrusted(ClassDesc returnType, ClassDesc[] trustedArgTypes) {\n@@ -89,1 +91,1 @@\n-    static MethodTypeDescImpl ofDescriptor(String descriptor) {\n+    public static MethodTypeDescImpl ofDescriptor(String descriptor) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":6,"deletions":4,"binary":false,"changes":10,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDescImpl.java","status":"renamed"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ModuleDesc;\n+\n+\/*\n+ * Implementation of {@code ModuleDesc}\n+ * @param name must have been validated\n+ *\/\n+public record ModuleDescImpl(String name) implements ModuleDesc {\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ModuleDesc[%s]\", name());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ModuleDescImpl.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.PackageDesc;\n+\n+\/*\n+ * Implementation of {@code PackageDesc}\n+ * @param internalName must have been validated\n+ *\/\n+public record PackageDescImpl(String internalName) implements PackageDesc {\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"PackageDesc[%s]\", name());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PackageDescImpl.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import sun.invoke.util.Wrapper;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for the class\n+ * constant corresponding to a primitive type (e.g., {@code int.class}).\n+ *\/\n+public final class PrimitiveClassDescImpl\n+        extends DynamicConstantDesc<Class<?>> implements ClassDesc {\n+\n+    private final String descriptor;\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} given a descriptor string for a primitive\n+     * type.\n+     *\n+     * @param descriptor the descriptor string, which must be a one-character\n+     * string corresponding to one of the nine base types\n+     * @throws IllegalArgumentException if the descriptor string does not\n+     * describe a valid primitive type\n+     * @jvms 4.3 Descriptors\n+     *\/\n+    public PrimitiveClassDescImpl(String descriptor) {\n+        super(ConstantDescs.BSM_PRIMITIVE_CLASS, requireNonNull(descriptor), ConstantDescs.CD_Class);\n+        if (descriptor.length() != 1\n+            || \"VIJCSBFDZ\".indexOf(descriptor.charAt(0)) < 0)\n+            throw new IllegalArgumentException(String.format(\"not a valid primitive type descriptor: %s\", descriptor));\n+        this.descriptor = descriptor;\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        return descriptor;\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup) {\n+        return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveType();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"PrimitiveClassDesc[%s]\", displayName());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import static jdk.internal.constant.ConstantUtils.*;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n+ * interface, or array type.  A {@linkplain ReferenceClassDescImpl} corresponds to a\n+ * {@code Constant_Class_info} entry in the constant pool of a classfile.\n+ *\/\n+public final class ReferenceClassDescImpl implements ClassDesc {\n+    private final String descriptor;\n+\n+    private ReferenceClassDescImpl(String descriptor) {\n+        this.descriptor = descriptor;\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n+     * interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @throws IllegalArgumentException if the descriptor string is not a valid\n+     * field descriptor string, or does not describe a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ReferenceClassDescImpl of(String descriptor) {\n+        int dLen = descriptor.length();\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n+        if (len <= 1 || len != dLen)\n+            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n+        return new ReferenceClassDescImpl(descriptor);\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n+     * for a class or interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ReferenceClassDescImpl ofValidated(String descriptor) {\n+        return new ReferenceClassDescImpl(descriptor);\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        return descriptor;\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n+            throws ReflectiveOperationException {\n+        if (isArray()) {\n+            if (isPrimitiveArray()) {\n+                return lookup.findClass(descriptor);\n+            }\n+            \/\/ Class.forName is slow on class or interface arrays\n+            int depth = ConstantUtils.arrayDepth(descriptor);\n+            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n+            for (int i = 0; i < depth; i++)\n+                clazz = clazz.arrayType();\n+            return clazz;\n+        }\n+        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n+    }\n+\n+    \/**\n+     * Whether the descriptor is one of a primitive array, given this is\n+     * already a valid reference type descriptor.\n+     *\/\n+    private boolean isPrimitiveArray() {\n+        \/\/ All L-type descriptors must end with a semicolon; same for reference\n+        \/\/ arrays, leaving primitive arrays the only ones without a final semicolon\n+        return descriptor.charAt(descriptor.length() - 1) != ';';\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@linkplain ReferenceClassDescImpl} is\n+     * equal to another {@linkplain ReferenceClassDescImpl}.  Equality is\n+     * determined by the two class descriptors having equal class descriptor\n+     * strings.\n+     *\n+     * @param o the {@code ClassDesc} to compare to this\n+     *       {@code ClassDesc}\n+     * @return {@code true} if the specified {@code ClassDesc}\n+     *      is equal to this {@code ClassDesc}.\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        ClassDesc constant = (ClassDesc) o;\n+        return descriptor.equals(constant.descriptorString());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return descriptor.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ClassDesc[%s]\", displayName());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -240,0 +240,6 @@\n+        try {\n+            ConstantDescs.CD_void.arrayType();\n+            fail(\"Should throw IAE\");\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ Expected\n+        }\n","filename":"test\/jdk\/java\/lang\/constant\/ClassDescTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package java.lang.constant;\n+package jdk.internal.constant;\n@@ -26,1 +26,0 @@\n-import java.lang.invoke.*;\n@@ -38,0 +37,1 @@\n+ * @modules java.base\/jdk.internal.constant\n","filename":"test\/jdk\/java\/lang\/constant\/boottest\/java.base\/jdk\/internal\/constant\/ConstantUtilsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/java\/lang\/constant\/boottest\/java.base\/java\/lang\/constant\/ConstantUtilsTest.java","status":"renamed"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -63,0 +64,15 @@\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @Warmup(iterations = 3, time = 2)\n+    @Measurement(iterations = 6, time = 1)\n+    @Fork(1)\n+    @State(Scope.Thread)\n+    public static class ReferenceOnly {\n+        public ClassDesc desc = ConstantDescs.CD_Object;\n+        @Benchmark\n+        public ClassDesc ofNested() {\n+            return desc.nested(\"Foo\");\n+        }\n+\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/ClassDescFactories.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}