{"files":[{"patch":"@@ -183,1 +183,2 @@\n-        int depth = arrayDepth(descriptorString());\n+        String desc = descriptorString();\n+        int depth = arrayDepth(desc);\n@@ -189,1 +190,5 @@\n-        return arrayType(1);\n+        if (desc.length() == 1 && desc.charAt(0) == 'V') {\n+            throw new IllegalArgumentException(\"not a valid reference type descriptor: [V\");\n+        }\n+        String newDesc = new StringBuilder(desc.length() + 1).append('[').append(desc).toString();\n+        return ReferenceClassDescImpl.ofValidated(newDesc);\n@@ -204,2 +209,4 @@\n-        int netRank;\n-        if (rank <= 0) {\n+        if (rank <= 1) {\n+            if (rank == 1) {\n+                return arrayType();\n+            }\n@@ -209,10 +216,10 @@\n-        try {\n-            int currentDepth = arrayDepth(desc);\n-            netRank = Math.addExact(currentDepth, rank);\n-            if (netRank > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-                throw new IllegalArgumentException(\"rank: \" + netRank +\n-                                                   \" exceeds maximum supported dimension of \" +\n-                                                   MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n-            }\n-        } catch (ArithmeticException ae) {\n-            throw new IllegalArgumentException(\"Integer overflow in rank computation\");\n+        long currentDepth = arrayDepth(desc);\n+        long netRank = currentDepth + rank;\n+        if (netRank > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+            throw new IllegalArgumentException(\"rank: \" + netRank +\n+                    \" exceeds maximum supported dimension of \" +\n+                    MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n+        }\n+        var sb = new StringBuilder(desc.length() + rank);\n+        for (int i = 0; i < rank; i++) {\n+            sb.append('[');\n@@ -220,0 +227,1 @@\n+        String newDesc = sb.append(desc).toString();\n@@ -221,1 +229,1 @@\n-            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %sV\", \"[\".repeat(rank)));\n+            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + newDesc);\n@@ -223,1 +231,1 @@\n-        return ReferenceClassDescImpl.ofValidated(\"[\".repeat(rank) + descriptorString());\n+        return ReferenceClassDescImpl.ofValidated(newDesc);\n@@ -335,3 +343,3 @@\n-        String className = internalToBinary(dropFirstAndLastChar(descriptorString()));\n-        int index = className.lastIndexOf('.');\n-        return (index == -1) ? \"\" : className.substring(0, index);\n+        String desc = descriptorString();\n+        int index = desc.lastIndexOf('\/');\n+        return (index == -1) ? \"\" : internalToBinary(desc.substring(1, index - 1));\n@@ -355,2 +363,2 @@\n-            return descriptorString().substring(Math.max(1, descriptorString().lastIndexOf('\/') + 1),\n-                                                descriptorString().length() - 1);\n+            String desc = descriptorString();\n+            return desc.substring(Math.max(1, desc.lastIndexOf('\/') + 1), desc.length() - 1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.constant;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Test various operations on\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class ClassDescMethods {\n+\n+    @Benchmark\n+    public String packageName() {\n+        return ConstantDescs.CD_Object.packageName();\n+    }\n+\n+    @Benchmark\n+    public String displayName() {\n+        return ConstantDescs.CD_Object.displayName();\n+    }\n+\n+    @Benchmark\n+    public void arrayType(Blackhole bh) {\n+        bh.consume(ConstantDescs.CD_Object.arrayType());\n+        bh.consume(ConstantDescs.CD_boolean.arrayType());\n+    }\n+\n+    @Benchmark\n+    public void arrayType1(Blackhole bh) {\n+        bh.consume(ConstantDescs.CD_Object.arrayType(1));\n+        bh.consume(ConstantDescs.CD_boolean.arrayType(1));\n+    }\n+\n+    @Benchmark\n+    public void arrayType2(Blackhole bh) {\n+        bh.consume(ConstantDescs.CD_Object.arrayType(2));\n+        bh.consume(ConstantDescs.CD_boolean.arrayType(2));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/ClassDescMethods.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}