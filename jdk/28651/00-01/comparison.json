{"files":[{"patch":"@@ -939,0 +939,8 @@\n+\/\/ Idealize vector operations whose vector size is less than the hardware supported\n+\/\/ max vector size. Generate a vector mask for the operation. Lanes with indices\n+\/\/ inside of the vector size are set to true, while the remaining lanes are set to\n+\/\/ false. Returns the corresponding masked vector node.\n+static Node* ideal_partial_operations(PhaseGVN* phase, Node* node, const TypeVect* vt) {\n+  if (!Matcher::vector_needs_partial_operations(node, vt)) {\n+    return nullptr;\n+  }\n@@ -940,1 +948,0 @@\n-Node* VectorNode::gen_masked_vector(PhaseGVN* gvn, Node* node, const TypeVect* vt) {\n@@ -949,5 +956,3 @@\n-\n-  \/\/ Generate a vector mask for vector operation whose vector length is lower than the\n-  \/\/ hardware supported max vector length.\n-  Node* length = gvn->transform(new ConvI2LNode(gvn->makecon(TypeInt::make(vlen))));\n-  Node* mask = gvn->transform(VectorMaskGenNode::make(length, bt, vlen));\n+  \/\/ Generate a vector mask, with lanes inside of the vector length set to true.\n+  Node* length = phase->transform(new ConvI2LNode(phase->makecon(TypeInt::make(vlen))));\n+  Node* mask = phase->transform(VectorMaskGenNode::make(length, bt, vlen));\n@@ -1033,2 +1038,3 @@\n-  if (Matcher::vector_needs_partial_operations(this, vect_type())) {\n-    return gen_masked_vector(phase, this, vect_type());\n+  Node* n = ideal_partial_operations(phase, this, vect_type());\n+  if (n != nullptr) {\n+    return n;\n@@ -1115,3 +1121,3 @@\n-  const TypeVect* vt = vect_type();\n-  if (Matcher::vector_needs_partial_operations(this, vt)) {\n-    return VectorNode::gen_masked_vector(phase, this, vt);\n+  Node* n = ideal_partial_operations(phase, this, vect_type());\n+  if (n != nullptr) {\n+    return n;\n@@ -1129,3 +1135,3 @@\n-  const TypeVect* vt = vect_type();\n-  if (Matcher::vector_needs_partial_operations(this, vt)) {\n-    return VectorNode::gen_masked_vector(phase, this, vt);\n+  Node* n = ideal_partial_operations(phase, this, vect_type());\n+  if (n != nullptr) {\n+    return n;\n@@ -1407,3 +1413,3 @@\n-  const TypeVect* vt = vect_type();\n-  if (Matcher::vector_needs_partial_operations(this, vt)) {\n-    return VectorNode::gen_masked_vector(phase, this, vt);\n+  Node* n = ideal_partial_operations(phase, this, vect_type());\n+  if (n != nullptr) {\n+    return n;\n@@ -1411,1 +1417,1 @@\n-  return nullptr;\n+  return Node::Ideal(phase, can_reshape);\n@@ -1889,3 +1895,3 @@\n-  const TypeVect* vt = vect_type();\n-  if (Matcher::vector_needs_partial_operations(this, vt)) {\n-    return VectorNode::gen_masked_vector(phase, this, vt);\n+  Node* n = ideal_partial_operations(phase, this, vect_type());\n+  if (n != nullptr) {\n+    return n;\n@@ -1893,1 +1899,1 @@\n-  return nullptr;\n+  return TypeNode::Ideal(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -121,5 +121,0 @@\n-  \/\/ Generate a vector mask for the input vector node. Lanes with indices less than\n-  \/\/ the vector length are set to true, while the remaining lanes are set to false.\n-  \/\/ Returns the corresponding masked vector node.\n-  static Node* gen_masked_vector(PhaseGVN* gvn, Node* node, const TypeVect* vt);\n-\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}