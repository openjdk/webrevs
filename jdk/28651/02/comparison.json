{"files":[{"patch":"@@ -349,2 +349,8 @@\n-    \/\/ Only SVE has partial vector operations\n-    if (UseSVE == 0) {\n+    \/\/ 1. Only SVE requires partial vector operations.\n+    \/\/ 2. The vector size in bytes must be smaller than MaxVectorSize.\n+    \/\/ 3. Predicated vectors have a mask input, which guarantees that\n+    \/\/    out-of-bounds lanes remain inactive.\n+    int length_in_bytes = vt->length_in_bytes();\n+    if (UseSVE == 0 ||\n+        length_in_bytes == MaxVectorSize ||\n+        node->is_predicated_vector()) {\n@@ -373,2 +379,0 @@\n-        \/\/ We use NEON load\/store instructions if the vector length is <= 128 bits.\n-        return vt->length_in_bytes() > 16;\n@@ -377,2 +381,3 @@\n-        \/\/ We may prefer using NEON instructions rather than SVE partial operations.\n-        return !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+        \/\/ For these ops, we prefer using NEON instructions rather than SVE\n+        \/\/ predicated instructions for better performance.\n+        return !VM_Version::use_neon_for_vector(length_in_bytes);\n@@ -381,2 +386,3 @@\n-        \/\/ For BYTE\/SHORT\/INT\/FLOAT\/DOUBLE types, we may prefer using NEON\n-        \/\/ instructions rather than SVE partial operations.\n+        \/\/ For BYTE\/SHORT\/INT\/FLOAT\/DOUBLE types, we prefer using NEON\n+        \/\/ instructions rather than SVE predicated instructions for\n+        \/\/ better performance.\n@@ -384,1 +390,1 @@\n-               !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+               !VM_Version::use_neon_for_vector(length_in_bytes);\n@@ -386,2 +392,3 @@\n-        \/\/ For other ops whose vector size is smaller than the max vector size, a\n-        \/\/ full-sized unpredicated operation does not impact the final vector result.\n+        \/\/ For other ops whose vector size is smaller than the max vector\n+        \/\/ size, a full-sized unpredicated operation does not impact the\n+        \/\/ vector result.\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -339,2 +339,8 @@\n-    \/\/ Only SVE has partial vector operations\n-    if (UseSVE == 0) {\n+    \/\/ 1. Only SVE requires partial vector operations.\n+    \/\/ 2. The vector size in bytes must be smaller than MaxVectorSize.\n+    \/\/ 3. Predicated vectors have a mask input, which guarantees that\n+    \/\/    out-of-bounds lanes remain inactive.\n+    int length_in_bytes = vt->length_in_bytes();\n+    if (UseSVE == 0 ||\n+        length_in_bytes == MaxVectorSize ||\n+        node->is_predicated_vector()) {\n@@ -363,2 +369,0 @@\n-        \/\/ We use NEON load\/store instructions if the vector length is <= 128 bits.\n-        return vt->length_in_bytes() > 16;\n@@ -367,2 +371,3 @@\n-        \/\/ We may prefer using NEON instructions rather than SVE partial operations.\n-        return !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+        \/\/ For these ops, we prefer using NEON instructions rather than SVE\n+        \/\/ predicated instructions for better performance.\n+        return !VM_Version::use_neon_for_vector(length_in_bytes);\n@@ -371,2 +376,3 @@\n-        \/\/ For BYTE\/SHORT\/INT\/FLOAT\/DOUBLE types, we may prefer using NEON\n-        \/\/ instructions rather than SVE partial operations.\n+        \/\/ For BYTE\/SHORT\/INT\/FLOAT\/DOUBLE types, we prefer using NEON\n+        \/\/ instructions rather than SVE predicated instructions for\n+        \/\/ better performance.\n@@ -374,1 +380,1 @@\n-               !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+               !VM_Version::use_neon_for_vector(length_in_bytes);\n@@ -376,2 +382,3 @@\n-        \/\/ For other ops whose vector size is smaller than the max vector size, a\n-        \/\/ full-sized unpredicated operation does not impact the final vector result.\n+        \/\/ For other ops whose vector size is smaller than the max vector\n+        \/\/ size, a full-sized unpredicated operation does not impact the\n+        \/\/ vector result.\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -332,0 +332,4 @@\n+  \/\/ Determines if a vector operation needs to be partially implemented with a mask\n+  \/\/ controlling only the lanes in range [0, vector_length) are processed. This applies\n+  \/\/ to operations whose vector length is less than the hardware-supported maximum\n+  \/\/ vector length. Returns true if the operation requires masking, false otherwise.\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -939,0 +939,8 @@\n+\/\/ Idealize vector operations whose vector size is less than the hardware supported\n+\/\/ max vector size. Generate a vector mask for the operation. Lanes with indices\n+\/\/ inside of the vector size are set to true, while the remaining lanes are set to\n+\/\/ false. Returns the corresponding masked vector node.\n+static Node* ideal_partial_operations(PhaseGVN* phase, Node* node, const TypeVect* vt) {\n+  if (!Matcher::vector_needs_partial_operations(node, vt)) {\n+    return nullptr;\n+  }\n@@ -940,1 +948,0 @@\n-Node* VectorNode::try_to_gen_masked_vector(PhaseGVN* gvn, Node* node, const TypeVect* vt) {\n@@ -944,0 +951,4 @@\n+  assert(Matcher::match_rule_supported_vector_masked(vopc, vlen, bt),\n+         \"The masked feature is required for the vector operation\");\n+  assert(Matcher::match_rule_supported_vector(Op_VectorMaskGen, vlen, bt),\n+         \"'VectorMaskGen' is required to generate a vector mask\");\n@@ -945,16 +956,3 @@\n-  \/\/ Predicated vectors do not need to add another mask input\n-  if (node->is_predicated_vector() || !Matcher::has_predicated_vectors() ||\n-      !Matcher::match_rule_supported_vector_masked(vopc, vlen, bt) ||\n-      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, vlen, bt)) {\n-    return nullptr;\n-  }\n-\n-  Node* mask = nullptr;\n-  \/\/ Generate a vector mask for vector operation whose vector length is lower than the\n-  \/\/ hardware supported max vector length.\n-  if (vt->length_in_bytes() < (uint)MaxVectorSize) {\n-    Node* length = gvn->transform(new ConvI2LNode(gvn->makecon(TypeInt::make(vlen))));\n-    mask = gvn->transform(VectorMaskGenNode::make(length, bt, vlen));\n-  } else {\n-    return nullptr;\n-  }\n+  \/\/ Generate a vector mask, with lanes inside of the vector length set to true.\n+  Node* length = phase->transform(new ConvI2LNode(phase->makecon(TypeInt::make(vlen))));\n+  Node* mask = phase->transform(VectorMaskGenNode::make(length, bt, vlen));\n@@ -1040,2 +1038,3 @@\n-  if (Matcher::vector_needs_partial_operations(this, vect_type())) {\n-    return try_to_gen_masked_vector(phase, this, vect_type());\n+  Node* n = ideal_partial_operations(phase, this, vect_type());\n+  if (n != nullptr) {\n+    return n;\n@@ -1122,3 +1121,3 @@\n-  const TypeVect* vt = vect_type();\n-  if (Matcher::vector_needs_partial_operations(this, vt)) {\n-    return VectorNode::try_to_gen_masked_vector(phase, this, vt);\n+  Node* n = ideal_partial_operations(phase, this, vect_type());\n+  if (n != nullptr) {\n+    return n;\n@@ -1136,3 +1135,3 @@\n-  const TypeVect* vt = vect_type();\n-  if (Matcher::vector_needs_partial_operations(this, vt)) {\n-    return VectorNode::try_to_gen_masked_vector(phase, this, vt);\n+  Node* n = ideal_partial_operations(phase, this, vect_type());\n+  if (n != nullptr) {\n+    return n;\n@@ -1414,3 +1413,3 @@\n-  const TypeVect* vt = vect_type();\n-  if (Matcher::vector_needs_partial_operations(this, vt)) {\n-    return VectorNode::try_to_gen_masked_vector(phase, this, vt);\n+  Node* n = ideal_partial_operations(phase, this, vect_type());\n+  if (n != nullptr) {\n+    return n;\n@@ -1418,1 +1417,1 @@\n-  return nullptr;\n+  return Node::Ideal(phase, can_reshape);\n@@ -1896,3 +1895,3 @@\n-  const TypeVect* vt = vect_type();\n-  if (Matcher::vector_needs_partial_operations(this, vt)) {\n-    return VectorNode::try_to_gen_masked_vector(phase, this, vt);\n+  Node* n = ideal_partial_operations(phase, this, vect_type());\n+  if (n != nullptr) {\n+    return n;\n@@ -1900,1 +1899,1 @@\n-  return nullptr;\n+  return TypeNode::Ideal(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":32,"deletions":33,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-  static Node* try_to_gen_masked_vector(PhaseGVN* gvn, Node* node, const TypeVect* vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1445,0 +1445,10 @@\n+    public static final String VECTOR_MASK_GEN = PREFIX + \"VECTOR_MASK_GEN\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_GEN, \"VectorMaskGen\");\n+    }\n+\n+    public static final String VECTOR_MASK_FIRST_TRUE = PREFIX + \"VECTOR_MASK_FIRST_TRUE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_FIRST_TRUE, \"VectorMaskFirstTrue\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test 8371603\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary Test the missing optimization issues for vector load\/store caused by JDK-8286941\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver ${test.main.class}\n+ *\/\n+public class TestVectorLoadStoreOptimization {\n+    private static final int LENGTH = 1024;\n+    private static final Generators random = Generators.G;\n+\n+    private static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_PREFERRED;\n+\n+    private static int[] a;\n+\n+    static {\n+        a = new int[LENGTH];\n+        random.fill(random.ints(), a);\n+    }\n+\n+    \/\/ Test that \"LoadVectorNode::Ideal()\" calls \"LoadNode::Ideal()\" as expected,\n+    \/\/ which sees the previous stores that go to the same position in-dependently,\n+    \/\/ and optimize out the load with matched store values.\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"1\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testLoadVector() {\n+        IntVector v1 = IntVector.fromArray(SPECIES, a, 0);\n+        v1.intoArray(a, SPECIES.length());\n+        v1.intoArray(a, 2 * SPECIES.length());\n+        \/\/ The second load vector equals to the first one and should be optimized\n+        \/\/ out by \"LoadNode::Ideal()\".\n+        IntVector v2 = IntVector.fromArray(SPECIES, a, SPECIES.length());\n+        v2.intoArray(a, 3 * SPECIES.length());\n+    }\n+\n+    @Check(test = \"testLoadVector\")\n+    public static void testLoadVectorVerify() {\n+        for (int i = SPECIES.length(); i < 4 * SPECIES.length(); i += SPECIES.length()) {\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Asserts.assertEquals(a[i + j], a[j]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that \"StoreVectorNode::Ideal()\" calls \"StoreNode::Ideal()\" as expected,\n+    \/\/ which can get rid of previous stores that go to the same position.\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"1\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testStoreVector() {\n+        IntVector v1 = IntVector.fromArray(SPECIES, a, 0 * SPECIES.length());\n+        IntVector v2 = IntVector.fromArray(SPECIES, a, 1 * SPECIES.length());\n+        \/\/ Useless store to same position as below, which should be optimized out by\n+        \/\/ \"StoreNode::Ideal()\".\n+        v1.intoArray(a, 3 * SPECIES.length());\n+        v2.intoArray(a, 3 * SPECIES.length());\n+    }\n+\n+    @Check(test = \"testStoreVector\")\n+    public static void testStoreVectorVerify() {\n+        for (int i = 3 * SPECIES.length(); i < 4 * SPECIES.length(); i++) {\n+            Asserts.assertEquals(a[i], a[i - 2 * SPECIES.length()]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorLoadStoreOptimization.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,432 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test 8371603\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary Test vector operations with vector size less than MaxVectorSize\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+public class TestVectorOperationsWithPartialSize {\n+    private static final int SIZE = 1024;\n+    private static final Generators random = Generators.G;\n+\n+    private static final VectorSpecies<Integer> ISPEC_128 = IntVector.SPECIES_128;\n+    private static final VectorSpecies<Long> LSPEC_128 = LongVector.SPECIES_128;\n+    private static final VectorSpecies<Float> FSPEC_128 = FloatVector.SPECIES_128;\n+    private static final VectorSpecies<Double> DSPEC_128 = DoubleVector.SPECIES_128;\n+    private static final VectorSpecies<Integer> ISPEC_256 = IntVector.SPECIES_256;\n+    private static final VectorSpecies<Long> LSPEC_256 = LongVector.SPECIES_256;\n+\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static long[] la;\n+    private static long[] lb;\n+    private static float[] fa;\n+    private static float[] fb;\n+    private static double[] da;\n+    private static double[] db;\n+    private static boolean[] m;\n+    private static boolean[] mr;\n+    private static int[] indices;\n+\n+    static {\n+        ia = new int[SIZE];\n+        ib = new int[SIZE];\n+        la = new long[SIZE];\n+        lb = new long[SIZE];\n+        fa = new float[SIZE];\n+        fb = new float[SIZE];\n+        da = new double[SIZE];\n+        db = new double[SIZE];\n+        m = new boolean[SIZE];\n+        mr = new boolean[SIZE];\n+        indices = new int[SIZE];\n+\n+        random.fill(random.ints(), ia);\n+        random.fill(random.longs(), la);\n+        random.fill(random.floats(), fa);\n+        random.fill(random.doubles(), da);\n+        random.fill(random.uniformInts(0, ISPEC_128.length()), indices);\n+        for (int i = 0; i < SIZE; i++) {\n+            m[i] = i % 2 == 0;\n+        }\n+    }\n+\n+    \/\/ ================ Load\/Store\/Gather\/Scatter Tests ==================\n+\n+    private static void verifyLoadStore(int[] expected, int[] actual, int vlen) {\n+        for (int i = 0; i < vlen; i++) {\n+            Asserts.assertEquals(expected[i], actual[i]);\n+        }\n+    }\n+\n+    private static void verifyLoadGatherStoreScatter(int[] expected, int[] actual, int[] indices, int vlen) {\n+        for (int i = 0; i < vlen; i++) {\n+            Asserts.assertEquals(expected[indices[i]], actual[indices[i]]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"1\",\n+                  IRNode.STORE_VECTOR, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public void testLoadStore_128() {\n+        IntVector v = IntVector.fromArray(ISPEC_128, ia, 0);\n+        v.intoArray(ib, 0);\n+        verifyLoadStore(ia, ib, ISPEC_128.length());\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.LOAD_VECTOR_MASKED, \"1\",\n+                  IRNode.STORE_VECTOR_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public void testLoadStore_256() {\n+        IntVector v = IntVector.fromArray(ISPEC_256, ia, 0);\n+        v.intoArray(ib, 0);\n+        verifyLoadStore(ia, ib, ISPEC_256.length());\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.LOAD_VECTOR_GATHER_MASKED, \"1\",\n+                  IRNode.STORE_VECTOR_SCATTER_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public void testLoadGatherStoreScatter_128() {\n+        IntVector v = IntVector.fromArray(ISPEC_128, ia, 0, indices, 0);\n+        v.intoArray(ib, 0, indices, 0);\n+        verifyLoadGatherStoreScatter(ia, ib, indices, ISPEC_128.length());\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.LOAD_VECTOR_GATHER_MASKED, \"1\",\n+                  IRNode.STORE_VECTOR_SCATTER_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public void testLoadGatherStoreScatter_256() {\n+        IntVector v = IntVector.fromArray(ISPEC_256, ia, 0, indices, 0);\n+        v.intoArray(ib, 0, indices, 0);\n+        verifyLoadGatherStoreScatter(ia, ib, indices, ISPEC_256.length());\n+    }\n+\n+    \/\/ ===================== Reduction Tests - Add =====================\n+\n+    interface binOpInt {\n+        int apply(int a, int b);\n+    }\n+\n+    interface binOpLong {\n+        long apply(long a, long b);\n+    }\n+\n+    private static int reduceLanes(int init, int[] arr, int vlen, binOpInt f) {\n+        int result = init;\n+        for (int i = 0; i < vlen; i++) {\n+            result = f.apply(arr[i], result);\n+        }\n+        return result;\n+    }\n+\n+    private static long reduceLanes(long init, long[] arr, int vlen,binOpLong f) {\n+        long result = init;\n+        for (int i = 0; i < vlen; i++) {\n+            result = f.apply(arr[i], result);\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Reduction add operations with integer types are implemented with NEON SIMD instructions\n+    \/\/ when the vector size is less than or equal to 128-bit.\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"0\",\n+                  IRNode.ADD_REDUCTION_VI, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public int testAddReductionInt_128() {\n+        IntVector v = IntVector.fromArray(ISPEC_128, ia, 0);\n+        int result = v.reduceLanes(VectorOperators.ADD);\n+        Asserts.assertEquals(reduceLanes(0, ia, ISPEC_128.length(), (a, b) -> (a + b)), result);\n+        return result;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.ADD_REDUCTION_VI, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public int testAddReductionInt_256() {\n+        IntVector v = IntVector.fromArray(ISPEC_256, ia, 0);\n+        int result = v.reduceLanes(VectorOperators.ADD);\n+        Asserts.assertEquals(reduceLanes(0, ia, ISPEC_256.length(), (a, b) -> (a + b)), result);\n+        return result;\n+    }\n+\n+    \/\/ Reduction add operations with long types are implemented with NEON SIMD instructions\n+    \/\/ when the vector size is less than or equal to 128-bit.\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"0\",\n+                  IRNode.ADD_REDUCTION_VL, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public long testAddReductionLong_128() {\n+        LongVector v = LongVector.fromArray(LSPEC_128, la, 0);\n+        long result = v.reduceLanes(VectorOperators.ADD);\n+        Asserts.assertEquals(reduceLanes(0L, la, LSPEC_128.length(), (a, b) -> (a + b)), result);\n+        return result;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.ADD_REDUCTION_VL, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public long testAddReductionLong_256() {\n+        LongVector v = LongVector.fromArray(LSPEC_256, la, 0);\n+        long result = v.reduceLanes(VectorOperators.ADD);\n+        Asserts.assertEquals(reduceLanes(0L, la, LSPEC_256.length(), (a, b) -> (a + b)), result);\n+        return result;\n+    }\n+\n+    private static void verifyAddReductionFloat(float actual, float[] arr, int vlen) {\n+        float expected = 0.0f;\n+        for (int i = 0; i < vlen; i++) {\n+            expected += arr[i];\n+        }\n+        \/\/ Floating point addition reduction ops may introduce rounding errors.\n+        float ROUNDING_ERROR_FACTOR_ADD = 10.0f;\n+        float tolerance = Math.ulp(expected) * ROUNDING_ERROR_FACTOR_ADD;\n+        if (Math.abs(expected - actual) > tolerance) {\n+            throw new RuntimeException(\n+                \"assertEqualsWithTolerance\" +\n+                \": expected \" + expected + \" but was \" + actual +\n+                \" (tolerance: \" + tolerance + \", diff: \" + Math.abs(expected - actual) + \")\"\n+            );\n+        }\n+    }\n+\n+    private static void verifyAddReductionDouble(double actual, double[] arr, int vlen) {\n+        double expected = 0.0;\n+        for (int i = 0; i < vlen; i++) {\n+            expected += arr[i];\n+        }\n+        \/\/ Floating point addition reduction ops may introduce rounding errors.\n+        double ROUNDING_ERROR_FACTOR_ADD = 10.0;\n+        double tolerance = Math.ulp(expected) * ROUNDING_ERROR_FACTOR_ADD;\n+        if (Math.abs(expected - actual) > tolerance) {\n+            throw new RuntimeException(\n+                \"assertEqualsWithTolerance\" +\n+                \": expected \" + expected + \" but was \" + actual +\n+                \" (tolerance: \" + tolerance + \", diff: \" + Math.abs(expected - actual) + \")\"\n+            );\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.ADD_REDUCTION_VF, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public float testAddReductionFloat() {\n+        FloatVector v = FloatVector.fromArray(FSPEC_128, fa, 0);\n+        float result = v.reduceLanes(VectorOperators.ADD);\n+        verifyAddReductionFloat(result, fa, FSPEC_128.length());\n+        return result;\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.ADD_REDUCTION_VD, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public double testAddReductionDouble() {\n+        DoubleVector v = DoubleVector.fromArray(DSPEC_128, da, 0);\n+        double result = v.reduceLanes(VectorOperators.ADD);\n+        verifyAddReductionDouble(result, da, DSPEC_128.length());\n+        return result;\n+    }\n+\n+    \/\/ ============== Reduction Tests - Logical ==============\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.AND_REDUCTION_V, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public int testAndReduction() {\n+        IntVector v = IntVector.fromArray(ISPEC_128, ia, 0);\n+        int result = v.reduceLanes(VectorOperators.AND);\n+        Asserts.assertEquals(reduceLanes(-1, ia, ISPEC_128.length(), (a, b) -> (a & b)), result);\n+        return result;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.OR_REDUCTION_V, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public int testOrReduction() {\n+        IntVector v = IntVector.fromArray(ISPEC_128, ia, 0);\n+        int result = v.reduceLanes(VectorOperators.OR);\n+        Asserts.assertEquals(reduceLanes(0, ia, ISPEC_128.length(), (a, b) -> (a | b)), result);\n+        return result;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.XOR_REDUCTION_V, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public int testXorReduction() {\n+        IntVector v = IntVector.fromArray(ISPEC_128, ia, 0);\n+        int result = v.reduceLanes(VectorOperators.XOR);\n+        Asserts.assertEquals(reduceLanes(0, ia, ISPEC_128.length(), (a, b) -> (a ^ b)), result);\n+        return result;\n+    }\n+\n+    \/\/ ===================== Reduction Tests - Min\/Max =====================\n+\n+    \/\/ Reduction min operations with non-long types are implemented with NEON SIMD instructions\n+    \/\/ when the vector size is less than or equal to 128-bit.\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"0\",\n+                  IRNode.MIN_REDUCTION_V, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 32\"})\n+    public int testMinReductionInt_128() {\n+        IntVector v = IntVector.fromArray(ISPEC_128, ia, 0);\n+        int result = v.reduceLanes(VectorOperators.MIN);\n+        Asserts.assertEquals(reduceLanes(Integer.MAX_VALUE, ia, ISPEC_128.length(), (a, b) -> Math.min(a, b)), result);\n+        return result;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.MIN_REDUCTION_V, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 64\"})\n+    public int testMinReductionInt_256() {\n+        IntVector v = IntVector.fromArray(ISPEC_256, ia, 0);\n+        int result = v.reduceLanes(VectorOperators.MIN);\n+        Asserts.assertEquals(reduceLanes(Integer.MAX_VALUE, ia, ISPEC_256.length(), (a, b) -> Math.min(a, b)), result);\n+        return result;\n+    }\n+\n+    \/\/ Reduction max operations with non-long types are implemented with NEON SIMD instructions\n+    \/\/ when the vector size is less than or equal to 128-bit.\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"0\",\n+                  IRNode.MAX_REDUCTION_V, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 32\"})\n+    public int testMaxReductionInt_128() {\n+        IntVector v = IntVector.fromArray(ISPEC_128, ia, 0);\n+        int result = v.reduceLanes(VectorOperators.MAX);\n+        Asserts.assertEquals(reduceLanes(Integer.MIN_VALUE, ia, ISPEC_128.length(), (a, b) -> Math.max(a, b)), result);\n+        return result;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.MAX_REDUCTION_V, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 64\"})\n+    public int testMaxReductionInt_256() {\n+        IntVector v = IntVector.fromArray(ISPEC_256, ia, 0);\n+        int result = v.reduceLanes(VectorOperators.MAX);\n+        Asserts.assertEquals(reduceLanes(Integer.MIN_VALUE, ia, ISPEC_256.length(), (a, b) -> Math.max(a, b)), result);\n+        return result;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.MIN_REDUCTION_V, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 32\"})\n+    public static long testMinReductionLong() {\n+        LongVector v = LongVector.fromArray(LSPEC_128, la, 0);\n+        long result = v.reduceLanes(VectorOperators.MIN);\n+        Asserts.assertEquals(reduceLanes(Long.MAX_VALUE, la, LSPEC_128.length(), (a, b) -> Math.min(a, b)), result);\n+        return result;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.MAX_REDUCTION_V, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 32\"})\n+    public static long testMaxReductionLong() {\n+        LongVector v = LongVector.fromArray(LSPEC_128, la, 0);\n+        long result = v.reduceLanes(VectorOperators.MAX);\n+        Asserts.assertEquals(reduceLanes(Long.MIN_VALUE, la, LSPEC_128.length(), (a, b) -> Math.max(a, b)), result);\n+        return result;\n+    }\n+\n+    \/\/ ====================== VectorMask Tests ======================\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.VECTOR_LOAD_MASK, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 32\"})\n+    public static void testLoadMask() {\n+        VectorMask<Integer> vm = VectorMask.fromArray(ISPEC_128, m, 0);\n+        vm.not().intoArray(mr, 0);\n+        \/\/ Verify that the mask is loaded correctly.\n+        for (int i = 0; i < ISPEC_128.length(); i++) {\n+            Asserts.assertEquals(!m[i], mr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.VECTOR_MASK_CMP, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 32\"})\n+    public static void testVectorMaskCmp() {\n+        IntVector v1 = IntVector.fromArray(ISPEC_128, ia, 0);\n+        IntVector v2 = IntVector.fromArray(ISPEC_128, ib, 0);\n+        VectorMask<Integer> vm = v1.compare(VectorOperators.LT, v2);\n+        vm.intoArray(mr, 0);\n+        \/\/ Verify that the mask is generated correctly.\n+        for (int i = 0; i < ISPEC_128.length(); i++) {\n+            Asserts.assertEquals(ia[i] < ib[i], mr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_MASK_GEN, \"1\",\n+                  IRNode.VECTOR_MASK_FIRST_TRUE, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 32\"})\n+    public static int testFirstTrue() {\n+        VectorMask<Integer> vm = ISPEC_128.maskAll(false);\n+        int result = vm.firstTrue();\n+        \/\/ The result is the vector length if no lane is true.\n+        \/\/ This is the default behavior of the firstTrue method.\n+        Asserts.assertEquals(ISPEC_128.length(), result);\n+        return result;\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorOperationsWithPartialSize.java","additions":432,"deletions":0,"binary":false,"changes":432,"status":"added"}]}