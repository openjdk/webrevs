{"files":[{"patch":"@@ -451,1 +451,0 @@\n-                address = ((DirectBuffer)dst).address() + pos;\n@@ -453,0 +452,1 @@\n+                address = ((DirectBuffer)dst).address() + pos;\n@@ -455,1 +455,1 @@\n-                address = ((DirectBuffer)buf).address();\n+                address = IOUtil.bufferAddress(buf) + pos;\n@@ -634,1 +634,0 @@\n-                address = ((DirectBuffer)src).address() + pos;\n@@ -636,0 +635,1 @@\n+                address = ((DirectBuffer)src).address() + pos;\n@@ -643,1 +643,1 @@\n-                address = ((DirectBuffer)buf).address();\n+                address = IOUtil.bufferAddress(buf) + pos;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousFileChannelImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,1 @@\n+        testViewsOfUnsupportedArenas(blah.toPath());\n@@ -564,0 +565,24 @@\n+    \/\/ tests unsupported MemorySegment view buffers\n+    static void testViewsOfUnsupportedArenas(Path file) throws IOException {\n+        System.out.println(\"testViewsOfUnsupportedArenas\");\n+\n+        AsynchronousFileChannel ch = AsynchronousFileChannel\n+            .open(file, CREATE, WRITE, TRUNCATE_EXISTING);\n+\n+        try {\n+            writeFully(ch, genUnsupportedBuffer(true), 0L);\n+            throw new RuntimeException(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            \/\/ ignore\n+        }\n+\n+        try {\n+            writeFully(ch, genUnsupportedBuffer(false), 0L);\n+            throw new RuntimeException(\"UnsupportedOperationException expected\");\n+        } catch (UnsupportedOperationException expected) {\n+            \/\/ ignore\n+        } finally {\n+            ch.close();\n+        }\n+    }\n+\n@@ -568,1 +593,2 @@\n-        return switch (rand.nextInt(3)) {\n+        rand.nextBytes(buf);\n+        return switch (rand.nextInt(4)) {\n@@ -573,1 +599,4 @@\n-            case 2 -> Arena.ofAuto().allocate(buf.length).asByteBuffer()\n+            case 2 -> Arena.global().allocate(buf.length).asByteBuffer()\n+                    .put(buf)\n+                    .flip();\n+            case 3 -> Arena.ofAuto().allocate(buf.length).asByteBuffer()\n@@ -580,0 +609,10 @@\n+    \/\/ returns ByteBuffer view of confined or shared arena\n+    static ByteBuffer genUnsupportedBuffer(boolean isConfined) {\n+        int size = 1024 + rand.nextInt(16000);\n+        byte[] buf = new byte[size];\n+        rand.nextBytes(buf);\n+        Arena arena = isConfined ? Arena.ofConfined() : Arena.ofShared();\n+        return arena.allocate(buf.length).asByteBuffer().put(buf).flip();\n+    }\n+\n+    \/\/ writes all remaining bytes in the buffer to the given channel at the\n","filename":"test\/jdk\/java\/nio\/channels\/AsynchronousFileChannel\/Basic.java","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"}]}