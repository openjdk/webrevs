{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.nio.channels.FileChannel;\n@@ -31,0 +32,1 @@\n+import java.util.zip.CRC32;\n@@ -39,2 +41,3 @@\n- * @bug 8226530\n- * @summary ZIP File System tests that leverage DirectoryStream\n+ * @bug 8226530 8303891\n+ * @summary Verify that ZipFile reads size fields using the Zip64 extra field for entries\n+ * of size > 0xFFFFFFFF\n@@ -45,2 +48,2 @@\n-\n-    private static final int BUFFER_SIZE = 2048;\n+    \/\/ Buffer used when writing zero-filled entries\n+    private static final byte[] EMPTY_BYTES = new byte[16384];\n@@ -53,3 +56,0 @@\n-    \/\/ List of files to be added to the ZIP file\n-    private static final List<String> ZIP_ENTRIES = List.of(LARGE_FILE_NAME,\n-            SMALL_FILE_NAME);\n@@ -57,1 +57,1 @@\n-    private static final long SMALL_FILE_SIZE = 0x100000L; \/\/ 1024L x 1024L;\n+    private static final long SMALL_FILE_SIZE = 0x1024L * 1024L; \/\/ 1MB\n@@ -66,1 +66,0 @@\n-        createFiles();\n@@ -76,1 +75,0 @@\n-\n@@ -92,0 +90,1 @@\n+     *\n@@ -95,1 +94,1 @@\n-        try (FileOutputStream fos = new FileOutputStream(ZIP_FILE_NAME);\n+        try (OutputStream fos = new SparseOutputStream(new FileOutputStream(ZIP_FILE_NAME));\n@@ -97,0 +96,1 @@\n+\n@@ -98,14 +98,3 @@\n-            for (String srcFile : ZIP_ENTRIES) {\n-                System.out.printf(\"...Adding Entry: %s%n\", srcFile);\n-                File fileToZip = new File(srcFile);\n-                try (FileInputStream fis = new FileInputStream(fileToZip)) {\n-                    ZipEntry zipEntry = new ZipEntry(fileToZip.getName());\n-                    zipEntry.setSize(fileToZip.length());\n-                    zos.putNextEntry(zipEntry);\n-                    byte[] bytes = new byte[BUFFER_SIZE];\n-                    int length;\n-                    while ((length = fis.read(bytes)) >= 0) {\n-                        zos.write(bytes, 0, length);\n-                    }\n-                }\n-            }\n+\n+            addEntry(LARGE_FILE_NAME, LARGE_FILE_SIZE, zos);\n+            addEntry(SMALL_FILE_NAME, SMALL_FILE_SIZE, zos);\n@@ -116,2 +105,1 @@\n-     * Create the files that will be added to the ZIP file\n-     * @throws IOException if there is a problem  creating the files\n+     * Add a STORED entry with the given name and size. The file content is filled with zero-bytes.\n@@ -119,7 +107,17 @@\n-    private static void createFiles() throws IOException {\n-        try (RandomAccessFile largeFile = new RandomAccessFile(LARGE_FILE_NAME, \"rw\");\n-             RandomAccessFile smallFile = new RandomAccessFile(SMALL_FILE_NAME, \"rw\")) {\n-            System.out.printf(\"Creating %s%n\", LARGE_FILE_NAME);\n-            largeFile.setLength(LARGE_FILE_SIZE);\n-            System.out.printf(\"Creating %s%n\", SMALL_FILE_NAME);\n-            smallFile.setLength(SMALL_FILE_SIZE);\n+    private static void addEntry(String entryName, long size, ZipOutputStream zos) throws IOException {\n+        ZipEntry e = new ZipEntry(entryName);\n+        e.setMethod(ZipEntry.STORED);\n+        e.setSize(size);\n+        e.setCrc(crc(size));\n+        zos.putNextEntry(e);\n+\n+        \/\/ Write size number of empty bytes\n+        long rem = size;\n+        while (rem > 0) {\n+            int lim = EMPTY_BYTES.length;\n+            if (rem < lim) {\n+                lim = (int) rem;\n+            }\n+            \/\/ Allows SparseOutputStream to simply advance position\n+            zos.write(EMPTY_BYTES, 0, lim);\n+            rem -= lim;\n@@ -146,0 +144,41 @@\n+\n+    \/**\n+     * Compute the CRC for a file of the given size filled with zero-bytes\n+     *\/\n+    private static long crc(long size) {\n+        CRC32 crc32 = new CRC32();\n+        long rem = size;\n+        while (rem > 0) {\n+            int lim = EMPTY_BYTES.length;\n+            if (rem < lim) {\n+                lim = (int) rem;\n+            }\n+            crc32.update(EMPTY_BYTES, 0, lim);\n+            rem -= lim;\n+        }\n+\n+        return crc32.getValue();\n+    }\n+\n+    \/**\n+     * An OutputStream which creates sparse holes when contents\n+     * from EMPTY_BYTES is written to it.\n+     *\/\n+    private static class SparseOutputStream extends FilterOutputStream {\n+        private final FileChannel channel;\n+\n+        public SparseOutputStream(FileOutputStream fileOutputStream) {\n+            super(fileOutputStream);\n+            this.channel = fileOutputStream.getChannel();\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            if (b == EMPTY_BYTES) {\n+                \/\/ Create a sparse 'hole' in the file instead of writing bytes\n+                channel.position(channel.position() + len);\n+            } else {\n+                super.write(b, off, len);\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/Zip64SizeTest.java","additions":74,"deletions":35,"binary":false,"changes":109,"status":"modified"}]}