{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,3 +23,0 @@\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n@@ -27,3 +24,9 @@\n-import java.io.*;\n-import java.nio.channels.Channels;\n-import java.nio.channels.FileChannel;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n@@ -32,4 +35,0 @@\n-import java.nio.file.StandardOpenOption;\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.zip.CRC32;\n@@ -40,1 +39,2 @@\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n@@ -45,2 +45,2 @@\n- * @summary Verify that ZipFile reads size fields using the Zip64 extra field for entries\n- * of size > 0xFFFFFFFF\n+ * @summary Verify that ZipFile reads size fields using the Zip64 extra\n+ * field when only the 'uncompressed size' field has the ZIP64 \"magic value\" 0xFFFFFFFF\n@@ -48,1 +48,1 @@\n- * @run testng Zip64SizeTest\n+ * @run junit Zip64SizeTest\n@@ -51,2 +51,0 @@\n-    \/\/ Buffer used when writing zero-filled entries\n-    private static final byte[] EMPTY_BYTES = new byte[16384];\n@@ -54,7 +52,9 @@\n-    private static final String ZIP_FILE_NAME = \"Zip64SizeTest.zip\";\n-    \/\/ File that will be created with a size greater than 0xFFFFFFFF\n-    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n-    \/\/ File that will be created with a size less than 0xFFFFFFFF\n-    private static final String SMALL_FILE_NAME = \"SmallZipEntry.txt\";\n-    private static final long LARGE_FILE_SIZE = 5L * 1024L * 1024L * 1024L; \/\/ 5GB\n-    private static final long SMALL_FILE_SIZE = 0x1024L * 1024L; \/\/ 1MB\n+    private static final Path ZIP_FILE = Path.of(\"Zip64SizeTest.zip\");\n+    \/\/ ontents to write to ZIP entries\n+    private static final byte[] CONTENT = \"Hello\".getBytes(StandardCharsets.UTF_8);\n+    \/\/ This opaque tag will be ignored by ZipEntry.setExtra0\n+    private static final int UNKNOWN_TAG = 0x9902;\n+    \/\/ Tag used when converting the extra field to a real ZIP64 extra field\n+    private static final short ZIP64_TAG = 0x1;\n+    \/\/ Marker value to indicate that the actual value is stored in the ZIP64 extra field\n+    private static final int ZIP64_MAGIC_VALUE = 0xFFFFFFFF;\n@@ -63,2 +63,2 @@\n-     * Validate that if the size of a ZIP entry exceeds 0xFFFFFFFF, that the\n-     * correct size is returned from the ZIP64 Extended information.\n+     * Validate that if the 'uncompressed size' of a ZIP CEN header is 0xFFFFFFFF, then the\n+     * actual size is retrieved from the corresponding ZIP64 Extended information field.\n@@ -66,1 +66,1 @@\n-     * @throws IOException\n+     * @throws IOException if an unexpected IOException occurs\n@@ -69,1 +69,1 @@\n-    public static void validateZipEntrySizes() throws IOException {\n+    public void validateZipEntrySizes() throws IOException {\n@@ -72,2 +72,2 @@\n-        try (ZipFile zip = new ZipFile(ZIP_FILE_NAME)) {\n-            ZipEntry ze = zip.getEntry(LARGE_FILE_NAME);\n+        try (ZipFile zip = new ZipFile(ZIP_FILE.toFile())) {\n+            ZipEntry ze = zip.getEntry(\"first\");\n@@ -75,2 +75,2 @@\n-            assertTrue(ze.getSize() == LARGE_FILE_SIZE);\n-            ze = zip.getEntry(SMALL_FILE_NAME);\n+            assertEquals(CONTENT.length, ze.getSize());\n+            ze = zip.getEntry(\"second\");\n@@ -78,1 +78,1 @@\n-            assertTrue(ze.getSize() == SMALL_FILE_SIZE);\n+            assertEquals(CONTENT.length, ze.getSize());\n@@ -83,11 +83,20 @@\n-     * Delete the files created for use by the test\n-     * @throws IOException if an error occurs deleting the files\n-     *\/\n-    private static void deleteFiles() throws IOException {\n-        Files.deleteIfExists(Path.of(ZIP_FILE_NAME));\n-        Files.deleteIfExists(Path.of(LARGE_FILE_NAME));\n-        Files.deleteIfExists(Path.of(SMALL_FILE_NAME));\n-    }\n-\n-    \/**\n-     * Create the ZIP file adding an entry whose size exceeds 0xFFFFFFFF\n+     * Create ZIP file with a CEN entry where the 'uncompressed size' is stored\n+     * in the ZIP64 field. This makes the ZIP64 data block 8 bytes long which\n+     * triggers the regression described in 8226530.\n+     *\n+     * The CEN entry for the \"first\" entry will have the following structure:\n+     * (Note the CEN 'Uncompressed Length' being 0xFFFFFFFF and the ZIP64\n+     * 'Uncompressed Size' being 5)\n+     *\n+     * 0081 CENTRAL HEADER #1     02014B50\n+     * 0085 Created Zip Spec      14 '2.0'\n+     * 0086 Created OS            00 'MS-DOS'\n+     * [...]\n+     * 0091 CRC                   F7D18982\n+     * 0095 Compressed Length     00000007\n+     * 0099 Uncompressed Length   FFFFFFFF\n+     * [..]\n+     * 00AF Filename              'first'\n+     * 00B4 Extra ID #0001        0001 'ZIP64'\n+     * 00B6   Length              0008\n+     * 00B8   Uncompressed Size   0000000000000005\n@@ -98,4 +107,2 @@\n-        \/\/ NTFS requires sparse files to be created explicitly\n-        EnumSet<StandardOpenOption> options = EnumSet.of(StandardOpenOption.CREATE_NEW,\n-                StandardOpenOption.WRITE,\n-                StandardOpenOption.SPARSE);\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ZipOutputStream zos = new ZipOutputStream(baos)) {\n@@ -103,4 +110,3 @@\n-        try (FileChannel channel = FileChannel.open(Path.of(ZIP_FILE_NAME), options);\n-             OutputStream outputStream = Channels.newOutputStream(channel);\n-             OutputStream fos = new SparseOutputStream(outputStream, channel);\n-             ZipOutputStream zos = new ZipOutputStream(fos)) {\n+            ZipEntry e1 = new ZipEntry(\"first\");\n+            \/\/ Make room for an 8-byte ZIP64 extra field\n+            e1.setExtra(createOpaqueExtra((short) Long.BYTES));\n@@ -108,1 +114,2 @@\n-            System.out.printf(\"Creating Zip file: %s%n\", ZIP_FILE_NAME);\n+            zos.putNextEntry(e1);\n+            zos.write(CONTENT);\n@@ -110,2 +117,3 @@\n-            addEntry(LARGE_FILE_NAME, LARGE_FILE_SIZE, zos);\n-            addEntry(SMALL_FILE_NAME, SMALL_FILE_SIZE, zos);\n+            ZipEntry e2 = new ZipEntry(\"second\");\n+            zos.putNextEntry(e2);\n+            zos.write(CONTENT);\n@@ -113,0 +121,4 @@\n+\n+        byte[] zip = baos.toByteArray();\n+        updateToZip64(zip);\n+        Files.write(ZIP_FILE, zip);\n@@ -116,1 +128,3 @@\n-     * Add a STORED entry with the given name and size. The file content is filled with zero-bytes.\n+     * Update the CEN entry of the \"first\" entry to use ZIP64 format for the\n+     * 'uncompressed size' field\n+     * @param zip the ZIP file to update to ZIP64\n@@ -118,18 +132,38 @@\n-    private static void addEntry(String entryName, long size, ZipOutputStream zos) throws IOException {\n-        ZipEntry e = new ZipEntry(entryName);\n-        e.setMethod(ZipEntry.STORED);\n-        e.setSize(size);\n-        e.setCrc(crc(size));\n-        zos.putNextEntry(e);\n-\n-        \/\/ Write size number of empty bytes\n-        long rem = size;\n-        while (rem > 0) {\n-            int lim = EMPTY_BYTES.length;\n-            if (rem < lim) {\n-                lim = (int) rem;\n-            }\n-            \/\/ Allows SparseOutputStream to simply advance position\n-            zos.write(EMPTY_BYTES, 0, lim);\n-            rem -= lim;\n-        }\n+    private static void updateToZip64(byte[] zip) {\n+        ByteBuffer buffer = ByteBuffer.wrap(zip).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Find the offset of the first CEN header\n+        int cenOffset = buffer.getInt(zip.length- ZipFile.ENDHDR + ZipFile.ENDOFF);\n+        \/\/ Find the offset of the extra field\n+        int nlen = buffer.getShort(cenOffset + ZipFile.CENNAM);\n+        int extraOffset = cenOffset + ZipFile.CENHDR + nlen;\n+\n+        \/\/ Change the header ID from 'unknown' to ZIP64\n+        buffer.putShort(extraOffset, ZIP64_TAG);\n+        \/\/ Update the 'uncompressed size' ZIP64 value to the actual uncompressed length\n+        int fieldOffset = extraOffset\n+                + Short.BYTES \/\/ TAG\n+                + Short.BYTES; \/\/ data size\n+        buffer.putLong(fieldOffset, CONTENT.length);\n+\n+        \/\/ Set the 'uncompressed size' field of the CEN to 0xFFFFFFFF\n+\n+        buffer.putInt(cenOffset + ZipFile.CENLEN, ZIP64_MAGIC_VALUE);\n+    }\n+\n+    \/**\n+     * Create a ZIP64 extra field with an 'unknown' tag, right-sized\n+     * for holding an 8-byte 'uncompressed size field'\n+     * @return\n+     * @param blockSize\n+     *\/\n+    private static byte[] createOpaqueExtra(short blockSize) {\n+        int size = Short.BYTES  \/\/ tag\n+                + Short.BYTES   \/\/ data size\n+                + blockSize;   \/\/ uncompressed size;\n+\n+        byte[] extra = new byte[size];\n+        ByteBuffer.wrap(extra).order(ByteOrder.LITTLE_ENDIAN)\n+                .putShort(0, (short) UNKNOWN_TAG)\n+                .putShort(Short.BYTES, blockSize);\n+\n+        return extra;\n@@ -142,1 +176,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -151,1 +185,1 @@\n-    @AfterMethod\n+    @AfterEach\n@@ -157,20 +191,2 @@\n-     * Compute the CRC for a file of the given size filled with zero-bytes\n-     *\/\n-    private static long crc(long size) {\n-        CRC32 crc32 = new CRC32();\n-        long rem = size;\n-        while (rem > 0) {\n-            int lim = EMPTY_BYTES.length;\n-            if (rem < lim) {\n-                lim = (int) rem;\n-            }\n-            crc32.update(EMPTY_BYTES, 0, lim);\n-            rem -= lim;\n-        }\n-\n-        return crc32.getValue();\n-    }\n-\n-    \/**\n-     * An OutputStream which creates sparse holes when contents\n-     * from EMPTY_BYTES is written to it.\n+     * Delete the files created for use by the test\n+     * @throws IOException if an error occurs deleting the files\n@@ -178,17 +194,2 @@\n-    private static class SparseOutputStream extends FilterOutputStream {\n-        private final FileChannel channel;\n-\n-        public SparseOutputStream(OutputStream out, FileChannel channel) {\n-            super(out);\n-            this.channel = channel;\n-        }\n-\n-        @Override\n-        public void write(byte[] b, int off, int len) throws IOException {\n-            if (b == EMPTY_BYTES) {\n-                \/\/ Create a sparse 'hole' in the file instead of writing bytes\n-                channel.position(channel.position() + len);\n-            } else {\n-                super.write(b, off, len);\n-            }\n-        }\n+    private static void deleteFiles() throws IOException {\n+        Files.deleteIfExists(ZIP_FILE);\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/Zip64SizeTest.java","additions":114,"deletions":113,"binary":false,"changes":227,"status":"modified"}]}