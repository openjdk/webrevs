{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,3 +23,0 @@\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n@@ -27,1 +24,9 @@\n-import java.io.*;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n@@ -30,1 +35,0 @@\n-import java.util.List;\n@@ -35,1 +39,2 @@\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n@@ -39,2 +44,3 @@\n- * @bug 8226530\n- * @summary ZIP File System tests that leverage DirectoryStream\n+ * @bug 8226530 8303891\n+ * @summary Verify that ZipFile reads size fields using the Zip64 extra\n+ * field when only the 'uncompressed size' field has the ZIP64 \"magic value\" 0xFFFFFFFF\n@@ -42,1 +48,1 @@\n- * @run testng Zip64SizeTest\n+ * @run junit Zip64SizeTest\n@@ -45,2 +51,0 @@\n-\n-    private static final int BUFFER_SIZE = 2048;\n@@ -48,10 +52,9 @@\n-    private static final String ZIP_FILE_NAME = \"Zip64SizeTest.zip\";\n-    \/\/ File that will be created with a size greater than 0xFFFFFFFF\n-    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n-    \/\/ File that will be created with a size less than 0xFFFFFFFF\n-    private static final String SMALL_FILE_NAME = \"SmallZipEntry.txt\";\n-    \/\/ List of files to be added to the ZIP file\n-    private static final List<String> ZIP_ENTRIES = List.of(LARGE_FILE_NAME,\n-            SMALL_FILE_NAME);\n-    private static final long LARGE_FILE_SIZE = 5L * 1024L * 1024L * 1024L; \/\/ 5GB\n-    private static final long SMALL_FILE_SIZE = 0x100000L; \/\/ 1024L x 1024L;\n+    private static final Path ZIP_FILE = Path.of(\"Zip64SizeTest.zip\");\n+    \/\/ Contents to write to ZIP entries\n+    private static final byte[] CONTENT = \"Hello\".getBytes(StandardCharsets.UTF_8);\n+    \/\/ This opaque tag will be ignored by ZipEntry.setExtra0\n+    private static final int UNKNOWN_TAG = 0x9902;\n+    \/\/ Tag used when converting the extra field to a real ZIP64 extra field\n+    private static final short ZIP64_TAG = 0x1;\n+    \/\/ Marker value to indicate that the actual value is stored in the ZIP64 extra field\n+    private static final int ZIP64_MAGIC_VALUE = 0xFFFFFFFF;\n@@ -60,3 +63,4 @@\n-     * Validate that if the size of a ZIP entry exceeds 0xFFFFFFFF, that the\n-     * correct size is returned from the ZIP64 Extended information.\n-     * @throws IOException\n+     * Validate that if the 'uncompressed size' of a ZIP CEN header is 0xFFFFFFFF, then the\n+     * actual size is retrieved from the corresponding ZIP64 Extended information field.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n@@ -65,2 +69,1 @@\n-    private static void validateZipEntrySizes() throws IOException {\n-        createFiles();\n+    public void validateZipEntrySizes() throws IOException {\n@@ -69,2 +72,2 @@\n-        try (ZipFile zip = new ZipFile(ZIP_FILE_NAME)) {\n-            ZipEntry ze = zip.getEntry(LARGE_FILE_NAME);\n+        try (ZipFile zip = new ZipFile(ZIP_FILE.toFile())) {\n+            ZipEntry ze = zip.getEntry(\"first\");\n@@ -72,2 +75,2 @@\n-            assertTrue(ze.getSize() == LARGE_FILE_SIZE);\n-            ze = zip.getEntry(SMALL_FILE_NAME);\n+            assertEquals(CONTENT.length, ze.getSize());\n+            ze = zip.getEntry(\"second\");\n@@ -75,2 +78,1 @@\n-            assertTrue(ze.getSize() == SMALL_FILE_SIZE);\n-\n+            assertEquals(CONTENT.length, ze.getSize());\n@@ -81,2 +83,22 @@\n-     * Delete the files created for use by the test\n-     * @throws IOException if an error occurs deleting the files\n+     * Create a ZIP file with a CEN entry where the 'uncompressed size' is stored in\n+     * the ZIP64 field, but the 'compressed size' is in the CEN field. This makes the\n+     * ZIP64 data block 8 bytes long, which triggers the regression described in 8226530.\n+     *\n+     * The CEN entry for the \"first\" entry will have the following structure:\n+     * (Note the CEN 'Uncompressed Length' being 0xFFFFFFFF and the ZIP64\n+     * 'Uncompressed Size' being 5)\n+     *\n+     * 0081 CENTRAL HEADER #1     02014B50\n+     * 0085 Created Zip Spec      14 '2.0'\n+     * 0086 Created OS            00 'MS-DOS'\n+     * [...] Omitted for brevity\n+     * 0091 CRC                   F7D18982\n+     * 0095 Compressed Length     00000007\n+     * 0099 Uncompressed Length   FFFFFFFF\n+     * [...] Omitted for brevity\n+     * 00AF Filename              'first'\n+     * 00B4 Extra ID #0001        0001 'ZIP64'\n+     * 00B6   Length              0008\n+     * 00B8   Uncompressed Size   0000000000000005\n+     *\n+     * @throws IOException if an error occurs creating the ZIP File\n@@ -84,4 +106,28 @@\n-    private static void deleteFiles() throws IOException {\n-        Files.deleteIfExists(Path.of(ZIP_FILE_NAME));\n-        Files.deleteIfExists(Path.of(LARGE_FILE_NAME));\n-        Files.deleteIfExists(Path.of(SMALL_FILE_NAME));\n+    private static void createZipFile() throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ZipOutputStream zos = new ZipOutputStream(baos)) {\n+\n+            \/\/ The 'first' entry will store 'uncompressed size' in the Zip64 format\n+            ZipEntry e1 = new ZipEntry(\"first\");\n+\n+            \/\/ Make an extra field with the correct size for an 8-byte 'uncompressed size'\n+            \/\/ Zip64 field. Temporarily use the 'unknown' tag 0x9902 to make\n+            \/\/ ZipEntry.setExtra0 skip parsing this as a Zip64.\n+            \/\/ See APPNOTE.TXT, 4.6.1 Third Party Mappings\n+            byte[] opaqueExtra = createBlankExtra((short) UNKNOWN_TAG, (short) Long.BYTES);\n+            e1.setExtra(opaqueExtra);\n+\n+            zos.putNextEntry(e1);\n+            zos.write(CONTENT);\n+\n+            \/\/ A second entry, not in Zip64 format\n+            ZipEntry e2 = new ZipEntry(\"second\");\n+            zos.putNextEntry(e2);\n+            zos.write(CONTENT);\n+        }\n+\n+        byte[] zip = baos.toByteArray();\n+\n+        \/\/ Update the CEN of 'first' to use the Zip64 format\n+        updateCENHeaderToZip64(zip);\n+        Files.write(ZIP_FILE, zip);\n@@ -91,2 +137,9 @@\n-     * Create the ZIP file adding an entry whose size exceeds 0xFFFFFFFF\n-     * @throws IOException if an error occurs creating the ZIP File\n+     * Update the CEN entry of the \"first\" entry to use ZIP64 format for the\n+     * 'uncompressed size' field. The updated extra field will have the following\n+     * structure:\n+     *\n+     * 00B4 Extra ID #0001        0001 'ZIP64'\n+     * 00B6   Length              0008\n+     * 00B8   Uncompressed Size   0000000000000005\n+     *\n+     * @param zip the ZIP file to update to ZIP64\n@@ -94,19 +147,18 @@\n-    private static void createZipFile() throws IOException {\n-        try (FileOutputStream fos = new FileOutputStream(ZIP_FILE_NAME);\n-             ZipOutputStream zos = new ZipOutputStream(fos)) {\n-            System.out.printf(\"Creating Zip file: %s%n\", ZIP_FILE_NAME);\n-            for (String srcFile : ZIP_ENTRIES) {\n-                System.out.printf(\"...Adding Entry: %s%n\", srcFile);\n-                File fileToZip = new File(srcFile);\n-                try (FileInputStream fis = new FileInputStream(fileToZip)) {\n-                    ZipEntry zipEntry = new ZipEntry(fileToZip.getName());\n-                    zipEntry.setSize(fileToZip.length());\n-                    zos.putNextEntry(zipEntry);\n-                    byte[] bytes = new byte[BUFFER_SIZE];\n-                    int length;\n-                    while ((length = fis.read(bytes)) >= 0) {\n-                        zos.write(bytes, 0, length);\n-                    }\n-                }\n-            }\n-        }\n+    private static void updateCENHeaderToZip64(byte[] zip) {\n+        ByteBuffer buffer = ByteBuffer.wrap(zip).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Find the offset of the first CEN header\n+        int cenOffset = buffer.getInt(zip.length- ZipFile.ENDHDR + ZipFile.ENDOFF);\n+        \/\/ Find the offset of the extra field\n+        int nlen = buffer.getShort(cenOffset + ZipFile.CENNAM);\n+        int extraOffset = cenOffset + ZipFile.CENHDR + nlen;\n+\n+        \/\/ Change the header ID from 'unknown' to ZIP64\n+        buffer.putShort(extraOffset, ZIP64_TAG);\n+        \/\/ Update the 'uncompressed size' ZIP64 value to the actual uncompressed length\n+        int fieldOffset = extraOffset\n+                + Short.BYTES \/\/ TAG\n+                + Short.BYTES; \/\/ data size\n+        buffer.putLong(fieldOffset, CONTENT.length);\n+\n+        \/\/ Set the 'uncompressed size' field of the CEN to 0xFFFFFFFF\n+        buffer.putInt(cenOffset + ZipFile.CENLEN, ZIP64_MAGIC_VALUE);\n@@ -116,2 +168,5 @@\n-     * Create the files that will be added to the ZIP file\n-     * @throws IOException if there is a problem  creating the files\n+     * Create an extra field with the given tag and data block size, and a\n+     * blank data block.\n+     * @return an extra field with the specified tag and size\n+     * @param tag the header id of the extra field\n+     * @param blockSize the size of the extra field's data block\n@@ -119,8 +174,10 @@\n-    private static void createFiles() throws IOException {\n-        try (RandomAccessFile largeFile = new RandomAccessFile(LARGE_FILE_NAME, \"rw\");\n-             RandomAccessFile smallFile = new RandomAccessFile(SMALL_FILE_NAME, \"rw\")) {\n-            System.out.printf(\"Creating %s%n\", LARGE_FILE_NAME);\n-            largeFile.setLength(LARGE_FILE_SIZE);\n-            System.out.printf(\"Creating %s%n\", SMALL_FILE_NAME);\n-            smallFile.setLength(SMALL_FILE_SIZE);\n-        }\n+    private static byte[] createBlankExtra(short tag, short blockSize) {\n+        int size = Short.BYTES  \/\/ tag\n+                + Short.BYTES   \/\/ data block size\n+                + blockSize;   \/\/ data block;\n+\n+        byte[] extra = new byte[size];\n+        ByteBuffer.wrap(extra).order(ByteOrder.LITTLE_ENDIAN)\n+                .putShort(0, tag)\n+                .putShort(Short.BYTES, blockSize);\n+        return extra;\n@@ -133,1 +190,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -142,1 +199,1 @@\n-    @AfterMethod\n+    @AfterEach\n@@ -146,0 +203,8 @@\n+\n+    \/**\n+     * Delete the files created for use by the test\n+     * @throws IOException if an error occurs deleting the files\n+     *\/\n+    private static void deleteFiles() throws IOException {\n+        Files.deleteIfExists(ZIP_FILE);\n+    }\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/Zip64SizeTest.java","additions":137,"deletions":72,"binary":false,"changes":209,"status":"modified"}]}