{"files":[{"patch":"@@ -466,0 +466,21 @@\n+    \/\/ Optimization for enum sets -- all package-private\n+\n+    boolean isRegularEnumSetCompatible() {\n+        return false;\n+    }\n+\n+    boolean isJumboEnumSetCompatible() {\n+        return false;\n+    }\n+\n+    Class<E> enumElementType() {\n+        throw new InternalError(\"cannot be called\");\n+    }\n+\n+    long regularEnumElements() {\n+        throw new InternalError(\"cannot be called\");\n+    }\n+\n+    long[] jumboEnumElements() {\n+        throw new InternalError(\"cannot be called\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractCollection.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1046,1 +1046,1 @@\n-    static class UnmodifiableCollection<E> implements Collection<E>, Serializable {\n+    static class UnmodifiableCollection<E> extends AbstractCollection<E> implements Serializable {\n@@ -1167,0 +1167,40 @@\n+\n+        @Override\n+        boolean isRegularEnumSetCompatible() {\n+            return getClass() == UnmodifiableSet.class\n+                && c instanceof AbstractCollection<?> ac && ac.isRegularEnumSetCompatible();\n+        }\n+\n+        @Override\n+        boolean isJumboEnumSetCompatible() {\n+            return getClass() == UnmodifiableSet.class\n+                && c instanceof AbstractCollection<?> ac && ac.isJumboEnumSetCompatible();\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        Class<E> enumElementType() {\n+            if (getClass() == UnmodifiableSet.class && c instanceof AbstractCollection<?> ac) {\n+                return (Class<E>)ac.enumElementType();\n+            } else {\n+                throw new InternalError(\"cannot be called\");\n+            }\n+        }\n+\n+        @Override\n+        long regularEnumElements() {\n+            if (getClass() == UnmodifiableSet.class && c instanceof AbstractCollection<?> ac) {\n+                return ac.regularEnumElements();\n+            } else {\n+                throw new InternalError(\"cannot be called\");\n+            }\n+        }\n+\n+        @Override\n+        long[] jumboEnumElements() {\n+            if (getClass() == UnmodifiableSet.class && c instanceof AbstractCollection<?> ac) {\n+                return ac.jumboEnumElements();\n+            } else {\n+                throw new InternalError(\"cannot be called\");\n+            }\n+        }\n@@ -2078,1 +2118,1 @@\n-    static class SynchronizedCollection<E> implements Collection<E>, Serializable {\n+    static class SynchronizedCollection<E> extends AbstractCollection<E> implements Serializable {\n@@ -2231,0 +2271,44 @@\n+\n+        @Override\n+        boolean isRegularEnumSetCompatible() {\n+            return getClass() == SynchronizedSet.class\n+                && c instanceof AbstractCollection<?> ac && ac.isRegularEnumSetCompatible();\n+        }\n+\n+        @Override\n+        boolean isJumboEnumSetCompatible() {\n+            return getClass() == SynchronizedSet.class\n+                && c instanceof AbstractCollection<?> ac && ac.isJumboEnumSetCompatible();\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        Class<E> enumElementType() {\n+            if (getClass() == SynchronizedSet.class && c instanceof AbstractCollection<?> ac) {\n+                return (Class<E>)ac.enumElementType();\n+            } else {\n+                throw new InternalError(\"cannot be called\");\n+            }\n+        }\n+\n+        @Override\n+        long regularEnumElements() {\n+            if (getClass() == SynchronizedSet.class && c instanceof AbstractCollection<?> ac) {\n+                synchronized (mutex) {\n+                    return ac.regularEnumElements();\n+                }\n+            } else {\n+                throw new InternalError(\"cannot be called\");\n+            }\n+        }\n+\n+        @Override\n+        long[] jumboEnumElements() {\n+            if (getClass() == SynchronizedSet.class && c instanceof AbstractCollection<?> ac) {\n+                synchronized (mutex) {\n+                    return ac.jumboEnumElements().clone();\n+                }\n+            } else {\n+                throw new InternalError(\"cannot be called\");\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":86,"deletions":2,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+        \/\/ Only treat empty EnumSets specially for compatibility.\n@@ -181,2 +182,1 @@\n-            while (i.hasNext())\n-                result.add(i.next());\n+            result.addAll(c);   \/\/ optimized for compatible sets\n@@ -413,0 +413,5 @@\n+    @Override\n+    Class<E> enumElementType() {\n+        return elementType;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/EnumSet.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.access.JavaLangAccess;\n@@ -893,0 +894,39 @@\n+    \/**\n+     * Creates a new Set from an untrusted array and checking for and\n+     * rejecting null and duplicate elements.\n+     *\n+     * @param <E> the Set's element type\n+     * @param input the non-empty input array\n+     * @return the new set\n+     *\/\n+    @SafeVarargs\n+    @SuppressWarnings({\"unchecked\", \"varargs\"})\n+    static <E> Set<E> setFromArray(E... input) {\n+        \/\/ assert input.length > 2;\n+        if (!(input[0] instanceof Enum<?> enum0)) {\n+            return new SetN<>(input);\n+        }\n+        @SuppressWarnings(\"rawtypes\")\n+        EnumSet es = EnumSet.<Enum>of(enum0);\n+        Class<?> esElementType = es.elementType;\n+        for (int i = 1; i < input.length; i++) {\n+            Object element = input[i];\n+            if (element == null) {\n+                throw new NullPointerException();\n+            }\n+            if (!esElementType.isInstance(element)) {\n+                return new SetN<>(input);\n+            }\n+            if (!es.add(element)) {\n+                throw new IllegalArgumentException(\"duplicate element: \" + element);\n+            }\n+        }\n+        if (es instanceof RegularEnumSet<?> res) {\n+            return (Set<E>)new ImmutableRegularEnumSet<>(res.regularEnumElements(), res.enumElementType());\n+        }\n+        if (es instanceof JumboEnumSet<?> jes) {\n+            return (Set<E>)new ImmutableJumboEnumSet<>(jes.jumboEnumElements(), jes.enumElementType(), jes.size());\n+        }\n+        \/\/ Should not be reached here. This is a fallback.\n+        return new SetN<>(input);\n+    }\n@@ -1065,0 +1105,269 @@\n+    @jdk.internal.ValueBased\n+    abstract static sealed class AbstractImmutableEnumSet<E extends Enum<E>> extends AbstractImmutableSet<E>\n+            implements Serializable permits ImmutableRegularEnumSet, ImmutableJumboEnumSet {\n+        static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+        @Stable\n+        final Class<E> elementType;\n+\n+        AbstractImmutableEnumSet(Class<E> elementType) {\n+            this.elementType = elementType;\n+        }\n+\n+        @Override\n+        final Class<E> enumElementType() {\n+            return elementType;\n+        }\n+\n+        abstract boolean containsOrdinal(int ordinal);\n+\n+        @Override\n+        public final boolean contains(Object e) {\n+            if (e == null)\n+                throw new NullPointerException();\n+            Class<?> eClass = e.getClass();\n+            if (eClass != elementType && eClass.getSuperclass() != elementType)\n+                return false;\n+\n+            return containsOrdinal(((Enum<?>)e).ordinal());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = 0;\n+            for (Object o : this) {\n+                h += o.hashCode();\n+            }\n+            return h;\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            Object[] result = new Object[size()];\n+            int i = 0;\n+            for (Object o : this) {\n+                result[i++] = o;\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] a) {\n+            int size = size();\n+            T[] result = a.length >= size ? a :\n+                    (T[])Array.newInstance(a.getClass().getComponentType(), size);\n+            int i = 0;\n+            for (Object o : this) {\n+                result[i++] = (T)o;\n+            }\n+            if (result.length > size) {\n+                result[i] = null;\n+            }\n+            return result;\n+        }\n+    }\n+\n+    @jdk.internal.ValueBased\n+    static final class ImmutableRegularEnumSet<E extends Enum<E>> extends AbstractImmutableEnumSet<E>\n+            implements Serializable {\n+        @Stable\n+        final long elements;\n+\n+        ImmutableRegularEnumSet(long elements, Class<E> elementType) {\n+            super(elementType);\n+            this.elements = elements;\n+        }\n+\n+        @Override\n+        boolean isRegularEnumSetCompatible() {\n+            return true;\n+        }\n+\n+        @Override\n+        long regularEnumElements() {\n+            return elements;\n+        }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return new ImmutableRESIterator();\n+        }\n+\n+        private final class ImmutableRESIterator implements Iterator<E> {\n+            long unseen = elements;\n+            long lastReturned = 0;\n+            final Enum<?>[] universe = JLA.getEnumConstantsShared(elementType);\n+\n+            @Override\n+            public boolean hasNext() {\n+                return unseen != 0;\n+            }\n+\n+            @Override\n+            @SuppressWarnings(\"unchecked\")\n+            public E next() {\n+                if (unseen == 0)\n+                    throw new NoSuchElementException();\n+                lastReturned = unseen & -unseen;\n+                unseen -= lastReturned;\n+                return (E) universe[Long.numberOfTrailingZeros(lastReturned)];\n+            }\n+        }\n+\n+        @Override\n+        public int size() {\n+            return Long.bitCount(elements);\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return elements == 0;\n+        }\n+\n+        @Override\n+        boolean containsOrdinal(int ordinal) {\n+            return (elements & (1L << ordinal)) != 0;\n+        }\n+\n+        @Override\n+        public boolean containsAll(Collection<?> c) {\n+            if (c instanceof AbstractCollection<?> ac && ac.isRegularEnumSetCompatible()) {\n+                if (ac.enumElementType() != elementType)\n+                    return ac.isEmpty();\n+\n+                return (ac.regularEnumElements() & ~elements) == 0;\n+            } else {\n+                return super.containsAll(c);\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof AbstractCollection<?> ac && ac.isRegularEnumSetCompatible()))\n+                return super.equals(o);\n+\n+            if (ac.enumElementType() != elementType)\n+                return elements == 0 && ac.regularEnumElements() == 0;\n+            return ac.regularEnumElements() == elements;\n+        }\n+\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+            throw new InvalidObjectException(\"not serial proxy\");\n+        }\n+\n+        @java.io.Serial\n+        private Object writeReplace() {\n+            return new CollSer(CollSer.IMM_SET, toArray());\n+        }\n+    }\n+\n+    @jdk.internal.ValueBased\n+    static final class ImmutableJumboEnumSet<E extends Enum<E>> extends AbstractImmutableEnumSet<E>\n+            implements Serializable {\n+        @Stable\n+        final long[] elements;\n+\n+        @Stable\n+        final int size;\n+\n+        ImmutableJumboEnumSet(long[] elements, Class<E> elementType, int size) {\n+            super(elementType);\n+            this.elements = elements;\n+            this.size = size;\n+        }\n+\n+        boolean isJumboEnumSetCompatible() {\n+            return true;\n+        }    \n+\n+        @Override\n+        long[] jumboEnumElements() {\n+            return elements;\n+        }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return new ImmutableJESIterator();\n+        }\n+\n+        private final class ImmutableJESIterator implements Iterator<E> {\n+            long unseen = elements[0];\n+            int unseenIndex = 0;\n+            long lastReturned = 0;\n+            int lastReturnedIndex = 0;\n+            final Enum<?>[] universe = JLA.getEnumConstantsShared(elementType);\n+\n+            @Override\n+            public boolean hasNext() {\n+                while (unseen == 0 && unseenIndex < elements.length - 1)\n+                    unseen = elements[++unseenIndex];\n+                return unseen != 0;\n+            }\n+\n+            @Override\n+            @SuppressWarnings(\"unchecked\")\n+            public E next() {\n+                if (!hasNext())\n+                    throw new NoSuchElementException();\n+                lastReturned = unseen & -unseen;\n+                lastReturnedIndex = unseenIndex;\n+                unseen -= lastReturned;\n+                return (E) universe[(lastReturnedIndex << 6)\n+                                    + Long.numberOfTrailingZeros(lastReturned)];\n+            }\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return size == 0L;\n+        }\n+\n+        @Override\n+        boolean containsOrdinal(int ordinal) {\n+            return (elements[ordinal >>> 6] & (1L << ordinal)) != 0;\n+        }\n+\n+        @Override\n+        public boolean containsAll(Collection<?> c) {\n+            if (!(c instanceof AbstractCollection<?> ac && ac.isJumboEnumSetCompatible()))\n+                return super.containsAll(c);\n+\n+            if (ac.enumElementType() != elementType)\n+                return ac.isEmpty();\n+\n+            long[] esElements = ac.jumboEnumElements();\n+            for (int i = 0; i < elements.length; i++)\n+                if ((esElements[i] & ~elements[i]) != 0)\n+                    return false;\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof AbstractCollection<?> ac && ac.isJumboEnumSetCompatible()))\n+                return super.equals(o);\n+\n+            if (ac.enumElementType() != elementType)\n+                return size == 0 && ac.size() == 0;\n+\n+            return Arrays.equals(ac.jumboEnumElements(), elements);\n+        }\n+\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+            throw new InvalidObjectException(\"not serial proxy\");\n+        }\n+\n+        @java.io.Serial\n+        private Object writeReplace() {\n+            return new CollSer(CollSer.IMM_SET, toArray());\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":309,"deletions":0,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -47,0 +47,10 @@\n+    @Override\n+    boolean isJumboEnumSetCompatible() {\n+        return true;\n+    }\n+\n+    @Override\n+    long[] jumboEnumElements() {\n+        return elements;\n+    }\n+\n@@ -251,1 +261,1 @@\n-        if (!(c instanceof JumboEnumSet<?> es))\n+        if (!(c instanceof AbstractCollection<?> ac && ac.isJumboEnumSetCompatible()))\n@@ -254,2 +264,2 @@\n-        if (es.elementType != elementType)\n-            return es.isEmpty();\n+        if (ac.enumElementType() != elementType)\n+            return ac.isEmpty();\n@@ -257,0 +267,1 @@\n+        long[] esElements = ac.jumboEnumElements();\n@@ -258,1 +269,1 @@\n-            if ((es.elements[i] & ~elements[i]) != 0)\n+            if ((esElements[i] & ~elements[i]) != 0)\n@@ -272,1 +283,1 @@\n-        if (!(c instanceof JumboEnumSet<?> es))\n+        if (!(c instanceof AbstractCollection<?> ac && ac.isJumboEnumSetCompatible()))\n@@ -275,2 +286,2 @@\n-        if (es.elementType != elementType) {\n-            if (es.isEmpty())\n+        if (ac.enumElementType() != elementType) {\n+            if (ac.isEmpty())\n@@ -280,1 +291,1 @@\n-                    es.elementType + \" != \" + elementType);\n+                    ac.enumElementType() + \" != \" + elementType);\n@@ -283,0 +294,1 @@\n+        long[] esElements = ac.jumboEnumElements();\n@@ -284,1 +296,1 @@\n-            elements[i] |= es.elements[i];\n+            elements[i] |= esElements[i];\n@@ -297,1 +309,1 @@\n-        if (!(c instanceof JumboEnumSet<?> es))\n+        if (!(c instanceof AbstractCollection<?> ac && ac.isJumboEnumSetCompatible()))\n@@ -300,1 +312,1 @@\n-        if (es.elementType != elementType)\n+        if (ac.enumElementType() != elementType)\n@@ -303,0 +315,1 @@\n+        long[] esElements = ac.jumboEnumElements();\n@@ -304,1 +317,1 @@\n-            elements[i] &= ~es.elements[i];\n+            elements[i] &= ~esElements[i];\n@@ -317,1 +330,1 @@\n-        if (!(c instanceof JumboEnumSet<?> es))\n+        if (!(c instanceof AbstractCollection<?> ac && ac.isJumboEnumSetCompatible()))\n@@ -320,1 +333,1 @@\n-        if (es.elementType != elementType) {\n+        if (ac.enumElementType() != elementType) {\n@@ -326,0 +339,1 @@\n+        long[] esElements = ac.jumboEnumElements();\n@@ -327,1 +341,1 @@\n-            elements[i] &= es.elements[i];\n+            elements[i] &= esElements[i];\n@@ -349,1 +363,1 @@\n-        if (!(o instanceof JumboEnumSet<?> es))\n+        if (!(o instanceof AbstractCollection<?> ac && ac.isJumboEnumSetCompatible()))\n@@ -352,2 +366,2 @@\n-        if (es.elementType != elementType)\n-            return size == 0 && es.size == 0;\n+        if (ac.enumElementType() != elementType)\n+            return size == 0 && ac.size() == 0;\n@@ -355,1 +369,1 @@\n-        return Arrays.equals(es.elements, elements);\n+        return Arrays.equals(ac.jumboEnumElements(), elements);\n","filename":"src\/java.base\/share\/classes\/java\/util\/JumboEnumSet.java","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,10 @@\n+    @Override\n+    boolean isRegularEnumSetCompatible() {\n+        return true;\n+    }\n+\n+    @Override\n+    long regularEnumElements() {\n+        return elements;\n+    }\n+\n@@ -199,1 +209,1 @@\n-        if (!(c instanceof RegularEnumSet<?> es))\n+        if (!(c instanceof AbstractCollection<?> ac && ac.isRegularEnumSetCompatible()))\n@@ -202,2 +212,2 @@\n-        if (es.elementType != elementType)\n-            return es.isEmpty();\n+        if (ac.enumElementType() != elementType)\n+            return ac.isEmpty();\n@@ -205,1 +215,1 @@\n-        return (es.elements & ~elements) == 0;\n+        return (ac.regularEnumElements() & ~elements) == 0;\n@@ -217,1 +227,1 @@\n-        if (!(c instanceof RegularEnumSet<?> es))\n+        if (!(c instanceof AbstractCollection<?> ac && ac.isRegularEnumSetCompatible()))\n@@ -220,2 +230,2 @@\n-        if (es.elementType != elementType) {\n-            if (es.isEmpty())\n+        if (ac.enumElementType() != elementType) {\n+            if (ac.isEmpty())\n@@ -225,1 +235,1 @@\n-                    es.elementType + \" != \" + elementType);\n+                    ac.enumElementType() + \" != \" + elementType);\n@@ -229,1 +239,1 @@\n-        elements |= es.elements;\n+        elements |= ac.regularEnumElements();\n@@ -242,1 +252,1 @@\n-        if (!(c instanceof RegularEnumSet<?> es))\n+        if (!(c instanceof AbstractCollection<?> ac && ac.isRegularEnumSetCompatible()))\n@@ -245,1 +255,1 @@\n-        if (es.elementType != elementType)\n+        if (ac.enumElementType() != elementType)\n@@ -249,1 +259,1 @@\n-        elements &= ~es.elements;\n+        elements &= ~ac.regularEnumElements();\n@@ -262,1 +272,1 @@\n-        if (!(c instanceof RegularEnumSet<?> es))\n+        if (!(c instanceof AbstractCollection<?> ac && ac.isRegularEnumSetCompatible()))\n@@ -265,1 +275,1 @@\n-        if (es.elementType != elementType) {\n+        if (ac.enumElementType() != elementType) {\n@@ -272,1 +282,1 @@\n-        elements &= es.elements;\n+        elements &= ac.regularEnumElements();\n@@ -293,1 +303,1 @@\n-        if (!(o instanceof RegularEnumSet<?> es))\n+        if (!(o instanceof AbstractCollection<?> ac && ac.isRegularEnumSetCompatible()))\n@@ -296,3 +306,3 @@\n-        if (es.elementType != elementType)\n-            return elements == 0 && es.elements == 0;\n-        return es.elements == elements;\n+        if (ac.enumElementType() != elementType)\n+            return elements == 0 && ac.regularEnumElements() == 0;\n+        return ac.regularEnumElements() == elements;\n","filename":"src\/java.base\/share\/classes\/java\/util\/RegularEnumSet.java","additions":30,"deletions":20,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3);\n+        return ImmutableCollections.setFromArray(e1, e2, e3);\n@@ -524,1 +524,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4);\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4);\n@@ -544,1 +544,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5);\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5);\n@@ -565,1 +565,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5,\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5,\n@@ -588,1 +588,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5,\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5,\n@@ -612,1 +612,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5,\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5,\n@@ -637,1 +637,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5,\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5,\n@@ -663,1 +663,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5,\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5,\n@@ -706,1 +706,1 @@\n-                return new ImmutableCollections.SetN<>(elements);\n+                return ImmutableCollections.setFromArray(elements);\n@@ -727,1 +727,1 @@\n-    @SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@@ -731,1 +731,2 @@\n-        } else if (coll.isEmpty()) { \/\/ Implicit nullcheck of coll\n+        }\n+        if (coll.isEmpty()) {\n@@ -733,2 +734,0 @@\n-        } else {\n-            return (Set<E>)Set.of(new HashSet<>(coll).toArray());\n@@ -736,0 +735,11 @@\n+        if (coll instanceof AbstractCollection<?> ac && ac.size() > 2) {\n+            if (ac.isRegularEnumSetCompatible()) {\n+                return (Set<E>)\n+                    new ImmutableCollections.ImmutableRegularEnumSet(ac.regularEnumElements(), ac.enumElementType());\n+            }\n+            if (ac.isJumboEnumSetCompatible()) {\n+                return (Set<E>)\n+                    new ImmutableCollections.ImmutableJumboEnumSet(ac.jumboEnumElements().clone(), ac.enumElementType(), ac.size());\n+            }\n+        }\n+        return (Set<E>)Set.of(new HashSet<>(coll).toArray());\n","filename":"src\/java.base\/share\/classes\/java\/util\/Set.java","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.EnumSet;\n@@ -51,1 +52,1 @@\n- * @bug 8048330\n+ * @bug 8048330 8302818\n@@ -73,1 +74,2 @@\n-    static Set<String> hashSetOf(String... args) {\n+    @SafeVarargs\n+    static <E> Set<E> hashSetOf(E... args) {\n@@ -345,0 +347,72 @@\n+\n+    \/\/ Test enum elements\n+\n+    enum Enum1 {\n+        E0, E1, E2, E3, E4, E5, E6, E7, E8, E9\n+    }\n+\n+    enum Enum2 {\n+        E0, E1, E2, E3, E4, E5, E6, E7, E8, E9,\n+        E10, E11, E12, E13, E14, E15, E16, E17, E18, E19,\n+        E20, E21, E22, E23, E24, E25, E26, E27, E28, E29,\n+        E30, E31, E32, E33, E34, E35, E36, E37, E38, E39,\n+        E40, E41, E42, E43, E44, E45, E46, E47, E48, E49,\n+        E50, E51, E52, E53, E54, E55, E56, E57, E58, E59,\n+        E60, E61, E62, E63, E64, E65, E66, E67, E68, E69,\n+        E70, E71, E72, E73, E74, E75, E76, E77, E78, E79\n+    }\n+\n+    @Test\n+    public void setOfPureLittleEnums() {\n+        Set<Enum1> set = Set.of(Enum1.E0, Enum1.E1, Enum1.E2, Enum1.E3);\n+        assertEquals(set, EnumSet.of(Enum1.E0, Enum1.E1, Enum1.E2, Enum1.E3));\n+        assertTrue(set.contains(Enum1.E0));\n+        assertFalse(set.contains(Enum1.E4));\n+        assertFalse(set.contains(Enum2.E0));\n+        assertFalse(set.contains(\"I'm not a enum\"));\n+    }\n+\n+    @Test\n+    public void setOfPureBigEnums() {\n+        Set<Enum2> set = Set.of(Enum2.E0, Enum2.E1, Enum2.E2, Enum2.E3, Enum2.E4,\n+                Enum2.E5, Enum2.E6, Enum2.E7, Enum2.E8, Enum2.E9,\n+                Enum2.E10, Enum2.E11, Enum2.E12, Enum2.E13, Enum2.E14,\n+                Enum2.E15, Enum2.E16, Enum2.E17, Enum2.E18, Enum2.E19);\n+        assertEquals(set, EnumSet.of(Enum2.E0, Enum2.E1, Enum2.E2, Enum2.E3, Enum2.E4,\n+                Enum2.E5, Enum2.E6, Enum2.E7, Enum2.E8, Enum2.E9, Enum2.E10,\n+                Enum2.E11, Enum2.E12, Enum2.E13, Enum2.E14, Enum2.E15,\n+                Enum2.E16, Enum2.E17, Enum2.E18, Enum2.E19));\n+        assertTrue(set.contains(Enum2.E0));\n+        assertFalse(set.contains(Enum2.E20));\n+        assertFalse(set.contains(Enum1.E0));\n+        assertFalse(set.contains(\"I'm not a enum\"));\n+    }\n+\n+    @Test\n+    public void setOfDifferentEnums() {\n+        Object[] objs = {Enum1.E0, Enum1.E1, Enum2.E0, Enum2.E1};\n+        Set<Object> set = Set.of(objs);\n+        assertEquals(set, hashSetOf(objs));\n+    }\n+\n+    @Test\n+    public void setOfEnumsAndRegularObjects() {\n+        Object[] objs = {Enum1.E0, Enum2.E1, Integer.valueOf(42), \"I'm not a enum either\"};\n+        Set<Object> set = Set.of(objs);\n+        assertEquals(set, hashSetOf(objs));\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class)\n+    public void enumDupsDisallowed1() {\n+        Set<Enum1> set = Set.of(Enum1.E0, Enum1.E1, Enum1.E0);\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class)\n+    public void enumDupsDisallowed2() {\n+        Set<Enum2> set = Set.of(Enum2.E0, Enum2.E1, Enum2.E0);\n+    }\n+\n+    @Test(expectedExceptions=NullPointerException.class)\n+    public void enumNullsDisallowed() {\n+        Set<Enum2> set = Set.of(Enum2.E0, Enum2.E1, null, Enum2.E2);\n+    }\n","filename":"test\/jdk\/java\/util\/Collection\/SetFactories.java","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"}]}