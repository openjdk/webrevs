{"files":[{"patch":"@@ -2529,1 +2529,1 @@\n-  MoveAndUpdateClosure cl(mark_bitmap(), cm, region_idx);\n+  MoveAndUpdateClosure cl(mark_bitmap(), region_idx);\n@@ -2543,1 +2543,1 @@\n-    MoveAndUpdateClosure cl(mark_bitmap(), cm, region_idx);\n+    MoveAndUpdateClosure cl(mark_bitmap(), region_idx);\n@@ -2630,1 +2630,1 @@\n-ParMarkBitMapClosure::IterationStatus\n+MoveAndUpdateClosure::IterationStatus\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -589,69 +589,0 @@\n-class ParMarkBitMapClosure: public StackObj {\n- public:\n-  typedef ParMarkBitMap::idx_t idx_t;\n-  typedef ParMarkBitMap::IterationStatus IterationStatus;\n-\n- public:\n-  inline ParMarkBitMapClosure(ParMarkBitMap* mbm, ParCompactionManager* cm,\n-                              size_t words = max_uintx);\n-\n-  inline ParCompactionManager* compaction_manager() const;\n-  inline ParMarkBitMap*        bitmap() const;\n-  inline size_t                words_remaining() const;\n-  inline bool                  is_full() const;\n-  inline HeapWord*             source() const;\n-\n-  inline void                  set_source(HeapWord* addr);\n-\n-  virtual IterationStatus do_addr(HeapWord* addr, size_t words) = 0;\n-\n- protected:\n-  inline void decrement_words_remaining(size_t words);\n-\n- private:\n-  ParMarkBitMap* const        _bitmap;\n-  ParCompactionManager* const _compaction_manager;\n-  size_t                      _words_remaining; \/\/ Words left to copy.\n-\n- protected:\n-  HeapWord*                   _source;          \/\/ Next addr that would be read.\n-};\n-\n-inline\n-ParMarkBitMapClosure::ParMarkBitMapClosure(ParMarkBitMap* bitmap,\n-                                           ParCompactionManager* cm,\n-                                           size_t words):\n-  _bitmap(bitmap), _compaction_manager(cm)\n-{\n-  _words_remaining = words;\n-  _source = nullptr;\n-}\n-\n-inline ParCompactionManager* ParMarkBitMapClosure::compaction_manager() const {\n-  return _compaction_manager;\n-}\n-\n-inline ParMarkBitMap* ParMarkBitMapClosure::bitmap() const {\n-  return _bitmap;\n-}\n-\n-inline size_t ParMarkBitMapClosure::words_remaining() const {\n-  return _words_remaining;\n-}\n-\n-inline bool ParMarkBitMapClosure::is_full() const {\n-  return words_remaining() == 0;\n-}\n-\n-inline HeapWord* ParMarkBitMapClosure::source() const {\n-  return _source;\n-}\n-\n-inline void ParMarkBitMapClosure::set_source(HeapWord* addr) {\n-  _source = addr;\n-}\n-\n-inline void ParMarkBitMapClosure::decrement_words_remaining(size_t words) {\n-  assert(_words_remaining >= words, \"processed too many words\");\n-  _words_remaining -= words;\n-}\n@@ -958,1 +889,4 @@\n-class MoveAndUpdateClosure: public ParMarkBitMapClosure {\n+class MoveAndUpdateClosure: public StackObj {\n+ private:\n+  ParMarkBitMap* const        _bitmap;\n+  size_t                      _words_remaining; \/\/ Words left to copy.\n@@ -960,0 +894,11 @@\n+\n+ protected:\n+  HeapWord*               _source;          \/\/ Next addr that would be read.\n+  HeapWord*               _destination;     \/\/ Next addr to be written.\n+  ObjectStartArray* const _start_array;\n+  size_t                  _offset;\n+\n+  inline void decrement_words_remaining(size_t words);\n+  \/\/ Update variables to indicate that word_count words were processed.\n+  inline void update_state(size_t words);\n+\n@@ -961,2 +906,2 @@\n-  inline MoveAndUpdateClosure(ParMarkBitMap* bitmap, ParCompactionManager* cm,\n-                              size_t region);\n+  typedef ParMarkBitMap::idx_t idx_t;\n+  typedef ParMarkBitMap::IterationStatus IterationStatus;\n@@ -964,3 +909,6 @@\n-  \/\/ Accessors.\n-  HeapWord* destination() const         { return _destination; }\n-  HeapWord* copy_destination() const    { return _destination + _offset; }\n+  ParMarkBitMap*        bitmap() const { return _bitmap; }\n+\n+  size_t    words_remaining()    const { return _words_remaining; }\n+  bool      is_full()            const { return _words_remaining == 0; }\n+  HeapWord* source()             const { return _source; }\n+  void      set_source(HeapWord* addr) { _source = addr; }\n@@ -972,1 +920,7 @@\n-  IterationStatus do_addr(HeapWord* addr, size_t size);\n+  virtual IterationStatus do_addr(HeapWord* addr, size_t words);\n+\n+  inline MoveAndUpdateClosure(ParMarkBitMap* bitmap, size_t region);\n+\n+  \/\/ Accessors.\n+  HeapWord* destination() const         { return _destination; }\n+  HeapWord* copy_destination() const    { return _destination + _offset; }\n@@ -981,9 +935,0 @@\n-\n-protected:\n-  \/\/ Update variables to indicate that word_count words were processed.\n-  inline void update_state(size_t word_count);\n-\n- protected:\n-  HeapWord*               _destination;         \/\/ Next addr to be written.\n-  ObjectStartArray* const _start_array;\n-  size_t                  _offset;\n@@ -992,0 +937,5 @@\n+inline void MoveAndUpdateClosure::decrement_words_remaining(size_t words) {\n+  assert(_words_remaining >= words, \"processed too many words\");\n+  _words_remaining -= words;\n+}\n+\n@@ -1002,4 +952,4 @@\n-MoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap,\n-                                           ParCompactionManager* cm,\n-                                           size_t region_idx) :\n-  ParMarkBitMapClosure(bitmap, cm, calculate_words_remaining(region_idx)),\n+MoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap, size_t region_idx) :\n+  _bitmap(bitmap),\n+  _words_remaining(calculate_words_remaining(region_idx)),\n+  _source(nullptr),\n@@ -1008,2 +958,1 @@\n-  _offset(0) { }\n-\n+  _offset(0) {}\n@@ -1043,1 +992,1 @@\n-  MoveAndUpdateClosure(bitmap, cm, region),\n+  MoveAndUpdateClosure(bitmap, region),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":41,"deletions":92,"binary":false,"changes":133,"status":"modified"}]}