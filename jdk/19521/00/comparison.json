{"files":[{"patch":"@@ -0,0 +1,371 @@\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Component;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.Scrollbar;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+import java.awt.event.InputEvent;\n+import java.util.ArrayList;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8333403\n+ * @summary Test performs various operations to check components events are triggered properly.\n+ * @run main ComponentEventTest\n+ *\/\n+public class ComponentEventTest {\n+\n+    private static Frame frame;\n+    private static Component[] components;\n+    private static boolean componentHidden = false;\n+    private static boolean componentShown = false;\n+    private static boolean componentMoved = false;\n+    private static boolean componentResized = false;\n+    private static ArrayList<ComponentEvent> events =\n+        new ArrayList<ComponentEvent>();\n+\n+    private static final ComponentListener componentListener =\n+        new ComponentListener() {\n+\n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                System.out.println(\"ComponentShown: \" + e.getSource());\n+                componentShown = true;\n+                events.add(e);\n+            }\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                System.out.println(\"ComponentResized: \" + e.getSource());\n+                componentResized = true;\n+                events.add(e);\n+            }\n+\n+            @Override\n+            public void componentMoved(ComponentEvent e) {\n+                System.out.println(\"ComponentMoved: \" + e.getSource());\n+                componentMoved = true;\n+                events.add(e);\n+            }\n+\n+            @Override\n+            public void componentHidden(ComponentEvent e) {\n+                System.out.println(\"ComponentHidden: \" + e.getSource());\n+                componentHidden = true;\n+                events.add(e);\n+            }\n+        };\n+\n+    private static void initializeGUI() {\n+        frame = new Frame(\"Component Event Test\");\n+        frame.setLayout(new FlowLayout());\n+\n+        Panel panel = new Panel();\n+        Button button = new Button(\"Button\");\n+        Label label = new Label(\"Label\");\n+        List list = new List();\n+        list.add(\"One\");\n+        list.add(\"Two\");\n+        list.add(\"Three\");\n+        Choice choice = new Choice();\n+        choice.add(\"Red\");\n+        choice.add(\"Orange\");\n+        choice.add(\"Yellow\");\n+        Checkbox checkbox = new Checkbox(\"Checkbox\");\n+        Scrollbar scrollbar = new Scrollbar(Scrollbar.HORIZONTAL, 0, 1, 0, 255);\n+        TextField textfield = new TextField(15);\n+        TextArea textarea = new TextArea(5, 15);\n+\n+        components = new Component[] { panel, button, label, list, choice,\n+            checkbox, scrollbar, textfield, textarea, frame };\n+\n+        for (int i = 0; i < components.length - 1; i++) {\n+            components[i].addComponentListener(componentListener);\n+            frame.add(components[i]);\n+        }\n+        frame.addComponentListener(componentListener);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.setAutoWaitForIdle(true);\n+\n+            EventQueue.invokeAndWait(ComponentEventTest::initializeGUI);\n+            robot.waitForIdle();\n+\n+            robot.mouseMove(\n+                components[0].getLocationOnScreen().x\n+                    + components[0].getSize().width \/ 2,\n+                components[0].getLocationOnScreen().y\n+                    + components[0].getSize().height \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            \/\/ Hide all components and check if the ComponentEvent is triggered\n+            for (int i = 0; i < components.length; i++) {\n+                Component currentComponent = components[i];\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setVisible(false);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (!componentHidden) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentHidden not triggered for \"\n+                            + currentComponent.getClass());\n+                }\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setVisible(false);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (componentHidden) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentHidden triggered when setVisible(false) \"\n+                            + \"called for a hidden \"\n+                            + components[i].getClass());\n+                }\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setVisible(true);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (!componentShown) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentShown not triggered for \"\n+                            + components[i].getClass());\n+                }\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setVisible(true);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (componentShown) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentShown triggered when setVisible(true) \"\n+                            + \"called for a shown \" + components[i].getClass());\n+                }\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setLocation(\n+                        currentComponent.getLocation().x + 1,\n+                        currentComponent.getLocation().y);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (!componentMoved) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentMoved not triggered for \"\n+                            + components[i].getClass());\n+                }\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setSize(\n+                        currentComponent.getSize().width + 1,\n+                        currentComponent.getSize().height);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (!componentResized) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentResized not triggered for \"\n+                            + components[i].getClass());\n+                }\n+\n+                \/\/ Disable the components and do the same set of operations\n+\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setEnabled(false);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+                robot.waitForIdle();\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setVisible(false);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (!componentHidden) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentHidden not triggered for disabled \"\n+                            + components[i].getClass());\n+                }\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setVisible(false);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (componentHidden) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentHidden triggered when setVisible(false) \"\n+                            + \"called for a hidden disabled \"\n+                            + components[i].getClass());\n+                }\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setVisible(true);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (!componentShown) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentShown not triggered for disabled \"\n+                            + components[i].getClass());\n+                }\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setVisible(true);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (componentShown) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentShown triggered when setVisible(true) \"\n+                            + \"called for a shown disabled \"\n+                            + components[i].getClass());\n+                }\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setLocation(\n+                        currentComponent.getLocation().x - 1,\n+                        currentComponent.getLocation().y);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (!componentMoved) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentMoved not triggered for disabled \"\n+                            + components[i].getClass());\n+                }\n+\n+                resetValues();\n+                EventQueue.invokeAndWait(() -> {\n+                    currentComponent.setSize(\n+                        currentComponent.getSize().width - 1,\n+                        currentComponent.getSize().height);\n+                    frame.invalidate();\n+                    frame.validate();\n+                });\n+\n+                robot.waitForIdle();\n+                if (!componentResized) {\n+                    throw new RuntimeException(\n+                        \"FAIL: ComponentResized not triggered for disabled \"\n+                            + components[i].getClass());\n+                }\n+            }\n+\n+            EventQueue.invokeAndWait(() -> {\n+                frame.dispose();\n+                frame.setVisible(true);\n+            });\n+\n+            robot.waitForIdle();\n+\n+            resetValues();\n+            EventQueue.invokeAndWait(() -> {\n+                frame.setExtendedState(Frame.ICONIFIED);\n+            });\n+\n+            robot.waitForIdle();\n+            if (componentShown || componentHidden || componentMoved\n+                || componentResized) {\n+                System.err.print(\"Events triggered are: \");\n+                for (int j = 0; j < events.size();\n+                    System.err.print(events.get(j) + \"; \"), j++);\n+                System.err.println(\"\");\n+                throw new RuntimeException(\n+                    \"FAIL: ComponentEvent triggered when frame is iconified\");\n+            }\n+\n+            resetValues();\n+            EventQueue.invokeAndWait(() -> {\n+                frame.setExtendedState(Frame.NORMAL);\n+            });\n+\n+            robot.waitForIdle();\n+            if (componentShown || componentHidden) {\n+                System.err.print(\"Events triggered are: \");\n+                for (int j = 0; j < events.size();\n+                    System.err.print(events.get(j) + \"; \"), j++);\n+                System.err.println(\"\");\n+                throw new RuntimeException(\n+                    \"FAIL: ComponentEvent triggered when frame is set to normal state\");\n+            }\n+\n+            System.out.println(\"Test PASSED\");\n+        } finally {\n+            EventQueue.invokeAndWait(ComponentEventTest::disposeFrame);\n+        }\n+    }\n+\n+    private static void resetValues() {\n+        componentShown = false;\n+        componentHidden = false;\n+        componentMoved = false;\n+        componentResized = false;\n+        events.clear();\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/event\/ComponentEvent\/ComponentEventTest.java","additions":371,"deletions":0,"binary":false,"changes":371,"status":"added"}]}