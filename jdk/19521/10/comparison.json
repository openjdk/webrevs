{"files":[{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Scrollbar;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+import java.awt.event.InputEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import jdk.test.lib.Platform;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8333403\n+ * @summary Test performs various operations to check components events are triggered properly.\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main ComponentEventTest\n+ *\/\n+public class ComponentEventTest {\n+\n+    private static final int DELAY = 500;\n+\n+    private static Frame frame;\n+    private static Robot robot;\n+\n+    private static Component[] components;\n+\n+    private static volatile Point centerPoint;\n+\n+    private static volatile boolean componentHidden;\n+    private static volatile boolean componentShown;\n+    private static volatile boolean componentMoved;\n+    private static volatile boolean componentResized;\n+\n+    private static final ComponentListener componentListener =\n+        new ComponentListener() {\n+\n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                System.out.println(\"ComponentShown: \" + e.getSource());\n+                componentShown = true;\n+            }\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                System.out.println(\"ComponentResized: \" + e.getSource());\n+                componentResized = true;\n+            }\n+\n+            @Override\n+            public void componentMoved(ComponentEvent e) {\n+                System.out.println(\"ComponentMoved: \" + e.getSource());\n+                componentMoved = true;\n+            }\n+\n+            @Override\n+            public void componentHidden(ComponentEvent e) {\n+                System.out.println(\"ComponentHidden: \" + e.getSource());\n+                componentHidden = true;\n+            }\n+        };\n+\n+    private static void initializeGUI() {\n+        frame = new Frame(\"Component Event Test\");\n+        frame.setLayout(new FlowLayout());\n+\n+        Panel panel = new Panel();\n+        Button button = new Button(\"Button\");\n+        Label label = new Label(\"Label\");\n+        List list = new List();\n+        list.add(\"One\");\n+        list.add(\"Two\");\n+        list.add(\"Three\");\n+        Choice choice = new Choice();\n+        choice.add(\"Red\");\n+        choice.add(\"Orange\");\n+        choice.add(\"Yellow\");\n+        Checkbox checkbox = new Checkbox(\"Checkbox\");\n+        Scrollbar scrollbar = new Scrollbar(Scrollbar.HORIZONTAL, 0, 1, 0, 255);\n+        TextField textfield = new TextField(15);\n+        TextArea textarea = new TextArea(5, 15);\n+\n+        components = new Component[] { panel, button, label, list, choice,\n+            checkbox, scrollbar, textfield, textarea, frame };\n+\n+        for (int i = 0; i < components.length - 1; i++) {\n+            components[i].addComponentListener(componentListener);\n+            frame.add(components[i]);\n+        }\n+        frame.addComponentListener(componentListener);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+\n+            EventQueue.invokeAndWait(ComponentEventTest::initializeGUI);\n+            robot.waitForIdle();\n+            robot.delay(DELAY);\n+\n+            doTest();\n+\n+            System.out.println(\"Test PASSED\");\n+        } finally {\n+            EventQueue.invokeAndWait(ComponentEventTest::disposeFrame);\n+        }\n+    }\n+\n+    private static void doTest()\n+        throws InvocationTargetException, InterruptedException {\n+        \/\/ Click the frame to ensure it gains focus\n+        clickFrame();\n+\n+        robot.delay(DELAY);\n+\n+        for (int i = 0; i < components.length; i++) {\n+            for (boolean state : new boolean[] { true, false }) {\n+                doTest(components[i], state);\n+            }\n+        }\n+\n+        robot.delay(DELAY);\n+\n+        System.out.println(\"Iconify frame\");\n+        resetValues();\n+        testIconifyFrame();\n+\n+        System.out.println(\"Deiconify frame\");\n+        resetValues();\n+        testDeiconifyFrame();\n+    }\n+\n+    private static void clickFrame()\n+        throws InvocationTargetException, InterruptedException {\n+        EventQueue.invokeAndWait(() -> {\n+            Point location = frame.getLocationOnScreen();\n+            Dimension size = frame.getSize();\n+            centerPoint = new Point(location.x + size.width \/ 2,\n+                location.y + size.height \/ 2);\n+        });\n+\n+        robot.mouseMove(centerPoint.x, centerPoint.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+    }\n+\n+    private static void testIconifyFrame()\n+        throws InvocationTargetException, InterruptedException {\n+        EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.ICONIFIED));\n+\n+        robot.waitForIdle();\n+        robot.delay(DELAY);\n+        if (componentShown || componentHidden || componentMoved\n+            || componentResized) {\n+            throw new RuntimeException(\n+                \"ComponentEvent triggered when frame is iconified\");\n+        }\n+    }\n+\n+    private static void testDeiconifyFrame()\n+        throws InvocationTargetException, InterruptedException {\n+        EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.NORMAL));\n+\n+        robot.waitForIdle();\n+        robot.delay(DELAY);\n+\n+        \/*\n+         * Because of the different behavior between MS Windows and other OS, we\n+         * receive native events WM_SIZE and WM_MOVE on Windows when the frame\n+         * state changes from iconified to normal. AWT sends these events to\n+         * components when it receives the events from the native system. See\n+         * JDK-6754618 for more information.\n+         *\/\n+\n+        if (componentShown || componentHidden) {\n+            throw new RuntimeException(\n+                \"FAIL: componentShown or componentHidden triggered \"\n+                    + \"when frame set to normal\");\n+        }\n+\n+        if (Platform.isWindows() && (!componentMoved || !componentResized)) {\n+            throw new RuntimeException(\n+                \"FAIL: componentMoved or componentResized wasn't triggered \"\n+                    + \"when frame set to normal\");\n+        }\n+        if (!Platform.isWindows() && (componentMoved || componentResized)) {\n+            throw new RuntimeException(\n+                \"FAIL: componentMoved or componentResized triggered \"\n+                    + \"when frame set to normal\");\n+        }\n+    }\n+\n+    private static void doTest(final Component currentComponent, boolean enable)\n+        throws InvocationTargetException, InterruptedException {\n+\n+        System.out.println(\"Component \" + currentComponent);\n+        System.out.println(\"  enabled \" + enable);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setEnabled(enable);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(false);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentHidden) {\n+            throw new RuntimeException(\"FAIL: ComponentHidden not triggered for\"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(false);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (componentHidden) {\n+            throw new RuntimeException(\"FAIL: ComponentHidden triggered when \"\n+                + \"setVisible(false) called for a hidden \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(true);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentShown) {\n+            throw new RuntimeException(\"FAIL: ComponentShown not triggered for \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(true);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (componentShown) {\n+            throw new RuntimeException(\"FAIL: ComponentShown triggered when \"\n+                + \"setVisible(true) called for a shown \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setLocation(currentComponent.getLocation().x + 1,\n+                currentComponent.getLocation().y);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentMoved) {\n+            throw new RuntimeException(\"FAIL: ComponentMoved not triggered for \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setSize(currentComponent.getSize().width + 1,\n+                currentComponent.getSize().height);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentResized) {\n+            throw new RuntimeException(\"FAIL: ComponentResized not triggered \"\n+                + \"when size increases for \" + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setSize(currentComponent.getSize().width - 1,\n+                currentComponent.getSize().height);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentResized) {\n+            throw new RuntimeException(\"FAIL: ComponentResized not triggered \"\n+                + \"when size decreases for \" + currentComponent.getClass());\n+        }\n+\n+        System.out.println(\"\\n\");\n+    }\n+\n+    private static void revalidateFrame() {\n+        frame.invalidate();\n+        frame.validate();\n+    }\n+\n+    private static void resetValues() {\n+        componentShown = false;\n+        componentHidden = false;\n+        componentMoved = false;\n+        componentResized = false;\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/ComponentEventTest.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"}]}