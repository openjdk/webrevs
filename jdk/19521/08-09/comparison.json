{"files":[{"patch":"@@ -0,0 +1,356 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Scrollbar;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+import java.awt.event.InputEvent;\n+import java.lang.reflect.InvocationTargetException;\n+import jdk.test.lib.Platform;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8333403\n+ * @summary Test performs various operations to check components events are triggered properly.\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main ComponentEventTest\n+ *\/\n+public class ComponentEventTest {\n+\n+    private static final int DELAY = 500;\n+\n+    private static Frame frame;\n+    private static Robot robot;\n+\n+    private static Component[] components;\n+\n+    private static volatile Point centerPoint;\n+\n+    private static volatile boolean componentHidden;\n+    private static volatile boolean componentShown;\n+    private static volatile boolean componentMoved;\n+    private static volatile boolean componentResized;\n+\n+    private static final ComponentListener componentListener =\n+        new ComponentListener() {\n+\n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                System.out.println(\"ComponentShown: \" + e.getSource());\n+                componentShown = true;\n+            }\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                System.out.println(\"ComponentResized: \" + e.getSource());\n+                componentResized = true;\n+            }\n+\n+            @Override\n+            public void componentMoved(ComponentEvent e) {\n+                System.out.println(\"ComponentMoved: \" + e.getSource());\n+                componentMoved = true;\n+            }\n+\n+            @Override\n+            public void componentHidden(ComponentEvent e) {\n+                System.out.println(\"ComponentHidden: \" + e.getSource());\n+                componentHidden = true;\n+            }\n+        };\n+\n+    private static void initializeGUI() {\n+        frame = new Frame(\"Component Event Test\");\n+        frame.setLayout(new FlowLayout());\n+\n+        Panel panel = new Panel();\n+        Button button = new Button(\"Button\");\n+        Label label = new Label(\"Label\");\n+        List list = new List();\n+        list.add(\"One\");\n+        list.add(\"Two\");\n+        list.add(\"Three\");\n+        Choice choice = new Choice();\n+        choice.add(\"Red\");\n+        choice.add(\"Orange\");\n+        choice.add(\"Yellow\");\n+        Checkbox checkbox = new Checkbox(\"Checkbox\");\n+        Scrollbar scrollbar = new Scrollbar(Scrollbar.HORIZONTAL, 0, 1, 0, 255);\n+        TextField textfield = new TextField(15);\n+        TextArea textarea = new TextArea(5, 15);\n+\n+        components = new Component[] { panel, button, label, list, choice,\n+            checkbox, scrollbar, textfield, textarea, frame };\n+\n+        for (int i = 0; i < components.length - 1; i++) {\n+            components[i].addComponentListener(componentListener);\n+            frame.add(components[i]);\n+        }\n+        frame.addComponentListener(componentListener);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+\n+            EventQueue.invokeAndWait(ComponentEventTest::initializeGUI);\n+            robot.waitForIdle();\n+            robot.delay(DELAY);\n+\n+            doTest();\n+\n+            System.out.println(\"Test PASSED\");\n+        } finally {\n+            EventQueue.invokeAndWait(ComponentEventTest::disposeFrame);\n+        }\n+    }\n+\n+    private static void doTest()\n+        throws InvocationTargetException, InterruptedException {\n+        \/\/ Click the frame to ensure it gains focus\n+        clickFrame();\n+\n+        robot.delay(DELAY);\n+\n+        for (int i = 0; i < components.length; i++) {\n+            for (boolean state : new boolean[] { true, false }) {\n+                doTest(components[i], state);\n+            }\n+        }\n+\n+        robot.delay(DELAY);\n+\n+        System.out.println(\"Iconify frame\");\n+        resetValues();\n+        iconifyFrame();\n+\n+        System.out.println(\"Deiconify frame\");\n+        resetValues();\n+        deiconifyFrame();\n+    }\n+\n+    private static void clickFrame()\n+        throws InvocationTargetException, InterruptedException {\n+        EventQueue.invokeAndWait(() -> {\n+            Point location = frame.getLocationOnScreen();\n+            Dimension size = frame.getSize();\n+            centerPoint = new Point(location.x + size.width \/ 2,\n+                location.y + size.height \/ 2);\n+        });\n+\n+        robot.mouseMove(centerPoint.x, centerPoint.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+    }\n+\n+    private static void iconifyFrame()\n+        throws InvocationTargetException, InterruptedException {\n+        EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.ICONIFIED));\n+\n+        robot.waitForIdle();\n+        robot.delay(DELAY);\n+        if (componentShown || componentHidden || componentMoved\n+            || componentResized) {\n+            throw new RuntimeException(\n+                \"ComponentEvent triggered when frame is iconified\");\n+        }\n+    }\n+\n+    private static void deiconifyFrame()\n+        throws InvocationTargetException, InterruptedException {\n+        EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.NORMAL));\n+\n+        robot.waitForIdle();\n+        robot.delay(DELAY);\n+\n+        \/*\n+         * Because of the different behavior between MS Windows and other OS, we\n+         * receive native events WM_SIZE and WM_MOVE on Windows when the frame\n+         * state changes from iconified to normal. AWT sends these events to\n+         * components when it receives the events from the native system. See\n+         * JDK-6754618 for more information.\n+         *\/\n+\n+        if (componentShown || componentHidden) {\n+            throw new RuntimeException(\n+                \"FAIL: componentShown or componentHidden triggered \"\n+                    + \"when frame set to normal\");\n+        }\n+\n+        if (Platform.isWindows() && (!componentMoved || !componentResized)) {\n+            throw new RuntimeException(\n+                \"FAIL: componentMoved or componentResized wasn't triggered \"\n+                    + \"when frame set to normal\");\n+        }\n+        if (!Platform.isWindows() && (componentMoved || componentResized)) {\n+            throw new RuntimeException(\n+                \"FAIL: componentMoved or componentResized triggered \"\n+                    + \"when frame set to normal\");\n+        }\n+    }\n+\n+    private static void doTest(final Component currentComponent, boolean enable)\n+        throws InvocationTargetException, InterruptedException {\n+\n+        System.out.println(\"Component \" + currentComponent);\n+        System.out.println(\"  enabled \" + enable);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setEnabled(enable);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(false);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentHidden) {\n+            throw new RuntimeException(\"FAIL: ComponentHidden not triggered for\"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(false);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (componentHidden) {\n+            throw new RuntimeException(\"FAIL: ComponentHidden triggered when \"\n+                + \"setVisible(false) called for a hidden \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(true);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentShown) {\n+            throw new RuntimeException(\"FAIL: ComponentShown not triggered for \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setVisible(true);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (componentShown) {\n+            throw new RuntimeException(\"FAIL: ComponentShown triggered when \"\n+                + \"setVisible(true) called for a shown \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setLocation(currentComponent.getLocation().x + 1,\n+                currentComponent.getLocation().y);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentMoved) {\n+            throw new RuntimeException(\"FAIL: ComponentMoved not triggered for \"\n+                + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setSize(currentComponent.getSize().width + 1,\n+                currentComponent.getSize().height);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentResized) {\n+            throw new RuntimeException(\"FAIL: ComponentResized not triggered \"\n+                + \"when size increases for \" + currentComponent.getClass());\n+        }\n+\n+        resetValues();\n+        EventQueue.invokeAndWait(() -> {\n+            currentComponent.setSize(currentComponent.getSize().width - 1,\n+                currentComponent.getSize().height);\n+            revalidateFrame();\n+        });\n+\n+        robot.delay(DELAY);\n+        if (!componentResized) {\n+            throw new RuntimeException(\"FAIL: ComponentResized not triggered \"\n+                + \"when size decreases for \" + currentComponent.getClass());\n+        }\n+\n+        System.out.println(\"\\n\");\n+    }\n+\n+    private static void revalidateFrame() {\n+        frame.invalidate();\n+        frame.validate();\n+    }\n+\n+    private static void resetValues() {\n+        componentShown = false;\n+        componentHidden = false;\n+        componentMoved = false;\n+        componentResized = false;\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/ComponentEventTest.java","additions":356,"deletions":0,"binary":false,"changes":356,"status":"added"},{"patch":"@@ -1,333 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.Button;\n-import java.awt.Checkbox;\n-import java.awt.Choice;\n-import java.awt.Component;\n-import java.awt.Dimension;\n-import java.awt.EventQueue;\n-import java.awt.FlowLayout;\n-import java.awt.Frame;\n-import java.awt.Label;\n-import java.awt.List;\n-import java.awt.Panel;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.Scrollbar;\n-import java.awt.TextArea;\n-import java.awt.TextField;\n-import java.awt.event.ComponentEvent;\n-import java.awt.event.ComponentListener;\n-import java.awt.event.InputEvent;\n-import java.lang.reflect.InvocationTargetException;\n-\n-\/*\n- * @test\n- * @key headful\n- * @bug 8333403\n- * @summary Test performs various operations to check components events are triggered properly.\n- * @run main ComponentEventTest\n- *\/\n-public class ComponentEventTest {\n-\n-    private static final int DELAY = 500;\n-\n-    private static Frame frame;\n-    private static Robot robot;\n-\n-    private static Component[] components;\n-\n-    private static volatile Point centerPoint;\n-\n-    private static volatile boolean componentHidden;\n-    private static volatile boolean componentShown;\n-    private static volatile boolean componentMoved;\n-    private static volatile boolean componentResized;\n-\n-    private static final ComponentListener componentListener =\n-        new ComponentListener() {\n-\n-            @Override\n-            public void componentShown(ComponentEvent e) {\n-                System.out.println(\"ComponentShown: \" + e.getSource());\n-                componentShown = true;\n-            }\n-\n-            @Override\n-            public void componentResized(ComponentEvent e) {\n-                System.out.println(\"ComponentResized: \" + e.getSource());\n-                componentResized = true;\n-            }\n-\n-            @Override\n-            public void componentMoved(ComponentEvent e) {\n-                System.out.println(\"ComponentMoved: \" + e.getSource());\n-                componentMoved = true;\n-            }\n-\n-            @Override\n-            public void componentHidden(ComponentEvent e) {\n-                System.out.println(\"ComponentHidden: \" + e.getSource());\n-                componentHidden = true;\n-            }\n-        };\n-\n-    private static void initializeGUI() {\n-        frame = new Frame(\"Component Event Test\");\n-        frame.setLayout(new FlowLayout());\n-\n-        Panel panel = new Panel();\n-        Button button = new Button(\"Button\");\n-        Label label = new Label(\"Label\");\n-        List list = new List();\n-        list.add(\"One\");\n-        list.add(\"Two\");\n-        list.add(\"Three\");\n-        Choice choice = new Choice();\n-        choice.add(\"Red\");\n-        choice.add(\"Orange\");\n-        choice.add(\"Yellow\");\n-        Checkbox checkbox = new Checkbox(\"Checkbox\");\n-        Scrollbar scrollbar = new Scrollbar(Scrollbar.HORIZONTAL, 0, 1, 0, 255);\n-        TextField textfield = new TextField(15);\n-        TextArea textarea = new TextArea(5, 15);\n-\n-        components = new Component[] { panel, button, label, list, choice,\n-            checkbox, scrollbar, textfield, textarea, frame };\n-\n-        for (int i = 0; i < components.length - 1; i++) {\n-            components[i].addComponentListener(componentListener);\n-            frame.add(components[i]);\n-        }\n-        frame.addComponentListener(componentListener);\n-\n-        frame.pack();\n-        frame.setLocationRelativeTo(null);\n-        frame.setVisible(true);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        try {\n-            robot = new Robot();\n-            robot.setAutoWaitForIdle(true);\n-\n-            EventQueue.invokeAndWait(ComponentEventTest::initializeGUI);\n-            robot.waitForIdle();\n-            robot.delay(DELAY);\n-\n-            doTest();\n-\n-            System.out.println(\"Test PASSED\");\n-        } finally {\n-            EventQueue.invokeAndWait(ComponentEventTest::disposeFrame);\n-        }\n-    }\n-\n-    private static void doTest()\n-        throws InvocationTargetException, InterruptedException {\n-        \/\/ Click on the Frame to ensure its gain Focus\n-        EventQueue.invokeAndWait(() -> {\n-            Point location = frame.getLocationOnScreen();\n-            Dimension size = frame.getSize();\n-            centerPoint = new Point(location.x + size.width \/ 2,\n-                location.y + size.height \/ 2);\n-        });\n-\n-        robot.mouseMove(centerPoint.x, centerPoint.y);\n-        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-        robot.delay(DELAY);\n-\n-        for (int i = 0; i < components.length; i++) {\n-            for (boolean state : new boolean[] { true, false }) {\n-                doTest(components[i], state);\n-            }\n-        }\n-\n-        robot.delay(DELAY);\n-\n-        System.out.println(\"Iconify frame\");\n-        resetValues();\n-        EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.ICONIFIED));\n-\n-        robot.waitForIdle();\n-        robot.delay(DELAY);\n-        if (componentShown || componentHidden || componentMoved\n-            || componentResized) {\n-            throw new RuntimeException(\n-                \"ComponentEvent triggered when frame is iconified\");\n-        }\n-\n-        System.out.println(\"Deiconify frame\");\n-        resetValues();\n-        EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.NORMAL));\n-\n-        robot.waitForIdle();\n-        robot.delay(DELAY);\n-\n-        \/*\n-         * Because of the different behavior between MS Windows and other OS ,we\n-         * natively received WM_SIZE\/WM_MOVE events when set frame iconify to\n-         * deiconify , The AWT sends the events to components when it receives\n-         * the events from the native system.\n-         * Please check the  JDK-6754618\n-         *\/\n-\n-        String os = System.getProperty(\"os.name\").toLowerCase();\n-        if (os.contains(\"windows\") && (componentShown || componentHidden\n-            || !componentMoved || !componentResized)) {\n-            throw new RuntimeException(\n-                \"FAIL: ComponentEvent triggered when frame set to normal\");\n-\n-        } else if (!os.contains(\"windows\") && (componentShown || componentHidden\n-            || componentMoved || componentResized)) {\n-            throw new RuntimeException(\n-                \"ComponentEvent triggered when frame set to normal\");\n-        }\n-    }\n-\n-    private static void doTest(final Component currentComponent, boolean enable)\n-        throws InvocationTargetException, InterruptedException {\n-\n-        System.out.println(\"Component \" + currentComponent);\n-        System.out.println(\"  enabled \" + enable);\n-\n-        EventQueue.invokeAndWait(() -> {\n-            currentComponent.setEnabled(enable);\n-            revalidateFrame();\n-        });\n-\n-        robot.delay(DELAY);\n-\n-        resetValues();\n-        EventQueue.invokeAndWait(() -> {\n-            currentComponent.setVisible(false);\n-            revalidateFrame();\n-        });\n-\n-        robot.delay(DELAY);\n-        if (!componentHidden) {\n-            throw new RuntimeException(\"FAIL: ComponentHidden not triggered for\"\n-                + currentComponent.getClass());\n-        }\n-\n-        resetValues();\n-        EventQueue.invokeAndWait(() -> {\n-            currentComponent.setVisible(false);\n-            revalidateFrame();\n-        });\n-\n-        robot.delay(DELAY);\n-        if (componentHidden) {\n-            throw new RuntimeException(\"FAIL: ComponentHidden triggered when \"\n-                + \"setVisible(false) called for a hidden \"\n-                + currentComponent.getClass());\n-        }\n-\n-        resetValues();\n-        EventQueue.invokeAndWait(() -> {\n-            currentComponent.setVisible(true);\n-            revalidateFrame();\n-        });\n-\n-        robot.delay(DELAY);\n-        if (!componentShown) {\n-            throw new RuntimeException(\"FAIL: ComponentShown not triggered for \"\n-                + currentComponent.getClass());\n-        }\n-\n-        resetValues();\n-        EventQueue.invokeAndWait(() -> {\n-            currentComponent.setVisible(true);\n-            revalidateFrame();\n-        });\n-\n-        robot.delay(DELAY);\n-        if (componentShown) {\n-            throw new RuntimeException(\"FAIL: ComponentShown triggered when \"\n-                + \"setVisible(true) called for a shown \"\n-                + currentComponent.getClass());\n-        }\n-\n-        resetValues();\n-        EventQueue.invokeAndWait(() -> {\n-            currentComponent.setLocation(currentComponent.getLocation().x + 1,\n-                currentComponent.getLocation().y);\n-            revalidateFrame();\n-        });\n-\n-        robot.delay(DELAY);\n-        if (!componentMoved) {\n-            throw new RuntimeException(\"FAIL: ComponentMoved not triggered for \"\n-                + currentComponent.getClass());\n-        }\n-\n-        resetValues();\n-        EventQueue.invokeAndWait(() -> {\n-            currentComponent.setSize(currentComponent.getSize().width + 1,\n-                currentComponent.getSize().height);\n-            revalidateFrame();\n-        });\n-\n-        robot.delay(DELAY);\n-        if (!componentResized) {\n-            throw new RuntimeException(\"FAIL: ComponentResized not triggered \"\n-                + \"when size increases for \" + currentComponent.getClass());\n-        }\n-\n-        resetValues();\n-        EventQueue.invokeAndWait(() -> {\n-            currentComponent.setSize(currentComponent.getSize().width - 1,\n-                currentComponent.getSize().height);\n-            revalidateFrame();\n-        });\n-\n-        robot.delay(DELAY);\n-        if (!componentResized) {\n-            throw new RuntimeException(\"FAIL: ComponentResized not triggered \"\n-                + \"when size decreases for \" + currentComponent.getClass());\n-        }\n-\n-        System.out.println(\"\\n\");\n-    }\n-\n-    private static void revalidateFrame() {\n-        frame.invalidate();\n-        frame.validate();\n-    }\n-\n-    private static void resetValues() {\n-        componentShown = false;\n-        componentHidden = false;\n-        componentMoved = false;\n-        componentResized = false;\n-    }\n-\n-    private static void disposeFrame() {\n-        if (frame != null) {\n-            frame.dispose();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/ComponentEvent\/ComponentEventTest.java","additions":0,"deletions":333,"binary":false,"changes":333,"status":"deleted"}]}