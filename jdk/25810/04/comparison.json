{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import java.util.Locale;\n@@ -96,1 +97,3 @@\n-        LINT_CATEGORY(\"lint.category\");\n+        LINT_CATEGORY(\"lint.category\"),\n+        DIAGNOSTIC_FLAGS_EMPTY(\"diagnostic.flags.empty\"),\n+        DIAGNOSTIC_FLAGS_NON_EMPTY(\"diagnostic.flags.non-empty\");\n@@ -262,0 +265,7 @@\n+        String diagnosticFlags = lines.stream()\n+                .filter(MessageLine::isDiagnosticFlags)\n+                .map(MessageLine::diagnosticFlags)\n+                .flatMap(Stream::of)\n+                .map(s -> s.replace('-', '_'))\n+                .map(s -> s.toUpperCase(Locale.ROOT))\n+                .collect(Collectors.joining(\", \"));\n@@ -268,0 +278,3 @@\n+                        diagnosticFlags.isEmpty() ?\n+                          StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                          StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n@@ -273,0 +286,3 @@\n+                        diagnosticFlags.isEmpty() ?\n+                          StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                          StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n@@ -290,0 +306,3 @@\n+                            diagnosticFlags.isEmpty() ?\n+                              StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                              StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n@@ -295,0 +314,3 @@\n+                            diagnosticFlags.isEmpty() ?\n+                              StubKind.DIAGNOSTIC_FLAGS_EMPTY.format() :\n+                              StubKind.DIAGNOSTIC_FLAGS_NON_EMPTY.format(diagnosticFlags),\n","filename":"make\/langtools\/tools\/propertiesparser\/gen\/ClassGenerator.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n- * such as {0}, {1}, etc within the property value.\n+ * such as {0}, {1}, etc within the property value, a lint category,\n+ * and\/or a list of diagnostic flags.\n@@ -52,1 +53,1 @@\n-            if (l != null && l.isLint()) {\n+            while (l != null && (l.isLint() || l.isDiagnosticFlags())) {\n@@ -77,1 +78,1 @@\n-            if (l.prev != null && (l.prev.isInfo() || l.prev.isLint()))\n+            while (l.prev != null && (l.prev.isInfo() || l.prev.isLint() || l.prev.isDiagnosticFlags()))\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/Message.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -42,0 +43,1 @@\n+    static final Pattern diagnosticFlagsPattern = Pattern.compile(\"# flags: ([a-z\\\\-]+(, ([a-z\\\\-]+))*)\");\n@@ -72,0 +74,13 @@\n+    public boolean isDiagnosticFlags() {\n+        return diagnosticFlagsPattern.matcher(text).matches();\n+    }\n+\n+    public String[] diagnosticFlags() {\n+        Matcher matcher = diagnosticFlagsPattern.matcher(text);\n+        if (matcher.matches()) {\n+            return matcher.group(1).split(\", \", -1);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/MessageLine.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+    import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\\n\\\n@@ -37,0 +38,4 @@\n+    import java.util.EnumSet;\\n\\\n+    \\n\\\n+    import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;\\n\\\n+    \\n\\\n@@ -61,1 +66,1 @@\n-    return new {0}({1}, {2}, {3});\n+    return new {0}({1}, {2}, {3}, {4});\n@@ -64,1 +69,1 @@\n-    return new {0}({1}, {2}, {3}, {4});\n+    return new {0}({1}, {2}, {3}, {4}, {5});\n@@ -70,1 +75,1 @@\n-    public static final {0} {1} = new {0}({2}, {3});\n+    public static final {0} {1} = new {0}({2}, {3}, {4});\n@@ -76,1 +81,1 @@\n-    public static final {0} {1} = new {0}({2}, {3}, {4});\n+    public static final {0} {1} = new {0}({2}, {3}, {4}, {5});\n@@ -87,0 +92,6 @@\n+diagnostic.flags.empty=\\\n+  EnumSet.noneOf(DiagnosticFlag.class)\n+\n+diagnostic.flags.non-empty=\\\n+  EnumSet.of({0})\n+\n","filename":"make\/langtools\/tools\/propertiesparser\/resources\/templates.properties","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -275,2 +275,0 @@\n-                Check.instance(this).clear(); \/\/clear mandatory warning handlers\n-                Preview.instance(this).clear(); \/\/clear mandatory warning handlers\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskPool.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import com.sun.tools.javac.util.MandatoryWarningHandler;\n@@ -74,3 +73,0 @@\n-    \/** the diag handler to manage preview feature usage diagnostics *\/\n-    private final MandatoryWarningHandler previewHandler;\n-\n@@ -108,1 +104,0 @@\n-        previewHandler = new MandatoryWarningHandler(log, source, verbose, true, LintCategory.PREVIEW);\n@@ -179,1 +174,2 @@\n-        previewHandler.report(pos, feature.isPlural() ?\n+        log.mandatoryWarning(pos,\n+            feature.isPlural() ?\n@@ -206,4 +202,0 @@\n-    public void reportPreviewWarning(DiagnosticPosition pos, LintWarning warnKey) {\n-        previewHandler.report(pos, warnKey);\n-    }\n-\n@@ -272,11 +264,0 @@\n-    \/**\n-     * Report any deferred diagnostics.\n-     *\/\n-    public void reportDeferredDiagnostics() {\n-        previewHandler.reportDeferredDiagnostic();\n-    }\n-\n-    public void clear() {\n-        previewHandler.clear();\n-    }\n-\n@@ -286,1 +267,1 @@\n-            log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos, disabledError(feature));\n+            log.error(pos, disabledError(feature));\n@@ -289,2 +270,1 @@\n-                log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos,\n-                          feature.error(source.name));\n+                log.error(pos, feature.error(source.name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -4149,2 +4148,1 @@\n-                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                              Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.error(this.sourceName));\n+                    log.error(tree.pos(), Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.error(this.sourceName));\n@@ -4170,2 +4168,1 @@\n-                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                            Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                    log.error(tree.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -167,12 +167,0 @@\n-        boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);\n-        boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);\n-        boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);\n-        boolean enforceMandatoryWarnings = true;\n-\n-        deprecationHandler = new MandatoryWarningHandler(log, null, verboseDeprecated,\n-                enforceMandatoryWarnings, LintCategory.DEPRECATION, \"deprecated\");\n-        removalHandler = new MandatoryWarningHandler(log, null, verboseRemoval,\n-                enforceMandatoryWarnings, LintCategory.REMOVAL);\n-        uncheckedHandler = new MandatoryWarningHandler(log, null, verboseUnchecked,\n-                enforceMandatoryWarnings, LintCategory.UNCHECKED);\n-\n@@ -195,12 +183,0 @@\n-    \/** A handler for messages about deprecated usage.\n-     *\/\n-    private MandatoryWarningHandler deprecationHandler;\n-\n-    \/** A handler for messages about deprecated-for-removal usage.\n-     *\/\n-    private MandatoryWarningHandler removalHandler;\n-\n-    \/** A handler for messages about unchecked or unsafe usage.\n-     *\/\n-    private MandatoryWarningHandler uncheckedHandler;\n-\n@@ -256,0 +232,1 @@\n+        LintWarning warningKey = null;\n@@ -259,1 +236,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym));\n+                    warningKey = LintWarnings.HasBeenDeprecatedForRemovalModule(sym);\n@@ -261,1 +238,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n+                    warningKey = LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location());\n@@ -266,1 +243,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym));\n+                warningKey = LintWarnings.HasBeenDeprecatedModule(sym);\n@@ -268,1 +245,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+                warningKey = LintWarnings.HasBeenDeprecated(sym, sym.location());\n@@ -271,0 +248,2 @@\n+        if (warningKey != null)\n+            log.mandatoryWarning(pos, warningKey);\n@@ -279,1 +258,1 @@\n-            preview.reportPreviewWarning(pos, warnKey);\n+            log.mandatoryWarning(pos, warnKey);\n@@ -296,1 +275,1 @@\n-            uncheckedHandler.report(pos, warnKey);\n+            log.mandatoryWarning(pos, warnKey);\n@@ -299,10 +278,0 @@\n-    \/**\n-     * Report any deferred diagnostics.\n-     *\/\n-    public void reportDeferredDiagnostics() {\n-        deprecationHandler.reportDeferredDiagnostic();\n-        removalHandler.reportDeferredDiagnostic();\n-        uncheckedHandler.reportDeferredDiagnostic();\n-    }\n-\n-\n@@ -314,1 +283,1 @@\n-        log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));\n+        log.error(DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));\n@@ -477,6 +446,0 @@\n-    public void clear() {\n-        deprecationHandler.clear();\n-        removalHandler.clear();\n-        uncheckedHandler.clear();\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":10,"deletions":47,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import com.sun.tools.javac.code.Preview;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.util.Log;\n@@ -123,1 +124,0 @@\n-        MemoryPreview.registerInstance(context);\n@@ -125,0 +125,4 @@\n+\n+        \/\/ This suppresses diagnostics like \"Note: Recompile with -Xlint:preview for details.\"\n+        Log.instance(context).suppressAggregatedWarningNotes(LintCategory.PREVIEW);\n+\n@@ -272,15 +276,0 @@\n-\n-    static class MemoryPreview extends Preview {\n-        static void registerInstance(Context context) {\n-            context.put(previewKey, (Factory<Preview>)MemoryPreview::new);\n-        }\n-\n-        MemoryPreview(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public void reportDeferredDiagnostics() {\n-            \/\/ suppress diagnostics like \"Note: Recompile with -Xlint:preview for details.\"\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryContext.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -62,0 +61,1 @@\n+import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n@@ -88,4 +88,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n-import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n-\n@@ -277,4 +273,0 @@\n-    \/** The preview language version.\n-     *\/\n-    protected Preview preview;\n-\n@@ -416,1 +408,0 @@\n-        preview = Preview.instance(context);\n@@ -1855,2 +1846,1 @@\n-        chk.reportDeferredDiagnostics();\n-        preview.reportDeferredDiagnostics();\n+        log.reportOutstandingNotes();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-            lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));\n+            lexError(pos, preview.disabledError(feature));\n@@ -187,1 +187,1 @@\n-            lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n+            lexError(pos, feature.error(source.name));\n@@ -202,14 +202,1 @@\n-        tk = TokenKind.ERROR;\n-        errPos = pos;\n-    }\n-\n-    \/**\n-     * Report an error at the given position using the provided arguments.\n-     *\n-     * @param flags  diagnostic flags.\n-     * @param pos    position in input buffer.\n-     * @param key    error key to report.\n-     *\/\n-    protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {\n-        log.error(flags, pos, key);\n-        if (flags != DiagnosticFlag.SOURCE_LEVEL) {\n+        if (!key.hasFlag(DiagnosticFlag.SOURCE_LEVEL)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -5614,1 +5614,1 @@\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));\n+            log.error(pos, preview.disabledError(feature));\n@@ -5617,1 +5617,1 @@\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n+            log.error(pos, feature.error(source.name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1926,0 +1926,1 @@\n+# flags: aggregate\n@@ -1931,0 +1932,1 @@\n+# flags: aggregate\n@@ -1936,0 +1938,1 @@\n+# flags: aggregate\n@@ -1946,0 +1949,1 @@\n+# flags: aggregate\n@@ -1957,0 +1961,1 @@\n+# flags: aggregate\n@@ -1962,0 +1967,1 @@\n+# flags: aggregate\n@@ -2360,0 +2366,1 @@\n+# flags: aggregate\n@@ -2365,0 +2372,1 @@\n+# flags: aggregate\n@@ -2374,0 +2382,1 @@\n+# flags: aggregate\n@@ -2381,0 +2390,1 @@\n+# flags: aggregate\n@@ -2386,0 +2396,1 @@\n+# flags: aggregate\n@@ -2784,0 +2795,1 @@\n+# flags: aggregate\n@@ -3180,0 +3192,1 @@\n+# flags: aggregate\n@@ -3186,0 +3199,1 @@\n+# flags: aggregate\n@@ -3249,0 +3263,1 @@\n+# flags: source-level\n@@ -3254,0 +3269,1 @@\n+# flags: source-level\n@@ -3269,0 +3285,1 @@\n+# flags: source-level\n@@ -3274,0 +3291,1 @@\n+# flags: source-level\n@@ -3285,0 +3303,1 @@\n+# flags: aggregate\n@@ -3290,0 +3309,1 @@\n+# flags: aggregate\n@@ -4252,0 +4272,1 @@\n+# flags: aggregate\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -240,1 +241,1 @@\n-            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, prefix, key, args));\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, null, prefix, key, args));\n@@ -255,1 +256,1 @@\n-            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, prefix, key, args), rewriter);\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, null, prefix, key, args), rewriter);\n@@ -282,1 +283,1 @@\n-            return create(flags, source, pos, DiagnosticInfo.of(kind, lc, prefix, key, args));\n+            return create(flags, source, pos, DiagnosticInfo.of(kind, null, lc, prefix, key, args));\n@@ -306,1 +307,2 @@\n-                return DiagnosticInfo.of(diagnosticInfo.type, category, diagnosticInfo.prefix, diagnosticInfo.code,\n+                return DiagnosticInfo.of(diagnosticInfo.type, diagnosticInfo.flags,\n+                        category, diagnosticInfo.prefix, diagnosticInfo.code,\n@@ -317,1 +319,1 @@\n-            return (Error)DiagnosticInfo.of(ERROR, prefix, code, args);\n+            return (Error)DiagnosticInfo.of(ERROR, null, prefix, code, args);\n@@ -324,1 +326,1 @@\n-            return (Warning)DiagnosticInfo.of(WARNING, lintCategory, prefix, code, args);\n+            return (Warning)DiagnosticInfo.of(WARNING, null, lintCategory, prefix, code, args);\n@@ -331,1 +333,1 @@\n-            return (Note)DiagnosticInfo.of(NOTE, prefix, code, args);\n+            return (Note)DiagnosticInfo.of(NOTE, null, prefix, code, args);\n@@ -338,1 +340,1 @@\n-            return (Fragment)DiagnosticInfo.of(FRAGMENT, prefix, code, args);\n+            return (Fragment)DiagnosticInfo.of(FRAGMENT, null, prefix, code, args);\n@@ -354,0 +356,1 @@\n+                                      null,\n@@ -450,0 +453,3 @@\n+        \/** Flags mandatory warnings that should pass through a mandatory warning aggregator.\n+         *\/\n+        AGGREGATE,\n@@ -506,0 +512,3 @@\n+        \/** A set of diagnostic flags to be automatically added to newly created JCDiagnostics. *\/\n+        Set<DiagnosticFlag> flags;\n+\n@@ -516,1 +525,1 @@\n-        private DiagnosticInfo(DiagnosticType type, String prefix, String code, Object... args) {\n+        private DiagnosticInfo(DiagnosticType type, Set<DiagnosticFlag> flags, String prefix, String code, Object... args) {\n@@ -518,0 +527,1 @@\n+            this.flags = flags != null ? flags : EnumSet.noneOf(DiagnosticFlag.class);\n@@ -533,2 +543,3 @@\n-        public static DiagnosticInfo of(DiagnosticType type, String prefix, String code, Object... args) {\n-            return of(type, null, prefix, code, args);\n+        public static DiagnosticInfo of(DiagnosticType type, Set<DiagnosticFlag> flags,\n+            String prefix, String code, Object... args) {\n+            return of(type, flags, null, prefix, code, args);\n@@ -537,1 +548,2 @@\n-        public static DiagnosticInfo of(DiagnosticType type, LintCategory lc, String prefix, String code, Object... args) {\n+        public static DiagnosticInfo of(DiagnosticType type, Set<DiagnosticFlag> flags,\n+            LintCategory lc, String prefix, String code, Object... args) {\n@@ -540,1 +552,1 @@\n-                    return new Error(prefix, code, args);\n+                    return new Error(flags, prefix, code, args);\n@@ -543,2 +555,2 @@\n-                            new Warning(prefix, code, args) :\n-                            new LintWarning(lc, prefix, code, args);\n+                            new Warning(flags, prefix, code, args) :\n+                            new LintWarning(flags, lc, prefix, code, args);\n@@ -546,1 +558,1 @@\n-                    return new Note(prefix, code, args);\n+                    return new Note(flags, prefix, code, args);\n@@ -548,1 +560,1 @@\n-                    return new Fragment(prefix, code, args);\n+                    return new Fragment(flags, prefix, code, args);\n@@ -572,0 +584,4 @@\n+\n+        public boolean hasFlag(DiagnosticFlag flag) {\n+            return flags.contains(flag);\n+        }\n@@ -578,2 +594,2 @@\n-        public Error(String prefix, String key, Object... args) {\n-            super(DiagnosticType.ERROR, prefix, key, args);\n+        public Error(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.ERROR, flags, prefix, key, args);\n@@ -587,2 +603,2 @@\n-        public Warning(String prefix, String key, Object... args) {\n-            super(DiagnosticType.WARNING, prefix, key, args);\n+        public Warning(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.WARNING, flags, prefix, key, args);\n@@ -598,2 +614,2 @@\n-        public LintWarning(LintCategory category, String prefix, String key, Object... args) {\n-            super(prefix, key, args);\n+        public LintWarning(Set<DiagnosticFlag> flags, LintCategory category, String prefix, String key, Object... args) {\n+            super(flags, prefix, key, args);\n@@ -612,2 +628,2 @@\n-        public Note(String prefix, String key, Object... args) {\n-            super(DiagnosticType.NOTE, prefix, key, args);\n+        public Note(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.NOTE, flags, prefix, key, args);\n@@ -621,2 +637,2 @@\n-        public Fragment(String prefix, String key, Object... args) {\n-            super(DiagnosticType.FRAGMENT, prefix, key, args);\n+        public Fragment(Set<DiagnosticFlag> flags, String prefix, String key, Object... args) {\n+            super(DiagnosticType.FRAGMENT, flags, prefix, key, args);\n@@ -667,0 +683,2 @@\n+\n+        this.flags.addAll(diagnosticInfo.flags);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":45,"deletions":27,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.EnumSet;\n@@ -44,0 +45,3 @@\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.Source;\n@@ -47,1 +51,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -53,0 +56,1 @@\n+import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;\n@@ -151,1 +155,1 @@\n-            return !(diag.isFlagSet(DiagnosticFlag.NON_DEFERRABLE) && passOnNonDeferrable) && filter.test(diag);\n+            return !(diag.isFlagSet(NON_DEFERRABLE) && passOnNonDeferrable) && filter.test(diag);\n@@ -240,0 +244,10 @@\n+    \/**\n+     * The compilation context.\n+     *\/\n+    private final Context context;\n+\n+    \/**\n+     * The root {@link Lint} singleton.\n+     *\/\n+    private Lint rootLint;\n+\n@@ -337,0 +351,1 @@\n+        this.context = context;\n@@ -520,1 +535,1 @@\n-        if (!d.isFlagSet(DiagnosticFlag.SOURCE_LEVEL))\n+        if (!d.isFlagSet(SOURCE_LEVEL))\n@@ -684,1 +699,42 @@\n-     }\n+    }\n+\n+    \/\/ Obtain root Lint singleton lazily to avoid init loops\n+    private Lint rootLint() {\n+        if (rootLint == null)\n+            rootLint = Lint.instance(context);\n+        return rootLint;\n+    }\n+\n+\/\/ Mandatory Warnings\n+\n+    private final EnumMap<LintCategory, WarningAggregator> aggregators = new EnumMap<>(LintCategory.class);\n+\n+    private final EnumSet<LintCategory> suppressedDeferredMandatory = EnumSet.noneOf(LintCategory.class);\n+\n+    \/**\n+     * Suppress aggregated mandatory warning notes for the specified category.\n+     *\/\n+    public void suppressAggregatedWarningNotes(LintCategory category) {\n+        suppressedDeferredMandatory.add(category);\n+    }\n+\n+    \/**\n+     * Report any remaining unreported aggregated mandatory warning notes.\n+     *\/\n+    public void reportOutstandingNotes() {\n+        aggregators.entrySet().stream()\n+          .filter(entry -> !suppressedDeferredMandatory.contains(entry.getKey()))\n+          .map(Map.Entry::getValue)\n+          .map(WarningAggregator::aggregationNotes)\n+          .flatMap(List::stream)\n+          .forEach(this::report);\n+        aggregators.clear();\n+    }\n+\n+    private WarningAggregator aggregatorFor(LintCategory lc) {\n+        return switch (lc) {\n+        case PREVIEW -> aggregators.computeIfAbsent(lc, c -> new WarningAggregator(this, Source.instance(context), c));\n+        case DEPRECATION -> aggregators.computeIfAbsent(lc, c -> new WarningAggregator(this, null, c, \"deprecated\"));\n+        default -> aggregators.computeIfAbsent(lc, c -> new WarningAggregator(this, null, c));\n+        };\n+    }\n@@ -698,0 +754,2 @@\n+        aggregators.clear();\n+        suppressedDeferredMandatory.clear();\n@@ -700,0 +758,2 @@\n+\/\/ DefaultDiagnosticHandler\n+\n@@ -706,0 +766,1 @@\n+\n@@ -730,0 +791,10 @@\n+\n+                \/\/ Apply the appropriate mandatory warning aggregator, if needed\n+                if (diagnostic.isFlagSet(AGGREGATE)) {\n+                    LintCategory category = diagnostic.getLintCategory();\n+                    boolean verbose = rootLint().isEnabled(category);\n+                    if (!aggregatorFor(category).aggregate(diagnostic, verbose))\n+                        return;\n+                }\n+\n+                \/\/ Emit warning unless not mandatory and warnings are disabled\n@@ -741,2 +812,1 @@\n-                if (diagnostic.isFlagSet(DiagnosticFlag.API) ||\n-                     shouldReport(diagnostic)) {\n+                if (diagnostic.isFlagSet(API) || shouldReport(diagnostic)) {\n@@ -752,1 +822,1 @@\n-            if (diagnostic.isFlagSet(JCDiagnostic.DiagnosticFlag.COMPRESSED)) {\n+            if (diagnostic.isFlagSet(COMPRESSED)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":77,"deletions":7,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1,309 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.util;\n-\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-import javax.tools.JavaFileObject;\n-\n-import com.sun.tools.javac.code.Lint.LintCategory;\n-import com.sun.tools.javac.code.Source;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n-import com.sun.tools.javac.util.JCDiagnostic.Note;\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n-\n-\n-\/**\n- * A handler to process mandatory warnings, setting up a deferred diagnostic\n- * to be printed at the end of the compilation if some warnings get suppressed\n- * because too many warnings have already been generated.\n- *\n- * <p>\n- * Note that the SuppressWarnings annotation can be used to suppress warnings\n- * about conditions that would otherwise merit a warning. Such processing\n- * is done when the condition is detected, and in those cases, no call is\n- * made on any API to generate a warning at all. In consequence, this handler only\n- * Returns to handle those warnings that JLS says must be generated.\n- *\n- * <p>\n- * All warnings must be in the same {@link LintCategory} provided to the constructor.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class MandatoryWarningHandler {\n-\n-    \/**\n-     * The kinds of different deferred diagnostics that might be generated\n-     * if a mandatory warning is suppressed because too many warnings have\n-     * already been output.\n-     *\n-     * The parameter is a fragment used to build an I18N message key for Log.\n-     *\/\n-    private enum DeferredDiagnosticKind {\n-        \/**\n-         * This kind is used when a single specific file is found to have warnings\n-         * and no similar warnings have already been given.\n-         * It generates a message like:\n-         *      FILE has ISSUES\n-         *\/\n-        IN_FILE(\".filename\"),\n-        \/**\n-         * This kind is used when a single specific file is found to have warnings\n-         * and when similar warnings have already been reported for the file.\n-         * It generates a message like:\n-         *      FILE has additional ISSUES\n-         *\/\n-        ADDITIONAL_IN_FILE(\".filename.additional\"),\n-        \/**\n-         * This kind is used when multiple files have been found to have warnings,\n-         * and none of them have had any similar warnings.\n-         * It generates a message like:\n-         *      Some files have ISSUES\n-         *\/\n-        IN_FILES(\".plural\"),\n-        \/**\n-         * This kind is used when multiple files have been found to have warnings,\n-         * and some of them have had already had specific similar warnings.\n-         * It generates a message like:\n-         *      Some files have additional ISSUES\n-         *\/\n-        ADDITIONAL_IN_FILES(\".plural.additional\");\n-\n-        DeferredDiagnosticKind(String v) { value = v; }\n-        String getKey(String prefix) { return prefix + value; }\n-\n-        private final String value;\n-    }\n-\n-\n-    \/**\n-     * Create a handler for mandatory warnings.\n-     *\n-     * @param log     The log on which to generate any diagnostics\n-     * @param source  Associated source file, or null for none\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n-     * @param enforceMandatory\n-     *                True if mandatory warnings and notes are being enforced.\n-     * @param lc      The lint category for all warnings\n-     *\/\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc) {\n-        this(log, source, verbose, enforceMandatory, lc, null);\n-    }\n-\n-    \/**\n-     * Create a handler for mandatory warnings.\n-     *\n-     * @param log     The log on which to generate any diagnostics\n-     * @param source  Associated source file, or null for none\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n-     * @param enforceMandatory\n-     *                True if mandatory warnings and notes are being enforced.\n-     * @param lc      The lint category for all warnings\n-     * @param prefix  A common prefix for the set of message keys for the messages\n-     *                that may be generated, or null to infer from the lint category.\n-     *\/\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc, String prefix) {\n-        this.log = log;\n-        this.source = source;\n-        this.verbose = verbose;\n-        this.prefix = prefix != null ? prefix : lc.option;\n-        this.enforceMandatory = enforceMandatory;\n-        this.lintCategory = lc;\n-    }\n-\n-    \/**\n-     * Report a mandatory warning.\n-     *\n-     * @param pos source code position\n-     * @param warnKey lint warning\n-     *\/\n-    public void report(DiagnosticPosition pos, LintWarning warnKey) {\n-        JavaFileObject currentSource = log.currentSourceFile();\n-        Assert.check(warnKey.getLintCategory() == lintCategory);\n-\n-        if (verbose) {\n-            if (sourcesWithReportedWarnings == null)\n-                sourcesWithReportedWarnings = new HashSet<>();\n-\n-            if (log.nwarnings < log.MaxWarnings) {\n-                \/\/ generate message and remember the source file\n-                logMandatoryWarning(pos, warnKey);\n-                sourcesWithReportedWarnings.add(currentSource);\n-            } else if (deferredDiagnosticKind == null) {\n-                \/\/ set up deferred message\n-                if (sourcesWithReportedWarnings.contains(currentSource)) {\n-                    \/\/ more errors in a file that already has reported warnings\n-                    deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;\n-                } else {\n-                    \/\/ warnings in a new source file\n-                    deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n-                }\n-                deferredDiagnosticSource = currentSource;\n-                deferredDiagnosticArg = currentSource;\n-            } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE\n-                        || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)\n-                       && !Objects.equals(deferredDiagnosticSource, currentSource)) {\n-                \/\/ additional errors in more than one source file\n-                deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;\n-                deferredDiagnosticArg = null;\n-            }\n-        } else {\n-            if (deferredDiagnosticKind == null) {\n-                \/\/ warnings in a single source\n-                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n-                deferredDiagnosticSource = currentSource;\n-                deferredDiagnosticArg = currentSource;\n-            }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &&\n-                        !Objects.equals(deferredDiagnosticSource, currentSource)) {\n-                \/\/ warnings in multiple source files\n-                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;\n-                deferredDiagnosticArg = null;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Report any diagnostic that might have been deferred by previous calls of report().\n-     *\/\n-    public void reportDeferredDiagnostic() {\n-        if (deferredDiagnosticKind != null) {\n-            if (deferredDiagnosticArg == null) {\n-                if (source != null) {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), source);\n-                } else {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));\n-                }\n-            } else {\n-                if (source != null) {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg, source);\n-                } else {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);\n-                }\n-            }\n-\n-            if (!verbose)\n-                logMandatoryNote(deferredDiagnosticSource, prefix + \".recompile\");\n-        }\n-    }\n-\n-    \/**\n-     * The log to which to report warnings.\n-     *\/\n-    private final Log log;\n-    private final Source source;\n-\n-    \/**\n-     * Whether or not to report individual warnings, or simply to report a\n-     * single aggregate warning at the end of the compilation.\n-     *\/\n-    private final boolean verbose;\n-\n-    \/**\n-     * The common prefix for all I18N message keys generated by this handler.\n-     *\/\n-    private final String prefix;\n-\n-    \/**\n-     * A set containing the names of the source files for which specific\n-     * warnings have been generated -- i.e. in verbose mode.  If a source name\n-     * appears in this list, then deferred diagnostics will be phrased to\n-     * include \"additionally\"...\n-     *\/\n-    private Set<JavaFileObject> sourcesWithReportedWarnings;\n-\n-    \/**\n-     * A variable indicating the latest best guess at what the final\n-     * deferred diagnostic will be. Initially as specific and helpful\n-     * as possible, as more warnings are reported, the scope of the\n-     * diagnostic will be broadened.\n-     *\/\n-    private DeferredDiagnosticKind deferredDiagnosticKind;\n-\n-    \/**\n-     * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable\n-     * gives the value of log.currentSource() for the file in question.\n-     *\/\n-    private JavaFileObject deferredDiagnosticSource;\n-\n-    \/**\n-     * An optional argument to be used when constructing the\n-     * deferred diagnostic message, based on deferredDiagnosticKind.\n-     * This variable should normally be set\/updated whenever\n-     * deferredDiagnosticKind is updated.\n-     *\/\n-    private Object deferredDiagnosticArg;\n-\n-    \/**\n-     * True if mandatory warnings and notes are being enforced.\n-     *\/\n-    private final boolean enforceMandatory;\n-\n-    \/**\n-     * A LintCategory to be included in point-of-use diagnostics to indicate\n-     * how messages might be suppressed (i.e. with @SuppressWarnings).\n-     *\/\n-    private final LintCategory lintCategory;\n-\n-    \/**\n-     * Reports a mandatory warning to the log.  If mandatory warnings\n-     * are not being enforced, treat this as an ordinary warning.\n-     *\/\n-    private void logMandatoryWarning(DiagnosticPosition pos, LintWarning warnKey) {\n-        if (enforceMandatory)\n-            log.mandatoryWarning(pos, warnKey);\n-        else\n-            log.warning(pos, warnKey);\n-    }\n-\n-    \/**\n-     * Reports a mandatory note to the log.  If mandatory notes are\n-     * not being enforced, treat this as an ordinary note.\n-     *\/\n-    private void logMandatoryNote(JavaFileObject file, String msg, Object... args) {\n-        if (enforceMandatory)\n-            log.mandatoryNote(file, new Note(\"compiler\", msg, args));\n-        else\n-            log.note(file, new Note(\"compiler\", msg, args));\n-    }\n-\n-    public void clear() {\n-        sourcesWithReportedWarnings = null;\n-        deferredDiagnosticKind = null;\n-        deferredDiagnosticSource = null;\n-        deferredDiagnosticArg = null;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningHandler.java","additions":0,"deletions":309,"binary":false,"changes":309,"status":"deleted"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.util;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.Source;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n+import com.sun.tools.javac.util.JCDiagnostic.Note;\n+import com.sun.tools.javac.util.JCDiagnostic.Warning;\n+\n+\n+\/**\n+ * An aggregator for warnings, setting up a deferred diagnostic\n+ * to be printed at the end of the compilation if some warnings get suppressed\n+ * because the lint category is not enabled or too many warnings have already\n+ * been generated.\n+ *\n+ * <p>\n+ * All warnings must be in the same {@link LintCategory} provided to the constructor.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+class WarningAggregator {\n+\n+    \/**\n+     * The kinds of different deferred diagnostics that might be generated\n+     * if a warning is suppressed because too many warnings have already been output.\n+     *\n+     * The parameter is a fragment used to build an I18N message key for Log.\n+     *\/\n+    private enum DeferredDiagnosticKind {\n+        \/**\n+         * This kind is used when a single specific file is found to have warnings\n+         * and no similar warnings have already been given.\n+         * It generates a message like:\n+         *      FILE has ISSUES\n+         *\/\n+        IN_FILE(\".filename\"),\n+        \/**\n+         * This kind is used when a single specific file is found to have warnings\n+         * and when similar warnings have already been reported for the file.\n+         * It generates a message like:\n+         *      FILE has additional ISSUES\n+         *\/\n+        ADDITIONAL_IN_FILE(\".filename.additional\"),\n+        \/**\n+         * This kind is used when multiple files have been found to have warnings,\n+         * and none of them have had any similar warnings.\n+         * It generates a message like:\n+         *      Some files have ISSUES\n+         *\/\n+        IN_FILES(\".plural\"),\n+        \/**\n+         * This kind is used when multiple files have been found to have warnings,\n+         * and some of them have had already had specific similar warnings.\n+         * It generates a message like:\n+         *      Some files have additional ISSUES\n+         *\/\n+        ADDITIONAL_IN_FILES(\".plural.additional\");\n+\n+        DeferredDiagnosticKind(String v) { value = v; }\n+        String getKey(String prefix) { return prefix + value; }\n+\n+        private final String value;\n+    }\n+\n+\n+    \/**\n+     * Create an aggregator for warnings.\n+     *\n+     * @param log     The log on which to generate any diagnostics\n+     * @param source  Associated source file, or null for none\n+     * @param lc      The lint category for all warnings\n+     *\/\n+    public WarningAggregator(Log log, Source source, LintCategory lc) {\n+        this(log, source, lc, null);\n+    }\n+\n+    \/**\n+     * Create an aggregator for warnings.\n+     *\n+     * @param log     The log on which to generate any diagnostics\n+     * @param source  Associated source file, or null for none\n+     * @param lc      The lint category for all warnings\n+     * @param prefix  A common prefix for the set of message keys for the messages\n+     *                that may be generated, or null to infer from the lint category.\n+     *\/\n+    public WarningAggregator(Log log, Source source, LintCategory lc, String prefix) {\n+        this.log = log;\n+        this.source = source;\n+        this.prefix = prefix != null ? prefix : lc.option;\n+        this.lintCategory = lc;\n+    }\n+\n+    \/**\n+     * Aggregate a warning and determine whether to emit it.\n+     *\n+     * @param diagnostic the warning\n+     * @param verbose whether the warning's lint category is enabled\n+     * @return true if diagnostic should be emitted, otherwise false\n+     *\/\n+    public boolean aggregate(JCDiagnostic diagnostic, boolean verbose) {\n+        Assert.check(diagnostic.getLintCategory() == lintCategory);\n+        JavaFileObject currentSource = log.currentSourceFile();\n+        if (verbose) {\n+            if (sourcesWithReportedWarnings == null)\n+                sourcesWithReportedWarnings = new HashSet<>();\n+            if (log.nwarnings < log.MaxWarnings) {\n+                \/\/ generate message and remember the source file\n+                sourcesWithReportedWarnings.add(currentSource);\n+                anyWarningEmitted = true;\n+                return true;\n+            } else if (deferredDiagnosticKind == null) {\n+                \/\/ set up deferred message\n+                if (sourcesWithReportedWarnings.contains(currentSource)) {\n+                    \/\/ more errors in a file that already has reported warnings\n+                    deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;\n+                } else {\n+                    \/\/ warnings in a new source file\n+                    deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n+                }\n+                deferredDiagnosticSource = currentSource;\n+                deferredDiagnosticArg = currentSource;\n+            } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE\n+                        || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)\n+                       && !Objects.equals(deferredDiagnosticSource, currentSource)) {\n+                \/\/ additional errors in more than one source file\n+                deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;\n+                deferredDiagnosticArg = null;\n+            }\n+        } else {\n+            if (deferredDiagnosticKind == null) {\n+                \/\/ warnings in a single source\n+                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n+                deferredDiagnosticSource = currentSource;\n+                deferredDiagnosticArg = currentSource;\n+            }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &&\n+                        !Objects.equals(deferredDiagnosticSource, currentSource)) {\n+                \/\/ warnings in multiple source files\n+                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;\n+                deferredDiagnosticArg = null;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Build and return any accumulated aggregation notes.\n+     *\/\n+    public List<JCDiagnostic> aggregationNotes() {\n+        List<JCDiagnostic> list = new ArrayList<>(2);\n+        if (deferredDiagnosticKind != null) {\n+            if (deferredDiagnosticArg == null) {\n+                if (source != null) {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), source);\n+                } else {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));\n+                }\n+            } else {\n+                if (source != null) {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg, source);\n+                } else {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);\n+                }\n+            }\n+            if (!anyWarningEmitted)\n+                addNote(list, deferredDiagnosticSource, prefix + \".recompile\");\n+        }\n+        return list;\n+    }\n+\n+    private void addNote(List<JCDiagnostic> list, JavaFileObject file, String msg, Object... args) {\n+        list.add(log.diags.mandatoryNote(log.getSource(file), new Note(null, \"compiler\", msg, args)));\n+    }\n+\n+    \/**\n+     * The log to which to report warnings.\n+     *\/\n+    private final Log log;\n+    private final Source source;\n+\n+    \/**\n+     * The common prefix for all I18N message keys generated by this handler.\n+     *\/\n+    private final String prefix;\n+\n+    \/**\n+     * A set containing the names of the source files for which specific\n+     * warnings have been generated -- i.e. in verbose mode.  If a source name\n+     * appears in this list, then deferred diagnostics will be phrased to\n+     * include \"additionally\"...\n+     *\/\n+    private Set<JavaFileObject> sourcesWithReportedWarnings;\n+\n+    \/**\n+     * A variable indicating the latest best guess at what the final\n+     * deferred diagnostic will be. Initially as specific and helpful\n+     * as possible, as more warnings are reported, the scope of the\n+     * diagnostic will be broadened.\n+     *\/\n+    private DeferredDiagnosticKind deferredDiagnosticKind;\n+\n+    \/**\n+     * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable\n+     * gives the value of log.currentSource() for the file in question.\n+     *\/\n+    private JavaFileObject deferredDiagnosticSource;\n+\n+    \/**\n+     * An optional argument to be used when constructing the\n+     * deferred diagnostic message, based on deferredDiagnosticKind.\n+     * This variable should normally be set\/updated whenever\n+     * deferredDiagnosticKind is updated.\n+     *\/\n+    private Object deferredDiagnosticArg;\n+\n+    \/**\n+     * Whether we have actually emitted a warning or just deferred everything.\n+     * In the latter case, the \"recompile\" notice is included in the summary.\n+     *\/\n+    private boolean anyWarningEmitted;\n+\n+    \/**\n+     * A LintCategory to be included in point-of-use diagnostics to indicate\n+     * how messages might be suppressed (i.e. with @SuppressWarnings).\n+     *\/\n+    private final LintCategory lintCategory;\n+\n+    public void clear() {\n+        sourcesWithReportedWarnings = null;\n+        deferredDiagnosticKind = null;\n+        deferredDiagnosticSource = null;\n+        deferredDiagnosticArg = null;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/WarningAggregator.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"}]}