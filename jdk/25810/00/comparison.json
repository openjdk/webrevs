{"files":[{"patch":"@@ -275,2 +275,0 @@\n-                Check.instance(this).clear(); \/\/clear mandatory warning handlers\n-                Preview.instance(this).clear(); \/\/clear mandatory warning handlers\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskPool.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -43,1 +44,0 @@\n-import com.sun.tools.javac.util.MandatoryWarningHandler;\n@@ -74,3 +74,0 @@\n-    \/** the diag handler to manage preview feature usage diagnostics *\/\n-    private final MandatoryWarningHandler previewHandler;\n-\n@@ -108,1 +105,0 @@\n-        previewHandler = new MandatoryWarningHandler(log, source, verbose, true, LintCategory.PREVIEW);\n@@ -179,1 +175,2 @@\n-        previewHandler.report(pos, feature.isPlural() ?\n+        log.mandatoryWarning(pos,\n+            feature.isPlural() ?\n@@ -181,1 +178,2 @@\n-                LintWarnings.PreviewFeatureUse(feature.nameFragment()));\n+                LintWarnings.PreviewFeatureUse(feature.nameFragment()),\n+            DiagnosticFlag.AGGREGATE);\n@@ -206,4 +204,0 @@\n-    public void reportPreviewWarning(DiagnosticPosition pos, LintWarning warnKey) {\n-        previewHandler.report(pos, warnKey);\n-    }\n-\n@@ -272,11 +266,0 @@\n-    \/**\n-     * Report any deferred diagnostics.\n-     *\/\n-    public void reportDeferredDiagnostics() {\n-        previewHandler.reportDeferredDiagnostic();\n-    }\n-\n-    public void clear() {\n-        previewHandler.clear();\n-    }\n-\n@@ -286,1 +269,1 @@\n-            log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos, disabledError(feature));\n+            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, disabledError(feature));\n@@ -289,2 +272,1 @@\n-                log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos,\n-                          feature.error(source.name));\n+                log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":7,"deletions":25,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -167,12 +167,0 @@\n-        boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);\n-        boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);\n-        boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);\n-        boolean enforceMandatoryWarnings = true;\n-\n-        deprecationHandler = new MandatoryWarningHandler(log, null, verboseDeprecated,\n-                enforceMandatoryWarnings, LintCategory.DEPRECATION, \"deprecated\");\n-        removalHandler = new MandatoryWarningHandler(log, null, verboseRemoval,\n-                enforceMandatoryWarnings, LintCategory.REMOVAL);\n-        uncheckedHandler = new MandatoryWarningHandler(log, null, verboseUnchecked,\n-                enforceMandatoryWarnings, LintCategory.UNCHECKED);\n-\n@@ -195,12 +183,0 @@\n-    \/** A handler for messages about deprecated usage.\n-     *\/\n-    private MandatoryWarningHandler deprecationHandler;\n-\n-    \/** A handler for messages about deprecated-for-removal usage.\n-     *\/\n-    private MandatoryWarningHandler removalHandler;\n-\n-    \/** A handler for messages about unchecked or unsafe usage.\n-     *\/\n-    private MandatoryWarningHandler uncheckedHandler;\n-\n@@ -256,0 +232,1 @@\n+        LintWarning warningKey = null;\n@@ -259,1 +236,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym));\n+                    warningKey = LintWarnings.HasBeenDeprecatedForRemovalModule(sym);\n@@ -261,1 +238,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n+                    warningKey = LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location());\n@@ -266,1 +243,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym));\n+                warningKey = LintWarnings.HasBeenDeprecatedModule(sym);\n@@ -268,1 +245,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+                warningKey = LintWarnings.HasBeenDeprecated(sym, sym.location());\n@@ -271,0 +248,2 @@\n+        Optional.ofNullable(warningKey)\n+          .ifPresent(key -> log.mandatoryWarning(pos, key, DiagnosticFlag.AGGREGATE));\n@@ -279,1 +258,1 @@\n-            preview.reportPreviewWarning(pos, warnKey);\n+            log.mandatoryWarning(pos, warnKey, DiagnosticFlag.AGGREGATE);\n@@ -296,1 +275,1 @@\n-            uncheckedHandler.report(pos, warnKey);\n+            log.mandatoryWarning(pos, warnKey, DiagnosticFlag.AGGREGATE);\n@@ -299,10 +278,0 @@\n-    \/**\n-     * Report any deferred diagnostics.\n-     *\/\n-    public void reportDeferredDiagnostics() {\n-        deprecationHandler.reportDeferredDiagnostic();\n-        removalHandler.reportDeferredDiagnostic();\n-        uncheckedHandler.reportDeferredDiagnostic();\n-    }\n-\n-\n@@ -314,1 +283,1 @@\n-        log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));\n+        log.error(DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));\n@@ -477,6 +446,0 @@\n-    public void clear() {\n-        deprecationHandler.clear();\n-        removalHandler.clear();\n-        uncheckedHandler.clear();\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":10,"deletions":47,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import com.sun.tools.javac.code.Preview;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.util.Log;\n@@ -123,1 +124,0 @@\n-        MemoryPreview.registerInstance(context);\n@@ -125,0 +125,4 @@\n+\n+        \/\/ This suppresses diagnostics like \"Note: Recompile with -Xlint:preview for details.\"\n+        Log.instance(context).suppressAggregatedWarningNotes(LintCategory.PREVIEW);\n+\n@@ -272,15 +276,0 @@\n-\n-    static class MemoryPreview extends Preview {\n-        static void registerInstance(Context context) {\n-            context.put(previewKey, (Factory<Preview>)MemoryPreview::new);\n-        }\n-\n-        MemoryPreview(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public void reportDeferredDiagnostics() {\n-            \/\/ suppress diagnostics like \"Note: Recompile with -Xlint:preview for details.\"\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryContext.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -62,0 +61,1 @@\n+import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n@@ -88,4 +88,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n-import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n-\n@@ -277,4 +273,0 @@\n-    \/** The preview language version.\n-     *\/\n-    protected Preview preview;\n-\n@@ -416,1 +408,0 @@\n-        preview = Preview.instance(context);\n@@ -1855,2 +1846,1 @@\n-        chk.reportDeferredDiagnostics();\n-        preview.reportDeferredDiagnostics();\n+        log.reportOutstandingNotes();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.EnumSet;\n@@ -162,0 +163,1 @@\n+     * @param flags      Any additional flags required\n@@ -163,2 +165,2 @@\n-    public void warning(Warning warningKey) {\n-        report(diags.warning(source, null, warningKey));\n+    public void warning(Warning warningKey, DiagnosticFlag... flags) {\n+        warning(null, warningKey, flags);\n@@ -171,0 +173,1 @@\n+     *  @param flags         Any additional flags required\n@@ -172,2 +175,2 @@\n-    public void warning(DiagnosticPosition pos, Warning warningKey) {\n-        report(diags.warning(source, pos, warningKey));\n+    public void warning(int pos, Warning warningKey, DiagnosticFlag... flags) {\n+        warning(wrap(pos), warningKey, flags);\n@@ -180,0 +183,1 @@\n+     *  @param flags         Any additional flags required\n@@ -181,2 +185,5 @@\n-    public void warning(int pos, Warning warningKey) {\n-        report(diags.warning(source, wrap(pos), warningKey));\n+    public void warning(DiagnosticPosition pos, Warning warningKey, DiagnosticFlag... flags) {\n+        EnumSet<DiagnosticFlag> flagSet = EnumSet.noneOf(DiagnosticFlag.class);\n+        for (DiagnosticFlag flag : flags)\n+            flagSet.add(flag);\n+        report(diags.create(flagSet, source, pos, warningKey));\n@@ -185,1 +192,1 @@\n-    \/** Report a warning.\n+    \/** Report a mandatory warning.\n@@ -188,0 +195,1 @@\n+     *  @param flags         Any additional flags required\n@@ -189,2 +197,5 @@\n-    public void mandatoryWarning(DiagnosticPosition pos, Warning warningKey) {\n-        report(diags.mandatoryWarning(source, pos, warningKey));\n+    public void mandatoryWarning(DiagnosticPosition pos, Warning warningKey, DiagnosticFlag... flags) {\n+        EnumSet<DiagnosticFlag> flagSet = EnumSet.of(DiagnosticFlag.MANDATORY);\n+        for (DiagnosticFlag flag : flags)\n+            flagSet.add(flag);\n+        report(diags.create(flagSet, source, pos, warningKey));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/AbstractLog.java","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -118,27 +118,0 @@\n-        \/**\n-         * Create a warning diagnostic that will not be hidden by the -nowarn or -Xlint:none options.\n-         *  @param lc     The lint category for the diagnostic\n-         *  @param source The source of the compilation unit, if any, in which to report the warning.\n-         *  @param pos    The source position at which to report the warning.\n-         *  @param key    The key for the localized warning message.\n-         *  @param args   Fields of the warning message.\n-         *  @see MandatoryWarningHandler\n-         *\/\n-        public JCDiagnostic mandatoryWarning(\n-                LintCategory lc,\n-                DiagnosticSource source, DiagnosticPosition pos, String key, Object... args) {\n-            return mandatoryWarning(source, pos, warningKey(lc, key, args));\n-        }\n-\n-        \/**\n-         * Create a warning diagnostic that will not be hidden by the -nowarn or -Xlint:none options.\n-         *  @param source The source of the compilation unit, if any, in which to report the warning.\n-         *  @param pos    The source position at which to report the warning.\n-         *  @param warningKey    The key for the localized warning message.\n-         *  @see MandatoryWarningHandler\n-         *\/\n-        public JCDiagnostic mandatoryWarning(\n-                DiagnosticSource source, DiagnosticPosition pos, Warning warningKey) {\n-            return create(EnumSet.of(DiagnosticFlag.MANDATORY), source, pos, warningKey);\n-        }\n-\n@@ -450,0 +423,3 @@\n+        \/** Flags mandatory warnings that should pass through a mandatory warning aggregator.\n+         *\/\n+        AGGREGATE,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.EnumSet;\n@@ -44,0 +45,3 @@\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.Source;\n@@ -47,1 +51,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -53,0 +56,1 @@\n+import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;\n@@ -151,1 +155,1 @@\n-            return !(diag.isFlagSet(DiagnosticFlag.NON_DEFERRABLE) && passOnNonDeferrable) && filter.test(diag);\n+            return !(diag.isFlagSet(NON_DEFERRABLE) && passOnNonDeferrable) && filter.test(diag);\n@@ -240,0 +244,10 @@\n+    \/**\n+     * The compilation context.\n+     *\/\n+    private final Context context;\n+\n+    \/**\n+     * The root {@link Lint} singleton.\n+     *\/\n+    private Lint rootLint;\n+\n@@ -337,0 +351,1 @@\n+        this.context = context;\n@@ -520,1 +535,1 @@\n-        if (!d.isFlagSet(DiagnosticFlag.SOURCE_LEVEL))\n+        if (!d.isFlagSet(SOURCE_LEVEL))\n@@ -684,1 +699,43 @@\n-     }\n+    }\n+\n+    \/\/ Obtain root Lint singleton lazily to avoid init loops\n+    private Lint rootLint() {\n+        if (rootLint == null)\n+            rootLint = Lint.instance(context);\n+        return rootLint;\n+    }\n+\n+\/\/ Mandatory Warnings\n+\n+    private final EnumMap<LintCategory, MandatoryWarningAggregator> aggregators = new EnumMap<>(LintCategory.class);\n+\n+    private final EnumSet<LintCategory> suppressedDeferredMandatory = EnumSet.noneOf(LintCategory.class);\n+\n+    \/**\n+     * Suppress aggregated mandatory warning notes for the specified category.\n+     *\/\n+    public void suppressAggregatedWarningNotes(LintCategory category) {\n+        suppressedDeferredMandatory.add(category);\n+    }\n+\n+    \/**\n+     * Report any remaining unreported aggregated mandatory warning notes.\n+     *\/\n+    public void reportOutstandingNotes() {\n+        aggregators.entrySet().stream()\n+          .filter(entry -> !suppressedDeferredMandatory.contains(entry.getKey()))\n+          .map(Map.Entry::getValue)\n+          .map(MandatoryWarningAggregator::aggregationNotes)\n+          .flatMap(List::stream)\n+          .forEach(this::report);\n+        aggregators.clear();\n+    }\n+\n+    private MandatoryWarningAggregator aggregatorFor(LintCategory lc) {\n+        return switch (lc) {\n+        case PREVIEW -> aggregators.computeIfAbsent(lc, c -> new MandatoryWarningAggregator(this, Source.instance(context), c));\n+        case DEPRECATION -> aggregators.computeIfAbsent(lc, c -> new MandatoryWarningAggregator(this, null, c, \"deprecated\"));\n+        case REMOVAL, UNCHECKED -> aggregators.computeIfAbsent(lc, c -> new MandatoryWarningAggregator(this, null, c));\n+        case null, default -> null;\n+        };\n+    }\n@@ -698,0 +755,2 @@\n+        aggregators.values().forEach(MandatoryWarningAggregator::clear);\n+        suppressedDeferredMandatory.clear();\n@@ -700,0 +759,2 @@\n+\/\/ DefaultDiagnosticHandler\n+\n@@ -706,0 +767,1 @@\n+\n@@ -730,0 +792,10 @@\n+\n+                \/\/ Apply the appropriate mandatory warning aggregator, if needed\n+                if (diagnostic.isFlagSet(AGGREGATE)) {\n+                    LintCategory category = diagnostic.getLintCategory();\n+                    boolean verbose = rootLint().isEnabled(category);\n+                    if (!aggregatorFor(category).aggregate(diagnostic, verbose))\n+                        return;\n+                }\n+\n+                \/\/ Emit warning unless not mandatory and warnings are disabled\n@@ -741,2 +813,1 @@\n-                if (diagnostic.isFlagSet(DiagnosticFlag.API) ||\n-                     shouldReport(diagnostic)) {\n+                if (diagnostic.isFlagSet(API) || shouldReport(diagnostic)) {\n@@ -752,1 +823,1 @@\n-            if (diagnostic.isFlagSet(JCDiagnostic.DiagnosticFlag.COMPRESSED)) {\n+            if (diagnostic.isFlagSet(COMPRESSED)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":78,"deletions":7,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.util;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.Source;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n+import com.sun.tools.javac.util.JCDiagnostic.Note;\n+import com.sun.tools.javac.util.JCDiagnostic.Warning;\n+\n+\n+\/**\n+ * An aggregator for mandatory warnings, setting up a deferred diagnostic\n+ * to be printed at the end of the compilation if some warnings get suppressed\n+ * because the lint category is not enabled or too many warnings have already\n+ * been generated.\n+ *\n+ * <p>\n+ * Note that the SuppressWarnings annotation can be used to suppress warnings\n+ * about conditions that would otherwise merit a warning. Such processing\n+ * is done when the condition is detected, and in those cases, no call is\n+ * made on any API to generate a warning at all. In consequence, this handler only\n+ * Returns to handle those warnings that JLS says must be generated.\n+ *\n+ * <p>\n+ * All warnings must be in the same {@link LintCategory} provided to the constructor.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+class MandatoryWarningAggregator {\n+\n+    \/**\n+     * The kinds of different deferred diagnostics that might be generated\n+     * if a mandatory warning is suppressed because too many warnings have\n+     * already been output.\n+     *\n+     * The parameter is a fragment used to build an I18N message key for Log.\n+     *\/\n+    private enum DeferredDiagnosticKind {\n+        \/**\n+         * This kind is used when a single specific file is found to have warnings\n+         * and no similar warnings have already been given.\n+         * It generates a message like:\n+         *      FILE has ISSUES\n+         *\/\n+        IN_FILE(\".filename\"),\n+        \/**\n+         * This kind is used when a single specific file is found to have warnings\n+         * and when similar warnings have already been reported for the file.\n+         * It generates a message like:\n+         *      FILE has additional ISSUES\n+         *\/\n+        ADDITIONAL_IN_FILE(\".filename.additional\"),\n+        \/**\n+         * This kind is used when multiple files have been found to have warnings,\n+         * and none of them have had any similar warnings.\n+         * It generates a message like:\n+         *      Some files have ISSUES\n+         *\/\n+        IN_FILES(\".plural\"),\n+        \/**\n+         * This kind is used when multiple files have been found to have warnings,\n+         * and some of them have had already had specific similar warnings.\n+         * It generates a message like:\n+         *      Some files have additional ISSUES\n+         *\/\n+        ADDITIONAL_IN_FILES(\".plural.additional\");\n+\n+        DeferredDiagnosticKind(String v) { value = v; }\n+        String getKey(String prefix) { return prefix + value; }\n+\n+        private final String value;\n+    }\n+\n+\n+    \/**\n+     * Create an aggregator for mandatory warnings.\n+     *\n+     * @param log     The log on which to generate any diagnostics\n+     * @param source  Associated source file, or null for none\n+     * @param lc      The lint category for all warnings\n+     *\/\n+    public MandatoryWarningAggregator(Log log, Source source, LintCategory lc) {\n+        this(log, source, lc, null);\n+    }\n+\n+    \/**\n+     * Create an aggregator for mandatory warnings.\n+     *\n+     * @param log     The log on which to generate any diagnostics\n+     * @param source  Associated source file, or null for none\n+     * @param lc      The lint category for all warnings\n+     * @param prefix  A common prefix for the set of message keys for the messages\n+     *                that may be generated, or null to infer from the lint category.\n+     *\/\n+    public MandatoryWarningAggregator(Log log, Source source, LintCategory lc, String prefix) {\n+        this.log = log;\n+        this.source = source;\n+        this.prefix = prefix != null ? prefix : lc.option;\n+        this.lintCategory = lc;\n+    }\n+\n+    \/**\n+     * Aggregate a mandatory warning and determine whether to emit it.\n+     *\n+     * @param diagnostic the mandatory warning\n+     * @param verbose whether the warning's lint category is enabled\n+     * @return true if diagnostic should be emitted, otherwise false\n+     *\/\n+    public boolean aggregate(JCDiagnostic diagnostic, boolean verbose) {\n+        Assert.check(diagnostic.isMandatory());\n+        Assert.check(diagnostic.getLintCategory() == lintCategory);\n+        JavaFileObject currentSource = log.currentSourceFile();\n+        if (verbose) {\n+            if (sourcesWithReportedWarnings == null)\n+                sourcesWithReportedWarnings = new HashSet<>();\n+            if (log.nwarnings < log.MaxWarnings) {\n+                \/\/ generate message and remember the source file\n+                sourcesWithReportedWarnings.add(currentSource);\n+                anyWarningEmitted = true;\n+                return true;\n+            } else if (deferredDiagnosticKind == null) {\n+                \/\/ set up deferred message\n+                if (sourcesWithReportedWarnings.contains(currentSource)) {\n+                    \/\/ more errors in a file that already has reported warnings\n+                    deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;\n+                } else {\n+                    \/\/ warnings in a new source file\n+                    deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n+                }\n+                deferredDiagnosticSource = currentSource;\n+                deferredDiagnosticArg = currentSource;\n+            } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE\n+                        || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)\n+                       && !Objects.equals(deferredDiagnosticSource, currentSource)) {\n+                \/\/ additional errors in more than one source file\n+                deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;\n+                deferredDiagnosticArg = null;\n+            }\n+        } else {\n+            if (deferredDiagnosticKind == null) {\n+                \/\/ warnings in a single source\n+                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n+                deferredDiagnosticSource = currentSource;\n+                deferredDiagnosticArg = currentSource;\n+            }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &&\n+                        !Objects.equals(deferredDiagnosticSource, currentSource)) {\n+                \/\/ warnings in multiple source files\n+                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;\n+                deferredDiagnosticArg = null;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Build and return any accumulated aggregation notes.\n+     *\/\n+    public List<JCDiagnostic> aggregationNotes() {\n+        List<JCDiagnostic> list = new ArrayList<>(2);\n+        if (deferredDiagnosticKind != null) {\n+            if (deferredDiagnosticArg == null) {\n+                if (source != null) {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), source);\n+                } else {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));\n+                }\n+            } else {\n+                if (source != null) {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg, source);\n+                } else {\n+                    addNote(list, deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);\n+                }\n+            }\n+            if (!anyWarningEmitted)\n+                addNote(list, deferredDiagnosticSource, prefix + \".recompile\");\n+        }\n+        return list;\n+    }\n+\n+    private void addNote(List<JCDiagnostic> list, JavaFileObject file, String msg, Object... args) {\n+        list.add(log.diags.mandatoryNote(log.getSource(file), new Note(\"compiler\", msg, args)));\n+    }\n+\n+    \/**\n+     * The log to which to report warnings.\n+     *\/\n+    private final Log log;\n+    private final Source source;\n+\n+    \/**\n+     * The common prefix for all I18N message keys generated by this handler.\n+     *\/\n+    private final String prefix;\n+\n+    \/**\n+     * A set containing the names of the source files for which specific\n+     * warnings have been generated -- i.e. in verbose mode.  If a source name\n+     * appears in this list, then deferred diagnostics will be phrased to\n+     * include \"additionally\"...\n+     *\/\n+    private Set<JavaFileObject> sourcesWithReportedWarnings;\n+\n+    \/**\n+     * A variable indicating the latest best guess at what the final\n+     * deferred diagnostic will be. Initially as specific and helpful\n+     * as possible, as more warnings are reported, the scope of the\n+     * diagnostic will be broadened.\n+     *\/\n+    private DeferredDiagnosticKind deferredDiagnosticKind;\n+\n+    \/**\n+     * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable\n+     * gives the value of log.currentSource() for the file in question.\n+     *\/\n+    private JavaFileObject deferredDiagnosticSource;\n+\n+    \/**\n+     * An optional argument to be used when constructing the\n+     * deferred diagnostic message, based on deferredDiagnosticKind.\n+     * This variable should normally be set\/updated whenever\n+     * deferredDiagnosticKind is updated.\n+     *\/\n+    private Object deferredDiagnosticArg;\n+\n+    \/**\n+     * Whether we have actually emitted a warning or just deferred everything.\n+     * In the latter case, the \"recompile\" notice is included in the summary.\n+     *\/\n+    private boolean anyWarningEmitted;\n+\n+    \/**\n+     * A LintCategory to be included in point-of-use diagnostics to indicate\n+     * how messages might be suppressed (i.e. with @SuppressWarnings).\n+     *\/\n+    private final LintCategory lintCategory;\n+\n+    public void clear() {\n+        sourcesWithReportedWarnings = null;\n+        deferredDiagnosticKind = null;\n+        deferredDiagnosticSource = null;\n+        deferredDiagnosticArg = null;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningAggregator.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -1,309 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.util;\n-\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-import javax.tools.JavaFileObject;\n-\n-import com.sun.tools.javac.code.Lint.LintCategory;\n-import com.sun.tools.javac.code.Source;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n-import com.sun.tools.javac.util.JCDiagnostic.Note;\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n-\n-\n-\/**\n- * A handler to process mandatory warnings, setting up a deferred diagnostic\n- * to be printed at the end of the compilation if some warnings get suppressed\n- * because too many warnings have already been generated.\n- *\n- * <p>\n- * Note that the SuppressWarnings annotation can be used to suppress warnings\n- * about conditions that would otherwise merit a warning. Such processing\n- * is done when the condition is detected, and in those cases, no call is\n- * made on any API to generate a warning at all. In consequence, this handler only\n- * Returns to handle those warnings that JLS says must be generated.\n- *\n- * <p>\n- * All warnings must be in the same {@link LintCategory} provided to the constructor.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class MandatoryWarningHandler {\n-\n-    \/**\n-     * The kinds of different deferred diagnostics that might be generated\n-     * if a mandatory warning is suppressed because too many warnings have\n-     * already been output.\n-     *\n-     * The parameter is a fragment used to build an I18N message key for Log.\n-     *\/\n-    private enum DeferredDiagnosticKind {\n-        \/**\n-         * This kind is used when a single specific file is found to have warnings\n-         * and no similar warnings have already been given.\n-         * It generates a message like:\n-         *      FILE has ISSUES\n-         *\/\n-        IN_FILE(\".filename\"),\n-        \/**\n-         * This kind is used when a single specific file is found to have warnings\n-         * and when similar warnings have already been reported for the file.\n-         * It generates a message like:\n-         *      FILE has additional ISSUES\n-         *\/\n-        ADDITIONAL_IN_FILE(\".filename.additional\"),\n-        \/**\n-         * This kind is used when multiple files have been found to have warnings,\n-         * and none of them have had any similar warnings.\n-         * It generates a message like:\n-         *      Some files have ISSUES\n-         *\/\n-        IN_FILES(\".plural\"),\n-        \/**\n-         * This kind is used when multiple files have been found to have warnings,\n-         * and some of them have had already had specific similar warnings.\n-         * It generates a message like:\n-         *      Some files have additional ISSUES\n-         *\/\n-        ADDITIONAL_IN_FILES(\".plural.additional\");\n-\n-        DeferredDiagnosticKind(String v) { value = v; }\n-        String getKey(String prefix) { return prefix + value; }\n-\n-        private final String value;\n-    }\n-\n-\n-    \/**\n-     * Create a handler for mandatory warnings.\n-     *\n-     * @param log     The log on which to generate any diagnostics\n-     * @param source  Associated source file, or null for none\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n-     * @param enforceMandatory\n-     *                True if mandatory warnings and notes are being enforced.\n-     * @param lc      The lint category for all warnings\n-     *\/\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc) {\n-        this(log, source, verbose, enforceMandatory, lc, null);\n-    }\n-\n-    \/**\n-     * Create a handler for mandatory warnings.\n-     *\n-     * @param log     The log on which to generate any diagnostics\n-     * @param source  Associated source file, or null for none\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n-     * @param enforceMandatory\n-     *                True if mandatory warnings and notes are being enforced.\n-     * @param lc      The lint category for all warnings\n-     * @param prefix  A common prefix for the set of message keys for the messages\n-     *                that may be generated, or null to infer from the lint category.\n-     *\/\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc, String prefix) {\n-        this.log = log;\n-        this.source = source;\n-        this.verbose = verbose;\n-        this.prefix = prefix != null ? prefix : lc.option;\n-        this.enforceMandatory = enforceMandatory;\n-        this.lintCategory = lc;\n-    }\n-\n-    \/**\n-     * Report a mandatory warning.\n-     *\n-     * @param pos source code position\n-     * @param warnKey lint warning\n-     *\/\n-    public void report(DiagnosticPosition pos, LintWarning warnKey) {\n-        JavaFileObject currentSource = log.currentSourceFile();\n-        Assert.check(warnKey.getLintCategory() == lintCategory);\n-\n-        if (verbose) {\n-            if (sourcesWithReportedWarnings == null)\n-                sourcesWithReportedWarnings = new HashSet<>();\n-\n-            if (log.nwarnings < log.MaxWarnings) {\n-                \/\/ generate message and remember the source file\n-                logMandatoryWarning(pos, warnKey);\n-                sourcesWithReportedWarnings.add(currentSource);\n-            } else if (deferredDiagnosticKind == null) {\n-                \/\/ set up deferred message\n-                if (sourcesWithReportedWarnings.contains(currentSource)) {\n-                    \/\/ more errors in a file that already has reported warnings\n-                    deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;\n-                } else {\n-                    \/\/ warnings in a new source file\n-                    deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n-                }\n-                deferredDiagnosticSource = currentSource;\n-                deferredDiagnosticArg = currentSource;\n-            } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE\n-                        || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)\n-                       && !Objects.equals(deferredDiagnosticSource, currentSource)) {\n-                \/\/ additional errors in more than one source file\n-                deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;\n-                deferredDiagnosticArg = null;\n-            }\n-        } else {\n-            if (deferredDiagnosticKind == null) {\n-                \/\/ warnings in a single source\n-                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;\n-                deferredDiagnosticSource = currentSource;\n-                deferredDiagnosticArg = currentSource;\n-            }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &&\n-                        !Objects.equals(deferredDiagnosticSource, currentSource)) {\n-                \/\/ warnings in multiple source files\n-                deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;\n-                deferredDiagnosticArg = null;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Report any diagnostic that might have been deferred by previous calls of report().\n-     *\/\n-    public void reportDeferredDiagnostic() {\n-        if (deferredDiagnosticKind != null) {\n-            if (deferredDiagnosticArg == null) {\n-                if (source != null) {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), source);\n-                } else {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));\n-                }\n-            } else {\n-                if (source != null) {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg, source);\n-                } else {\n-                    logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);\n-                }\n-            }\n-\n-            if (!verbose)\n-                logMandatoryNote(deferredDiagnosticSource, prefix + \".recompile\");\n-        }\n-    }\n-\n-    \/**\n-     * The log to which to report warnings.\n-     *\/\n-    private final Log log;\n-    private final Source source;\n-\n-    \/**\n-     * Whether or not to report individual warnings, or simply to report a\n-     * single aggregate warning at the end of the compilation.\n-     *\/\n-    private final boolean verbose;\n-\n-    \/**\n-     * The common prefix for all I18N message keys generated by this handler.\n-     *\/\n-    private final String prefix;\n-\n-    \/**\n-     * A set containing the names of the source files for which specific\n-     * warnings have been generated -- i.e. in verbose mode.  If a source name\n-     * appears in this list, then deferred diagnostics will be phrased to\n-     * include \"additionally\"...\n-     *\/\n-    private Set<JavaFileObject> sourcesWithReportedWarnings;\n-\n-    \/**\n-     * A variable indicating the latest best guess at what the final\n-     * deferred diagnostic will be. Initially as specific and helpful\n-     * as possible, as more warnings are reported, the scope of the\n-     * diagnostic will be broadened.\n-     *\/\n-    private DeferredDiagnosticKind deferredDiagnosticKind;\n-\n-    \/**\n-     * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable\n-     * gives the value of log.currentSource() for the file in question.\n-     *\/\n-    private JavaFileObject deferredDiagnosticSource;\n-\n-    \/**\n-     * An optional argument to be used when constructing the\n-     * deferred diagnostic message, based on deferredDiagnosticKind.\n-     * This variable should normally be set\/updated whenever\n-     * deferredDiagnosticKind is updated.\n-     *\/\n-    private Object deferredDiagnosticArg;\n-\n-    \/**\n-     * True if mandatory warnings and notes are being enforced.\n-     *\/\n-    private final boolean enforceMandatory;\n-\n-    \/**\n-     * A LintCategory to be included in point-of-use diagnostics to indicate\n-     * how messages might be suppressed (i.e. with @SuppressWarnings).\n-     *\/\n-    private final LintCategory lintCategory;\n-\n-    \/**\n-     * Reports a mandatory warning to the log.  If mandatory warnings\n-     * are not being enforced, treat this as an ordinary warning.\n-     *\/\n-    private void logMandatoryWarning(DiagnosticPosition pos, LintWarning warnKey) {\n-        if (enforceMandatory)\n-            log.mandatoryWarning(pos, warnKey);\n-        else\n-            log.warning(pos, warnKey);\n-    }\n-\n-    \/**\n-     * Reports a mandatory note to the log.  If mandatory notes are\n-     * not being enforced, treat this as an ordinary note.\n-     *\/\n-    private void logMandatoryNote(JavaFileObject file, String msg, Object... args) {\n-        if (enforceMandatory)\n-            log.mandatoryNote(file, new Note(\"compiler\", msg, args));\n-        else\n-            log.note(file, new Note(\"compiler\", msg, args));\n-    }\n-\n-    public void clear() {\n-        sourcesWithReportedWarnings = null;\n-        deferredDiagnosticKind = null;\n-        deferredDiagnosticSource = null;\n-        deferredDiagnosticArg = null;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningHandler.java","additions":0,"deletions":309,"binary":false,"changes":309,"status":"deleted"}]}