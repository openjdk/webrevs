{"files":[{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import jdk.internal.access.JavaObjectStreamReflectionAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArray;\n+\n+\/**\n+ * Utilities relating to serialization and deserialization of objects.\n+ *\/\n+final class ObjectStreamReflection {\n+\n+    \/\/ todo: these could be constants\n+    private static final MethodHandle DRO_HANDLE;\n+    private static final MethodHandle DWO_HANDLE;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MethodType droType = MethodType.methodType(void.class, ObjectStreamClass.class, Object.class, ObjectInputStream.class);\n+            DRO_HANDLE = lookup.findStatic(ObjectStreamReflection.class, \"defaultReadObject\", droType);\n+            MethodType dwoType = MethodType.methodType(void.class, ObjectStreamClass.class, Object.class, ObjectOutputStream.class);\n+            DWO_HANDLE = lookup.findStatic(ObjectStreamReflection.class, \"defaultWriteObject\", dwoType);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Populate a serializable object from data acquired from the stream's\n+     * {@link java.io.ObjectInputStream.GetField} object independently of\n+     * the actual {@link ObjectInputStream} implementation which may\n+     * arbitrarily override the {@link ObjectInputStream#readFields()} method\n+     * in order to deserialize using a custom object format.\n+     * <p>\n+     * The fields are populated using the mechanism defined in {@link ObjectStreamClass},\n+     * which requires objects and primitives to each be packed into a separate array\n+     * whose relative field offsets are defined in the {@link ObjectStreamField}\n+     * corresponding to each field.\n+     * Utility methods on the {@code ObjectStreamClass} instance are then used\n+     * to validate and perform the actual field accesses.\n+     *\n+     * @param streamClass the object stream class of the object (must not be {@code null})\n+     * @param obj the object to deserialize (must not be {@code null})\n+     * @param ois the object stream (must not be {@code null})\n+     * @throws IOException if the call to {@link ObjectInputStream#readFields}\n+     *                     or one of its field accessors throws this exception type\n+     * @throws ClassNotFoundException if the call to {@link ObjectInputStream#readFields}\n+     *                                or one of its field accessors throws this exception type\n+     *\/\n+    private static void defaultReadObject(ObjectStreamClass streamClass, Object obj, ObjectInputStream ois)\n+            throws IOException, ClassNotFoundException {\n+        ObjectInputStream.GetField getField = ois.readFields();\n+        byte[] bytes = new byte[streamClass.getPrimDataSize()];\n+        Object[] objs = new Object[streamClass.getNumObjFields()];\n+        for (ObjectStreamField field : streamClass.getFields(false)) {\n+            int offset = field.getOffset();\n+            String fieldName = field.getName();\n+            switch (field.getTypeCode()) {\n+                case 'B' -> bytes[offset] = getField.get(fieldName, (byte) 0);\n+                case 'C' -> ByteArray.setChar(bytes, offset, getField.get(fieldName, (char) 0));\n+                case 'D' -> ByteArray.setDoubleRaw(bytes, offset, getField.get(fieldName, 0.0));\n+                case 'F' -> ByteArray.setFloatRaw(bytes, offset, getField.get(fieldName, 0.0f));\n+                case 'I' -> ByteArray.setInt(bytes, offset, getField.get(fieldName, 0));\n+                case 'J' -> ByteArray.setLong(bytes, offset, getField.get(fieldName, 0L));\n+                case 'S' -> ByteArray.setShort(bytes, offset, getField.get(fieldName, (short) 0));\n+                case 'Z' -> ByteArray.setBoolean(bytes, offset, getField.get(fieldName, false));\n+                case '[', 'L' -> objs[offset] = getField.get(fieldName, null);\n+                default -> throw new IllegalStateException();\n+            }\n+        }\n+        streamClass.checkObjFieldValueTypes(obj, objs);\n+        streamClass.setPrimFieldValues(obj, bytes);\n+        streamClass.setObjFieldValues(obj, objs);\n+    }\n+\n+    \/**\n+     * Populate and write a stream's {@link java.io.ObjectOutputStream.PutField} object\n+     * from field data acquired from a serializable object independently of\n+     * the actual {@link ObjectOutputStream} implementation which may\n+     * arbitrarily override the {@link ObjectOutputStream#putFields()}\n+     * and {@link ObjectOutputStream#writeFields()} methods\n+     * in order to deserialize using a custom object format.\n+     * <p>\n+     * The fields are accessed using the mechanism defined in {@link ObjectStreamClass},\n+     * which causes objects and primitives to each be packed into a separate array\n+     * whose relative field offsets are defined in the {@link ObjectStreamField}\n+     * corresponding to each field.\n+     *\n+     * @param streamClass the object stream class of the object (must not be {@code null})\n+     * @param obj the object to serialize (must not be {@code null})\n+     * @param oos the object stream (must not be {@code null})\n+     * @throws IOException if the call to {@link ObjectInputStream#readFields}\n+     *                     or one of its field accessors throws this exception type\n+     *\/\n+    private static void defaultWriteObject(ObjectStreamClass streamClass, Object obj, ObjectOutputStream oos)\n+            throws IOException {\n+        ObjectOutputStream.PutField putField = oos.putFields();\n+        byte[] bytes = new byte[streamClass.getPrimDataSize()];\n+        Object[] objs = new Object[streamClass.getNumObjFields()];\n+        streamClass.getPrimFieldValues(obj, bytes);\n+        streamClass.getObjFieldValues(obj, objs);\n+        for (ObjectStreamField field : streamClass.getFields(false)) {\n+            int offset = field.getOffset();\n+            String fieldName = field.getName();\n+            switch (field.getTypeCode()) {\n+                case 'B' -> putField.put(fieldName, bytes[offset]);\n+                case 'C' -> putField.put(fieldName, ByteArray.getChar(bytes, offset));\n+                case 'D' -> putField.put(fieldName, ByteArray.getDouble(bytes, offset));\n+                case 'F' -> putField.put(fieldName, ByteArray.getFloat(bytes, offset));\n+                case 'I' -> putField.put(fieldName, ByteArray.getInt(bytes, offset));\n+                case 'J' -> putField.put(fieldName, ByteArray.getLong(bytes, offset));\n+                case 'S' -> putField.put(fieldName, ByteArray.getShort(bytes, offset));\n+                case 'Z' -> putField.put(fieldName, ByteArray.getBoolean(bytes, offset));\n+                case '[', 'L' -> putField.put(fieldName, objs[offset]);\n+                default -> throw new IllegalStateException();\n+            }\n+        }\n+        oos.writeFields();\n+    }\n+\n+    static final class Access implements JavaObjectStreamReflectionAccess {\n+        static {\n+            SharedSecrets.setJavaObjectStreamReflectionAccess(new Access());\n+        }\n+\n+        public MethodHandle defaultReadObject(Class<?> clazz) {\n+            return handleForClass(DRO_HANDLE, clazz, ObjectInputStream.class);\n+        }\n+\n+        public MethodHandle defaultWriteObject(Class<?> clazz) {\n+            return handleForClass(DWO_HANDLE, clazz, ObjectOutputStream.class);\n+        }\n+\n+        private static MethodHandle handleForClass(final MethodHandle handle, final Class<?> clazz, final Class<?> ioClass) {\n+            ObjectStreamClass streamClass = ObjectStreamClass.lookup(clazz);\n+            if (streamClass != null) {\n+                try {\n+                    streamClass.checkDefaultSerialize();\n+                    return handle.bindTo(streamClass)\n+                        .asType(MethodType.methodType(void.class, clazz, ioClass));\n+                } catch (InvalidClassException e) {\n+                    \/\/ ignore and return null\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamReflection.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+public interface JavaObjectStreamReflectionAccess {\n+    MethodHandle defaultReadObject(Class<?> clazz);\n+    MethodHandle defaultWriteObject(Class<?> clazz);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaObjectStreamReflectionAccess.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -82,0 +82,1 @@\n+    private static JavaObjectStreamReflectionAccess javaObjectStreamReflectionAccess;\n@@ -462,0 +463,15 @@\n+    public static JavaObjectStreamReflectionAccess getJavaObjectStreamReflectionAccess() {\n+        var access = javaObjectStreamReflectionAccess;\n+        if (access == null) {\n+            try {\n+                Class.forName(\"java.io.ObjectStreamReflection$Access\", true, null);\n+                access = javaObjectStreamReflectionAccess;\n+            } catch (ClassNotFoundException e) {}\n+        }\n+        return access;\n+    }\n+\n+    public static void setJavaObjectStreamReflectionAccess(JavaObjectStreamReflectionAccess access) {\n+        javaObjectStreamReflectionAccess = access;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.io.ObjectStreamField;\n@@ -42,0 +43,1 @@\n+import java.lang.reflect.Proxy;\n@@ -44,0 +46,2 @@\n+import java.util.Set;\n+\n@@ -72,0 +76,1 @@\n+\n@@ -384,0 +389,40 @@\n+    public final MethodHandle defaultReadObjectForSerialization(Class<?> cl) {\n+        if (hasDefaultOrNoSerialization(cl)) {\n+            return null;\n+        }\n+\n+        return SharedSecrets.getJavaObjectStreamReflectionAccess().defaultReadObject(cl);\n+    }\n+\n+    public final MethodHandle defaultWriteObjectForSerialization(Class<?> cl) {\n+        if (hasDefaultOrNoSerialization(cl)) {\n+            return null;\n+        }\n+\n+        return SharedSecrets.getJavaObjectStreamReflectionAccess().defaultWriteObject(cl);\n+    }\n+\n+    \/**\n+     * These are specific leaf classes which appear to be Serializable, but which\n+     * have special semantics according to the serialization specification. We\n+     * could theoretically include array classes here, but it is easier and clearer\n+     * to just use `Class#isArray` instead.\n+     *\/\n+    private static final Set<Class<?>> nonSerializableLeafClasses = Set.of(\n+        Class.class,\n+        String.class,\n+        ObjectStreamClass.class\n+    );\n+\n+    private static boolean hasDefaultOrNoSerialization(Class<?> cl) {\n+        return ! Serializable.class.isAssignableFrom(cl)\n+            || cl.isInterface()\n+            || cl.isArray()\n+            || Proxy.isProxyClass(cl)\n+            || Externalizable.class.isAssignableFrom(cl)\n+            || cl.isEnum()\n+            || cl.isRecord()\n+            || cl.isHidden()\n+            || nonSerializableLeafClasses.contains(cl);\n+    }\n+\n@@ -489,0 +534,22 @@\n+    public final ObjectStreamField[] serialPersistentFields(Class<?> cl) {\n+        if (! Serializable.class.isAssignableFrom(cl) || cl.isInterface() || cl.isEnum()) {\n+            return null;\n+        }\n+\n+        try {\n+            Field field = cl.getDeclaredField(\"serialPersistentFields\");\n+            int mods = field.getModifiers();\n+            if (! (Modifier.isStatic(mods) && Modifier.isPrivate(mods) && Modifier.isFinal(mods))) {\n+                return null;\n+            }\n+            if (field.getType() != ObjectStreamField[].class) {\n+                return null;\n+            }\n+            field.setAccessible(true);\n+            ObjectStreamField[] array = (ObjectStreamField[]) field.get(null);\n+            return array != null && array.length > 0 ? array.clone() : array;\n+        } catch (ReflectiveOperationException e) {\n+            return null;\n+        }\n+    }\n+\n@@ -578,1 +645,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamField;\n@@ -160,0 +163,44 @@\n+    \/**\n+     * Generate and return a direct MethodHandle which implements\n+     * the general default behavior for serializable class's {@code readObject}.\n+     * The generated method behaves in accordance with the\n+     * Java Serialization specification's rules for that method.\n+     * <p>\n+     * The generated method will invoke {@link ObjectInputStream#readFields()}\n+     * to acquire the stream field values. The serialization fields of the class will\n+     * then be populated from the stream values.\n+     * <p>\n+     * Only fields which are eligible for default serialization will be populated.\n+     * This includes only fields which are not {@code transient} and not {@code static}\n+     * (even if the field is {@code final} or {@code private}).\n+     * <p>\n+     * Requesting a default serialization method for a class in a disallowed\n+     * category is not supported; {@code null} will be returned for such classes.\n+     * The disallowed categories include (but are not limited to):\n+     * <ul>\n+     *     <li>Classes which do not implement {@code Serializable}<\/li>\n+     *     <li>Classes which implement {@code Externalizable}<\/li>\n+     *     <li>Classes which are specially handled by the Java Serialization specification,\n+     *     including record classes, enum constant classes, {@code Class}, {@code String},\n+     *     array classes, reflection proxy classes, and hidden classes<\/li>\n+     *     <li>Classes which declare a valid {@code serialPersistentFields} value<\/li>\n+     *     <li>Any special types which may possibly be added to the JDK or the Java language\n+     *     in the future which in turn might require special handling by the\n+     *     provisions of the corresponding future version of the Java Serialization\n+     *     specification<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The generated method will accept the instance as its first argument\n+     * and the {@code ObjectInputStream} as its second argument.\n+     * The return type of the method is {@code void}.\n+     *\n+     * @param cl a Serializable class\n+     * @return  a direct MethodHandle for the synthetic {@code readObject} method\n+     *          or {@code null} if the class falls in a disallowed category\n+     *\n+     * @since 24\n+     *\/\n+    public final MethodHandle defaultReadObjectForSerialization(Class<?> cl) {\n+        return delegate.defaultReadObjectForSerialization(cl);\n+    }\n+\n@@ -175,0 +222,47 @@\n+    \/**\n+     * Generate and return a direct MethodHandle which implements\n+     * the general default behavior for serializable class's {@code writeObject}.\n+     * The generated method behaves in accordance with the\n+     * Java Serialization specification's rules for that method.\n+     * <p>\n+     * The generated method will invoke {@link ObjectOutputStream#putFields}\n+     * to acquire the buffer for the stream field values. The buffer will\n+     * be populated from the serialization fields of the class. The buffer\n+     * will then be flushed to the stream using the\n+     * {@link ObjectOutputStream#writeFields()} method.\n+     * <p>\n+     * Only fields which are eligible for default serialization will be written\n+     * to the buffer.\n+     * This includes only fields which are not {@code transient} and not {@code static}\n+     * (even if the field is {@code final} or {@code private}).\n+     * <p>\n+     * Requesting a default serialization method for a class in a disallowed\n+     * category is not supported; {@code null} will be returned for such classes.\n+     * The disallowed categories include (but are not limited to):\n+     * <ul>\n+     *     <li>Classes which do not implement {@code Serializable}<\/li>\n+     *     <li>Classes which implement {@code Externalizable}<\/li>\n+     *     <li>Classes which are specially handled by the Java Serialization specification,\n+     *     including record classes, enum constant classes, {@code Class}, {@code String},\n+     *     array classes, reflection proxy classes, and hidden classes<\/li>\n+     *     <li>Classes which declare a valid {@code serialPersistentFields} value<\/li>\n+     *     <li>Any special types which may possibly be added to the JDK or the Java language\n+     *     in the future which in turn might require special handling by the\n+     *     provisions of the corresponding future version of the Java Serialization\n+     *     specification<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The generated method will accept the instance as its first argument\n+     * and the {@code ObjectOutputStream} as its second argument.\n+     * The return type of the method is {@code void}.\n+     *\n+     * @param cl a Serializable class\n+     * @return  a direct MethodHandle for the synthetic {@code writeObject} method\n+     *          or {@code null} if the class falls in a disallowed category\n+     *\n+     * @since 24\n+     *\/\n+    public final MethodHandle defaultWriteObjectForSerialization(Class<?> cl) {\n+        return delegate.defaultWriteObjectForSerialization(cl);\n+    }\n+\n@@ -228,0 +322,17 @@\n+\n+    \/**\n+     * {@return the declared {@code serialPersistentFields} from a\n+     * serializable class, or {@code null} if none is declared, the field\n+     * is declared but not valid, or the class is not a valid serializable class}\n+     * A class is a valid serializable class if it implements {@code Serializable}\n+     * but not {@code Externalizable}. The {@code serialPersistentFields} field\n+     * is valid if it meets the type and accessibility restrictions defined\n+     * by the Java Serialization specification.\n+     *\n+     * @param cl a Serializable class\n+     *\n+     * @since 24\n+     *\/\n+    public final ObjectStreamField[] serialPersistentFields(Class<?> cl) {\n+        return delegate.serialPersistentFields(cl);\n+    }\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/reflect\/ReflectionFactory.java","additions":112,"deletions":1,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.io.ObjectStreamClass;\n@@ -33,0 +34,1 @@\n+import java.io.ObjectStreamField;\n@@ -34,0 +36,1 @@\n+import java.io.Serial;\n@@ -38,0 +41,1 @@\n+import java.util.Arrays;\n@@ -49,1 +53,1 @@\n- * @bug 8137058 8164908 8168980 8275137\n+ * @bug 8137058 8164908 8168980 8275137 8333796\n@@ -330,0 +334,503 @@\n+    private static final String[] names = {\n+        \"boolean_\",\n+        \"final_boolean\",\n+        \"byte_\",\n+        \"final_byte\",\n+        \"char_\",\n+        \"final_char\",\n+        \"short_\",\n+        \"final_short\",\n+        \"int_\",\n+        \"final_int\",\n+        \"long_\",\n+        \"final_long\",\n+        \"float_\",\n+        \"final_float\",\n+        \"double_\",\n+        \"final_double\",\n+        \"str\",\n+        \"final_str\",\n+        \"writeFields\",\n+    };\n+\n+    \/\/ test that the generated read\/write objects are working properly\n+    @Test\n+    static void testDefaultReadWriteObject() throws Throwable {\n+        Ser2 ser = new Ser2((byte) 0x33, (short) 0x2244, (char) 0x5342, 0x05382716, 0xf035a73b09113bacL, 1234f, 3456.0, true, new Ser3(0x004917aa));\n+        ser.byte_ = (byte) 0x44;\n+        ser.short_ = (short) 0x3355;\n+        ser.char_ = (char) 0x6593;\n+        ser.int_ = 0x4928a299;\n+        ser.long_ = 0x24aa19883f4b9138L;\n+        ser.float_ = 4321f;\n+        ser.double_ = 6543.0;\n+        ser.boolean_ = false;\n+        ser.ser = new Ser3(0x70b030a0);\n+        \/\/ first, ensure that each field gets written\n+        MethodHandle writeObject = factory.defaultWriteObjectForSerialization(Ser2.class);\n+        Assert.assertNotNull(writeObject, \"writeObject not created\");\n+        boolean[] called = new boolean[19];\n+        @SuppressWarnings(\"removal\")\n+        ObjectOutputStream oos = new ObjectOutputStream() {\n+            protected void writeObjectOverride(final Object obj) throws IOException {\n+                throw new IOException(\"Wrong method called\");\n+            }\n+\n+            public void defaultWriteObject() throws IOException {\n+                throw new IOException(\"Wrong method called\");\n+            }\n+\n+            public void writeFields() {\n+                called[18] = true;\n+            }\n+\n+            public PutField putFields() {\n+                return new PutField() {\n+                    public void put(final String name, final boolean val) {\n+                        switch (name) {\n+                            case \"boolean_\" -> {\n+                                Assert.assertFalse(val);\n+                                called[0] = true;\n+                            }\n+                            case \"final_boolean\" -> {\n+                                Assert.assertTrue(val);\n+                                called[1] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final byte val) {\n+                        switch (name) {\n+                            case \"byte_\" -> {\n+                                Assert.assertEquals(val, (byte) 0x44);\n+                                called[2] = true;\n+                            }\n+                            case \"final_byte\" -> {\n+                                Assert.assertEquals(val, (byte) 0x33);\n+                                called[3] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final char val) {\n+                        switch (name) {\n+                            case \"char_\" -> {\n+                                Assert.assertEquals(val, (char) 0x6593);\n+                                called[4] = true;\n+                            }\n+                            case \"final_char\" -> {\n+                                Assert.assertEquals(val, (char) 0x5342);\n+                                called[5] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final short val) {\n+                        switch (name) {\n+                            case \"short_\" -> {\n+                                Assert.assertEquals(val, (short) 0x3355);\n+                                called[6] = true;\n+                            }\n+                            case \"final_short\" -> {\n+                                Assert.assertEquals(val, (short) 0x2244);\n+                                called[7] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final int val) {\n+                        switch (name) {\n+                            case \"int_\" -> {\n+                                Assert.assertEquals(val, 0x4928a299);\n+                                called[8] = true;\n+                            }\n+                            case \"final_int\" -> {\n+                                Assert.assertEquals(val, 0x05382716);\n+                                called[9] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final long val) {\n+                        switch (name) {\n+                            case \"long_\" -> {\n+                                Assert.assertEquals(val, 0x24aa19883f4b9138L);\n+                                called[10] = true;\n+                            }\n+                            case \"final_long\" -> {\n+                                Assert.assertEquals(val, 0xf035a73b09113bacL);\n+                                called[11] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final float val) {\n+                        switch (name) {\n+                            case \"float_\" -> {\n+                                Assert.assertEquals(val, 4321f);\n+                                called[12] = true;\n+                            }\n+                            case \"final_float\" -> {\n+                                Assert.assertEquals(val, 1234f);\n+                                called[13] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final double val) {\n+                        switch (name) {\n+                            case \"double_\" -> {\n+                                Assert.assertEquals(val, 6543.0);\n+                                called[14] = true;\n+                            }\n+                            case \"final_double\" -> {\n+                                Assert.assertEquals(val, 3456.0);\n+                                called[15] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final Object val) {\n+                        switch (name) {\n+                            case \"ser\" -> {\n+                                Assert.assertEquals(val, new Ser3(0x70b030a0));\n+                                called[16] = true;\n+                            }\n+                            case \"final_ser\" -> {\n+                                Assert.assertEquals(val, new Ser3(0x004917aa));\n+                                called[17] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    @SuppressWarnings(\"removal\")\n+                    public void write(final ObjectOutput out) throws IOException {\n+                        throw new IOException(\"Wrong method called\");\n+                    }\n+                };\n+            }\n+        };\n+        writeObject.invokeExact(ser, oos);\n+        for (int i = 0; i < 19; i ++) {\n+            Assert.assertTrue(called[i], names[i]);\n+        }\n+        \/\/ now, test the read side\n+        MethodHandle readObject = factory.defaultReadObjectForSerialization(Ser2.class);\n+        Assert.assertNotNull(readObject, \"readObject not created\");\n+        @SuppressWarnings(\"removal\")\n+        ObjectInputStream ois = new ObjectInputStream() {\n+            protected Object readObjectOverride() throws IOException {\n+                throw new IOException(\"Wrong method called\");\n+            }\n+\n+            public GetField readFields() {\n+                return new GetField() {\n+                    public ObjectStreamClass getObjectStreamClass() {\n+                        throw new Error(\"Wrong method called\");\n+                    }\n+\n+                    public boolean defaulted(final String name) throws IOException {\n+                        throw new IOException(\"Wrong method called\");\n+                    }\n+\n+                    public boolean get(final String name, final boolean val) {\n+                        return switch (name) {\n+                            case \"boolean_\" -> {\n+                                called[0] = true;\n+                                yield true;\n+                            }\n+                            case \"final_boolean\" -> {\n+                                called[1] = true;\n+                                yield true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public byte get(final String name, final byte val) {\n+                        return switch (name) {\n+                            case \"byte_\" -> {\n+                                called[2] = true;\n+                                yield (byte) 0x11;\n+                            }\n+                            case \"final_byte\" -> {\n+                                called[3] = true;\n+                                yield (byte) 0x9f;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public char get(final String name, final char val) {\n+                        return switch (name) {\n+                            case \"char_\" -> {\n+                                called[4] = true;\n+                                yield (char) 0x59a2;\n+                            }\n+                            case \"final_char\" -> {\n+                                called[5] = true;\n+                                yield (char) 0xe0d0;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public short get(final String name, final short val) {\n+                        return switch (name) {\n+                            case \"short_\" -> {\n+                                called[6] = true;\n+                                yield (short) 0x0917;\n+                            }\n+                            case \"final_short\" -> {\n+                                called[7] = true;\n+                                yield (short) 0x110e;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public int get(final String name, final int val) {\n+                        return switch (name) {\n+                            case \"int_\" -> {\n+                                called[8] = true;\n+                                yield 0xd0244e19;\n+                            }\n+                            case \"final_int\" -> {\n+                                called[9] = true;\n+                                yield 0x011004da;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public long get(final String name, final long val) {\n+                        return switch (name) {\n+                            case \"long_\" -> {\n+                                called[10] = true;\n+                                yield 0x0b8101d84aa31711L;\n+                            }\n+                            case \"final_long\" -> {\n+                                called[11] = true;\n+                                yield 0x30558aa7189ed821L;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public float get(final String name, final float val) {\n+                        return switch (name) {\n+                            case \"float_\" -> {\n+                                called[12] = true;\n+                                yield 0x5.01923ap18f;\n+                            }\n+                            case \"final_float\" -> {\n+                                called[13] = true;\n+                                yield 0x0.882afap1f;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public double get(final String name, final double val) {\n+                        return switch (name) {\n+                            case \"double_\" -> {\n+                                called[14] = true;\n+                                yield 0x9.4a8fp6;\n+                            }\n+                            case \"final_double\" -> {\n+                                called[15] = true;\n+                                yield 0xf.881a8p4;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public Object get(final String name, final Object val) {\n+                        return switch (name) {\n+                            case \"ser\" -> {\n+                                called[16] = true;\n+                                yield new Ser3(0x44cc55dd);\n+                            }\n+                            case \"final_ser\" -> {\n+                                called[17] = true;\n+                                yield new Ser3(0x9a8b7c6d);\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+                };\n+            }\n+        };\n+        \/\/ all the same methods, except for `writeFields`\n+        Arrays.fill(called, false);\n+        Constructor<?> ctor = factory.newConstructorForSerialization(Ser2.class, Object.class.getDeclaredConstructor());\n+        ser = (Ser2) ctor.newInstance();\n+        readObject.invokeExact(ser, ois);\n+        \/\/ excluding \"writeFields\", so 18 instead of 19\n+        for (int i = 0; i < 18; i ++) {\n+            Assert.assertTrue(called[i], names[i]);\n+        }\n+        Assert.assertEquals(ser.byte_, (byte)0x11);\n+        Assert.assertEquals(ser.final_byte, (byte)0x9f);\n+        Assert.assertEquals(ser.char_, (char)0x59a2);\n+        Assert.assertEquals(ser.final_char, (char)0xe0d0);\n+        Assert.assertEquals(ser.short_, (short)0x0917);\n+        Assert.assertEquals(ser.final_short, (short)0x110e);\n+        Assert.assertEquals(ser.int_, 0xd0244e19);\n+        Assert.assertEquals(ser.final_int, 0x011004da);\n+        Assert.assertEquals(ser.long_, 0x0b8101d84aa31711L);\n+        Assert.assertEquals(ser.final_long, 0x30558aa7189ed821L);\n+        Assert.assertEquals(ser.float_, 0x5.01923ap18f);\n+        Assert.assertEquals(ser.final_float, 0x0.882afap1f);\n+        Assert.assertEquals(ser.double_, 0x9.4a8fp6);\n+        Assert.assertEquals(ser.final_double, 0xf.881a8p4);\n+        Assert.assertEquals(ser.ser, new Ser3(0x44cc55dd));\n+        Assert.assertEquals(ser.final_ser, new Ser3(0x9a8b7c6d));\n+    }\n+\n+    static class Ser2 implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = -2852896623833548574L;\n+\n+        byte byte_;\n+        short short_;\n+        char char_;\n+        int int_;\n+        long long_;\n+        float float_;\n+        double double_;\n+        boolean boolean_;\n+        Ser3 ser;\n+\n+        final byte final_byte;\n+        final short final_short;\n+        final char final_char;\n+        final int final_int;\n+        final long final_long;\n+        final float final_float;\n+        final double final_double;\n+        final boolean final_boolean;\n+        final Ser3 final_ser;\n+\n+        Ser2(final byte final_byte, final short final_short, final char final_char, final int final_int,\n+            final long final_long, final float final_float, final double final_double,\n+            final boolean final_boolean, final Ser3 final_ser) {\n+\n+            this.final_byte = final_byte;\n+            this.final_short = final_short;\n+            this.final_char = final_char;\n+            this.final_int = final_int;\n+            this.final_long = final_long;\n+            this.final_float = final_float;\n+            this.final_double = final_double;\n+            this.final_boolean = final_boolean;\n+            this.final_ser = final_ser;\n+        }\n+    }\n+\n+    static class Ser3 implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = -1234752876749422678L;\n+\n+        @Serial\n+        private static final ObjectStreamField[] serialPersistentFields = {\n+            new ObjectStreamField(\"value\", int.class)\n+        };\n+\n+        final int value;\n+\n+        Ser3(final int value) {\n+            this.value = value;\n+        }\n+\n+        public boolean equals(final Object obj) {\n+            return obj instanceof Ser3 s && value == s.value;\n+        }\n+\n+        public int hashCode() {\n+            return value;\n+        }\n+    }\n+\n+    static class SerInvalidFields implements Serializable {\n+        \/\/ this is deliberately wrong\n+        @SuppressWarnings({\"unused\", \"serial\"})\n+        @Serial\n+        private static final String serialPersistentFields = \"Oops!\";\n+        @Serial\n+        private static final long serialVersionUID = -8090960816811629489L;\n+    }\n+\n+    static class Ext1 implements Externalizable {\n+\n+        @Serial\n+        private static final long serialVersionUID = 7109990719266285013L;\n+\n+        public void writeExternal(final ObjectOutput objectOutput) {\n+        }\n+\n+        public void readExternal(final ObjectInput objectInput) {\n+        }\n+    }\n+\n+    static class Ext2 implements Externalizable {\n+        public void writeExternal(final ObjectOutput objectOutput) {\n+        }\n+\n+        public void readExternal(final ObjectInput objectInput) {\n+        }\n+    }\n+\n+    record Rec1(int hello, boolean world) implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = 12349876L;\n+    }\n+\n+    enum Enum1 {\n+        hello,\n+        world,\n+        ;\n+        private static final long serialVersionUID = 1020304050L;\n+    }\n+\n+    interface Proxy1 {\n+        void hello();\n+    }\n+\n+    static class SerialPersistentFields implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = -4947917866973382882L;\n+        @Serial\n+        private static final ObjectStreamField[] serialPersistentFields = {\n+            new ObjectStreamField(\"array1\", Object[].class),\n+            new ObjectStreamField(\"nonExistent\", String.class)\n+        };\n+\n+        private int int1;\n+        private Object[] array1;\n+    }\n+\n+    \/\/ Check our simple accessors\n+    @Test\n+    static void testAccessors() {\n+        Assert.assertEquals(factory.serialPersistentFields(Ser3.class), Ser3.serialPersistentFields);\n+        Assert.assertNotSame(factory.serialPersistentFields(Ser3.class), Ser3.serialPersistentFields);\n+        Assert.assertNull(factory.serialPersistentFields(SerInvalidFields.class));\n+    }\n+\n+    \/\/ Ensure that classes with serialPersistentFields do not allow default setting\/getting\n+    @Test\n+    static void testDisallowed() {\n+        Assert.assertNull(factory.defaultWriteObjectForSerialization(SerialPersistentFields.class));\n+        Assert.assertNull(factory.defaultReadObjectForSerialization(SerialPersistentFields.class));\n+    }\n+\n","filename":"test\/jdk\/sun\/reflect\/ReflectionFactory\/ReflectionFactoryTest.java","additions":508,"deletions":1,"binary":false,"changes":509,"status":"modified"}]}