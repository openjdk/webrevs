{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.io.ObjectStreamField;\n@@ -42,0 +43,1 @@\n+import java.lang.reflect.Proxy;\n@@ -44,0 +46,2 @@\n+import java.util.Set;\n+\n@@ -433,0 +437,80 @@\n+    public final MethodHandle defaultReadObjectForSerialization(Class<?> cl) {\n+        if (! isValidSerializable(cl)) {\n+            return null;\n+        }\n+\n+        return SerializationBytecodeGenerator.defaultReadObjectForSerialization(cl);\n+    }\n+\n+    public final MethodHandle defaultWriteObjectForSerialization(Class<?> cl) {\n+        if (! isValidSerializable(cl)) {\n+            return null;\n+        }\n+\n+        return SerializationBytecodeGenerator.defaultWriteObjectForSerialization(cl);\n+    }\n+\n+    public final ObjectStreamField[] serialPersistentFields(Class<?> cl) {\n+        if (! Serializable.class.isAssignableFrom(cl) || cl.isInterface() || cl.isEnum()) {\n+            return null;\n+        }\n+\n+        try {\n+            Field field = cl.getDeclaredField(\"serialPersistentFields\");\n+            int mods = field.getModifiers();\n+            if (! (Modifier.isStatic(mods) && Modifier.isPrivate(mods) && Modifier.isFinal(mods))) {\n+                return null;\n+            }\n+            if (field.getType() != ObjectStreamField[].class) {\n+                return null;\n+            }\n+            field.setAccessible(true);\n+            ObjectStreamField[] array = (ObjectStreamField[]) field.get(null);\n+            return array != null && array.length > 0 ? array.clone() : array;\n+        } catch (ReflectiveOperationException e) {\n+            return null;\n+        }\n+    }\n+\n+    public final long serialVersionUID(Class<?> cl) {\n+        if (! Serializable.class.isAssignableFrom(cl) || cl.isInterface() || cl.isEnum()) {\n+            return 0;\n+        }\n+\n+        try {\n+            Field field = cl.getDeclaredField(\"serialVersionUID\");\n+            int mods = field.getModifiers();\n+            if (! (Modifier.isStatic(mods) && Modifier.isPrivate(mods) && Modifier.isFinal(mods))) {\n+                return 0;\n+            }\n+            field.setAccessible(true);\n+            return field.getLong(null);\n+        } catch (ReflectiveOperationException e) {\n+            return 0;\n+        }\n+    }\n+\n+    \/**\n+     * These are specific leaf classes which appear to be Serializable, but which\n+     * have special semantics according to the serialization specification. We\n+     * could theoretically include array classes here, but it is easier and clearer\n+     * to just use `Class#isArray` instead.\n+     *\/\n+    private static final Set<Class<?>> nonSerializableLeafClasses = Set.of(\n+        Class.class,\n+        String.class,\n+        ObjectStreamClass.class\n+    );\n+\n+    private static boolean isValidSerializable(Class<?> cl) {\n+        return Serializable.class.isAssignableFrom(cl)\n+            && ! cl.isInterface()\n+            && ! cl.isArray()\n+            && ! Proxy.isProxyClass(cl)\n+            && ! Externalizable.class.isAssignableFrom(cl)\n+            && ! cl.isEnum()\n+            && ! cl.isRecord()\n+            && ! cl.isHidden()\n+            && ! nonSerializableLeafClasses.contains(cl);\n+    }\n+\n@@ -635,1 +719,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":85,"deletions":2,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamField;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.TypeKind;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n+\n+\/**\n+ * The private serialization bytecode generator used by {@code sun.misc.ReflectionFactory}.\n+ *\/\n+final class SerializationBytecodeGenerator {\n+    private static final MethodHandles.Lookup lookup = MethodHandles.lookup();\n+    @SuppressWarnings(\"removal\")\n+    private static final ReflectionFactory reflectionFactory = AccessController.doPrivileged((PrivilegedAction<ReflectionFactory>) ReflectionFactory::getReflectionFactory);\n+\n+    \/*\n+     * The accessors generated by this class are implemented using an anonymous+hidden\n+     * class to carry the method. Because we are using a non-privileged lookup, we\n+     * generate unreflected accessor method handles based on setAccessible(true) fields\n+     * for the (likely) case that we won't have access to a given field. The accessor's\n+     * type must also be erased to `Object` when non-primitive because we may not have\n+     * access to the field's type. This is generally not much of a penalty though,\n+     * because the object-based methods we interact with on `PutField` and `GetField`\n+     * all work in terms of `Object` anyway.\n+     *\/\n+\n+    \/\/ no instances\n+    private SerializationBytecodeGenerator() {}\n+\n+    static MethodHandle defaultReadObjectForSerialization(Class<?> cl) {\n+        List<MethodHandle> setters = new ArrayList<>();\n+        byte[] bytes = ClassFile.of().build(CD_Generated_readObject, classBuilder -> classBuilder.withMethod(\"readObject\",\n+            MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_Object, CD_ObjectInputStream),\n+            Modifier.STATIC | Modifier.PRIVATE,\n+            mb -> mb.withCode(cb -> {\n+                \/\/ get our GetField\n+                cb.aload(1);\n+                cb.invokevirtual(CD_ObjectInputStream, \"readFields\", MTD_ObjectInputStream_readFields);\n+                cb.astore(2);\n+                \/\/ check to see if stream fields are present, and if so, restrict the wire format accordingly\n+                ObjectStreamField[] spf = reflectionFactory.serialPersistentFields(cl);\n+                Map<String, ObjectStreamField> fields = spf == null ? null : Stream.of(spf).collect(Collectors.toMap(\n+                    ObjectStreamField::getName,\n+                    Function.identity()\n+                ));\n+                \/\/ iterate the fields of the class\n+                for (Field field : cl.getDeclaredFields()) {\n+                    int fieldMods = field.getModifiers();\n+                    if (Modifier.isStatic(fieldMods) || Modifier.isTransient(fieldMods)) {\n+                        continue;\n+                    }\n+                    String fieldName = field.getName();\n+                    Class<?> fieldType = field.getType();\n+                    if (fields != null && (! fields.containsKey(fieldName) || fields.get(fieldName).getType() != fieldType)) {\n+                        \/\/ field does not match stream data\n+                        continue;\n+                    }\n+\n+                    \/\/ generate setter\n+                    field.setAccessible(true);\n+                    int idx = setters.size();\n+                    MethodHandle mh;\n+                    try {\n+                        mh = lookup.unreflectSetter(field);\n+                        if (fieldType.isPrimitive()) {\n+                            mh = mh.asType(MethodType.methodType(void.class, Object.class, fieldType));\n+                        } else {\n+                            mh = mh.asType(MethodType.methodType(void.class, Object.class, Object.class));\n+                        }\n+                        setters.add(mh);\n+                    } catch (IllegalAccessException e) {\n+                        throw new InternalError(\"Error generating accessor for field \" + field, e);\n+                    }\n+                    cb.ldc(DynamicConstantDesc.ofNamed(\n+                        ConstantDescs.BSM_CLASS_DATA_AT,\n+                        ConstantDescs.DEFAULT_NAME,\n+                        ConstantDescs.CD_MethodHandle,\n+                        Integer.valueOf(idx)\n+                    ));\n+                    \/\/ stack: <mh>\n+                    cb.aload(0); \/\/ stack: <mh> this\n+                    cb.aload(2); \/\/ stack: <mh> this GetField\n+                    cb.ldc(fieldName); \/\/ stack: <mh> this GetField <name>\n+\n+                    ClassDesc fieldDesc = fieldType.describeConstable().orElseThrow(InternalError::new);\n+\n+                    switch (TypeKind.from(fieldDesc)) {\n+                        case ByteType -> {\n+                            cb.iconst_0();\n+                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_B);\n+                        }\n+                        case CharType -> {\n+                            cb.iconst_0();\n+                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_C);\n+                        }\n+                        case DoubleType -> {\n+                            cb.dconst_0();\n+                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_D);\n+                        }\n+                        case FloatType -> {\n+                            cb.fconst_0();\n+                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_F);\n+                        }\n+                        case IntType -> {\n+                            cb.iconst_0();\n+                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_I);\n+                        }\n+                        case LongType -> {\n+                            cb.lconst_0();\n+                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_J);\n+                        }\n+                        case ShortType -> {\n+                            cb.iconst_0();\n+                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_S);\n+                        }\n+                        case BooleanType -> {\n+                            cb.iconst_0();\n+                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_Z);\n+                        }\n+                        case ReferenceType -> {\n+                            cb.aconst_null();\n+                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_L);\n+                        }\n+                    }\n+                    \/\/ stack: <mh> this <val>\n+                    cb.invokevirtual(ConstantDescs.CD_MethodHandle, \"invokeExact\", mh.type().describeConstable().orElseThrow(InternalError::new));\n+                }\n+                cb.return_();\n+            })\n+        ));\n+        try {\n+            MethodHandles.Lookup hcLookup = lookup.defineHiddenClassWithClassData(bytes, List.copyOf(setters), true);\n+            return hcLookup.findStatic(hcLookup.lookupClass(), \"readObject\", MethodType.methodType(void.class, Object.class, ObjectInputStream.class))\n+                .asType(MethodType.methodType(void.class, cl, ObjectInputStream.class));\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+            throw new InternalError(\"Error in readObject generation\", e);\n+        }\n+    }\n+\n+    static MethodHandle defaultWriteObjectForSerialization(Class<?> cl) {\n+        List<MethodHandle> getters = new ArrayList<>();\n+        byte[] bytes = ClassFile.of().build(CD_Generated_writeObject, classBuilder -> classBuilder.withMethod(\"writeObject\",\n+            MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_Object, CD_ObjectOutputStream),\n+            Modifier.STATIC | Modifier.PRIVATE,\n+            mb -> mb.withCode(cb -> {\n+                \/\/ get our PutField\n+                cb.aload(1);\n+                cb.invokevirtual(CD_ObjectOutputStream, \"putFields\", MTD_ObjectOutputStream_putFields);\n+                cb.astore(2);\n+                \/\/ check to see if stream fields are present, and if so, restrict the wire format accordingly\n+                ObjectStreamField[] spf = reflectionFactory.serialPersistentFields(cl);\n+                Map<String, ObjectStreamField> fields = spf == null ? null : Stream.of(spf).collect(Collectors.toMap(\n+                    ObjectStreamField::getName,\n+                    Function.identity()\n+                ));\n+                \/\/ iterate the fields of the class\n+                for (Field field : cl.getDeclaredFields()) {\n+                    int fieldMods = field.getModifiers();\n+                    if (Modifier.isStatic(fieldMods) || Modifier.isTransient(fieldMods)) {\n+                        continue;\n+                    }\n+                    String fieldName = field.getName();\n+                    Class<?> fieldType = field.getType();\n+                    if (fields != null && (! fields.containsKey(fieldName) || fields.get(fieldName).getType() != fieldType)) {\n+                        \/\/ field does not match stream data\n+                        continue;\n+                    }\n+\n+                    \/\/ stack: (empty)\n+                    cb.aload(2);\n+                    \/\/ stack: PutField\n+                    cb.ldc(fieldName);\n+                    \/\/ stack: PutField fieldName\n+                    \/\/ generate getter\n+                    field.setAccessible(true);\n+                    int idx = getters.size();\n+                    MethodHandle getter;\n+                    try {\n+                        getter = lookup.unreflectGetter(field);\n+                        if (fieldType.isPrimitive()) {\n+                            getter = getter.asType(MethodType.methodType(fieldType, Object.class));\n+                        } else {\n+                            getter = getter.asType(MethodType.methodType(Object.class, Object.class));\n+                        }\n+                        getters.add(getter);\n+                    } catch (IllegalAccessException e) {\n+                        throw new InternalError(\"Error generating accessor for field \" + field, e);\n+                    }\n+                    cb.ldc(DynamicConstantDesc.ofNamed(\n+                        ConstantDescs.BSM_CLASS_DATA_AT,\n+                        ConstantDescs.DEFAULT_NAME,\n+                        ConstantDescs.CD_MethodHandle,\n+                        Integer.valueOf(idx)\n+                    ));\n+                    \/\/ stack: PutField fieldName <mh>\n+                    cb.aload(0);\n+                    \/\/ stack: PutField fieldName <mh> this\n+                    cb.invokevirtual(ConstantDescs.CD_MethodHandle, \"invokeExact\", getter.type().describeConstable().orElseThrow(InternalError::new));\n+                    \/\/ stack: PutField fieldName <val>\n+                    switch (TypeKind.from(fieldType)) {\n+                        case ByteType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_B);\n+                        case CharType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_C);\n+                        case DoubleType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_D);\n+                        case FloatType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_F);\n+                        case IntType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_I);\n+                        case LongType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_J);\n+                        case ShortType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_S);\n+                        case BooleanType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_Z);\n+                        case ReferenceType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_L);\n+                    }\n+                    \/\/ stack: (empty)\n+                }\n+                \/\/ commit fields to stream\n+                cb.aload(1);\n+                cb.invokevirtual(CD_ObjectOutputStream, \"writeFields\", ConstantDescs.MTD_void);\n+                cb.return_();\n+            })\n+        ));\n+        try {\n+            MethodHandles.Lookup hcLookup = lookup.defineHiddenClassWithClassData(bytes, List.copyOf(getters), true);\n+            return hcLookup.findStatic(hcLookup.lookupClass(), \"writeObject\", MethodType.methodType(void.class, Object.class, ObjectOutputStream.class))\n+                .asType(MethodType.methodType(void.class, cl, ObjectOutputStream.class));\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+            throw new InternalError(\"Error in writeObject generation\", e);\n+        }\n+    }\n+\n+    private static final ClassDesc CD_ObjectInputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n+    private static final ClassDesc CD_ObjectInputStream_GetField = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream$GetField;\");\n+\n+    private static final ClassDesc CD_ObjectOutputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n+    private static final ClassDesc CD_ObjectOutputStream_PutField = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream$PutField;\");\n+\n+    private static final ClassDesc CD_Generated_writeObject = ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/reflect\/Generated$$writeObject;\");\n+    private static final ClassDesc CD_Generated_readObject = ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/reflect\/Generated$$readObject;\");\n+\n+    private static final MethodTypeDesc MTD_ObjectInputStream_readFields = MethodTypeDescImpl.ofValidated(CD_ObjectInputStream_GetField);\n+\n+    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_B = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_byte, ConstantDescs.CD_String, ConstantDescs.CD_byte);\n+    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_C = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_char, ConstantDescs.CD_String, ConstantDescs.CD_char);\n+    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_D = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_double, ConstantDescs.CD_String, ConstantDescs.CD_double);\n+    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_F = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_float, ConstantDescs.CD_String, ConstantDescs.CD_float);\n+    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_I = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int, ConstantDescs.CD_String, ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_J = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_long, ConstantDescs.CD_String, ConstantDescs.CD_long);\n+    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_L = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_Object, ConstantDescs.CD_String, ConstantDescs.CD_Object);\n+    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_S = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_short, ConstantDescs.CD_String, ConstantDescs.CD_short);\n+    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_Z = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_boolean, ConstantDescs.CD_String, ConstantDescs.CD_boolean);\n+\n+    private static final MethodTypeDesc MTD_ObjectOutputStream_putFields = MethodTypeDescImpl.ofValidated(CD_ObjectOutputStream_PutField);\n+\n+    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_B = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_byte);\n+    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_C = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_char);\n+    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_D = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_double);\n+    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_F = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_float);\n+    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_I = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_J = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_long);\n+    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_L = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_Object);\n+    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_S = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_short);\n+    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_Z = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_boolean);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationBytecodeGenerator.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamField;\n@@ -160,0 +163,45 @@\n+    \/**\n+     * Returns a direct MethodHandle for a variation of {@code readObject}\n+     * which always initializes its fields from the stream\n+     * {@link ObjectInputStream#readFields()} mechanism.\n+     * <p>\n+     * The generated method will accept the instance as its first argument\n+     * and the {@code ObjectInputStream} as its second argument.\n+     * The return type of the method is {@code void}.\n+     *\n+     * @param cl a Serializable class\n+     * @return  a direct MethodHandle for the synthetic {@code readObject} method\n+     *          or {@code null} if the class is not serializable\n+     *\n+     * @since 24\n+     *\/\n+    public final MethodHandle defaultReadObjectForSerialization(Class<?> cl) {\n+        return delegate.defaultReadObjectForSerialization(cl);\n+    }\n+\n+    \/**\n+     * {@return the declared <code>serialPersistentFields<\/code> from a serializable class,\n+     * or <code>null<\/code> if none is declared or the class is not a valid\n+     * serializable class}\n+     *\n+     * @param cl a Serializable class\n+     *\n+     * @since 24\n+     *\/\n+    public final ObjectStreamField[] serialPersistentFields(Class<?> cl) {\n+        return delegate.serialPersistentFields(cl);\n+    }\n+\n+    \/**\n+     * {@return the declared <code>serialVersionUID<\/code> from a serializable class,\n+     * or <code>0L<\/code> if none is declared or the class is not a valid\n+     * serializable class}\n+     *\n+     * @param cl a Serializable class\n+     *\n+     * @since 24\n+     *\/\n+    public final long serialVersionUID(Class<?> cl) {\n+        return delegate.serialVersionUID(cl);\n+    }\n+\n@@ -175,0 +223,19 @@\n+    \/**\n+     * Returns a direct MethodHandle for a variation of {@code writeObject}\n+     * which always writes its fields to the stream\n+     * {@link ObjectOutputStream#putFields()} mechanism.\n+     * <p>\n+     * The generated method will accept the instance as its first argument\n+     * and the {@code ObjectOutputStream} as its second argument.\n+     * The return type of the method is {@code void}.\n+     *\n+     * @param cl a Serializable class\n+     * @return  a direct MethodHandle for the synthetic {@code writeObject} method\n+     *          or {@code null} if the class is not serializable\n+     *\n+     * @since 24\n+     *\/\n+    public final MethodHandle defaultWriteObjectForSerialization(Class<?> cl) {\n+        return delegate.defaultWriteObjectForSerialization(cl);\n+    }\n+\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/reflect\/ReflectionFactory.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.io.ObjectStreamClass;\n@@ -33,0 +34,1 @@\n+import java.io.ObjectStreamField;\n@@ -34,0 +36,1 @@\n+import java.io.Serial;\n@@ -38,0 +41,4 @@\n+import java.lang.reflect.Proxy;\n+import java.security.AccessController;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.Arrays;\n@@ -49,1 +56,1 @@\n- * @bug 8137058 8164908 8168980 8275137\n+ * @bug 8137058 8164908 8168980 8275137 8333796\n@@ -331,0 +338,640 @@\n+    private static final String[] names = {\n+        \"boolean_\",\n+        \"final_boolean\",\n+        \"byte_\",\n+        \"final_byte\",\n+        \"char_\",\n+        \"final_char\",\n+        \"short_\",\n+        \"final_short\",\n+        \"int_\",\n+        \"final_int\",\n+        \"long_\",\n+        \"final_long\",\n+        \"float_\",\n+        \"final_float\",\n+        \"double_\",\n+        \"final_double\",\n+        \"str\",\n+        \"final_str\",\n+        \"writeFields\",\n+    };\n+\n+    \/\/ test that the generated read\/write objects are working properly\n+    @Test\n+    static void testDefaultReadWriteObject() throws Throwable {\n+        Ser2 ser = new Ser2((byte) 0x33, (short) 0x2244, (char) 0x5342, 0x05382716, 0xf035a73b09113bacL, 1234f, 3456.0, true, new Ser3(0x004917aa));\n+        ser.byte_ = (byte) 0x44;\n+        ser.short_ = (short) 0x3355;\n+        ser.char_ = (char) 0x6593;\n+        ser.int_ = 0x4928a299;\n+        ser.long_ = 0x24aa19883f4b9138L;\n+        ser.float_ = 4321f;\n+        ser.double_ = 6543.0;\n+        ser.boolean_ = false;\n+        ser.ser = new Ser3(0x70b030a0);\n+        \/\/ first, ensure that each field gets written\n+        MethodHandle writeObject = factory.defaultWriteObjectForSerialization(Ser2.class);\n+        Assert.assertNotNull(writeObject, \"writeObject not created\");\n+        boolean[] called = new boolean[19];\n+        @SuppressWarnings(\"removal\")\n+        ObjectOutputStream oos = AccessController.doPrivileged((PrivilegedExceptionAction<ObjectOutputStream>) () -> new ObjectOutputStream() {\n+            protected void writeObjectOverride(final Object obj) throws IOException {\n+                throw new IOException(\"Wrong method called\");\n+            }\n+\n+            public void defaultWriteObject() throws IOException {\n+                throw new IOException(\"Wrong method called\");\n+            }\n+\n+            public void writeFields() {\n+                called[18] = true;\n+            }\n+\n+            public PutField putFields() {\n+                return new PutField() {\n+                    public void put(final String name, final boolean val) {\n+                        switch (name) {\n+                            case \"boolean_\" -> {\n+                                Assert.assertFalse(val);\n+                                called[0] = true;\n+                            }\n+                            case \"final_boolean\" -> {\n+                                Assert.assertTrue(val);\n+                                called[1] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final byte val) {\n+                        switch (name) {\n+                            case \"byte_\" -> {\n+                                Assert.assertEquals(val, (byte) 0x44);\n+                                called[2] = true;\n+                            }\n+                            case \"final_byte\" -> {\n+                                Assert.assertEquals(val, (byte) 0x33);\n+                                called[3] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final char val) {\n+                        switch (name) {\n+                            case \"char_\" -> {\n+                                Assert.assertEquals(val, (char) 0x6593);\n+                                called[4] = true;\n+                            }\n+                            case \"final_char\" -> {\n+                                Assert.assertEquals(val, (char) 0x5342);\n+                                called[5] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final short val) {\n+                        switch (name) {\n+                            case \"short_\" -> {\n+                                Assert.assertEquals(val, (short) 0x3355);\n+                                called[6] = true;\n+                            }\n+                            case \"final_short\" -> {\n+                                Assert.assertEquals(val, (short) 0x2244);\n+                                called[7] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final int val) {\n+                        switch (name) {\n+                            case \"int_\" -> {\n+                                Assert.assertEquals(val, 0x4928a299);\n+                                called[8] = true;\n+                            }\n+                            case \"final_int\" -> {\n+                                Assert.assertEquals(val, 0x05382716);\n+                                called[9] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final long val) {\n+                        switch (name) {\n+                            case \"long_\" -> {\n+                                Assert.assertEquals(val, 0x24aa19883f4b9138L);\n+                                called[10] = true;\n+                            }\n+                            case \"final_long\" -> {\n+                                Assert.assertEquals(val, 0xf035a73b09113bacL);\n+                                called[11] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final float val) {\n+                        switch (name) {\n+                            case \"float_\" -> {\n+                                Assert.assertEquals(val, 4321f);\n+                                called[12] = true;\n+                            }\n+                            case \"final_float\" -> {\n+                                Assert.assertEquals(val, 1234f);\n+                                called[13] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final double val) {\n+                        switch (name) {\n+                            case \"double_\" -> {\n+                                Assert.assertEquals(val, 6543.0);\n+                                called[14] = true;\n+                            }\n+                            case \"final_double\" -> {\n+                                Assert.assertEquals(val, 3456.0);\n+                                called[15] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    public void put(final String name, final Object val) {\n+                        switch (name) {\n+                            case \"ser\" -> {\n+                                Assert.assertEquals(val, new Ser3(0x70b030a0));\n+                                called[16] = true;\n+                            }\n+                            case \"final_ser\" -> {\n+                                Assert.assertEquals(val, new Ser3(0x004917aa));\n+                                called[17] = true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    @SuppressWarnings(\"removal\")\n+                    public void write(final ObjectOutput out) throws IOException {\n+                        throw new IOException(\"Wrong method called\");\n+                    }\n+                };\n+            }\n+        });\n+        writeObject.invokeExact(ser, oos);\n+        for (int i = 0; i < 19; i ++) {\n+            Assert.assertTrue(called[i], names[i]);\n+        }\n+        \/\/ now, test the read side\n+        MethodHandle readObject = factory.defaultReadObjectForSerialization(Ser2.class);\n+        Assert.assertNotNull(readObject, \"readObject not created\");\n+        @SuppressWarnings(\"removal\")\n+        ObjectInputStream ois = AccessController.doPrivileged((PrivilegedExceptionAction<ObjectInputStream>) () -> new ObjectInputStream() {\n+            protected Object readObjectOverride() throws IOException {\n+                throw new IOException(\"Wrong method called\");\n+            }\n+\n+            public GetField readFields() {\n+                return new GetField() {\n+                    public ObjectStreamClass getObjectStreamClass() {\n+                        throw new Error(\"Wrong method called\");\n+                    }\n+\n+                    public boolean defaulted(final String name) throws IOException {\n+                        throw new IOException(\"Wrong method called\");\n+                    }\n+\n+                    public boolean get(final String name, final boolean val) {\n+                        return switch (name) {\n+                            case \"boolean_\" -> {\n+                                called[0] = true;\n+                                yield true;\n+                            }\n+                            case \"final_boolean\" -> {\n+                                called[1] = true;\n+                                yield true;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public byte get(final String name, final byte val) {\n+                        return switch (name) {\n+                            case \"byte_\" -> {\n+                                called[2] = true;\n+                                yield (byte) 0x11;\n+                            }\n+                            case \"final_byte\" -> {\n+                                called[3] = true;\n+                                yield (byte) 0x9f;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public char get(final String name, final char val) {\n+                        return switch (name) {\n+                            case \"char_\" -> {\n+                                called[4] = true;\n+                                yield (char) 0x59a2;\n+                            }\n+                            case \"final_char\" -> {\n+                                called[5] = true;\n+                                yield (char) 0xe0d0;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public short get(final String name, final short val) {\n+                        return switch (name) {\n+                            case \"short_\" -> {\n+                                called[6] = true;\n+                                yield (short) 0x0917;\n+                            }\n+                            case \"final_short\" -> {\n+                                called[7] = true;\n+                                yield (short) 0x110e;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public int get(final String name, final int val) {\n+                        return switch (name) {\n+                            case \"int_\" -> {\n+                                called[8] = true;\n+                                yield 0xd0244e19;\n+                            }\n+                            case \"final_int\" -> {\n+                                called[9] = true;\n+                                yield 0x011004da;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public long get(final String name, final long val) {\n+                        return switch (name) {\n+                            case \"long_\" -> {\n+                                called[10] = true;\n+                                yield 0x0b8101d84aa31711L;\n+                            }\n+                            case \"final_long\" -> {\n+                                called[11] = true;\n+                                yield 0x30558aa7189ed821L;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public float get(final String name, final float val) {\n+                        return switch (name) {\n+                            case \"float_\" -> {\n+                                called[12] = true;\n+                                yield 0x5.01923ap18f;\n+                            }\n+                            case \"final_float\" -> {\n+                                called[13] = true;\n+                                yield 0x0.882afap1f;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public double get(final String name, final double val) {\n+                        return switch (name) {\n+                            case \"double_\" -> {\n+                                called[14] = true;\n+                                yield 0x9.4a8fp6;\n+                            }\n+                            case \"final_double\" -> {\n+                                called[15] = true;\n+                                yield 0xf.881a8p4;\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+\n+                    public Object get(final String name, final Object val) {\n+                        return switch (name) {\n+                            case \"ser\" -> {\n+                                called[16] = true;\n+                                yield new Ser3(0x44cc55dd);\n+                            }\n+                            case \"final_ser\" -> {\n+                                called[17] = true;\n+                                yield new Ser3(0x9a8b7c6d);\n+                            }\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+                };\n+            }\n+        });\n+        \/\/ all the same methods, except for `writeFields`\n+        Arrays.fill(called, false);\n+        Constructor<?> ctor = factory.newConstructorForSerialization(Ser2.class, Object.class.getDeclaredConstructor());\n+        ser = (Ser2) ctor.newInstance();\n+        readObject.invokeExact(ser, ois);\n+        \/\/ excluding \"writeFields\", so 18 instead of 19\n+        for (int i = 0; i < 18; i ++) {\n+            Assert.assertTrue(called[i], names[i]);\n+        }\n+        Assert.assertEquals(ser.byte_, (byte)0x11);\n+        Assert.assertEquals(ser.final_byte, (byte)0x9f);\n+        Assert.assertEquals(ser.char_, (char)0x59a2);\n+        Assert.assertEquals(ser.final_char, (char)0xe0d0);\n+        Assert.assertEquals(ser.short_, (short)0x0917);\n+        Assert.assertEquals(ser.final_short, (short)0x110e);\n+        Assert.assertEquals(ser.int_, 0xd0244e19);\n+        Assert.assertEquals(ser.final_int, 0x011004da);\n+        Assert.assertEquals(ser.long_, 0x0b8101d84aa31711L);\n+        Assert.assertEquals(ser.final_long, 0x30558aa7189ed821L);\n+        Assert.assertEquals(ser.float_, 0x5.01923ap18f);\n+        Assert.assertEquals(ser.final_float, 0x0.882afap1f);\n+        Assert.assertEquals(ser.double_, 0x9.4a8fp6);\n+        Assert.assertEquals(ser.final_double, 0xf.881a8p4);\n+        Assert.assertEquals(ser.ser, new Ser3(0x44cc55dd));\n+        Assert.assertEquals(ser.final_ser, new Ser3(0x9a8b7c6d));\n+    }\n+\n+    static class Ser2 implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = -2852896623833548574L;\n+\n+        byte byte_;\n+        short short_;\n+        char char_;\n+        int int_;\n+        long long_;\n+        float float_;\n+        double double_;\n+        boolean boolean_;\n+        Ser3 ser;\n+\n+        final byte final_byte;\n+        final short final_short;\n+        final char final_char;\n+        final int final_int;\n+        final long final_long;\n+        final float final_float;\n+        final double final_double;\n+        final boolean final_boolean;\n+        final Ser3 final_ser;\n+\n+        Ser2(final byte final_byte, final short final_short, final char final_char, final int final_int,\n+            final long final_long, final float final_float, final double final_double,\n+            final boolean final_boolean, final Ser3 final_ser) {\n+\n+            this.final_byte = final_byte;\n+            this.final_short = final_short;\n+            this.final_char = final_char;\n+            this.final_int = final_int;\n+            this.final_long = final_long;\n+            this.final_float = final_float;\n+            this.final_double = final_double;\n+            this.final_boolean = final_boolean;\n+            this.final_ser = final_ser;\n+        }\n+    }\n+\n+    static class Ser3 implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = -1234752876749422678L;\n+\n+        @Serial\n+        private static final ObjectStreamField[] serialPersistentFields = {\n+            new ObjectStreamField(\"value\", int.class)\n+        };\n+\n+        final int value;\n+\n+        Ser3(final int value) {\n+            this.value = value;\n+        }\n+\n+        public boolean equals(final Object obj) {\n+            return obj instanceof Ser3 s && value == s.value;\n+        }\n+\n+        public int hashCode() {\n+            return value;\n+        }\n+    }\n+\n+    static class SerInvalidFields implements Serializable {\n+        \/\/ this is deliberately wrong\n+        @SuppressWarnings({\"unused\", \"serial\"})\n+        @Serial\n+        private static final String serialPersistentFields = \"Oops!\";\n+        @Serial\n+        private static final long serialVersionUID = -8090960816811629489L;\n+    }\n+\n+    static class Ext1 implements Externalizable {\n+\n+        @Serial\n+        private static final long serialVersionUID = 7109990719266285013L;\n+\n+        public void writeExternal(final ObjectOutput objectOutput) {\n+        }\n+\n+        public void readExternal(final ObjectInput objectInput) {\n+        }\n+    }\n+\n+    static class Ext2 implements Externalizable {\n+        public void writeExternal(final ObjectOutput objectOutput) {\n+        }\n+\n+        public void readExternal(final ObjectInput objectInput) {\n+        }\n+    }\n+\n+    record Rec1(int hello, boolean world) implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = 12349876L;\n+    }\n+\n+    enum Enum1 {\n+        hello,\n+        world,\n+        ;\n+        private static final long serialVersionUID = 1020304050L;\n+    }\n+\n+    interface Proxy1 {\n+        void hello();\n+    }\n+\n+    static class SerialPersistentFields implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = -4947917866973382882L;\n+        @Serial\n+        private static final ObjectStreamField[] serialPersistentFields = {\n+            new ObjectStreamField(\"array1\", Object[].class),\n+            new ObjectStreamField(\"nonExistent\", String.class)\n+        };\n+\n+        private int int1;\n+        private Object[] array1;\n+    }\n+\n+    \/\/ Check our simple accessors\n+    @Test\n+    static void testAccessors() {\n+        Assert.assertEquals(factory.serialVersionUID(Ser3.class), -1234752876749422678L);\n+        Assert.assertEquals(factory.serialPersistentFields(Ser3.class), Ser3.serialPersistentFields);\n+        Assert.assertNotSame(factory.serialPersistentFields(Ser3.class), Ser3.serialPersistentFields);\n+        Assert.assertNull(factory.serialPersistentFields(SerInvalidFields.class));\n+        Assert.assertEquals(factory.serialVersionUID(Ext1.class), 7109990719266285013L);\n+        Assert.assertEquals(factory.serialVersionUID(Ext2.class), 0);\n+        Assert.assertEquals(factory.serialVersionUID(Rec1.class), 12349876L);\n+        \/\/ make sure we cannot access the forbidden ones\n+        Assert.assertEquals(factory.serialVersionUID(Object.class), 0);\n+        Assert.assertEquals(factory.serialVersionUID(Enum1.class), 0);\n+        Assert.assertEquals(factory.serialVersionUID(\n+            Proxy.newProxyInstance(\n+                ReflectionFactoryTest.class.getClassLoader(),\n+                new Class<?>[] { Proxy1.class },\n+                (_, _, _) -> null).getClass()\n+            ), 0\n+        );\n+        Assert.assertEquals(factory.serialVersionUID(byte[].class), 0);\n+        Assert.assertEquals(factory.serialVersionUID(Externalizable.class), 0);\n+    }\n+\n+    \/\/ Ensure that classes with serialPersistentFields do not get\/set other fields\n+    @Test\n+    static void testDisallowed() throws Throwable {\n+        \/\/ first check write\n+        MethodHandle writeHandle = factory.defaultWriteObjectForSerialization(SerialPersistentFields.class);\n+        SerialPersistentFields spf = new SerialPersistentFields();\n+        spf.int1 = 123;\n+        spf.array1 = new Object[] { \"Hello\", \"world\" };\n+        writeHandle.invokeExact(spf, (ObjectOutputStream) new ObjectOutputStream() {\n+            protected void writeObjectOverride(final Object obj) throws IOException {\n+                throw new IOException(\"Wrong method called\");\n+            }\n+\n+            public PutField putFields() {\n+                return new PutField() {\n+                    public void put(final String name, final boolean val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public void put(final String name, final byte val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public void put(final String name, final char val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public void put(final String name, final short val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public void put(final String name, final int val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public void put(final String name, final long val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public void put(final String name, final float val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public void put(final String name, final double val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public void put(final String name, final Object val) {\n+                        switch (name) {\n+                            case \"array1\" -> Assert.assertEquals((Object[])val, new Object[] {\n+                                \"Hello\", \"world\"\n+                            });\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        }\n+                    }\n+\n+                    @SuppressWarnings(\"removal\")\n+                    public void write(final ObjectOutput out) throws IOException {\n+                        throw new IOException(\"Wrong method called\");\n+                    }\n+                };\n+            }\n+\n+            public void writeFields() {\n+                \/\/ ignore\n+            }\n+        });\n+        MethodHandle readHandle = factory.defaultReadObjectForSerialization(SerialPersistentFields.class);\n+        readHandle.invokeExact(spf, (ObjectInputStream) new ObjectInputStream() {\n+            protected Object readObjectOverride() throws IOException {\n+                throw new IOException(\"Wrong method called\");\n+            }\n+\n+            public GetField readFields() {\n+                return new GetField() {\n+                    public ObjectStreamClass getObjectStreamClass() {\n+                        throw new Error(\"Wrong method called\");\n+                    }\n+\n+                    public boolean defaulted(final String name) {\n+                        return false;\n+                    }\n+\n+                    public boolean get(final String name, final boolean val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public byte get(final String name, final byte val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public char get(final String name, final char val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public short get(final String name, final short val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public int get(final String name, final int val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public long get(final String name, final long val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public float get(final String name, final float val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public double get(final String name, final double val) {\n+                        throw new Error(\"Unexpected field \" + name);\n+                    }\n+\n+                    public Object get(final String name, final Object val) {\n+                        return switch (name) {\n+                            case \"array1\" -> new Object[] { \"Changed!\" };\n+                            default -> throw new Error(\"Unexpected field \" + name);\n+                        };\n+                    }\n+                };\n+            }\n+        });\n+        Assert.assertEquals(spf.int1, 123);\n+        Assert.assertEquals(spf.array1, new Object[] { \"Changed!\" });\n+    }\n+\n","filename":"test\/jdk\/sun\/reflect\/ReflectionFactory\/ReflectionFactoryTest.java","additions":649,"deletions":2,"binary":false,"changes":651,"status":"modified"},{"patch":"@@ -11,0 +11,2 @@\n+        permission java.io.SerializablePermission \"enableSubclassImplementation\";\n+        permission java.lang.RuntimePermission \"getClassLoaderPermission\";\n","filename":"test\/jdk\/sun\/reflect\/ReflectionFactory\/security.policy","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}