{"files":[{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import jdk.internal.access.JavaObjectStreamDefaultSupportAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArray;\n+\n+\/**\n+ *\n+ *\/\n+final class ObjectStreamDefaultSupport {\n+\n+    \/\/ todo: these could be constants\n+    private static final MethodHandle DRO_HANDLE;\n+    private static final MethodHandle DWO_HANDLE;\n+\n+    static {\n+        try {\n+            MethodType droType = MethodType.methodType(void.class, ObjectStreamClass.class, Object.class, ObjectInputStream.class);\n+            DRO_HANDLE = MethodHandles.lookup().findStatic(ObjectStreamDefaultSupport.class, \"defaultReadObject\", droType);\n+            MethodType dwoType = MethodType.methodType(void.class, ObjectStreamClass.class, Object.class, ObjectOutputStream.class);\n+            DWO_HANDLE = MethodHandles.lookup().findStatic(ObjectStreamDefaultSupport.class, \"defaultWriteObject\", dwoType);\n+        } catch (NoSuchMethodException e) {\n+            throw new NoSuchMethodError(e.getMessage());\n+        } catch (IllegalAccessException e) {\n+            throw new IllegalAccessError(e.getMessage());\n+        }\n+    }\n+\n+    private static void defaultReadObject(ObjectStreamClass streamClass, Object obj, ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+        ObjectInputStream.GetField getField = ois.readFields();\n+        byte[] bytes = new byte[streamClass.getPrimDataSize()];\n+        Object[] objs = new Object[streamClass.getNumObjFields()];\n+        for (ObjectStreamField field : streamClass.getFields(false)) {\n+            int offset = field.getOffset();\n+            String fieldName = field.getName();\n+            switch (field.getTypeCode()) {\n+                case 'B' -> bytes[offset] = getField.get(fieldName, (byte) 0);\n+                case 'C' -> ByteArray.setChar(bytes, offset, getField.get(fieldName, (char) 0));\n+                case 'D' -> ByteArray.setDoubleRaw(bytes, offset, getField.get(fieldName, 0.0));\n+                case 'F' -> ByteArray.setFloatRaw(bytes, offset, getField.get(fieldName, 0.0f));\n+                case 'I' -> ByteArray.setInt(bytes, offset, getField.get(fieldName, 0));\n+                case 'J' -> ByteArray.setLong(bytes, offset, getField.get(fieldName, 0L));\n+                case 'S' -> ByteArray.setShort(bytes, offset, getField.get(fieldName, (short) 0));\n+                case 'Z' -> ByteArray.setBoolean(bytes, offset, getField.get(fieldName, false));\n+                case '[', 'L' -> objs[offset] = getField.get(fieldName, null);\n+                default -> throw new IllegalStateException();\n+            }\n+        }\n+        streamClass.setPrimFieldValues(obj, bytes);\n+        streamClass.setObjFieldValues(obj, objs);\n+    }\n+\n+    private static void defaultWriteObject(ObjectStreamClass streamClass, Object obj, ObjectOutputStream oos) throws IOException {\n+        ObjectOutputStream.PutField putField = oos.putFields();\n+        byte[] bytes = new byte[streamClass.getPrimDataSize()];\n+        Object[] objs = new Object[streamClass.getNumObjFields()];\n+        streamClass.getPrimFieldValues(obj, bytes);\n+        streamClass.getObjFieldValues(obj, objs);\n+        for (ObjectStreamField field : streamClass.getFields(false)) {\n+            int offset = field.getOffset();\n+            String fieldName = field.getName();\n+            switch (field.getTypeCode()) {\n+                case 'B' -> putField.put(fieldName, bytes[offset]);\n+                case 'C' -> putField.put(fieldName, ByteArray.getChar(bytes, offset));\n+                case 'D' -> putField.put(fieldName, ByteArray.getDouble(bytes, offset));\n+                case 'F' -> putField.put(fieldName, ByteArray.getFloat(bytes, offset));\n+                case 'I' -> putField.put(fieldName, ByteArray.getInt(bytes, offset));\n+                case 'J' -> putField.put(fieldName, ByteArray.getLong(bytes, offset));\n+                case 'S' -> putField.put(fieldName, ByteArray.getShort(bytes, offset));\n+                case 'Z' -> putField.put(fieldName, ByteArray.getBoolean(bytes, offset));\n+                case '[', 'L' -> putField.put(fieldName, objs[offset]);\n+                default -> throw new IllegalStateException();\n+            }\n+        }\n+        oos.writeFields();\n+    }\n+\n+    static final class Access implements JavaObjectStreamDefaultSupportAccess {\n+        static {\n+            SharedSecrets.setJavaObjectStreamDefaultSupportAccess(new Access());\n+        }\n+\n+        public MethodHandle defaultReadObject(Class<?> clazz) {\n+            ObjectStreamClass streamClass = getStreamClass(clazz);\n+            return streamClass == null ? null : DRO_HANDLE.bindTo(streamClass).asType(MethodType.methodType(void.class, streamClass.forClass(), ObjectInputStream.class));\n+        }\n+\n+        public MethodHandle defaultWriteObject(Class<?> clazz) {\n+            ObjectStreamClass streamClass = getStreamClass(clazz);\n+            return streamClass == null ? null : DWO_HANDLE.bindTo(streamClass).asType(MethodType.methodType(void.class, streamClass.forClass(), ObjectOutputStream.class));\n+        }\n+\n+        private static ObjectStreamClass getStreamClass(final Class<?> clazz) {\n+            ObjectStreamClass streamClass = ObjectStreamClass.lookup(clazz);\n+            if (streamClass == null) {\n+                return null;\n+            }\n+            try {\n+                streamClass.checkDefaultSerialize();\n+            } catch (InvalidClassException e) {\n+                return null;\n+            }\n+            return streamClass;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamDefaultSupport.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+public interface JavaObjectStreamDefaultSupportAccess {\n+    MethodHandle defaultReadObject(Class<?> clazz);\n+    MethodHandle defaultWriteObject(Class<?> clazz);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaObjectStreamDefaultSupportAccess.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -76,0 +76,1 @@\n+    private static JavaObjectStreamDefaultSupportAccess javaObjectStreamDefaultSupportAccess;\n@@ -456,0 +457,15 @@\n+    public static JavaObjectStreamDefaultSupportAccess getJavaObjectStreamDefaultSupportAccess() {\n+        var access = javaObjectStreamDefaultSupportAccess;\n+        if (access == null) {\n+            try {\n+                Class.forName(\"java.io.ObjectStreamDefaultSupport$Access\", true, null);\n+                access = javaObjectStreamDefaultSupportAccess;\n+            } catch (ClassNotFoundException e) {}\n+        }\n+        return access;\n+    }\n+\n+    public static void setJavaObjectStreamDefaultSupportAccess(JavaObjectStreamDefaultSupportAccess access) {\n+        javaObjectStreamDefaultSupportAccess = access;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.internal.access.JavaObjectStreamDefaultSupportAccess;\n@@ -76,0 +77,1 @@\n+    private final JavaObjectStreamDefaultSupportAccess javaObjectStreamDefaultSupportAccess;\n@@ -78,0 +80,1 @@\n+        this.javaObjectStreamDefaultSupportAccess = SharedSecrets.getJavaObjectStreamDefaultSupportAccess();\n@@ -442,1 +445,1 @@\n-        return SerializationBytecodeGenerator.defaultReadObjectForSerialization(cl);\n+        return javaObjectStreamDefaultSupportAccess.defaultReadObject(cl);\n@@ -450,1 +453,1 @@\n-        return SerializationBytecodeGenerator.defaultWriteObjectForSerialization(cl);\n+        return javaObjectStreamDefaultSupportAccess.defaultWriteObject(cl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,306 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectStreamField;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.TypeKind;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Modifier;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import jdk.internal.constant.MethodTypeDescImpl;\n-import jdk.internal.constant.ReferenceClassDescImpl;\n-\n-\/**\n- * The private serialization bytecode generator used by {@code sun.misc.ReflectionFactory}.\n- *\/\n-final class SerializationBytecodeGenerator {\n-    private static final MethodHandles.Lookup lookup = MethodHandles.lookup();\n-    @SuppressWarnings(\"removal\")\n-    private static final ReflectionFactory reflectionFactory = AccessController.doPrivileged((PrivilegedAction<ReflectionFactory>) ReflectionFactory::getReflectionFactory);\n-\n-    \/*\n-     * The accessors generated by this class are implemented using an anonymous+hidden\n-     * class to carry the method. Because we are using a non-privileged lookup, we\n-     * generate unreflected accessor method handles based on setAccessible(true) fields\n-     * for the (likely) case that we won't have access to a given field. The accessor's\n-     * type must also be erased to `Object` when non-primitive because we may not have\n-     * access to the field's type. This is generally not much of a penalty though,\n-     * because the object-based methods we interact with on `PutField` and `GetField`\n-     * all work in terms of `Object` anyway.\n-     *\/\n-\n-    \/\/ no instances\n-    private SerializationBytecodeGenerator() {}\n-\n-    static MethodHandle defaultReadObjectForSerialization(Class<?> cl) {\n-        List<MethodHandle> setters = new ArrayList<>();\n-        byte[] bytes = ClassFile.of().build(CD_Generated_readObject, classBuilder -> classBuilder.withMethod(\"readObject\",\n-            MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_Object, CD_ObjectInputStream),\n-            Modifier.STATIC | Modifier.PRIVATE,\n-            mb -> mb.withCode(cb -> {\n-                \/\/ get our GetField\n-                cb.aload(1);\n-                cb.invokevirtual(CD_ObjectInputStream, \"readFields\", MTD_ObjectInputStream_readFields);\n-                cb.astore(2);\n-                \/\/ check to see if stream fields are present, and if so, restrict the wire format accordingly\n-                ObjectStreamField[] spf = reflectionFactory.serialPersistentFields(cl);\n-                Map<String, ObjectStreamField> fields = spf == null ? null : Stream.of(spf).collect(Collectors.toMap(\n-                    ObjectStreamField::getName,\n-                    Function.identity()\n-                ));\n-                \/\/ iterate the fields of the class\n-                for (Field field : cl.getDeclaredFields()) {\n-                    int fieldMods = field.getModifiers();\n-                    if (Modifier.isStatic(fieldMods) || Modifier.isTransient(fieldMods)) {\n-                        continue;\n-                    }\n-                    String fieldName = field.getName();\n-                    Class<?> fieldType = field.getType();\n-                    if (fields != null && (! fields.containsKey(fieldName) || fields.get(fieldName).getType() != fieldType)) {\n-                        \/\/ field does not match stream data\n-                        continue;\n-                    }\n-\n-                    \/\/ generate setter\n-                    field.setAccessible(true);\n-                    int idx = setters.size();\n-                    MethodHandle mh;\n-                    try {\n-                        mh = lookup.unreflectSetter(field);\n-                        if (fieldType.isPrimitive()) {\n-                            mh = mh.asType(MethodType.methodType(void.class, Object.class, fieldType));\n-                        } else {\n-                            mh = mh.asType(MethodType.methodType(void.class, Object.class, Object.class));\n-                        }\n-                        setters.add(mh);\n-                    } catch (IllegalAccessException e) {\n-                        throw new InternalError(\"Error generating accessor for field \" + field, e);\n-                    }\n-                    cb.ldc(DynamicConstantDesc.ofNamed(\n-                        ConstantDescs.BSM_CLASS_DATA_AT,\n-                        ConstantDescs.DEFAULT_NAME,\n-                        ConstantDescs.CD_MethodHandle,\n-                        Integer.valueOf(idx)\n-                    ));\n-                    \/\/ stack: <mh>\n-                    cb.aload(0); \/\/ stack: <mh> this\n-                    cb.aload(2); \/\/ stack: <mh> this GetField\n-                    cb.ldc(fieldName); \/\/ stack: <mh> this GetField <name>\n-\n-                    ClassDesc fieldDesc = fieldType.describeConstable().orElseThrow(InternalError::new);\n-\n-                    switch (TypeKind.from(fieldDesc)) {\n-                        case ByteType -> {\n-                            cb.iconst_0();\n-                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_B);\n-                        }\n-                        case CharType -> {\n-                            cb.iconst_0();\n-                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_C);\n-                        }\n-                        case DoubleType -> {\n-                            cb.dconst_0();\n-                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_D);\n-                        }\n-                        case FloatType -> {\n-                            cb.fconst_0();\n-                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_F);\n-                        }\n-                        case IntType -> {\n-                            cb.iconst_0();\n-                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_I);\n-                        }\n-                        case LongType -> {\n-                            cb.lconst_0();\n-                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_J);\n-                        }\n-                        case ShortType -> {\n-                            cb.iconst_0();\n-                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_S);\n-                        }\n-                        case BooleanType -> {\n-                            cb.iconst_0();\n-                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_Z);\n-                        }\n-                        case ReferenceType -> {\n-                            cb.aconst_null();\n-                            cb.invokevirtual(CD_ObjectInputStream_GetField, \"get\", MTD_ObjectInputStream_GetField_get_L);\n-                        }\n-                    }\n-                    \/\/ stack: <mh> this <val>\n-                    cb.invokevirtual(ConstantDescs.CD_MethodHandle, \"invokeExact\", mh.type().describeConstable().orElseThrow(InternalError::new));\n-                }\n-                cb.return_();\n-            })\n-        ));\n-        try {\n-            MethodHandles.Lookup hcLookup = lookup.defineHiddenClassWithClassData(bytes, List.copyOf(setters), true);\n-            return hcLookup.findStatic(hcLookup.lookupClass(), \"readObject\", MethodType.methodType(void.class, Object.class, ObjectInputStream.class))\n-                .asType(MethodType.methodType(void.class, cl, ObjectInputStream.class));\n-        } catch (IllegalAccessException | NoSuchMethodException e) {\n-            throw new InternalError(\"Error in readObject generation\", e);\n-        }\n-    }\n-\n-    static MethodHandle defaultWriteObjectForSerialization(Class<?> cl) {\n-        List<MethodHandle> getters = new ArrayList<>();\n-        byte[] bytes = ClassFile.of().build(CD_Generated_writeObject, classBuilder -> classBuilder.withMethod(\"writeObject\",\n-            MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_Object, CD_ObjectOutputStream),\n-            Modifier.STATIC | Modifier.PRIVATE,\n-            mb -> mb.withCode(cb -> {\n-                \/\/ get our PutField\n-                cb.aload(1);\n-                cb.invokevirtual(CD_ObjectOutputStream, \"putFields\", MTD_ObjectOutputStream_putFields);\n-                cb.astore(2);\n-                \/\/ check to see if stream fields are present, and if so, restrict the wire format accordingly\n-                ObjectStreamField[] spf = reflectionFactory.serialPersistentFields(cl);\n-                Map<String, ObjectStreamField> fields = spf == null ? null : Stream.of(spf).collect(Collectors.toMap(\n-                    ObjectStreamField::getName,\n-                    Function.identity()\n-                ));\n-                \/\/ iterate the fields of the class\n-                for (Field field : cl.getDeclaredFields()) {\n-                    int fieldMods = field.getModifiers();\n-                    if (Modifier.isStatic(fieldMods) || Modifier.isTransient(fieldMods)) {\n-                        continue;\n-                    }\n-                    String fieldName = field.getName();\n-                    Class<?> fieldType = field.getType();\n-                    if (fields != null && (! fields.containsKey(fieldName) || fields.get(fieldName).getType() != fieldType)) {\n-                        \/\/ field does not match stream data\n-                        continue;\n-                    }\n-\n-                    \/\/ stack: (empty)\n-                    cb.aload(2);\n-                    \/\/ stack: PutField\n-                    cb.ldc(fieldName);\n-                    \/\/ stack: PutField fieldName\n-                    \/\/ generate getter\n-                    field.setAccessible(true);\n-                    int idx = getters.size();\n-                    MethodHandle getter;\n-                    try {\n-                        getter = lookup.unreflectGetter(field);\n-                        if (fieldType.isPrimitive()) {\n-                            getter = getter.asType(MethodType.methodType(fieldType, Object.class));\n-                        } else {\n-                            getter = getter.asType(MethodType.methodType(Object.class, Object.class));\n-                        }\n-                        getters.add(getter);\n-                    } catch (IllegalAccessException e) {\n-                        throw new InternalError(\"Error generating accessor for field \" + field, e);\n-                    }\n-                    cb.ldc(DynamicConstantDesc.ofNamed(\n-                        ConstantDescs.BSM_CLASS_DATA_AT,\n-                        ConstantDescs.DEFAULT_NAME,\n-                        ConstantDescs.CD_MethodHandle,\n-                        Integer.valueOf(idx)\n-                    ));\n-                    \/\/ stack: PutField fieldName <mh>\n-                    cb.aload(0);\n-                    \/\/ stack: PutField fieldName <mh> this\n-                    cb.invokevirtual(ConstantDescs.CD_MethodHandle, \"invokeExact\", getter.type().describeConstable().orElseThrow(InternalError::new));\n-                    \/\/ stack: PutField fieldName <val>\n-                    switch (TypeKind.from(fieldType)) {\n-                        case ByteType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_B);\n-                        case CharType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_C);\n-                        case DoubleType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_D);\n-                        case FloatType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_F);\n-                        case IntType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_I);\n-                        case LongType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_J);\n-                        case ShortType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_S);\n-                        case BooleanType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_Z);\n-                        case ReferenceType -> cb.invokevirtual(CD_ObjectOutputStream_PutField, \"put\", MTD_ObjectOutputStream_PutField_put_L);\n-                    }\n-                    \/\/ stack: (empty)\n-                }\n-                \/\/ commit fields to stream\n-                cb.aload(1);\n-                cb.invokevirtual(CD_ObjectOutputStream, \"writeFields\", ConstantDescs.MTD_void);\n-                cb.return_();\n-            })\n-        ));\n-        try {\n-            MethodHandles.Lookup hcLookup = lookup.defineHiddenClassWithClassData(bytes, List.copyOf(getters), true);\n-            return hcLookup.findStatic(hcLookup.lookupClass(), \"writeObject\", MethodType.methodType(void.class, Object.class, ObjectOutputStream.class))\n-                .asType(MethodType.methodType(void.class, cl, ObjectOutputStream.class));\n-        } catch (IllegalAccessException | NoSuchMethodException e) {\n-            throw new InternalError(\"Error in writeObject generation\", e);\n-        }\n-    }\n-\n-    private static final ClassDesc CD_ObjectInputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n-    private static final ClassDesc CD_ObjectInputStream_GetField = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream$GetField;\");\n-\n-    private static final ClassDesc CD_ObjectOutputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n-    private static final ClassDesc CD_ObjectOutputStream_PutField = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream$PutField;\");\n-\n-    private static final ClassDesc CD_Generated_writeObject = ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/reflect\/Generated$$writeObject;\");\n-    private static final ClassDesc CD_Generated_readObject = ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/reflect\/Generated$$readObject;\");\n-\n-    private static final MethodTypeDesc MTD_ObjectInputStream_readFields = MethodTypeDescImpl.ofValidated(CD_ObjectInputStream_GetField);\n-\n-    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_B = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_byte, ConstantDescs.CD_String, ConstantDescs.CD_byte);\n-    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_C = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_char, ConstantDescs.CD_String, ConstantDescs.CD_char);\n-    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_D = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_double, ConstantDescs.CD_String, ConstantDescs.CD_double);\n-    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_F = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_float, ConstantDescs.CD_String, ConstantDescs.CD_float);\n-    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_I = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int, ConstantDescs.CD_String, ConstantDescs.CD_int);\n-    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_J = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_long, ConstantDescs.CD_String, ConstantDescs.CD_long);\n-    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_L = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_Object, ConstantDescs.CD_String, ConstantDescs.CD_Object);\n-    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_S = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_short, ConstantDescs.CD_String, ConstantDescs.CD_short);\n-    private static final MethodTypeDesc MTD_ObjectInputStream_GetField_get_Z = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_boolean, ConstantDescs.CD_String, ConstantDescs.CD_boolean);\n-\n-    private static final MethodTypeDesc MTD_ObjectOutputStream_putFields = MethodTypeDescImpl.ofValidated(CD_ObjectOutputStream_PutField);\n-\n-    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_B = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_byte);\n-    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_C = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_char);\n-    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_D = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_double);\n-    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_F = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_float);\n-    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_I = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_int);\n-    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_J = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_long);\n-    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_L = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_Object);\n-    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_S = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_short);\n-    private static final MethodTypeDesc MTD_ObjectOutputStream_PutField_put_Z = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_void, ConstantDescs.CD_String, ConstantDescs.CD_boolean);\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationBytecodeGenerator.java","additions":0,"deletions":306,"binary":false,"changes":306,"status":"deleted"},{"patch":"@@ -850,1 +850,1 @@\n-    \/\/ Ensure that classes with serialPersistentFields do not get\/set other fields\n+    \/\/ Ensure that classes with serialPersistentFields do not allow default setting\/getting\n@@ -852,124 +852,3 @@\n-    static void testDisallowed() throws Throwable {\n-        \/\/ first check write\n-        MethodHandle writeHandle = factory.defaultWriteObjectForSerialization(SerialPersistentFields.class);\n-        SerialPersistentFields spf = new SerialPersistentFields();\n-        spf.int1 = 123;\n-        spf.array1 = new Object[] { \"Hello\", \"world\" };\n-        writeHandle.invokeExact(spf, (ObjectOutputStream) new ObjectOutputStream() {\n-            protected void writeObjectOverride(final Object obj) throws IOException {\n-                throw new IOException(\"Wrong method called\");\n-            }\n-\n-            public PutField putFields() {\n-                return new PutField() {\n-                    public void put(final String name, final boolean val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public void put(final String name, final byte val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public void put(final String name, final char val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public void put(final String name, final short val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public void put(final String name, final int val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public void put(final String name, final long val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public void put(final String name, final float val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public void put(final String name, final double val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public void put(final String name, final Object val) {\n-                        switch (name) {\n-                            case \"array1\" -> Assert.assertEquals((Object[])val, new Object[] {\n-                                \"Hello\", \"world\"\n-                            });\n-                            default -> throw new Error(\"Unexpected field \" + name);\n-                        }\n-                    }\n-\n-                    @SuppressWarnings(\"removal\")\n-                    public void write(final ObjectOutput out) throws IOException {\n-                        throw new IOException(\"Wrong method called\");\n-                    }\n-                };\n-            }\n-\n-            public void writeFields() {\n-                \/\/ ignore\n-            }\n-        });\n-        MethodHandle readHandle = factory.defaultReadObjectForSerialization(SerialPersistentFields.class);\n-        readHandle.invokeExact(spf, (ObjectInputStream) new ObjectInputStream() {\n-            protected Object readObjectOverride() throws IOException {\n-                throw new IOException(\"Wrong method called\");\n-            }\n-\n-            public GetField readFields() {\n-                return new GetField() {\n-                    public ObjectStreamClass getObjectStreamClass() {\n-                        throw new Error(\"Wrong method called\");\n-                    }\n-\n-                    public boolean defaulted(final String name) {\n-                        return false;\n-                    }\n-\n-                    public boolean get(final String name, final boolean val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public byte get(final String name, final byte val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public char get(final String name, final char val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public short get(final String name, final short val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public int get(final String name, final int val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public long get(final String name, final long val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public float get(final String name, final float val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public double get(final String name, final double val) {\n-                        throw new Error(\"Unexpected field \" + name);\n-                    }\n-\n-                    public Object get(final String name, final Object val) {\n-                        return switch (name) {\n-                            case \"array1\" -> new Object[] { \"Changed!\" };\n-                            default -> throw new Error(\"Unexpected field \" + name);\n-                        };\n-                    }\n-                };\n-            }\n-        });\n-        Assert.assertEquals(spf.int1, 123);\n-        Assert.assertEquals(spf.array1, new Object[] { \"Changed!\" });\n+    static void testDisallowed() {\n+        Assert.assertNull(factory.defaultWriteObjectForSerialization(SerialPersistentFields.class));\n+        Assert.assertNull(factory.defaultReadObjectForSerialization(SerialPersistentFields.class));\n","filename":"test\/jdk\/sun\/reflect\/ReflectionFactory\/ReflectionFactoryTest.java","additions":4,"deletions":125,"binary":false,"changes":129,"status":"modified"}]}