{"files":[{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.io;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-\n-import jdk.internal.access.JavaObjectStreamDefaultSupportAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.util.ByteArray;\n-\n-\/**\n- *\n- *\/\n-final class ObjectStreamDefaultSupport {\n-\n-    \/\/ todo: these could be constants\n-    private static final MethodHandle DRO_HANDLE;\n-    private static final MethodHandle DWO_HANDLE;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MethodType droType = MethodType.methodType(void.class, ObjectStreamClass.class, Object.class, ObjectInputStream.class);\n-            DRO_HANDLE = lookup.findStatic(ObjectStreamDefaultSupport.class, \"defaultReadObject\", droType);\n-            MethodType dwoType = MethodType.methodType(void.class, ObjectStreamClass.class, Object.class, ObjectOutputStream.class);\n-            DWO_HANDLE = lookup.findStatic(ObjectStreamDefaultSupport.class, \"defaultWriteObject\", dwoType);\n-        } catch (NoSuchMethodException e) {\n-            throw new NoSuchMethodError(e.getMessage());\n-        } catch (IllegalAccessException e) {\n-            throw new IllegalAccessError(e.getMessage());\n-        }\n-    }\n-\n-    private static void defaultReadObject(ObjectStreamClass streamClass, Object obj, ObjectInputStream ois) throws IOException, ClassNotFoundException {\n-        ObjectInputStream.GetField getField = ois.readFields();\n-        byte[] bytes = new byte[streamClass.getPrimDataSize()];\n-        Object[] objs = new Object[streamClass.getNumObjFields()];\n-        for (ObjectStreamField field : streamClass.getFields(false)) {\n-            int offset = field.getOffset();\n-            String fieldName = field.getName();\n-            switch (field.getTypeCode()) {\n-                case 'B' -> bytes[offset] = getField.get(fieldName, (byte) 0);\n-                case 'C' -> ByteArray.setChar(bytes, offset, getField.get(fieldName, (char) 0));\n-                case 'D' -> ByteArray.setDoubleRaw(bytes, offset, getField.get(fieldName, 0.0));\n-                case 'F' -> ByteArray.setFloatRaw(bytes, offset, getField.get(fieldName, 0.0f));\n-                case 'I' -> ByteArray.setInt(bytes, offset, getField.get(fieldName, 0));\n-                case 'J' -> ByteArray.setLong(bytes, offset, getField.get(fieldName, 0L));\n-                case 'S' -> ByteArray.setShort(bytes, offset, getField.get(fieldName, (short) 0));\n-                case 'Z' -> ByteArray.setBoolean(bytes, offset, getField.get(fieldName, false));\n-                case '[', 'L' -> objs[offset] = getField.get(fieldName, null);\n-                default -> throw new IllegalStateException();\n-            }\n-        }\n-        streamClass.setPrimFieldValues(obj, bytes);\n-        streamClass.setObjFieldValues(obj, objs);\n-    }\n-\n-    private static void defaultWriteObject(ObjectStreamClass streamClass, Object obj, ObjectOutputStream oos) throws IOException {\n-        ObjectOutputStream.PutField putField = oos.putFields();\n-        byte[] bytes = new byte[streamClass.getPrimDataSize()];\n-        Object[] objs = new Object[streamClass.getNumObjFields()];\n-        streamClass.getPrimFieldValues(obj, bytes);\n-        streamClass.getObjFieldValues(obj, objs);\n-        for (ObjectStreamField field : streamClass.getFields(false)) {\n-            int offset = field.getOffset();\n-            String fieldName = field.getName();\n-            switch (field.getTypeCode()) {\n-                case 'B' -> putField.put(fieldName, bytes[offset]);\n-                case 'C' -> putField.put(fieldName, ByteArray.getChar(bytes, offset));\n-                case 'D' -> putField.put(fieldName, ByteArray.getDouble(bytes, offset));\n-                case 'F' -> putField.put(fieldName, ByteArray.getFloat(bytes, offset));\n-                case 'I' -> putField.put(fieldName, ByteArray.getInt(bytes, offset));\n-                case 'J' -> putField.put(fieldName, ByteArray.getLong(bytes, offset));\n-                case 'S' -> putField.put(fieldName, ByteArray.getShort(bytes, offset));\n-                case 'Z' -> putField.put(fieldName, ByteArray.getBoolean(bytes, offset));\n-                case '[', 'L' -> putField.put(fieldName, objs[offset]);\n-                default -> throw new IllegalStateException();\n-            }\n-        }\n-        oos.writeFields();\n-    }\n-\n-    static final class Access implements JavaObjectStreamDefaultSupportAccess {\n-        static {\n-            SharedSecrets.setJavaObjectStreamDefaultSupportAccess(new Access());\n-        }\n-\n-        public MethodHandle defaultReadObject(Class<?> clazz) {\n-            ObjectStreamClass streamClass = getStreamClass(clazz);\n-            return streamClass == null ? null : DRO_HANDLE.bindTo(streamClass).asType(MethodType.methodType(void.class, streamClass.forClass(), ObjectInputStream.class));\n-        }\n-\n-        public MethodHandle defaultWriteObject(Class<?> clazz) {\n-            ObjectStreamClass streamClass = getStreamClass(clazz);\n-            return streamClass == null ? null : DWO_HANDLE.bindTo(streamClass).asType(MethodType.methodType(void.class, streamClass.forClass(), ObjectOutputStream.class));\n-        }\n-\n-        private static ObjectStreamClass getStreamClass(final Class<?> clazz) {\n-            ObjectStreamClass streamClass = ObjectStreamClass.lookup(clazz);\n-            if (streamClass == null) {\n-                return null;\n-            }\n-            try {\n-                streamClass.checkDefaultSerialize();\n-            } catch (InvalidClassException e) {\n-                return null;\n-            }\n-            return streamClass;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamDefaultSupport.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import jdk.internal.access.JavaObjectStreamDefaultSupportAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArray;\n+\n+\/**\n+ * Utilities relating to serialization and deserialization of objects.\n+ *\/\n+final class ObjectStreamReflection {\n+\n+    \/\/ todo: these could be constants\n+    private static final MethodHandle DRO_HANDLE;\n+    private static final MethodHandle DWO_HANDLE;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MethodType droType = MethodType.methodType(void.class, ObjectStreamClass.class, Object.class, ObjectInputStream.class);\n+            DRO_HANDLE = lookup.findStatic(ObjectStreamReflection.class, \"defaultReadObject\", droType);\n+            MethodType dwoType = MethodType.methodType(void.class, ObjectStreamClass.class, Object.class, ObjectOutputStream.class);\n+            DWO_HANDLE = lookup.findStatic(ObjectStreamReflection.class, \"defaultWriteObject\", dwoType);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Populate a serializable object from data acquired from the stream's\n+     * {@link java.io.ObjectInputStream.GetField} object independently of\n+     * the actual {@link ObjectInputStream} implementation which may\n+     * arbitrarily override the {@link ObjectInputStream#readFields()} method\n+     * in order to deserialize using a custom object format.\n+     * <p>\n+     * The fields are populated using the mechanism defined in {@link ObjectStreamClass},\n+     * which requires objects and primitives to each be packed into a separate array\n+     * whose relative field offsets are defined in the {@link ObjectStreamField}\n+     * corresponding to each field.\n+     * Utility methods on the {@code ObjectStreamClass} instance are then used\n+     * to validate and perform the actual field accesses.\n+     *\n+     * @param streamClass the object stream class of the object (must not be {@code null})\n+     * @param obj the object to deserialize (must not be {@code null})\n+     * @param ois the object stream (must not be {@code null})\n+     * @throws IOException if the call to {@link ObjectInputStream#readFields} or one of its field accessors throws this exception type\n+     * @throws ClassNotFoundException if the call to {@link ObjectInputStream#readFields} or one of its field accessors throws this exception type\n+     *\/\n+    private static void defaultReadObject(ObjectStreamClass streamClass, Object obj, ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+        ObjectInputStream.GetField getField = ois.readFields();\n+        byte[] bytes = new byte[streamClass.getPrimDataSize()];\n+        Object[] objs = new Object[streamClass.getNumObjFields()];\n+        for (ObjectStreamField field : streamClass.getFields(false)) {\n+            int offset = field.getOffset();\n+            String fieldName = field.getName();\n+            switch (field.getTypeCode()) {\n+                case 'B' -> bytes[offset] = getField.get(fieldName, (byte) 0);\n+                case 'C' -> ByteArray.setChar(bytes, offset, getField.get(fieldName, (char) 0));\n+                case 'D' -> ByteArray.setDoubleRaw(bytes, offset, getField.get(fieldName, 0.0));\n+                case 'F' -> ByteArray.setFloatRaw(bytes, offset, getField.get(fieldName, 0.0f));\n+                case 'I' -> ByteArray.setInt(bytes, offset, getField.get(fieldName, 0));\n+                case 'J' -> ByteArray.setLong(bytes, offset, getField.get(fieldName, 0L));\n+                case 'S' -> ByteArray.setShort(bytes, offset, getField.get(fieldName, (short) 0));\n+                case 'Z' -> ByteArray.setBoolean(bytes, offset, getField.get(fieldName, false));\n+                case '[', 'L' -> objs[offset] = getField.get(fieldName, null);\n+                default -> throw new IllegalStateException();\n+            }\n+        }\n+        streamClass.setPrimFieldValues(obj, bytes);\n+        streamClass.checkObjFieldValueTypes(obj, objs);\n+        streamClass.setObjFieldValues(obj, objs);\n+    }\n+\n+    \/**\n+     * Populate and write a stream's {@link java.io.ObjectOutputStream.PutField} object\n+     * from field data acquired from a serializable object independently of\n+     * the actual {@link ObjectOutputStream} implementation which may\n+     * arbitrarily override the {@link ObjectOutputStream#putFields()}\n+     * and {@link ObjectOutputStream#writeFields()} methods\n+     * in order to deserialize using a custom object format.\n+     * <p>\n+     * The fields are accessed using the mechanism defined in {@link ObjectStreamClass},\n+     * which causes objects and primitives to each be packed into a separate array\n+     * whose relative field offsets are defined in the {@link ObjectStreamField}\n+     * corresponding to each field.\n+     *\n+     * @param streamClass the object stream class of the object (must not be {@code null})\n+     * @param obj the object to serialize (must not be {@code null})\n+     * @param oos the object stream (must not be {@code null})\n+     * @throws IOException if the call to {@link ObjectInputStream#readFields} or one of its field accessors throws this exception type\n+     *\/\n+    private static void defaultWriteObject(ObjectStreamClass streamClass, Object obj, ObjectOutputStream oos) throws IOException {\n+        ObjectOutputStream.PutField putField = oos.putFields();\n+        byte[] bytes = new byte[streamClass.getPrimDataSize()];\n+        Object[] objs = new Object[streamClass.getNumObjFields()];\n+        streamClass.getPrimFieldValues(obj, bytes);\n+        streamClass.getObjFieldValues(obj, objs);\n+        for (ObjectStreamField field : streamClass.getFields(false)) {\n+            int offset = field.getOffset();\n+            String fieldName = field.getName();\n+            switch (field.getTypeCode()) {\n+                case 'B' -> putField.put(fieldName, bytes[offset]);\n+                case 'C' -> putField.put(fieldName, ByteArray.getChar(bytes, offset));\n+                case 'D' -> putField.put(fieldName, ByteArray.getDouble(bytes, offset));\n+                case 'F' -> putField.put(fieldName, ByteArray.getFloat(bytes, offset));\n+                case 'I' -> putField.put(fieldName, ByteArray.getInt(bytes, offset));\n+                case 'J' -> putField.put(fieldName, ByteArray.getLong(bytes, offset));\n+                case 'S' -> putField.put(fieldName, ByteArray.getShort(bytes, offset));\n+                case 'Z' -> putField.put(fieldName, ByteArray.getBoolean(bytes, offset));\n+                case '[', 'L' -> putField.put(fieldName, objs[offset]);\n+                default -> throw new IllegalStateException();\n+            }\n+        }\n+        oos.writeFields();\n+    }\n+\n+    static final class Access implements JavaObjectStreamDefaultSupportAccess {\n+        static {\n+            SharedSecrets.setJavaObjectStreamDefaultSupportAccess(new Access());\n+        }\n+\n+        public MethodHandle defaultReadObject(Class<?> clazz) {\n+            ObjectStreamClass streamClass = getStreamClass(clazz);\n+            return streamClass == null ? null : DRO_HANDLE.bindTo(streamClass).asType(MethodType.methodType(void.class, streamClass.forClass(), ObjectInputStream.class));\n+        }\n+\n+        public MethodHandle defaultWriteObject(Class<?> clazz) {\n+            ObjectStreamClass streamClass = getStreamClass(clazz);\n+            return streamClass == null ? null : DWO_HANDLE.bindTo(streamClass).asType(MethodType.methodType(void.class, streamClass.forClass(), ObjectOutputStream.class));\n+        }\n+\n+        private static ObjectStreamClass getStreamClass(final Class<?> clazz) {\n+            ObjectStreamClass streamClass = ObjectStreamClass.lookup(clazz);\n+            if (streamClass == null) {\n+                return null;\n+            }\n+            try {\n+                streamClass.checkDefaultSerialize();\n+            } catch (InvalidClassException e) {\n+                return null;\n+            }\n+            return streamClass;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamReflection.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -441,1 +441,1 @@\n-        if (! isValidSerializable(cl)) {\n+        if (hasDefaultOrNoSerialization(cl)) {\n@@ -449,1 +449,1 @@\n-        if (! isValidSerializable(cl)) {\n+        if (hasDefaultOrNoSerialization(cl)) {\n@@ -478,18 +478,0 @@\n-    public final long serialVersionUID(Class<?> cl) {\n-        if (! Serializable.class.isAssignableFrom(cl) || cl.isInterface() || cl.isEnum()) {\n-            return 0;\n-        }\n-\n-        try {\n-            Field field = cl.getDeclaredField(\"serialVersionUID\");\n-            int mods = field.getModifiers();\n-            if (! (Modifier.isStatic(mods) && Modifier.isPrivate(mods) && Modifier.isFinal(mods))) {\n-                return 0;\n-            }\n-            field.setAccessible(true);\n-            return field.getLong(null);\n-        } catch (ReflectiveOperationException e) {\n-            return 0;\n-        }\n-    }\n-\n@@ -508,10 +490,10 @@\n-    private static boolean isValidSerializable(Class<?> cl) {\n-        return Serializable.class.isAssignableFrom(cl)\n-            && ! cl.isInterface()\n-            && ! cl.isArray()\n-            && ! Proxy.isProxyClass(cl)\n-            && ! Externalizable.class.isAssignableFrom(cl)\n-            && ! cl.isEnum()\n-            && ! cl.isRecord()\n-            && ! cl.isHidden()\n-            && ! nonSerializableLeafClasses.contains(cl);\n+    private static boolean hasDefaultOrNoSerialization(Class<?> cl) {\n+        return ! Serializable.class.isAssignableFrom(cl)\n+            || cl.isInterface()\n+            || cl.isArray()\n+            || Proxy.isProxyClass(cl)\n+            || Externalizable.class.isAssignableFrom(cl)\n+            || cl.isEnum()\n+            || cl.isRecord()\n+            || cl.isHidden()\n+            || nonSerializableLeafClasses.contains(cl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":12,"deletions":30,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -195,13 +195,0 @@\n-    \/**\n-     * {@return the declared <code>serialVersionUID<\/code> from a serializable class,\n-     * or <code>0L<\/code> if none is declared or the class is not a valid\n-     * serializable class}\n-     *\n-     * @param cl a Serializable class\n-     *\n-     * @since 24\n-     *\/\n-    public final long serialVersionUID(Class<?> cl) {\n-        return delegate.serialVersionUID(cl);\n-    }\n-\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/reflect\/ReflectionFactory.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"}]}