{"files":[{"patch":"@@ -781,0 +781,10 @@\n+     * @apiNote The notion of overriding, by itself, does not involve the\n+     * method's return type, listed exceptions, or, to some extent, access\n+     * modifiers. These are additional requirements checked by the compiler\n+     * (see {@jls 8.4.8.3}).\n+     *\n+     * If the source being reflected upon has not been sufficiently compiled\n+     * &mdash; such as when processing annotations &mdash; the additional\n+     * requirements might not be checked, potentially causing this method\n+     * to return a false positive.\n+     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-#include \"export.h\"\n+public class S {\n@@ -26,2 +26,1 @@\n-EXPORT void do_recurse(int depth, void (*cb)(int, void*)) {\n-    cb(depth, cb);\n+    public void m() { }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/overrides\/S.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/jdk\/java\/foreign\/stackwalk\/libReentrantUpcalls.c","status":"copied"},{"patch":"@@ -24,1 +24,1 @@\n-#include \"export.h\"\n+public class T1 extends S {\n@@ -26,2 +26,1 @@\n-EXPORT void do_recurse(int depth, void (*cb)(int, void*)) {\n-    cb(depth, cb);\n+    protected void m() { }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/overrides\/T1.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/jdk\/java\/foreign\/stackwalk\/libReentrantUpcalls.c","status":"copied"},{"patch":"@@ -24,1 +24,1 @@\n-#include \"export.h\"\n+public class T2 extends S {\n@@ -26,2 +26,1 @@\n-EXPORT void do_recurse(int depth, void (*cb)(int, void*)) {\n-    cb(depth, cb);\n+    public int m() { return 0; }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/overrides\/T2.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/jdk\/java\/foreign\/stackwalk\/libReentrantUpcalls.c","status":"copied"},{"patch":"@@ -24,1 +24,1 @@\n-#include \"export.h\"\n+public class T3 extends S {\n@@ -26,2 +26,1 @@\n-EXPORT void do_recurse(int depth, void (*cb)(int, void*)) {\n-    cb(depth, cb);\n+    public void m() throws Exception { }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/overrides\/T3.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/jdk\/java\/foreign\/stackwalk\/libReentrantUpcalls.c","status":"copied"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8174840\n+ * @library \/tools\/javac\/lib\n+ * @build   JavacTestingAbstractProcessor TestOverrides\n+ * @compile -processor TestOverrides -proc:only S.java T1.java T2.java T3.java\n+ *\/\n+\n+import java.util.Set;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import static javax.lang.model.element.ElementKind.METHOD;\n+\n+\/*\n+ * This test models a few cases where Elements.overrides produces a false\n+ * positive which warrants @apiNote.\n+ *\/\n+public class TestOverrides extends JavacTestingAbstractProcessor {\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment round) {\n+        if (!round.processingOver()) {\n+            var sm = mIn(elements.getTypeElement(\"S\"));\n+            for (var subtypeName : new String[]{\"T1\", \"T2\", \"T3\"}) {\n+                var t = elements.getTypeElement(subtypeName);\n+                var tm = mIn(t);\n+                if (!elements.overrides(tm, sm, t))\n+                    messager.printError(String.format(\n+                            \"%s does not override %s from %s\", tm, sm, t.getQualifiedName()));\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private ExecutableElement mIn(TypeElement t) {\n+        return t.getEnclosedElements().stream()\n+                .filter(e -> e.getKind() == METHOD)\n+                .filter(e -> e.getSimpleName().toString().equals(\"m\"))\n+                .map(e -> (ExecutableElement) e)\n+                .findAny()\n+                .get();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/overrides\/TestOverrides.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"}]}