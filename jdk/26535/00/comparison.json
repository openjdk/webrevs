{"files":[{"patch":"@@ -90,1 +90,0 @@\n-gc\/g1\/humongousObjects\/objectGraphTest\/TestObjectGraphAfterGC.java 8156755 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,288 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1.humongousObjects.objectGraphTest;\n-\n-import gc.testlibrary.Helpers;\n-import jdk.test.lib.Asserts;\n-import jdk.test.whitebox.WhiteBox;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.function.Consumer;\n-\n-\/**\n- * Provides methods to initiate GC of requested type and\n- * checks for states of humongous and non-humongous soft\/weak externally\n- * referenced objects after GCs\n- *\/\n-public enum GC {\n-    CMC {\n-        @Override\n-        public Runnable get() {\n-            return () -> {\n-                WHITE_BOX.g1RunConcurrentGC();\n-            };\n-        }\n-\n-        public Consumer<ReferenceInfo<Object[]>> getChecker() {\n-            return getCheckerImpl(false, false, true, false);\n-        }\n-\n-        @Override\n-        public List<String> shouldContain() {\n-            return Arrays.asList(GCTokens.WB_INITIATED_CMC);\n-        }\n-\n-        @Override\n-        public List<String> shouldNotContain() {\n-            return Arrays.asList(GCTokens.WB_INITIATED_YOUNG_GC, GCTokens.WB_INITIATED_MIXED_GC,\n-                    GCTokens.FULL_GC, GCTokens.YOUNG_GC);\n-        }\n-    },\n-\n-    CMC_NO_SURV_ROOTS {\n-        @Override\n-        public Runnable get() {\n-            return () -> {\n-                WHITE_BOX.concurrentGCAcquireControl();\n-                try {\n-                    WHITE_BOX.youngGC();\n-                    WHITE_BOX.youngGC();\n-                    WHITE_BOX.concurrentGCRunTo(WHITE_BOX.AFTER_MARKING_STARTED);\n-                    WHITE_BOX.concurrentGCRunToIdle();\n-                } finally {\n-                    WHITE_BOX.concurrentGCReleaseControl();\n-                }\n-            };\n-        }\n-\n-        public Consumer<ReferenceInfo<Object[]>> getChecker() {\n-            return getCheckerImpl(true, false, true, false);\n-        }\n-\n-        @Override\n-        public List<String> shouldContain() {\n-            return Arrays.asList(GCTokens.WB_INITIATED_CMC);\n-        }\n-\n-        @Override\n-        public List<String> shouldNotContain() {\n-            return Arrays.asList(GCTokens.WB_INITIATED_MIXED_GC,\n-                    GCTokens.FULL_GC, GCTokens.YOUNG_GC);\n-        }\n-    },\n-\n-    YOUNG_GC {\n-        @Override\n-        public Runnable get() {\n-            return WHITE_BOX::youngGC;\n-        }\n-\n-        public Consumer<ReferenceInfo<Object[]>> getChecker() {\n-            return getCheckerImpl(false, false, true, false);\n-        }\n-\n-        @Override\n-        public List<String> shouldContain() {\n-            return Arrays.asList(GCTokens.WB_INITIATED_YOUNG_GC);\n-        }\n-\n-        @Override\n-        public List<String> shouldNotContain() {\n-            return Arrays.asList(GCTokens.WB_INITIATED_MIXED_GC, GCTokens.FULL_GC, GCTokens.WB_INITIATED_CMC,\n-                    GCTokens.CMC, GCTokens.YOUNG_GC);\n-        }\n-    },\n-\n-    FULL_GC {\n-        @Override\n-        public Runnable get() {\n-            return System::gc;\n-        }\n-\n-        public Consumer<ReferenceInfo<Object[]>> getChecker() {\n-            return getCheckerImpl(true, false, true, false);\n-        }\n-\n-        @Override\n-        public List<String> shouldContain() {\n-            return Arrays.asList(GCTokens.FULL_GC);\n-        }\n-\n-        @Override\n-        public List<String> shouldNotContain() {\n-            return Arrays.asList(GCTokens.WB_INITIATED_YOUNG_GC, GCTokens.WB_INITIATED_MIXED_GC,\n-                    GCTokens.WB_INITIATED_CMC, GCTokens.CMC, GCTokens.YOUNG_GC);\n-        }\n-    },\n-\n-    MIXED_GC {\n-        @Override\n-        public Runnable get() {\n-            return () -> {\n-                WHITE_BOX.concurrentGCAcquireControl();\n-                try {\n-                    WHITE_BOX.youngGC();\n-                    WHITE_BOX.youngGC();\n-                    WHITE_BOX.concurrentGCRunTo(WHITE_BOX.AFTER_MARKING_STARTED);\n-                    WHITE_BOX.concurrentGCRunToIdle();\n-                    WHITE_BOX.youngGC();\n-                    \/\/ Provoking Mixed GC\n-                    WHITE_BOX.youngGC();\/\/ second evacuation pause will be mixed\n-                } finally {\n-                    WHITE_BOX.concurrentGCReleaseControl();\n-                }\n-            };\n-        }\n-\n-        public Consumer<ReferenceInfo<Object[]>> getChecker() {\n-            return getCheckerImpl(true, false, true, false);\n-        }\n-\n-        @Override\n-        public List<String> shouldContain() {\n-            return Arrays.asList(GCTokens.WB_INITIATED_CMC);\n-        }\n-\n-        @Override\n-        public List<String> shouldNotContain() {\n-            return Arrays.asList(GCTokens.YOUNG_GC);\n-        }\n-    },\n-\n-    FULL_GC_MEMORY_PRESSURE {\n-        @Override\n-        public Runnable get() {\n-            return WHITE_BOX::fullGC;\n-        }\n-\n-        public Consumer<ReferenceInfo<Object[]>> getChecker() {\n-            return getCheckerImpl(true, true, true, true);\n-        }\n-\n-        @Override\n-        public List<String> shouldContain() {\n-            return Arrays.asList(GCTokens.FULL_GC_MEMORY_PRESSURE);\n-        }\n-\n-        @Override\n-        public List<String> shouldNotContain() {\n-            return Arrays.asList(GCTokens.WB_INITIATED_YOUNG_GC, GCTokens.WB_INITIATED_MIXED_GC,\n-                    GCTokens.WB_INITIATED_CMC, GCTokens.CMC, GCTokens.YOUNG_GC, GCTokens.FULL_GC);\n-        }\n-    };\n-\n-    protected String getErrorMessage(ReferenceInfo<Object[]> ref, boolean expectedNull, String gcType) {\n-        return String.format(\"Externally effectively %s referenced %shumongous object was%s deleted after %s\",\n-                (ref.softlyReachable ? \"soft\" : \"weak\"), (ref.effectiveHumongous ? \"\" : \"non-\"),\n-                (expectedNull ? \" not\" : \"\"), gcType);\n-    }\n-\n-    protected Consumer<ReferenceInfo<Object[]>> getCaseCheck(boolean expectedNull) {\n-        return expectedNull\n-                ? r -> Asserts.assertNull(r.reference.get(), getErrorMessage(r, true, name()))\n-                : r -> Asserts.assertNotNull(r.reference.get(), getErrorMessage(r, false, name()));\n-    }\n-\n-    protected Consumer<ReferenceInfo<Object[]>> getCheckerImpl(boolean weakH, boolean softH,\n-                                                               boolean weakS, boolean softS) {\n-        return new Checker(getCaseCheck(weakH), getCaseCheck(softH), getCaseCheck(weakS), getCaseCheck(softS));\n-    }\n-\n-    protected String getGcLogName(String prefix) {\n-        return prefix + \"_\" + name() + \".gc.log\";\n-    }\n-\n-    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-\n-    \/**\n-     * @return method to initiate GC\n-     *\/\n-    public abstract Runnable get();\n-\n-    \/**\n-     * @return checker for objects' states after GC\n-     *\/\n-    public abstract Consumer<ReferenceInfo<Object[]>> getChecker();\n-\n-    \/**\n-     * @return list of tokens that should be contained in gc log after gc of specified type\n-     *\/\n-    public abstract List<String> shouldContain();\n-\n-    \/**\n-     * @return list of tokens that should not be contained in gc log after gc of specified type\n-     *\/\n-    public abstract List<String> shouldNotContain();\n-\n-\n-    \/**\n-     * Checks object' state after gc\n-     * Contains 4 Consumers which are called depending on humongous\/non-humongous and\n-     * external weak\/soft referenced objects\n-     *\/\n-    private static class Checker implements Consumer<ReferenceInfo<Object[]>> {\n-        \/\/ 4 consumers with checks for (humongous \/simple objects)*(weak\/soft referenced)\n-        final Consumer<ReferenceInfo<Object[]>> weakHumongousCheck;\n-        final Consumer<ReferenceInfo<Object[]>> softHumongousCheck;\n-        final Consumer<ReferenceInfo<Object[]>> weakSimpleCheck;\n-        final Consumer<ReferenceInfo<Object[]>> softSimpleCheck;\n-\n-        public Checker(Consumer<ReferenceInfo<Object[]>> weakHumongousCheck,\n-                       Consumer<ReferenceInfo<Object[]>> softHumongousCheck,\n-                       Consumer<ReferenceInfo<Object[]>> weakSimpleCheck,\n-                       Consumer<ReferenceInfo<Object[]>> softSimpleCheck) {\n-            this.weakHumongousCheck = weakHumongousCheck;\n-            this.softHumongousCheck = softHumongousCheck;\n-            this.weakSimpleCheck = weakSimpleCheck;\n-            this.softSimpleCheck = softSimpleCheck;\n-        }\n-\n-        public void accept(ReferenceInfo<Object[]> ref) {\n-\n-            System.out.println(\"reference.get() returned \" + ref.reference.get());\n-            if (ref.effectiveHumongous && ref.softlyReachable) {\n-                System.out.println(\"soft and humongous\");\n-                softHumongousCheck.accept(ref);\n-            }\n-\n-            if (ref.effectiveHumongous && !ref.softlyReachable) {\n-                System.out.println(\"weak and humongous\");\n-                weakHumongousCheck.accept(ref);\n-\n-            }\n-\n-            if (!ref.effectiveHumongous && ref.softlyReachable) {\n-                System.out.println(\"soft and non-humongous\");\n-                softSimpleCheck.accept(ref);\n-            }\n-\n-            if (!ref.effectiveHumongous && !ref.softlyReachable) {\n-                System.out.println(\"weak and non-humongous\");\n-                weakSimpleCheck.accept(ref);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/objectGraphTest\/GC.java","additions":0,"deletions":288,"binary":false,"changes":288,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1.humongousObjects.objectGraphTest;\n-\n-\/**\n- * Contains tokens that could appear in gc log\n- *\/\n-public final class GCTokens {\n-    \/\/ Private c-tor to prevent instantiating\n-    private GCTokens() {\n-    }\n-\n-    public static final String WB_INITIATED_YOUNG_GC = \"Young (Normal) (WhiteBox Initiated Young GC)\";\n-    public static final String WB_INITIATED_MIXED_GC = \"Young (Mixed) (WhiteBox Initiated Young GC)\";\n-    public static final String WB_INITIATED_CMC = \"WhiteBox Initiated Run to Breakpoint\";\n-    public static final String FULL_GC = \"Full (System.gc())\";\n-    public static final String FULL_GC_MEMORY_PRESSURE = \"WhiteBox Initiated Full GC\";\n-    public static final String CMC = \"Concurrent Mark)\";\n-    public static final String YOUNG_GC = \"GC pause (young)\";\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/objectGraphTest\/GCTokens.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1.humongousObjects.objectGraphTest;\n-\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n-import java.util.function.Predicate;\n-\n-public class ObjectGraph {\n-\n-    private ObjectGraph() {\n-    }\n-\n-    public enum ReferenceType {\n-        NONE,\n-        WEAK,\n-        SOFT,\n-        STRONG;\n-    }\n-\n-    \/**\n-     * Performs operation on all nodes that are reachable from initial ones\n-     *\n-     * @param nodes     initial nodes\n-     * @param operation operation\n-     *\/\n-    public static void propagateTransitiveProperty(Set<Object[]> nodes, Consumer<Object[]> operation) {\n-        Deque<Object[]> roots = new ArrayDeque<>();\n-        nodes.stream().forEach(roots::push);\n-        ObjectGraph.enumerateAndMark(roots, operation);\n-    }\n-\n-    \/**\n-     * Connects graph's vertexes with single-directed (vertex -> neighbour) link\n-     *\n-     * @param vertex    who is connected\n-     * @param neighbour connected to whom\n-     *\/\n-    private static void connectVertexes(Object[] vertex, Object[] neighbour) {\n-\n-        \/\/ check if vertex array is full\n-        if (vertex[vertex.length - 1] != null) {\n-            throw new Error(\"Array is full and no connections could be added\");\n-        }\n-        int i = 0;\n-        while (vertex[i] != null) {\n-            ++i;\n-        }\n-        vertex[i] = neighbour;\n-    }\n-\n-\n-    \/**\n-     * Builds object graph using description from list of parsed nodes. Graph uses Object[] as nodes, first n elements\n-     * of array are links to connected nodes, others are null. Then runs visitors on generated graph\n-     *\n-     * @param parsedNodes             list of nodes' description\n-     * @param visitors                visitors that will visit each node of generated graph\n-     * @param humongousAllocationSize size of humongous node\n-     * @param simpleAllocationSize    size of simple (non-humongous) node\n-     * @return root reference to generated graph\n-     *\/\n-    public static Object[] generateObjectNodes(List<TestcaseData.FinalParsedNode> parsedNodes,\n-                                               Map<Predicate<TestcaseData.FinalParsedNode>,\n-                                                       BiConsumer<TestcaseData.FinalParsedNode, Object[][]>> visitors,\n-                                               int humongousAllocationSize, int simpleAllocationSize) {\n-\n-        Object[][] objectNodes = new Object[parsedNodes.size()][];\n-\n-        \/\/ Allocating nodes on Object[]\n-        for (int i = 0; i < parsedNodes.size(); ++i) {\n-            objectNodes[i] = new Object[(parsedNodes.get(i).isHumongous ?\n-                    humongousAllocationSize : simpleAllocationSize)];\n-        }\n-\n-        \/\/ Connecting nodes on allocated on Object[]\n-        for (int i = 0; i < parsedNodes.size(); ++i) {\n-            for (int j = 0; j < parsedNodes.get(i).getConnectedTo().size(); ++j) {\n-                connectVertexes(objectNodes[i], objectNodes[parsedNodes.get(i).getConnectedTo().get(j)]);\n-            }\n-        }\n-\n-        \/\/ Calling visitors\n-        visitors.entrySet()\n-                .stream()\n-                .forEach(\n-                        entry -> parsedNodes.stream()\n-                                .filter(parsedNode -> entry.getKey().test(parsedNode))\n-                                .forEach(node -> entry.getValue().accept(node, objectNodes))\n-                );\n-\n-        return objectNodes[0];\n-    }\n-\n-    \/**\n-     * Enumerates graph starting with provided vertexes. All vertexes that are reachable from the provided ones are\n-     * marked\n-     *\n-     * @param markedParents provided vertexes\n-     * @param markVertex    lambda which marks vertexes\n-     *\/\n-    public static void enumerateAndMark(Deque<Object[]> markedParents,\n-                                        Consumer<Object[]> markVertex) {\n-        Map<Object[], Boolean> isVisited = new HashMap<>();\n-        while (!markedParents.isEmpty()) {\n-            Object[] vertex = markedParents.pop();\n-            if (vertex == null || isVisited.containsKey(vertex)) {\n-                continue;\n-            }\n-            isVisited.put(vertex, true);\n-            markVertex.accept(vertex);\n-\n-            for (int i = 0; i < vertex.length; ++i) {\n-                if (vertex[i] == null) {\n-                    break;\n-                }\n-                markedParents.add((Object[]) vertex[i]);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/objectGraphTest\/ObjectGraph.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-The test checks that after different type of GC unreachable objects behave as expected:\n-\n-1. Young GC - weakly referenced non-humongous objects are collected, other objects are not collected.\n-\n-2. Full GC - weakly referenced non-humongous and humongous objects are collected, softly referenced non-humongous and\n-             humongous objects are not collected.\n-\n-3. Full GC with memory pressure - weakly and softly referenced non-humongous and humongous objects are collected.\n-\n-4. CMC -  weakly referenced non-humongous objects are collected, other objects are not collected since weak references\n-          from Young Gen is handled as strong during CMC.\n-\n-5. CMC_NO_SURV_ROOTS -  weakly referenced non-humongous and humongous objects are collected, softly referenced\n-                        non-humongous and humongous objects are not collected since we make 2 Young GC to promote all\n-                        weak references to Old Gen.\n-\n-6. Mixed GC - weakly referenced non-humongous and humongous objects are collected, softly referenced non-humongous and\n-              humongous objects are not collected.\n-\n-The test gets gc type as a command line argument.\n-Then the test allocates object graph in heap (currently testing scenarios are pre-generated and stored in\n-TestcaseData.getPregeneratedTestcases()) with TestObjectGraphAfterGC::allocateObjectGraph.\n-\n-Since we are testing humongous objects we need pretty unusual nodes - arrays of Object.\n-We need this since only large enough array could be Humongous object (in fact class with huge amount of fields is\n-humongous too but it's for other tests).\n-ObjectGraph class generates object graph with Object[] nodes. It also provides a way to collect\n-information about each node using \"visitor\" pattern.\n-\n-Using visitors we build Set of ReferenceInfo instances which contains the following information:\n-reference - external weak\/soft reference to graph's node\n-graphId and nodeId - graph's and node's ids - we need this for error handling\n-softlyReachable - is node effectively referenced by external soft reference. It could be when external\n-soft reference or when this node is reachable from node that exteranally referenced by soft reference\n-effectiveHumongous - if node behaves effectively humongous.  It could be when node is humongous\n-or when this node is reachable from humongous node.\n-\n-When we leave TestObjectGraphAfterGC::allocateObjectGraph we make graph reachable only with references from Set of\n-ReferenceInfo instances.\n-\n-We run specified gc and check that each instance of ReferenceInfo set behaves as expected.\n-Then we check that gc log file contains expected tokens and doesn't contain tokens that it should not contain.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/objectGraphTest\/README","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1.humongousObjects.objectGraphTest;\n-\n-import java.lang.ref.Reference;\n-\n-\/**\n- * Immutable structure that holds the following information about graph's node\n- * reference - weak\/soft reference to graph's node\n- * graphId and nodeId - graph's and node's ids - we need this for error handling\n- * softlyReachable - is node effectively referenced by external soft reference. It could be when external\n- * soft reference or when this node is reachable from node that externally referenced by soft reference\n- * effectiveHumongous - if node behaves effectively humongous.  It could be when node is humongous\n- * or when this node is reachable from humongous node.\n- *\n- * @param <T> - actual type of node\n- *\/\n-public class ReferenceInfo<T> {\n-    public final Reference<T> reference;\n-    public final String graphId;\n-    public final String nodeId;\n-    public final boolean softlyReachable;\n-    public final boolean effectiveHumongous;\n-\n-    public ReferenceInfo(Reference<T> reference, String graphId, String nodeId, boolean softlyReachable,\n-                         boolean effectiveHumongous) {\n-        this.reference = reference;\n-        this.graphId = graphId;\n-        this.nodeId = nodeId;\n-        this.softlyReachable = softlyReachable;\n-        this.effectiveHumongous = effectiveHumongous;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Node %s is effectively %shumongous and effectively %ssoft referenced\\n\"\n-                        + \"\\tReference type is %s and it points to %s\", nodeId,\n-                (effectiveHumongous ? \"\" : \"non-\"), (softlyReachable ? \"\" : \"non-\"),\n-                reference.getClass().getSimpleName(), reference.get());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/objectGraphTest\/ReferenceInfo.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,254 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1.humongousObjects.objectGraphTest;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.whitebox.WhiteBox;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.SoftReference;\n-import java.lang.ref.WeakReference;\n-import java.nio.file.Files;\n-import java.util.Map;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-\n-\/**\n- * @test TestObjectGraphAfterGC\n- * @summary Checks that objects' graph behave as expected after gc\n- * @requires vm.gc.G1\n- * @requires vm.opt.ExplicitGCInvokesConcurrent != true\n- * @library \/test\/lib \/\n- * @modules java.management java.base\/jdk.internal.misc\n- * @build jdk.test.whitebox.WhiteBox\n- *\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *\n- * @run main\/othervm -Xms200M -Xmx200M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- * -XX:+UnlockExperimentalVMOptions -XX:MaxGCPauseMillis=30000 -XX:G1MixedGCLiveThresholdPercent=100 -XX:G1HeapWastePercent=0\n- * -XX:G1HeapRegionSize=1M -Xlog:gc=info:file=TestObjectGraphAfterGC_MIXED_GC.gc.log -XX:MaxTenuringThreshold=1\n- * -XX:G1MixedGCCountTarget=1  -XX:G1OldCSetRegionThresholdPercent=100 -XX:SurvivorRatio=1 -XX:InitiatingHeapOccupancyPercent=0\n- * gc.g1.humongousObjects.objectGraphTest.TestObjectGraphAfterGC MIXED_GC\n- *\n- * @run main\/othervm -Xms200M -Xmx200M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- * -XX:G1HeapRegionSize=1M -Xlog:gc*=debug:file=TestObjectGraphAfterGC_YOUNG_GC.gc.log\n- * gc.g1.humongousObjects.objectGraphTest.TestObjectGraphAfterGC YOUNG_GC\n- *\n- * @run main\/othervm -Xms200M -Xmx200M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- * -XX:G1HeapRegionSize=1M -Xlog:gc=info:file=TestObjectGraphAfterGC_FULL_GC.gc.log\n- * gc.g1.humongousObjects.objectGraphTest.TestObjectGraphAfterGC FULL_GC\n- *\n- * @run main\/othervm -Xms200M -Xmx200M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- * -XX:G1HeapRegionSize=1M -Xlog:gc=info:file=TestObjectGraphAfterGC_FULL_GC_MEMORY_PRESSURE.gc.log\n- * gc.g1.humongousObjects.objectGraphTest.TestObjectGraphAfterGC FULL_GC_MEMORY_PRESSURE\n- *\n- * @run main\/othervm -Xms200M -Xmx200M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- * -XX:G1HeapRegionSize=1M -Xlog:gc=info:file=TestObjectGraphAfterGC_CMC.gc.log -XX:MaxTenuringThreshold=16\n- * gc.g1.humongousObjects.objectGraphTest.TestObjectGraphAfterGC CMC\n- *\n- * @run main\/othervm -Xms200M -Xmx200M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- * -XX:G1HeapRegionSize=1M -Xlog:gc=info:file=TestObjectGraphAfterGC_CMC_NO_SURV_ROOTS.gc.log -XX:MaxTenuringThreshold=1\n- * gc.g1.humongousObjects.objectGraphTest.TestObjectGraphAfterGC CMC_NO_SURV_ROOTS\n- *\n- *\/\n-\n-\/**\n- * Checks that objects' graph behave as expected after gc\n- * See README file for detailed info on test's logic\n- *\/\n-public class TestObjectGraphAfterGC {\n-\n-    private static final int simpleAllocationSize = 1024;\n-\n-    \/**\n-     * Entry point\n-     *\n-     * @param args - first argument - gc name\n-     *\/\n-    public static void main(String[] args) {\n-\n-        if (args.length < 1) {\n-            throw new Error(\"Expected gc name wasn't provided as command line argument\");\n-        }\n-\n-        GC gcType = GC.valueOf(args[0].toUpperCase());\n-\n-        System.out.println(\"Testing \" + gcType.name());\n-\n-        TestcaseData.getPregeneratedTestcases().stream().forEach(testcase -> {\n-            System.out.println(\"Testcase: \" + testcase);\n-\n-            try {\n-                TestObjectGraphAfterGC.doTesting(testcase, gcType.get(), gcType.getChecker(),\n-                        gcType.getGcLogName(TestObjectGraphAfterGC.class.getSimpleName()), gcType.shouldContain(),\n-                        gcType.shouldNotContain());\n-            } catch (IOException e) {\n-                throw new Error(\"Problems trying to find or open \" + TestObjectGraphAfterGC.class.getSimpleName()\n-                        + \".gc.log\", e);\n-            }\n-            System.out.println(\" Passed\");\n-        });\n-    }\n-\n-    \/**\n-     * Implements testing with 3 methods - allocateObjectGraph, checkResults and checkGCLog\n-     *\n-     * @param testcaseData     testcase in the following notation:\n-     *                         H - humongous node\n-     *                         S - non-humongous node\n-     *                         s - external soft reference\n-     *                         w - external weak reference\n-     *                         Hs->Sw - 1st node is humongous, externally soft referenced and strong references to\n-     *                         non-humongous node 2 which is externally weak referenced\n-     *                         H->1 - humongous node connects to the first node of chain\n-     * @param doGC             method that initiates gc\n-     * @param checker          consumer that checks node's state after gc and throws Error if it's wrong\n-     * @param gcLogName        name of gc log\n-     * @param shouldContain    list of tokens that should be contained in gc log\n-     * @param shouldNotContain list of tokens that should not be contained in gc log\n-     * @throws IOException if there are some issues with gc log\n-     *\/\n-    private static void doTesting(String testcaseData, Runnable doGC, Consumer<ReferenceInfo<Object[]>> checker,\n-                                  String gcLogName, List<String> shouldContain, List<String> shouldNotContain)\n-            throws IOException {\n-        Set<ReferenceInfo<Object[]>> nodeData = allocateObjectGraph(testcaseData);\n-        doGC.run();\n-        checkResults(nodeData, checker);\n-        checkGCLog(gcLogName, shouldContain, shouldNotContain);\n-    }\n-\n-    \/**\n-     * Allocates a number of objects of humongous and regular size and links then with strong references.\n-     * How many objects to create, their size and links between them is encoded in the given parameters.\n-     * As the result an object graph will be created.\n-     * For the testing purpose for each created object (a graph node) an extra ReferenceInfo object will be created.\n-     * The ReferenceInfo instances will contain either weak or soft reference to the graph node.\n-     *\n-     * @param testcaseData testcase in the\n-     *                     <p>\n-     *                     H - humongous node\n-     *                     S - non-humongous node\n-     *                     s - external soft reference\n-     *                     w - external weak reference\n-     *                     Hs->Sw - 1st node is humongous, externally soft referenced and strong references to\n-     *                     non-humongous node 2 which is externally weak referenced\n-     *                     H->1 - humongous node connects to the first node of chain\n-     * @return set of ReferenceInfo objects containing weak\/soft reference to the graph node and other data on how\n-     * objects should behave after gc\n-     *\/\n-    private static Set<ReferenceInfo<Object[]>> allocateObjectGraph(String testcaseData) {\n-        Map<Object[], String> nodeIds = new HashMap<>();\n-        Set<Object[]> humongousNodes = new HashSet<>();\n-        Set<Object[]> externalSoftReferenced = new HashSet<>();\n-        Set<Object[]> externalWeakReferenced = new HashSet<>();\n-\n-        Map<Predicate<TestcaseData.FinalParsedNode>, BiConsumer<TestcaseData.FinalParsedNode, Object[][]>> visitors\n-                = new HashMap<>();\n-\n-        visitors.put((parsedNode -> true),\n-                (parsedNode, objects) -> nodeIds.put(objects[Integer.valueOf(parsedNode.id)], parsedNode.id)\n-        );\n-\n-        visitors.put((parsedNode -> parsedNode.isHumongous),\n-                (parsedNode, objects) -> humongousNodes.add(objects[Integer.valueOf(parsedNode.id)])\n-        );\n-\n-        visitors.put(parsedNode -> parsedNode.getReferencesTypes().stream().\n-                        anyMatch(referenceType -> referenceType == ObjectGraph.ReferenceType.SOFT),\n-                (parsedNode, objects) -> externalSoftReferenced.add(objects[Integer.valueOf(parsedNode.id)])\n-        );\n-\n-        visitors.put(parsedNode -> parsedNode.getReferencesTypes().stream().\n-                        anyMatch(referenceType -> referenceType == ObjectGraph.ReferenceType.WEAK),\n-                (parsedNode, objects) -> externalWeakReferenced.add(objects[Integer.valueOf(parsedNode.id)])\n-        );\n-\n-        List<TestcaseData.FinalParsedNode> internalParsedNodes = TestcaseData.parse(testcaseData);\n-\n-        Object[] root = ObjectGraph.generateObjectNodes(internalParsedNodes, visitors,\n-                WhiteBox.getWhiteBox().g1RegionSize(), simpleAllocationSize);\n-\n-        ObjectGraph.propagateTransitiveProperty(humongousNodes, humongousNodes::add);\n-        Set<Object[]> effectiveSoftReferenced = new HashSet<>();\n-        ObjectGraph.propagateTransitiveProperty(externalSoftReferenced, effectiveSoftReferenced::add);\n-\n-        \/\/ Create external references\n-        ReferenceQueue<Object[]> referenceQueue = new ReferenceQueue<>();\n-        Set<Reference<Object[]>> externalRefs = new HashSet<>();\n-\n-        externalWeakReferenced.stream()\n-                .forEach(objects -> externalRefs.add(new WeakReference<>(objects, referenceQueue)));\n-        externalSoftReferenced.stream()\n-                .forEach(objects -> externalRefs.add(new SoftReference<>(objects, referenceQueue)));\n-\n-        return externalRefs.stream()\n-                .map(ref -> new ReferenceInfo<>(ref, testcaseData, nodeIds.get(ref.get()),\n-                        effectiveSoftReferenced.contains(ref.get()), humongousNodes.contains(ref.get())))\n-                .collect(Collectors.toSet());\n-\n-    }\n-\n-    \/**\n-     * Checks that object' state after gc is as expected\n-     *\n-     * @param nodeData array with information about nodes\n-     * @param checker  consumer that checks node's state after gc and throws Error if it's wrong\n-     *\/\n-    private static void checkResults(Set<ReferenceInfo<Object[]>> nodeData, Consumer<ReferenceInfo<Object[]>> checker) {\n-        nodeData.stream().forEach(checker::accept);\n-    }\n-\n-    \/**\n-     * Checks that gc log contains what we expected and does not contain what we didn't expect\n-     *\n-     * @param gcLogName        gc log name\n-     * @param shouldContain    list of tokens that should be contained in gc log\n-     * @param shouldNotContain list of tokens that should not be contained in gc log\n-     * @throws IOException if there are some issues with gc log\n-     *\/\n-    private static void checkGCLog(String gcLogName, List<String> shouldContain, List<String> shouldNotContain)\n-            throws IOException {\n-\n-        if (gcLogName == null) {\n-            return;\n-        }\n-        String gcLog = new String(Files.readAllBytes(new File(gcLogName).toPath()));\n-\n-        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(gcLog, \"\");\n-\n-        shouldContain.stream().forEach(outputAnalyzer::shouldContain);\n-        shouldNotContain.stream().forEach(outputAnalyzer::shouldNotContain);\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/objectGraphTest\/TestObjectGraphAfterGC.java","additions":0,"deletions":254,"binary":false,"changes":254,"status":"deleted"},{"patch":"@@ -1,206 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1.humongousObjects.objectGraphTest;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public final class TestcaseData {\n-    \/**\n-     * Temporary node description used during parsing\n-     *\/\n-    private static class InternalParsedNode {\n-        public String id;\n-        public final ArrayList<Integer> connectedTo = new ArrayList<>();\n-        public final ArrayList<Integer> connectedFrom = new ArrayList<>();\n-        public final List<ObjectGraph.ReferenceType> referencesTypes = new ArrayList<>();\n-        public boolean isHumongous;\n-    }\n-\n-    \/**\n-     * Immutable node description.\n-     * Contains:\n-     * Node id\n-     * Humongous flag\n-     * List of external references' types\n-     * List of nodes connected to\n-     *\/\n-    public static class FinalParsedNode {\n-        public final String id;\n-        public final boolean isHumongous;\n-        private final List<ObjectGraph.ReferenceType> referencesTypes;\n-        private final ArrayList<Integer> connectedTo;\n-\n-\n-        public FinalParsedNode(InternalParsedNode internalParsedNode) {\n-            referencesTypes = internalParsedNode.referencesTypes;\n-            connectedTo = internalParsedNode.connectedTo;\n-            id = internalParsedNode.id;\n-            isHumongous = internalParsedNode.isHumongous;\n-        }\n-\n-        public List<ObjectGraph.ReferenceType> getReferencesTypes() {\n-            return Collections.unmodifiableList(referencesTypes);\n-        }\n-\n-        public List<Integer> getConnectedTo() {\n-            return Collections.unmodifiableList(connectedTo);\n-        }\n-    }\n-\n-    \/**\n-     * @param testcaseDesc testcase in the following notation:\n-     *                     H - humongous node\n-     *                     S - non-humongous node\n-     *                     s - external soft reference\n-     *                     w - external weak reference\n-     *                     Hs->Sw - 1st node is humongous, externally soft referenced and strong references to non-humongous node 2 which is\n-     *                     externally weak referenced\n-     *                     H->1 - humongous node connects to the first node of chain\n-     * @return list of nodes description in FinalParsedNode structure\n-     *\/\n-    public static List<FinalParsedNode> parse(String testcaseDesc) {\n-        String[] nodes = testcaseDesc.split(\"-\");\n-        List<InternalParsedNode> internalParsedNodeList = new ArrayList<>();\n-\n-        for (int i = 0; i < nodes.length; ++i) {\n-            String node = nodes[i];\n-            InternalParsedNode nd;\n-            if (node.contains(\"1\")) {\n-                nd = internalParsedNodeList.get(0);\n-\n-            } else {\n-                nd = new InternalParsedNode();\n-                internalParsedNodeList.add(nd);\n-                nd.id = String.valueOf(i);\n-            }\n-\n-            if (node.startsWith(\">\")) {\n-                nd.connectedFrom.add(i - 1);\n-            }\n-            if (node.endsWith(\"<\")) {\n-                nd.connectedFrom.add(i + 1);\n-            }\n-            if (node.contains(\"w\")) {\n-                nd.referencesTypes.add(ObjectGraph.ReferenceType.WEAK);\n-            }\n-\n-            if (node.contains(\"s\")) {\n-                nd.referencesTypes.add(ObjectGraph.ReferenceType.SOFT);\n-            }\n-            if (node.contains(\"H\")) {\n-                nd.isHumongous = true;\n-            }\n-\n-            if (node.contains(\"S\")) {\n-                nd.isHumongous = false;\n-            }\n-        }\n-\n-        \/\/ we have connectedFrom but we need to get connectedTo\n-        for (int i = 0; i < internalParsedNodeList.size(); ++i) {\n-            for (Integer reference : internalParsedNodeList.get(i).connectedFrom) {\n-                internalParsedNodeList.get(reference).connectedTo.add(i);\n-            }\n-        }\n-\n-        List<FinalParsedNode> finalParsedNodes = internalParsedNodeList.stream().map(FinalParsedNode::new)\n-                .collect(Collectors.toList());\n-\n-        return finalParsedNodes;\n-    }\n-\n-    \/**\n-     * @return List of pregenerated testing cases\n-     *\/\n-    public static List<String> getPregeneratedTestcases() {\n-        return Arrays.asList(\n-                \"Hw\",\n-                \"Sw\",\n-                \"Sw->Hw\",\n-                \"Hw->Sw\",\n-                \"Sw<->Hw\",\n-                \"Sw<->Sw\",\n-                \"Hw->Sw->Sw\",\n-                \"Hw->Sw->Sw\",\n-                \"Sw->Hw->Sw\",\n-                \"Hw->Sw->Sw->1\",\n-                \"Sw->Hw->Sw->1\",\n-                \"Sw->Hw->Hw->1\",\n-                \"Sw<->Hw<->Hw->1\",\n-                \"Sw<->Hw<->Sw->1\",\n-                \"Sw->Hw<->Sw\",\n-                \"Hs\",\n-                \"Ss\",\n-                \"Ss->Hs\",\n-                \"Hs->Ss\",\n-                \"Ss<->Hs\",\n-                \"Ss<->Ss\",\n-                \"Hs->Ss->Ss\",\n-                \"Hs->Ss->Ss\",\n-                \"Ss->Hs->Ss\",\n-                \"Hs->Ss->Ss->1\",\n-                \"Ss->Hs->Ss->1\",\n-                \"Ss->Hs->Hs->1\",\n-                \"Ss<->Hs<->Hs->1\",\n-                \"Ss<->Hs<->Ss->1\",\n-                \"Ss->Hs<->Ss\",\n-                \"Ss->Hw\",\n-                \"Sw->Hs\",\n-                \"Hs->Sw\",\n-                \"Hw->Ss\",\n-                \"Ss<->Hw\",\n-                \"Sw<->Hs\",\n-                \"Ss<->Sw\",\n-                \"Sw<->Ss\",\n-                \"Hs->Sw->Sw\",\n-                \"Hw->Ss->Sw\",\n-                \"Hw->Sw->Ss\",\n-                \"Ss->Hw->Sw\",\n-                \"Sw->Hs->Sw\",\n-                \"Sw->Hw->Ss\",\n-                \"Hs->Sw->Sw->1\",\n-                \"Hw->Ss->Sw->1\",\n-                \"Hw->Sw->Ss->1\",\n-                \"Ss->Hw->Sw->1\",\n-                \"Ss->Hs->Sw->1\",\n-                \"Sw->Hw->Ss->1\",\n-                \"Ss->Hw->Hw->1\",\n-                \"Sw->Hs->Hw->1\",\n-                \"Sw->Hw->Hs->1\",\n-                \"Ss<->Hw<->Hw->1\",\n-                \"Sw<->Hs<->Hw->1\",\n-                \"Sw<->Hw<->Hs->1\",\n-                \"Ss<->Hw<->Sw->1\",\n-                \"Sw<->Hs<->Sw->1\",\n-                \"Sw<->Hw<->Ss->1\",\n-                \"Ss->Hw<->Sw\",\n-                \"Sw->Hs<->Sw\",\n-                \"Sw->Hw<->Ss\"\n-        );\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/objectGraphTest\/TestcaseData.java","additions":0,"deletions":206,"binary":false,"changes":206,"status":"deleted"}]}