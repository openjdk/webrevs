{"files":[{"patch":"@@ -36,0 +36,1 @@\n+  friend class ZTest;\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemoryManager.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/z\/zRangeRegistry.inline.hpp\"\n@@ -33,1 +34,1 @@\n-#include \"unittest.hpp\"\n+#include \"zunittest.hpp\"\n@@ -43,1 +44,1 @@\n-class ZForwardingTest : public Test {\n+class ZForwardingTest : public ZTest {\n@@ -49,20 +50,2 @@\n-  char*             _reserved;\n-  static size_t     _page_offset;\n-\n-  char* reserve_page_memory() {\n-    \/\/ Probe for a free 2MB region inside the usable address range.\n-    \/\/ Inspired by ZVirtualMemoryManager::reserve_contiguous.\n-    const size_t unused = ZAddressOffsetMax - ZGranuleSize;\n-    const size_t increment = MAX2(align_up(unused \/ 100, ZGranuleSize), ZGranuleSize);\n-\n-    for (uintptr_t start = 0; start + ZGranuleSize <= ZAddressOffsetMax; start += increment) {\n-      char* const reserved = os::attempt_reserve_memory_at((char*)ZAddressHeapBase + start, ZGranuleSize, mtTest);\n-      if (reserved != nullptr) {\n-        \/\/ Success\n-        return reserved;\n-      }\n-    }\n-\n-    \/\/ Failed\n-    return nullptr;\n-  }\n+  ZAddressReserver  _zaddress_reserver;\n+  zoffset           _page_offset;\n@@ -71,1 +54,5 @@\n-    ZGlobalsPointers::initialize();\n+    \/\/ Only run test on supported Windows versions\n+    if (!is_os_supported()) {\n+      GTEST_SKIP() << \"OS not supported\";\n+    }\n+\n@@ -87,13 +74,2 @@\n-    \/\/ Preconditions for reserve_free_granule()\n-    ASSERT_NE(ZAddressHeapBase, 0u);\n-    ASSERT_NE(ZAddressOffsetMax, 0u);\n-    ASSERT_NE(ZGranuleSize, 0u);\n-\n-    _reserved = nullptr;\n-\n-    \/\/ Find a suitable address for the testing page\n-    char* reserved = reserve_page_memory();\n-\n-    ASSERT_NE(reserved, nullptr) << \"Failed to reserve the page granule. Test needs tweaking\";\n-    ASSERT_GE(reserved, (char*)ZAddressHeapBase);\n-    ASSERT_LT(reserved, (char*)ZAddressHeapBase + ZAddressOffsetMax);\n+    _zaddress_reserver.SetUp(ZGranuleSize);\n+    _page_offset = _zaddress_reserver.registry()->peek_low_address();\n@@ -101,3 +77,3 @@\n-    _reserved = reserved;\n-\n-    os::commit_memory((char*)_reserved, ZGranuleSize, false \/* executable *\/);\n+    if (_page_offset == zoffset::invalid) {\n+      GTEST_SKIP() << \"Unable to reserve memory\";\n+    }\n@@ -105,1 +81,2 @@\n-    _page_offset = uintptr_t(_reserved) - ZAddressHeapBase;\n+    char* const addr = (char*)untype(ZOffset::address_unsafe(_page_offset));\n+    os::commit_memory(addr, ZGranuleSize, \/* executable *\/ false);\n@@ -109,0 +86,5 @@\n+    if (!is_os_supported()) {\n+      \/\/ Test skipped, nothing to cleanup\n+      return;\n+    }\n+\n@@ -113,3 +95,4 @@\n-    if (_reserved != nullptr) {\n-      os::uncommit_memory((char*)_reserved, ZGranuleSize, false \/* executable *\/);\n-      os::release_memory((char*)_reserved, ZGranuleSize);\n+\n+    if (_page_offset != zoffset::invalid) {\n+      char* const addr = (char*)untype(ZOffset::address_unsafe(_page_offset));\n+      os::uncommit_memory(addr, ZGranuleSize, false \/* executable *\/);\n@@ -117,0 +100,2 @@\n+\n+    _zaddress_reserver.TearDown();\n@@ -222,1 +207,1 @@\n-  static void test(void (*function)(ZForwarding*), uint32_t size) {\n+  void test(void (*function)(ZForwarding*), uint32_t size) {\n@@ -260,1 +245,1 @@\n-  static void test(void (*function)(ZForwarding*)) {\n+  void test(void (*function)(ZForwarding*)) {\n@@ -288,2 +273,0 @@\n-\n-size_t ZForwardingTest::_page_offset;\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zForwarding.cpp","additions":30,"deletions":47,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  static constexpr size_t ReservationSize = 32 * M;\n+  static constexpr size_t ReservationSize = 3 * ZGranuleSize;\n@@ -39,0 +39,1 @@\n+  ZAddressReserver        _zaddress_reserver;\n@@ -49,3 +50,8 @@\n-    _reserver = (ZVirtualMemoryReserver*)os::malloc(sizeof(ZVirtualMemoryManager), mtTest);\n-    _reserver = ::new (_reserver) ZVirtualMemoryReserver(ReservationSize);\n-    _registry = &_reserver->_registry;\n+    _zaddress_reserver.SetUp(ReservationSize);\n+    _reserver = _zaddress_reserver.reserver();\n+    _registry = _zaddress_reserver.registry();\n+\n+    if (_reserver->reserved() < ReservationSize || !_registry->is_contiguous()) {\n+      GTEST_SKIP() << \"Fixture failed to reserve adequate memory, reserved \"\n+          << (_reserver->reserved() >> ZGranuleSizeShift) << \" * ZGranuleSize\";\n+    }\n@@ -61,3 +67,3 @@\n-    _reserver->unreserve_all();\n-    _reserver->~ZVirtualMemoryReserver();\n-    os::free(_reserver);\n+    _registry = nullptr;\n+    _reserver = nullptr;\n+    _zaddress_reserver.TearDown();\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zMapper_windows.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  ZAddressReserver        _zaddress_reserver;\n@@ -69,3 +70,8 @@\n-    _reserver = (ZVirtualMemoryReserver*)os::malloc(sizeof(ZVirtualMemoryManager), mtTest);\n-    _reserver = ::new (_reserver) ZVirtualMemoryReserver(ReservationSize);\n-    _registry = &_reserver->_registry;\n+    _zaddress_reserver.SetUp(ReservationSize);\n+    _reserver = _zaddress_reserver.reserver();\n+    _registry = _zaddress_reserver.registry();\n+\n+    if (_reserver->reserved() < ReservationSize || !_registry->is_contiguous()) {\n+      GTEST_SKIP() << \"Fixture failed to reserve adequate memory, reserved \"\n+          << (_reserver->reserved() >> ZGranuleSizeShift) << \" * ZGranuleSize\";\n+    }\n@@ -80,4 +86,3 @@\n-    \/\/ Best-effort cleanup\n-    _reserver->unreserve_all();\n-    _reserver->~ZVirtualMemoryReserver();\n-    os::free(_reserver);\n+    _registry = nullptr;\n+    _reserver = nullptr;\n+    _zaddress_reserver.TearDown();\n@@ -115,5 +120,0 @@\n-    if (_reserver->reserved() < 4 * ZGranuleSize || !_registry->is_contiguous()) {\n-      GTEST_SKIP() << \"Fixture failed to reserve adequate memory, reserved \"\n-          << (_reserver->reserved() >> ZGranuleSizeShift) << \" * ZGranuleSize\";\n-    }\n-\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zVirtualMemoryManager.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/z\/zVirtualMemoryManager.hpp\"\n@@ -63,0 +64,44 @@\n+public:\n+  class ZAddressReserver {\n+    ZVirtualMemoryReserver* _reserver;\n+    bool _active;\n+\n+    public:\n+      ZAddressReserver()\n+        : _reserver(nullptr),\n+          _active(false) {}\n+\n+      ~ZAddressReserver() {\n+        GTEST_EXPECT_FALSE(_active) << \"ZAddressReserver deconstructed without calling TearDown\";\n+      }\n+\n+      void SetUp(size_t reservation_size) {\n+        GTEST_EXPECT_TRUE(ZArguments::is_os_supported()) << \"Should not use SetUp on unsupported systems\";\n+        GTEST_EXPECT_FALSE(_active) << \"SetUp called twice without a TearDown\";\n+        _active = true;\n+\n+        _reserver = (ZVirtualMemoryReserver*)os::malloc(sizeof(ZVirtualMemoryManager), mtTest);\n+        _reserver = ::new (_reserver) ZVirtualMemoryReserver(reservation_size);\n+      }\n+\n+      void TearDown() {\n+        GTEST_EXPECT_TRUE(_active) << \"TearDown called without a preceding SetUp\";\n+        _active = false;\n+\n+        \/\/ Best-effort cleanup\n+        _reserver->unreserve_all();\n+        _reserver->~ZVirtualMemoryReserver();\n+        os::free(_reserver);\n+      }\n+\n+      ZVirtualMemoryReserver* reserver() {\n+        GTEST_EXPECT_TRUE(_active) << \"Should only use HeapReserver while active\";\n+        return _reserver;\n+      }\n+\n+      ZVirtualMemoryRegistry* registry() {\n+        GTEST_EXPECT_TRUE(_active) << \"Should only use HeapReserver while active\";\n+        return &_reserver->_registry;\n+      }\n+  };\n+\n","filename":"test\/hotspot\/gtest\/gc\/z\/zunittest.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"}]}