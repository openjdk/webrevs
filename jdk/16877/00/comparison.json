{"files":[{"patch":"@@ -493,0 +493,5 @@\n+  \/\/ Return the uncommon trap If projection of this Parse Predicate.\n+  ParsePredicateUncommonProj* uncommon_proj() const {\n+    return proj_out(0)->as_IfFalse();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,2 +102,2 @@\n-IfProjNode* PhaseIdealLoop::create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n-                                                        Deoptimization::DeoptReason reason,\n+IfTrueNode* PhaseIdealLoop::create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_success_proj,\n+                                                        Node* new_entry, const Deoptimization::DeoptReason reason,\n@@ -105,6 +105,4 @@\n-  assert(parse_predicate_proj->is_uncommon_trap_if_pattern(reason), \"must be a uct if pattern!\");\n-  ParsePredicateNode* parse_predicate = parse_predicate_proj->in(0)->as_ParsePredicate();\n-\n-  ProjNode* uncommon_proj = parse_predicate->proj_out(false);\n-  Node* uct_region = uncommon_proj->unique_ctrl_out();\n-  assert(uct_region->is_Region() || uct_region->is_Call(), \"must be a region or call uct\");\n+  assert(parse_predicate_success_proj->is_uncommon_trap_if_pattern(reason), \"must be a uct if pattern!\");\n+  ParsePredicateNode* parse_predicate = parse_predicate_success_proj->in(0)->as_ParsePredicate();\n+  ParsePredicateUncommonProj* uncommon_proj = parse_predicate->uncommon_proj();\n+  Node* uncommon_trap = parse_predicate->uncommon_trap();\n@@ -113,3 +111,3 @@\n-  if (!uct_region->is_Region()) { \/\/ create a region to guard the call\n-    assert(uct_region->is_Call(), \"must be call uct\");\n-    CallNode* call = uct_region->as_Call();\n+  if (!uncommon_trap->is_Region()) { \/\/ create a region to guard the call\n+    assert(uncommon_trap->is_Call(), \"must be call uct\");\n+    CallNode* call = uncommon_trap->as_Call();\n@@ -117,1 +115,1 @@\n-    uct_region = new RegionNode(1);\n+    uncommon_trap = new RegionNode(1);\n@@ -119,1 +117,1 @@\n-    uncommon_proj = uncommon_proj->clone()->as_Proj();\n+    uncommon_proj = uncommon_proj->clone()->as_IfFalse();\n@@ -121,3 +119,3 @@\n-    uct_region->add_req(uncommon_proj);\n-    register_control(uct_region, loop, uncommon_proj);\n-    _igvn.replace_input_of(call, 0, uct_region);\n+    uncommon_trap->add_req(uncommon_proj);\n+    register_control(uncommon_trap, loop, uncommon_proj);\n+    _igvn.replace_input_of(call, 0, uncommon_trap);\n@@ -126,1 +124,1 @@\n-      set_idom(call, uct_region, dom_depth(uct_region));\n+      set_idom(call, uncommon_trap, dom_depth(uncommon_trap));\n@@ -130,1 +128,1 @@\n-    lazy_replace(uncommon_proj_orig, uct_region);\n+    lazy_replace(uncommon_proj_orig, uncommon_trap);\n@@ -133,3 +131,3 @@\n-    for (; proj_index < uct_region->req(); proj_index++)\n-      if (uct_region->in(proj_index) == uncommon_proj) break;\n-    assert(proj_index < uct_region->req(), \"sanity\");\n+    for (; proj_index < uncommon_trap->req(); proj_index++)\n+      if (uncommon_trap->in(proj_index) == uncommon_proj) break;\n+    assert(proj_index < uncommon_trap->req(), \"sanity\");\n@@ -160,2 +158,3 @@\n-  IfProjNode* if_cont = new IfTrueNode(new_iff);\n-  IfProjNode* if_uct  = new IfFalseNode(new_iff);\n+\n+  IfTrueNode* if_cont = new IfTrueNode(new_iff);\n+  IfFalseNode* if_uct = new IfFalseNode(new_iff);\n@@ -164,1 +163,1 @@\n-  register_control(if_uct, get_loop(uct_region), new_iff);\n+  register_control(if_uct, get_loop(uncommon_trap), new_iff);\n@@ -166,1 +165,1 @@\n-  _igvn.add_input_to(uct_region, if_uct);\n+  _igvn.add_input_to(uncommon_trap, if_uct);\n@@ -170,1 +169,1 @@\n-  assert(uct_region->in(uct_region->req() - 1) == if_uct, \"new edge should be last\");\n+  assert(uncommon_trap->in(uncommon_trap->req() - 1) == if_uct, \"new edge should be last\");\n@@ -172,2 +171,2 @@\n-  for (DUIterator_Fast imax, i = uct_region->fast_outs(imax); i < imax; i++) {\n-    Node* use = uct_region->fast_out(i);\n+  for (DUIterator_Fast imax, i = uncommon_trap->fast_outs(imax); i < imax; i++) {\n+    Node* use = uncommon_trap->fast_out(i);\n@@ -175,1 +174,1 @@\n-      assert(use->in(0) == uct_region, \"\");\n+      assert(use->in(0) == uncommon_trap, \"\");\n@@ -196,1 +195,1 @@\n-  assert(!has_phi || uct_region->req() > 3, \"no phis when region is created\");\n+  assert(!has_phi || uncommon_trap->req() > 3, \"no phis when region is created\");\n@@ -208,1 +207,1 @@\n-    Node* ridom = idom(uct_region);\n+    Node* ridom = idom(uncommon_trap);\n@@ -210,1 +209,1 @@\n-    set_idom(uct_region, nrdom, dom_depth(uct_region));\n+    set_idom(uncommon_trap, nrdom, dom_depth(uncommon_trap));\n@@ -213,1 +212,1 @@\n-  return if_cont->as_IfProj();\n+  return if_cont;\n@@ -399,1 +398,5 @@\n-  Node* bol = create_bool_from_template_assertion_predicate(iff, nullptr, nullptr, parse_predicate_proj);\n+  Node* opaque4_node = iff->in(1);\n+  TemplateAssertionPredicateBool template_assertion_predicate_bool(opaque4_node->in(1));\n+  BoolNode* bol = template_assertion_predicate_bool.clone(parse_predicate_proj, this);\n+  opaque4_node = clone_and_register(opaque4_node, parse_predicate_proj);\n+  _igvn.replace_input_of(opaque4_node, 1, bol);\n@@ -401,1 +404,1 @@\n-  _igvn.replace_input_of(if_proj->in(0), 1, bol);\n+  _igvn.replace_input_of(if_proj->in(0), 1, opaque4_node);\n@@ -785,2 +788,2 @@\n-BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init,\n-                                       Node* limit, jint stride, Node* range, bool upper, bool& overflow) {\n+BoolNode* PhaseIdealLoop::rc_predicate(Node* ctrl, const int scale, Node* offset, Node* init, Node* limit,\n+                                       const jint stride, Node* range, const bool upper, bool& overflow) {\n@@ -1188,1 +1191,1 @@\n-    BoolNode* new_predicate_bol = invar.clone(bol, ctrl)->as_Bool();\n+    BoolNode* hoisted_check_predicate_bool = invar.clone(bol, ctrl)->as_Bool();\n@@ -1193,2 +1196,3 @@\n-      new_predicate_bol = new BoolNode(new_predicate_bol->in(1), new_predicate_bol->_test.negate());\n-      register_new_node(new_predicate_bol, ctrl);\n+      hoisted_check_predicate_bool = new BoolNode(hoisted_check_predicate_bool->in(1),\n+                                                  hoisted_check_predicate_bool->_test.negate());\n+      register_new_node(hoisted_check_predicate_bool, ctrl);\n@@ -1199,1 +1203,1 @@\n-    new_predicate_iff->set_req(1, new_predicate_bol);\n+    new_predicate_iff->set_req(1, hoisted_check_predicate_bool);\n@@ -1238,1 +1242,2 @@\n-    Node* ctrl = parse_predicate_proj->in(0)->as_If()->in(0);\n+    ParsePredicateNode* parse_predicate = parse_predicate_proj->in(0)->as_ParsePredicate();\n+    Node* ctrl = parse_predicate->in(0);\n@@ -1247,1 +1252,1 @@\n-    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n+    BoolNode* lower_bound_bol = rc_predicate(ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n@@ -1254,1 +1259,3 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %d\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) {\n+      tty->print_cr(\"lower bound check if: %d\", lower_bound_iff->_idx);\n+    }\n@@ -1257,2 +1264,1 @@\n-    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true,\n-                                             overflow);\n+    BoolNode* upper_bound_bol = rc_predicate(lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);\n@@ -1265,1 +1271,3 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %d\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) {\n+      tty->print_cr(\"upper bound check if: %d\", upper_bound_iff->_idx);\n+    }\n@@ -1307,1 +1315,1 @@\n-  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n+  BoolNode* bol = rc_predicate(upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n@@ -1330,1 +1338,1 @@\n-  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n+  bol = rc_predicate(new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n@@ -1353,4 +1361,0 @@\n-  if (head->is_OuterStripMinedLoop()) {\n-    return false;\n-  }\n-\n@@ -1527,1 +1531,1 @@\n-bool IdealLoopTree::loop_predication( PhaseIdealLoop *phase) {\n+bool IdealLoopTree::loop_predication(PhaseIdealLoop* phase) {\n@@ -1534,1 +1538,1 @@\n-  \/\/ self\n+  \/\/ Self\n@@ -1539,1 +1543,2 @@\n-  if (_next) { \/\/sibling\n+  \/\/ Sibling\n+  if (_next) {\n@@ -1547,1 +1552,5 @@\n-  return _head->is_Loop() && !_irreducible && !tail()->is_top();\n+  return !_head->is_Root() &&\n+         _head->is_Loop() &&\n+         !_head->is_OuterStripMinedLoop() &&\n+         !_irreducible &&\n+         !tail()->is_top();\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":66,"deletions":57,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -1388,34 +1388,0 @@\n-\/\/ Is 'n' a node that can be found on the input chain of a Template Assertion Predicate bool (i.e. between a Template\n-\/\/ Assertion Predicate If node and the OpaqueLoop* nodes)?\n-static bool is_part_of_template_assertion_predicate_bool(Node* n) {\n-  int op = n->Opcode();\n-  return (n->is_Bool() ||\n-          n->is_Cmp() ||\n-          op == Op_AndL ||\n-          op == Op_OrL ||\n-          op == Op_RShiftL ||\n-          op == Op_LShiftL ||\n-          op == Op_LShiftI ||\n-          op == Op_AddL ||\n-          op == Op_AddI ||\n-          op == Op_MulL ||\n-          op == Op_MulI ||\n-          op == Op_SubL ||\n-          op == Op_SubI ||\n-          op == Op_ConvI2L ||\n-          op == Op_CastII);\n-}\n-\n-bool PhaseIdealLoop::subgraph_has_opaque(Node* n) {\n-  if (n->Opcode() == Op_OpaqueLoopInit || n->Opcode() == Op_OpaqueLoopStride) {\n-    return true;\n-  }\n-  if (!is_part_of_template_assertion_predicate_bool(n)) {\n-    return false;\n-  }\n-  uint init;\n-  uint stride;\n-  count_opaque_loop_nodes(n, init, stride);\n-  return init != 0 || stride != 0;\n-}\n-\n@@ -1465,55 +1431,5 @@\n-    if (is_part_of_template_assertion_predicate_bool(n)) {\n-      for (uint j = 1; j < n->req(); j++) {\n-        Node* m = n->in(j);\n-        if (m != nullptr) {\n-          wq.push(m);\n-        }\n-      }\n-      continue;\n-    }\n-    if (n->Opcode() == Op_OpaqueLoopInit) {\n-      init++;\n-    } else if (n->Opcode() == Op_OpaqueLoopStride) {\n-      stride++;\n-    }\n-  }\n-}\n-\n-\/\/ Create a new Bool node from the provided Template Assertion Predicate.\n-\/\/ Unswitched loop: new_init and new_stride are both null. Clone OpaqueLoopInit and OpaqueLoopStride.\n-\/\/ Otherwise: Replace found OpaqueLoop* nodes with new_init and new_stride, respectively.\n-Node* PhaseIdealLoop::create_bool_from_template_assertion_predicate(Node* template_assertion_predicate, Node* new_init,\n-                                                                    Node* new_stride, Node* control) {\n-  Node_Stack to_clone(2);\n-  Node* opaque4 = template_assertion_predicate->in(1);\n-  assert(opaque4->Opcode() == Op_Opaque4, \"must be Opaque4\");\n-  to_clone.push(opaque4, 1);\n-  uint current = C->unique();\n-  Node* result = nullptr;\n-  bool is_unswitched_loop = new_init == nullptr && new_stride == nullptr;\n-  assert(new_init != nullptr || is_unswitched_loop, \"new_init must be set when new_stride is non-null\");\n-  \/\/ Look for the opaque node to replace with the new value\n-  \/\/ and clone everything in between. We keep the Opaque4 node\n-  \/\/ so the duplicated predicates are eliminated once loop\n-  \/\/ opts are over: they are here only to keep the IR graph\n-  \/\/ consistent.\n-  do {\n-    Node* n = to_clone.node();\n-    uint i = to_clone.index();\n-    Node* m = n->in(i);\n-    if (is_part_of_template_assertion_predicate_bool(m)) {\n-      to_clone.push(m, 1);\n-      continue;\n-    }\n-    if (m->is_Opaque1()) {\n-      if (n->_idx < current) {\n-        n = n->clone();\n-        register_new_node(n, control);\n-      }\n-      int op = m->Opcode();\n-      if (op == Op_OpaqueLoopInit) {\n-        if (is_unswitched_loop && m->_idx < current && new_init == nullptr) {\n-          new_init = m->clone();\n-          register_new_node(new_init, control);\n-        }\n-        n->set_req(i, new_init);\n+    if (TemplateAssertionPredicateBool::could_be_part(n)) {\n+      if (n->Opcode() == Op_OpaqueLoopInit) {\n+        init++;\n+      } else if (n->Opcode() == Op_OpaqueLoopStride) {\n+        stride++;\n@@ -1521,31 +1437,5 @@\n-        assert(op == Op_OpaqueLoopStride, \"unexpected opaque node\");\n-        if (is_unswitched_loop && m->_idx < current && new_stride == nullptr) {\n-          new_stride = m->clone();\n-          register_new_node(new_stride, control);\n-        }\n-        if (new_stride != nullptr) {\n-          n->set_req(i, new_stride);\n-        }\n-      }\n-      to_clone.set_node(n);\n-    }\n-    while (true) {\n-      Node* cur = to_clone.node();\n-      uint j = to_clone.index();\n-      if (j+1 < cur->req()) {\n-        to_clone.set_index(j+1);\n-        break;\n-      }\n-      to_clone.pop();\n-      if (to_clone.size() == 0) {\n-        result = cur;\n-        break;\n-      }\n-      Node* next = to_clone.node();\n-      j = to_clone.index();\n-      if (next->in(j) != cur) {\n-        assert(cur->_idx >= current || next->in(j)->Opcode() == Op_Opaque1, \"new node or Opaque1 being replaced\");\n-        if (next->_idx < current) {\n-          next = next->clone();\n-          register_new_node(next, control);\n-          to_clone.set_node(next);\n+        for (uint j = 1; j < n->req(); j++) {\n+          Node* m = n->in(j);\n+          if (m != nullptr) {\n+            wq.push(m);\n+          }\n@@ -1553,1 +1443,0 @@\n-        next->set_req(j, cur);\n@@ -1556,4 +1445,1 @@\n-  } while (result == nullptr);\n-  assert(result->_idx >= current, \"new node expected\");\n-  assert(!is_unswitched_loop || new_init != nullptr, \"new_init must always be found and cloned\");\n-  return result;\n+  }\n@@ -1567,1 +1453,11 @@\n-  Node* result = create_bool_from_template_assertion_predicate(iff, new_init, new_stride, control);\n+  Node* opaque4_node = iff->in(1);\n+  TemplateAssertionPredicateBool template_assertion_predicate_bool(opaque4_node->in(1));\n+  BoolNode* new_bool;\n+  if (new_stride == nullptr) {\n+    new_bool = template_assertion_predicate_bool.clone_and_replace_init(control, new_init, this);\n+  } else {\n+    new_bool = template_assertion_predicate_bool.clone_and_replace_opaque_loop_nodes(control, new_init, new_stride, this);\n+  }\n+  opaque4_node = clone_and_register(opaque4_node, control);\n+  _igvn.replace_input_of(opaque4_node, 1, new_bool);\n+\n@@ -1571,1 +1467,1 @@\n-  new_iff->set_req(1, result);\n+  new_iff->set_req(1, opaque4_node);\n@@ -2819,1 +2715,1 @@\n-  BoolNode* bol = rc_predicate(loop, ctrl, scale_con, offset, value, nullptr, stride_con,\n+  BoolNode* bol = rc_predicate(ctrl, scale_con, offset, value, nullptr, stride_con,\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":24,"deletions":128,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -86,3 +86,3 @@\n-\/\/------------------------------find_unswitching_candidate-----------------------------\n-\/\/ Find candidate \"if\" for unswitching\n-IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree *loop) const {\n+\/\/ Find invariant test in loop body that does not exit the loop. If multiple are found, we pick the first one in the\n+\/\/ loop body. Return the candidate \"if\" for unswitching.\n+IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree* loop) const {\n@@ -91,2 +91,2 @@\n-  LoopNode *head = loop->_head->as_Loop();\n-  IfNode* unswitch_iff = nullptr;\n+  LoopNode* head = loop->_head->as_Loop();\n+  IfNode* unswitching_candidate = nullptr;\n@@ -105,1 +105,1 @@\n-              unswitch_iff = iff;\n+              unswitching_candidate = iff;\n@@ -113,1 +113,1 @@\n-  return unswitch_iff;\n+  return unswitching_candidate;\n@@ -116,5 +116,8 @@\n-\/\/------------------------------do_unswitching-----------------------------\n-\/\/ Clone loop with an invariant test (that does not exit) and\n-\/\/ insert a clone of the test that selects which version to\n-\/\/ execute.\n-void PhaseIdealLoop::do_unswitching(IdealLoopTree *loop, Node_List &old_new) {\n+\/\/ Perform Loop Unswitching on the loop containing an invariant test that does not exit the loop. The loop is cloned\n+\/\/ such that we have two identical loops next to each other - a fast and a slow loop. We modify the loops as follows:\n+\/\/ - Fast loop: We remove the invariant test together with the false path and only leave the true path in the loop.\n+\/\/ - Slow loop: We remove the invariant test together with the true path and only leave the false path in the loop.\n+\/\/\n+\/\/ We insert a new If node before both loops that performs the removed invariant test. If the test is true at runtime,\n+\/\/ we select the fast loop. Otherwise, we select the slow loop.\n+void PhaseIdealLoop::do_unswitching(IdealLoopTree* loop, Node_List& old_new) {\n@@ -126,3 +129,2 @@\n-  \/\/ Find first invariant test that doesn't exit the loop\n-  IfNode* unswitch_iff = find_unswitching_candidate((const IdealLoopTree *)loop);\n-  assert(unswitch_iff != nullptr, \"should be at least one\");\n+  IfNode* unswitching_candidate = find_unswitching_candidate(loop);\n+  assert(unswitching_candidate != nullptr, \"should be at least one\");\n@@ -142,3 +144,2 @@\n-  IfNode* invar_iff = create_slow_version_of_loop(loop, old_new, unswitch_iff, CloneIncludesStripMined);\n-  ProjNode* proj_true = invar_iff->proj_out(1);\n-  verify_fast_loop(head, proj_true);\n+  IfNode* loop_selector = create_slow_version_of_loop(loop, old_new, unswitching_candidate);\n+  IfTrueNode* loop_selector_fast_loop_proj = loop_selector->proj_out(1)->as_IfTrue();\n@@ -156,2 +157,2 @@\n-  for (DUIterator_Fast imax, i = unswitch_iff->fast_outs(imax); i < imax; i++) {\n-    ProjNode* proj= unswitch_iff->fast_out(i)->as_Proj();\n+  for (DUIterator_Fast imax, i = unswitching_candidate->fast_outs(imax); i < imax; i++) {\n+    IfProjNode* proj = unswitching_candidate->fast_out(i)->as_IfProj();\n@@ -165,1 +166,1 @@\n-    ProjNode* invar_proj = invar_iff->proj_out(proj->_con)->as_Proj();\n+    IfProjNode* loop_selector_if_proj = loop_selector->proj_out(proj->_con)->as_IfProj();\n@@ -169,1 +170,1 @@\n-      nuse->set_req(0, invar_proj);\n+      nuse->set_req(0, loop_selector_if_proj);\n@@ -171,1 +172,1 @@\n-      register_new_node(nuse, invar_proj);\n+      register_new_node(nuse, loop_selector_if_proj);\n@@ -179,2 +180,2 @@\n-  _igvn.rehash_node_delayed(unswitch_iff);\n-  dominated_by(proj_true->as_IfProj(), unswitch_iff, false, false);\n+  _igvn.rehash_node_delayed(unswitching_candidate);\n+  dominated_by(loop_selector_fast_loop_proj->as_IfProj(), unswitching_candidate, false, false);\n@@ -182,4 +183,4 @@\n-  IfNode* unswitch_iff_clone = old_new[unswitch_iff->_idx]->as_If();\n-  _igvn.rehash_node_delayed(unswitch_iff_clone);\n-  ProjNode* proj_false = invar_iff->proj_out(0);\n-  dominated_by(proj_false->as_IfProj(), unswitch_iff_clone, false, false);\n+  IfNode* unswitching_candidate_clone = old_new[unswitching_candidate->_idx]->as_If();\n+  _igvn.rehash_node_delayed(unswitching_candidate_clone);\n+  IfFalseNode* loop_selector_slow_loop_proj = loop_selector->proj_out(0)->as_IfFalse();\n+  dominated_by(loop_selector_slow_loop_proj, unswitching_candidate_clone, false, false);\n@@ -198,2 +199,2 @@\n-                  head->_idx,                unswitch_iff->_idx,\n-                  old_new[head->_idx]->_idx, unswitch_iff_clone->_idx);\n+                  head->_idx, unswitching_candidate->_idx,\n+                  old_new[head->_idx]->_idx, unswitching_candidate_clone->_idx);\n@@ -206,1 +207,1 @@\n-bool PhaseIdealLoop::has_control_dependencies_from_predicates(LoopNode* head) const {\n+bool PhaseIdealLoop::has_control_dependencies_from_predicates(LoopNode* head) {\n@@ -221,42 +222,23 @@\n-\/\/-------------------------create_slow_version_of_loop------------------------\n-\/\/ Create a slow version of the loop by cloning the loop\n-\/\/ and inserting an if to select fast-slow versions.\n-\/\/ Return the inserted if.\n-IfNode* PhaseIdealLoop::create_slow_version_of_loop(IdealLoopTree *loop,\n-                                                      Node_List &old_new,\n-                                                      IfNode* unswitch_iff,\n-                                                      CloneLoopMode mode) {\n-  LoopNode* head  = loop->_head->as_Loop();\n-  Node*     entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n-  _igvn.rehash_node_delayed(entry);\n-  IdealLoopTree* outer_loop = loop->_parent;\n-\n-  head->verify_strip_mined(1);\n-\n-  \/\/ Add test to new \"if\" outside of loop\n-  Node *bol   = unswitch_iff->in(1)->as_Bool();\n-  IfNode* iff = (unswitch_iff->Opcode() == Op_RangeCheck) ? new RangeCheckNode(entry, bol, unswitch_iff->_prob, unswitch_iff->_fcnt) :\n-    new IfNode(entry, bol, unswitch_iff->_prob, unswitch_iff->_fcnt);\n-  register_node(iff, outer_loop, entry, dom_depth(entry));\n-  IfProjNode* iffast = new IfTrueNode(iff);\n-  register_node(iffast, outer_loop, iff, dom_depth(iff));\n-  IfProjNode* ifslow = new IfFalseNode(iff);\n-  register_node(ifslow, outer_loop, iff, dom_depth(iff));\n-\n-  \/\/ Clone the loop body.  The clone becomes the slow loop.  The\n-  \/\/ original pre-header will (illegally) have 3 control users\n-  \/\/ (old & new loops & new if).\n-  clone_loop(loop, old_new, dom_depth(head->skip_strip_mined()), mode, iff);\n-  assert(old_new[head->_idx]->is_Loop(), \"\" );\n-\n-  \/\/ Fast (true) and Slow (false) control\n-  IfProjNode* iffast_pred = iffast;\n-  IfProjNode* ifslow_pred = ifslow;\n-  clone_parse_and_assertion_predicates_to_unswitched_loop(loop, old_new, iffast_pred, ifslow_pred);\n-\n-  Node* l = head->skip_strip_mined();\n-  _igvn.replace_input_of(l, LoopNode::EntryControl, iffast_pred);\n-  set_idom(l, iffast_pred, dom_depth(l));\n-  LoopNode* slow_l = old_new[head->_idx]->as_Loop()->skip_strip_mined();\n-  _igvn.replace_input_of(slow_l, LoopNode::EntryControl, ifslow_pred);\n-  set_idom(slow_l, ifslow_pred, dom_depth(l));\n+\/\/ Class to create an If node that selects if the fast or the slow loop should be executed at runtime.\n+class UnswitchedLoopSelector {\n+  PhaseIdealLoop* _phase;\n+  IdealLoopTree* _outer_loop;\n+  Node* _original_loop_entry;\n+  uint _dom_depth;\n+  IfNode* _selector;\n+  IfTrueNode* _fast_loop_proj;\n+  IfFalseNode* _slow_loop_proj;\n+\n+  IfNode* create_selector_if(IdealLoopTree* loop, IfNode* unswitch_if_candidate) {\n+    const uint dom_depth = _phase->dom_depth(_original_loop_entry);\n+    _phase->igvn().rehash_node_delayed(_original_loop_entry);\n+    Node* unswitching_candidate_bool = unswitch_if_candidate->in(1)->as_Bool();\n+    IfNode* selector_if =\n+        (unswitch_if_candidate->Opcode() == Op_RangeCheck) ?\n+        new RangeCheckNode(_original_loop_entry, unswitching_candidate_bool, unswitch_if_candidate->_prob,\n+                           unswitch_if_candidate->_fcnt) :\n+        new IfNode(_original_loop_entry, unswitching_candidate_bool, unswitch_if_candidate->_prob,\n+                   unswitch_if_candidate->_fcnt);\n+    _phase->register_node(selector_if, _outer_loop, _original_loop_entry, dom_depth);\n+    return selector_if;\n+  }\n@@ -264,1 +246,5 @@\n-  recompute_dom_depth();\n+  IfTrueNode* create_fast_loop_proj() {\n+    IfTrueNode* fast_loop_proj = new IfTrueNode(_selector);\n+    _phase->register_node(fast_loop_proj, _outer_loop, _selector, _dom_depth);\n+    return fast_loop_proj;\n+  }\n@@ -266,2 +252,51 @@\n-  return iff;\n-}\n+  IfFalseNode* create_slow_loop_proj() {\n+    IfFalseNode* slow_loop_proj = new IfFalseNode(_selector);\n+    _phase->register_node(slow_loop_proj, _outer_loop, _selector, _dom_depth);\n+    return slow_loop_proj;\n+  }\n+\n+ public:\n+  UnswitchedLoopSelector(IfNode* unswitch_if_candidate, IdealLoopTree* loop)\n+      : _phase(loop->_phase),\n+        _outer_loop(loop->_head->as_Loop()->is_strip_mined() ? loop->_parent->_parent : loop->_parent),\n+        _original_loop_entry(loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl)),\n+        _dom_depth(_phase->dom_depth(_original_loop_entry)),\n+        _selector(create_selector_if(loop, unswitch_if_candidate)),\n+        _fast_loop_proj(create_fast_loop_proj()),\n+        _slow_loop_proj(create_slow_loop_proj()) {}\n+\n+  uint dom_depth() const {\n+    return _dom_depth;\n+  }\n+\n+  Node* entry() const {\n+    return _selector->in(0);\n+  }\n+\n+  IfNode* selector() const {\n+    return _selector;\n+  }\n+\n+  IfTrueNode* fast_loop_proj() const {\n+    return _fast_loop_proj;\n+  }\n+\n+  IfFalseNode* slow_loop_proj() const {\n+    return _slow_loop_proj;\n+  }\n+};\n+\n+\/\/ Class to unswitch a loop and create predicates at the new loops. The newly cloned loop becomes the slow loop while\n+\/\/ the original loop becomes the fast loop.\n+class OriginalLoop {\n+  LoopNode* _loop_head; \/\/ The original loop becomes the fast loop.\n+  LoopNode* _strip_mined_loop_head;\n+  IdealLoopTree* _loop;\n+  Node_List* _old_new;\n+  PhaseIdealLoop* _phase;\n+\n+  void fix_loop_entries(IfProjNode* iffast_pred, IfProjNode* ifslow_pred) {\n+    _phase->replace_loop_entry(_strip_mined_loop_head, iffast_pred);\n+    LoopNode* slow_loop_strip_mined_head = _old_new->at(_strip_mined_loop_head->_idx)->as_Loop();\n+    _phase->replace_loop_entry(slow_loop_strip_mined_head, ifslow_pred);\n+  }\n@@ -270,13 +305,11 @@\n-void PhaseIdealLoop::verify_fast_loop(LoopNode* head, const ProjNode* proj_true) const {\n-  assert(proj_true->is_IfTrue(), \"must be true projection\");\n-  Node* entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n-  Predicates predicates(entry);\n-  if (!predicates.has_any()) {\n-    \/\/ No Parse Predicate.\n-    Node* uniqc = proj_true->unique_ctrl_out();\n-    assert((uniqc == head && !head->is_strip_mined()) || (uniqc == head->in(LoopNode::EntryControl)\n-                                                          && head->is_strip_mined()), \"must hold by construction if no predicates\");\n-  } else {\n-    \/\/ There is at least one Parse Predicate. When skipping all predicates\/predicate blocks, we should end up\n-    \/\/ at 'proj_true'.\n-    assert(proj_true == predicates.entry(), \"must hold by construction if at least one Parse Predicate\");\n+  static void verify_unswitched_loops(LoopNode* fast_loop_head, UnswitchedLoopSelector& unswitched_loop_selector,\n+                                      Node_List* old_new) {\n+    verify_unswitched_loop(fast_loop_head, unswitched_loop_selector.fast_loop_proj());\n+    verify_unswitched_loop(old_new->at(fast_loop_head->_idx)->as_Loop(), unswitched_loop_selector.slow_loop_proj());\n+  }\n+\n+  static void verify_unswitched_loop(LoopNode* loop_head, IfProjNode* loop_selector_if_proj) {\n+    Node* entry = loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+    Predicates predicates(entry);\n+    \/\/ When skipping all predicates, we should end up at 'loop_selector_if_proj'.\n+    assert(loop_selector_if_proj == predicates.entry(), \"should end up at selector if\");\n@@ -284,1 +317,0 @@\n-}\n@@ -287,0 +319,37 @@\n+ public:\n+  OriginalLoop(IdealLoopTree* loop, Node_List* old_new)\n+      : _loop_head(loop->_head->as_Loop()),\n+        _strip_mined_loop_head(_loop_head->skip_strip_mined()),\n+        _loop(loop),\n+        _old_new(old_new),\n+        _phase(loop->_phase) {}\n+\n+\n+  \/\/ Unswitch on the invariant unswitching candidate If. Return the new if which switches between the slow and fast loop.\n+  IfNode* unswitch(IfNode* unswitching_candidate) {\n+    UnswitchedLoopSelector unswitched_loop_selector(unswitching_candidate, _loop);\n+    IfNode* loop_selector = unswitched_loop_selector.selector();\n+    const uint first_slow_loop_node_index = _phase->C->unique();\n+    _phase->clone_loop(_loop, *_old_new, _phase->dom_depth(_loop_head),\n+                       PhaseIdealLoop::CloneIncludesStripMined, loop_selector);\n+    \/\/ Fast (true) and Slow (false) control\n+    IfProjNode* iffast_pred = unswitched_loop_selector.fast_loop_proj();\n+    IfProjNode* ifslow_pred = unswitched_loop_selector.slow_loop_proj();\n+    _phase->clone_parse_and_assertion_predicates_to_unswitched_loop(_loop, *_old_new, iffast_pred, ifslow_pred);\n+\n+    fix_loop_entries(iffast_pred, ifslow_pred);\n+\n+    DEBUG_ONLY(verify_unswitched_loops(_loop_head, unswitched_loop_selector, _old_new);)\n+    return loop_selector;\n+  }\n+};\n+\n+\/\/ Create a slow version of the loop by cloning the loop and inserting an If to select the fast or slow version.\n+\/\/ Return the inserted loop selector If.\n+IfNode* PhaseIdealLoop::create_slow_version_of_loop(IdealLoopTree* loop, Node_List& old_new,\n+                                                    IfNode* unswitching_candidate) {\n+  OriginalLoop original_loop(loop, &old_new);\n+  IfNode* loop_selector = original_loop.unswitch(unswitching_candidate);\n+  recompute_dom_depth();\n+  return loop_selector;\n+}\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":160,"deletions":91,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -4102,1 +4102,1 @@\n-  Node* entry = loop->_head->in(LoopNode::EntryControl);\n+  Node* entry = loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n@@ -4141,1 +4141,1 @@\n-  Node* entry = loop->_head->in(LoopNode::EntryControl);\n+  Node* entry = loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -949,3 +949,0 @@\n-  static bool subgraph_has_opaque(Node* n);\n-  Node* create_bool_from_template_assertion_predicate(Node* template_assertion_predicate, Node* new_init, Node* new_stride,\n-                                                      Node* control);\n@@ -1336,1 +1333,1 @@\n-  IfProjNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n+  IfTrueNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_success_proj, Node* new_entry,\n@@ -1353,0 +1350,5 @@\n+  void replace_loop_entry(LoopNode* loop_head, Node* new_entry) {\n+    _igvn.replace_input_of(loop_head, LoopNode::EntryControl, new_entry);\n+    set_idom(loop_head, new_entry, dom_depth(new_entry));\n+  }\n+\n@@ -1354,2 +1356,2 @@\n-  BoolNode* rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init, Node* limit,\n-                         jint stride, Node* range, bool upper, bool& overflow);\n+  BoolNode* rc_predicate(Node* ctrl, int scale, Node* offset, Node* init, Node* limit, jint stride, Node* range,\n+                         bool upper, bool& overflow);\n@@ -1392,2 +1394,1 @@\n-  bool has_control_dependencies_from_predicates(LoopNode* head) const;\n-  void verify_fast_loop(LoopNode* head, const ProjNode* proj_true) const NOT_DEBUG_RETURN;\n+  static bool has_control_dependencies_from_predicates(LoopNode* head);\n@@ -1411,4 +1412,1 @@\n-  IfNode* create_slow_version_of_loop(IdealLoopTree *loop,\n-                                        Node_List &old_new,\n-                                        IfNode* unswitch_iff,\n-                                        CloneLoopMode mode);\n+  IfNode* create_slow_version_of_loop(IdealLoopTree* loop, Node_List& old_new, IfNode* unswitching_candidate);\n@@ -1419,1 +1417,1 @@\n-  void do_unswitching (IdealLoopTree *loop, Node_List &old_new);\n+  void do_unswitching(IdealLoopTree* loop, Node_List& old_new);\n@@ -1422,1 +1420,1 @@\n-  IfNode* find_unswitching_candidate(const IdealLoopTree *loop) const;\n+  IfNode* find_unswitching_candidate(const IdealLoopTree* loop) const;\n@@ -1621,0 +1619,1 @@\n+ public:\n@@ -1624,0 +1623,1 @@\n+ private:\n@@ -1650,0 +1650,6 @@\n+  Node* clone_and_register(Node* n, Node* ctrl) {\n+    n = n->clone();\n+    register_new_node(n, ctrl);\n+    return n;\n+  }\n+\n@@ -1726,6 +1732,0 @@\n-  bool clone_cmp_down(Node* n, const Node* blk1, const Node* blk2);\n-\n-  void clone_loadklass_nodes_at_cmp_index(const Node* n, Node* cmp, int i);\n-\n-  bool clone_cmp_loadklass_down(Node* n, const Node* blk1, const Node* blk2);\n-\n@@ -1734,0 +1734,4 @@\n+  bool clone_cmp_loadklass_down(Node* n, const Node* blk1, const Node* blk2);\n+  void clone_loadklass_nodes_at_cmp_index(const Node* n, Node* cmp, int i);\n+  bool clone_cmp_down(Node* n, const Node* blk1, const Node* blk2);\n+  void clone_template_assertion_predicate_bool_down_if_related(Node* n);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -137,0 +137,2 @@\n+class OpaqueLoopInitNode;\n+class OpaqueLoopStrideNode;\n@@ -786,0 +788,2 @@\n+      DEFINE_CLASS_ID(OpaqueLoopInit, Opaque1, 0)\n+      DEFINE_CLASS_ID(OpaqueLoopStride, Opaque1, 1)\n@@ -955,0 +959,2 @@\n+  DEFINE_CLASS_QUERY(OpaqueLoopInit)\n+  DEFINE_CLASS_QUERY(OpaqueLoopStride)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    init_class_id(Class_OpaqueLoopInit);\n@@ -70,0 +71,1 @@\n+    init_class_id(Class_OpaqueLoopStride);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/subnode.hpp\"\n@@ -150,0 +151,328 @@\n+\n+TemplateAssertionPredicateBool::TemplateAssertionPredicateBool(Node* source_bool) : _source_bool(source_bool->as_Bool()) {\n+#ifdef ASSERT\n+  \/\/ During IGVN, we could have multiple outputs of the _source_bool, for example, when the backedge of the loop of\n+  \/\/ this Template Assertion Predicate is about to die and the CastII on the last value bool already folded to a\n+  \/\/ constant (i.e. no OpaqueLoop* nodes anymore). Then IGVN could already have commoned up the bool with the bool of\n+  \/\/ one of the Hoisted Check Predicates. Just check that the Template Assertion Predicate is one of the outputs.\n+  bool has_template_output = false;\n+  for (DUIterator_Fast imax, i = source_bool->fast_outs(imax); i < imax; i++) {\n+    Node* out = source_bool->fast_out(i);\n+    if (out->Opcode() == Op_Opaque4) {\n+      has_template_output = true;\n+      break;\n+    }\n+  }\n+  assert(has_template_output, \"must find Template Assertion Predicate as output\");\n+#endif \/\/ ASSERT\n+}\n+\n+\/\/ Stack used when performing DFS on a Template Assertion Predicate Bool. The DFS traversal visits non-CFG inputs of a\n+\/\/ node in increasing node index order (i.e. first visiting the input node at index 1). Each time a new node is visited,\n+\/\/ it is inserted on top of the stack. Each node n in the stack maintains a node input index i, denoted as [n, i]:\n+\/\/\n+\/\/ i = 0, [n, 0]:\n+\/\/     n is currently being visited for the first time in the DFS traversal and was newly added to the stack\n+\/\/\n+\/\/ i > 0, [n, i]:\n+\/\/     Let node s be the next node being visited after node n in the DFS traversal. The following holds:\n+\/\/         n->in(i) = s\n+class DFSNodeStack : public StackObj {\n+  Node_Stack _stack;\n+  static const uint _no_inputs_visited_yet = 0;\n+\n+ public:\n+  explicit DFSNodeStack(BoolNode* template_bool)\n+      : _stack(2) {\n+        _stack.push(template_bool, _no_inputs_visited_yet);\n+  }\n+\n+  \/\/ Push the next unvisited input of the current node on top of the stack and return true. The visiting order of node\n+  \/\/ inputs is in increasing node input index order. If there are no unvisited inputs left, do nothing and return false.\n+  bool push_next_unvisited_input() {\n+    Node* node_on_top = top();\n+    increment_top_node_input_index();\n+    const uint next_unvisited_input = _stack.index();\n+    for (uint index = next_unvisited_input; index < node_on_top->req(); index++) {\n+      Node* input = node_on_top->in(index);\n+      if (TemplateAssertionPredicateBool::could_be_part(input)) {\n+        \/\/ We only care about nodes that could possibly be part of a Template Assertion Predicate Bool.\n+        _stack.set_index(index);\n+        _stack.push(input, _no_inputs_visited_yet);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  Node* top() const {\n+    return _stack.node();\n+  }\n+\n+  uint node_index_to_previously_visited_parent() const {\n+    return _stack.index();\n+  }\n+\n+  bool is_not_empty() const {\n+    return _stack.size() > 0;\n+  }\n+\n+  Node* pop() {\n+    Node* popped_node = top();\n+    _stack.pop();\n+    return popped_node;\n+  }\n+\n+  void increment_top_node_input_index() {\n+    _stack.set_index(_stack.index() + 1);\n+  }\n+\n+  void replace_top_with(Node* node) {\n+    _stack.set_node(node);\n+  }\n+};\n+\n+\/\/ Interface to transform OpaqueLoop* nodes of a Template Assertion Predicate Bool. The transformations must return a\n+\/\/ new or different existing node.\n+class TransformOpaqueLoopNodes : public StackObj {\n+ public:\n+  virtual Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) = 0;\n+  virtual Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) = 0;\n+};\n+\n+\/\/ Class to clone a Template Assertion Predicate Bool. The BoolNode and all the nodes up to but excluding the OpaqueLoop*\n+\/\/ nodes are cloned. The OpaqueLoop* nodes are transformed by the provided strategy (e.g. cloned or replaced).\n+class CloneTemplateAssertionPredicateBool : public StackObj {\n+  DFSNodeStack _stack;\n+  PhaseIdealLoop* _phase;\n+  uint _index_before_cloning;\n+  Node* _ctrl_for_clones;\n+  DEBUG_ONLY(bool _found_init;)\n+\n+  \/\/ Replace the OpaqueLoop*Node opaque_loop_node currently on top of the stack by transforming it with the provided\n+  \/\/ strategy. The transformation must return a new or an existing node other than the OpaqueLoop* node itself.\n+  void transform_opaque_loop_node(const Node* opaque_loop_node, TransformOpaqueLoopNodes* transform_opaque_nodes) {\n+    assert(opaque_loop_node == _stack.top(), \"must be top node\");\n+    Node* transformed_node;\n+    if (opaque_loop_node->is_OpaqueLoopInit()) {\n+      DEBUG_ONLY(_found_init = true;)\n+      transformed_node = transform_opaque_nodes->transform_opaque_init(opaque_loop_node->as_OpaqueLoopInit());\n+    } else {\n+      transformed_node = transform_opaque_nodes->transform_opaque_stride(opaque_loop_node->as_OpaqueLoopStride());\n+    }\n+    assert(transformed_node != opaque_loop_node, \"OpaqueLoop*Node must have been transformed\");\n+    _stack.replace_top_with(transformed_node);\n+  }\n+\n+  \/\/ Similar to pop_node() but handles only newly transformed OpaqueLoop* nodes.\n+  void pop_transformed_opaque_loop_node() {\n+    Node* transformed_opaque_loop_node = _stack.pop();\n+    assert(_stack.is_not_empty(), \"must not be empty when popping a transformed OpaqueLoop*Node\");\n+    if (must_clone_node_on_top(transformed_opaque_loop_node)) {\n+      clone_and_replace_top_node();\n+    }\n+    \/\/ Rewire the current node on top (child of old OpaqueLoop*Node) to the newly transformed node.\n+    rewire_node_on_top_to(transformed_opaque_loop_node);\n+  }\n+\n+  \/\/ Must only clone current top node if the following two conditions hold:\n+  \/\/ (1) [top, i], top->in(i) != previously_visited_parent\n+  \/\/ (2) top is not a clone.\n+  \/\/ If (1) is false, then we have not transformed or cloned previously_visited_parent and thus know that\n+  \/\/ previously_visited_parent is not part of the Template Assertion Predicate Bool (i.e. not on the chain to an\n+  \/\/ OpaqueLoop* node). We don't need to clone top at this point as it might also not be part of the Template Assertion\n+  \/\/ Predicate Bool.\n+  \/\/ If (1) is true then previously_visited_parent is part of the Template Assertion Predicate Bool. But if top was\n+  \/\/ already cloned, we do not need to clone it again to avoid duplicates.\n+  bool must_clone_node_on_top(Node* previously_visited_parent) {\n+    Node* child_of_previously_visited_parent = _stack.top();\n+    const uint node_index_to_previously_visited_parent = _stack.node_index_to_previously_visited_parent();\n+    return child_of_previously_visited_parent->_idx < _index_before_cloning && \/\/ (2)\n+           child_of_previously_visited_parent->in(node_index_to_previously_visited_parent) != previously_visited_parent; \/\/ (1)\n+  }\n+\n+  \/\/ `new_parent` replaced the old parent of the current node on top of the stack for which we stored\n+  \/\/     [top, i]\n+  \/\/ where\n+  \/\/     top->in(i) = old_parent.\n+  \/\/ We clone the current node on top and replace it in the stack such that\n+  \/\/     [cloned_top, i]\n+  void clone_and_replace_top_node() {\n+    Node* top = _stack.top();\n+    Node* cloned_top = _phase->clone_and_register(top, _ctrl_for_clones);\n+    _stack.replace_top_with(cloned_top);\n+  }\n+\n+  \/\/ Pop a node from the stack and do the following with the node now being on top:\n+  \/\/ - Is top node part of Template Assertion Predicate Bool?\n+  \/\/   - No? Done.\n+  \/\/   - Yes:\n+  \/\/     - Cloned before?\n+  \/\/       - No? Clone and replace node on top with cloned version.\n+  \/\/     - Rewire the node on top to the previous node on top (i.e. the cloned node to its new cloned\/transformed\n+  \/\/       parent).\n+  void pop_node() {\n+    Node* previously_visited_parent = _stack.pop();\n+    if (_stack.is_not_empty()) {\n+      if (must_clone_node_on_top(previously_visited_parent)) {\n+        clone_and_replace_top_node();\n+        rewire_node_on_top_to(previously_visited_parent);\n+      } else if (is_cloned_node(previously_visited_parent)) {\n+        rewire_node_on_top_to(previously_visited_parent);\n+      } \/\/ Else: Node is not part of the Template Assertion Predicate Bool (i.e. not on the chain to an OpaqueLoop* node)\n+    }\n+  }\n+\n+  bool is_cloned_node(Node* node) const {\n+    return node->_idx >= _index_before_cloning;\n+  }\n+\n+  \/\/ `new_parent` replaced the old parent of the current node on top of the stack for which we stored:\n+  \/\/     [top, i]\n+  \/\/ where\n+  \/\/     top->in(i) = old_parent.\n+  \/\/ We rewire the top node to the new parent such that:\n+  \/\/     top->in(i) = new_parent\n+  void rewire_node_on_top_to(Node* new_parent) {\n+    Node* top = _stack.top();\n+    assert(is_cloned_node(top) && !top->is_Opaque1(), \"must be cloned node on chain to OpaqueLoop*Node (excluded)\");\n+    const uint index_to_old_parent = _stack.node_index_to_previously_visited_parent();\n+    top->set_req(index_to_old_parent, new_parent);\n+  }\n+\n+ public:\n+  CloneTemplateAssertionPredicateBool(BoolNode* template_bool, Node* ctrl_for_clones, PhaseIdealLoop* phase)\n+      : _stack(template_bool),\n+        _phase(phase),\n+        _index_before_cloning(phase->C->unique()),\n+        _ctrl_for_clones(ctrl_for_clones)\n+  DEBUG_ONLY(COMMA _found_init(false)) {}\n+\n+  \/\/ Look for the OpaqueLoop* nodes to transform them with the strategy defined with 'transform_opaque_loop_nodes'.\n+  \/\/ Clone all nodes in between.\n+  BoolNode* clone(TransformOpaqueLoopNodes* transform_opaque_loop_nodes) {\n+    Node* current;\n+    while (_stack.is_not_empty()) {\n+      current = _stack.top();\n+      if (current->is_Opaque1()) {\n+        transform_opaque_loop_node(current, transform_opaque_loop_nodes);\n+        pop_transformed_opaque_loop_node();\n+      } else if (!_stack.push_next_unvisited_input()) {\n+        pop_node();\n+      }\n+    }\n+    assert(current->is_Bool() && current->_idx >= _index_before_cloning, \"new BoolNode expected\");\n+    assert(_found_init, \"OpaqueLoopInitNode must always be found\");\n+    return current->as_Bool();\n+  }\n+};\n+\n+\/\/ This class caches a single OpaqueLoopInitNode and OpaqueLoopStrideNode. If the node is not cached, yet, we clone it\n+\/\/ and store the clone in the cache to be returned for subsequent calls.\n+class CachedOpaqueLoopNodes {\n+  OpaqueLoopInitNode* _cached_opaque_new_init;\n+  OpaqueLoopStrideNode* _cached_new_opaque_stride;\n+  PhaseIdealLoop* _phase;\n+  Node* _new_ctrl;\n+\n+ public:\n+  CachedOpaqueLoopNodes(PhaseIdealLoop* phase, Node* new_ctrl)\n+      : _cached_opaque_new_init(nullptr),\n+        _cached_new_opaque_stride(nullptr),\n+        _phase(phase),\n+        _new_ctrl(new_ctrl) {}\n+\n+  OpaqueLoopInitNode* clone_if_not_cached(OpaqueLoopInitNode* opaque_init) {\n+    if (_cached_opaque_new_init == nullptr) {\n+      _cached_opaque_new_init = _phase->clone_and_register(opaque_init, _new_ctrl)->as_OpaqueLoopInit();\n+    }\n+    return _cached_opaque_new_init;\n+  }\n+\n+  OpaqueLoopStrideNode* clone_if_not_cached(OpaqueLoopStrideNode* opaque_stride) {\n+    if (_cached_new_opaque_stride == nullptr) {\n+      _cached_new_opaque_stride = _phase->clone_and_register(opaque_stride, _new_ctrl)->as_OpaqueLoopStride();\n+    }\n+    return _cached_new_opaque_stride;\n+  }\n+};\n+\n+\/\/ The transformations of this class clone the existing OpaqueLoop* nodes without any other update.\n+class CloneOpaqueLoopNodes : public TransformOpaqueLoopNodes {\n+  CachedOpaqueLoopNodes _cached_opaque_loop_nodes;\n+\n+ public:\n+  CloneOpaqueLoopNodes(PhaseIdealLoop* phase, Node* new_ctrl)\n+      : _cached_opaque_loop_nodes(phase, new_ctrl) {}\n+\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) override {\n+    return _cached_opaque_loop_nodes.clone_if_not_cached(opaque_init);\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) override {\n+    return _cached_opaque_loop_nodes.clone_if_not_cached(opaque_stride);\n+  }\n+};\n+\n+\/\/ Clones this Template Assertion Predicate Bool. This includes all nodes from the BoolNode to the OpaqueLoop* nodes.\n+\/\/ The cloned nodes are not updated.\n+BoolNode* TemplateAssertionPredicateBool::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n+  CloneOpaqueLoopNodes clone_opaque_loop_nodes(phase, new_ctrl);\n+  CloneTemplateAssertionPredicateBool clone_template_assertion_predicate_bool(_source_bool, new_ctrl, phase);\n+  return clone_template_assertion_predicate_bool.clone(&clone_opaque_loop_nodes);\n+}\n+\n+\/\/ The transformations of this class clone the existing OpaqueLoopStrideNode and replace the OpaqueLoopInitNode with\n+\/\/ a new node.\n+class CloneWithNewInit : public TransformOpaqueLoopNodes {\n+  Node* _new_init;\n+  CachedOpaqueLoopNodes _cached_opaque_loop_nodes;\n+\n+ public:\n+  CloneWithNewInit(PhaseIdealLoop* phase, Node* new_ctrl, Node* new_init)\n+      : _new_init(new_init),\n+        _cached_opaque_loop_nodes(phase, new_ctrl) {}\n+\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) override {\n+    return _new_init;\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) override {\n+    return _cached_opaque_loop_nodes.clone_if_not_cached(opaque_stride);\n+  }\n+};\n+\n+\/\/ Clones this Template Assertion Predicate Bool including the OpaqueLoopStrideNode (includes all nodes from the BoolNode\n+\/\/ to the OpaqueLoopStrideNode). The OpaqueLoopInitNode is replaced with a new node.\n+BoolNode* TemplateAssertionPredicateBool::clone_and_replace_init(Node* new_ctrl, Node* new_init,\n+                                                                 PhaseIdealLoop* phase) {\n+  CloneWithNewInit clone_with_new_init(phase, new_ctrl, new_init);\n+  CloneTemplateAssertionPredicateBool clone_template_assertion_predicate_bool(_source_bool, new_ctrl, phase);\n+  return clone_template_assertion_predicate_bool.clone(&clone_with_new_init);\n+}\n+\n+\n+\/\/ The transformations of this class replace the existing OpaqueLoop* nodes with new nodes.\n+class ReplaceOpaqueLoopNodes : public TransformOpaqueLoopNodes {\n+  Node* _new_init;\n+  Node* _new_stride;\n+\n+ public:\n+  ReplaceOpaqueLoopNodes(Node* new_init, Node* new_stride) : _new_init(new_init), _new_stride(new_stride) {}\n+\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) override {\n+    return _new_init;\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) override {\n+    return _new_stride;\n+  }\n+};\n+\n+\/\/ Clones this Template Assertion Predicate Bool and replaces the OpaqueLoop* nodes with new nodes.\n+BoolNode* TemplateAssertionPredicateBool::clone_and_replace_opaque_loop_nodes(Node* new_ctrl, Node* new_init,\n+                                                                              Node* new_stride, PhaseIdealLoop* phase) {\n+  ReplaceOpaqueLoopNodes replaceOpaqueLoopNodes(new_init, new_stride);\n+  CloneTemplateAssertionPredicateBool clone_template_assertion_predicate_bool(_source_bool, new_ctrl, phase);\n+  return clone_template_assertion_predicate_bool.clone(&replaceOpaqueLoopNodes);\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":329,"deletions":0,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"opto\/loopnode.hpp\"\n+#include \"opto\/opaquenode.hpp\"\n@@ -266,0 +268,36 @@\n+\/\/ A Template Assertion Predicate Bool represents the BoolNode for the initial value or the last value of a\n+\/\/ Template Assertion Predicate and all the nodes up to and including the OpaqueLoop* nodes.\n+class TemplateAssertionPredicateBool : public StackObj {\n+  BoolNode* _source_bool;\n+\n+ public:\n+  explicit TemplateAssertionPredicateBool(Node* source_bool);\n+\n+  \/\/ Is 'n' a node that could be part of a Template Assertion Predicate Bool (i.e. could be found on the input chain of\n+  \/\/ a Template Assertion Predicate BoolNode up to and including the OpaqueLoop* nodes)?\n+  static bool could_be_part(const Node* n) {\n+    const int opcode = n->Opcode();\n+    return (opcode == Op_OpaqueLoopInit ||\n+            opcode == Op_OpaqueLoopStride ||\n+            n->is_Bool() ||\n+            n->is_Cmp() ||\n+            opcode == Op_AndL ||\n+            opcode == Op_OrL ||\n+            opcode == Op_RShiftL ||\n+            opcode == Op_LShiftL ||\n+            opcode == Op_LShiftI ||\n+            opcode == Op_AddL ||\n+            opcode == Op_AddI ||\n+            opcode == Op_MulL ||\n+            opcode == Op_MulI ||\n+            opcode == Op_SubL ||\n+            opcode == Op_SubI ||\n+            opcode == Op_ConvI2L ||\n+            opcode == Op_CastII);\n+  }\n+\n+  BoolNode* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n+  BoolNode* clone_and_replace_init(Node* new_ctrl, Node* new_init, PhaseIdealLoop* phase);\n+  BoolNode* clone_and_replace_opaque_loop_nodes(Node* new_ctrl, Node* new_init, Node* new_stride, PhaseIdealLoop* phase);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\n+#include \"opto\/predicates.hpp\"\n@@ -98,18 +98,1 @@\n-  if (subgraph_has_opaque(n)) {\n-    Unique_Node_List wq;\n-    wq.push(n);\n-    for (uint i = 0; i < wq.size(); i++) {\n-      Node* m = wq.at(i);\n-      if (m->is_If()) {\n-        assert(assertion_predicate_has_loop_opaque_node(m->as_If()), \"opaque node not reachable from if?\");\n-        Node* bol = create_bool_from_template_assertion_predicate(m, nullptr, nullptr, m->in(0));\n-        _igvn.replace_input_of(m, 1, bol);\n-      } else {\n-        assert(!m->is_CFG(), \"not CFG expected\");\n-        for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax; j++) {\n-          Node* u = m->fast_out(j);\n-          wq.push(u);\n-        }\n-      }\n-    }\n-  }\n+  clone_template_assertion_predicate_bool_down_if_related(n);\n@@ -429,0 +412,94 @@\n+\/\/ This class clones Template Assertion Predicates Bools down as part of the Split If optimization.\n+class CloneTemplateAssertionPredicateBoolDown {\n+  PhaseIdealLoop* _phase;\n+\n+  \/\/ Check if 'n' belongs to the init or last value Template Assertion Predicate Bool, including the OpaqueLoop* nodes.\n+  static bool could_be_part_of_template_assertion_predicate_bool(Node* n) {\n+    if (TemplateAssertionPredicateBool::could_be_part(n)) {\n+      ResourceMark rm;\n+      Unique_Node_List list;\n+      list.push(n);\n+      for (uint i = 0; i < list.size(); i++) {\n+        Node* next = list.at(i);\n+        const int opcode = next->Opcode();\n+        if (opcode == Op_OpaqueLoopInit || opcode == Op_OpaqueLoopStride) {\n+          return true;\n+        } else if (TemplateAssertionPredicateBool::could_be_part(next)) {\n+          push_non_null_inputs(list, next);\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  static void push_non_null_inputs(Unique_Node_List& list, const Node* n) {\n+    for (uint i = 1; i < n->req(); i++) {\n+      Node* input = n->in(i);\n+      if (input != nullptr) {\n+        list.push(input);\n+      }\n+    }\n+  }\n+\n+  \/\/          OpaqueLoop*Node                  cloned OpaqueLoop*Node     \\\n+  \/\/                |                                    |                | Template Assertion\n+  \/\/               ...                              cloned ...            | Predicate Bool\n+  \/\/                |                ====>               |                |\n+  \/\/            bool_node                         cloned bool_node        \/\n+  \/\/                |                                    |\n+  \/\/   template_assertion_predicate         template_assertion_predicate\n+  void clone_template_assertion_predicate_bool(Node* n) {\n+    Unique_Node_List list;\n+    list.push(n);\n+\n+    for (uint i = 0; i < list.size(); i++) {\n+      Node* next = list.at(i);\n+      if (is_template_assertion_predicate(next)) {\n+        clone_template_assertion_predicate_bool_and_replace(next);\n+      } else {\n+        assert(!next->is_CFG(), \"no CFG expected in Template Assertion Predicate Bool\");\n+        push_outputs(list, next);\n+      }\n+    }\n+  }\n+\n+  static bool is_template_assertion_predicate(Node* n) {\n+    return n->is_If() && n->in(1)->Opcode() == Op_Opaque4;\n+  }\n+\n+  void clone_template_assertion_predicate_bool_and_replace(Node* template_assertion_predicate) {\n+    Node* new_ctrl = template_assertion_predicate->in(0);\n+    Node* opaque4_node = template_assertion_predicate->in(1);\n+    TemplateAssertionPredicateBool template_assertion_predicate_bool(opaque4_node->in(1));\n+    BoolNode* cloned_bool = template_assertion_predicate_bool.clone(new_ctrl, _phase);\n+    _phase->igvn().replace_input_of(opaque4_node, 1, cloned_bool);\n+  }\n+\n+  static void push_outputs(Unique_Node_List& list, const Node* n) {\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      Node* out = n->fast_out(j);\n+      list.push(out);\n+    }\n+  }\n+\n+ public:\n+  CloneTemplateAssertionPredicateBoolDown(PhaseIdealLoop* phase) : _phase(phase) {}\n+\n+  \/\/ 'n' could be a node belonging to a Template Assertion Predicate Bool (i.e. any node between a Template Assertion\n+  \/\/ Predicate and its OpaqueLoop* nodes (included)). In this case, we need to clone all the nodes belonging to the\n+  \/\/ Template Assertion Predicate Bool down. This avoids creating the phi node on the BoolNode input chain from the\n+  \/\/ OpaqueLoop* nodes. Otherwise, we could not find the OpaqueLoop* nodes anymore when trying to access them in\n+  \/\/ with Template Assertion Predicate Bool related code (pattern matching does not expect phis).\n+  void clone_if_part_of_template_assertion_predicate_bool(Node* n) {\n+    if (!could_be_part_of_template_assertion_predicate_bool(n)) {\n+      return;\n+    }\n+    clone_template_assertion_predicate_bool(n);\n+  }\n+};\n+\n+void PhaseIdealLoop::clone_template_assertion_predicate_bool_down_if_related(Node* n) {\n+  CloneTemplateAssertionPredicateBoolDown clone_down(this);\n+  clone_down.clone_if_part_of_template_assertion_predicate_bool(n);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":96,"deletions":19,"binary":false,"changes":115,"status":"modified"}]}