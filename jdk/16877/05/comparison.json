{"files":[{"patch":"@@ -496,0 +496,5 @@\n+  \/\/ Return the uncommon trap If projection of this Parse Predicate.\n+  ParsePredicateUncommonProj* uncommon_proj() const {\n+    return proj_out(0)->as_IfFalse();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,2 +102,2 @@\n-IfProjNode* PhaseIdealLoop::create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n-                                                        Deoptimization::DeoptReason reason,\n+IfTrueNode* PhaseIdealLoop::create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_success_proj,\n+                                                        Node* new_entry, const Deoptimization::DeoptReason reason,\n@@ -105,6 +105,4 @@\n-  assert(parse_predicate_proj->is_uncommon_trap_if_pattern(reason), \"must be a uct if pattern!\");\n-  ParsePredicateNode* parse_predicate = parse_predicate_proj->in(0)->as_ParsePredicate();\n-\n-  ProjNode* uncommon_proj = parse_predicate->proj_out(false);\n-  Node* uct_region = uncommon_proj->unique_ctrl_out();\n-  assert(uct_region->is_Region() || uct_region->is_Call(), \"must be a region or call uct\");\n+  assert(parse_predicate_success_proj->is_uncommon_trap_if_pattern(reason), \"must be a uct if pattern!\");\n+  ParsePredicateNode* parse_predicate = parse_predicate_success_proj->in(0)->as_ParsePredicate();\n+  ParsePredicateUncommonProj* uncommon_proj = parse_predicate->uncommon_proj();\n+  Node* uncommon_trap = parse_predicate->uncommon_trap();\n@@ -113,3 +111,3 @@\n-  if (!uct_region->is_Region()) { \/\/ create a region to guard the call\n-    assert(uct_region->is_Call(), \"must be call uct\");\n-    CallNode* call = uct_region->as_Call();\n+  if (!uncommon_trap->is_Region()) { \/\/ create a region to guard the call\n+    assert(uncommon_trap->is_Call(), \"must be call uct\");\n+    CallNode* call = uncommon_trap->as_Call();\n@@ -117,1 +115,1 @@\n-    uct_region = new RegionNode(1);\n+    uncommon_trap = new RegionNode(1);\n@@ -119,1 +117,1 @@\n-    uncommon_proj = uncommon_proj->clone()->as_Proj();\n+    uncommon_proj = uncommon_proj->clone()->as_IfFalse();\n@@ -121,3 +119,3 @@\n-    uct_region->add_req(uncommon_proj);\n-    register_control(uct_region, loop, uncommon_proj);\n-    _igvn.replace_input_of(call, 0, uct_region);\n+    uncommon_trap->add_req(uncommon_proj);\n+    register_control(uncommon_trap, loop, uncommon_proj);\n+    _igvn.replace_input_of(call, 0, uncommon_trap);\n@@ -126,1 +124,1 @@\n-      set_idom(call, uct_region, dom_depth(uct_region));\n+      set_idom(call, uncommon_trap, dom_depth(uncommon_trap));\n@@ -130,1 +128,1 @@\n-    lazy_replace(uncommon_proj_orig, uct_region);\n+    lazy_replace(uncommon_proj_orig, uncommon_trap);\n@@ -133,3 +131,3 @@\n-    for (; proj_index < uct_region->req(); proj_index++)\n-      if (uct_region->in(proj_index) == uncommon_proj) break;\n-    assert(proj_index < uct_region->req(), \"sanity\");\n+    for (; proj_index < uncommon_trap->req(); proj_index++)\n+      if (uncommon_trap->in(proj_index) == uncommon_proj) break;\n+    assert(proj_index < uncommon_trap->req(), \"sanity\");\n@@ -160,2 +158,3 @@\n-  IfProjNode* if_cont = new IfTrueNode(new_iff);\n-  IfProjNode* if_uct  = new IfFalseNode(new_iff);\n+\n+  IfTrueNode* if_cont = new IfTrueNode(new_iff);\n+  IfFalseNode* if_uct = new IfFalseNode(new_iff);\n@@ -164,1 +163,1 @@\n-  register_control(if_uct, get_loop(uct_region), new_iff);\n+  register_control(if_uct, get_loop(uncommon_trap), new_iff);\n@@ -166,1 +165,1 @@\n-  _igvn.add_input_to(uct_region, if_uct);\n+  _igvn.add_input_to(uncommon_trap, if_uct);\n@@ -170,1 +169,1 @@\n-  assert(uct_region->in(uct_region->req() - 1) == if_uct, \"new edge should be last\");\n+  assert(uncommon_trap->in(uncommon_trap->req() - 1) == if_uct, \"new edge should be last\");\n@@ -172,2 +171,2 @@\n-  for (DUIterator_Fast imax, i = uct_region->fast_outs(imax); i < imax; i++) {\n-    Node* use = uct_region->fast_out(i);\n+  for (DUIterator_Fast imax, i = uncommon_trap->fast_outs(imax); i < imax; i++) {\n+    Node* use = uncommon_trap->fast_out(i);\n@@ -175,1 +174,1 @@\n-      assert(use->in(0) == uct_region, \"\");\n+      assert(use->in(0) == uncommon_trap, \"\");\n@@ -196,1 +195,1 @@\n-  assert(!has_phi || uct_region->req() > 3, \"no phis when region is created\");\n+  assert(!has_phi || uncommon_trap->req() > 3, \"no phis when region is created\");\n@@ -208,1 +207,1 @@\n-    Node* ridom = idom(uct_region);\n+    Node* ridom = idom(uncommon_trap);\n@@ -210,1 +209,1 @@\n-    set_idom(uct_region, nrdom, dom_depth(uct_region));\n+    set_idom(uncommon_trap, nrdom, dom_depth(uncommon_trap));\n@@ -213,1 +212,1 @@\n-  return if_cont->as_IfProj();\n+  return if_cont;\n@@ -760,2 +759,2 @@\n-BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init,\n-                                       Node* limit, jint stride, Node* range, bool upper, bool& overflow) {\n+BoolNode* PhaseIdealLoop::rc_predicate(Node* ctrl, const int scale, Node* offset, Node* init, Node* limit,\n+                                       const jint stride, Node* range, const bool upper, bool& overflow) {\n@@ -1168,1 +1167,1 @@\n-    BoolNode* new_predicate_bol = invar.clone(bol, ctrl)->as_Bool();\n+    BoolNode* hoisted_check_predicate_bool = invar.clone(bol, ctrl)->as_Bool();\n@@ -1173,2 +1172,3 @@\n-      new_predicate_bol = new BoolNode(new_predicate_bol->in(1), new_predicate_bol->_test.negate());\n-      register_new_node(new_predicate_bol, ctrl);\n+      hoisted_check_predicate_bool = new BoolNode(hoisted_check_predicate_bool->in(1),\n+                                                  hoisted_check_predicate_bool->_test.negate());\n+      register_new_node(hoisted_check_predicate_bool, ctrl);\n@@ -1179,1 +1179,1 @@\n-    new_predicate_iff->set_req(1, new_predicate_bol);\n+    new_predicate_iff->set_req(1, hoisted_check_predicate_bool);\n@@ -1223,1 +1223,2 @@\n-    Node* ctrl = parse_predicate_proj->in(0)->as_If()->in(0);\n+    ParsePredicateNode* parse_predicate = parse_predicate_proj->in(0)->as_ParsePredicate();\n+    Node* ctrl = parse_predicate->in(0);\n@@ -1232,1 +1233,1 @@\n-    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n+    BoolNode* lower_bound_bol = rc_predicate(ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n@@ -1239,1 +1240,3 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %d\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) {\n+      tty->print_cr(\"lower bound check if: %d\", lower_bound_iff->_idx);\n+    }\n@@ -1242,2 +1245,1 @@\n-    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true,\n-                                             overflow);\n+    BoolNode* upper_bound_bol = rc_predicate(lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);\n@@ -1250,1 +1252,3 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %d\", upper_bound_iff->_idx);\n+    if (TraceLoopPredicate) {\n+      tty->print_cr(\"upper bound check if: %d\", upper_bound_iff->_idx);\n+    }\n@@ -1297,1 +1301,1 @@\n-  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n+  BoolNode* bol = rc_predicate(upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n@@ -1320,1 +1324,1 @@\n-  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n+  bol = rc_predicate(new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n@@ -1343,4 +1347,0 @@\n-  if (head->is_OuterStripMinedLoop()) {\n-    return false;\n-  }\n-\n@@ -1517,1 +1517,1 @@\n-bool IdealLoopTree::loop_predication( PhaseIdealLoop *phase) {\n+bool IdealLoopTree::loop_predication(PhaseIdealLoop* phase) {\n@@ -1524,1 +1524,1 @@\n-  \/\/ self\n+  \/\/ Self\n@@ -1529,1 +1529,2 @@\n-  if (_next) { \/\/sibling\n+  \/\/ Sibling\n+  if (_next) {\n@@ -1537,1 +1538,5 @@\n-  return _head->is_Loop() && !_irreducible && !tail()->is_top();\n+  return !_head->is_Root() &&\n+         _head->is_Loop() &&\n+         !_head->is_OuterStripMinedLoop() &&\n+         !_irreducible &&\n+         !tail()->is_top();\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":60,"deletions":55,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2775,1 +2775,1 @@\n-  BoolNode* bol = rc_predicate(loop, ctrl, scale_con, offset, value, nullptr, stride_con,\n+  BoolNode* bol = rc_predicate(ctrl, scale_con, offset, value, nullptr, stride_con,\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4323,1 +4323,1 @@\n-  Node* entry = loop->_head->in(LoopNode::EntryControl);\n+  Node* entry = loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n@@ -4362,1 +4362,1 @@\n-  Node* entry = loop->_head->in(LoopNode::EntryControl);\n+  Node* entry = loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1340,1 +1340,1 @@\n-  IfProjNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n+  IfTrueNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n@@ -1363,1 +1363,1 @@\n-  BoolNode* rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init, Node* limit,\n+  BoolNode* rc_predicate(Node* ctrl, int scale, Node* offset, Node* init, Node* limit,\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}