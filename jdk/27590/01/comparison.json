{"files":[{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.errno;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.*;\n+import java.util.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@SuppressWarnings(\"restricted\")\n+public class errno_h$shared {\n+\n+    errno_h$shared() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    public static final OfBoolean C_BOOL = (OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n+    public static final OfByte C_CHAR =(OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n+    public static final OfShort C_SHORT = (OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n+    public static final OfInt C_INT = (OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n+    public static final OfLong C_LONG_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n+    public static final OfFloat C_FLOAT = (OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n+    public static final OfDouble C_DOUBLE = (OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n+    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n+    public static final OfLong C_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n+\n+    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+    static void traceDowncall(String name, Object... args) {\n+         String traceArgs = Arrays.stream(args)\n+                       .map(Object::toString)\n+                       .collect(Collectors.joining(\", \"));\n+         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n+    }\n+\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemoryLayout align(MemoryLayout layout, long align) {\n+        return switch (layout) {\n+            case PaddingLayout p -> p;\n+            case ValueLayout v -> v.withByteAlignment(align);\n+            case GroupLayout g -> {\n+                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n+                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n+                yield g instanceof StructLayout ?\n+                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n+            }\n+            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n+        };\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/errno\/errno_h$shared.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.errno;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.*;\n+\n+@SuppressWarnings(\"restricted\")\n+public class errno_h extends errno_h$shared {\n+\n+    errno_h() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n+\n+    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n+            .or(Linker.nativeLinker().defaultLookup());\n+\n+    private static final int EINTR = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EINTR 4\n+     * }\n+     *\/\n+    public static int EINTR() {\n+        return EINTR;\n+    }\n+\n+    private static class strerror_r {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                C_INT,\n+                C_INT,\n+                C_POINTER,\n+                C_LONG\n+        );\n+\n+        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"strerror_r\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)\n+     * }\n+     *\/\n+    public static FunctionDescriptor strerror_r$descriptor() {\n+        return strerror_r.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)\n+     * }\n+     *\/\n+    public static MethodHandle strerror_r$handle() {\n+        return strerror_r.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)\n+     * }\n+     *\/\n+    public static MemorySegment strerror_r$address() {\n+        return strerror_r.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)\n+     * }\n+     *\/\n+    public static int strerror_r(int __errnum, MemorySegment __strerrbuf, long __buflen) {\n+        var mh$ = strerror_r.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"strerror_r\", __errnum, __strerrbuf, __buflen);\n+            }\n+            return (int)mh$.invokeExact(__errnum, __strerrbuf, __buflen);\n+        } catch (Error | RuntimeException ex) {\n+           throw ex;\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/errno\/errno_h.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Defines native structures for errno APIs.\n+ * Generated with the following jextract command:\n+ * {@snippet lang = \"Shell Script\":\n+ *\n+ * HEADER_NAME=errno.h\n+ * echo \"#include <errno.h>\" > $HEADER_NAME\n+ * echo \"#include <string.h>\" >> $HEADER_NAME\n+ *\n+ * jextract --target-package jdk.internal.ffi.generated.errno \\\n+ *    --include-constant EINTR \\\n+ *    --include-function strerror_r \\\n+ *    $HEADER_NAME\n+ * }\n+ *\n+ *\/\n+\n+package jdk.internal.ffi.generated.errno;\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/errno\/package-info.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,378 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.kqueue;\n+\n+import java.lang.foreign.*;\n+import java.util.function.*;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct kevent {\n+ *     uintptr_t ident;\n+ *     int16_t filter;\n+ *     uint16_t flags;\n+ *     uint32_t fflags;\n+ *     intptr_t data;\n+ *     void *udata;\n+ * }\n+ * }\n+ *\/\n+@SuppressWarnings(\"restricted\")\n+public class kevent {\n+\n+    kevent() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        kqueue_h.align(kqueue_h.C_LONG, 4).withName(\"ident\"),\n+        kqueue_h.C_SHORT.withName(\"filter\"),\n+        kqueue_h.C_SHORT.withName(\"flags\"),\n+        kqueue_h.C_INT.withName(\"fflags\"),\n+        kqueue_h.align(kqueue_h.C_LONG, 4).withName(\"data\"),\n+        kqueue_h.align(kqueue_h.C_POINTER, 4).withName(\"udata\")\n+    ).withName(\"kevent\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfLong ident$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"ident\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * uintptr_t ident\n+     * }\n+     *\/\n+    public static final OfLong ident$layout() {\n+        return ident$LAYOUT;\n+    }\n+\n+    private static final long ident$OFFSET = $LAYOUT.byteOffset(groupElement(\"ident\"));\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * uintptr_t ident\n+     * }\n+     *\/\n+    public static final long ident$offset() {\n+        return ident$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uintptr_t ident\n+     * }\n+     *\/\n+    public static long ident(MemorySegment struct) {\n+        return struct.get(ident$LAYOUT, ident$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * uintptr_t ident\n+     * }\n+     *\/\n+    public static void ident(MemorySegment struct, long fieldValue) {\n+        struct.set(ident$LAYOUT, ident$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfShort filter$LAYOUT = (OfShort)$LAYOUT.select(groupElement(\"filter\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int16_t filter\n+     * }\n+     *\/\n+    public static final OfShort filter$layout() {\n+        return filter$LAYOUT;\n+    }\n+\n+    private static final long filter$OFFSET = $LAYOUT.byteOffset(groupElement(\"filter\"));\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int16_t filter\n+     * }\n+     *\/\n+    public static final long filter$offset() {\n+        return filter$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int16_t filter\n+     * }\n+     *\/\n+    public static short filter(MemorySegment struct) {\n+        return struct.get(filter$LAYOUT, filter$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int16_t filter\n+     * }\n+     *\/\n+    public static void filter(MemorySegment struct, short fieldValue) {\n+        struct.set(filter$LAYOUT, filter$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfShort flags$LAYOUT = (OfShort)$LAYOUT.select(groupElement(\"flags\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * uint16_t flags\n+     * }\n+     *\/\n+    public static final OfShort flags$layout() {\n+        return flags$LAYOUT;\n+    }\n+\n+    private static final long flags$OFFSET = $LAYOUT.byteOffset(groupElement(\"flags\"));\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * uint16_t flags\n+     * }\n+     *\/\n+    public static final long flags$offset() {\n+        return flags$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uint16_t flags\n+     * }\n+     *\/\n+    public static short flags(MemorySegment struct) {\n+        return struct.get(flags$LAYOUT, flags$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * uint16_t flags\n+     * }\n+     *\/\n+    public static void flags(MemorySegment struct, short fieldValue) {\n+        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt fflags$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"fflags\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * uint32_t fflags\n+     * }\n+     *\/\n+    public static final OfInt fflags$layout() {\n+        return fflags$LAYOUT;\n+    }\n+\n+    private static final long fflags$OFFSET = $LAYOUT.byteOffset(groupElement(\"fflags\"));\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * uint32_t fflags\n+     * }\n+     *\/\n+    public static final long fflags$offset() {\n+        return fflags$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uint32_t fflags\n+     * }\n+     *\/\n+    public static int fflags(MemorySegment struct) {\n+        return struct.get(fflags$LAYOUT, fflags$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * uint32_t fflags\n+     * }\n+     *\/\n+    public static void fflags(MemorySegment struct, int fieldValue) {\n+        struct.set(fflags$LAYOUT, fflags$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfLong data$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * intptr_t data\n+     * }\n+     *\/\n+    public static final OfLong data$layout() {\n+        return data$LAYOUT;\n+    }\n+\n+    private static final long data$OFFSET = $LAYOUT.byteOffset(groupElement(\"data\"));\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * intptr_t data\n+     * }\n+     *\/\n+    public static final long data$offset() {\n+        return data$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * intptr_t data\n+     * }\n+     *\/\n+    public static long data(MemorySegment struct) {\n+        return struct.get(data$LAYOUT, data$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * intptr_t data\n+     * }\n+     *\/\n+    public static void data(MemorySegment struct, long fieldValue) {\n+        struct.set(data$LAYOUT, data$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout udata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"udata\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *udata\n+     * }\n+     *\/\n+    public static final AddressLayout udata$layout() {\n+        return udata$LAYOUT;\n+    }\n+\n+    private static final long udata$OFFSET = $LAYOUT.byteOffset(groupElement(\"udata\"));\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *udata\n+     * }\n+     *\/\n+    public static final long udata$offset() {\n+        return udata$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *udata\n+     * }\n+     *\/\n+    public static MemorySegment udata(MemorySegment struct) {\n+        return struct.get(udata$LAYOUT, udata$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *udata\n+     * }\n+     *\/\n+    public static void udata(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(udata$LAYOUT, udata$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/kevent.java","additions":378,"deletions":0,"binary":false,"changes":378,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.kqueue;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.*;\n+import java.util.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@SuppressWarnings(\"restricted\")\n+public class kqueue_h$shared {\n+\n+    kqueue_h$shared() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    public static final OfBoolean C_BOOL = (OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n+    public static final OfByte C_CHAR =(OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n+    public static final OfShort C_SHORT = (OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n+    public static final OfInt C_INT = (OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n+    public static final OfLong C_LONG_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n+    public static final OfFloat C_FLOAT = (OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n+    public static final OfDouble C_DOUBLE = (OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n+    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n+    public static final OfLong C_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n+\n+    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+    static void traceDowncall(String name, Object... args) {\n+         String traceArgs = Arrays.stream(args)\n+                       .map(Object::toString)\n+                       .collect(Collectors.joining(\", \"));\n+         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n+    }\n+\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemoryLayout align(MemoryLayout layout, long align) {\n+        return switch (layout) {\n+            case PaddingLayout p -> p;\n+            case ValueLayout v -> v.withByteAlignment(align);\n+            case GroupLayout g -> {\n+                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n+                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n+                yield g instanceof StructLayout ?\n+                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n+            }\n+            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n+        };\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/kqueue_h$shared.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.kqueue;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.*;\n+\n+@SuppressWarnings(\"restricted\")\n+public class kqueue_h extends kqueue_h$shared {\n+\n+    kqueue_h() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n+\n+    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n+            .or(Linker.nativeLinker().defaultLookup());\n+\n+    private static final int EV_ADD = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EV_ADD 1\n+     * }\n+     *\/\n+    public static int EV_ADD() {\n+        return EV_ADD;\n+    }\n+    private static final int EV_DELETE = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EV_DELETE 2\n+     * }\n+     *\/\n+    public static int EV_DELETE() {\n+        return EV_DELETE;\n+    }\n+    private static final int EV_ONESHOT = (int)16L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EV_ONESHOT 16\n+     * }\n+     *\/\n+    public static int EV_ONESHOT() {\n+        return EV_ONESHOT;\n+    }\n+    private static final int EV_CLEAR = (int)32L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EV_CLEAR 32\n+     * }\n+     *\/\n+    public static int EV_CLEAR() {\n+        return EV_CLEAR;\n+    }\n+\n+    private static class kqueue {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            kqueue_h.C_INT    );\n+\n+        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"kqueue\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int kqueue()\n+     * }\n+     *\/\n+    public static FunctionDescriptor kqueue$descriptor() {\n+        return kqueue.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int kqueue()\n+     * }\n+     *\/\n+    public static MethodHandle kqueue$handle() {\n+        return kqueue.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * int kqueue()\n+     * }\n+     *\/\n+    public static MemorySegment kqueue$address() {\n+        return kqueue.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int kqueue()\n+     * }\n+     *\/\n+    public static int kqueue() {\n+        var mh$ = kqueue.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"kqueue\");\n+            }\n+            return (int)mh$.invokeExact();\n+        } catch (Error | RuntimeException ex) {\n+           throw ex;\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class kevent {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            kqueue_h.C_INT,\n+            kqueue_h.C_INT,\n+            kqueue_h.C_POINTER,\n+            kqueue_h.C_INT,\n+            kqueue_h.C_POINTER,\n+            kqueue_h.C_INT,\n+            kqueue_h.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"kevent\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)\n+     * }\n+     *\/\n+    public static FunctionDescriptor kevent$descriptor() {\n+        return kevent.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)\n+     * }\n+     *\/\n+    public static MethodHandle kevent$handle() {\n+        return kevent.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)\n+     * }\n+     *\/\n+    public static MemorySegment kevent$address() {\n+        return kevent.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)\n+     * }\n+     *\/\n+    public static int kevent(int kq, MemorySegment changelist, int nchanges, MemorySegment eventlist, int nevents, MemorySegment timeout) {\n+        var mh$ = kevent.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"kevent\", kq, changelist, nchanges, eventlist, nevents, timeout);\n+            }\n+            return (int)mh$.invokeExact(kq, changelist, nchanges, eventlist, nevents, timeout);\n+        } catch (Error | RuntimeException ex) {\n+           throw ex;\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    private static final int EVFILT_READ = (int)-1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EVFILT_READ -1\n+     * }\n+     *\/\n+    public static int EVFILT_READ() {\n+        return EVFILT_READ;\n+    }\n+    private static final int EVFILT_WRITE = (int)-2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EVFILT_WRITE -2\n+     * }\n+     *\/\n+    public static int EVFILT_WRITE() {\n+        return EVFILT_WRITE;\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/kqueue_h.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Defines native structures for Kqueue socket APIs.\n+ * Generated with the following jextract command:\n+ * {@snippet lang = \"Shell Script\":\n+ *\n+ *  HEADER_NAME=kqueue.h\n+ *   echo \"#include <sys\/types.h> \" > $HEADER_NAME\n+ *   echo \"#include <sys\/event.h>\" >> $HEADER_NAME\n+ *\n+ *\n+ * jextract --target-package jdk.internal.ffi.generated.kqueue \\\n+ *    --include-constant EV_CLEAR \\\n+ *    --include-constant EV_ONESHOT \\\n+ *    --include-constant EV_DELETE \\\n+ *    --include-constant EV_ADD \\\n+ *    --include-constant EVFILT_WRITE \\\n+ *    --include-constant EVFILT_READ \\\n+ *    --include-function kevent \\\n+ *    --include-function kqueue \\\n+ *    --include-struct kevent \\\n+ *    $HEADER_NAME\n+ * }\n+ *\n+ *\/\n+\n+package jdk.internal.ffi.generated.kqueue;\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/package-info.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Defines native structures for timespec APIs.\n+ * Generated with the following jextract command:\n+ * {@snippet lang = \"Shell Script\":\n+ *\n+ * HEADER_NAME=timespec.h\n+ * echo \"#include <time.h>\" > $HEADER_NAME\n+ *\n+ * jextract --target-package jdk.internal.ffi.generated.timespec \\\n+ *    --include-struct timespec \\\n+ *    $HEADER_NAME\n+ * }\n+ *\n+ *\/\n+\n+package jdk.internal.ffi.generated.timespec;\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/timespec\/package-info.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.timespec;\n+\n+import java.lang.foreign.*;\n+import java.util.function.*;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct timespec {\n+ *     __darwin_time_t tv_sec;\n+ *     long tv_nsec;\n+ * }\n+ * }\n+ *\/\n+@SuppressWarnings(\"restricted\")\n+public class timespec {\n+\n+    timespec() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        timespec_h.C_LONG.withName(\"tv_sec\"),\n+        timespec_h.C_LONG.withName(\"tv_nsec\")\n+    ).withName(\"timespec\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfLong tv_sec$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"tv_sec\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * __darwin_time_t tv_sec\n+     * }\n+     *\/\n+    public static final OfLong tv_sec$layout() {\n+        return tv_sec$LAYOUT;\n+    }\n+\n+    private static final long tv_sec$OFFSET = $LAYOUT.byteOffset(groupElement(\"tv_sec\"));\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * __darwin_time_t tv_sec\n+     * }\n+     *\/\n+    public static final long tv_sec$offset() {\n+        return tv_sec$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * __darwin_time_t tv_sec\n+     * }\n+     *\/\n+    public static long tv_sec(MemorySegment struct) {\n+        return struct.get(tv_sec$LAYOUT, tv_sec$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * __darwin_time_t tv_sec\n+     * }\n+     *\/\n+    public static void tv_sec(MemorySegment struct, long fieldValue) {\n+        struct.set(tv_sec$LAYOUT, tv_sec$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfLong tv_nsec$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"tv_nsec\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * long tv_nsec\n+     * }\n+     *\/\n+    public static final OfLong tv_nsec$layout() {\n+        return tv_nsec$LAYOUT;\n+    }\n+\n+    private static final long tv_nsec$OFFSET = $LAYOUT.byteOffset(groupElement(\"tv_nsec\"));\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * long tv_nsec\n+     * }\n+     *\/\n+    public static final long tv_nsec$offset() {\n+        return tv_nsec$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * long tv_nsec\n+     * }\n+     *\/\n+    public static long tv_nsec(MemorySegment struct) {\n+        return struct.get(tv_nsec$LAYOUT, tv_nsec$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * long tv_nsec\n+     * }\n+     *\/\n+    public static void tv_nsec(MemorySegment struct, long fieldValue) {\n+        struct.set(tv_nsec$LAYOUT, tv_nsec$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/timespec\/timespec.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.timespec;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.*;\n+import java.util.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@SuppressWarnings(\"restricted\")\n+public class timespec_h$shared {\n+\n+    timespec_h$shared() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    public static final OfBoolean C_BOOL = (OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n+    public static final OfByte C_CHAR =(OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n+    public static final OfShort C_SHORT = (OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n+    public static final OfInt C_INT = (OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n+    public static final OfLong C_LONG_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n+    public static final OfFloat C_FLOAT = (OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n+    public static final OfDouble C_DOUBLE = (OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n+    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n+    public static final OfLong C_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n+\n+    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+    static void traceDowncall(String name, Object... args) {\n+         String traceArgs = Arrays.stream(args)\n+                       .map(Object::toString)\n+                       .collect(Collectors.joining(\", \"));\n+         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n+    }\n+\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemoryLayout align(MemoryLayout layout, long align) {\n+        return switch (layout) {\n+            case PaddingLayout p -> p;\n+            case ValueLayout v -> v.withByteAlignment(align);\n+            case GroupLayout g -> {\n+                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n+                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n+                yield g instanceof StructLayout ?\n+                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n+            }\n+            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n+        };\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/timespec\/timespec_h$shared.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.timespec;\n+\n+import java.lang.foreign.*;\n+\n+public class timespec_h extends timespec_h$shared {\n+\n+    timespec_h() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n+\n+    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n+            .or(Linker.nativeLinker().defaultLookup());\n+\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/timespec\/timespec_h.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"}]}