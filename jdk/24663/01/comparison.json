{"files":[{"patch":"@@ -3112,0 +3112,4 @@\n+Node* BlackholeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -738,0 +738,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344251\n+ * @summary Test that blackhole without control input are removed\n+ * @library \/test\/lib \/\n+ * @run driver compiler.blackhole.DeadBhElimination\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class DeadBhElimination {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+                \"-XX:-TieredCompilation\",\n+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \/\/ Prevent the dead branches to be compiled into an uncommon trap\n+                \/\/ instead of generating a BlackholeNode.\n+                \"-XX:PerMethodTrapLimit=0\",\n+                \"-XX:PerMethodSpecTrapLimit=0\",\n+                \"-XX:CompileCommand=blackhole,compiler.blackhole.DeadBhElimination::iAmABlackhole\"\n+        );\n+    }\n+\n+    static public void iAmABlackhole(int x) {}\n+\n+    @Test\n+    @IR(counts = {IRNode.BLACKHOLE, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(failOn = {IRNode.BLACKHOLE}, phase = CompilePhase.FINAL_CODE)\n+    static void removalAfterLoopOpt() {\n+        int a = 77;\n+        int b = 0;\n+        do {\n+            a--;\n+            b++;\n+        } while (a > 0);\n+        \/\/ b == 77, known after first loop opts round\n+        \/\/ loop is detected as empty loop\n+\n+        if(b == 78) { \/\/ dead\n+            iAmABlackhole(a);\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/DeadBhElimination.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -2710,0 +2710,5 @@\n+    public static final String BLACKHOLE = PREFIX + \"BLACKHOLE\" + POSTFIX;\n+    static {\n+        fromBeforeRemoveUselessToFinalCode(BLACKHOLE, \"Blackhole\");\n+    }\n+\n@@ -2836,0 +2841,7 @@\n+    private static void fromBeforeRemoveUselessToFinalCode(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                CompilePhase.BEFORE_REMOVEUSELESS,\n+                CompilePhase.FINAL_CODE));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}