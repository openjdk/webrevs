{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import org.junit.Assert;\n@@ -37,0 +36,2 @@\n+import static org.junit.Assert.assertArrayEquals;\n+\n@@ -39,0 +40,2 @@\n+    public static final int NUM_COPIES = 100;\n+\n@@ -42,6 +45,3 @@\n-        \/\/ Create some compressed data\n-        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n-        try (GZIPOutputStream out = new GZIPOutputStream(buf)) {\n-            out.write(\"boo\".getBytes(\"ASCII\"));\n-        }\n-        byte[] gz = buf.toByteArray();\n+        \/\/ Create some uncompressed data and then repeat it NUM_COPIES times\n+        byte[] uncompressed1 = \"this is a test\".getBytes(\"ASCII\");\n+        byte[] uncompressedN = repeat(uncompressed1, NUM_COPIES);\n@@ -49,5 +49,3 @@\n-        \/\/ Repeat to build a sequence of concatenated compressed streams\n-        buf.reset();\n-        for(int i = 0; i < 100; i++)\n-            buf.write(gz);\n-        final byte[] gz32 = buf.toByteArray();\n+        \/\/ Compress the original data and then repeat that NUM_COPIES times\n+        byte[] compressed1 = gzip(uncompressed1);\n+        byte[] compressedN = repeat(compressed1, NUM_COPIES);\n@@ -55,2 +53,3 @@\n-        \/\/ (a) Read it back from a stream where available() is accurate\n-        long count1 = countBytes(new GZIPInputStream(new ByteArrayInputStream(gz32)));\n+        \/\/ (a) Read back copied compressed data from a stream where available() is accurate and verify\n+        byte[] readback1 = new GZIPInputStream(new ByteArrayInputStream(compressedN)).readAllBytes();\n+        assertArrayEquals(uncompressedN, readback1);\n@@ -58,2 +57,4 @@\n-        \/\/ (b) Read it back from a stream where available() always returns zero\n-        long count2 = countBytes(new GZIPInputStream(new ZeroAvailableInputStream(new ByteArrayInputStream(gz32))));\n+        \/\/ (b) Read back copied compressed data from a stream where available() always returns zero and verify\n+        byte[] readback2 = new GZIPInputStream(new ZeroAvailableStream(new ByteArrayInputStream(compressedN))).readAllBytes();\n+        assertArrayEquals(uncompressedN, readback2);\n+    }\n@@ -61,2 +62,8 @@\n-        \/\/ They should be the same\n-        Assert.assertEquals(count2, count1);\n+    public static byte[] repeat(byte[] data, int count) {\n+        byte[] repeat = new byte[data.length * count];\n+        int off = 0;\n+        for (int i = 0; i < count; i++) {\n+            System.arraycopy(data, 0, repeat, off, data.length);\n+            off += data.length;\n+        }\n+        return repeat;\n@@ -65,6 +72,6 @@\n-    public long countBytes(InputStream in) throws IOException {\n-        long count = 0;\n-        while (in.read() != -1)\n-            count++;\n-        in.close();\n-        return count;\n+    public static byte[] gzip(byte[] data) throws IOException {\n+        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        try (GZIPOutputStream out = new GZIPOutputStream(buf)) {\n+            out.write(data);\n+        }\n+        return buf.toByteArray();\n@@ -73,2 +80,2 @@\n-    public static class ZeroAvailableInputStream extends FilterInputStream {\n-        public ZeroAvailableInputStream(InputStream in) {\n+    public static class ZeroAvailableStream extends FilterInputStream {\n+        public ZeroAvailableStream(InputStream in) {\n@@ -78,1 +85,1 @@\n-        public int available() throws IOException {\n+        public int available() {\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamAvailable.java","additions":34,"deletions":27,"binary":false,"changes":61,"status":"modified"}]}