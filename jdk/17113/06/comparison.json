{"files":[{"patch":"@@ -39,0 +39,19 @@\n+ * <p>\n+ * The GZIP compressed data format is self-delimiting, i.e., it includes an explicit trailer\n+ * frame that marks the end of the compressed data. Therefore it's possible for the underlying\n+ * input to contain additional data beyond the end of the GZIP data. If that occurs, this class\n+ * will automatically attempt to continue by decoding a new GZIP-compressed data stream.\n+ * In this way, decoding of concatenated GZIP-compressed data streams is supported by default.\n+ *\n+ * <p>\n+ * However, this also means that if the underlying input contains non-GZIP data following\n+ * one or more GZIP-compressed data streams, then this class will read some small portion of\n+ * that non-GZIP data before finally discarding it and returning EOF; or, it may misinterpret\n+ * that data as the start of a new, valid GZIP compressed data stream, before throwing an\n+ * inevitable {@link ZipException} when that turns out not to be the case.\n+ *\n+ * <p>\n+ * Therefore, even though the GZIP compressed data format is self-delimiting, when the GZIP\n+ * compressed data is followed by non-GZIP data this class cannot be relied upon to stop\n+ * reading from the underlying input stream precisely at the last byte of valid GZIP data.\n+ *\n@@ -240,3 +259,0 @@\n-        \/\/ If there are more bytes available in \"in\" or\n-        \/\/ the leftover in the \"inf\" is > 26 bytes:\n-        \/\/ this.trailer(8) + next.header.min(10) + next.trailer(8)\n@@ -244,11 +260,5 @@\n-        if (this.in.available() > 0 || n > 26) {\n-            int m = 8;                  \/\/ this.trailer\n-            try {\n-                m += readHeader(in);    \/\/ next.header\n-            } catch (IOException ze) {\n-                return true;  \/\/ ignore any malformed, do nothing\n-            }\n-            inf.reset();\n-            if (n > m)\n-                inf.setInput(buf, len - n + m, n - m);\n-            return false;\n+        int m = 8;                  \/\/ this.trailer\n+        try {\n+            m += readHeader(in);    \/\/ next.header\n+        } catch (IOException ze) {\n+            return true;  \/\/ ignore any malformed, do nothing\n@@ -256,1 +266,4 @@\n-        return true;\n+        inf.reset();\n+        if (n > m)\n+            inf.setInput(buf, len - n + m, n - m);\n+        return false;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPInputStream.java","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 7036144\n+ * @summary Test concatenated gz streams when available() returns zero\n+ * @run junit GZIPInputStreamAvailable\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+public class GZIPInputStreamAvailable {\n+\n+    public static final int NUM_COPIES = 100;\n+\n+    @Test\n+    public void testZeroAvailable() throws IOException {\n+\n+        \/\/ Create some uncompressed data and then repeat it NUM_COPIES times\n+        byte[] uncompressed1 = \"this is a test\".getBytes(\"ASCII\");\n+        byte[] uncompressedN = repeat(uncompressed1, NUM_COPIES);\n+\n+        \/\/ Compress the original data and then repeat that NUM_COPIES times\n+        byte[] compressed1 = deflate(uncompressed1);\n+        byte[] compressedN = repeat(compressed1, NUM_COPIES);\n+\n+        \/\/ (a) Read back inflated data from a stream where available() is accurate and verify\n+        byte[] readback1 = inflate(new ByteArrayInputStream(compressedN));\n+        assertArrayEquals(uncompressedN, readback1);\n+\n+        \/\/ (b) Read back inflated data from a stream where available() always returns zero and verify\n+        byte[] readback2 = inflate(new ZeroAvailableStream(new ByteArrayInputStream(compressedN)));\n+        assertArrayEquals(uncompressedN, readback2);\n+    }\n+\n+    public static byte[] repeat(byte[] data, int count) {\n+        byte[] repeat = new byte[data.length * count];\n+        int off = 0;\n+        for (int i = 0; i < count; i++) {\n+            System.arraycopy(data, 0, repeat, off, data.length);\n+            off += data.length;\n+        }\n+        return repeat;\n+    }\n+\n+    public static byte[] deflate(byte[] data) throws IOException {\n+        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        try (GZIPOutputStream out = new GZIPOutputStream(buf)) {\n+            out.write(data);\n+        }\n+        return buf.toByteArray();\n+    }\n+\n+    public static byte[] inflate(InputStream in) throws IOException {\n+        return new GZIPInputStream(in).readAllBytes();\n+    }\n+\n+    public static class ZeroAvailableStream extends FilterInputStream {\n+        public ZeroAvailableStream(InputStream in) {\n+            super(in);\n+        }\n+        @Override\n+        public int available() {\n+            return 0;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamAvailable.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}