{"files":[{"patch":"@@ -431,0 +431,17 @@\n+\/\/ return the file name of the backing store file for the named\n+\/\/ shared memory region for the given user name and vmid.\n+\/\/\n+\/\/ the caller is expected to free the allocated memory.\n+\/\/\n+static char* get_sharedmem_filename(const char* dirname, int vmid, int nspid) {\n+\n+  int pid = LINUX_ONLY((nspid == -1) ? vmid : nspid) NOT_LINUX(vmid);\n+\n+  \/\/ add 2 for the file separator and a null terminator.\n+  size_t nbytes = strlen(dirname) + UINT_CHARS + 2;\n+\n+  char* name = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);\n+  snprintf(name, nbytes, \"%s\/%d\", dirname, pid);\n+\n+  return name;\n+}\n@@ -513,1 +530,0 @@\n-  int searchpid;\n@@ -521,3 +537,1 @@\n-  if (nspid == -1) {\n-    searchpid = vmid;\n-  } else {\n+  if (nspid != -1) {\n@@ -526,1 +540,0 @@\n-    searchpid = nspid;\n@@ -528,2 +541,0 @@\n-#else\n-  searchpid = vmid;\n@@ -581,1 +592,0 @@\n-    struct dirent* udentry;\n@@ -583,32 +593,22 @@\n-    while ((udentry = os::readdir(subdirp)) != nullptr) {\n-\n-      if (filename_to_pid(udentry->d_name) == searchpid) {\n-        struct stat statbuf;\n-        int result;\n-\n-        char* filename = NEW_C_HEAP_ARRAY(char,\n-                                          strlen(usrdir_name) + strlen(udentry->d_name) + 2,\n-                                          mtInternal);\n-\n-        strcpy(filename, usrdir_name);\n-        strcat(filename, \"\/\");\n-        strcat(filename, udentry->d_name);\n-\n-        \/\/ don't follow symbolic links for the file\n-        RESTARTABLE(::lstat(filename, &statbuf), result);\n-        if (result == OS_ERR) {\n-           FREE_C_HEAP_ARRAY(char, filename);\n-           continue;\n-        }\n-\n-        \/\/ skip over files that are not regular files.\n-        if (!S_ISREG(statbuf.st_mode)) {\n-          FREE_C_HEAP_ARRAY(char, filename);\n-          continue;\n-        }\n-\n-        \/\/ compare and save filename with latest creation time\n-        if (statbuf.st_size > 0 && statbuf.st_ctime > oldest_ctime) {\n-\n-          if (statbuf.st_ctime > oldest_ctime) {\n-            char* user = strchr(dentry->d_name, '_') + 1;\n+    \/\/ the filename corresponding to the vmid (or nspid)\n+    const char* filename = get_sharedmem_filename(usrdir_name, vmid, nspid);\n+    struct stat statbuf;\n+    int result;\n+    \/\/ check if it exists; don't follow symbolic links for the file\n+    RESTARTABLE(::lstat(filename, &statbuf), result);\n+    if (result == OS_ERR) {\n+      FREE_C_HEAP_ARRAY(char, filename);\n+      FREE_C_HEAP_ARRAY(char, usrdir_name);\n+      os::closedir(subdirp);\n+      continue;\n+    }\n+    \/\/ skip over files that are not regular files.\n+    if (!S_ISREG(statbuf.st_mode)) {\n+      FREE_C_HEAP_ARRAY(char, filename);\n+      FREE_C_HEAP_ARRAY(char, usrdir_name);\n+      os::closedir(subdirp);\n+      continue;\n+    }\n+    FREE_C_HEAP_ARRAY(char, filename);\n+    \/\/ compare and save filename with latest creation time\n+    if (statbuf.st_size > 0 && statbuf.st_ctime > oldest_ctime) {\n@@ -616,2 +616,2 @@\n-            FREE_C_HEAP_ARRAY(char, oldest_user);\n-            oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);\n+      if (statbuf.st_ctime > oldest_ctime) {\n+        char* user = strchr(dentry->d_name, '_') + 1;\n@@ -619,4 +619,2 @@\n-            strcpy(oldest_user, user);\n-            oldest_ctime = statbuf.st_ctime;\n-          }\n-        }\n+        FREE_C_HEAP_ARRAY(char, oldest_user);\n+        oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);\n@@ -624,1 +622,2 @@\n-        FREE_C_HEAP_ARRAY(char, filename);\n+        strcpy(oldest_user, user);\n+        oldest_ctime = statbuf.st_ctime;\n@@ -627,0 +626,1 @@\n+    \/\/ done with this sub-directory, move on to next eligible one\n@@ -652,19 +652,0 @@\n-\/\/ return the file name of the backing store file for the named\n-\/\/ shared memory region for the given user name and vmid.\n-\/\/\n-\/\/ the caller is expected to free the allocated memory.\n-\/\/\n-static char* get_sharedmem_filename(const char* dirname, int vmid, int nspid) {\n-\n-  int pid = LINUX_ONLY((nspid == -1) ? vmid : nspid) NOT_LINUX(vmid);\n-\n-  \/\/ add 2 for the file separator and a null terminator.\n-  size_t nbytes = strlen(dirname) + UINT_CHARS + 2;\n-\n-  char* name = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);\n-  snprintf(name, nbytes, \"%s\/%d\", dirname, pid);\n-\n-  return name;\n-}\n-\n-\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":47,"deletions":66,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -265,0 +265,16 @@\n+\/\/ return the file name of the backing store file for the named\n+\/\/ shared memory region for the given user name and vmid.\n+\/\/\n+\/\/ the caller is expected to free the allocated memory.\n+\/\/\n+static char* get_sharedmem_filename(const char* dirname, int vmid) {\n+\n+  \/\/ add 2 for the file separator and a null terminator.\n+  size_t nbytes = strlen(dirname) + UINT_CHARS + 2;\n+\n+  char* name = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);\n+  _snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n+\n+  return name;\n+}\n+\n@@ -356,1 +372,0 @@\n-    struct dirent* udentry;\n@@ -358,16 +373,17 @@\n-    while ((udentry = os::readdir(subdirp)) != nullptr) {\n-\n-      if (filename_to_pid(udentry->d_name) == vmid) {\n-        struct stat statbuf;\n-\n-        char* filename = NEW_C_HEAP_ARRAY(char,\n-           strlen(usrdir_name) + strlen(udentry->d_name) + 2, mtInternal);\n-\n-        strcpy(filename, usrdir_name);\n-        strcat(filename, \"\\\\\");\n-        strcat(filename, udentry->d_name);\n-\n-        if (::stat(filename, &statbuf) == OS_ERR) {\n-           FREE_C_HEAP_ARRAY(char, filename);\n-           continue;\n-        }\n+    \/\/ the filename corresponding to the vmid\n+    const char* filename = get_sharedmem_filename(usrdir_name, vmid);\n+    struct stat statbuf;\n+    \/\/ check if it exists\n+    if (::stat(filename, &statbuf) == OS_ERR) {\n+      FREE_C_HEAP_ARRAY(char, filename);\n+      FREE_C_HEAP_ARRAY(char, usrdir_name);\n+      os::closedir(subdirp);\n+      continue;\n+    }\n+    \/\/ skip over files that are not regular files.\n+    if ((statbuf.st_mode & S_IFMT) != S_IFREG) {\n+      FREE_C_HEAP_ARRAY(char, filename);\n+      FREE_C_HEAP_ARRAY(char, usrdir_name);\n+      os::closedir(subdirp);\n+      continue;\n+    }\n@@ -375,5 +391,17 @@\n-        \/\/ skip over files that are not regular files.\n-        if ((statbuf.st_mode & S_IFMT) != S_IFREG) {\n-          FREE_C_HEAP_ARRAY(char, filename);\n-          continue;\n-        }\n+    \/\/ If we found a matching file with a newer creation time, then\n+    \/\/ save the user name. The newer creation time indicates that\n+    \/\/ we found a newer incarnation of the process associated with\n+    \/\/ vmid. Due to the way that Windows recycles pids and the fact\n+    \/\/ that we can't delete the file from the file system namespace\n+    \/\/ until last close, it is possible for there to be more than\n+    \/\/ one hsperfdata file with a name matching vmid (diff users).\n+    \/\/\n+    \/\/ We no longer ignore hsperfdata files where (st_size == 0).\n+    \/\/ In this function, all we're trying to do is determine the\n+    \/\/ name of the user that owns the process associated with vmid\n+    \/\/ so the size doesn't matter. Very rarely, we have observed\n+    \/\/ hsperfdata files where (st_size == 0) and the st_size field\n+    \/\/ later becomes the expected value.\n+    \/\/\n+    if (statbuf.st_ctime > latest_ctime) {\n+      char* user = strchr(dentry->d_name, '_') + 1;\n@@ -381,24 +409,2 @@\n-        \/\/ If we found a matching file with a newer creation time, then\n-        \/\/ save the user name. The newer creation time indicates that\n-        \/\/ we found a newer incarnation of the process associated with\n-        \/\/ vmid. Due to the way that Windows recycles pids and the fact\n-        \/\/ that we can't delete the file from the file system namespace\n-        \/\/ until last close, it is possible for there to be more than\n-        \/\/ one hsperfdata file with a name matching vmid (diff users).\n-        \/\/\n-        \/\/ We no longer ignore hsperfdata files where (st_size == 0).\n-        \/\/ In this function, all we're trying to do is determine the\n-        \/\/ name of the user that owns the process associated with vmid\n-        \/\/ so the size doesn't matter. Very rarely, we have observed\n-        \/\/ hsperfdata files where (st_size == 0) and the st_size field\n-        \/\/ later becomes the expected value.\n-        \/\/\n-        if (statbuf.st_ctime > latest_ctime) {\n-          char* user = strchr(dentry->d_name, '_') + 1;\n-\n-          FREE_C_HEAP_ARRAY(char, latest_user);\n-          latest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);\n-\n-          strcpy(latest_user, user);\n-          latest_ctime = statbuf.st_ctime;\n-        }\n+      FREE_C_HEAP_ARRAY(char, latest_user);\n+      latest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);\n@@ -406,2 +412,2 @@\n-        FREE_C_HEAP_ARRAY(char, filename);\n-      }\n+      strcpy(latest_user, user);\n+      latest_ctime = statbuf.st_ctime;\n@@ -409,0 +415,1 @@\n+    FREE_C_HEAP_ARRAY(char, filename);\n@@ -463,16 +470,0 @@\n-\/\/ return the file name of the backing store file for the named\n-\/\/ shared memory region for the given user name and vmid.\n-\/\/\n-\/\/ the caller is expected to free the allocated memory.\n-\/\/\n-static char* get_sharedmem_filename(const char* dirname, int vmid) {\n-\n-  \/\/ add 2 for the file separator and a null terminator.\n-  size_t nbytes = strlen(dirname) + UINT_CHARS + 2;\n-\n-  char* name = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);\n-  _snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n-\n-  return name;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":55,"deletions":64,"binary":false,"changes":119,"status":"modified"}]}