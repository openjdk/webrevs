{"files":[{"patch":"@@ -691,3 +691,7 @@\n-                ZipPath zpath = dir.resolve(childFileName);\n-                if (filter == null || filter.accept(zpath))\n-                    list.add(zpath);\n+                \/\/ ignore \".\" and \"..\"\n+                if (childFileName != null && !isSelfOrParent(childFileName.getPath())) {\n+                    ZipPath zpath = dir.resolve(childFileName);\n+                    if (filter == null || filter.accept(zpath)) {\n+                        list.add(zpath);\n+                    }\n+                }\n@@ -1960,0 +1964,9 @@\n+    \/\/ Return true if file name is \".\" or \"..\"\n+    private static boolean isSelfOrParent(final byte[] nameAsBytes) {\n+        if (nameAsBytes[0] == '.') {\n+            return (nameAsBytes.length == 1) ||\n+                    (nameAsBytes.length == 2 && nameAsBytes[1] == '.');\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -935,0 +935,4 @@\n+    byte[] getPath() {\n+        return this.path;\n+    }\n+\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import jdk.test.lib.util.JarBuilder;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * @test\n+ * @bug 8251329\n+ * @summary Verify that Files.walkFileTree, on a ZipFileSystem representing a jar file, doesn't end up in an infinite loop\n+ * when the source jar has an entry named \".\"\n+ * @library \/test\/lib\/\n+ * @run testng ZipFSFileWalkTest\n+ *\/\n+public class ZipFSFileWalkTest {\n+\n+    private static final byte[] FILE_CONTENT = \"Hello world!!!\".getBytes(StandardCharsets.UTF_8);\n+\n+    \/**\n+     * Uses {@link Files#walkFileTree(Path, FileVisitor)} to walk a zipfs created on a jar which\n+     * has some entries named \".\" and \"..\". Expects that the walk completes successfully and finds the\n+     * expected content.\n+     *\/\n+    @Test\n+    public void testSingleAndDoubleDotEntries() throws Exception {\n+        final Path jar = Path.of(\"8251329-test.jar\");\n+        final JarBuilder builder = new JarBuilder(jar.toString());\n+        \/\/ add some entries\n+        builder.addEntry(\"d1\/\", new byte[0]);\n+        builder.addEntry(\"d1\/file.txt\", FILE_CONTENT);\n+        \/\/ add the \".\" dir\n+        builder.addEntry(\".\/\", new byte[0]);\n+        \/\/ add the \"..\" dir\n+        builder.addEntry(\"..\/\", new byte[0]);\n+        \/\/ add some other entries\n+        builder.addEntry(\"file.txt\", FILE_CONTENT);\n+        builder.addEntry(\"d2\/\", new byte[0]);\n+        builder.addEntry(\"d3.\/\", new byte[0]);\n+        builder.addEntry(\"d3.\/..file.txt\", FILE_CONTENT);\n+        \/\/ add a \".\" dir under some other dir\n+        builder.addEntry(\"d2\/.\/\", new byte[0]);\n+        builder.addEntry(\"d2\/.\/file.txt\", FILE_CONTENT);\n+        \/\/ add a \"..\" dir under some other dir\n+        builder.addEntry(\"d1\/..\/\", new byte[0]);\n+        builder.addEntry(\"d1\/..\/file.txt\", FILE_CONTENT);\n+        builder.build();\n+        try (final FileSystem fs = FileSystems.newFileSystem(jar)) {\n+            \/\/ walk using the root path and a relative path\n+            final List<Path> walkStartPaths = List.of(\n+                    fs.getRootDirectories().iterator().next(),\n+                    fs.getPath(\".\/\"));\n+            for (final Path walkStartPath : walkStartPaths) {\n+                \/\/ paths are relative to the start path of our tree walk\n+                final Set<String> expectedDirs = new HashSet<>(Set.of(\n+                        walkStartPath.toString(),\n+                        walkStartPath.resolve(\"META-INF\").toString(),\n+                        walkStartPath.resolve(\"d1\").toString(),\n+                        walkStartPath.resolve(\"d2\").toString(),\n+                        walkStartPath.resolve(\"d3.\").toString()));\n+                final Set<String> expectedFiles = new HashSet<>(Set.of(\n+                        walkStartPath.resolve(\"META-INF\/MANIFEST.MF\").toString(),\n+                        walkStartPath.resolve(\"d1\/file.txt\").toString(),\n+                        walkStartPath.resolve(\"file.txt\").toString(),\n+                        walkStartPath.resolve(\"d3.\/..file.txt\").toString()));\n+                final SimpleJarFileVisitor visitor = new SimpleJarFileVisitor(expectedDirs, expectedFiles);\n+                System.out.println(\"Walking file tree starting at \" + walkStartPath + \" of jar \" + jar);\n+                Files.walkFileTree(walkStartPath, visitor);\n+                \/\/ make sure all expected content was found\n+                visitor.assertVisitedAllExpected();\n+            }\n+        }\n+    }\n+\n+    private static final class SimpleJarFileVisitor extends SimpleFileVisitor<Path> {\n+        private final Set<String> expectedDirs;\n+        private final Set<String> expectedFiles;\n+\n+        private SimpleJarFileVisitor(final Set<String> expectedDirs, final Set<String> expectedFiles) {\n+            this.expectedDirs = new HashSet<>(expectedDirs);\n+            this.expectedFiles = new HashSet<>(expectedFiles);\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(final Path dir, final BasicFileAttributes attrs) throws IOException {\n+            if (!expectedDirs.remove(dir.toString())) {\n+                throw new IOException(\"Unexpected directory \" + dir + \" \" + expectedDirs);\n+            }\n+            System.out.println(\"Visited directory \" + dir);\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path file, BasicFileAttributes at) throws IOException {\n+            if (!expectedFiles.remove(file.toString())) {\n+                throw new IOException(\"Unexpected file \" + file);\n+            }\n+            System.out.println(\"Visited file \" + file);\n+            \/\/ the test isn't interested in the manifest file content\n+            if (file.getFileName().toString().equals(\"MANIFEST.MF\")) {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            if (!Arrays.equals(FILE_CONTENT, Files.readAllBytes(file))) {\n+                throw new RuntimeException(\"Unexpected content in file \" + file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        private void assertVisitedAllExpected() {\n+            if (!this.expectedDirs.isEmpty()) {\n+                throw new RuntimeException(\"Missing directories \" + this.expectedDirs);\n+            }\n+            if (!this.expectedFiles.isEmpty()) {\n+                throw new RuntimeException(\"Missing files \" + this.expectedFiles);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/ZipFSFileWalkTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}