{"files":[{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -207,4 +208,1 @@\n-        \/\/ If we have an enclosing layout, drop the alignment check for the accessed element,\n-        \/\/ we check the root layout instead\n-        ValueLayout accessedLayout = enclosing != null ? valueLayout.withByteAlignment(1) : valueLayout;\n-        VarHandle handle = accessedLayout.varHandle();\n+        VarHandle handle = valueLayout.varHandle();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,5 +32,1 @@\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -53,2 +49,4 @@\n-    public void testAccessModes(MemorySegment segment, ValueLayout layout, AccessMode mode) throws Throwable {\n-        VarHandle varHandle = layout.varHandle();\n+    public void testAccessModes(MemorySegment segment, MemoryLayout layout, AccessMode mode) throws Throwable {\n+        VarHandle varHandle = layout instanceof ValueLayout ?\n+                layout.varHandle() :\n+                layout.varHandle(MemoryLayout.PathElement.groupElement(0));\n@@ -56,1 +54,1 @@\n-        boolean compatible = AccessModeKind.supportedModes(layout).contains(AccessModeKind.of(mode));\n+        boolean compatible = AccessModeKind.supportedModes(accessLayout(layout)).contains(AccessModeKind.of(mode));\n@@ -64,1 +62,2 @@\n-            assertTrue(compatible);\n+            assertTrue(compatible ||\n+                    (layout instanceof GroupLayout && segment.maxByteAlignment() < layout.byteAlignment()));\n@@ -68,0 +67,8 @@\n+    static ValueLayout accessLayout(MemoryLayout layout) {\n+        return switch (layout) {\n+            case ValueLayout vl -> vl;\n+            case GroupLayout gl -> accessLayout(gl.memberLayouts().get(0));\n+            default -> throw new IllegalStateException();\n+        };\n+    }\n+\n@@ -148,0 +155,1 @@\n+                layouts.add(MemoryLayout.structLayout(layout.withByteAlignment(align)));\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -40,0 +41,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -60,0 +63,7 @@\n+    static final VarHandle VH_SEQ_INT = bindToZeroOffset(MemoryLayout.sequenceLayout(ELEM_SIZE, JAVA_INT).varHandle(PathElement.sequenceElement()));\n+    static final VarHandle VH_SEQ_INT_UNALIGNED = bindToZeroOffset(MemoryLayout.sequenceLayout(ELEM_SIZE, JAVA_INT.withByteAlignment(1)).varHandle(PathElement.sequenceElement()));\n+\n+    static VarHandle bindToZeroOffset(VarHandle varHandle) {\n+        return MethodHandles.insertCoordinates(varHandle, 1, 0L);\n+    }\n+\n@@ -135,0 +145,17 @@\n+    public int segment_loop_nested() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_SEQ_INT.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_nested_unaligned() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_SEQ_INT_UNALIGNED.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"}]}