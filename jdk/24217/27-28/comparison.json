{"files":[{"patch":"@@ -46,2 +46,19 @@\n-     * There can be at most one Renderer instance at any time. This is to avoid that users accidentally\n-     * render templates to strings, rather than letting them all render together.\n+     * There can be at most one Renderer instance at any time.\n+     *\n+     * When using nested templates, the user of the Template Framework may be tempted to first render\n+     * the nested template to a {@link String}, and then use this {@link String} as a token in an outer\n+     * {@link Template#body}. This would be a bad pattern: the outer and nested {@link Template} would\n+     * be rendered separately, and could not interact. For example, the nested {@link Template} would\n+     * not have access to the scopes of the outer {@link Template}. The inner {@link Template} could\n+     * not access {@link Name}s and {@link Hook}s from the outer {@link Template}. The user might assume\n+     * that the inner {@link Template} has access to the outer {@link Template}, but they would actually\n+     * be separated. This could lead to unexpected behavior or even bugs.\n+     *\n+     * Instead, the user should create a {@link TemplateToken} from the inner {@link Template}, and\n+     * use that {@link TemplateToken} in the {@link Template#body} of the outer {@link Template}.\n+     * This way, the inner and outer {@link Template}s get rendered together, and the inner {@link Template}\n+     * has access to the {@link Name}s and {@link Hook}s of the outer {@link Template}.\n+     *\n+     * The {@link Renderer} instance exists during the whole rendering process. Should the user ever\n+     * attempt to render a nested {@link Template} to a {@link String}, we would detect that there is\n+     * already a {@link Renderer} instance for the outer {@link Template}, and throw a {@link RendererException}.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Renderer.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"}]}