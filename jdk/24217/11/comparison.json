{"files":[{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record AddNameToken(Name name) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/AddNameToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * This class collects code, i.e. {@link String}s or {@link List}s of {@link String}s.\n+ * All the Strings are later collected in a {@link StringBuilder}. If we used a {@link StringBuilder}\n+ * directly to collect the Strings, we could not as easily insert code at an \"earlier\" position, i.e.\n+ * reaching out to a {@link Hook#set}.\n+ *\/\n+sealed interface Code permits Code.Token, Code.CodeList {\n+\n+    record Token(String s) implements Code {\n+        @Override\n+        public void renderTo(StringBuilder builder) {\n+            builder.append(s);\n+        }\n+    }\n+\n+    record CodeList(List<Code> list) implements Code {\n+        @Override\n+        public void renderTo(StringBuilder builder) {\n+            list.forEach(code -> code.renderTo(builder));\n+        }\n+    }\n+\n+    void renderTo(StringBuilder builder);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Code.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * The {@link CodeFrame} represents a frame (i.e. scope) of code, appending {@link Code} to the {@code 'codeList'}\n+ * as {@link Token}s are rendered, and adding names to the {@link NameSet}s as they get defined by {@link Template#define}.\n+ * {@link Hook}s can be added to a frame, which allows code to be inserted at that location later.\n+ * When a {@link Hook} is {@link Hook#set}, this separates the {@link Template} into an outer and inner\n+ * {@link CodeFrame}, ensuring that names that are {@link Template#defineName}'d inside the inner frame\n+ * are only available inside that frame.\n+ *\n+ * <p>\n+ * On the other hand, each {@link TemplateFrame} represents the frame (or scope) of exactly one use of a\n+ * {@link Template}.\n+ *\n+ * <p>\n+ * For simple {@link Template} nesting, the {@link CodeFrame}s and {@link TemplateFrame}s overlap exactly.\n+ * However, when using {@link Hook#insert}, we simply nest {@link TemplateFrame}s, going further \"in\",\n+ * but we jump to an outer {@link CodeFrame}, ensuring that we insert {@link Code} at the outer frame,\n+ * and operating on the names of the outer frame. Once the {@link Hook#insert}ion is complete, we jump\n+ * back to the caller {@link TemplateFrame} and {@link CodeFrame}.\n+ *\/\n+class CodeFrame {\n+    public final CodeFrame parent;\n+    private final List<Code> codeList = new ArrayList<Code>();\n+    private final Map<Hook, Code.CodeList> hookCodeLists = new HashMap<>();\n+\n+    \/**\n+     * The {@link NameSet} is used for variable and fields etc.\n+     *\/\n+    final NameSet names;\n+\n+    private CodeFrame(CodeFrame parent, boolean isTransparentForNames) {\n+        this.parent = parent;\n+        if (parent == null) {\n+            \/\/ NameSet without any parent.\n+            this.names = new NameSet(null);\n+        } else if (isTransparentForNames) {\n+            \/\/ We use the same NameSet as the parent - makes it transparent.\n+            this.names     = parent.names;\n+        } else {\n+            \/\/ New NameSet, to make sure we have a nested scope for the names.\n+            this.names     = new NameSet(parent.names);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a base frame, which has no {@link parent}.\n+     *\/\n+    public static CodeFrame makeBase() {\n+        return new CodeFrame(null, false);\n+    }\n+\n+    \/**\n+     * Creates a normal frame, which has a {@link parent} and which defines an inner\n+     * {@link NameSet}, for the names that are generated inside this frame. Once this\n+     * frame is exited, the name from inside this frame are not available any more.\n+     *\/\n+    public static CodeFrame make(CodeFrame parent) {\n+        return new CodeFrame(parent, false);\n+    }\n+\n+    \/**\n+     * Creates a special frame, which has a {@link parent} and but uses the {@link NameSet}\n+     * from the parent frame, allowing {@link Template#defineName} to persist in the outer\n+     * frame when the current frame is exited. This is necessary for {@link Hook#insert},\n+     * where we would possibly want to make field or variable definitions during the insertion\n+     * that are not just local to the insertion but affect the {@link CodeFrame} that we\n+     * {@link Hook#set} earlier and are now {@link Hook#insert}ing into.\n+     *\/\n+    public static CodeFrame makeTransparentForNames(CodeFrame parent) {\n+        return new CodeFrame(parent, true);\n+    }\n+\n+    void addString(String s) {\n+        codeList.add(new Code.Token(s));\n+    }\n+\n+    void addCode(Code code) {\n+        codeList.add(code);\n+    }\n+\n+    void addHook(Hook hook) {\n+        if (hasHook(hook)) {\n+            \/\/ This should never happen, as we add a dedicated CodeFrame for each hook.\n+            throw new RuntimeException(\"Internal error: Duplicate Hook in CodeFrame: \" + hook.name());\n+        }\n+        hookCodeLists.put(hook, new Code.CodeList(new ArrayList<Code>()));\n+    }\n+\n+    boolean hasHook(Hook hook) {\n+        return hookCodeLists.containsKey(hook);\n+    }\n+\n+    CodeFrame codeFrameForHook(Hook hook) {\n+        CodeFrame current = this;\n+        while (current != null) {\n+            if (current.hasHook(hook)) {\n+                return current;\n+            }\n+            current = current.parent;\n+        }\n+        return null;\n+    }\n+\n+    void addName(Name name) {\n+        names.add(name);\n+    }\n+\n+    long weighNames(Name.Type type, boolean onlyMutable) {\n+        return names.weight(type, onlyMutable);\n+    }\n+\n+    Name sampleName(Name.Type type, boolean onlyMutable) {\n+        return names.sample(type, onlyMutable);\n+    }\n+\n+    Code getCode() {\n+        return new Code.CodeList(codeList);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/CodeFrame.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * {@link Hook}s can be {@link #set} for a certain scope in a {@link Template}, and all nested\n+ * {@link Template}s in this scope, and then from within this scope, any {@link Template} can\n+ * {@link #insert} code to where the {@link Hook} was {@link #set}. This can be useful to reach\n+ * \"back\" or to some outer scope, e.g. while generating code for a method, one can reach out\n+ * to the class scope to insert fields.\n+ *\n+ * Example:\n+ * {@snippet lang=java :\n+ * var myHook = new Hook(\"MyHook\");\n+ *\n+ * var template1 = Template.make(\"name\", (String name) -> body(\n+ *     \"\"\"\n+ *     public static int #name = 42;\n+ *     \"\"\"\n+ * ));\n+ *\n+ * var template2 = Template.make(() -> body(\n+ *     \"\"\"\n+ *     public class Test {\n+ *     \"\"\",\n+ *     \/\/ Set the hook here.\n+ *     myHook.set(\n+ *         \"\"\"\n+ *         public static void main(String[] args) {\n+ *         System.out.println(\"$field: \" + $field)\n+ *         \"\"\",\n+ *         \/\/ Reach out to where the hook was set, and insert the code of template1.\n+ *         myHook.insert(template1.withArgs($(\"field\"))),\n+ *         \"\"\"\n+ *         }\n+ *         \"\"\"\n+ *     ),\n+ *     \"\"\"\n+ *     }\n+ *     \"\"\"\n+ * ));\n+ * }\n+ *\n+ * @param name The name of the Hook, for debugging purposes only.\n+ *\/\n+public record Hook(String name) {\n+    \/**\n+     * Set this {@link Hook} for the scope of the provided {@code 'tokens'}.\n+     * From anywhere inside this scope, even in nested {@link Template}s, code can be\n+     * {@link #insert}ed back to the location where this {@link Hook} was {@link #set}.\n+     *\n+     * @param tokens A list of tokens, which have the same restrictions as {@link Template#body}.\n+     * @return A {@link Token} that captures the setting of the scope and the list of validated {@link Token}s.\n+     *\/\n+    public Token set(Object... tokens) {\n+        return new HookSetToken(this, Token.parse(tokens));\n+    }\n+\n+    \/**\n+     * Inserts a {@link TemplateWithArgs} to the innermost location where this {@link Hook} was {@link #set}.\n+     * This could be in the same {@link Template}, or one nested further out.\n+     *\n+     * @param templateWithArgs The {@link Template} with applied arguments to be inserted at the {@link Hook}.\n+     * @return The {@link Token} which when used inside a {@link Template#body} performs the code insertion into the {@link Hook}.\n+     *\/\n+    public Token insert(TemplateWithArgs templateWithArgs) {\n+        return new HookInsertToken(this, templateWithArgs);\n+    }\n+\n+    \/**\n+     * Checks if the {@link Hook} was {@link Hook#set} for the current scope or an outer scope.\n+     *\n+     * @return If the {@link Hook} was {@link Hook#set} for the current scope or an outer scope.\n+     *\/\n+    public boolean isSet() {\n+        return Renderer.getCurrent().isSet(this);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Hook.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record HookInsertToken(Hook hook, TemplateWithArgs templateWithArgs) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookInsertToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+record HookSetToken(Hook hook, List<Token> tokens) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookSetToken.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * {@link Name}s represent things like fields and local variables, or even method names that can be\n+ * added to a code scope with {@link Template#addName} and sampled with {@link Template#sampleName},\n+ * according to the {@code 'weight'} of each {@link Name}. Every {@link Name} has a {@link Name.Type},\n+ * so that sampling can be restricted to these types, or subtypes, defined by {@link Name.Type#isSubtypeOf}.\n+ *\n+ * @param name The {@link String} name used in code.\n+ * @param type The type with which we restrict {@link Template#weighNames} and {@link Template#sampleName}.\n+ * @param mutable Defines if the name is considered mutable or immutable.\n+ * @param weight The weight measured by {@link Template#weighNames} and according to which we sample with {@link Template#sampleName}.\n+ *\/\n+public record Name(String name, Name.Type type, boolean mutable, int weight) {\n+\n+    \/**\n+     * Creates a new {@link Name}.\n+     *\/\n+    public Name {\n+        if (0 >= weight || weight > 1000) {\n+            throw new IllegalArgumentException(\"Unexpected weight: \" + weight);\n+        }\n+    }\n+\n+    \/**\n+     * The interface for the type of a {@link Name}.\n+     *\/\n+    public interface Type {\n+        \/**\n+         * The name of the type, that can be used in code.\n+         *\n+         * @return The {@link String} representation of the type, that can be used in code.\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Defines the subtype relationship with other types, which is used to filter {@link Name}s\n+         * in {@link Template#weighNames} and {@link Template#sampleName}.\n+         *\n+         * @param other The other type, where we check if it is the supertype of {@code 'this'}.\n+         * @return If {@code 'this'} is a subtype of {@code 'other'}.\n+         *\/\n+        boolean isSubtypeOf(Type other);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Name.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * The {@link NameSet} defines a set of {@link Name}s (e.g. fields or variable names). They extend the\n+ * set of the {@code 'parent'} set.\n+ *\/\n+class NameSet {\n+    static final Random RANDOM = Utils.getRandomInstance();\n+\n+    private final NameSet parent;\n+    private final List<Name> names = new ArrayList<>();\n+\n+    NameSet(NameSet parent) {\n+        this.parent = parent;\n+    }\n+\n+    private long localWeight(Name.Type type, boolean onlyMutable) {\n+        long sum = 0;\n+        for (var name : names) {\n+            if (name.type().isSubtypeOf(type) && (name.mutable() || !onlyMutable)) {\n+                sum += name.weight();\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    public long weight(Name.Type type, boolean onlyMutable) {\n+        long w = localWeight(type, onlyMutable);\n+        if (parent != null) { w += parent.weight(type, onlyMutable); }\n+        return w;\n+    }\n+\n+    \/**\n+     * Randomly sample a name from this set or a parent set, restricted to the specified type.\n+     *\/\n+    public Name sample(Name.Type type, boolean onlyMutable) {\n+        long w = weight(type, onlyMutable);\n+        if (w <= 0) {\n+            throw new RendererException(\"No variable of type '\" + type.toString() + \"'.\");\n+        }\n+\n+        long r = RANDOM.nextLong(w);\n+        return sample(type, onlyMutable, r);\n+    }\n+\n+    private Name sample(Name.Type type, boolean onlyMutable, long r) {\n+        for (var name : names) {\n+            if (name.type().isSubtypeOf(type) && (name.mutable() || !onlyMutable)) {\n+                r -= name.weight();\n+                if (r < 0) { return name; }\n+            }\n+        }\n+        return parent.sample(type, onlyMutable, r);\n+    }\n+\n+    \/**\n+     * Add a variable of a specified type to the set.\n+     *\/\n+    public void add(Name name) {\n+        names.add(name);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameSet.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record NothingToken() implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NothingToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+# Template Framework\n+The Template Framework allows the generation of code with Templates. The goal is that these Templates are easy to write, and allow regression tests to cover a larger scope, and to make template based fuzzing easy to extend.\n+\n+We want to make it easy to generate variants of tests. Often, we would like to have a set of tests, corresponding to a set of types, a set of operators, a set of constants, etc. Writing all the tests by hand is cumbersome or even impossible. When generating such tests with scripts, it would be preferable if the code generation happens automatically, and the generator script was checked into the code base. Code generation can go beyond simple regression tests, and one might want to generate random code from a list of possible templates, to fuzz individual Java features and compiler optimizations.\n+\n+The Template Framework provides a facility to generate code with Templates. Templates are essencially a list of tokens that are concatenated (i.e. rendered) to a String. The Templates can have \"holes\", which are filled (replaced) by different values at each Template instantiation. For example, these \"holes\" can be filled with different types, operators or constants. Templates can also be nested, allowing a modular use of Templates.\n+\n+The Template Framework only generates code in the form of a String. This code can then be compiled and executed, for example with the help of the [Compile Framework](..\/compile_framework\/README.md).\n+\n+The basic functionalities of the Template Framework are described in the [Template Interface](.\/Template.java), together with some examples. More examples can be found in [TestSimple.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestSimple.java), [TestAdvanced.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestAdvanced.java) and [TestTutorial.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java).\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/README.md","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * The {@link Renderer} class is used to keep track of the states during a nested\n+ * {@link Template} rendering. There can only be a single {@link Renderer} active\n+ * at any point, since there are static methods that reference {@link Renderer#getCurrent}.\n+ *\n+ * The {@link Renderer} instance keeps track of the current frames,\n+ * see {@link TemplateFrame} and {@link CodeFrame}.\n+ *\/\n+class Renderer {\n+    private static final Pattern DOLLAR_NAME_PATTERN = Pattern.compile(\"\\\\$([a-zA-Z_][a-zA-Z0-9_]*)\");\n+    private static final Pattern HASHTAG_REPLACEMENT_PATTERN = Pattern.compile(\"#([a-zA-Z_][a-zA-Z0-9_]*)\");\n+\n+    \/**\n+     * There can be at most one Renderer instance at any time. This is to avoid that users accidentally\n+     * render templates to strings, rather than letting them all render together.\n+     *\/\n+    private static Renderer renderer = null;\n+\n+    private int nextTemplateFrameId;\n+    private TemplateFrame baseTemplateFrame;\n+    private TemplateFrame currentTemplateFrame;\n+    private CodeFrame baseCodeFrame;\n+    private CodeFrame currentCodeFrame;\n+\n+    \/\/ We do not want any other instances, so we keep it private.\n+    private Renderer(float fuel) {\n+        nextTemplateFrameId = 0;\n+        baseTemplateFrame = TemplateFrame.makeBase(nextTemplateFrameId++, fuel);\n+        currentTemplateFrame = baseTemplateFrame;\n+        baseCodeFrame = CodeFrame.makeBase();\n+        currentCodeFrame = baseCodeFrame;\n+    }\n+\n+    static Renderer getCurrent() {\n+        if (renderer == null) {\n+            throw new RendererException(\"A Template method such as '$' or 'let' was called outside a template rendering.\");\n+        }\n+        return renderer;\n+    }\n+\n+    static String render(TemplateWithArgs templateWithArgs) {\n+        return render(templateWithArgs, Template.DEFAULT_FUEL);\n+    }\n+\n+    static String render(TemplateWithArgs templateWithArgs, float fuel) {\n+        \/\/ Check nobody else is using the Renderer.\n+        if (renderer != null) {\n+            throw new RendererException(\"Nested render not allowed. Please only use 'withArgs' inside Templates, and call 'render' only once at the end.\");\n+        }\n+        try {\n+            renderer = new Renderer(fuel);\n+            renderer.renderTemplateWithArgs(templateWithArgs);\n+            renderer.checkFrameConsistencyAfterRendering();\n+            return renderer.collectCode();\n+        } finally {\n+            \/\/ Release the Renderer.\n+            renderer = null;\n+        }\n+    }\n+\n+    private void checkFrameConsistencyAfterRendering() {\n+        \/\/ Ensure CodeFrame consistency.\n+        if (baseCodeFrame != currentCodeFrame) {\n+            throw new RuntimeException(\"Internal error: Renderer did not end up at base CodeFrame.\");\n+        }\n+        \/\/ Ensure TemplateFrame consistency.\n+        if (baseTemplateFrame != currentTemplateFrame) {\n+            throw new RuntimeException(\"Internal error: Renderer did not end up at base TemplateFrame.\");\n+        }\n+    }\n+\n+    private String collectCode() {\n+        StringBuilder builder = new StringBuilder();\n+        baseCodeFrame.getCode().renderTo(builder);\n+        return builder.toString();\n+    }\n+\n+    String $(String name) {\n+        return currentTemplateFrame.$(name);\n+    }\n+\n+    void addHashtagReplacement(String key, Object value) {\n+        currentTemplateFrame.addHashtagReplacement(key, format(value));\n+    }\n+\n+    private String getHashtagReplacement(String key) {\n+        return currentTemplateFrame.getHashtagReplacement(key);\n+    }\n+\n+    float fuel() {\n+        return currentTemplateFrame.fuel;\n+    }\n+\n+    void setFuelCost(float fuelCost) {\n+        currentTemplateFrame.setFuelCost(fuelCost);\n+    }\n+\n+    long weighNames(Name.Type type, boolean onlyMutable) {\n+        return currentCodeFrame.weighNames(type, onlyMutable);\n+    }\n+\n+    Name sampleName(Name.Type type, boolean onlyMutable) {\n+        return currentCodeFrame.sampleName(type, onlyMutable);\n+    }\n+\n+    \/**\n+     * Formats values to {@link String} with the goal of using them in Java code.\n+     * By default we use the overrides of {@link Object#toString}.\n+     * But for some boxed primitives we need to create a special formatting.\n+     *\/\n+    static String format(Object value) {\n+        return switch (value) {\n+            case String s -> s;\n+            case Integer i -> i.toString();\n+            \/\/ We need to append the \"L\" so that the values are not interpreted as ints,\n+            \/\/ and then javac might complain that the values are too large for an int.\n+            case Long l -> l.toString() + \"L\";\n+            \/\/ Some Float and Double values like Infinity and NaN need a special representation.\n+            case Float f -> formatFloat(f);\n+            case Double d -> formatDouble(d);\n+            default -> value.toString();\n+        };\n+    }\n+\n+    private static String formatFloat(Float f) {\n+        if (Float.isFinite(f)) {\n+            return f.toString() + \"f\";\n+        } else if (f.isNaN()) {\n+            return \"Float.intBitsToFloat(\" + Float.floatToRawIntBits(f) + \" \/* NaN *\/)\";\n+        } else if (f.isInfinite()) {\n+            if (f > 0) {\n+                return \"Float.POSITIVE_INFINITY\";\n+            } else {\n+                return \"Float.NEGATIVE_INFINITY\";\n+            }\n+        } else {\n+            throw new RuntimeException(\"Not handled: \" + f);\n+        }\n+    }\n+\n+    private static String formatDouble(Double d) {\n+        if (Double.isFinite(d)) {\n+            return d.toString();\n+        } else if (d.isNaN()) {\n+            return \"Double.longBitsToDouble(\" + Double.doubleToRawLongBits(d) + \"L \/* NaN *\/)\";\n+        } else if (d.isInfinite()) {\n+            if (d > 0) {\n+                return \"Double.POSITIVE_INFINITY\";\n+            } else {\n+                return \"Double.NEGATIVE_INFINITY\";\n+            }\n+        } else {\n+            throw new RuntimeException(\"Not handled: \" + d);\n+        }\n+    }\n+\n+    private void renderTemplateWithArgs(TemplateWithArgs templateWithArgs) {\n+        TemplateFrame templateFrame = TemplateFrame.make(currentTemplateFrame, nextTemplateFrameId++);\n+        currentTemplateFrame = templateFrame;\n+\n+        templateWithArgs.visitArguments((name, value) -> addHashtagReplacement(name, format(value)));\n+        TemplateBody body = templateWithArgs.instantiate();\n+        renderTokenList(body.tokens());\n+\n+        if (currentTemplateFrame != templateFrame) {\n+            throw new RuntimeException(\"Internal error: TemplateFrame mismatch!\");\n+        }\n+        currentTemplateFrame = currentTemplateFrame.parent;\n+    }\n+\n+    private void renderToken(Token token) {\n+        switch (token) {\n+            case StringToken(String s) -> {\n+                currentCodeFrame.addString(templateString(s));\n+            }\n+            case NothingToken() -> {\n+                \/\/ Nothing.\n+            }\n+            case HookSetToken(Hook hook, List<Token> tokens) -> {\n+                CodeFrame outerCodeFrame = currentCodeFrame;\n+\n+                \/\/ We need a CodeFrame to which the hook can insert code. That way, name\n+                \/\/ definitions at the hook cannot excape the hookCodeFrame.\n+                CodeFrame hookCodeFrame = CodeFrame.make(outerCodeFrame);\n+                hookCodeFrame.addHook(hook);\n+\n+                \/\/ We need a CodeFrame where the tokens can be rendered. That way, name\n+                \/\/ definitions from the tokens cannot escape the innerCodeFrame to the\n+                \/\/ hookCodeFrame.\n+                CodeFrame innerCodeFrame = CodeFrame.make(hookCodeFrame);\n+                currentCodeFrame = innerCodeFrame;\n+\n+                renderTokenList(tokens);\n+\n+                \/\/ Close the hookCodeFrame and innerCodeFrame. hookCodeFrame code comes before the\n+                \/\/ innerCodeFrame code from the tokens.\n+                currentCodeFrame = outerCodeFrame;\n+                currentCodeFrame.addCode(hookCodeFrame.getCode());\n+                currentCodeFrame.addCode(innerCodeFrame.getCode());\n+            }\n+            case HookInsertToken(Hook hook, TemplateWithArgs t) -> {\n+                \/\/ Switch to hook CodeFrame.\n+                CodeFrame callerCodeFrame = currentCodeFrame;\n+                CodeFrame hookCodeFrame = codeFrameForHook(hook);\n+\n+                \/\/ Use a transparent nested CodeFrame. We need a CodeFrame so that the code generated\n+                \/\/ by the TemplateWithArgs can be collected, and hook insertions from it can still\n+                \/\/ be made to the hookCodeFrame before the code from the TemplateWithArgs is added to\n+                \/\/ the hookCodeFrame.\n+                \/\/ But the CodeFrame must be transparent, so that its name definitions go out to\n+                \/\/ the hookCodeFrame, and are not limited to the CodeFrame for the TemplateWithArgs.\n+                currentCodeFrame = CodeFrame.makeTransparentForNames(hookCodeFrame);\n+\n+                renderTemplateWithArgs(t);\n+\n+                hookCodeFrame.addCode(currentCodeFrame.getCode());\n+\n+                \/\/ Switch back from hook CodeFrame to caller CodeFrame.\n+                currentCodeFrame = callerCodeFrame;\n+            }\n+            case TemplateWithArgs t -> {\n+                \/\/ Use a nested CodeFrame.\n+                CodeFrame callerCodeFrame = currentCodeFrame;\n+                currentCodeFrame = CodeFrame.make(currentCodeFrame);\n+\n+                renderTemplateWithArgs(t);\n+\n+                callerCodeFrame.addCode(currentCodeFrame.getCode());\n+                currentCodeFrame = callerCodeFrame;\n+            }\n+            case AddNameToken(Name name) -> {\n+                currentCodeFrame.addName(name);\n+            }\n+        }\n+    }\n+\n+    private void renderTokenList(List<Token> tokens) {\n+        CodeFrame codeFrame = currentCodeFrame;\n+        for (Token t : tokens) {\n+            renderToken(t);\n+        }\n+        if (codeFrame != currentCodeFrame) {\n+            throw new RuntimeException(\"Internal error: CodeFrame mismatch.\");\n+        }\n+    }\n+\n+    private String templateString(String s) {\n+        var temp = DOLLAR_NAME_PATTERN.matcher(s).replaceAll(\n+            (MatchResult result) -> $(result.group(1))\n+        );\n+        return HASHTAG_REPLACEMENT_PATTERN.matcher(temp).replaceAll(\n+            \/\/ We must escape \"$\", because it has a special meaning in replaceAll.\n+            (MatchResult result) -> getHashtagReplacement(result.group(1)).replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\")\n+        );\n+    }\n+\n+    boolean isSet(Hook hook) {\n+        return currentCodeFrame.codeFrameForHook(hook) != null;\n+    }\n+\n+    private CodeFrame codeFrameForHook(Hook hook) {\n+        CodeFrame codeFrame = currentCodeFrame.codeFrameForHook(hook);\n+        if (codeFrame == null) {\n+            throw new RendererException(\"Hook '\" + hook.name() + \"' was referenced but not found!\");\n+        }\n+        return codeFrame;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Renderer.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * This exception is thrown when something goes wrong during {@link Template}\n+ * rendering, or in the use of any of its static methods.\n+ * It most likely indicates a wrong use of the {@link Template}s.\n+ *\/\n+public class RendererException extends RuntimeException {\n+    RendererException(String message) {\n+        super(message);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/RendererException.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record StringToken(String value) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/StringToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,608 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import java.util.List;\n+\n+\/**\n+ * The Template Framework allows the generation of code with Templates. The goal is that these Templates are\n+ * easy to write, and allow regression tests to cover a larger scope, and to make template based fuzzing easy\n+ * to extend.\n+ *\n+ * <p>\n+ * <strong>Motivation:<\/strong> We want to make it easy to generate variants of tests. Often, we would like to\n+ * have a set of tests, corresponding to a set of types, a set of operators, a set of constants, etc. Writing all\n+ * the tests by hand is cumbersome or even impossible. When generating such tests with scripts, it would be\n+ * preferable if the code generation happens automatically, and the generator script was checked into the code\n+ * base. Code generation can go beyond simple regression tests, and one might want to generate random code from\n+ * a list of possible templates, to fuzz individual Java features and compiler optimizations.\n+ *\n+ * <p>\n+ * The Template Framework provides a facility to generate code with Templates. Templates are essencially a list\n+ * of tokens that are concatenated (i.e. rendered) to a String. The Templates can have \"holes\", which are\n+ * filled (replaced) by different values at each Template instantiation. For example, these \"holes\" can\n+ * be filled with different types, operators or constants. Templates can also be nested, allowing a modular\n+ * use of Templates.\n+ *\n+ * <p>\n+ * <strong>Example:<\/strong>\n+ * The following snippets are from the example test {@code TestAdvanced.java}.\n+ * First, we define a template that generates a {@code @Test} method for a given type, operator and\n+ * constant generator. We define two constants {@code con1} and {@code con2}, and then use a multiline\n+ * string with hashtags {@code #} (i.e. \"holes\")  that are then replaced by the template arguments and the\n+ * {@link #let} definitions.\n+ *\n+ * <p>\n+ * {@snippet lang=java :\n+ * var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> body(\n+ *     let(\"con1\", generator.next()),\n+ *     let(\"con2\", generator.next()),\n+ *     \"\"\"\n+ *     \/\/ #typeName #operator #con1 #con2\n+ *     public static #typeName $GOLD = $test();\n+ *\n+ *     @Test\n+ *     public static #typeName $test() {\n+ *         return (#typeName)(#con1 #operator #con2);\n+ *     }\n+ *\n+ *     @Check(test = \"$test\")\n+ *     public static void $check(#typeName result) {\n+ *         Verify.checkEQ(result, $GOLD);\n+ *     }\n+ *     \"\"\"\n+ * ));\n+ * }\n+ *\n+ * <p>\n+ * To get an executable test, we define a Template that produces a class body with a main method. The Template\n+ * takes a list of types, and calls the {@code testTemplate} defined above for each type and operator. We use\n+ * the {@code TestFramework} to call our {@code @Test} methods.\n+ *\n+ * <p>\n+ * {@snippet lang=java :\n+ * var classTemplate = Template.make(\"types\", (List<Type> types) -> body(\n+ *     let(\"classpath\", comp.getEscapedClassPathOfCompiledClasses()),\n+ *     \"\"\"\n+ *     package p.xyz;\n+ *\n+ *     import compiler.lib.ir_framework.*;\n+ *     import compiler.lib.verify.*;\n+ *\n+ *     public class InnerTest {\n+ *         public static void main() {\n+ *             \/\/ Set the classpath, so that the TestFramework test VM knows where\n+ *             \/\/ the CompileFramework put the class files of the compiled source code.\n+ *             TestFramework framework = new TestFramework(InnerTest.class);\n+ *             framework.addFlags(\"-classpath\", \"#classpath\");\n+ *             framework.start();\n+ *         }\n+ *\n+ *     \"\"\",\n+ *     \/\/ Call the testTemplate for each type and operator, generating a\n+ *     \/\/ list of lists of TemplateWithArgs:\n+ *     types.stream().map((Type type) ->\n+ *         type.operators().stream().map((String operator) ->\n+ *             testTemplate.withArgs(type.name(), operator, type.generator())).toList()\n+ *     ).toList(),\n+ *     \"\"\"\n+ *     }\n+ *     \"\"\"\n+ * ));\n+ * }\n+ *\n+ * <p>\n+ * Finally, we generate the list of types, and pass it to the class template:\n+ *\n+ * {@snippet lang=java :\n+ * List<Type> types = List.of(\n+ *     new Type(\"byte\",   GEN_BYTE::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"char\",   GEN_CHAR::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"short\",  GEN_SHORT::next,  List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"int\",    GEN_INT::next,    List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"long\",   GEN_LONG::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"float\",  GEN_FLOAT::next,  List.of(\"+\", \"-\", \"*\", \"\/\")),\n+ *     new Type(\"double\", GEN_DOUBLE::next, List.of(\"+\", \"-\", \"*\", \"\/\"))\n+ * );\n+ *\n+ * \/\/ Use the template with one argument, and render it to a String.\n+ * return classTemplate.withArgs(types).render();\n+ * }\n+ *\n+ * <p>\n+ * Once we rendered the source code to a String, we can compile it with the {@code CompileFramework}.\n+ *\n+ * <p>\n+ * <strong>Details:<\/strong>\n+ * <p>\n+ * A {@link Template} can have zero or more arguments, and for each number of arguments there is an implementation\n+ * (e.g. {@link ZeroArgs} for zero arguments and {@link TwoArgs} for two arguments). This allows the use of Generics\n+ * for the template argument types, i.e. the template arguments can be type checked. Ideally, we would have used\n+ * String Templates to inject these arguments into the strings. But since String Templates are not (yet) available,\n+ * the {@link Template}s provide <strong>hashtag replacements<\/strong> in the Strings: the {@link Template} argument\n+ * names are captured, and the argument values automatically replace any {@code \"#name\"} in the Strings. See the\n+ * different overloads of {@link #make} for examples. Additional hashtag replacements can be defined\n+ * with {@link #let}.\n+ *\n+ * <p>\n+ * When using nested {@link Template}s, there can be collisions with identifiers (e.g. variable names and method names).\n+ * For this, {@link Template}s provide <strong>dollar replacements<\/strong>, which automaticall rename any\n+ * {@code \"$name\"} in the String with a {@code \"name_ID\"}, where the {@code \"ID\"} is unique for every use of\n+ * a {@link Template}. The dollar replacement can also be captured with {@link #$}, and passed to nested\n+ * {@link Template}s, which allows sharing of these identifier names between {@link Template}s.\n+ *\n+ * <p>\n+ * To render a {@link Template} to a {@link String}, one first has to apply the arguments (e.g. with\n+ * {@link TwoArgs#withArgs}) and then the resulting {@link TemplateWithArgs} can either be used as a\n+ * {@link Token} inside another {@link Template}, or rendered to a {@link String} with {@link TemplateWithArgs#render}.\n+ *\n+ * <p>\n+ * A {@link TemplateWithArgs} can be used directly as a {@link Token} inside the {@link Template#body} to\n+ * nest the {@link Template}s. Alternatively, code can be {@link Hook#insert}ed to where a {@link Hook}\n+ * was {@link Hook#set} earlier (in some outer scope of the code). For example, while generating code in\n+ * a method, one can reach out to the scope of the class, and insert a new field, or define a utility method.\n+ *\n+ * <p>\n+ * A {@link TemplateBinding} allows the recursive use of {@link Template}s. With the indirection of such a binding,\n+ * a {@link Template} can reference itself. To ensure the termination of recursion, the templates are rendered\n+ * with a certain amount of {@link #fuel}, which is decreased at each {@link Template} nesting by a certain amount\n+ * (can be changed with {@link #setFuelCost}). Recursive templates are supposed to terminate once the {@link #fuel}\n+ * is depleted (i.e. reaches zero).\n+ *\n+ * <p>\n+ * Code generation often involves defining fields and variables, which are then available inside a defined\n+ * scope, and can be sampled in any nested scope. To allow the use of names for multiple applications (e.g.\n+ * fields, variables, methods, etc.), we define a {@link Name}, which captures the {@link String} representation\n+ * to be used in code, as well as its type and if it is mutable. One can add such a {@link Name} to the\n+ * current code scope with {@link #addName}, and sample from the current or outer scopes with {@link #sampleName}.\n+ * When generating code, one might want to create {@link Name}s (variables, fields, etc.) in local scope, or\n+ * in some outer scope with the use of {@link Hook}s.\n+ *\n+ * <p>\n+ * More examples for these functionalities can be found in {@link TestTutorial}, {@link TestSimple}, and\n+ * {@link TestAdvanced}.\n+ *\/\n+public interface Template {\n+\n+    \/**\n+     * Creates a {@link Template} with no arguments.\n+     * See {@link #body} for more details about how to construct a {@link Template} with {@link Token}s.\n+     *\n+     * <p>\n+     * Example:\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> body(\n+     *     \"\"\"\n+     *     Multi-line string or other tokens.\n+     *     \"\"\"\n+     * ));\n+     * }\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @return A {@link Template} with zero arguments.\n+     *\/\n+    static ZeroArgs make(Supplier<TemplateBody> body) {\n+        return new ZeroArgs(body);\n+    }\n+\n+    \/**\n+     * Creates a {@link Template} with one argument.\n+     * See {@link #body} for more details about how to construct a {@link Template} with {@link Token}s.\n+     *\n+     * <p>\n+     * Here an example with template argument {@code 'a'}, captured once as string name\n+     * for use in hashtag replacements, and captured once as lambda argument with the corresponding type\n+     * of the generic argument.\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", (Integer a) -> body(\n+     *     \"\"\"\n+     *     Multi-line string or other tokens.\n+     *     We can use the hashtag replacement #a to directly insert the String value of a.\n+     *     \"\"\",\n+     *     \"We can also use the captured parameter of a: \" + a\n+     * ));\n+     * }\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param <A> Type of the (first) argument.\n+     * @param arg0Name The name of the (first) argument for hashtag replacement.\n+     * @return A {@link Template} with one argument.\n+     *\/\n+    static <A> OneArgs<A> make(String arg0Name, Function<A, TemplateBody> body) {\n+        return new OneArgs<>(arg0Name, body);\n+    }\n+\n+    \/**\n+     * Creates a {@link Template} with two arguments.\n+     * See {@link #body} for more details about how to construct a {@link Template} with {@link Token}s.\n+     *\n+     * <p>\n+     * Here an example with template arguments {@code 'a'} and {@code 'b'}, captured once as string names\n+     * for use in hashtag replacements, and captured once as lambda arguments with the corresponding types\n+     * of the generic arguments.\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", \"b\", (Integer a, String b) -> body(\n+     *     \"\"\"\n+     *     Multi-line string or other tokens.\n+     *     We can use the hashtag replacement #a and #b to directly insert the String value of a and b.\n+     *     \"\"\",\n+     *     \"We can also use the captured parameter of a and b: \" + a + \" and \" + b\n+     * ));\n+     * }\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param <A> Type of the first argument.\n+     * @param arg0Name The name of the first argument for hashtag replacement.\n+     * @param <B> Type of the second argument.\n+     * @param arg1Name The name of the second argument for hashtag replacement.\n+     * @return A {@link Template} with two arguments.\n+     *\/\n+    static <A, B> TwoArgs<A, B> make(String arg0Name, String arg1Name, BiFunction<A, B, TemplateBody> body) {\n+        return new TwoArgs<>(arg0Name, arg1Name, body);\n+    }\n+\n+    \/**\n+     * Interface for function with three arguments.\n+     *\n+     * @param <T> Type of the first argument.\n+     * @param <U> Type of the second argument.\n+     * @param <V> Type of the third argument.\n+     * @param <R> Type of the return value.\n+     *\/\n+    @FunctionalInterface\n+    public interface TriFunction<T, U, V, R> {\n+\n+        \/**\n+         * Function definition for the three argument functions.\n+         *\n+         * @param t The first argument.\n+         * @param u The second argument.\n+         * @param v The third argument.\n+         * @return Return value of the three argument function.\n+         *\/\n+        R apply(T t, U u, V v);\n+    }\n+\n+    \/**\n+     * Creates a {@link Template} with three arguments.\n+     * See {@link #body} for more details about how to construct a {@link Template} with {@link Token}s.\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param <A> Type of the first argument.\n+     * @param arg0Name The name of the first argument for hashtag replacement.\n+     * @param <B> Type of the second argument.\n+     * @param arg1Name The name of the second argument for hashtag replacement.\n+     * @param <C> Type of the third argument.\n+     * @param arg2Name The name of the third argument for hashtag replacement.\n+     * @return A {@link Template} with three arguments.\n+     *\/\n+    static <A, B, C> ThreeArgs<A, B, C> make(String arg0Name, String arg1Name, String arg2Name, TriFunction<A, B, C, TemplateBody> body) {\n+        return new ThreeArgs<>(arg0Name, arg1Name, arg2Name, body);\n+    }\n+\n+    \/**\n+     * A {@link Template} with no arguments.\n+     *\n+     * @param function The {@link Supplier} that creates the {@link TemplateBody}.\n+     *\/\n+    record ZeroArgs(Supplier<TemplateBody> function) implements Template {\n+        TemplateBody instantiate() {\n+            return function.get();\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateWithArgs} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation, and it can also be used with\n+         * {@link TemplateWithArgs#render} to render the template to a {@link String}\n+         * directly.\n+         *\n+         * @return The template all (zero) arguments applied.\n+         *\/\n+        public TemplateWithArgs withArgs() {\n+            return new TemplateWithArgs.ZeroArgsUse(this);\n+        }\n+    }\n+\n+\n+    \/**\n+     * A {@link Template} with one argument.\n+     *\n+     * @param arg0Name The name of the (first) argument, used for hashtag replacements in the {@link Template}.\n+     * @param <A> The type of the (first) argument.\n+     * @param function The {@link Function} that creates the {@link TemplateBody} given the template argument.\n+     *\/\n+    record OneArgs<A>(String arg0Name, Function<A, TemplateBody> function) implements Template {\n+        TemplateBody instantiate(A a) {\n+            return function.apply(a);\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateWithArgs} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation, and it can also be used with\n+         * {@link TemplateWithArgs#render} to render the template to a {@link String}\n+         * directly.\n+         *\n+         * @param a The value for the (first) argument.\n+         * @return The template its argument applied.\n+         *\/\n+        public TemplateWithArgs withArgs(A a) {\n+            return new TemplateWithArgs.OneArgsUse<>(this, a);\n+        }\n+    }\n+\n+    \/**\n+     * A {@link Template} with two arguments.\n+     *\n+     * @param arg0Name The name of the first argument, used for hashtag replacements in the {@link Template}.\n+     * @param arg1Name The name of the second argument, used for hashtag replacements in the {@link Template}.\n+     * @param <A> The type of the first argument.\n+     * @param <B> The type of the second argument.\n+     * @param function The {@link BiFunction} that creates the {@link TemplateBody} given the template arguments.\n+     *\/\n+    record TwoArgs<A, B>(String arg0Name, String arg1Name,\n+                         BiFunction<A, B, TemplateBody> function) implements Template {\n+        TemplateBody instantiate(A a, B b) {\n+            return function.apply(a, b);\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateWithArgs} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation, and it can also be used with\n+         * {@link TemplateWithArgs#render} to render the template to a {@link String}\n+         * directly.\n+         *\n+         * @param a The value for the first argument.\n+         * @param b The value for the second argument.\n+         * @return The template all (two) arguments applied.\n+         *\/\n+        public TemplateWithArgs withArgs(A a, B b) {\n+            return new TemplateWithArgs.TwoArgsUse<>(this, a, b);\n+        }\n+    }\n+\n+    \/**\n+     * A {@link Template} with three arguments.\n+     *\n+     * @param arg0Name The name of the first argument, used for hashtag replacements in the {@link Template}.\n+     * @param arg1Name The name of the second argument, used for hashtag replacements in the {@link Template}.\n+     * @param arg2Name The name of the third argument, used for hashtag replacements in the {@link Template}.\n+     * @param <A> The type of the first argument.\n+     * @param <B> The type of the second argument.\n+     * @param <C> The type of the third argument.\n+     * @param function The function with three arguments that creates the {@link TemplateBody} given the template arguments.\n+     *\/\n+    record ThreeArgs<A, B, C>(String arg0Name, String arg1Name, String arg2Name,\n+                              TriFunction<A, B, C, TemplateBody> function) implements Template {\n+        TemplateBody instantiate(A a, B b, C c) {\n+            return function.apply(a, b, c);\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateWithArgs} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation, and it can also be used with\n+         * {@link TemplateWithArgs#render} to render the template to a {@link String}\n+         * directly.\n+         *\n+         * @param a The value for the first argument.\n+         * @param b The value for the second argument.\n+         * @param c The value for the third argument.\n+         * @return The template all (three) arguments applied.\n+         *\/\n+        public TemplateWithArgs withArgs(A a, B b, C c) {\n+            return new TemplateWithArgs.ThreeArgsUse<>(this, a, b, c);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a {@link TemplateBody} from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (e.g. {@link Integer} or auto-boxed {@code int}), any {@link Token},\n+     * or {@link List}s of any of these.\n+     *\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> body(\n+     *     \"\"\"\n+     *     Multi-line string\n+     *     \"\"\",\n+     *     \"normal string \", Integer.valueOf(3), 3, Float.valueOf(1.5f), 1.5f,\n+     *     List.of(\"abc\", \"def\"),\n+     *     nestedTemplate.withArgs(42)\n+     * ));\n+     * }\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s, boxed primitive types\n+     *               (e.g. {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link TemplateBody} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static TemplateBody body(Object... tokens) {\n+        return new TemplateBody(Token.parse(tokens));\n+    }\n+\n+    \/**\n+     * Retrieves the dollar replacement of the {@code 'name'} for the\n+     * current {@link Template} that is being instanciated. It returns the same\n+     * dollar replacement as the string use {@code \"$name\"}.\n+     *\n+     * Here an example where a {@link Template} creates a local variable {@code 'var'},\n+     * with an implicit dollar replacement, and then captures that dollar replacement\n+     * using {@link #$} for the use inside a nested template.\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> body(\n+     *     \"\"\"\n+     *     int $var = 42;\n+     *     \"\"\",\n+     *     otherTemplate.withArgs($(\"var\"))\n+     * ));\n+     * }\n+     *\n+     * @param name The {@link String} name of the name.\n+     * @return The dollar replacement for the {@code 'name'}.\n+     *\/\n+    static String $(String name) {\n+        return Renderer.getCurrent().$(name);\n+    }\n+\n+    \/**\n+     * Define a hashtag replacement for {@code \"#key\"}, with a specific value.\n+     *\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", (Integer a) -> body(\n+     *     let(\"b\", a * 5),\n+     *     \"\"\"\n+     *     System.out.prinln(\"Use a and b with hashtag replacement: #a and #b\");\n+     *     \"\"\"\n+     * ));\n+     * }\n+     *\n+     * @param key Name for the hashtag replacement.\n+     * @param value The value that the hashtag is replaced with.\n+     * @return A token that does nothing, so that the {@link #let} cal can easily be put in a list of tokens\n+     *         inside a {@link Template#body}.\n+     * @throws RendererException if there is a duplicate hashtag {@code key}.\n+     *\/\n+    static Token let(String key, Object value) {\n+        Renderer.getCurrent().addHashtagReplacement(key, value);\n+        return new NothingToken();\n+    }\n+\n+    \/**\n+     * Define a hashtag replacement for {@code \"#key\"}, with a specific value, which is also captured\n+     * by the provided {@code 'function'} with type {@code <T>}.\n+     *\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", (Integer a) -> let(\"b\", a * 2, (Integer b) -> body(\n+     *     \"\"\"\n+     *     System.out.println(\"Use a and b with hashtag replacement: #a and #b\");\n+     *     \"\"\",\n+     *     \"System.out.println(\\\"Use a and b as capture variables:\\\"\" + a + \" and \" + b + \");\\n\"\n+     * )));\n+     * }\n+     *\n+     * @param key Name for the hashtag replacement.\n+     * @param value The value that the hashtag is replaced with.\n+     * @param <T> The type of the value.\n+     * @param function The function that is applied with the provided {@code 'value'}.\n+     * @return A token that does nothing, so that the {@link #let} cal can easily be put in a list of tokens\n+     *         inside a {@link Template#body}.\n+     * @throws RendererException if there is a duplicate hashtag {@code key}.\n+     *\/\n+    static <T> TemplateBody let(String key, T value, Function<T, TemplateBody> function) {\n+        Renderer.getCurrent().addHashtagReplacement(key, value);\n+        return function.apply(value);\n+    }\n+\n+    \/**\n+     * Default amount of fuel for {@link TemplateWithArgs#render}. It guides the nesting depth of {@link Template}s.\n+     *\/\n+    public final static float DEFAULT_FUEL = 100.0f;\n+\n+    \/**\n+     * The default amount of fuel spent per {@link Template}. It is suptracted from the current {@link #fuel} at every\n+     * nesting level, and once the {@link #fuel} reaches zero, the nesting is supposed to terminate.\n+     *\/\n+    public final static float DEFAULT_FUEL_COST = 10.0f;\n+\n+    \/**\n+     * The current remaining fuel for nested {@link Template}s. Every level of {@link Template} nestig\n+     * subtracts a certain amount of fuel, and when it reaches zero, {@link Template}s are supposed to\n+     * stop nesting, if possible. This is not a hard rule, but a guide, and a mechanism to ensure\n+     * termination in recursive {@link Template} instantiations.\n+     *\n+     * <p>\n+     * Example of a recursive {@link Template}, which checks the remaining {@link #fuel} at every level,\n+     * and terminates if it reaches zero. It also demonstrates the use of {@link TemplateBinding} for\n+     * the recursive use of {@link Template}s. We {@link TemplateWithArgs#render} with {@code 30} total fuel, and spending {@code 5} fuel at each recursion level.\n+     * {@snippet lang=java :\n+     * var binding = new TemplateBinding<Template.OneArgs<Integer>>();\n+     * var template = Template.make(\"depth\", (Integer depth) -> body(\n+     *     setFuelCost(5.0f),\n+     *     let(\"fuel\", fuel()),\n+     *     \"\"\"\n+     *     System.out.println(\"Currently at depth #depth with fuel #fuel\");\n+     *     \"\"\",\n+     *     (fuel() > 0) ? binding.get().withArgs(depth + 1)\n+     *                    \"\/\/ terminate\\n\"\n+     * ));\n+     * binding.bind(template);\n+     * String code = template.withArgs(0).render(30.0f);\n+     * }\n+     *\n+     * @return The amount of fuel left for nested {@link Template} use.\n+     *\/\n+    static float fuel() {\n+        return Renderer.getCurrent().fuel();\n+    }\n+\n+    \/**\n+     * Changes the amount of fuel used for the current {@link Template}, where the default is\n+     * {@link Template#DEFAULT_FUEL_COST}.\n+     *\n+     * @param fuelCost The amount of fuel used for the current {@link Template}.\n+     * @return A token for convenient use in {@link Template#body}.\n+     *\/\n+    static Token setFuelCost(float fuelCost) {\n+        Renderer.getCurrent().setFuelCost(fuelCost);\n+        return new NothingToken();\n+    }\n+\n+    \/**\n+     * Add a {@link Name} in the current code frame.\n+     * Note that there can be duplicate definitions, and they simply increase\n+     * the {@link #weighNames} weight, and increase the probability of sampling\n+     * the name with {@link #sampleName}.\n+     *\n+     * @param name The {@link Name} to be added to the current code frame.\n+     * @return The token that performs the defining action.\n+     *\/\n+    static Token addName(Name name) {\n+        return new AddNameToken(name);\n+    }\n+\n+    \/**\n+     * Weight the {@link Name}s for the specified {@link Name.Type}.\n+     *\n+     * @param type The type of the names to weigh.\n+     * @param onlyMutable Determines if we weigh the mutable names or all.\n+     * @return The weight of names for the specified parameters.\n+     *\/\n+    static long weighNames(Name.Type type, boolean onlyMutable) {\n+        return Renderer.getCurrent().weighNames(type, onlyMutable);\n+    }\n+\n+    \/**\n+     * Sample a random name for the specified type.\n+     *\n+     * @param type The type of the names to sample from.\n+     * @param onlyMutable Determines if we sample from the mutable names or all.\n+     * @return The sampled name.\n+     *\/\n+    static Name sampleName(Name.Type type, boolean onlyMutable) {\n+        return Renderer.getCurrent().sampleName(type, onlyMutable);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Template.java","additions":608,"deletions":0,"binary":false,"changes":608,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * To facilitate recursive uses of {@link Template}s, e.g. where a template uses\n+ * itself, where a template needs to be referenced before it is fully defined,\n+ * one can use the indirection of a {@link TemplateBinding}. The {@link TemplateBinding}\n+ * is allocated first without any {@link Template} bound to it yet. At this stage,\n+ * it can be used with {@link #get} inside a {@link Template}. Later, we can {@link #bind}\n+ * a {@link Template} to the binding, such that {@link #get} returns that bound\n+ * {@link Template}.\n+ *\n+ * @param <T> Type of the template.\n+ *\/\n+public class TemplateBinding<T extends Template> {\n+    private T template = null;\n+\n+    \/**\n+     * Creates a new {@link TemplateBinding} that has no {@link Template} bound to it yet.\n+     *\/\n+    public TemplateBinding() {}\n+\n+    \/**\n+     * Retrieve the {@link Template} that was previously bound to the binding.\n+     *\n+     * @return The {@link Template} that was previously bound with {@link #bind}.\n+     * @throws RendererException if no {@link Template} was bound yet.\n+     *\/\n+    public T get() {\n+        if (template == null) {\n+            throw new RendererException(\"Cannot 'get' before 'bind'.\");\n+        }\n+        return template;\n+    }\n+\n+\n+    \/**\n+     * Binds a {@link Template} for future reference using {@link #get}.\n+     *\n+     * @param template The {@link Template} to be bound.\n+     * @throws RendererException if a {@link Template} was already bound.\n+     *\/\n+    public void bind(T template) {\n+         if (this.template != null) {\n+            throw new RendererException(\"Duplicate 'bind' not allowed.\");\n+        }\n+        this.template = template;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateBinding.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * A {@link Template} generates a {@link TemplateBody}, which is a list of {@link Token}s,\n+ * which are then later rendered to {@link String}s.\n+ *\n+ * @param tokens The list of {@link Token}s that are later rendered to {@link String}s.\n+ *\/\n+public record TemplateBody(List<Token> tokens) {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateBody.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * The {@link TemplateFrame} is the frame for a {@link TemplateWithArgs}. It ensures\n+ * that each template use has its own unique {@link id} used to deconflict names\n+ * using {@link Template#$}. It also has a set of hashtag replacements, which combine the\n+ * key-value pairs from the template argument and the {@link Template#let} definitions.\n+ * The {@link parent} relationship provides a trace for the use chain of templates.\n+ * The {@link fuel} is reduced over this chain, to give a heuristic on how much time\n+ * is spend on the code from the template corrsponding to the frame, and to give a\n+ * termination criterion to avoid nesting templates too deeply.\n+ *\n+ * <p>\n+ * See also {@link CodeFrame} for more explanations about the frames.\n+ *\/\n+class TemplateFrame {\n+    final TemplateFrame parent;\n+    final int id;\n+    final Map<String, String> hashtagReplacements = new HashMap<>();\n+    final float fuel;\n+    float fuelCost;\n+\n+    public static TemplateFrame makeBase(int id, float fuel) {\n+        return new TemplateFrame(null, id, fuel, 0.0f);\n+    }\n+\n+    public static TemplateFrame make(TemplateFrame parent, int id) {\n+        return new TemplateFrame(parent, id, parent.fuel - parent.fuelCost, Template.DEFAULT_FUEL_COST);\n+    }\n+\n+    private TemplateFrame(TemplateFrame parent, int id, float fuel, float fuelCost) {\n+        this.parent = parent;\n+        this.id = id;\n+        this.fuel = fuel;\n+        this.fuelCost = fuelCost;\n+    }\n+\n+    public String $(String name) {\n+        return name + \"_\" + id;\n+    }\n+\n+    void addHashtagReplacement(String key, String value) {\n+        if (!hashtagReplacements.containsKey(key)) {\n+            hashtagReplacements.put(key, value);\n+            return;\n+        }\n+        throw new RendererException(\"Duplicate hashtag replacement for #\" + key);\n+    }\n+\n+    String getHashtagReplacement(String key) {\n+        if (hashtagReplacements.containsKey(key)) {\n+            return hashtagReplacements.get(key);\n+        }\n+        throw new RendererException(\"Missing hashtag replacement for #\" + key);\n+    }\n+\n+    void setFuelCost(float fuelCost) {\n+        this.fuelCost = fuelCost;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateFrame.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * Represents a {@link Template} with applied arguments, ready for instantiation, either\n+ * as a {@link Token} inside another {@link Template} or with {@link #render}.\n+ *\/\n+public sealed abstract class TemplateWithArgs implements Token\n+                                              permits TemplateWithArgs.ZeroArgsUse,\n+                                                      TemplateWithArgs.OneArgsUse,\n+                                                      TemplateWithArgs.TwoArgsUse,\n+                                                      TemplateWithArgs.ThreeArgsUse\n+{\n+    private TemplateWithArgs() {}\n+\n+    \/**\n+     * Represents a zero-argument {@link Template} with applied arguments, ready for instantiation\n+     * either as a {@link Token} inside another {@link Template} or with {@link #render}.\n+     *\/\n+    public static final class ZeroArgsUse extends TemplateWithArgs implements Token {\n+        private final Template.ZeroArgs zeroArgs;\n+\n+        ZeroArgsUse(Template.ZeroArgs zeroArgs) {\n+            this.zeroArgs = zeroArgs;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return zeroArgs.instantiate();\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {}\n+    }\n+\n+    \/**\n+     * Represents a one-argument {@link Template} with applied arguments, ready for instantiation\n+     * either as a {@link Token} inside another {@link Template} or with {@link #render}.\n+     *\n+     * @param <A> The type of the (first) argument.\n+     *\/\n+    public static final class OneArgsUse<A> extends TemplateWithArgs implements Token {\n+        private final Template.OneArgs<A> oneArgs;\n+        private final A a;\n+\n+        OneArgsUse(Template.OneArgs<A> oneArgs, A a) {\n+            this.oneArgs = oneArgs;\n+            this.a = a;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return oneArgs.instantiate(a);\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {\n+            visitor.visit(oneArgs.arg0Name(), a);\n+        }\n+    }\n+\n+    \/**\n+     * Represents a two-argument {@link Template} with applied arguments, ready for instantiation\n+     * either as a {@link Token} inside another {@link Template} or with {@link #render}.\n+     *\n+     * @param <A> The type of the first argument.\n+     * @param <B> The type of the second argument.\n+     *\/\n+    public static final class TwoArgsUse<A, B> extends TemplateWithArgs implements Token {\n+        private final Template.TwoArgs<A, B> twoArgs;\n+        private final A a;\n+        private final B b;\n+\n+        TwoArgsUse(Template.TwoArgs<A, B> twoArgs, A a, B b) {\n+            this.twoArgs = twoArgs;\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return twoArgs.instantiate(a, b);\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {\n+            visitor.visit(twoArgs.arg0Name(), a);\n+            visitor.visit(twoArgs.arg1Name(), b);\n+        }\n+    }\n+\n+    \/**\n+     * Represents a three-argument {@link Template} with applied arguments, ready for instantiation\n+     * either as a {@link Token} inside another {@link Template} or with {@link #render}.\n+     *\n+     * @param <A> The type of the first argument.\n+     * @param <B> The type of the second argument.\n+     * @param <C> The type of the second argument.\n+     *\/\n+    public static final class ThreeArgsUse<A, B, C> extends TemplateWithArgs implements Token {\n+        private final Template.ThreeArgs<A, B, C> threeArgs;\n+        private final A a;\n+        private final B b;\n+        private final C c;\n+\n+        ThreeArgsUse(Template.ThreeArgs<A, B, C> threeArgs, A a, B b, C c) {\n+            this.threeArgs = threeArgs;\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return threeArgs.instantiate(a, b, c);\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {\n+            visitor.visit(threeArgs.arg0Name(), a);\n+            visitor.visit(threeArgs.arg1Name(), b);\n+            visitor.visit(threeArgs.arg2Name(), c);\n+        }\n+    }\n+\n+    abstract TemplateBody instantiate();\n+\n+    @FunctionalInterface\n+    interface ArgumentVisitor {\n+        void visit(String name, Object value);\n+    }\n+\n+    abstract void visitArguments(ArgumentVisitor visitor);\n+\n+    \/**\n+     * Renders the {@link Template} with applied arguments to a {@link String}.\n+     *\n+     * @return The {@link Template} rendered to a {@link String}.\n+     *\/\n+    public final String render() {\n+        return Renderer.render(this);\n+    }\n+\n+    \/**\n+     * Renders the {@link Template} with applied arguments to a {@link String}.\n+     *\n+     * @param fuel The amount of fuel provided for recursive {@link Template} instantiations.\n+     * @return The {@link Template} rendered to a {@link String}.\n+     *\/\n+    public final String render(float fuel) {\n+        return Renderer.render(this, fuel);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateWithArgs.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * The {@link Template#body} and {@link Hook#set} are given a list of tokens, which are either\n+ * {@link Token}s or {@link String}s or some permitted boxed primitives. These are then parsed\n+ * and all non {@link Token}s are converted to {@link StringToken}s. The parsing also flattens\n+ * {@link List}s.\n+ *\/\n+sealed interface Token permits StringToken,\n+                               TemplateWithArgs,\n+                               TemplateWithArgs.ZeroArgsUse,\n+                               TemplateWithArgs.OneArgsUse,\n+                               TemplateWithArgs.TwoArgsUse,\n+                               TemplateWithArgs.ThreeArgsUse,\n+                               HookSetToken,\n+                               HookInsertToken,\n+                               AddNameToken,\n+                               NothingToken\n+{\n+    static List<Token> parse(Object[] objects) {\n+        if (objects == null) {\n+            throw new IllegalArgumentException(\"Unexpected tokens: null\");\n+        }\n+        List<Token> outputList = new ArrayList<Token>();\n+        parseToken(Arrays.asList(objects), outputList);\n+        return outputList;\n+    }\n+\n+    private static void parseList(List<Object> inputList, List<Token> outputList) {\n+        for (Object o : inputList) {\n+            parseToken(o, outputList);\n+        }\n+    }\n+\n+    private static void parseToken(Object o, List<Token> outputList) {\n+        if (o == null) {\n+            throw new IllegalArgumentException(\"Unexpected token: null\");\n+        }\n+        switch (o) {\n+            case Token t   -> outputList.add(t);\n+            case String s  -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Integer s -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Long s    -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Double s  -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Float s   -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Boolean s -> outputList.add(new StringToken(Renderer.format(s)));\n+            case List l    -> parseList(l, outputList);\n+            default -> throw new IllegalArgumentException(\"Unexpected token: \" + o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Token.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import compiler.lib.template_framework.Hook;\n+\n+\/**\n+ * Provides a hook for class and method scopes, to be used in Templates.\n+ *\/\n+public abstract class Hooks {\n+    private Hooks() {} \/\/ Avoid instanciation and need for documentation.\n+\n+    \/**\n+     * Template {@link Hook} used by the Template Library for class scopes, to insert\n+     * fields and methods.\n+     *\/\n+    public static final Hook CLASS_HOOK = new Hook(\"Class\");\n+\n+    \/**\n+     * Template {@link Hook} used by the Template Library for method scopes, to insert\n+     * local variables, and computations for local variables at the beginning of a\n+     * method.\n+     *\/\n+    public static final Hook METHOD_HOOK = new Hook(\"Method\");\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Hooks.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test simple use of Templates with the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run main template_framework.examples.TestAdvanced\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+\/**\n+ * This is a basic example for Templates, using them to cover a list of test variants.\n+ * <p>\n+ * The \"@compile\" command for JTREG is required so that the frameworks used in the Template code\n+ * are compiled and available for the Test-VM.\n+ * <p>\n+ * Additionally, we must set the classpath for the Test-VM, so that it has access to all compiled\n+ * classes (see {@link CompileFramework#getEscapedClassPathOfCompiledClasses}).\n+ *\/\n+public class TestAdvanced {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static final RestrictableGenerator<Integer> GEN_BYTE = Generators.G.safeRestrict(Generators.G.ints(), Byte.MIN_VALUE, Byte.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_CHAR = Generators.G.safeRestrict(Generators.G.ints(), Character.MIN_VALUE, Character.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_SHORT = Generators.G.safeRestrict(Generators.G.ints(), Short.MIN_VALUE, Short.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    public static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+    public static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+    public static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ Object ret = p.xyz.InnterTest.main();\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {});\n+    }\n+\n+    interface MyGenerator {\n+        Object next();\n+    }\n+\n+    record Type(String name, MyGenerator generator, List<String> operators) {}\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate(CompileFramework comp) {\n+\n+        \/\/ The test template:\n+        \/\/ - For a chosen type, operator, and generator.\n+        \/\/ - The variable name \"GOLD\" and the test name \"test\" would get conflicts\n+        \/\/   if we instanciate the template multiple times. Thus, we use the $ prefix\n+        \/\/   so that the Template Framework can replace the names and make them unique\n+        \/\/   for each Template instantiation.\n+        \/\/ - The GOLD value is computed at the beginning, hopefully by the interpreter.\n+        \/\/ - The test method is eventually compiled, and the values are verified by the\n+        \/\/   check method.\n+        var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> body(\n+            let(\"con1\", generator.next()),\n+            let(\"con2\", generator.next()),\n+            \"\"\"\n+            \/\/ #typeName #operator #con1 #con2\n+            public static #typeName $GOLD = $test();\n+\n+            @Test\n+            public static #typeName $test() {\n+                return (#typeName)(#con1 #operator #con2);\n+            }\n+\n+            @Check(test = \"$test\")\n+            public static void $check(#typeName result) {\n+                Verify.checkEQ(result, $GOLD);\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Template for the Class.\n+        var classTemplate = Template.make(\"types\", (List<Type> types) -> body(\n+            let(\"classpath\", comp.getEscapedClassPathOfCompiledClasses()),\n+            \"\"\"\n+            package p.xyz;\n+\n+            import compiler.lib.ir_framework.*;\n+            import compiler.lib.verify.*;\n+\n+            public class InnerTest {\n+                public static void main() {\n+                    TestFramework framework = new TestFramework(InnerTest.class);\n+                    \/\/ Set the classpath, so that the TestFramework test VM knows where\n+                    \/\/ the CompileFramework put the class files of the compiled source code.\n+                    framework.addFlags(\"-classpath\", \"#classpath\");\n+                    framework.start();\n+                }\n+\n+            \"\"\",\n+            \/\/ Call the testTemplate for each type and operator, generating a\n+            \/\/ list of lists of TemplateWithArgs:\n+            types.stream().map((Type type) ->\n+                type.operators().stream().map((String operator) ->\n+                    testTemplate.withArgs(type.name(), operator, type.generator())).toList()\n+            ).toList(),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ For each type, we choose a list of operators that do not throw exceptions.\n+        List<Type> types = List.of(\n+            new Type(\"byte\",   GEN_BYTE::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"char\",   GEN_CHAR::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"short\",  GEN_SHORT::next,  List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"int\",    GEN_INT::next,    List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"long\",   GEN_LONG::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"float\",  GEN_FLOAT::next,  List.of(\"+\", \"-\", \"*\", \"\/\")),\n+            new Type(\"double\", GEN_DOUBLE::next, List.of(\"+\", \"-\", \"*\", \"\/\"))\n+        );\n+\n+        \/\/ Use the template with one argument and render it to a String.\n+        return classTemplate.withArgs(types).render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestAdvanced.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test simple use of Templates with the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.examples.TestSimple\n+ *\/\n+\n+package template_framework.examples;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import static compiler.lib.template_framework.Template.body;\n+\n+public class TestSimple {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate());\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ Object ret = p.xyz.InnterTest.test();\n+        Object ret = comp.invoke(\"p.xyz.InnerTest\", \"test\", new Object[] {});\n+        System.out.println(\"res: \" + ret);\n+\n+        \/\/ Check that the return value is the sum of the two arguments.\n+        if ((42 + 7) != (int)ret) {\n+            throw new RuntimeException(\"Unexpected result\");\n+        }\n+    }\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate() {\n+        \/\/ Create a Template with two arguments.\n+        var template = Template.make(\"arg1\", \"arg2\", (Integer arg1, String arg2) -> body(\n+            \"\"\"\n+            package p.xyz;\n+            public class InnerTest {\n+                public static int test() {\n+                    return #arg1 + #arg2;\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Use the template with two arguments, and render it to a String.\n+        return template.withArgs(42, \"7\").render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestSimple.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,543 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Demonstrate the use of Templates with the Compile Framework.\n+ *          It displays the use of most features in the Template Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.examples.TestTutorial\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import compiler.lib.compile_framework.*;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.Hook;\n+import compiler.lib.template_framework.TemplateBinding;\n+import compiler.lib.template_framework.Name;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.$;\n+import static compiler.lib.template_framework.Template.fuel;\n+import static compiler.lib.template_framework.Template.addName;\n+import static compiler.lib.template_framework.Template.sampleName;\n+import static compiler.lib.template_framework.Template.weighNames;\n+\n+import compiler.lib.template_framework.library.Hooks;\n+\n+public class TestTutorial {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add java source files.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest1\", generateWithListOfTokens());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest2\", generateWithTemplateArguments());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest3\", generateWithHashtagAndDollarReplacements());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest4\", generateWithCustomHooks());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest5\", generateWithLibraryHooks());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest6\", generateWithRecursionAndBindingsAndFuel());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest7\", generateWithNames());\n+\n+        \/\/ Compile the source files.\n+        \/\/ Hint: if you want to see the generated source code, you can enable\n+        \/\/       printing of the source code that the CompileFramework receives,\n+        \/\/       with -DCompileFrameworkVerbose=true\n+        comp.compile();\n+\n+        \/\/ Object ret = p.xyz.InnterTest1.main();\n+        comp.invoke(\"p.xyz.InnerTest1\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest2\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest3\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest4\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest5\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest6\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest7\", \"main\", new Object[] {});\n+    }\n+\n+    \/\/ This example shows the use of various Tokens.\n+    public static String generateWithListOfTokens() {\n+        \/\/ A Template is essentially a function \/ lambda that produces a\n+        \/\/ token body, which is a list of Tokens that are concatenated.\n+        var templateClass = Template.make(() -> body(\n+            \/\/ The \"body\" method is filled by a sequence of \"Tokens\".\n+            \/\/ These can be Strings and multi-line Strings, but also\n+            \/\/ boxed primitives.\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest1 {\n+                public static void main() {\n+                    System.out.println(\"Hello World!\");\n+            \"\"\",\n+            \"int a = \", 1, \";\\n\",\n+            \"float b = \", 1.5f, \";\\n\",\n+            \/\/ Special Float values are \"smartly\" formatted!\n+            \"float nan = \", Float.POSITIVE_INFINITY, \";\\n\",\n+            \"boolean c = \", true, \";\\n\",\n+            \/\/ Lists of Tokens are also allowed:\n+            List.of(\"int \", \"d = 5\", \";\\n\"),\n+            \/\/ We can also stream \/ map over an existing list, or one created on\n+            \/\/ the fly:\n+            List.of(3, 5, 7, 11).stream().map(i -> \"System.out.println(\" + i + \");\\n\").toList(),\n+            \"\"\"\n+                    System.out.println(a + \" \" + b + \" \" + nan + \" \" + c + \" \" + d);\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ This example shows the use of Templates, with and without arguments.\n+    public static String generateWithTemplateArguments() {\n+        \/\/ A Template with no arguments.\n+        var templateHello = Template.make(() -> body(\n+            \"\"\"\n+            System.out.println(\"Hello\");\n+            \"\"\"\n+        ));\n+\n+        \/\/ A Template with a single Integer argument.\n+        var templateCompare = Template.make(\"arg\", (Integer arg) -> body(\n+            \"System.out.println(\", arg, \");\\n\",  \/\/ capture arg via lambda argument\n+            \"System.out.println(#arg);\\n\",       \/\/ capture arg via hashtag replacement\n+            \"if (#arg != \", arg, \") { throw new RuntimeException(\\\"mismatch\\\"); }\\n\"\n+        ));\n+\n+        \/\/ A Template that creates the body of the Class and main method, and then\n+        \/\/ uses the two Templates above inside it.\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest2 {\n+                public static void main() {\n+            \"\"\",\n+                    templateHello.withArgs(),\n+                    templateCompare.withArgs(7),\n+                    templateCompare.withArgs(42),\n+            \"\"\"\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ Example with hashtag replacements (arguments and let), and $-name renamings.\n+    \/\/ Note: hashtag replacements are a workaround for the missing string templates.\n+    \/\/       If we had string templates, we could just capture the typed lambda\n+    \/\/       arguments, and use them directly in the String via string templating.\n+    public static String generateWithHashtagAndDollarReplacements() {\n+        var template1 = Template.make(\"x\", (Integer x) -> body(\n+            \/\/ We have the \"#x\" hashtag replacement from the argument capture above.\n+            \/\/ Additionally, we can define \"#con\" as a hashtag replacement from let:\n+            let(\"con\", 3 * x),\n+            \/\/ In the code below, we use \"var\" as a local variable. But if we were\n+            \/\/ to instantiate this template twice, the names could conflict. Hence,\n+            \/\/ we automatically rename the names that have a $ prepended.\n+            \"\"\"\n+            int $var = #con;\n+            System.out.println(\"T1: #x, #con, \" + $var);\n+            \"\"\"\n+        ));\n+\n+        var template2 = Template.make(\"x\", (Integer x) ->\n+            \/\/ Sometimes it can be helpful to not just create a hashtag replacement\n+            \/\/ with let, but also to capture the variable.\n+            let(\"y\", 11 * x, y ->\n+                body(\n+                    \"\"\"\n+                    System.out.println(\"T2: #x, #y\");\n+                    \"\"\",\n+                    template1.withArgs(y)\n+                )\n+            )\n+        );\n+\n+        \/\/ This template generates an int variable and assigns it a value.\n+        \/\/ Together with template4, we see that each template has a unique renaming\n+        \/\/ for a $-name replacement.\n+        var template3 = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            int #name = #value; \/\/ Note: $var is not #name\n+            \"\"\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"\"\"\n+            \/\/ We will define the variable $var:\n+            \"\"\",\n+            \/\/ We can capture the $-name programmatically, and pass it to other templates:\n+            template3.withArgs($(\"var\"), 42),\n+            \"\"\"\n+            if ($var != 42) { throw new RuntimeException(\"Wrong value!\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest3 {\n+                public static void main() {\n+            \"\"\",\n+                    template1.withArgs(1),\n+                    template1.withArgs(7),\n+                    template2.withArgs(2),\n+                    template2.withArgs(5),\n+                    template4.withArgs(),\n+            \"\"\"\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ In this example, we look at the use of Hooks.\n+    public static String generateWithCustomHooks() {\n+        \/\/ We can define a custom hook.\n+        \/\/ Note: generally we prefer using the pre-defined CLASS_HOOK and METHOD_HOOK from the library,\n+        \/\/       when ever possible. See also the example after this one.\n+        var myHook = new Hook(\"MyHook\");\n+\n+        var template1 = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            public static int #name = #value;\n+            \"\"\"\n+        ));\n+\n+        var template2 = Template.make(\"x\", (Integer x) -> body(\n+            \"\"\"\n+            \/\/ Let us go back to the hook, and define a field named $field...\n+            \"\"\",\n+            myHook.insert(template1.withArgs($(\"field\"), x)),\n+            \"\"\"\n+            System.out.println(\"$field: \" + $field);\n+            if ($field != #x) { throw new RuntimeException(\"Wrong value!\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest4 {\n+            \"\"\",\n+            \/\/ We set a Hook outside the main method, but inside the Class.\n+            \/\/ The Hook is set for the Tokens inside the set braces.\n+            \/\/ As long as the hook is set, we can insert code into the hook,\n+            \/\/ here we can define static fields for example.\n+            myHook.set(\n+                \"\"\"\n+                public static void main() {\n+                \"\"\",\n+                    template2.withArgs(5),\n+                    template2.withArgs(7),\n+                \"\"\"\n+                }\n+                \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ We saw the use of custom hooks above, but now we look at the use of CLASS_HOOK and METHOD_HOOK\n+    \/\/ from the Temlate Library.\n+    public static String generateWithLibraryHooks() {\n+        var templateStaticField = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            static { System.out.println(\"Defining static field #name\"); }\n+            public static int #name = #value;\n+            \"\"\"\n+        ));\n+\n+        var templateLocalVariable = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            System.out.println(\"Defining local variable #name\");\n+            int #name = #value;\n+            \"\"\"\n+        ));\n+\n+        var templateMethodBody = Template.make(() -> body(\n+            \"\"\"\n+            \/\/ Let's define a local variable $var and a static field $field.\n+            \"\"\",\n+            Hooks.CLASS_HOOK.insert(templateStaticField.withArgs($(\"field\"), 5)),\n+            Hooks.METHOD_HOOK.insert(templateLocalVariable.withArgs($(\"var\"), 11)),\n+            \"\"\"\n+            System.out.println(\"$field: \" + $field);\n+            System.out.println(\"$var: \" + $var);\n+            if ($field * $var != 55) { throw new RuntimeException(\"Wrong value!\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest5 {\n+            \"\"\",\n+            \/\/ Class Hook for fields.\n+            Hooks.CLASS_HOOK.set(\n+                \"\"\"\n+                public static void main() {\n+                \"\"\",\n+                \/\/ Method Hook for local variables, and earlier computations.\n+                Hooks.METHOD_HOOK.set(\n+                    \"\"\"\n+                    \/\/ This is the beginning of the \"main\" method body.\n+                    System.out.println(\"Welcome to main!\");\n+                    \"\"\",\n+                    templateMethodBody.withArgs(),\n+                    \"\"\"\n+                    System.out.println(\"Going to call other...\");\n+                    other();\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+\n+                private static void other() {\n+                \"\"\",\n+                \/\/ Have a separate method hook for other, so that it can insert\n+                \/\/ its own local variables.\n+                Hooks.METHOD_HOOK.set(\n+                    \"\"\"\n+                    System.out.println(\"Welcome to other!\");\n+                    \"\"\",\n+                    templateMethodBody.withArgs(),\n+                    \"\"\"\n+                    System.out.println(\"Done with other.\");\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+                \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ This example shows the use of bindings to allow cyclic references of Templates,\n+    \/\/ allowing recursive template generation. We also show the use of fuel to limit\n+    \/\/ recursion.\n+    public static String generateWithRecursionAndBindingsAndFuel() {\n+        \/\/ Binding allows the use of template1 inside of template1, via the binding indirection.\n+        var binding1 = new TemplateBinding<Template.OneArgs<Integer>>();\n+        var template1 = Template.make(\"depth\", (Integer depth) -> body(\n+            let(\"fuel\", fuel()),\n+            \"\"\"\n+            System.out.println(\"At depth #depth with fuel #fuel.\");\n+            \"\"\",\n+            \/\/ We cannot yet use template1 directly, as it is being defined.\n+            \/\/ So we use binding1 instead.\n+            \/\/ For every recursion depth, some fuel is automatically subtracted\n+            \/\/ so that the fuel slowly depletes with the depth.\n+            \/\/ We keep the recursion going until the fuel is depleted.\n+            (fuel() > 0) ? binding1.get().withArgs(depth + 1)\n+                        : \"System.out.println(\\\"Fuel depleted.\\\");\\n\",\n+            \"\"\"\n+            System.out.println(\"Exit depth #depth.\");\n+            \"\"\"\n+        ));\n+        binding1.bind(template1);\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest6 {\n+                public static void main() {\n+                    System.out.println(\"Welcome to main!\");\n+                    \"\"\",\n+                    template1.withArgs(0),\n+                    \"\"\"\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ In the example below (\"generateWithNames\"), we see the use of Names to add\n+    \/\/ variables and fields to code scopes, and then sample from those variables\n+    \/\/ and fields. Every Name has a Name.Type, which we now define for int and long.\n+    private record MyPrimitive(String name) implements Name.Type {\n+        @Override\n+        public boolean isSubtypeOf(Name.Type other) {\n+            return other instanceof MyPrimitive(String n) && n == name();\n+        }\n+\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyPrimitive myInt = new MyPrimitive(\"int\");\n+    private static final MyPrimitive myLong = new MyPrimitive(\"long\");\n+\n+    \/\/ Example with names, i.e. addName, weighNames, and sampleName.\n+    \/\/ These can be used to add variables and fields to code scopes, and then sample\n+    \/\/ from the available variables and fields later.\n+    public static String generateWithNames() {\n+        var templateSample = Template.make(\"type\", (Name.Type type) -> body(\n+            let(\"name\", sampleName(type, false).name()),\n+            \"\"\"\n+            System.out.println(\"Sampling type #type: #name = \" + #name);\n+            \"\"\"\n+        ));\n+\n+        var templateStaticField = Template.make(\"type\", (Name.Type type) -> body(\n+            addName(new Name($(\"field\"), type, true, 1)),\n+            \"\"\"\n+            public static #type $field = 0;\n+            \"\"\"\n+        ));\n+\n+        var templateLocalVariable = Template.make(\"type\", (Name.Type type) -> body(\n+            addName(new Name($(\"var\"), type, true, 1)),\n+            \"\"\"\n+            #type $var = 0;\n+            \"\"\"\n+        ));\n+\n+        var templateStatus = Template.make(() -> body(\n+            let(\"ints\", weighNames(myInt, false)),\n+            let(\"longs\", weighNames(myLong, false)),\n+            \"\"\"\n+            System.out.println(\"Status: #ints ints, #longs longs.\");\n+            \"\"\"\n+        ));\n+\n+        var templateMain = Template.make(() -> body(\n+            \"\"\"\n+            System.out.println(\"Starting inside main...\");\n+            \"\"\",\n+            templateStatus.withArgs(),\n+            Hooks.METHOD_HOOK.insert(templateLocalVariable.withArgs(myInt)),\n+            Hooks.METHOD_HOOK.insert(templateLocalVariable.withArgs(myLong)),\n+            Hooks.CLASS_HOOK.insert(templateStaticField.withArgs(myInt)),\n+            Hooks.CLASS_HOOK.insert(templateStaticField.withArgs(myLong)),\n+            templateStatus.withArgs(),\n+            \/\/ We should see a mix if fields and variables sampled.\n+            Collections.nCopies(5, templateSample.withArgs(myInt)),\n+            Collections.nCopies(5, templateSample.withArgs(myLong)),\n+            templateStatus.withArgs(),\n+            \"\"\"\n+            System.out.println(\"Finishing inside main.\");\n+            \"\"\"\n+        ));\n+\n+        var templateOther = Template.make(() -> body(\n+            \"\"\"\n+            System.out.println(\"Starting inside other...\");\n+            \"\"\",\n+            templateStatus.withArgs(),\n+            \/\/ We still have all the field definitions from main.\n+            Collections.nCopies(5, templateSample.withArgs(myInt)),\n+            Collections.nCopies(5, templateSample.withArgs(myLong)),\n+            templateStatus.withArgs(),\n+            \"\"\"\n+            System.out.println(\"Finishing inside other.\");\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest7 {\n+            \"\"\",\n+            \/\/ Class Hook for fields.\n+            Hooks.CLASS_HOOK.set(\n+                \"\"\"\n+                public static void main() {\n+                \"\"\",\n+                \/\/ Method Hook for local variables, and earlier computations.\n+                Hooks.METHOD_HOOK.set(\n+                    \"\"\"\n+                    \/\/ This is the beginning of the \"main\" method body.\n+                    System.out.println(\"Welcome to main!\");\n+                    \"\"\",\n+                    templateMain.withArgs(),\n+                    \"\"\"\n+                    System.out.println(\"Going to call other...\");\n+                    other();\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+\n+                private static void other() {\n+                \"\"\",\n+                \/\/ Have a separate method hook for other, so that it can insert\n+                \/\/ its own local variables.\n+                Hooks.METHOD_HOOK.set(\n+                    \"\"\"\n+                    System.out.println(\"Welcome to other!\");\n+                    \"\"\",\n+                    templateOther.withArgs(),\n+                    \"\"\"\n+                    System.out.println(\"Done with other.\");\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+                \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":543,"deletions":0,"binary":false,"changes":543,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test formatting of Integer, Long, Float and Double.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.tests.TestFormat\n+ *\/\n+\n+package template_framework.tests;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.generators.*;\n+import compiler.lib.verify.*;\n+import compiler.lib.template_framework.Template;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+public class TestFormat {\n+    record FormatInfo(int id, String type, Object value) {}\n+\n+    public static void main(String[] args) {\n+        List<FormatInfo> list = new ArrayList();\n+\n+        for (int i = 0; i < 1000; i++) {\n+            int v = Generators.G.ints().next();\n+            list.add(new FormatInfo(i, \"int\", v));\n+        }\n+\n+        for (int i = 1000; i < 2000; i++) {\n+            long v = Generators.G.longs().next();\n+            list.add(new FormatInfo(i, \"long\", v));\n+        }\n+\n+        for (int i = 2000; i < 3000; i++) {\n+            float v = Generators.G.floats().next();\n+            list.add(new FormatInfo(i, \"float\", v));\n+        }\n+\n+        for (int i = 3000; i < 4000; i++) {\n+            double v = Generators.G.doubles().next();\n+            list.add(new FormatInfo(i, \"double\", v));\n+        }\n+\n+        CompileFramework comp = new CompileFramework();\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(list));\n+        comp.compile();\n+\n+        \/\/ Run each of the \"get\" methods, and check the result.\n+        for (FormatInfo info : list) {\n+            Object ret1 = comp.invoke(\"p.xyz.InnerTest\", \"get_let_\" + info.id, new Object[] {});\n+            Object ret2 = comp.invoke(\"p.xyz.InnerTest\", \"get_token_\" + info.id, new Object[] {});\n+            System.out.println(\"id: \" + info.id + \" -> \" + info.value + \" == \" + ret1 + \" == \" + ret2);\n+            Verify.checkEQ(ret1, info.value);\n+            Verify.checkEQ(ret2, info.value);\n+        }\n+    }\n+\n+    private static String generate(List<FormatInfo> list) {\n+        \/\/ Generate 2 \"get\" methods, one that formats via \"let\" (hashtag), the other via direct token.\n+        var template1 = Template.make(\"info\", (FormatInfo info) -> body(\n+            let(\"id\", info.id()),\n+            let(\"type\", info.type()),\n+            let(\"value\", info.value()),\n+            \"\"\"\n+            public static #type get_let_#id() { return #value; }\n+            \"\"\",\n+            \"public static #type get_token_#id() { return \", info.value(), \"; }\\n\"\n+        ));\n+\n+        \/\/ For each FormatInfo in list, generate the \"get\" methods inside InnerTest class.\n+        var template2 = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+            public class InnerTest {\n+            \"\"\",\n+            list.stream().map(info -> template1.withArgs(info)).toList(),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        return template2.withArgs().render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestFormat.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,1267 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test some basic Template instantiations. We do not necessarily generate correct\n+ *          java code, we just test that the code generation deterministically creates the\n+ *          expected String.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.tests.TestTemplate\n+ *\/\n+\n+package template_framework.tests;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.HashSet;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.Name;\n+import compiler.lib.template_framework.Hook;\n+import compiler.lib.template_framework.TemplateBinding;\n+import compiler.lib.template_framework.RendererException;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.$;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.fuel;\n+import static compiler.lib.template_framework.Template.setFuelCost;\n+import static compiler.lib.template_framework.Template.addName;\n+import static compiler.lib.template_framework.Template.weighNames;\n+import static compiler.lib.template_framework.Template.sampleName;\n+\n+public class TestTemplate {\n+    interface FailingTest {\n+        void run();\n+    }\n+\n+    private record MyPrimitive(String name) implements Name.Type {\n+        @Override\n+        public boolean isSubtypeOf(Name.Type other) {\n+            return other instanceof MyPrimitive(String n) && n == name();\n+        }\n+\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyPrimitive myInt = new MyPrimitive(\"int\");\n+    private static final MyPrimitive myLong = new MyPrimitive(\"long\");\n+\n+    public static void main(String[] args) {\n+        testSingleLine();\n+        testMultiLine();\n+        testBodyTokens();\n+        testWithOneArguments();\n+        testWithTwoArguments();\n+        testWithThreeArguments();\n+        testNested();\n+        testHookSimple();\n+        testHookIsSet();\n+        testHookNested();\n+        testHookWithNestedTemplates();\n+        testHookRecursion();\n+        testDollar();\n+        testLet();\n+        testSelector();\n+        testRecursion();\n+        testFuel();\n+        testFuelCustom();\n+        testNames();\n+        testNames2();\n+        testNames3();\n+        testListArgument();\n+\n+        expectRendererException(() -> testFailingNestedRendering(), \"Nested render not allowed.\");\n+        expectRendererException(() -> $(\"name\"),                          \"A Template method such as\");\n+        expectRendererException(() -> let(\"x\",\"y\"),                       \"A Template method such as\");\n+        expectRendererException(() -> fuel(),                             \"A Template method such as\");\n+        expectRendererException(() -> setFuelCost(1.0f),                  \"A Template method such as\");\n+        expectRendererException(() -> weighNames(myInt, true),            \"A Template method such as\");\n+        expectRendererException(() -> sampleName(myInt, true),            \"A Template method such as\");\n+        expectRendererException(() -> (new Hook(\"abc\")).isSet(),          \"A Template method such as\");\n+        expectRendererException(() -> testFailingHook(), \"Hook 'Hook1' was referenced but not found!\");\n+        expectRendererException(() -> testFailingSample(), \"No variable of type 'int'.\");\n+        expectRendererException(() -> testFailingHashtag1(), \"Duplicate hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingHashtag2(), \"Duplicate hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingHashtag3(), \"Duplicate hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingHashtag4(), \"Missing hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingBinding1(), \"Duplicate 'bind' not allowed.\");\n+        expectRendererException(() -> testFailingBinding2(), \"Cannot 'get' before 'bind'.\");\n+        expectIllegalArgumentException(() -> body(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> body(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> body(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        Hook hook1 = new Hook(\"Hook1\");\n+        expectIllegalArgumentException(() -> hook1.set(null),         \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> hook1.set(\"x\", null),    \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> hook1.set(hook1),        \"Unexpected token:\");\n+    }\n+\n+    public static void testSingleLine() {\n+        var template = Template.make(() -> body(\"Hello World!\"));\n+        String code = template.withArgs().render();\n+        checkEQ(code, \"Hello World!\");\n+    }\n+\n+    public static void testMultiLine() {\n+        var template = Template.make(() -> body(\n+            \"\"\"\n+            Code on more\n+            than a single line\n+            \"\"\"\n+        ));\n+        String code = template.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            Code on more\n+            than a single line\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testBodyTokens() {\n+        \/\/ We can fill the body with Objects of different types, and they get concatenated.\n+        \/\/ Lists get flattened into the body.\n+        var template = Template.make(() -> body(\n+            \"start \",\n+            Integer.valueOf(1), 1,\n+            Long.valueOf(2), 2L,\n+            Double.valueOf(3.4), 3.4,\n+            Float.valueOf(5.6f), 5.6f,\n+            List.of(\" \", 1, \" and \", 2),\n+            \" end\"\n+        ));\n+        String code = template.withArgs().render();\n+        checkEQ(code, \"start 112L2L3.43.45.6f5.6f 1 and 2 end\");\n+    }\n+\n+    public static void testWithOneArguments() {\n+        \/\/ Capture String argument via String name.\n+        var template1 = Template.make(\"a\", (String a) -> body(\"start #a end\"));\n+        checkEQ(template1.withArgs(\"x\").render(), \"start x end\");\n+        checkEQ(template1.withArgs(\"a\").render(), \"start a end\");\n+        checkEQ(template1.withArgs(\"\" ).render(), \"start  end\");\n+\n+        \/\/ Capture String argument via typed lambda argument.\n+        var template2 = Template.make(\"a\", (String a) -> body(\"start \", a, \" end\"));\n+        checkEQ(template2.withArgs(\"x\").render(), \"start x end\");\n+        checkEQ(template2.withArgs(\"a\").render(), \"start a end\");\n+        checkEQ(template2.withArgs(\"\" ).render(), \"start  end\");\n+\n+        \/\/ Capture Integer argument via String name.\n+        var template3 = Template.make(\"a\", (Integer a) -> body(\"start #a end\"));\n+        checkEQ(template3.withArgs(0  ).render(), \"start 0 end\");\n+        checkEQ(template3.withArgs(22 ).render(), \"start 22 end\");\n+        checkEQ(template3.withArgs(444).render(), \"start 444 end\");\n+\n+        \/\/ Capture Integer argument via templated lambda argument.\n+        var template4 = Template.make(\"a\", (Integer a) -> body(\"start \", a, \" end\"));\n+        checkEQ(template4.withArgs(0  ).render(), \"start 0 end\");\n+        checkEQ(template4.withArgs(22 ).render(), \"start 22 end\");\n+        checkEQ(template4.withArgs(444).render(), \"start 444 end\");\n+\n+        \/\/ Test Strings with backslashes:\n+        var template5 = Template.make(\"a\", (String a) -> body(\"start #a \" + a + \" end\"));\n+        checkEQ(template5.withArgs(\"\/\").render(), \"start \/ \/ end\");\n+        checkEQ(template5.withArgs(\"\\\\\").render(), \"start \\\\ \\\\ end\");\n+        checkEQ(template5.withArgs(\"\\\\\\\\\").render(), \"start \\\\\\\\ \\\\\\\\ end\");\n+    }\n+\n+    public static void testWithTwoArguments() {\n+        \/\/ Capture 2 String arguments via String names.\n+        var template1 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\"start #a1 #a2 end\"));\n+        checkEQ(template1.withArgs(\"x\", \"y\").render(), \"start x y end\");\n+        checkEQ(template1.withArgs(\"a\", \"b\").render(), \"start a b end\");\n+        checkEQ(template1.withArgs(\"\",  \"\" ).render(), \"start   end\");\n+\n+        \/\/ Capture 2 String arguments via typed lambda arguments.\n+        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\"start \", a1, \" \", a2, \" end\"));\n+        checkEQ(template2.withArgs(\"x\", \"y\").render(), \"start x y end\");\n+        checkEQ(template2.withArgs(\"a\", \"b\").render(), \"start a b end\");\n+        checkEQ(template2.withArgs(\"\",  \"\" ).render(), \"start   end\");\n+\n+        \/\/ Capture 2 Integer arguments via String names.\n+        var template3 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> body(\"start #a1 #a2 end\"));\n+        checkEQ(template3.withArgs(0,   1  ).render(), \"start 0 1 end\");\n+        checkEQ(template3.withArgs(22,  33 ).render(), \"start 22 33 end\");\n+        checkEQ(template3.withArgs(444, 555).render(), \"start 444 555 end\");\n+\n+        \/\/ Capture 2 Integer arguments via templated lambda arguments.\n+        var template4 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> body(\"start \", a1, \" \", a2, \" end\"));\n+        checkEQ(template4.withArgs(0,   1  ).render(), \"start 0 1 end\");\n+        checkEQ(template4.withArgs(22,  33 ).render(), \"start 22 33 end\");\n+        checkEQ(template4.withArgs(444, 555).render(), \"start 444 555 end\");\n+    }\n+\n+    public static void testWithThreeArguments() {\n+        \/\/ Capture 3 String arguments via String names.\n+        var template1 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> body(\"start #a1 #a2 #a3 end\"));\n+        checkEQ(template1.withArgs(\"x\", \"y\", \"z\").render(), \"start x y z end\");\n+        checkEQ(template1.withArgs(\"a\", \"b\", \"c\").render(), \"start a b c end\");\n+        checkEQ(template1.withArgs(\"\",  \"\", \"\" ).render(),  \"start    end\");\n+\n+        \/\/ Capture 3 String arguments via typed lambda arguments.\n+        var template2 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> body(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n+        checkEQ(template1.withArgs(\"x\", \"y\", \"z\").render(), \"start x y z end\");\n+        checkEQ(template1.withArgs(\"a\", \"b\", \"c\").render(), \"start a b c end\");\n+        checkEQ(template1.withArgs(\"\",  \"\", \"\" ).render(),  \"start    end\");\n+\n+        \/\/ Capture 3 Integer arguments via String names.\n+        var template3 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> body(\"start #a1 #a2 #a3 end\"));\n+        checkEQ(template3.withArgs(0,   1  , 2  ).render(), \"start 0 1 2 end\");\n+        checkEQ(template3.withArgs(22,  33 , 44 ).render(), \"start 22 33 44 end\");\n+        checkEQ(template3.withArgs(444, 555, 666).render(), \"start 444 555 666 end\");\n+\n+        \/\/ Capture 2 Integer arguments via templated lambda arguments.\n+        var template4 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> body(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n+        checkEQ(template3.withArgs(0,   1  , 2  ).render(), \"start 0 1 2 end\");\n+        checkEQ(template3.withArgs(22,  33 , 44 ).render(), \"start 22 33 44 end\");\n+        checkEQ(template3.withArgs(444, 555, 666).render(), \"start 444 555 666 end\");\n+    }\n+\n+    public static void testNested() {\n+        var template1 = Template.make(() -> body(\"proton\"));\n+\n+        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\n+            \"electron #a1\\n\",\n+            \"neutron #a2\\n\"\n+        ));\n+\n+        var template3 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\n+            \"Universe \", template1.withArgs(), \" {\\n\",\n+                template2.withArgs(\"up\", \"down\"),\n+                template2.withArgs(a1, a2),\n+            \"}\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            template3.withArgs(\"low\", \"high\"),\n+            \"{\\n\",\n+                template3.withArgs(\"42\", \"24\"),\n+            \"}\"\n+        ));\n+\n+        String code = template4.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            Universe proton {\n+            electron up\n+            neutron down\n+            electron low\n+            neutron high\n+            }\n+            {\n+            Universe proton {\n+            electron up\n+            neutron down\n+            electron 42\n+            neutron 24\n+            }\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookSimple() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\"Hello\\n\"));\n+\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            hook1.set(\n+                \"World\\n\",\n+                hook1.insert(template1.withArgs())\n+            ),\n+            \"}\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            Hello\n+            World\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookIsSet() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template0 = Template.make(() -> body(\"isSet: \", hook1.isSet(), \"\\n\"));\n+\n+        var template1 = Template.make(() -> body(\"Hello\\n\", template0.withArgs()));\n+\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            template0.withArgs(),\n+            hook1.set(\n+                \"World\\n\",\n+                template0.withArgs(),\n+                hook1.insert(template1.withArgs())\n+            ),\n+            template0.withArgs(),\n+            \"}\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            isSet: false\n+            Hello\n+            isSet: true\n+            World\n+            isSet: true\n+            isSet: false\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookNested() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+\n+        \/\/ Test nested use of hooks in the same template.\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            hook1.set(), \/\/ empty\n+            \"zero\\n\",\n+            hook1.set(\n+                template1.withArgs(\"one\"),\n+                template1.withArgs(\"two\"),\n+                hook1.insert(template1.withArgs(\"intoHook1a\")),\n+                hook1.insert(template1.withArgs(\"intoHook1b\")),\n+                template1.withArgs(\"three\"),\n+                hook1.set(\n+                    template1.withArgs(\"four\"),\n+                    hook1.insert(template1.withArgs(\"intoHook1c\")),\n+                    template1.withArgs(\"five\")\n+                ),\n+                template1.withArgs(\"six\"),\n+                hook1.set(), \/\/ empty\n+                template1.withArgs(\"seven\"),\n+                hook1.insert(template1.withArgs(\"intoHook1d\")),\n+                template1.withArgs(\"eight\"),\n+                hook1.set(\n+                    template1.withArgs(\"nine\"),\n+                    hook1.insert(template1.withArgs(\"intoHook1e\")),\n+                    template1.withArgs(\"ten\")\n+                ),\n+                template1.withArgs(\"eleven\")\n+            ),\n+            \"}\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            zero\n+            x intoHook1a x\n+            x intoHook1b x\n+            x intoHook1d x\n+            x one x\n+            x two x\n+            x three x\n+            x intoHook1c x\n+            x four x\n+            x five x\n+            x six x\n+            x seven x\n+            x eight x\n+            x intoHook1e x\n+            x nine x\n+            x ten x\n+            x eleven x\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookWithNestedTemplates() {\n+        var hook1 = new Hook(\"Hook1\");\n+        var hook2 = new Hook(\"Hook2\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+\n+        var template2 = Template.make(\"b\", (String b) -> body(\n+            \"{\\n\",\n+            template1.withArgs(b + \"A\"),\n+            hook1.insert(template1.withArgs(b + \"B\")),\n+            hook2.insert(template1.withArgs(b + \"C\")),\n+            template1.withArgs(b + \"D\"),\n+            hook1.set(\n+                template1.withArgs(b + \"E\"),\n+                hook1.insert(template1.withArgs(b + \"F\")),\n+                hook2.insert(template1.withArgs(b + \"G\")),\n+                template1.withArgs(b + \"H\"),\n+                hook2.set(\n+                    template1.withArgs(b + \"I\"),\n+                    hook1.insert(template1.withArgs(b + \"J\")),\n+                    hook2.insert(template1.withArgs(b + \"K\")),\n+                    template1.withArgs(b + \"L\")\n+                ),\n+                template1.withArgs(b + \"M\"),\n+                hook1.insert(template1.withArgs(b + \"N\")),\n+                hook2.insert(template1.withArgs(b + \"O\")),\n+                template1.withArgs(b + \"O\")\n+            ),\n+            template1.withArgs(b + \"P\"),\n+            hook1.insert(template1.withArgs(b + \"Q\")),\n+            hook2.insert(template1.withArgs(b + \"R\")),\n+            template1.withArgs(b + \"S\"),\n+            \"}\\n\"\n+        ));\n+\n+        \/\/ Test use of hooks across templates.\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            \"base-A\\n\",\n+            hook1.set(\n+                \"base-B\\n\",\n+                hook2.set(\n+                    \"base-C\\n\",\n+                    template2.withArgs(\"sub-\"),\n+                    \"base-D\\n\"\n+                ),\n+                \"base-E\\n\"\n+            ),\n+            \"base-F\\n\",\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            base-A\n+            x sub-B x\n+            x sub-Q x\n+            base-B\n+            x sub-C x\n+            x sub-G x\n+            x sub-O x\n+            x sub-R x\n+            base-C\n+            {\n+            x sub-A x\n+            x sub-D x\n+            x sub-F x\n+            x sub-J x\n+            x sub-N x\n+            x sub-E x\n+            x sub-H x\n+            x sub-K x\n+            x sub-I x\n+            x sub-L x\n+            x sub-M x\n+            x sub-O x\n+            x sub-P x\n+            x sub-S x\n+            }\n+            base-D\n+            base-E\n+            base-F\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookRecursion() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+\n+        var template2 = Template.make(\"b\", (String b) -> body(\n+            \"<\\n\",\n+            template1.withArgs(b + \"A\"),\n+            hook1.insert(template1.withArgs(b + \"B\")), \/\/ sub-B is rendered before template2.\n+            template1.withArgs(b + \"C\"),\n+            \"inner-hook-start\\n\",\n+            hook1.set(\n+                \"inner-hook-end\\n\",\n+                template1.withArgs(b + \"E\"),\n+                hook1.insert(template1.withArgs(b + \"E\")),\n+                template1.withArgs(b + \"F\")\n+            ),\n+            \">\\n\"\n+        ));\n+\n+        \/\/ Test use of hooks across templates.\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            \"hook-start\\n\",\n+            hook1.set(\n+                \"hook-end\\n\",\n+                hook1.insert(template2.withArgs(\"sub-\")),\n+                \"base-C\\n\"\n+            ),\n+            \"base-D\\n\",\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            hook-start\n+            x sub-B x\n+            <\n+            x sub-A x\n+            x sub-C x\n+            inner-hook-start\n+            x sub-E x\n+            inner-hook-end\n+            x sub-E x\n+            x sub-F x\n+            >\n+            hook-end\n+            base-C\n+            base-D\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDollar() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x $name #a x\\n\"));\n+\n+        var template2 = Template.make(\"a\", (String a) -> body(\n+            \"{\\n\",\n+            \"y $name #a y\\n\",\n+            template1.withArgs($(\"name\")),\n+            \"}\\n\"\n+        ));\n+\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            \"$name\\n\",\n+            \"$name\", \"\\n\",\n+            \"z $name z\\n\",\n+            \"z$name z\\n\",\n+            template1.withArgs(\"name\"),     \/\/ does not capture -> literal \"$name\"\n+            template1.withArgs(\"$name\"),    \/\/ does not capture -> literal \"$name\"\n+            template1.withArgs($(\"name\")),  \/\/ capture replacement name \"name_1\"\n+            hook1.set(\n+                \"$name\\n\"\n+            ),\n+            \"break\\n\",\n+            hook1.set(\n+                \"one\\n\",\n+                hook1.insert(template1.withArgs($(\"name\"))),\n+                \"two\\n\",\n+                template1.withArgs($(\"name\")),\n+                \"three\\n\",\n+                hook1.insert(template2.withArgs($(\"name\"))),\n+                \"four\\n\"\n+            ),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            name_1\n+            name_1\n+            z name_1 z\n+            zname_1 z\n+            x name_2 name x\n+            x name_3 $name x\n+            x name_4 name_1 x\n+            name_1\n+            break\n+            x name_5 name_1 x\n+            {\n+            y name_7 name_1 y\n+            x name_8 name_7 x\n+            }\n+            one\n+            two\n+            x name_6 name_1 x\n+            three\n+            four\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testLet() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\n+            \"{\\n\",\n+            \"y #a y\\n\",\n+            let(\"b\", \"<\" + a + \">\"),\n+            \"y #b y\\n\",\n+            \"}\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"a\", (Integer a) -> let(\"b\", a * 10, b ->\n+            body(\n+                let(\"c\", b * 3),\n+                \"abc = #a #b #c\\n\"\n+            )\n+        ));\n+\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            let(\"x\", \"abc\"),\n+            template1.withArgs(\"alpha\"),\n+            \"break\\n\",\n+            \"x1 = #x\\n\",\n+            hook1.set(\n+                \"x2 = #x\\n\", \/\/ leaks inside\n+                template1.withArgs(\"beta\"),\n+                let(\"y\", \"one\"),\n+                \"y1 = #y\\n\"\n+            ),\n+            \"break\\n\",\n+            \"y2 = #y\\n\", \/\/ leaks outside\n+            \"break\\n\",\n+            template2.withArgs(5),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            {\n+            y alpha y\n+            y <alpha> y\n+            }\n+            break\n+            x1 = abc\n+            x2 = abc\n+            {\n+            y beta y\n+            y <beta> y\n+            }\n+            y1 = one\n+            break\n+            y2 = one\n+            break\n+            abc = 5 50 150\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testSelector() {\n+        var template1 = Template.make(\"a\", (String a) -> body(\n+            \"<\\n\",\n+            \"x #a x\\n\",\n+            \">\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"a\", (String a) -> body(\n+            \"<\\n\",\n+            \"y #a y\\n\",\n+            \">\\n\"\n+        ));\n+\n+        var template3 = Template.make(\"a\", (Integer a) -> body(\n+            \"[\\n\",\n+            \"z #a z\\n\",\n+            \/\/ Select which template should be used:\n+            a > 0 ? template1.withArgs(\"A_\" + a)\n+                  : template2.withArgs(\"B_\" + a),\n+            \"]\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"{\\n\",\n+            template3.withArgs(-1),\n+            \"break\\n\",\n+            template3.withArgs(0),\n+            \"break\\n\",\n+            template3.withArgs(1),\n+            \"break\\n\",\n+            template3.withArgs(2),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template4.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [\n+            z -1 z\n+            <\n+            y B_-1 y\n+            >\n+            ]\n+            break\n+            [\n+            z 0 z\n+            <\n+            y B_0 y\n+            >\n+            ]\n+            break\n+            [\n+            z 1 z\n+            <\n+            x A_1 x\n+            >\n+            ]\n+            break\n+            [\n+            z 2 z\n+            <\n+            x A_2 x\n+            >\n+            ]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testRecursion() {\n+        \/\/ Binding allows use of template1 inside template1, via the Binding indirection.\n+        var binding1 = new TemplateBinding<Template.OneArgs<Integer>>();\n+\n+        var template1 = Template.make(\"i\", (Integer i) -> body(\n+            \"[ #i\\n\",\n+            \/\/ We cannot yet use the template1 directly, as it is being defined.\n+            \/\/ So we use binding1 instead.\n+            i < 0 ? \"done\\n\" : binding1.get().withArgs(i - 1),\n+            \"] #i\\n\"\n+        ));\n+        binding1.bind(template1);\n+\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            \/\/ Now, we can use template1 normally, as it is already defined.\n+            template1.withArgs(3),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [ 3\n+            [ 2\n+            [ 1\n+            [ 0\n+            [ -1\n+            done\n+            ] -1\n+            ] 0\n+            ] 1\n+            ] 2\n+            ] 3\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFuel() {\n+        var template1 = Template.make(() -> body(\n+            let(\"f\", fuel()),\n+\n+            \"<#f>\\n\"\n+        ));\n+\n+        \/\/ Binding allows use of template2 inside template2, via the Binding indirection.\n+        var binding2 = new TemplateBinding<Template.OneArgs<Integer>>();\n+        var template2 = Template.make(\"i\", (Integer i) -> body(\n+            let(\"f\", fuel()),\n+\n+            \"[ #i #f\\n\",\n+            template1.withArgs(),\n+            fuel() <= 60.f ? \"done\" : binding2.get().withArgs(i - 1),\n+            \"] #i #f\\n\"\n+        ));\n+        binding2.bind(template2);\n+\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            template2.withArgs(3),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [ 3 90.0f\n+            <80.0f>\n+            [ 2 80.0f\n+            <70.0f>\n+            [ 1 70.0f\n+            <60.0f>\n+            [ 0 60.0f\n+            <50.0f>\n+            done] 0 60.0f\n+            ] 1 70.0f\n+            ] 2 80.0f\n+            ] 3 90.0f\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFuelCustom() {\n+        var template1 = Template.make(() -> body(\n+            setFuelCost(2.0f),\n+            let(\"f\", fuel()),\n+\n+            \"<#f>\\n\"\n+        ));\n+\n+        \/\/ Binding allows use of template2 inside template2, via the Binding indirection.\n+        var binding2 = new TemplateBinding<Template.OneArgs<Integer>>();\n+        var template2 = Template.make(\"i\", (Integer i) -> body(\n+            setFuelCost(3.0f),\n+            let(\"f\", fuel()),\n+\n+            \"[ #i #f\\n\",\n+            template1.withArgs(),\n+            fuel() <= 5.f ? \"done\\n\" : binding2.get().withArgs(i - 1),\n+            \"] #i #f\\n\"\n+        ));\n+        binding2.bind(template2);\n+\n+        var template3 = Template.make(() -> body(\n+            setFuelCost(5.0f),\n+            let(\"f\", fuel()),\n+\n+            \"{ #f\\n\",\n+            template2.withArgs(3),\n+            \"} #f\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render(20.0f);\n+        String expected =\n+            \"\"\"\n+            { 20.0f\n+            [ 3 15.0f\n+            <12.0f>\n+            [ 2 12.0f\n+            <9.0f>\n+            [ 1 9.0f\n+            <6.0f>\n+            [ 0 6.0f\n+            <3.0f>\n+            [ -1 3.0f\n+            <0.0f>\n+            done\n+            ] -1 3.0f\n+            ] 0 6.0f\n+            ] 1 9.0f\n+            ] 2 12.0f\n+            ] 3 15.0f\n+            } 20.0f\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testNames() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\n+            \"[\", weighNames(myInt, true), \"]\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"name\", \"type\", (String name, Name.Type type) -> body(\n+            addName(new Name(name, type, true, 1)),\n+            \"define #type #name\\n\",\n+            template1.withArgs()\n+        ));\n+\n+        var template3 = Template.make(() -> body(\n+            \"<\\n\",\n+            hook1.insert(template2.withArgs($(\"name\"), myInt)),\n+            \"$name = 5\\n\",\n+            \">\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"{\\n\",\n+            template1.withArgs(),\n+            hook1.set(\n+                template1.withArgs(),\n+                \"something\\n\",\n+                template3.withArgs(),\n+                \"more\\n\",\n+                template1.withArgs(),\n+                \"more\\n\",\n+                template2.withArgs($(\"name\"), myInt),\n+                \"more\\n\",\n+                template1.withArgs()\n+            ),\n+            template1.withArgs(),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template4.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [0L]\n+            define int name_4\n+            [1L]\n+            [0L]\n+            something\n+            <\n+            name_4 = 5\n+            >\n+            more\n+            [1L]\n+            more\n+            define int name_1\n+            [2L]\n+            more\n+            [1L]\n+            [0L]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testNames2() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"type\", (Name.Type type) -> body(\n+            \"[#type: \", weighNames(type, true), \" and \", weighNames(type, false), \"]\\n\"\n+        ));\n+\n+\n+        var template2 = Template.make(\"name\", \"type\", (String name, Name.Type type) -> body(\n+            addName(new Name(name, type, true, 1)),\n+            \"define mutable #type #name\\n\",\n+            template1.withArgs(type)\n+        ));\n+\n+        var template3 = Template.make(\"name\", \"type\", (String name, Name.Type type) -> body(\n+            addName(new Name(name, type, false, 1)),\n+            \"define immutable #type #name\\n\",\n+            template1.withArgs(type)\n+        ));\n+\n+        var template4 = Template.make(\"type\", (Name.Type type) -> body(\n+            \"{ $store\\n\",\n+            hook1.insert(template2.withArgs($(\"name\"), type)),\n+            \"$name = 5\\n\",\n+            \"} $store\\n\"\n+        ));\n+\n+        var template5 = Template.make(\"type\", (Name.Type type) -> body(\n+            \"{ $load\\n\",\n+            hook1.insert(template3.withArgs($(\"name\"), type)),\n+            \"blackhole($name)\\n\",\n+            \"} $load\\n\"\n+        ));\n+\n+        var template6 = Template.make(\"type\", (Name.Type type) -> body(\n+            let(\"v\", sampleName(type, true).name()),\n+            \"{ $sample\\n\",\n+            \"#v = 7\\n\",\n+            \"} $sample\\n\"\n+        ));\n+\n+        var template7 = Template.make(\"type\", (Name.Type type) -> body(\n+            let(\"v\", sampleName(type, false).name()),\n+            \"{ $sample\\n\",\n+            \"blackhole(#v)\\n\",\n+            \"} $sample\\n\"\n+        ));\n+\n+        var template8 = Template.make(() -> body(\n+            \"class $X {\\n\",\n+            template1.withArgs(myInt),\n+            hook1.set(\n+                \"begin $body\\n\",\n+                template1.withArgs(myInt),\n+                \"start with immutable\\n\",\n+                template5.withArgs(myInt),\n+                \"then load from it\\n\",\n+                template7.withArgs(myInt),\n+                template1.withArgs(myInt),\n+                \"now make something mutable\\n\",\n+                template4.withArgs(myInt),\n+                \"then store to it\\n\",\n+                template6.withArgs(myInt),\n+                template1.withArgs(myInt)\n+            ),\n+            template1.withArgs(myInt),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template8.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            class X_1 {\n+            [int: 0L and 0L]\n+            define immutable int name_4\n+            [int: 0L and 1L]\n+            define mutable int name_9\n+            [int: 1L and 2L]\n+            begin body_1\n+            [int: 0L and 0L]\n+            start with immutable\n+            { load_4\n+            blackhole(name_4)\n+            } load_4\n+            then load from it\n+            { sample_7\n+            blackhole(name_4)\n+            } sample_7\n+            [int: 0L and 1L]\n+            now make something mutable\n+            { store_9\n+            name_9 = 5\n+            } store_9\n+            then store to it\n+            { sample_12\n+            name_9 = 7\n+            } sample_12\n+            [int: 1L and 2L]\n+            [int: 0L and 0L]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testNames3() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"type\", (Name.Type type) -> body(\n+            \"[#type: \", weighNames(type, true), \" and \", weighNames(type, false), \"]\\n\"\n+        ));\n+\n+        \/\/ Example that shows that addName runs before any code gets generated.\n+        \/\/ To avoid this behaviour, you have to wrap the addName in their own template.\n+        var template2 = Template.make(() -> body(\n+            \"class $Y {\\n\",\n+            template1.withArgs(myInt),\n+            hook1.set(\n+                \"begin $body\\n\",\n+                template1.withArgs(myInt),\n+                \"define mutable\\n\",\n+                addName(new Name($(\"v1\"), myInt, true, 1)),\n+                template1.withArgs(myInt),\n+                \"define immutable\\n\",\n+                addName(new Name($(\"v1\"), myInt, false, 1)),\n+                template1.withArgs(myInt)\n+            ),\n+            template1.withArgs(myInt),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            class Y_1 {\n+            [int: 0L and 0L]\n+            begin body_1\n+            [int: 0L and 0L]\n+            define mutable\n+            [int: 1L and 1L]\n+            define immutable\n+            [int: 1L and 2L]\n+            [int: 0L and 0L]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    record MyItem(Name.Type type, String op) {}\n+\n+    public static void testListArgument() {\n+        var template1 = Template.make(\"item\", (MyItem item) -> body(\n+            let(\"type\", item.type()),\n+            let(\"op\", item.op()),\n+            \"#type apply #op\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"list\", (List<MyItem> list) -> body(\n+            \"class $Z {\\n\",\n+            \/\/ Use template1 for every item in the list.\n+            list.stream().map(item -> template1.withArgs(item)).toList(),\n+            \"}\\n\"\n+        ));\n+\n+        List<MyItem> list = List.of(new MyItem(myInt, \"+\"),\n+                                    new MyItem(myInt, \"-\"),\n+                                    new MyItem(myInt, \"*\"),\n+                                    new MyItem(myInt, \"\/\"),\n+                                    new MyItem(myLong, \"+\"),\n+                                    new MyItem(myLong, \"-\"),\n+                                    new MyItem(myLong, \"*\"),\n+                                    new MyItem(myLong, \"\/\"));\n+\n+        String code = template2.withArgs(list).render();\n+        String expected =\n+            \"\"\"\n+            class Z_1 {\n+            int apply +\n+            int apply -\n+            int apply *\n+            int apply \/\n+            long apply +\n+            long apply -\n+            long apply *\n+            long apply \/\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFailingNestedRendering() {\n+        var template1 = Template.make(() -> body(\n+            \"alpha\\n\"\n+        ));\n+\n+        var template2 = Template.make(() -> body(\n+            \"beta\\n\",\n+            \/\/ Nested \"render\" call not allowed!\n+            template1.withArgs().render(),\n+            \"gamma\\n\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+    }\n+\n+    public static void testFailingHook() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\n+            \"alpha\\n\"\n+        ));\n+\n+        var template2 = Template.make(() -> body(\n+            \"beta\\n\",\n+            \/\/ Use hook without hook1.set\n+            hook1.insert(template1.withArgs()),\n+            \"gamma\\n\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+    }\n+\n+    public static void testFailingSample() {\n+        var template1 = Template.make(() -> body(\n+            let(\"v\", sampleName(myInt, true).name()),\n+            \"v is #v\\n\"\n+        ));\n+\n+        String code = template1.withArgs().render();\n+    }\n+\n+    public static void testFailingHashtag1() {\n+        var template1 = Template.make(\"a\", \"a\", (String _, String _) -> body(\n+            \"nothing\\n\"\n+        ));\n+\n+        String code = template1.withArgs(\"x\", \"y\").render();\n+    }\n+\n+    public static void testFailingHashtag2() {\n+        var template1 = Template.make(\"a\", (String _) -> body(\n+            let(\"a\", \"x\"),\n+            \"nothing\\n\"\n+        ));\n+\n+        String code = template1.withArgs(\"y\").render();\n+    }\n+\n+    public static void testFailingHashtag3() {\n+        var template1 = Template.make(() -> body(\n+            let(\"a\", \"x\"),\n+            let(\"a\", \"y\"),\n+            \"nothing\\n\"\n+        ));\n+\n+        String code = template1.withArgs().render();\n+    }\n+\n+    public static void testFailingHashtag4() {\n+        var template1 = Template.make(() -> body(\n+            \"#a\\n\"\n+        ));\n+\n+        String code = template1.withArgs().render();\n+    }\n+\n+    public static void testFailingBinding1() {\n+        var binding = new TemplateBinding<Template.ZeroArgs>();\n+        var template1 = Template.make(() -> body(\n+            \"nothing\\n\"\n+        ));\n+        binding.bind(template1);\n+        binding.bind(template1);\n+    }\n+\n+    public static void testFailingBinding2() {\n+        var binding = new TemplateBinding<Template.ZeroArgs>();\n+        var template1 = Template.make(() -> body(\n+            \"nothing\\n\",\n+            binding.get().withArgs()\n+        ));\n+        String code = template1.withArgs().render();\n+    }\n+\n+    public static void expectRendererException(FailingTest test, String errorPrefix) {\n+        try {\n+            test.run();\n+            System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+            throw new RuntimeException(\"Should have thrown!\");\n+        } catch(RendererException e) {\n+            if (!e.getMessage().startsWith(errorPrefix)) {\n+                System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+                System.out.println(\"got: \" + e.getMessage());\n+                throw new RuntimeException(\"Prefix mismatch\", e);\n+            }\n+        }\n+    }\n+\n+    public static void expectIllegalArgumentException(FailingTest test, String errorPrefix) {\n+        try {\n+            test.run();\n+            System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+            throw new RuntimeException(\"Should have thrown!\");\n+        } catch(IllegalArgumentException e) {\n+            if (!e.getMessage().startsWith(errorPrefix)) {\n+                System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+                System.out.println(\"got: \" + e.getMessage());\n+                throw new RuntimeException(\"Prefix mismatch\", e);\n+            }\n+        }\n+    }\n+\n+    public static void checkEQ(String code, String expected) {\n+        if (!code.equals(expected)) {\n+            System.out.println(\"\\\"\" + code + \"\\\"\");\n+            System.out.println(\"\\\"\" + expected + \"\\\"\");\n+            throw new RuntimeException(\"Template rendering mismatch!\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestTemplate.java","additions":1267,"deletions":0,"binary":false,"changes":1267,"status":"added"}]}