{"files":[{"patch":"@@ -69,1 +69,2 @@\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest8\", generateWithNames());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest8\", generateWithNamesForFieldsAndVariables());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9\", generateWithNamesForMethods());\n@@ -86,0 +87,1 @@\n+        comp.invoke(\"p.xyz.InnerTest9\", \"main\", new Object[] {});\n@@ -532,1 +534,1 @@\n-    public static String generateWithNames() {\n+    public static String generateWithNamesForFieldsAndVariables() {\n@@ -674,0 +676,88 @@\n+\n+    \/\/ We kept the Names purposfully abstract, so that it can not just be used for\n+    \/\/ fields or variables, but many other applications. Some ideas:\n+    \/\/ - Method names. The Type could represent the signature of the static method\n+    \/\/                 or the class of the non-static method.\n+    \/\/ - Class names. Type could represent the signature of the constructor, so\n+    \/\/                that we could instantiate random instances.\n+    \/\/ - try\/catch blocks. If a specific Exception is caught in the scope, we could\n+    \/\/                     register that Exception, and in the inner scope we can\n+    \/\/                     check the weight for an Exception and its subtypes. If\n+    \/\/                     the weight is non-zero, we know the exception would be\n+    \/\/                     caught.\n+    \/\/\n+    \/\/ Let us show an examples with Method names. But for simplicity, we assume they\n+    \/\/ all have the same signature: they take two int arguments and return an int.\n+    private record MyMethod() implements Name.Type {\n+        @Override\n+        public boolean isSubtypeOf(Name.Type other) {\n+            return other instanceof MyMethod();\n+        }\n+\n+        @Override\n+        public String name() { return \"<not used, don't worry>\"; }\n+    }\n+    private static final MyMethod myMethod = new MyMethod();\n+\n+    public static String generateWithNamesForMethods() {\n+        \/\/ Define a method, which takes two ints, returns the result of op.\n+        var templateMethod = Template.make(\"op\", (String op) -> body(\n+            \/\/ Register the method name, so we can later sample.\n+            \/\/ Note: method names are not mutable.\n+            addName(new Name($(\"methodName\"), myMethod, false, 1)),\n+            \"\"\"\n+            public static int $methodName(int a, int b) {\n+                return a #op b;\n+            }\n+            \"\"\"\n+        ));\n+\n+        var templateSample = Template.make(() -> body(\n+            \/\/ Sample a random method, and retrieve its name.\n+            let(\"methodName\", sampleName(myMethod, false).name()),\n+            \"\"\"\n+            System.out.println(\"Calling #methodName with inputs 7 and 11\");\n+            System.out.println(\"  result: \" + #methodName(7, 11));\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest9 {\n+                \/\/ Let us define some methods that we can sample from later.\n+            \"\"\",\n+            \/\/ We must set a CLASS_HOOK here, and insert the method definitions to that hook.\n+            Hooks.CLASS_HOOK.set(\n+                \/\/ If we directly nest the templateMethod, then the addName goes to the nested\n+                \/\/ scope, and is not available at the class scope, i.e. it is not visible\n+                \/\/ for sampleName in outside of the templateMethod.\n+                \/\/ DO NOT DO THIS, the nested addName will not be visible:\n+                \"\/\/ We cannot sample from the following methods:\\n\",\n+                templateMethod.asToken(\"+\"),\n+                templateMethod.asToken(\"-\"),\n+                \/\/ However, if we insert to the CLASS_HOOK, then the Rendere makes the\n+                \/\/ scope of the inserted templateMethod transparent, and the addName\n+                \/\/ goes out to the scope of the CLASS_HOOK (but no further than that).\n+                \/\/ RATHER, DO THIS, to ensure the addName is visible:\n+                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"*\")),\n+                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"|\")),\n+                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"&\")),\n+                \"\"\"\n+\n+                    public static void main() {\n+                        \/\/ Now, we call some random methods, but only those that were inserted\n+                        \/\/ to the CLASS_HOOK.\n+                        \"\"\",\n+                        Collections.nCopies(10, templateSample.asToken()),\n+                        \"\"\"\n+                    }\n+                }\n+                \"\"\"\n+            )\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":92,"deletions":2,"binary":false,"changes":94,"status":"modified"}]}