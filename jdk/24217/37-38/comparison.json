{"files":[{"patch":"@@ -62,9 +62,10 @@\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest1\", generateWithListOfTokens());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest2\", generateWithTemplateArguments());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest3\", generateWithHashtagAndDollarReplacements());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest4\", generateWithCustomHooks());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest5\", generateWithLibraryHooks());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest6\", generateWithRecursionAndBindingsAndFuel());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest7\", generateWithNamesSimple());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest8\", generateWithNamesForFieldsAndVariables());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest9\", generateWithNamesForMethods());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest1\",  generateWithListOfTokens());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest2\",  generateWithTemplateArguments());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest3\",  generateWithHashtagAndDollarReplacements());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest4\",  generateWithCustomHooks());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest5\",  generateWithLibraryHooks());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest6\",  generateWithRecursionAndBindingsAndFuel());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest7\",  generateWithNamesSimple());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest8\",  generateWithNamesForFieldsAndVariables());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9\",  generateWithNamesForMethods());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest10\", generateWithNamesForFuzzing());\n@@ -79,9 +80,10 @@\n-        comp.invoke(\"p.xyz.InnerTest1\", \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest2\", \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest3\", \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest4\", \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest5\", \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest6\", \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest7\", \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest8\", \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest9\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest1\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest2\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest3\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest4\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest5\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest6\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest7\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest8\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest9\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest10\", \"main\", new Object[] {});\n@@ -764,0 +766,114 @@\n+\n+    \/\/ There are two more concepts to understand more deeply with Names.\n+    \/\/\n+    \/\/ One is the use of mutable and immutable Names.\n+    \/\/ In some cases, we only want to sample Names that are mutable, because\n+    \/\/ we want to store to a field or variable. We have to make sure that we\n+    \/\/ do not generate code that tries to store to a final field or variable.\n+    \/\/ In other cases, we are only want to load, and we do not care if the\n+    \/\/ fields or variables are final or non-final.\n+    \/\/\n+    \/\/ Another concept is subtyping of Name Types. With primitive types, this\n+    \/\/ is irrelevant, but with instances of Objects, this becomes relevant.\n+    \/\/ We may want to load an object of any field or variable of a certain\n+    \/\/ class, or any subclass.\n+    \/\/\n+    \/\/ Let us look at an example that demonstrates these two concepts.\n+    \/\/\n+    \/\/ First, we define a Name Type that represents different classes, that\n+    \/\/ may or may not be in a subtype relation. Subtypes start with the name\n+    \/\/ of the super type.\n+    private record MyClass(String name) implements Name.Type {\n+        @Override\n+        public boolean isSubtypeOf(Name.Type other) {\n+            return other instanceof MyClass(String n) && name().startsWith(n);\n+        }\n+\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyClass myClassA   = new MyClass(\"MyClassA\");\n+    private static final MyClass myClassA1  = new MyClass(\"MyClassA1\");\n+    private static final MyClass myClassA2  = new MyClass(\"MyClassA2\");\n+    private static final MyClass myClassA11 = new MyClass(\"MyClassA11\");\n+    private static final MyClass myClassB   = new MyClass(\"MyClassB\");\n+    private static final List<MyClass> myClassList = List.of(myClassA, myClassA1, myClassA2, myClassA11, myClassB);\n+\n+    public static String generateWithNamesForFuzzing() {\n+        var templateStaticField = Template.make(\"type\", \"mutable\", (Name.Type type, Boolean mutable) -> body(\n+            addName(new Name($(\"field\"), type, mutable, 1)),\n+            let(\"isFinal\", mutable ? \"\" : \"final\"),\n+            \"\"\"\n+            public static #isFinal #type $field = new #type();\n+            \"\"\"\n+        ));\n+\n+        var templateLoad = Template.make(\"type\", (Name.Type type) -> body(\n+            \/\/ We only load from the field, so we do not need a mutable one,\n+            \/\/ we can load from final and non-final fields.\n+            let(\"field\", sampleName(type, false).name()),\n+            \"\"\"\n+            System.out.println(\"#field: \" + #field);\n+            \"\"\"\n+        ));\n+\n+        var templateStore = Template.make(\"type\", (Name.Type type) -> body(\n+            \/\/ We are storing to a field, so it better be non-final, i.e. mutable.\n+            let(\"field\", sampleName(type, true).name()),\n+            \"\"\"\n+            #field = null;\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest10 {\n+                \/\/ First, we define our classes.\n+                public static class MyClassA {}\n+                public static class MyClassA1 extends MyClassA {}\n+                public static class MyClassA2 extends MyClassA {}\n+                public static class MyClassA11 extends MyClassA1 {}\n+                public static class MyClassB {}\n+\n+                \/\/ Now, we define a list of static fields. Some of them are final, others not.\n+                \"\"\",\n+                \/\/ We must create a CLASS_HOOK and insert the fields to it. Otherwise,\n+                \/\/ addName is restricted to the scope of the templateStaticField. But\n+                \/\/ with the insertion to CLASS_HOOK, the addName goes through the scope\n+                \/\/ of the templateStaticField out to the scope of the CLASS_HOOK.\n+                Hooks.CLASS_HOOK.set(\n+                    myClassList.stream().map(c ->\n+                        (Object)Hooks.CLASS_HOOK.insert(templateStaticField.asToken(c, true))\n+                    ).toList(),\n+                    myClassList.stream().map(c ->\n+                        (Object)Hooks.CLASS_HOOK.insert(templateStaticField.asToken(c, false))\n+                    ).toList(),\n+                    \"\"\"\n+\n+                    public static void main() {\n+                        \/\/ All fields are still in their initial state.\n+                        \"\"\",\n+                        myClassList.stream().map(c -> templateLoad.asToken(c)).toList(),\n+                        \"\"\"\n+                        \/\/ Now lets mutate some fields.\n+                        \"\"\",\n+                        myClassList.stream().map(c -> templateStore.asToken(c)).toList(),\n+                        \"\"\"\n+                        \/\/ And now some fields are different than before.\n+                        \"\"\",\n+                        myClassList.stream().map(c -> templateLoad.asToken(c)).toList(),\n+                        \"\"\"\n+                    }\n+                    \"\"\"\n+                ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":134,"deletions":18,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    \/\/ Simulate a Classes. Subtypes start with the name of the super type.\n+    \/\/ Simulate classes. Subtypes start with the name of the super type.\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestTemplate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}