{"files":[{"patch":"@@ -4,0 +4,4 @@\n+We want to make it easy to generate variants of tests. Often, we would like to have a set of tests, corresponding to a set of types, a set of operators, a set of constants, etc. Writing all the tests by hand is cumbersome or even impossible. When generating such tests with scripts, it would be preferable if the code generation happens automatically, and the generator script was checked into the code base. Code generation can go beyond simple regression tests, and one might want to generate random code from a list of possible templates, to fuzz individual Java features and compiler optimizations.\n+\n+The Template Framework provides a facility to generate code with Templates. Templates are essencially a list of tokens that are concatenated (i.e. rendered) to a String. The Templates can have \"holes\", which are filled (replaced) by different values at each Template instantiation. For example, these \"holes\" can be filled with different types, operators or constants. Templates can also be nested, allowing a modular use of the Templates.\n+\n@@ -6,1 +10,1 @@\n-The basic functionalities of the Template Framework are described in the [Template Interface](.\/Template.java), together with some examples. More examples can be found in [TestSimple.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestSimple.java) and [TestTutorial.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java).\n+The basic functionalities of the Template Framework are described in the [Template Interface](.\/Template.java), together with some examples. More examples can be found in [TestSimple.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestSimple.java), [TestAdvanced.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestAdvanced.java) and [TestTutorial.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java).\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/README.md","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -32,1 +33,47 @@\n- * {@link Template}s are used to generate code, based on {@link Token}s which are rendered to {@link String}s.\n+ * The Template Framework allows the generation of code with Templates. The goal is that these Templates are\n+ * easy to write, and allow regression tests to cover a larger scope, and to make template based fuzzing easy\n+ * to extend.\n+ *\n+ * <p>\n+ * <strong>Motivation:<\/strong> We want to make it easy to generate variants of tests. Often, we would like to\n+ * have a set of tests, corresponding to a set of types, a set of operators, a set of constants, etc. Writing all\n+ * the tests by hand is cumbersome or even impossible. When generating such tests with scripts, it would be\n+ * preferable if the code generation happens automatically, and the generator script was checked into the code\n+ * base. Code generation can go beyond simple regression tests, and one might want to generate random code from\n+ * a list of possible templates, to fuzz individual Java features and compiler optimizations.\n+ *\n+ * <p>\n+ * The Template Framework provides a facility to generate code with Templates. Templates are essencially a list\n+ * of tokens that are concatenated (i.e. rendered) to a String. The Templates can have \"holes\", which are\n+ * filled (replaced) by different values at each Template instantiation. For example, these \"holes\" can\n+ * be filled with different types, operators or constants. Templates can also be nested, allowing a modular\n+ * use of the Templates.\n+ *\n+ * <p>\n+ * <strong>Example:<\/strong>\n+ * The following are snippets from the example test {@code TestAdvanced.java}.\n+ * First, we define a template that generates a {@code @Test} method for a given type, operator and\n+ * constant generator. We define two constants {@code con1} and {@code con2}, and then use a multiline\n+ * string with hashtag {@code #} \"holes\" that are then replaced by the template arguments and the\n+ * {@link #let} definitions.\n+ *\n+ * {@snippet lang=java :\n+ * var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> body(\n+ *     let(\"con1\", generator.next()),\n+ *     let(\"con2\", generator.next()),\n+ *     \"\"\"\n+ *     \/\/ #typeName #operator #con1 #con2\n+ *     public static #typeName $GOLD = $test();\n+ *\n+ *     @Test\n+ *     public static #typeName $test() {\n+ *         return (#typeName)(#con1 #operator #con2);\n+ *     }\n+ *\n+ *     @Check(test = \"$test\")\n+ *     public static void $check(#typeName result) {\n+ *         Verify.checkEQ(result, $GOLD);\n+ *     }\n+ *     \"\"\"\n+ * ));\n+ * }\n@@ -34,0 +81,56 @@\n+ * To get an executable test, we define a class Template, which takes a list of types,\n+ * and calls the test template for each type and operator. We use the {@code TestFramework}\n+ * to call our {@code @Test} methods.\n+ *\n+ * {@snippet lang=java :\n+ * var classTemplate = Template.make(\"types\", (List<Type> types) -> body(\n+ *     let(\"classpath\", comp.getEscapedClassPathOfCompiledClasses()),\n+ *     \"\"\"\n+ *     package p.xyz;\n+ *\n+ *     import compiler.lib.ir_framework.*;\n+ *     import compiler.lib.verify.*;\n+ *\n+ *     public class InnerTest {\n+ *         public static void main() {\n+ *             \/\/ Set the classpath, so that the TestFramework test VM knows where\n+ *             \/\/ the CompileFramework put the class files of the compiled source code.\n+ *             TestFramework framework = new TestFramework(InnerTest.class);\n+ *             framework.addFlags(\"-classpath\", \"#classpath\");\n+ *             framework.start();\n+ *         }\n+ *\n+ *     \"\"\",\n+ *     \/\/ Call the testTemplate for each type and operator, generating a\n+ *     \/\/ list of list of TemplateWithArgs:\n+ *     types.stream().map((Type type) ->\n+ *         type.operators().stream().map((String operator) ->\n+ *             testTemplate.withArgs(type.name(), operator, type.generator())).toList()\n+ *     ).toList(),\n+ *     \"\"\"\n+ *     }\n+ *     \"\"\"\n+ * ));\n+ * }\n+ *\n+ * Finally, we generate the list of types, and pass it to the class template:\n+ *\n+ * {@snippet lang=java :\n+ * List<Type> types = List.of(\n+ *     new Type(\"byte\",   () -> GEN_BYTE.next(),   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"char\",   () -> GEN_CHAR.next(),   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"short\",  () -> GEN_SHORT.next(),  List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"int\",    () -> GEN_INT.next(),    List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"long\",   () -> GEN_LONG.next(),   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"float\",  () -> GEN_FLOAT.next(),  List.of(\"+\", \"-\", \"*\", \"\/\")),\n+ *     new Type(\"double\", () -> GEN_DOUBLE.next(), List.of(\"+\", \"-\", \"*\", \"\/\"))\n+ * );\n+ *\n+ * \/\/ Use the template with one arguments, and render it to a String.\n+ * return classTemplate.withArgs(types).render();\n+ * }\n+ *\n+ * Once we rendered the source code to a String, we can compiole it with the {@code CompileFramework}.\n+ *\n+ * <p>\n+ * <strong>Details:<\/strong>\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Template.java","additions":104,"deletions":1,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test simple use of Templates with the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run main template_framework.examples.TestAdvanced\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+\/**\n+ * This is a basic example for Templates, using them to cover a list of test variants.\n+ * <p>\n+ * The \"@compile\" command for JTREG is required so that the frameworks used in the Template code\n+ * are compiled and available for the Test-VM.\n+ * <p>\n+ * Additionally, we must set the classpath for the Test-VM, so that it has access to all compiled\n+ * classes (see {@link CompileFramework#getEscapedClassPathOfCompiledClasses}).\n+ *\/\n+public class TestAdvanced {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static final RestrictableGenerator<Integer> GEN_BYTE = Generators.G.safeRestrict(Generators.G.ints(), Byte.MIN_VALUE, Byte.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_CHAR = Generators.G.safeRestrict(Generators.G.ints(), Character.MIN_VALUE, Character.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_SHORT = Generators.G.safeRestrict(Generators.G.ints(), Short.MIN_VALUE, Short.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    public static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+    public static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+    public static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ Object ret = p.xyz.InnterTest.main();\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {});\n+    }\n+\n+    interface MyGenerator {\n+        Object next();\n+    }\n+\n+    record Type(String name, MyGenerator generator, List<String> operators) {}\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate(CompileFramework comp) {\n+\n+        \/\/ The test template:\n+        \/\/ - For a chosen type, operator, and generator.\n+        \/\/ - The variable name \"GOLD\" and the test name \"test\" would get conflicts\n+        \/\/   if we instanciate the template multiple times. Thus, we use the $ prefix\n+        \/\/   so that the Template Framework can replace the names and make them unique\n+        \/\/   for each Template instantiation.\n+        \/\/ - The GOLD value is computed at the beginning, hopefully by the interpreter.\n+        \/\/ - The test method is eventually compiled, and the values are verified by the\n+        \/\/   check method.\n+        var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> body(\n+            let(\"con1\", generator.next()),\n+            let(\"con2\", generator.next()),\n+            \"\"\"\n+            \/\/ #typeName #operator #con1 #con2\n+            public static #typeName $GOLD = $test();\n+\n+            @Test\n+            public static #typeName $test() {\n+                return (#typeName)(#con1 #operator #con2);\n+            }\n+\n+            @Check(test = \"$test\")\n+            public static void $check(#typeName result) {\n+                Verify.checkEQ(result, $GOLD);\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Template for the Class.\n+        var classTemplate = Template.make(\"types\", (List<Type> types) -> body(\n+            let(\"classpath\", comp.getEscapedClassPathOfCompiledClasses()),\n+            \"\"\"\n+            package p.xyz;\n+\n+            import compiler.lib.ir_framework.*;\n+            import compiler.lib.verify.*;\n+\n+            public class InnerTest {\n+                public static void main() {\n+                    TestFramework framework = new TestFramework(InnerTest.class);\n+                    \/\/ Set the classpath, so that the TestFramework test VM knows where\n+                    \/\/ the CompileFramework put the class files of the compiled source code.\n+                    framework.addFlags(\"-classpath\", \"#classpath\");\n+                    framework.start();\n+                }\n+\n+            \"\"\",\n+            \/\/ Call the testTemplate for each type and operator, generating a\n+            \/\/ list of list of TemplateWithArgs:\n+            types.stream().map((Type type) ->\n+                type.operators().stream().map((String operator) ->\n+                    testTemplate.withArgs(type.name(), operator, type.generator())).toList()\n+            ).toList(),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ For each type, we chose a list of operators that do not throw exceptions.\n+        List<Type> types = List.of(\n+            new Type(\"byte\",   () -> GEN_BYTE.next(),   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"char\",   () -> GEN_CHAR.next(),   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"short\",  () -> GEN_SHORT.next(),  List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"int\",    () -> GEN_INT.next(),    List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"long\",   () -> GEN_LONG.next(),   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"float\",  () -> GEN_FLOAT.next(),  List.of(\"+\", \"-\", \"*\", \"\/\")),\n+            new Type(\"double\", () -> GEN_DOUBLE.next(), List.of(\"+\", \"-\", \"*\", \"\/\"))\n+        );\n+\n+        \/\/ Use the template with one arguments, and render it to a String.\n+        return classTemplate.withArgs(types).render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestAdvanced.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"}]}