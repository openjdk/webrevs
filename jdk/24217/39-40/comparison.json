{"files":[{"patch":"@@ -137,2 +137,2 @@\n-    long weighNames(Name.Type type, boolean onlyMutable) {\n-        return names.weight(type, onlyMutable);\n+    Name sampleName(NameSet.Predicate predicate) {\n+        return names.sample(predicate);\n@@ -141,2 +141,10 @@\n-    Name sampleName(Name.Type type, boolean onlyMutable) {\n-        return names.sample(type, onlyMutable);\n+    int countNames(NameSet.Predicate predicate) {\n+        return names.count(predicate);\n+    }\n+\n+    boolean hasAnyNames(NameSet.Predicate predicate) {\n+        return names.hasAny(predicate);\n+    }\n+\n+    List<Name> listNames(NameSet.Predicate predicate) {\n+        return names.toList(predicate);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/CodeFrame.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * {@link DataName}s represent things like fields and local variables, and can be added to the local\n+ * scope with {@link Template#addDataName}, and accessed with {@link Template#dataNames}, from where\n+ * count, list or even sample random {@link DataName}s. Every {@link DataName} has a {@link DataName.Type},\n+ * so that sampling can be restricted to these types.\n+ *\n+ * For method and class names and alike, there are the analogous {@link StructuralName}s.\n+ *\n+ * @param name The {@link String} name used in code.\n+ * @param type The type of the {@link DataName}.\n+ * @param mutable Defines if the {@link DataName} is considered mutable or immutable.\n+ * @param weight The weight of the {@link DataName}, it corresponds to the probability of choosing this\n+ *               {@link DataName} when sampling later on.\n+ *\/\n+public record DataName(String name, DataName.Type type, boolean mutable, int weight) implements Name {\n+\n+    \/**\n+     * {@link Mutability} defines the possible states of {@link DataName}s, or the\n+     * desired state when filtering.\n+     *\/\n+    public enum Mutability {\n+        \/**\n+         * Used for mutable fields and variables, i.e. writing is allowed.\n+         *\/\n+        MUTABLE,\n+        \/**\n+         * Used for immutable fields and variables, i.e. writing is not allowed,\n+         * for example because the field or variable is final.\n+         *\/\n+        IMMUTABLE,\n+        \/**\n+         * When filtering, we sometimes want to indicate that we accept\n+         * mutable and immutable fields and variables, for example when\n+         * we are only reading, the mutability state does not matter.\n+         *\/\n+        MUTABLE_OR_IMMUTABLE\n+    }\n+\n+    \/**\n+     * Creates a new {@link DataName}.\n+     *\/\n+    public DataName {\n+        if (0 >= weight || weight > 1000) {\n+            throw new IllegalArgumentException(\"Unexpected weight: \" + weight);\n+        }\n+    }\n+\n+    \/**\n+     * The interface for the type of a {@link DataName}.\n+     *\/\n+    public interface Type extends Name.Type {\n+        \/**\n+         * The name of the type, that can be used in code.\n+         *\n+         * @return The {@link String} representation of the type, that can be used in code.\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Defines the subtype relationship with other types, which is used to filter {@link DataName}s\n+         * in {@link View#exactOf}, {@link View#subtypeOf}, and {@link View#supertypeOf}.\n+         *\n+         * @param other The other type, where we check if it is the supertype of {@code 'this'}.\n+         * @return If {@code 'this'} is a subtype of {@code 'other'}.\n+         *\/\n+        boolean isSubtypeOf(DataName.Type other);\n+    }\n+\n+    \/**\n+     * The {@link View} represents a filtered set of {@link DataName}s in the current scope.\n+     * It can be obtained with {@link Template#dataNames}. It can be used to count the\n+     * available {@link DataName}s, or sample a random {@link DataName} according to the\n+     * weights of the {@link DataName}s in the filtered set.\n+     *\/\n+    public static final class View {\n+        private final Mutability mutability;\n+        private final DataName.Type subtype;\n+        private final DataName.Type supertype;\n+\n+        View(Mutability mutability, DataName.Type subtype, DataName.Type supertype) {\n+            this.mutability = mutability;\n+            this.subtype = subtype;\n+            this.supertype = supertype;\n+        }\n+\n+        View(Mutability mutability) {\n+            this(mutability, null, null);\n+        }\n+\n+        NameSet.Predicate predicate() {\n+            if (subtype == null && supertype == null) {\n+                throw new UnsupportedOperationException(\"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n+            }\n+            return (Name name) -> {\n+                if (!(name instanceof DataName dn)) { return false; }\n+                if (mutability == Mutability.MUTABLE && !dn.mutable()) { return false; }\n+                if (mutability == Mutability.IMMUTABLE && dn.mutable()) { return false; }\n+                if (subtype != null && !dn.type().isSubtypeOf(subtype)) { return false; }\n+                if (supertype != null && !supertype.isSubtypeOf(dn.type())) { return false; }\n+                return true;\n+            };\n+        }\n+\n+        \/**\n+         * Create a filtered {@link View}, where all {@link DataName}s must be subtypes of {@code type}.\n+         *\n+         * @param type The type of which all {@link DataName}s must be subtypes of.\n+         * @return The filtered {@link View}.\n+         * @throws UnsupportedOperationException If this {@link View} was already filtered with\n+         *                                       {@link subtypeOf} or {@link exactOf}.\n+         *\/\n+        public View subtypeOf(DataName.Type type) {\n+            if (subtype != null) {\n+                throw new UnsupportedOperationException(\"Cannot constrain to subtype \" + type + \", is already constrained: \" + subtype);\n+            }\n+            return new View(mutability, type, supertype);\n+        }\n+\n+        \/**\n+         * Create a filtered {@link View}, where all {@link DataName}s must be subtypes of {@code type}.\n+         *\n+         * @param type The type of which all {@link DataName}s must be supertype of.\n+         * @return The filtered {@link View}.\n+         * @throws UnsupportedOperationException If this {@link View} was already filtered with\n+         *                                       {@link supertypeOf} or {@link exactOf}.\n+         *\/\n+        public View supertypeOf(DataName.Type type) {\n+            if (supertype != null) {\n+                throw new UnsupportedOperationException(\"Cannot constrain to supertype \" + type + \", is already constrained: \" + supertype);\n+            }\n+            return new View(mutability, subtype, type);\n+        }\n+\n+        \/**\n+         * Create a filtered {@link View}, where all {@link DataName}s must be of exact {@code type},\n+         * hence it must be both subtype and supertype thereof.\n+         *\n+         * @param type The type of which all {@link DataName}s must be.\n+         * @return The filtered {@link View}.\n+         * @throws UnsupportedOperationException If this {@link View} was already filtered with\n+         *                                       {@link subtypeOf}, {@link supertypeOf} or {@link exactOf}.\n+         *\/\n+        public View exactOf(DataName.Type type) {\n+            return subtypeOf(type).supertypeOf(type);\n+        }\n+\n+        \/**\n+         * Samples a random {@link DataName} from the filtered set, according to the weights\n+         * of the contained {@link DataName}s.\n+         *\n+         * @return The sampled {@link DataName}.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link subtypeOf}, {@link supertypeOf} or {@link exactOf}.\n+         * @throws RendererException If the set was empty.\n+         *\/\n+        public DataName sample() {\n+            DataName n = (DataName)Renderer.getCurrent().sampleName(predicate());\n+            if (n == null) {\n+                String msg1 = (subtype == null) ? \"\" : \", subtypeOf(\" + subtype + \")\";\n+                String msg2 = (supertype == null) ? \"\" : \", supertypeOf(\" + supertype + \")\";\n+                throw new RendererException(\"No variable: \" + mutability + msg1 + msg2 + \".\");\n+            }\n+            return n;\n+        }\n+\n+        \/**\n+         * Counts the number of {@link DataName}s in the filtered set.\n+         *\n+         * @return The number of {@link DataName}s in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link subtypeOf}, {@link supertypeOf} or {@link exactOf}.\n+         *\/\n+        public int count() {\n+            return Renderer.getCurrent().countNames(predicate());\n+        }\n+\n+        \/**\n+         * Checks if there are any {@link DataName}s in the filtered set.\n+         *\n+         * @return Returns {@code true} iff there is at least one {@link DataName} in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link subtypeOf}, {@link supertypeOf} or {@link exactOf}.\n+         *\/\n+        public boolean hasAny() {\n+            return Renderer.getCurrent().hasAnyNames(predicate());\n+        }\n+\n+        \/**\n+         * Collects all {@link DataName}s in the filtered set.\n+         *\n+         * @return A {@link List} of all {@link DataName}s in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link subtypeOf}, {@link supertypeOf} or {@link exactOf}.\n+         *\/\n+        public List<DataName> toList() {\n+            List<Name> list = Renderer.getCurrent().listNames(predicate());\n+            return list.stream().map(n -> (DataName)n).toList();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/DataName.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -31,12 +31,7 @@\n-\/**\n- * {@link Name}s represent things like fields and local variables, or even method names that can be\n- * added to a code scope with {@link Template#addName} and sampled with {@link Template#sampleName},\n- * according to the {@code 'weight'} of each {@link Name}. Every {@link Name} has a {@link Name.Type},\n- * so that sampling can be restricted to these types, or subtypes, defined by {@link Name.Type#isSubtypeOf}.\n- *\n- * @param name The {@link String} name used in code.\n- * @param type The type with which we restrict {@link Template#weighNames} and {@link Template#sampleName}.\n- * @param mutable Defines if the name is considered mutable or immutable.\n- * @param weight The weight measured by {@link Template#weighNames} and according to which we sample with {@link Template#sampleName}.\n- *\/\n-public record Name(String name, Name.Type type, boolean mutable, int weight) {\n+sealed interface Name permits DataName, StructuralName {\n+    \/**\n+     * The name of the type, that can be used in code.\n+     *\n+     * @return The {@String} name of the name, that can be used in code.\n+     *\/\n+    String name();\n@@ -45,1 +40,3 @@\n-     * Creates a new {@link Name}.\n+     * The type of the name, allowing for filtering by type.\n+     *\n+     * @return The type of the name.\n@@ -47,5 +44,1 @@\n-    public Name {\n-        if (0 >= weight || weight > 1000) {\n-            throw new IllegalArgumentException(\"Unexpected weight: \" + weight);\n-        }\n-    }\n+    Type type();\n@@ -54,1 +47,4 @@\n-     * The interface for the type of a {@link Name}.\n+     * The weight of the name, corresponds to the probability of\n+     * choosing this name when sampling.\n+     *\n+     * @return The weight of the name.\n@@ -56,0 +52,2 @@\n+    int weight();\n+\n@@ -60,1 +58,1 @@\n-         * @return The {@link String} representation of the type, that can be used in code.\n+         * @return The {@link String} name of the type, that can be used in code.\n@@ -63,9 +61,0 @@\n-\n-        \/**\n-         * Defines the subtype relationship with other types, which is used to filter {@link Name}s\n-         * in {@link Template#weighNames} and {@link Template#sampleName}.\n-         *\n-         * @param other The other type, where we check if it is the supertype of {@code 'this'}.\n-         * @return If {@code 'this'} is a subtype of {@code 'other'}.\n-         *\/\n-        boolean isSubtypeOf(Type other);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Name.java","additions":18,"deletions":29,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+    interface Predicate {\n+        boolean check(Name type);\n+    }\n+\n@@ -46,8 +50,4 @@\n-    private long localWeight(Name.Type type, boolean onlyMutable) {\n-        long sum = 0;\n-        for (var name : names) {\n-            if (name.type().isSubtypeOf(type) && (name.mutable() || !onlyMutable)) {\n-                sum += name.weight();\n-            }\n-        }\n-        return sum;\n+    private long weight(Predicate predicate) {\n+        long w = names.stream().filter(n -> predicate.check(n)).mapToInt(Name::weight).sum();\n+        if (parent != null) { w += parent.weight(predicate); }\n+        return w;\n@@ -56,4 +56,16 @@\n-    public long weight(Name.Type type, boolean onlyMutable) {\n-        long w = localWeight(type, onlyMutable);\n-        if (parent != null) { w += parent.weight(type, onlyMutable); }\n-        return w;\n+    public int count(Predicate predicate) {\n+        int c = (int)names.stream().filter(n -> predicate.check(n)).count();\n+        if (parent != null) { c += parent.count(predicate); }\n+        return c;\n+    }\n+\n+    public boolean hasAny(Predicate predicate) {\n+        return names.stream().anyMatch(n -> predicate.check(n)) ||\n+               (parent != null && parent.hasAny(predicate));\n+    }\n+\n+    public List<Name> toList(Predicate predicate) {\n+        List<Name> list = (parent != null) ? parent.toList(predicate)\n+                                           : new ArrayList<>();\n+        list.addAll(names.stream().filter(n -> predicate.check(n)).toList());\n+        return list;\n@@ -63,1 +75,1 @@\n-     * Randomly sample a name from this set or a parent set, restricted to the specified type.\n+     * Randomly sample a name from this set or a parent set, restricted to the predicate.\n@@ -65,2 +77,2 @@\n-    public Name sample(Name.Type type, boolean onlyMutable) {\n-        long w = weight(type, onlyMutable);\n+    public Name sample(Predicate predicate) {\n+        long w = weight(predicate);\n@@ -68,1 +80,1 @@\n-            throw new RendererException(\"No variable of type '\" + type.toString() + \"'.\");\n+            return null;\n@@ -72,1 +84,1 @@\n-        return sample(type, onlyMutable, r);\n+        return sample(predicate, r);\n@@ -75,1 +87,1 @@\n-    private Name sample(Name.Type type, boolean onlyMutable, long r) {\n+    private Name sample(Predicate predicate, long r) {\n@@ -77,1 +89,1 @@\n-            if (name.type().isSubtypeOf(type) && (name.mutable() || !onlyMutable)) {\n+            if (predicate.check(name)) {\n@@ -82,1 +94,1 @@\n-        return parent.sample(type, onlyMutable, r);\n+        return parent.sample(predicate, r);\n@@ -89,0 +101,1 @@\n+        \/\/ TODO: verification!\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameSet.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-            throw new RendererException(\"A Template method such as '$' or 'let' was called outside a template rendering.\");\n+            throw new RendererException(\"A Template method such as '$', 'let', 'sample', 'count' etc. was called outside a template rendering.\");\n@@ -154,2 +154,2 @@\n-    long weighNames(Name.Type type, boolean onlyMutable) {\n-        return currentCodeFrame.weighNames(type, onlyMutable);\n+    Name sampleName(NameSet.Predicate predicate) {\n+        return currentCodeFrame.sampleName(predicate);\n@@ -158,2 +158,10 @@\n-    Name sampleName(Name.Type type, boolean onlyMutable) {\n-        return currentCodeFrame.sampleName(type, onlyMutable);\n+    int countNames(NameSet.Predicate predicate) {\n+        return currentCodeFrame.countNames(predicate);\n+    }\n+\n+    boolean hasAnyNames(NameSet.Predicate predicate) {\n+        return currentCodeFrame.hasAnyNames(predicate);\n+    }\n+\n+    List<Name> listNames(NameSet.Predicate predicate) {\n+        return currentCodeFrame.listNames(predicate);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Renderer.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * {@link StructuralName}s represent things like method and class names, and can be added to the local\n+ * scope with {@link Template#addStructuralName}, and accessed with {@link Template#structuralNames}, from where\n+ * count, list or even sample random {@link StructuralName}s. Every {@link StructuralName} has a {@link StructuralName.Type},\n+ * so that sampling can be restricted to these types.\n+ *\n+ * For field and variable names and alike, there are the analogous {@link DataName}s.\n+ *\n+ * @param name The {@link String} name used in code.\n+ * @param type The type of the {@link StructuralName}.\n+ * @param weight The weight of the {@link StructuralName}, it corresponds to the probability of choosing this\n+ *               {@link StructuralName} when sampling later on.\n+ *\/\n+public record StructuralName(String name, StructuralName.Type type, int weight) implements Name {\n+\n+    \/**\n+     * Creates a new {@link StructuralName}.\n+     *\/\n+    public StructuralName {\n+        if (0 >= weight || weight > 1000) {\n+            throw new IllegalArgumentException(\"Unexpected weight: \" + weight);\n+        }\n+    }\n+\n+    \/**\n+     * The interface for the type of a {@link StructuralName}.\n+     *\/\n+    public interface Type extends Name.Type {\n+        \/**\n+         * The name of the type, that can be used in code.\n+         *\n+         * @return The {@link String} representation of the type, that can be used in code.\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Defines the subtype relationship with other types, which is used to filter {@link StructuralName}s\n+         * in {@link View#exactOf}, {@link View#subtypeOf}, and {@link View#supertypeOf}.\n+         *\n+         * @param other The other type, where we check if it is the supertype of {@code 'this'}.\n+         * @return If {@code 'this'} is a subtype of {@code 'other'}.\n+         *\/\n+        boolean isSubtypeOf(StructuralName.Type other);\n+    }\n+\n+    \/**\n+     * The {@link View} represents a filtered set of {@link StructuralName}s in the current scope.\n+     * It can be obtained with {@link Template#structuralNames}. It can be used to count the\n+     * available {@link StructuralName}s, or sample a random {@link StructuralName} according to the\n+     * weights of the {@link StructuralName}s in the filtered set.\n+     *\/\n+    public static final class View {\n+        private final StructuralName.Type subtype;\n+        private final StructuralName.Type supertype;\n+\n+        View(StructuralName.Type subtype, StructuralName.Type supertype) {\n+            this.subtype = subtype;\n+            this.supertype = supertype;\n+        }\n+\n+        View() {\n+            this(null, null);\n+        }\n+\n+        NameSet.Predicate predicate() {\n+            if (subtype == null && supertype == null) {\n+                throw new UnsupportedOperationException(\"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n+            }\n+            return (Name name) -> {\n+                if (!(name instanceof StructuralName dn)) { return false; }\n+                if (subtype != null && !dn.type().isSubtypeOf(subtype)) { return false; }\n+                if (supertype != null && !supertype.isSubtypeOf(dn.type())) { return false; }\n+                return true;\n+            };\n+        }\n+\n+        \/**\n+         * Create a filtered {@link View}, where all {@link StructuralName}s must be subtypes of {@code type}.\n+         *\n+         * @param type The type of which all {@link StructuralName}s must be subtypes of.\n+         * @return The filtered {@link View}.\n+         * @throws UnsupportedOperationException If this {@link View} was already filtered with\n+         *                                       {@link subtypeOf} or {@link exactOf}.\n+         *\/\n+        public View subtypeOf(StructuralName.Type type) {\n+            if (subtype != null) {\n+                throw new UnsupportedOperationException(\"Cannot constrain to subtype \" + type + \", is already constrained: \" + subtype);\n+            }\n+            return new View(type, supertype);\n+        }\n+\n+        \/**\n+         * Create a filtered {@link View}, where all {@link StructuralName}s must be subtypes of {@code type}.\n+         *\n+         * @param type The type of which all {@link StructuralName}s must be supertype of.\n+         * @return The filtered {@link View}.\n+         * @throws UnsupportedOperationException If this {@link View} was already filtered with\n+         *                                       {@link supertypeOf} or {@link exactOf}.\n+         *\/\n+        public View supertypeOf(StructuralName.Type type) {\n+            if (supertype != null) {\n+                throw new UnsupportedOperationException(\"Cannot constrain to supertype \" + type + \", is already constrained: \" + supertype);\n+            }\n+            return new View(subtype, type);\n+        }\n+\n+        \/**\n+         * Create a filtered {@link View}, where all {@link StructuralName}s must be of exact {@code type},\n+         * hence it must be both subtype and supertype thereof.\n+         *\n+         * @param type The type of which all {@link StructuralName}s must be.\n+         * @return The filtered {@link View}.\n+         * @throws UnsupportedOperationException If this {@link View} was already filtered with\n+         *                                       {@link subtypeOf}, {@link supertypeOf} or {@link exactOf}.\n+         *\/\n+        public View exactOf(StructuralName.Type type) {\n+            return subtypeOf(type).supertypeOf(type);\n+        }\n+\n+        \/**\n+         * Samples a random {@link StructuralName} from the filtered set, according to the weights\n+         * of the contained {@link StructuralName}s.\n+         *\n+         * @return The sampled {@link StructuralName}.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link subtypeOf}, {@link supertypeOf} or {@link exactOf}.\n+         * @throws RendererException If the set was empty.\n+         *\/\n+        public StructuralName sample() {\n+            StructuralName n = (StructuralName)Renderer.getCurrent().sampleName(predicate());\n+            if (n == null) {\n+                String msg1 = (subtype == null) ? \"\" : \" subtypeOf(\" + subtype + \")\";\n+                String msg2 = (supertype == null) ? \"\" : \" supertypeOf(\" + supertype + \")\";\n+                throw new RendererException(\"No variable:\" + msg1 + msg2 + \".\");\n+            }\n+            return n;\n+        }\n+\n+        \/**\n+         * Counts the number of {@link StructuralName}s in the filtered set.\n+         *\n+         * @return The number of {@link StructuralName}s in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link subtypeOf}, {@link supertypeOf} or {@link exactOf}.\n+         *\/\n+        public int count() {\n+            return Renderer.getCurrent().countNames(predicate());\n+        }\n+\n+        \/**\n+         * Checks if there are any {@link StructuralName}s in the filtered set.\n+         *\n+         * @return Returns {@code true} iff there is at least one {@link StructuralName} in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link subtypeOf}, {@link supertypeOf} or {@link exactOf}.\n+         *\/\n+        public boolean hasAny() {\n+            return Renderer.getCurrent().hasAnyNames(predicate());\n+        }\n+\n+        \/**\n+         * Collects all {@link StructuralName}s in the filtered set.\n+         *\n+         * @return A {@link List} of all {@link StructuralName}s in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link subtypeOf}, {@link supertypeOf} or {@link exactOf}.\n+         *\/\n+        public List<StructuralName> toList() {\n+            List<Name> list = Renderer.getCurrent().listNames(predicate());\n+            return list.stream().map(n -> (StructuralName)n).toList();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/StructuralName.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -187,7 +187,8 @@\n- * Code generation often involves defining fields and variables, which are then available inside a defined\n- * scope, and can be sampled in any nested scope. To allow the use of names for multiple applications (e.g.\n- * fields, variables, methods, etc.), we define a {@link Name}, which captures the {@link String} representation\n- * to be used in code, as well as its type and if it is mutable. One can add such a {@link Name} to the\n- * current code scope with {@link #addName}, and sample from the current or outer scopes with {@link #sampleName}.\n- * When generating code, one might want to create {@link Name}s (variables, fields, etc.) in local scope, or\n- * in some outer scope with the use of {@link Hook}s.\n+ * Code generation can involve keeping track of fields and variables, as well as the scopes in which they\n+ * are available, and if they are mutable or immutable. We model fields and variables with {@link DataName}s,\n+ * which we can add to the current scope with {@link addDataName}. We can access the {@link DataName}s with\n+ * {@link dataNames}. We can filter for {@link DataName}s of specific {@link DataName.Type}s, and then\n+ * we can call {@link DataName.View#count}, {@link DataName.View#sample}, {@link DataName.View#toList}, etc.\n+ * There are many use-cases for this mechanism, especially facilitating communication between the code\n+ * of outer and inner {@link Template}s. Especially for fuzzing, it may be useful to be able to add\n+ * fields and variables, and sample them randomly, to create a random data flow graph.\n@@ -196,2 +197,66 @@\n- * More examples for these functionalities can be found in {@link TestTutorial}, {@link TestSimple}, and\n- * {@link TestAdvanced}.\n+ * Similarly, we may want to model method and class names, and possibly other structural names. We model\n+ * these names with {@link StructuralName}, which works analogous to {@link DataName}, except that they\n+ * are not concerned about mutability.\n+ *\n+ * <p>\n+ * When working with {@link DataName}s and {@link StructuralName}s, it is important to be aware of the\n+ * relevant scopes, as well as the execution order of the {@link Template} lambdas, as well as the evaluation\n+ * of the {@link Template#body} tokens. When a {@link Template} is rendered, its lambda is invoke. In the\n+ * lambda, we generate the tokens, and create the {@link Template#body}. Once the lambda returns, the\n+ * tokens are evaluated one by one. While evaluating the tokens, the Renderer might encounter a nested\n+ * {@link TemplateToken}, which in turn triggers the evaluation of that nested {@link Template}, i.e.\n+ * the evaluation of its lambda and later the evaluation of its tokens. It is important to keep in mind\n+ * that the lambda is always executed first, and the tokens are evaluated afterwards. A method like\n+ * {@code dataNames(MUTABLE).exactOf(type).count()} is a method that is executed during the evaluation\n+ * of the lambda. But a method like {@link addDataName} returns a token, and does not immediately add\n+ * the {@link DataName}. This ensures that the {@link DataName} is only inserted when the tokens are\n+ * evaluated, so that it is inserted at the exact scope where we would expect it.\n+ *\n+ * <p>\n+ * Let us look at the following example to better understand the execution order.\n+ *\n+ * <p>\n+ * {@snippet lang=java :\n+ * var testTemplate = Template.make(() -> body(\n+ *     \/\/ The lambda has just been invoked.\n+ *     \/\/ We count the DataNames and assign the count to the hashtag replacement \"c1\".\n+ *     let(\"c1\", dataNames(MUTABLE).exactOf(someType).count()),\n+ *     \/\/ We want to define a DataName \"v1\", and create a token for it.\n+ *     addDataName($(\"v1\"), someType, MUTABLE),\n+ *     \/\/ We count the DataNames again, but the count does NOT change compared to \"c1\".\n+ *     \/\/ This is because the token for \"v1\" is only evaluated later.\n+ *     let(\"c2\", dataNames(MUTABLE).exactOf(someType).count()),\n+ *     \/\/ Create a nested scope.\n+ *     METHOD_HOOK.set(\n+ *         \/\/ We want to define a DataName \"v2\", which is only valid inside this\n+ *         \/\/ nested scope.\n+ *         addDataName($(\"v2\"), someType, MUTABLE),\n+ *         \/\/ The count is still not different to \"c1\".\n+ *         let(\"c3\", dataNames(MUTABLE).exactOf(someType).count()),\n+ *         \/\/ We nest a Template. This creats a TemplateToken, which is later evaluated.\n+ *         \/\/ By the time the TemplateToken is evaluated, the tokens from above will\n+ *         \/\/ be already evaluated. Hence, \"v1\" and \"v2\" are added by then, and if the\n+ *         \/\/ \"otherTemplate\" were to count the DataNames, the count would be increased\n+ *         \/\/ by 2 compared to \"c1\".\n+ *         otherTemplate.asToken(),\n+ *     ),\n+ *     \/\/ After closing the scope, \"v2\" is no longer available.\n+ *     \/\/ The count is still the same as \"c1\", since \"v1\" is still only a token.\n+ *     let(\"c4\", dataNames(MUTABLE).exactOf(someType).count()),\n+ *     \/\/ We nest another Template. Again, this creates a TemplateToken, which is only\n+ *     \/\/ evaluated later. By that time, the token for \"v1\" is evaluated, and so the\n+ *     \/\/ nested Template would observe an increment in the count.\n+ *     anotherTemplate.asToken(),\n+ *     \/\/ By this point, all methods are called, and the tokens generated. The\n+ *     \/\/ The lambda returns the \"body\", which is all of the tokens that we just\n+ *     \/\/ generated. After returning from the lambda, the tokens will be evaluated\n+ *     \/\/ one by one.\n+ * ));\n+ * }\n+\n+ * <p>\n+ * More examples for these functionalities can be found in {@code TestTutorial.java}, {@code TestSimple.java},\n+ * and {@code TestAdvanced.java}, which all produce compilable Java code. Additional examples can be found in\n+ * the tests, such as {@code TestTemplate.java} and {@code TestFormat.java}, which do not necessarily generate\n+ * valid Java code, but generate deterministic Strings which are easier to verify, and may also serve as a\n+ * reference when learning about these functionalities.\n@@ -676,1 +741,1 @@\n-     * Add a {@link Name} in the current scope, i.e. the innermost of either\n+     * Add a {@link DataName} in the current scope, i.e. the innermost of either\n@@ -678,3 +743,0 @@\n-     * Note that there can be duplicate definitions, and they simply increase\n-     * the {@link #weighNames} weight, and increase the probability of sampling\n-     * the name with {@link #sampleName}.\n@@ -682,1 +744,7 @@\n-     * @param name The {@link Name} to be added to the current scope.\n+     * @param name The name of the {@link DataName}, i.e. the {@link String} used in code.\n+     * @param type The type of the {@link DataName}.\n+     * @param mutability Indicates if the {@link DataName} is to be mutable or immutable,\n+     *                   i.e. if we intend to use the {@link DataName} only for reading\n+     *                   or if we also allow it to be mutated.\n+     * @param weight The weight of the {@link DataName}, which correlates to the probability\n+     *               of this {@link DataName} being chosen when we sample.\n@@ -685,2 +753,7 @@\n-    static Token addName(Name name) {\n-        return new AddNameToken(name);\n+    static Token addDataName(String name, DataName.Type type, DataName.Mutability mutability, int weight) {\n+        if (mutability != DataName.Mutability.MUTABLE &&\n+            mutability != DataName.Mutability.IMMUTABLE) {\n+            throw new IllegalArgumentException(\"Unexpected mutability: \" + mutability);\n+        }\n+        boolean mutable = mutability == DataName.Mutability.MUTABLE;\n+        return new AddNameToken(new DataName(name, type, mutable, 1));\n@@ -690,1 +763,2 @@\n-     * Weigh the {@link Name}s for the specified {@link Name.Type}.\n+     * Add a {@link DataName} in the current scope, i.e. the innermost of either\n+     * {@link Template#body} or {@link Hook#set}, with a {@code weight} of 1.\n@@ -692,3 +766,42 @@\n-     * @param type The type of the names to weigh.\n-     * @param onlyMutable Determines if we weigh the mutable names or all.\n-     * @return The weight of names for the specified parameters.\n+     * @param name The name of the {@link DataName}, i.e. the {@link String} used in code.\n+     * @param type The type of the {@link DataName}.\n+     * @param mutability Indicates if the {@link DataName} is to be mutable or immutable,\n+     *                   i.e. if we intend to use the {@link DataName} only for reading\n+     *                   or if we also allow it to be mutated.\n+     * @return The token that performs the defining action.\n+     *\/\n+    static Token addDataName(String name, DataName.Type type, DataName.Mutability mutability) {\n+        return addDataName(name, type, mutability, 1);\n+    }\n+\n+    \/**\n+     * Access the set of {@link DataName}s, for sampling, counting, etc.\n+     *\n+     * @param mutability Indicates if we only sample from mutable, immutable or either {@link DataName}s.\n+     * @return A view on the {@link DataName}s, on which we can sample, count, etc.\n+     *\/\n+    static DataName.View dataNames(DataName.Mutability mutability) {\n+        return new DataName.View(mutability);\n+    }\n+\n+    \/**\n+     * Add a {@link StructuralName} in the current scope, i.e. the innermost of either\n+     * {@link Template#body} or {@link Hook#set}.\n+     *\n+     * @param name The name of the {@link StructuralName}, i.e. the {@link String} used in code.\n+     * @param type The type of the {@link StructuralName}.\n+     * @param weight The weight of the {@link StructuralName}, which correlates to the probability\n+     *               of this {@link StructuralName} being chosen when we sample.\n+     * @return The token that performs the defining action.\n+     *\/\n+    static Token addStructuralName(String name, StructuralName.Type type, int weight) {\n+        return new AddNameToken(new StructuralName(name, type, 1));\n+    }\n+\n+    \/**\n+     * Add a {@link StructuralName} in the current scope, i.e. the innermost of either\n+     * {@link Template#body} or {@link Hook#set}, with a {@code weight} of 1.\n+     *\n+     * @param name The name of the {@link StructuralName}, i.e. the {@link String} used in code.\n+     * @param type The type of the {@link StructuralName}.\n+     * @return The token that performs the defining action.\n@@ -696,2 +809,2 @@\n-    static long weighNames(Name.Type type, boolean onlyMutable) {\n-        return Renderer.getCurrent().weighNames(type, onlyMutable);\n+    static Token addStructuralName(String name, StructuralName.Type type) {\n+        return addStructuralName(name, type, 1);\n@@ -701,1 +814,1 @@\n-     * Sample a random name for the specified type.\n+     * Access the set of {@link StructuralName}s, for sampling, counting, etc.\n@@ -703,3 +816,1 @@\n-     * @param type The type of the names to sample from.\n-     * @param onlyMutable Determines if we sample from the mutable names or all.\n-     * @return The sampled name.\n+     * @return A view on the {@link StructuralName}s, on which we can sample, count, etc.\n@@ -707,2 +818,2 @@\n-    static Name sampleName(Name.Type type, boolean onlyMutable) {\n-        return Renderer.getCurrent().sampleName(type, onlyMutable);\n+    static StructuralName.View structuralNames() {\n+        return new StructuralName.View();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Template.java","additions":139,"deletions":28,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-import compiler.lib.template_framework.Name;\n+import compiler.lib.template_framework.DataName;\n+import compiler.lib.template_framework.StructuralName;\n@@ -49,3 +50,7 @@\n-import static compiler.lib.template_framework.Template.addName;\n-import static compiler.lib.template_framework.Template.sampleName;\n-import static compiler.lib.template_framework.Template.weighNames;\n+import static compiler.lib.template_framework.Template.addDataName;\n+import static compiler.lib.template_framework.Template.dataNames;\n+import static compiler.lib.template_framework.Template.addStructuralName;\n+import static compiler.lib.template_framework.Template.structuralNames;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE;\n+import static compiler.lib.template_framework.DataName.Mutability.IMMUTABLE;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE_OR_IMMUTABLE;\n@@ -68,4 +73,4 @@\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest7\",  generateWithNamesSimple());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest8\",  generateWithNamesForFieldsAndVariables());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest9\",  generateWithNamesForMethods());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest10\", generateWithNamesForFuzzing());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest7\",  generateWithDataNamesSimple());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest8\",  generateWithDataNamesForFieldsAndVariables());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest10\", generateWithDataNamesForFuzzing());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9\",  generateWithStructuralNamesForMethods());\n@@ -430,5 +435,6 @@\n-    \/\/ Below, we introduce the concept of \"Names\". Code generation often involves defining\n-    \/\/ fields and variables, which are then available inside a defined scope, and can be\n-    \/\/ sampled in any nested scope. To allow the use of names for multiple applications\n-    \/\/ (e.g. fields, variables, methods, etc.), we define a Name, which captures the String\n-    \/\/ representation to be used in code, as well as its type and if it is mutable.\n+    \/\/ Below, we introduce the concept of \"DataNames\". Code generation often involves defining\n+    \/\/ fields and variables, which are then available inside a defined scope. \"DataNames\" can\n+    \/\/ be registered at a certain scope with addDataName. This \"DataName\" is then available\n+    \/\/ in this scope, and in any nested scope, including nested Templates. This allows us to\n+    \/\/ add some fields and registers in one Template, and later on, in another Template, we\n+    \/\/ can access these fields and registers again with \"dataNames()\".\n@@ -436,1 +442,20 @@\n-    \/\/ To get started, we show an example where all Names have the same type, and where\n+    \/\/ Here a few use-cases:\n+    \/\/ - You are writing some inner Template, and would like to access a random field or\n+    \/\/   variable from an outer Template. Luckily, the outer Templates have added their\n+    \/\/   fields and variables, and you can now access them with \"dataNames()\". You can\n+    \/\/   count them, get a list of them, or sample a random one.\n+    \/\/ - You are writing some outer Template, and would like to generate a variable that\n+    \/\/   an inner Template could read from or even write to. You can \"addDataName\" the\n+    \/\/   variable, and the inner Template can then find that variable in \"dataNames()\".\n+    \/\/   If the inner Template wants to find a random field or varialbe, it may sample\n+    \/\/   from \"dataNodes()\", and with some probability, it would sample the your variable.\n+    \/\/\n+    \/\/ A \"DataName\" captures the name of the field or variable in a String. It also\n+    \/\/ stores the type of the field or variable, as well as its \"mutability\", i.e.\n+    \/\/ an indication if the field or variable is only for reading, or if writing to\n+    \/\/ it is also allowed. If a field or variable is final, we must make sure that the\n+    \/\/ \"DataName\" is immutable, otherwise we risk that some Template attempts to generate\n+    \/\/ code that writes to the final field or variable, and then we get a compilation\n+    \/\/ error from \"javac\" later on.\n+    \/\/\n+    \/\/ To get started, we show an example where all DataNames have the same type, and where\n@@ -438,1 +463,1 @@\n-    private record MySimpleInt() implements Name.Type {\n+    private record MySimpleInt() implements DataName.Type {\n@@ -440,1 +465,1 @@\n-        \/\/ Names, because we do not just sample from the given type, but also its subtypes.\n+        \/\/ DataNames, because we do not just sample from the given type, but also its subtypes.\n@@ -442,1 +467,1 @@\n-        public boolean isSubtypeOf(Name.Type other) {\n+        public boolean isSubtypeOf(DataName.Type other) {\n@@ -455,1 +480,1 @@\n-    \/\/ Names, which gives us one of the fields. We increment that randomly\n+    \/\/ DataNames, which gives us one of the fields. We increment that randomly\n@@ -457,1 +482,1 @@\n-    public static String generateWithNamesSimple() {\n+    public static String generateWithDataNamesSimple() {\n@@ -459,1 +484,1 @@\n-            \/\/ Sample a random Name, i.e. field, and assign its name to\n+            \/\/ Sample a random DataName, i.e. field, and assign its name to\n@@ -461,1 +486,1 @@\n-            \/\/ We are picking a mutable Name, because we are not just\n+            \/\/ We are picking a mutable DataName, because we are not just\n@@ -463,1 +488,1 @@\n-            let(\"f\", sampleName(mySimpleInt, true).name()),\n+            let(\"f\", dataNames(MUTABLE).exactOf(mySimpleInt).sample().name()),\n@@ -473,1 +498,1 @@\n-            \/\/ We make all Names mutable, and with the same weight of 1,\n+            \/\/ We make all DataNames mutable, and with the same weight of 1,\n@@ -475,3 +500,4 @@\n-            addName(new Name($(\"f1\"), mySimpleInt, true, 1)),\n-            addName(new Name($(\"f2\"), mySimpleInt, true, 1)),\n-            addName(new Name($(\"f3\"), mySimpleInt, true, 1)),\n+            \/\/ Note: the default weight is 1, so we can also omit the weight.\n+            addDataName($(\"f1\"), mySimpleInt, MUTABLE, 1),\n+            addDataName($(\"f2\"), mySimpleInt, MUTABLE, 1),\n+            addDataName($(\"f3\"), mySimpleInt, MUTABLE), \/\/ omit weight, default is 1.\n@@ -510,1 +536,1 @@\n-    \/\/ and would not have had to rely on the Template Framework's Names for this. However,\n+    \/\/ and would not have had to rely on the Template Framework's DataNames for this. However,\n@@ -515,1 +541,1 @@\n-    \/\/ register their Names. When sampling from the main method, we should be able to see\n+    \/\/ register their DataNames. When sampling from the main method, we should be able to see\n@@ -520,1 +546,1 @@\n-    private record MyPrimitive(String name) implements Name.Type {\n+    private record MyPrimitive(String name) implements DataName.Type {\n@@ -522,1 +548,1 @@\n-        public boolean isSubtypeOf(Name.Type other) {\n+        public boolean isSubtypeOf(DataName.Type other) {\n@@ -536,1 +562,1 @@\n-    public static String generateWithNamesForFieldsAndVariables() {\n+    public static String generateWithDataNamesForFieldsAndVariables() {\n@@ -538,2 +564,2 @@\n-        var templateStaticField = Template.make(\"type\", (Name.Type type) -> body(\n-            addName(new Name($(\"field\"), type, true, 1)),\n+        var templateStaticField = Template.make(\"type\", (DataName.Type type) -> body(\n+            addDataName($(\"field\"), type, MUTABLE),\n@@ -549,2 +575,2 @@\n-        var templateLocalVariable = Template.make(\"type\", (Name.Type type) -> body(\n-            addName(new Name($(\"var\"), type, true, 1)),\n+        var templateLocalVariable = Template.make(\"type\", (DataName.Type type) -> body(\n+            addDataName($(\"var\"), type, MUTABLE),\n@@ -558,2 +584,2 @@\n-        var templateSample = Template.make(\"type\", (Name.Type type) -> body(\n-            let(\"name\", sampleName(type, true).name()),\n+        var templateSample = Template.make(\"type\", (DataName.Type type) -> body(\n+            let(\"name\", dataNames(MUTABLE).exactOf(type).sample().name()),\n@@ -567,2 +593,2 @@\n-            let(\"ints\", weighNames(myInt, true)),\n-            let(\"longs\", weighNames(myLong, true)),\n+            let(\"ints\", dataNames(MUTABLE).exactOf(myInt).count()),\n+            let(\"longs\", dataNames(MUTABLE).exactOf(myLong).count()),\n@@ -615,1 +641,1 @@\n-            \/\/ Sampling 5 random int and 5 random long Names. We should\n+            \/\/ Sampling 5 random int and 5 random long DataNames. We should\n@@ -679,94 +705,1 @@\n-    \/\/ We kept the Names purposfully abstract, so that it can not just be used for\n-    \/\/ fields or variables, but many other applications. Some ideas:\n-    \/\/ - Method names. The Type could represent the signature of the static method\n-    \/\/                 or the class of the non-static method.\n-    \/\/ - Class names. Type could represent the signature of the constructor, so\n-    \/\/                that we could instantiate random instances.\n-    \/\/ - try\/catch blocks. If a specific Exception is caught in the scope, we could\n-    \/\/                     register that Exception, and in the inner scope we can\n-    \/\/                     check the weight for an Exception and its subtypes. If\n-    \/\/                     the weight is non-zero, we know the exception would be\n-    \/\/                     caught.\n-    \/\/\n-    \/\/ Let us show an examples with Method names. But for simplicity, we assume they\n-    \/\/ all have the same signature: they take two int arguments and return an int.\n-    \/\/\n-    \/\/ Should you ever work on a test where there are methods with different signatures,\n-    \/\/ then you would have to very carefully study and design the subtype relation between\n-    \/\/ methods. You may want to read up about covariance and contravariance. This\n-    \/\/ example ignores all of that, because we only have \"(II)I\" methods.\n-    private record MyMethodType() implements Name.Type {\n-        @Override\n-        public boolean isSubtypeOf(Name.Type other) {\n-            return other instanceof MyMethodType();\n-        }\n-\n-        @Override\n-        public String name() { return \"<not used, don't worry>\"; }\n-    }\n-    private static final MyMethodType myMethodType = new MyMethodType();\n-\n-    public static String generateWithNamesForMethods() {\n-        \/\/ Define a method, which takes two ints, returns the result of op.\n-        var templateMethod = Template.make(\"op\", (String op) -> body(\n-            \/\/ Register the method name, so we can later sample.\n-            \/\/ Note: method names are not mutable.\n-            addName(new Name($(\"methodName\"), myMethodType, false, 1)),\n-            \"\"\"\n-            public static int $methodName(int a, int b) {\n-                return a #op b;\n-            }\n-            \"\"\"\n-        ));\n-\n-        var templateSample = Template.make(() -> body(\n-            \/\/ Sample a random method, and retrieve its name.\n-            let(\"methodName\", sampleName(myMethodType, false).name()),\n-            \"\"\"\n-            System.out.println(\"Calling #methodName with inputs 7 and 11\");\n-            System.out.println(\"  result: \" + #methodName(7, 11));\n-            \"\"\"\n-        ));\n-\n-        var templateClass = Template.make(() -> body(\n-            \"\"\"\n-            package p.xyz;\n-\n-            public class InnerTest9 {\n-                \/\/ Let us define some methods that we can sample from later.\n-            \"\"\",\n-            \/\/ We must set a CLASS_HOOK here, and insert the method definitions to that hook.\n-            Hooks.CLASS_HOOK.set(\n-                \/\/ If we directly nest the templateMethod, then the addName goes to the nested\n-                \/\/ scope, and is not available at the class scope, i.e. it is not visible\n-                \/\/ for sampleName in outside of the templateMethod.\n-                \/\/ DO NOT DO THIS, the nested addName will not be visible:\n-                \"\/\/ We cannot sample from the following methods:\\n\",\n-                templateMethod.asToken(\"+\"),\n-                templateMethod.asToken(\"-\"),\n-                \/\/ However, if we insert to the CLASS_HOOK, then the Rendere makes the\n-                \/\/ scope of the inserted templateMethod transparent, and the addName\n-                \/\/ goes out to the scope of the CLASS_HOOK (but no further than that).\n-                \/\/ RATHER, DO THIS to ensure the addName is visible:\n-                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"*\")),\n-                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"|\")),\n-                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"&\")),\n-                \"\"\"\n-\n-                    public static void main() {\n-                        \/\/ Now, we call some random methods, but only those that were inserted\n-                        \/\/ to the CLASS_HOOK.\n-                        \"\"\",\n-                        Collections.nCopies(10, templateSample.asToken()),\n-                        \"\"\"\n-                    }\n-                }\n-                \"\"\"\n-            )\n-        ));\n-\n-        \/\/ Render templateClass to String.\n-        return templateClass.render();\n-    }\n-\n-    \/\/ There are two more concepts to understand more deeply with Names.\n+    \/\/ There are two more concepts to understand more deeply with DataNames.\n@@ -774,2 +707,2 @@\n-    \/\/ One is the use of mutable and immutable Names.\n-    \/\/ In some cases, we only want to sample Names that are mutable, because\n+    \/\/ One is the use of mutable and immutable DataNames.\n+    \/\/ In some cases, we only want to sample DataNames that are mutable, because\n@@ -781,1 +714,1 @@\n-    \/\/ Another concept is subtyping of Name Types. With primitive types, this\n+    \/\/ Another concept is subtyping of DataName Types. With primitive types, this\n@@ -784,1 +717,2 @@\n-    \/\/ class, or any subclass.\n+    \/\/ class, or any subclass. When a value of a given class, we can only\n+    \/\/ store it to fields and variables of that class or any superclass.\n@@ -788,1 +722,1 @@\n-    \/\/ First, we define a Name Type that represents different classes, that\n+    \/\/ First, we define a DataName Type that represents different classes, that\n@@ -791,1 +725,1 @@\n-    private record MyClass(String name) implements Name.Type {\n+    private record MyClass(String name) implements DataName.Type {\n@@ -793,1 +727,1 @@\n-        public boolean isSubtypeOf(Name.Type other) {\n+        public boolean isSubtypeOf(DataName.Type other) {\n@@ -807,3 +741,3 @@\n-    public static String generateWithNamesForFuzzing() {\n-        var templateStaticField = Template.make(\"type\", \"mutable\", (Name.Type type, Boolean mutable) -> body(\n-            addName(new Name($(\"field\"), type, mutable, 1)),\n+    public static String generateWithDataNamesForFuzzing() {\n+        var templateStaticField = Template.make(\"type\", \"mutable\", (DataName.Type type, Boolean mutable) -> body(\n+            addDataName($(\"field\"), type, mutable ? MUTABLE : IMMUTABLE),\n@@ -816,1 +750,1 @@\n-        var templateLoad = Template.make(\"type\", (Name.Type type) -> body(\n+        var templateLoad = Template.make(\"type\", (DataName.Type type) -> body(\n@@ -819,1 +753,4 @@\n-            let(\"field\", sampleName(type, false).name()),\n+            \/\/ We want to find any field of which we can read the value and store\n+            \/\/ it in our variable v of our given type. Hence, we can take a field\n+            \/\/ of the given type or any subtype thereof.\n+            let(\"field\", dataNames(MUTABLE_OR_IMMUTABLE).subtypeOf(type).sample().name()),\n@@ -821,1 +758,2 @@\n-            System.out.println(\"#field: \" + #field);\n+            #type $v = #field;\n+            System.out.println(\"#field: \" + $v);\n@@ -825,1 +763,1 @@\n-        var templateStore = Template.make(\"type\", (Name.Type type) -> body(\n+        var templateStore = Template.make(\"type\", (DataName.Type type) -> body(\n@@ -827,1 +765,3 @@\n-            let(\"field\", sampleName(type, true).name()),\n+            \/\/ We want to store a new instance of our given type to a field. This\n+            \/\/ field must be of the given type or any supertype.\n+            let(\"field\", dataNames(MUTABLE).supertypeOf(type).sample().name()),\n@@ -829,1 +769,1 @@\n-            #field = null;\n+            #field = new #type();\n@@ -848,2 +788,2 @@\n-                \/\/ addName is restricted to the scope of the templateStaticField. But\n-                \/\/ with the insertion to CLASS_HOOK, the addName goes through the scope\n+                \/\/ addDataName is restricted to the scope of the templateStaticField. But\n+                \/\/ with the insertion to CLASS_HOOK, the addDataName goes through the scope\n@@ -885,0 +825,97 @@\n+\n+    \/\/ \"DataNames\" are useful for modeling fields and variables. They hold data,\n+    \/\/ and we can read and write to them, they may be mutable or immutable.\n+    \/\/ We now introduce another set of \"Names\", the \"StructuralNames\". They are\n+    \/\/ useful for modeling method names an class names, and possibly more. Anything\n+    \/\/ that has a fixed name in the Java code, for which mutability is inapplicalbe.\n+    \/\/ Some use-cases for \"StructuralNames\":\n+    \/\/ - Method names. The Type could represent the signature of the static method\n+    \/\/                 or the class of the non-static method.\n+    \/\/ - Class names. Type could represent the signature of the constructor, so\n+    \/\/                that we could instantiate random instances.\n+    \/\/ - try\/catch blocks. If a specific Exception is caught in the scope, we could\n+    \/\/                     register that Exception, and in the inner scope we can\n+    \/\/                     check if there is any \"StructuralName\" for an Exception\n+    \/\/                     and its subtypes - if so, we know the exception would be\n+    \/\/                     caught.\n+    \/\/\n+    \/\/ Let us show an examples with Method names. But for simplicity, we assume they\n+    \/\/ all have the same signature: they take two int arguments and return an int.\n+    \/\/\n+    \/\/ Should you ever work on a test where there are methods with different signatures,\n+    \/\/ then you would have to very carefully study and design the subtype relation between\n+    \/\/ methods. You may want to read up about covariance and contravariance. This\n+    \/\/ example ignores all of that, because we only have \"(II)I\" methods.\n+    private record MyMethodType() implements StructuralName.Type {\n+        @Override\n+        public boolean isSubtypeOf(StructuralName.Type other) {\n+            return other instanceof MyMethodType();\n+        }\n+\n+        @Override\n+        public String name() { return \"<not used, don't worry>\"; }\n+    }\n+    private static final MyMethodType myMethodType = new MyMethodType();\n+\n+    public static String generateWithStructuralNamesForMethods() {\n+        \/\/ Define a method, which takes two ints, returns the result of op.\n+        var templateMethod = Template.make(\"op\", (String op) -> body(\n+            \/\/ Register the method name, so we can later sample.\n+            addStructuralName($(\"methodName\"), myMethodType),\n+            \"\"\"\n+            public static int $methodName(int a, int b) {\n+                return a #op b;\n+            }\n+            \"\"\"\n+        ));\n+\n+        var templateSample = Template.make(() -> body(\n+            \/\/ Sample a random method, and retrieve its name.\n+            let(\"methodName\", structuralNames().exactOf(myMethodType).sample().name()),\n+            \"\"\"\n+            System.out.println(\"Calling #methodName with inputs 7 and 11\");\n+            System.out.println(\"  result: \" + #methodName(7, 11));\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest9 {\n+                \/\/ Let us define some methods that we can sample from later.\n+            \"\"\",\n+            \/\/ We must set a CLASS_HOOK here, and insert the method definitions to that hook.\n+            Hooks.CLASS_HOOK.set(\n+                \/\/ If we directly nest the templateMethod, then the addStructuralName goes to the nested\n+                \/\/ scope, and is not available at the class scope, i.e. it is not visible\n+                \/\/ for sampleStructuralName in outside of the templateMethod.\n+                \/\/ DO NOT DO THIS, the nested addStructuralName will not be visible:\n+                \"\/\/ We cannot sample from the following methods:\\n\",\n+                templateMethod.asToken(\"+\"),\n+                templateMethod.asToken(\"-\"),\n+                \/\/ However, if we insert to the CLASS_HOOK, then the Rendere makes the\n+                \/\/ scope of the inserted templateMethod transparent, and the addStructuralName\n+                \/\/ goes out to the scope of the CLASS_HOOK (but no further than that).\n+                \/\/ RATHER, DO THIS to ensure the addStructuralName is visible:\n+                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"*\")),\n+                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"|\")),\n+                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"&\")),\n+                \"\"\"\n+\n+                    public static void main() {\n+                        \/\/ Now, we call some random methods, but only those that were inserted\n+                        \/\/ to the CLASS_HOOK.\n+                        \"\"\",\n+                        Collections.nCopies(10, templateSample.asToken()),\n+                        \"\"\"\n+                    }\n+                }\n+                \"\"\"\n+            )\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":189,"deletions":152,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import compiler.lib.template_framework.Name;\n+import compiler.lib.template_framework.DataName;\n@@ -51,3 +51,5 @@\n-import static compiler.lib.template_framework.Template.addName;\n-import static compiler.lib.template_framework.Template.weighNames;\n-import static compiler.lib.template_framework.Template.sampleName;\n+import static compiler.lib.template_framework.Template.addDataName;\n+import static compiler.lib.template_framework.Template.dataNames;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE;\n+import static compiler.lib.template_framework.DataName.Mutability.IMMUTABLE;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE_OR_IMMUTABLE;\n@@ -60,1 +62,1 @@\n-    private record MyPrimitive(String name) implements Name.Type {\n+    private record MyPrimitive(String name) implements DataName.Type {\n@@ -62,1 +64,1 @@\n-        public boolean isSubtypeOf(Name.Type other) {\n+        public boolean isSubtypeOf(DataName.Type other) {\n@@ -73,1 +75,1 @@\n-    private record MyClass(String name) implements Name.Type {\n+    private record MyClass(String name) implements DataName.Type {\n@@ -75,1 +77,1 @@\n-        public boolean isSubtypeOf(Name.Type other) {\n+        public boolean isSubtypeOf(DataName.Type other) {\n@@ -107,4 +109,4 @@\n-        testNames();\n-        testNames2();\n-        testNames3();\n-        testNames4();\n+        testDataNames();\n+        testDataNames2();\n+        testDataNames3();\n+        testDataNames4();\n@@ -118,2 +120,2 @@\n-        expectRendererException(() -> weighNames(myInt, true),            \"A Template method such as\");\n-        expectRendererException(() -> sampleName(myInt, true),            \"A Template method such as\");\n+        expectRendererException(() -> dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).count(),  \"A Template method such as\");\n+        expectRendererException(() -> dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).sample(), \"A Template method such as\");\n@@ -122,1 +124,1 @@\n-        expectRendererException(() -> testFailingSample(), \"No variable of type 'int'.\");\n+        expectRendererException(() -> testFailingSample1(),  \"No variable: MUTABLE, subtypeOf(int), supertypeOf(int).\");\n@@ -136,0 +138,2 @@\n+        expectIllegalArgumentException(() -> testFailingAddDataName(), \"Unexpected mutability: MUTABLE_OR_IMMUTABLE\");\n+        expectUnsupportedOperationException(() -> testFailingSample2(), \"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n@@ -903,1 +907,1 @@\n-    public static void testNames() {\n+    public static void testDataNames() {\n@@ -907,1 +911,7 @@\n-            \"[\", weighNames(myInt, true), \"]\\n\"\n+            \"[\",\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).hasAny(),\n+            \", \",\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).count(),\n+            \", names: {\",\n+            String.join(\", \", dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            \"}]\\n\"\n@@ -910,2 +920,2 @@\n-        var template2 = Template.make(\"name\", \"type\", (String name, Name.Type type) -> body(\n-            addName(new Name(name, type, true, 1)),\n+        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n+            addDataName(name, type, MUTABLE),\n@@ -945,1 +955,1 @@\n-            [0L]\n+            [false, 0, names: {}]\n@@ -947,2 +957,2 @@\n-            [1L]\n-            [0L]\n+            [true, 1, names: {name_4}]\n+            [false, 0, names: {}]\n@@ -954,1 +964,1 @@\n-            [1L]\n+            [true, 1, names: {name_4}]\n@@ -957,1 +967,1 @@\n-            [2L]\n+            [true, 2, names: {name_4, name_1}]\n@@ -959,2 +969,2 @@\n-            [1L]\n-            [0L]\n+            [true, 1, names: {name_4}]\n+            [false, 0, names: {}]\n@@ -966,1 +976,1 @@\n-    public static void testNames2() {\n+    public static void testDataNames2() {\n@@ -969,2 +979,8 @@\n-        var template1 = Template.make(\"type\", (Name.Type type) -> body(\n-            \"[#type: \", weighNames(type, true), \" and \", weighNames(type, false), \"]\\n\"\n+        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> body(\n+            \"  #mutability: [\",\n+            dataNames(mutability).exactOf(myInt).hasAny(),\n+            \", \",\n+            dataNames(mutability).exactOf(myInt).count(),\n+            \", names: {\",\n+            String.join(\", \", dataNames(mutability).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            \"}]\\n\"\n@@ -973,0 +989,7 @@\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+            \"[#type:\\n\",\n+            template0.asToken(type, MUTABLE),\n+            template0.asToken(type, IMMUTABLE),\n+            template0.asToken(type, MUTABLE_OR_IMMUTABLE),\n+            \"]\\n\"\n+        ));\n@@ -974,2 +997,2 @@\n-        var template2 = Template.make(\"name\", \"type\", (String name, Name.Type type) -> body(\n-            addName(new Name(name, type, true, 1)),\n+        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n+            addDataName(name, type, MUTABLE),\n@@ -980,2 +1003,2 @@\n-        var template3 = Template.make(\"name\", \"type\", (String name, Name.Type type) -> body(\n-            addName(new Name(name, type, false, 1)),\n+        var template3 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n+            addDataName(name, type, IMMUTABLE),\n@@ -986,1 +1009,1 @@\n-        var template4 = Template.make(\"type\", (Name.Type type) -> body(\n+        var template4 = Template.make(\"type\", (DataName.Type type) -> body(\n@@ -993,1 +1016,1 @@\n-        var template5 = Template.make(\"type\", (Name.Type type) -> body(\n+        var template5 = Template.make(\"type\", (DataName.Type type) -> body(\n@@ -1000,2 +1023,2 @@\n-        var template6 = Template.make(\"type\", (Name.Type type) -> body(\n-            let(\"v\", sampleName(type, true).name()),\n+        var template6 = Template.make(\"type\", (DataName.Type type) -> body(\n+            let(\"v\", dataNames(MUTABLE).exactOf(type).sample().name()),\n@@ -1007,2 +1030,2 @@\n-        var template7 = Template.make(\"type\", (Name.Type type) -> body(\n-            let(\"v\", sampleName(type, false).name()),\n+        var template7 = Template.make(\"type\", (DataName.Type type) -> body(\n+            let(\"v\", dataNames(MUTABLE_OR_IMMUTABLE).exactOf(type).sample().name()),\n@@ -1039,5 +1062,17 @@\n-            [int: 0L and 0L]\n-            define immutable int name_4\n-            [int: 0L and 1L]\n-            define mutable int name_9\n-            [int: 1L and 2L]\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n+            define immutable int name_10\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [true, 1, names: {name_10}]\n+              MUTABLE_OR_IMMUTABLE: [true, 1, names: {name_10}]\n+            ]\n+            define mutable int name_21\n+            [int:\n+              MUTABLE: [true, 1, names: {name_21}]\n+              IMMUTABLE: [true, 1, names: {name_10}]\n+              MUTABLE_OR_IMMUTABLE: [true, 2, names: {name_10, name_21}]\n+            ]\n@@ -1045,1 +1080,5 @@\n-            [int: 0L and 0L]\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n@@ -1047,3 +1086,3 @@\n-            { load_4\n-            blackhole(name_4)\n-            } load_4\n+            { load_10\n+            blackhole(name_10)\n+            } load_10\n@@ -1051,4 +1090,8 @@\n-            { sample_7\n-            blackhole(name_4)\n-            } sample_7\n-            [int: 0L and 1L]\n+            { sample_16\n+            blackhole(name_10)\n+            } sample_16\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [true, 1, names: {name_10}]\n+              MUTABLE_OR_IMMUTABLE: [true, 1, names: {name_10}]\n+            ]\n@@ -1056,3 +1099,3 @@\n-            { store_9\n-            name_9 = 5\n-            } store_9\n+            { store_21\n+            name_21 = 5\n+            } store_21\n@@ -1060,5 +1103,13 @@\n-            { sample_12\n-            name_9 = 7\n-            } sample_12\n-            [int: 1L and 2L]\n-            [int: 0L and 0L]\n+            { sample_27\n+            name_21 = 7\n+            } sample_27\n+            [int:\n+              MUTABLE: [true, 1, names: {name_21}]\n+              IMMUTABLE: [true, 1, names: {name_10}]\n+              MUTABLE_OR_IMMUTABLE: [true, 2, names: {name_10, name_21}]\n+            ]\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n@@ -1070,1 +1121,1 @@\n-    public static void testNames3() {\n+    public static void testDataNames3() {\n@@ -1073,2 +1124,16 @@\n-        var template1 = Template.make(\"type\", (Name.Type type) -> body(\n-            \"[#type: \", weighNames(type, true), \" and \", weighNames(type, false), \"]\\n\"\n+        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> body(\n+            \"  #mutability: [\",\n+            dataNames(mutability).exactOf(myInt).hasAny(),\n+            \", \",\n+            dataNames(mutability).exactOf(myInt).count(),\n+            \", names: {\",\n+            String.join(\", \", dataNames(mutability).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            \"}]\\n\"\n+        ));\n+\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+            \"[#type:\\n\",\n+            template0.asToken(type, MUTABLE),\n+            template0.asToken(type, IMMUTABLE),\n+            template0.asToken(type, MUTABLE_OR_IMMUTABLE),\n+            \"]\\n\"\n@@ -1083,2 +1148,2 @@\n-                \"define mutable\\n\",\n-                addName(new Name($(\"v1\"), myInt, true, 1)),\n+                \"define mutable $v1\\n\",\n+                addDataName($(\"v1\"), myInt, MUTABLE),\n@@ -1086,2 +1151,2 @@\n-                \"define immutable\\n\",\n-                addName(new Name($(\"v1\"), myInt, false, 1)),\n+                \"define immutable $v2\\n\",\n+                addDataName($(\"v2\"), myInt, IMMUTABLE),\n@@ -1098,1 +1163,5 @@\n-            [int: 0L and 0L]\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n@@ -1100,6 +1169,22 @@\n-            [int: 0L and 0L]\n-            define mutable\n-            [int: 1L and 1L]\n-            define immutable\n-            [int: 1L and 2L]\n-            [int: 0L and 0L]\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n+            define mutable v1_1\n+            [int:\n+              MUTABLE: [true, 1, names: {v1_1}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [true, 1, names: {v1_1}]\n+            ]\n+            define immutable v2_1\n+            [int:\n+              MUTABLE: [true, 1, names: {v1_1}]\n+              IMMUTABLE: [true, 1, names: {v2_1}]\n+              MUTABLE_OR_IMMUTABLE: [true, 2, names: {v1_1, v2_1}]\n+            ]\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n@@ -1111,1 +1196,1 @@\n-    public static void testNames4() {\n+    public static void testDataNames4() {\n@@ -1114,2 +1199,24 @@\n-        var template1 = Template.make(\"type\", (Name.Type type) -> body(\n-            \"  [#type: \", weighNames(type, true), \" and \", weighNames(type, false), \"]\\n\"\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+            \"[#type:\\n\",\n+            \"  exact: \",\n+            dataNames(MUTABLE).exactOf(type).hasAny(),\n+            \", \",\n+            dataNames(MUTABLE).exactOf(type).count(),\n+            \", {\",\n+            String.join(\", \", dataNames(MUTABLE).exactOf(type).toList().stream().map(DataName::name).toList()),\n+            \"}\\n\",\n+            \"  subtype: \",\n+            dataNames(MUTABLE).subtypeOf(type).hasAny(),\n+            \", \",\n+            dataNames(MUTABLE).subtypeOf(type).count(),\n+            \", {\",\n+            String.join(\", \", dataNames(MUTABLE).subtypeOf(type).toList().stream().map(DataName::name).toList()),\n+            \"}\\n\",\n+            \"  supertype: \",\n+            dataNames(MUTABLE).supertypeOf(type).hasAny(),\n+            \", \",\n+            dataNames(MUTABLE).supertypeOf(type).count(),\n+            \", {\",\n+            String.join(\", \", dataNames(MUTABLE).supertypeOf(type).toList().stream().map(DataName::name).toList()),\n+            \"}\\n\",\n+            \"]\\n\"\n@@ -1118,1 +1225,1 @@\n-        List<Name.Type> types = List.of(myClassA, myClassA1, myClassA2, myClassA11, myClassB);\n+        List<DataName.Type> types = List.of(myClassA, myClassA1, myClassA2, myClassA11, myClassB);\n@@ -1120,1 +1227,1 @@\n-            \"Weigh Names:\\n\",\n+            \"DataNames:\\n\",\n@@ -1124,2 +1231,2 @@\n-        var template3 = Template.make(\"type\", (Name.Type type) -> body(\n-            let(\"name\", sampleName(type, true)),\n+        var template3 = Template.make(\"type\", (DataName.Type type) -> body(\n+            let(\"name\", dataNames(MUTABLE).subtypeOf(type).sample()),\n@@ -1134,1 +1241,1 @@\n-                addName(new Name($(\"v1\"), myClassA11, true, 1)),\n+                addDataName($(\"v1\"), myClassA11, MUTABLE),\n@@ -1139,1 +1246,1 @@\n-                addName(new Name($(\"v2\"), myClassA, true, 1)),\n+                addDataName($(\"v2\"), myClassA, MUTABLE),\n@@ -1152,6 +1259,26 @@\n-            Weigh Names:\n-              [myClassA: 0L and 0L]\n-              [myClassA1: 0L and 0L]\n-              [myClassA2: 0L and 0L]\n-              [myClassA11: 0L and 0L]\n-              [myClassB: 0L and 0L]\n+            DataNames:\n+            [myClassA:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA1:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA2:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA11:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassB:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n@@ -1159,3 +1286,3 @@\n-            Sample myClassA11: Name[name=v1_1, type=myClassA11, mutable=true, weight=1]\n-            Sample myClassA1: Name[name=v1_1, type=myClassA11, mutable=true, weight=1]\n-            Sample myClassA: Name[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA11: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA1: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n@@ -1163,14 +1290,54 @@\n-            Sample myClassA11: Name[name=v1_1, type=myClassA11, mutable=true, weight=1]\n-            Sample myClassA1: Name[name=v1_1, type=myClassA11, mutable=true, weight=1]\n-            Weigh Names:\n-              [myClassA: 2L and 2L]\n-              [myClassA1: 1L and 1L]\n-              [myClassA2: 0L and 0L]\n-              [myClassA11: 1L and 1L]\n-              [myClassB: 0L and 0L]\n-            Weigh Names:\n-              [myClassA: 0L and 0L]\n-              [myClassA1: 0L and 0L]\n-              [myClassA2: 0L and 0L]\n-              [myClassA11: 0L and 0L]\n-              [myClassB: 0L and 0L]\n+            Sample myClassA11: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA1: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            DataNames:\n+            [myClassA:\n+              exact: true, 1, {v2_1}\n+              subtype: true, 2, {v1_1, v2_1}\n+              supertype: true, 1, {v2_1}\n+            ]\n+            [myClassA1:\n+              exact: false, 0, {}\n+              subtype: true, 1, {v1_1}\n+              supertype: true, 1, {v2_1}\n+            ]\n+            [myClassA2:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: true, 1, {v2_1}\n+            ]\n+            [myClassA11:\n+              exact: true, 1, {v1_1}\n+              subtype: true, 1, {v1_1}\n+              supertype: true, 2, {v1_1, v2_1}\n+            ]\n+            [myClassB:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            DataNames:\n+            [myClassA:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA1:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA2:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA11:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassB:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n@@ -1182,1 +1349,1 @@\n-    record MyItem(Name.Type type, String op) {}\n+    record MyItem(DataName.Type type, String op) {}\n@@ -1256,1 +1423,10 @@\n-    public static void testFailingSample() {\n+    public static void testFailingSample1() {\n+        var template1 = Template.make(() -> body(\n+            let(\"v\", dataNames(MUTABLE).exactOf(myInt).sample().name()),\n+            \"v is #v\\n\"\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingSample2() {\n@@ -1258,1 +1434,1 @@\n-            let(\"v\", sampleName(myInt, true).name()),\n+            let(\"v\", dataNames(MUTABLE).sample().name()),\n@@ -1318,0 +1494,7 @@\n+    public static void testFailingAddDataName() {\n+        var template1 = Template.make(() -> body(\n+            addDataName(\"name\", myInt, MUTABLE_OR_IMMUTABLE)\n+        ));\n+        String code = template1.render();\n+    }\n+\n@@ -1321,1 +1504,1 @@\n-            System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+            System.out.println(\"Should have thrown RendererException with prefix: \" + errorPrefix);\n@@ -1335,1 +1518,1 @@\n-            System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+            System.out.println(\"Should have thrown IllegalArgumentException with prefix: \" + errorPrefix);\n@@ -1346,0 +1529,14 @@\n+    public static void expectUnsupportedOperationException(FailingTest test, String errorPrefix) {\n+        try {\n+            test.run();\n+            System.out.println(\"Should have thrown UnsupportedOperationException with prefix: \" + errorPrefix);\n+            throw new RuntimeException(\"Should have thrown!\");\n+        } catch(UnsupportedOperationException e) {\n+            if (!e.getMessage().startsWith(errorPrefix)) {\n+                System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+                System.out.println(\"got: \" + e.getMessage());\n+                throw new RuntimeException(\"Prefix mismatch\", e);\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestTemplate.java","additions":308,"deletions":111,"binary":false,"changes":419,"status":"modified"}]}