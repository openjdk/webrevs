{"files":[{"patch":"@@ -68,1 +68,2 @@\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest7\", generateWithNames());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest7\", generateWithNamesSimple());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest8\", generateWithNames());\n@@ -84,0 +85,1 @@\n+        comp.invoke(\"p.xyz.InnerTest8\", \"main\", new Object[] {});\n@@ -424,3 +426,90 @@\n-    \/\/ In the example below (\"generateWithNames\"), we see the use of Names to add\n-    \/\/ variables and fields to code scopes, and then sample from those variables\n-    \/\/ and fields. Every Name has a Name.Type, which we now define for int and long.\n+    \/\/ Below, we introduce the concept of \"Names\". Code generation often involves defining\n+    \/\/ fields and variables, which are then available inside a defined scope, and can be\n+    \/\/ sampled in any nested scope. To allow the use of names for multiple applications\n+    \/\/ (e.g. fields, variables, methods, etc.), we define a Name, which captures the String\n+    \/\/ representation to be used in code, as well as its type and if it is mutable.\n+    \/\/\n+    \/\/ To get started, we show an example where all Names have the same type, and where\n+    \/\/ all Names are mutable. For simplicity, our type represents the primitive int type.\n+    private record MySimpleType() implements Name.Type {\n+        \/\/ The type is only subtype of itself. This is relevant when sampling or weighing\n+        \/\/ Names, because we do not just sample from the given type, but also its subtypes.\n+        @Override\n+        public boolean isSubtypeOf(Name.Type other) {\n+            return other instanceof MySimpleType();\n+        }\n+\n+        \/\/ The name of the type can later be accessed, and used in code. We are working\n+        \/\/ with ints, so that is what we return.\n+        @Override\n+        public String name() { return \"int\"; }\n+    }\n+    private static final MySimpleType mySimpleType = new MySimpleType();\n+\n+    \/\/ In this Example, we generate 3 fields, and add their names to the\n+    \/\/ current scope. In a nested Template, we can then sample one of these\n+    \/\/ Names, which gives us one of the fields. We increment that randomly\n+    \/\/ chosen field. At the end, we print all three fields.\n+    public static String generateWithNamesSimple() {\n+        var templateMain = Template.make(() -> body(\n+            \/\/ Sample a random Name, i.e. field, and assign its name to\n+            \/\/ the hashtag replacement \"#f\".\n+            \/\/ We are picking a mutable Name, because we are not just\n+            \/\/ reading but also writing to the field.\n+            let(\"f\", sampleName(mySimpleType, true).name()),\n+            \"\"\"\n+            \/\/ Let us now sample a random field #f, and increment it.\n+            #f += 42;\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \/\/ Let us define the names for the three fields.\n+            \/\/ We can then sample from these names in a nested Template.\n+            \/\/ We make all Names mutable, and with the same weight of 1,\n+            \/\/ so that they have equal probability of being sampled.\n+            addName(new Name($(\"f1\"), mySimpleType, true, 1)),\n+            addName(new Name($(\"f2\"), mySimpleType, true, 1)),\n+            addName(new Name($(\"f3\"), mySimpleType, true, 1)),\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest7 {\n+                \/\/ Let us define a some fields.\n+                public static int $f1;\n+                public static int $f2;\n+                public static int $f3;\n+\n+                public static void main() {\n+                    \/\/ Let us now call the nested template that samples\n+                    \/\/ a random field and increments it.\n+                    \"\"\",\n+                    templateMain.asToken(),\n+                    \"\"\"\n+                    \/\/ Now, we can print all three fields, and see which\n+                    \/\/ one was incremented.\n+                    System.out.println(\"f1: \" + $f1);\n+                    System.out.println(\"f2: \" + $f2);\n+                    System.out.println(\"f3: \" + $f3);\n+                    \/\/ We have two zeros, and one 42.\n+                    if ($f1 + $f2 + $f3 != 42) { throw new RuntimeException(\"wrong result!\"); }\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ In the example above, we could have easily kept track of the three fields ourselves,\n+    \/\/ and would not have had to rely on the Template Framework's Names for this. However,\n+    \/\/ with more complicated examples, this gets more and more difficult, if not impossible.\n+    \/\/\n+    \/\/ In the example below, we make the scenario a little more realistic. We work with an\n+    \/\/ int and a long type. In the main method, we add some fields and local variables, and\n+    \/\/ register their Names. When sampling from the main method, we should be able to see\n+    \/\/ both fields and variables that we just registered. But from another method, we should\n+    \/\/ only see the fields, but the local variables from main should not be sampled.\n+    \/\/\n+    \/\/ Let us now define the wrapper for primitive types such as int and long.\n@@ -433,0 +522,4 @@\n+        \/\/ Note: the name method is automatically overridden by the record\n+        \/\/       field accessor.\n+        \/\/ But we would like to also directly use the type in the templates,\n+        \/\/ hence we let \"toString\" return \"int\" or \"long\".\n@@ -439,3 +532,0 @@\n-    \/\/ Example with names, i.e. addName, weighNames, and sampleName.\n-    \/\/ These can be used to add variables and fields to code scopes, and then sample\n-    \/\/ from the available variables and fields later.\n@@ -443,7 +533,1 @@\n-        var templateSample = Template.make(\"type\", (Name.Type type) -> body(\n-            let(\"name\", sampleName(type, false).name()),\n-            \"\"\"\n-            System.out.println(\"Sampling type #type: #name = \" + #name);\n-            \"\"\"\n-        ));\n-\n+        \/\/ Define a static field.\n@@ -452,0 +536,3 @@\n+            \/\/ Note: since we have overridden MyPrimitive::toString, we can use\n+            \/\/       the type directly as \"#type\" in the template, which then\n+            \/\/       gets hashtag replaced with \"int\" or \"long\".\n@@ -457,0 +544,1 @@\n+        \/\/ Define a local variable.\n@@ -464,0 +552,10 @@\n+        \/\/ Sample a random field or variable, from those that are available at\n+        \/\/ the current scope.\n+        var templateSample = Template.make(\"type\", (Name.Type type) -> body(\n+            let(\"name\", sampleName(type, true).name()),\n+            \"\"\"\n+            System.out.println(\"Sampling type #type: #name = \" + #name);\n+            \"\"\"\n+        ));\n+\n+        \/\/ Check how many fields and variables are available at the current scope.\n@@ -465,2 +563,2 @@\n-            let(\"ints\", weighNames(myInt, false)),\n-            let(\"longs\", weighNames(myLong, false)),\n+            let(\"ints\", weighNames(myInt, true)),\n+            let(\"longs\", weighNames(myLong, true)),\n@@ -472,0 +570,1 @@\n+        \/\/ Definition of the main method body.\n@@ -476,0 +575,1 @@\n+            \/\/ Check the initial status, there should be nothing available.\n@@ -477,0 +577,2 @@\n+            \/\/ Define some local variables. We place them at the beginning of\n+            \/\/ the method, by using the METHOD_HOOK.\n@@ -479,0 +581,2 @@\n+            \/\/ Define some static fields. We place them at the top of the class,\n+            \/\/ by using the CLASS_HOOK.\n@@ -481,0 +585,2 @@\n+            \/\/ If we check the status now, we should see two int and two\n+            \/\/ long names, corresponding to our two fields and variables.\n@@ -482,1 +588,5 @@\n-            \/\/ We should see a mix of fields and variables sampled.\n+            \/\/ Now, we sample 5 int and 5 long names. We should get a mix\n+            \/\/ of fields and variables. We have access to the fields because\n+            \/\/ we inserted them to the class scope. We have access to the\n+            \/\/ variables because we inserted them to the current method\n+            \/\/ body.\n@@ -485,0 +595,1 @@\n+            \/\/ The status should not have changed since we last checked.\n@@ -491,0 +602,2 @@\n+        \/\/ Definition of another method's body. It is in the same class\n+        \/\/ as the main method, so it has access to the same static fields.\n@@ -495,0 +608,2 @@\n+            \/\/ We should see the fields defined in the main body,\n+            \/\/ one int and one long field.\n@@ -496,1 +611,2 @@\n-            \/\/ We still have all the field definitions from main.\n+            \/\/ Sampling 5 random int and 5 random long Names. We should\n+            \/\/ only see the fields, and not the local variables from main.\n@@ -499,0 +615,1 @@\n+            \/\/ The status should not have changed since we last checked.\n@@ -505,0 +622,1 @@\n+        \/\/ Finally, we put it all together in a class.\n@@ -509,1 +627,1 @@\n-            public class InnerTest7 {\n+            public class InnerTest8 {\n@@ -516,1 +634,1 @@\n-                \/\/ Method Hook for local variables, and earlier computations.\n+                \/\/ Method Hook for local variables.\n@@ -533,2 +651,2 @@\n-                \/\/ Have a separate method hook for other, so that it can insert\n-                \/\/ its own local variables.\n+                \/\/ Have a separate method hook for other, where it could insert\n+                \/\/ its own local variables (but happens not to).\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":140,"deletions":22,"binary":false,"changes":162,"status":"modified"}]}