{"files":[{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record AddNameToken(Name name) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/AddNameToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * This class collects code, i.e. {@link String}s or {@link List}s of {@link String}s.\n+ * All the Strings are later collected in a {@link StringBuilder}. If we used a {@link StringBuilder}\n+ * directly to collect the Strings, we could not as easily insert code at an \"earlier\" position, i.e.\n+ * reaching out to a {@link Hook#set}.\n+ *\/\n+sealed interface Code permits Code.Token, Code.CodeList {\n+\n+    record Token(String s) implements Code {\n+        @Override\n+        public void renderTo(StringBuilder builder) {\n+            builder.append(s);\n+        }\n+    }\n+\n+    record CodeList(List<Code> list) implements Code {\n+        @Override\n+        public void renderTo(StringBuilder builder) {\n+            list.forEach(code -> code.renderTo(builder));\n+        }\n+    }\n+\n+    void renderTo(StringBuilder builder);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Code.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * The {@link CodeFrame} represents a frame (i.e. scope) of code, appending {@link Code} to the {@code 'codeList'}\n+ * as {@link Token}s are rendered, and adding names to the {@link NameSet}s as they get defined by {@link Template#define}.\n+ * {@link Hook}s can be added to a frame, which allows code to be inserted at that location later.\n+ * When a {@link Hook} is {@link Hook#set}, this separates the {@link Template} into an outer and inner\n+ * {@link CodeFrame}, ensuring that names that are {@link Template#defineName}'d inside the inner frame\n+ * are only available inside that frame.\n+ *\n+ * <p>\n+ * On the other hand, each {@link TemplateFrame} represents the frame (or scope) of exactly one use of a\n+ * {@link Template}.\n+ *\n+ * <p>\n+ * For simple {@link Template} nesting, the {@link CodeFrame}s and {@link TemplateFrame}s overlap exactly.\n+ * However, when using {@link Hook#insert}, we simply nest {@link TemplateFrame}s, going further \"in\",\n+ * but we jump to an outer {@link CodeFrame}, ensuring that we insert {@link Code} at the outer frame,\n+ * and operating on the names of the outer frame. Once the {@link Hook#insert}ion is complete, we jump\n+ * back to the caller {@link TemplateFrame} and {@link CodeFrame}.\n+ *\/\n+class CodeFrame {\n+    public final CodeFrame parent;\n+    private final List<Code> codeList = new ArrayList<Code>();\n+    private final Map<Hook, Code.CodeList> hookCodeLists = new HashMap<>();\n+\n+    \/**\n+     * The {@link NameSet} is used for variable and fields etc.\n+     *\/\n+    final NameSet names;\n+\n+    private CodeFrame(CodeFrame parent, boolean isTransparentForNames) {\n+        this.parent = parent;\n+        if (parent == null) {\n+            \/\/ NameSet without any parent.\n+            this.names = new NameSet(null);\n+        } else if (isTransparentForNames) {\n+            \/\/ We use the same NameSet as the parent - makes it transparent.\n+            this.names     = parent.names;\n+        } else {\n+            \/\/ New NameSet, to make sure we have a nested scope for the names.\n+            this.names     = new NameSet(parent.names);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a base frame, which has no {@link parent}.\n+     *\/\n+    public static CodeFrame makeBase() {\n+        return new CodeFrame(null, false);\n+    }\n+\n+    \/**\n+     * Creates a normal frame, which has a {@link parent} and which defines an inner\n+     * {@link NameSet}, for the names that are generated inside this frame. Once this\n+     * frame is exited, the name from inside this frame are not available any more.\n+     *\/\n+    public static CodeFrame make(CodeFrame parent) {\n+        return new CodeFrame(parent, false);\n+    }\n+\n+    \/**\n+     * Creates a special frame, which has a {@link parent} and but uses the {@link NameSet}\n+     * from the parent frame, allowing {@link Template#defineName} to persist in the outer\n+     * frame when the current frame is exited. This is necessary for {@link Hook#insert},\n+     * where we would possibly want to make field or variable definitions during the insertion\n+     * that are not just local to the insertion but affect the {@link CodeFrame} that we\n+     * {@link Hook#set} earlier and are now {@link Hook#insert}ing into.\n+     *\/\n+    public static CodeFrame makeTransparentForNames(CodeFrame parent) {\n+        return new CodeFrame(parent, true);\n+    }\n+\n+    void addString(String s) {\n+        codeList.add(new Code.Token(s));\n+    }\n+\n+    void addCode(Code code) {\n+        codeList.add(code);\n+    }\n+\n+    void addHook(Hook hook) {\n+        if (hasHook(hook)) {\n+            \/\/ This should never happen, as we add a dedicated CodeFrame for each hook.\n+            throw new RuntimeException(\"Internal error: Duplicate Hook in CodeFrame: \" + hook.name());\n+        }\n+        hookCodeLists.put(hook, new Code.CodeList(new ArrayList<Code>()));\n+    }\n+\n+    boolean hasHook(Hook hook) {\n+        return hookCodeLists.containsKey(hook);\n+    }\n+\n+    CodeFrame codeFrameForHook(Hook hook) {\n+        CodeFrame current = this;\n+        while (current != null) {\n+            if (current.hasHook(hook)) {\n+                return current;\n+            }\n+            current = current.parent;\n+        }\n+        return null;\n+    }\n+\n+    void addName(Name name) {\n+        names.add(name);\n+    }\n+\n+    long weighNames(Name.Type type, boolean onlyMutable) {\n+        return names.weight(type, onlyMutable);\n+    }\n+\n+    Name sampleName(Name.Type type, boolean onlyMutable) {\n+        return names.sample(type, onlyMutable);\n+    }\n+\n+    Code getCode() {\n+        return new Code.CodeList(codeList);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/CodeFrame.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * {@link Hook}s can be {@link #set} for a certain scope in a {@link Template}, and all nested\n+ * {@link Template}s in this scope, and then from within this scope, any {@link Template} can\n+ * {@link #insert} code to where the {@link Hook} was {@link #set}. This can be useful to reach\n+ * \"back\" or to some outer scope, e.g. while generating code for a method, one can reach out\n+ * to the class scope to insert fields.\n+ *\n+ * Example:\n+ * {@snippet lang=java :\n+ * var myHook = new Hook(\"MyHook\");\n+ *\n+ * var template1 = Template.make(\"name\", (String name) -> body(\n+ *     \"\"\"\n+ *     public static int #name = 42;\n+ *     \"\"\"\n+ * ));\n+ *\n+ * var template2 = Template.make(() -> body(\n+ *     \"\"\"\n+ *     public class Test {\n+ *     \"\"\",\n+ *     \/\/ Set the hook here.\n+ *     myHook.set(\n+ *         \"\"\"\n+ *         public static void main(String[] args) {\n+ *         System.out.println(\"$field: \" + $field)\n+ *         \"\"\",\n+ *         \/\/ Reach out to where the hook was set, and insert the code of template1.\n+ *         myHook.insert(template1.withArgs($(\"field\"))),\n+ *         \"\"\"\n+ *         }\n+ *         \"\"\"\n+ *     ),\n+ *     \"\"\"\n+ *     }\n+ *     \"\"\"\n+ * ));\n+ * }\n+ *\n+ * @param name The name of the Hook, for debugging purposes only.\n+ *\/\n+public record Hook(String name) {\n+    \/**\n+     * Set this {@link Hook} for the scope of the provided {@code 'tokens'}.\n+     * From anywhere inside this scope, even in nested {@link Template}s, code can be\n+     * {@link #insert}ed back to the location where this {@link Hook} was {@link #set}.\n+     *\n+     * @param tokens A list of tokens, which have the same restrictions as {@link Template#body}.\n+     * @return A {@link Token} that captures the setting of the scope and the list of validated {@link Token}s.\n+     *\/\n+    public Token set(Object... tokens) {\n+        return new HookSetToken(this, Token.parse(tokens));\n+    }\n+\n+    \/**\n+     * Inserts a {@link TemplateWithArgs} to the innermost location where this {@link Hook} was {@link #set}.\n+     * This could be in the same {@link Template}, or one nested further out.\n+     *\n+     * @param templateWithArgs The {@link Template} with applied arguments to be inserted at the {@link Hook}.\n+     * @return The {@link Token} which when used inside a {@link Template#body} performs the code insertion into the {@link Hook}.\n+     *\/\n+    public Token insert(TemplateWithArgs templateWithArgs) {\n+        return new HookInsertToken(this, templateWithArgs);\n+    }\n+\n+    \/**\n+     * Checks if the {@link Hook} was {@link Hook#set} for the current scope or an outer scope.\n+     *\n+     * @return If the {@link Hook} was {@link Hook#set} for the current scope or an outer scope.\n+     *\/\n+    public boolean isSet() {\n+        return Renderer.getCurrent().isSet(this);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Hook.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record HookInsertToken(Hook hook, TemplateWithArgs templateWithArgs) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookInsertToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+record HookSetToken(Hook hook, List<Token> tokens) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookSetToken.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * {@link Name}s represent things like fields and local variables, or even method names that can be\n+ * added to a code scope with {@link Template#addName} and sampled with {@link Template#sampleName},\n+ * according to the {@code 'weight'} of each {@link Name}. Every {@link Name} has a {@link Name.Type},\n+ * so that sampling can be restricted to these types, or subtypes, defined by {@link Name.Type#isSubtypeOf}.\n+ *\n+ * @param name The {@link String} name used in code.\n+ * @param type The type with which we restrict {@link Template#weighNames} and {@link Template#sampleName}.\n+ * @param mutable Defines if the name is considered mutable or immutable.\n+ * @param weight The weight measured by {@link Template#weighNames} and according to which we sample with {@link Template#sampleName}.\n+ *\/\n+public record Name(String name, Name.Type type, boolean mutable, int weight) {\n+\n+    \/**\n+     * Creates a new {@link Name}.\n+     *\/\n+    public Name {\n+        if (0 >= weight || weight > 1000) {\n+            throw new IllegalArgumentException(\"Unexpected weight: \" + weight);\n+        }\n+    }\n+\n+    \/**\n+     * The interface for the type of a {@link Name}.\n+     *\/\n+    public interface Type {\n+        \/**\n+         * The name of the type, that can be used in code.\n+         *\n+         * @return The {@link String} representation of the type, that can be used in code.\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Defines the subtype relationship with other types, which is used to filter {@link Name}s\n+         * in {@link Template#weighNames} and {@link Template#sampleName}.\n+         *\n+         * @param other The other type, where we check if it is the supertype of {@code 'this'}.\n+         * @return If {@code 'this'} is a subtype of {@code 'other'}.\n+         *\/\n+        boolean isSubtypeOf(Type other);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Name.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * The {@link NameSet} defines a set of {@link Name}s (e.g. fields or variable names). They extend the\n+ * set of the {@code 'parent'} set.\n+ *\/\n+class NameSet {\n+    static final Random RANDOM = Utils.getRandomInstance();\n+\n+    private final NameSet parent;\n+    private final List<Name> names = new ArrayList<>();\n+\n+    NameSet(NameSet parent) {\n+        this.parent = parent;\n+    }\n+\n+    private long localWeight(Name.Type type, boolean onlyMutable) {\n+        long sum = 0;\n+        for (var name : names) {\n+            if (name.type().isSubtypeOf(type) && (name.mutable() || !onlyMutable)) {\n+                sum += name.weight();\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    public long weight(Name.Type type, boolean onlyMutable) {\n+        long w = localWeight(type, onlyMutable);\n+        if (parent != null) { w += parent.weight(type, onlyMutable); }\n+        return w;\n+    }\n+\n+    \/**\n+     * Randomly sample a name from this set or a parent set, restricted to the specified type.\n+     *\/\n+    public Name sample(Name.Type type, boolean onlyMutable) {\n+        long w = weight(type, onlyMutable);\n+        if (w <= 0) {\n+            throw new RendererException(\"No variable of type '\" + type.toString() + \"'.\");\n+        }\n+\n+        long r = RANDOM.nextLong(w);\n+        return sample(type, onlyMutable, r);\n+    }\n+\n+    private Name sample(Name.Type type, boolean onlyMutable, long r) {\n+        for (var name : names) {\n+            if (name.type().isSubtypeOf(type) && (name.mutable() || !onlyMutable)) {\n+                r -= name.weight();\n+                if (r < 0) { return name; }\n+            }\n+        }\n+        return parent.sample(type, onlyMutable, r);\n+    }\n+\n+    \/**\n+     * Add a variable of a specified type to the set.\n+     *\/\n+    public void add(Name name) {\n+        names.add(name);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameSet.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record NothingToken() implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NothingToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+# Template Framework\n+The Template Framework allows the generation of code with Templates. The goal is that these Templates are easy to write, and allow regression tests to cover a larger scope, and to make template based fuzzing easy to extend.\n+\n+The Template Framework only generates code in the form of a String. This code can then be compiled and executed, for example with help of the [Compile Framework](..\/compile_framework\/README.md).\n+\n+The basic functionalities of the Template Framework are described in the [Template Interface](.\/Template.java), together with some examples. More examples can be found in [TestSimple.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestSimple.java) and [TestTutorial.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java).\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/README.md","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * The {@link Renderer} class is used to keep track of the states during a nested\n+ * {@link Template} rendering. There can only be a single {@link Renderer} active\n+ * at any point, since there are static methods that reference {@link Renderer#getCurrent}.\n+ *\n+ * The {@link Renderer} instance keeps track of the current frames,\n+ * see {@link TemplateFrame} and {@link CodeFrame}.\n+ *\/\n+class Renderer {\n+    private static final Pattern DOLLAR_NAME_PATTERN = Pattern.compile(\"\\\\$([a-zA-Z_][a-zA-Z0-9_]*)\");\n+    private static final Pattern HASHTAG_REPLACEMENT_PATTERN = Pattern.compile(\"#([a-zA-Z_][a-zA-Z0-9_]*)\");\n+\n+    \/**\n+     * There can be at most one Renderer instance at any time. This is to avoid that users accidentally\n+     * render templates to strings, rather than letting them all render together.\n+     *\/\n+    private static Renderer renderer = null;\n+\n+    private int nextTemplateFrameId;\n+    private TemplateFrame baseTemplateFrame;\n+    private TemplateFrame currentTemplateFrame;\n+    private CodeFrame baseCodeFrame;\n+    private CodeFrame currentCodeFrame;\n+\n+    \/\/ We do not want any other instances, so we keep it private.\n+    private Renderer(float fuel) {\n+        nextTemplateFrameId = 0;\n+        baseTemplateFrame = TemplateFrame.makeBase(nextTemplateFrameId++, fuel);\n+        currentTemplateFrame = baseTemplateFrame;\n+        baseCodeFrame = CodeFrame.makeBase();\n+        currentCodeFrame = baseCodeFrame;\n+    }\n+\n+    static Renderer getCurrent() {\n+        if (renderer == null) {\n+            throw new RendererException(\"A Template method such as '$' or 'let' was called outside a template rendering.\");\n+        }\n+        return renderer;\n+    }\n+\n+    static String render(TemplateWithArgs templateWithArgs) {\n+        return render(templateWithArgs, Template.DEFAULT_FUEL);\n+    }\n+\n+    static String render(TemplateWithArgs templateWithArgs, float fuel) {\n+        \/\/ Check nobody else is using the Renderer.\n+        if (renderer != null) {\n+            throw new RendererException(\"Nested render not allowed. Please only use 'withArgs' inside Templates, and call 'render' only once at the end.\");\n+        }\n+        try {\n+            renderer = new Renderer(fuel);\n+            renderer.renderTemplateWithArgs(templateWithArgs);\n+            renderer.checkFrameConsistencyAfterRendering();\n+            return renderer.collectCode();\n+        } finally {\n+            \/\/ Release the Renderer.\n+            renderer = null;\n+        }\n+    }\n+\n+    private void checkFrameConsistencyAfterRendering() {\n+        \/\/ Ensure CodeFrame consistency.\n+        if (baseCodeFrame != currentCodeFrame) {\n+            throw new RuntimeException(\"Internal error: Renderer did not end up at base CodeFrame.\");\n+        }\n+        \/\/ Ensure TemplateFrame consistency.\n+        if (baseTemplateFrame != currentTemplateFrame) {\n+            throw new RuntimeException(\"Internal error: Renderer did not end up at base TemplateFrame.\");\n+        }\n+    }\n+\n+    private String collectCode() {\n+        StringBuilder builder = new StringBuilder();\n+        baseCodeFrame.getCode().renderTo(builder);\n+        return builder.toString();\n+    }\n+\n+    String $(String name) {\n+        return currentTemplateFrame.$(name);\n+    }\n+\n+    void addHashtagReplacement(String key, Object value) {\n+        currentTemplateFrame.addHashtagReplacement(key, format(value));\n+    }\n+\n+    private String getHashtagReplacement(String key) {\n+        return currentTemplateFrame.getHashtagReplacement(key);\n+    }\n+\n+    float fuel() {\n+        return currentTemplateFrame.fuel;\n+    }\n+\n+    void setFuelCost(float fuelCost) {\n+        currentTemplateFrame.setFuelCost(fuelCost);\n+    }\n+\n+    long weighNames(Name.Type type, boolean onlyMutable) {\n+        return currentCodeFrame.weighNames(type, onlyMutable);\n+    }\n+\n+    Name sampleName(Name.Type type, boolean onlyMutable) {\n+        return currentCodeFrame.sampleName(type, onlyMutable);\n+    }\n+\n+    \/**\n+     * Formats values to {@link String} with the goal of using them in Java code.\n+     * By default we use the overrides of {@link Object#toString}.\n+     * But for some boxed primitives we need to create a special formatting.\n+     *\/\n+    static String format(Object value) {\n+        return switch (value) {\n+            case String s -> s;\n+            case Integer i -> i.toString();\n+            \/\/ We need to append the \"L\" so that the values are not interpreted as ints,\n+            \/\/ and then javac might complain that the values are too large for an int.\n+            case Long l -> l.toString() + \"L\";\n+            \/\/ Some Float and Double values like Infinity and NaN need a special representation.\n+            case Float f -> formatFloat(f);\n+            case Double d -> formatDouble(d);\n+            default -> value.toString();\n+        };\n+    }\n+\n+    private static String formatFloat(Float f) {\n+        if (Float.isFinite(f)) {\n+            return f.toString() + \"f\";\n+        } else if (f.isNaN()) {\n+            return \"Float.intBitsToFloat(\" + Float.floatToRawIntBits(f) + \" \/* NaN *\/)\";\n+        } else if (f.isInfinite()) {\n+            if (f > 0) {\n+                return \"Float.POSITIVE_INFINITY\";\n+            } else {\n+                return \"Float.NEGATIVE_INFINITY\";\n+            }\n+        } else {\n+            throw new RuntimeException(\"Not handled: \" + f);\n+        }\n+    }\n+\n+    private static String formatDouble(Double d) {\n+        if (Double.isFinite(d)) {\n+            return d.toString();\n+        } else if (d.isNaN()) {\n+            return \"Double.longBitsToDouble(\" + Double.doubleToRawLongBits(d) + \"L \/* NaN *\/)\";\n+        } else if (d.isInfinite()) {\n+            if (d > 0) {\n+                return \"Double.POSITIVE_INFINITY\";\n+            } else {\n+                return \"Double.NEGATIVE_INFINITY\";\n+            }\n+        } else {\n+            throw new RuntimeException(\"Not handled: \" + d);\n+        }\n+    }\n+\n+    private void renderTemplateWithArgs(TemplateWithArgs templateWithArgs) {\n+        TemplateFrame templateFrame = TemplateFrame.make(currentTemplateFrame, nextTemplateFrameId++);\n+        currentTemplateFrame = templateFrame;\n+\n+        templateWithArgs.visitArguments((name, value) -> addHashtagReplacement(name, format(value)));\n+        TemplateBody body = templateWithArgs.instantiate();\n+        renderTokenList(body.tokens());\n+\n+        if (currentTemplateFrame != templateFrame) {\n+            throw new RuntimeException(\"Internal error: TemplateFrame mismatch!\");\n+        }\n+        currentTemplateFrame = currentTemplateFrame.parent;\n+    }\n+\n+    private void renderToken(Token token) {\n+        switch (token) {\n+            case StringToken(String s) -> {\n+                currentCodeFrame.addString(templateString(s));\n+            }\n+            case NothingToken() -> {\n+                \/\/ Nothing.\n+            }\n+            case HookSetToken(Hook hook, List<Token> tokens) -> {\n+                CodeFrame outerCodeFrame = currentCodeFrame;\n+\n+                \/\/ We need a CodeFrame to which the hook can insert code. That way, name\n+                \/\/ definitions at the hook cannot excape the hookCodeFrame.\n+                CodeFrame hookCodeFrame = CodeFrame.make(outerCodeFrame);\n+                hookCodeFrame.addHook(hook);\n+\n+                \/\/ We need a CodeFrame where the tokens can be rendered. That way, name\n+                \/\/ definitions from the tokens cannot escape the innerCodeFrame to the\n+                \/\/ hookCodeFrame.\n+                CodeFrame innerCodeFrame = CodeFrame.make(hookCodeFrame);\n+                currentCodeFrame = innerCodeFrame;\n+\n+                renderTokenList(tokens);\n+\n+                \/\/ Close the hookCodeFrame and innerCodeFrame. hookCodeFrame code comes before the\n+                \/\/ innerCodeFrame code from the tokens.\n+                currentCodeFrame = outerCodeFrame;\n+                currentCodeFrame.addCode(hookCodeFrame.getCode());\n+                currentCodeFrame.addCode(innerCodeFrame.getCode());\n+            }\n+            case HookInsertToken(Hook hook, TemplateWithArgs t) -> {\n+                \/\/ Switch to hook CodeFrame.\n+                CodeFrame callerCodeFrame = currentCodeFrame;\n+                CodeFrame hookCodeFrame = codeFrameForHook(hook);\n+\n+                \/\/ Use a transparent nested CodeFrame. We need a CodeFrame so that the code generated\n+                \/\/ by the TemplateWithArgs can be collected, and hook insertions from it can still\n+                \/\/ be made to the hookCodeFrame before the code from the TemplateWithArgs is added to\n+                \/\/ the hookCodeFrame.\n+                \/\/ But the CodeFrame must be transparent, so that its name definitions go out to\n+                \/\/ the hookCodeFrame, and are not limited to the CodeFrame for the TemplateWithArgs.\n+                currentCodeFrame = CodeFrame.makeTransparentForNames(hookCodeFrame);\n+\n+                renderTemplateWithArgs(t);\n+\n+                hookCodeFrame.addCode(currentCodeFrame.getCode());\n+\n+                \/\/ Switch back from hook CodeFrame to caller CodeFrame.\n+                currentCodeFrame = callerCodeFrame;\n+            }\n+            case TemplateWithArgs t -> {\n+                \/\/ Use a nested CodeFrame.\n+                CodeFrame callerCodeFrame = currentCodeFrame;\n+                currentCodeFrame = CodeFrame.make(currentCodeFrame);\n+\n+                renderTemplateWithArgs(t);\n+\n+                callerCodeFrame.addCode(currentCodeFrame.getCode());\n+                currentCodeFrame = callerCodeFrame;\n+            }\n+            case AddNameToken(Name name) -> {\n+                currentCodeFrame.addName(name);\n+            }\n+        }\n+    }\n+\n+    private void renderTokenList(List<Token> tokens) {\n+        CodeFrame codeFrame = currentCodeFrame;\n+        for (Token t : tokens) {\n+            renderToken(t);\n+        }\n+        if (codeFrame != currentCodeFrame) {\n+            throw new RuntimeException(\"Internal error: CodeFrame mismatch.\");\n+        }\n+    }\n+\n+    private String templateString(String s) {\n+        var temp = DOLLAR_NAME_PATTERN.matcher(s).replaceAll(\n+            (MatchResult result) -> $(result.group(1))\n+        );\n+        return HASHTAG_REPLACEMENT_PATTERN.matcher(temp).replaceAll(\n+            \/\/ We must escape \"$\", because it has a special meaning in replaceAll.\n+            (MatchResult result) -> getHashtagReplacement(result.group(1)).replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\")\n+        );\n+    }\n+\n+    boolean isSet(Hook hook) {\n+        return currentCodeFrame.codeFrameForHook(hook) != null;\n+    }\n+\n+    private CodeFrame codeFrameForHook(Hook hook) {\n+        CodeFrame codeFrame = currentCodeFrame.codeFrameForHook(hook);\n+        if (codeFrame == null) {\n+            throw new RendererException(\"Hook '\" + hook.name() + \"' was referenced but not found!\");\n+        }\n+        return codeFrame;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Renderer.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * This exception is thrown when something goes wrong during {@link Template}\n+ * rendering, or in the use of any of its static methods.\n+ * It most likely indicates a wrong use of the {@link Template}s.\n+ *\/\n+public class RendererException extends RuntimeException {\n+    RendererException(String message) {\n+        super(message);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/RendererException.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record StringToken(String value) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/StringToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,496 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.List;\n+\n+\/**\n+ * {@link Template}s are used to generate code, based on {@link Token}s which are rendered to {@link String}s.\n+ *\n+ * <p>\n+ * A {@link Template} can have zero or more arguments, and for each number of arguments there is an implementation\n+ * (e.g. {@link ZeroArgs} for zero arguments and {@link TwoArgs} for two arguments). This allows the use of Generics\n+ * for the template argument types, i.e. the template arguments can be type checked. Ideally, we would have used\n+ * String Templates to inject these arguments into the strings. But since String Templates are not (yet) available,\n+ * the {@link Template}s provide <strong>hashtag replacements<\/strong> in the Strings: the {@link Template} argument\n+ * names are captured, and the argument values automatically replace any {@code \"#name\"} in the Strings. See the\n+ * different overloads of {@link #make} for examples. Additional hashtag replacements can be defined \n+ * with {@link #let}.\n+ *\n+ * <p>\n+ * When using nested {@link Template}s, there can be collisions with identifiers (e.g. variable names and method names).\n+ * For this, {@link Template}s provide <strong>dollar replacements<\/strong>, which automaticall rename any\n+ * {@code \"$name\"} in the String with a {@code \"name_ID\"}, where the {@code \"ID\"} is unique for every use of\n+ * a {@link Template}. The dollar replacement can also be captured with {@link #$}, and passed to nested\n+ * {@link Template}s, which allows sharing of these identifier names between {@link Template}s.\n+ *\n+ * <p>\n+ * To render a {@link Template} to a {@link String}, one first has to apply the arguments (e.g. with\n+ * {@link TwoArgs#withArgs}) and then the resulting {@link TemplateWithArgs} can either be used as a\n+ * {@link Token} inside another {@link Template}, or rendered to a {@link String} with {@link TemplateWithArgs#render}.\n+ *\n+ * <p>\n+ * A {@link TemplateWithArgs} can be used directly as a {@link Token} inside the {@link Template#body} to\n+ * nest the {@link Template}s. Alternatively, code can be {@link Hook#insert}ed to where a {@link Hook}\n+ * was {@link Hook#set} earlier (in some outer scope of the code). For example, while generating code in\n+ * a method, one can reach out to the scope of the class, and insert a new field, or define a utility method.\n+ *\n+ * <p>\n+ * A {@link TemplateBinding} allows the recurisve use of {@link Template}s. With the indirection of such a binding,\n+ * a {@link Template} can reference itself. To ensure the termination of recursion, the templates are rendered\n+ * with a certain amount of {@link #fuel}, which is decreased at each {@link Template} nesting by a certain amount\n+ * (can be changed with {@link #setFuelCost}). Recursive templates are supposed to terminate once the {@link #fuel}\n+ * is depleated (i.e. reaches zero).\n+ *\n+ * <p>\n+ * Code generation often involves defining fields and variables, which are then available inside a defined\n+ * scope, and can be sampled in any nested scope. To allow the use of names for multiple applications (e.g.\n+ * fields, variables, methods, etc), we define a {@link Name}, which captures the {@link String} representation\n+ * to be used in code, as well as its type and if it is mutable. One can add such a {@link Name} to the\n+ * current code scope with {@link #addName}, and sample from the current or outer scopes with {@link #sampleName}.\n+ * When generating code, one might want to create {@link Name}s (variables, fields, etc) in local scope, or\n+ * in some outer scope with the use of {@link Hook}s.\n+ *\/\n+public interface Template {\n+\n+    \/**\n+     * Creates a {@link Template} with no arguments.\n+     * See {@link #body} for more details about how to construct a {@link Template} with {@link Token}s.\n+     *\n+     * <p>\n+     * Example:\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> body(\n+     *     \"\"\"\n+     *     Multi-line string or other tokens.\n+     *     \"\"\"\n+     * ));\n+     * }\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @return A {@link Template} with zero arguments.\n+     *\/\n+    static ZeroArgs make(Supplier<TemplateBody> body) {\n+        return new ZeroArgs(body);\n+    }\n+\n+    \/**\n+     * Creates a {@link Template} with one argument.\n+     * See {@link #body} for more details about how to construct a {@link Template} with {@link Token}s.\n+     *\n+     * <p>\n+     * Here an example with template argument {@code 'a'}, captured once as string name\n+     * for use in hashtag replacements, and captured once as lambda argument with the corresponding type\n+     * of the generic argument.\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", (Integer a) -> body(\n+     *     \"\"\"\n+     *     Multi-line string or other tokens.\n+     *     We can use the hashtag replacement #a to directly insert the String value of a.\n+     *     \"\"\",\n+     *     \"We can also use the captured parameter of a: \" + a\n+     * ));\n+     * }\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param <A> Type of the (first) argument.\n+     * @param arg0Name The name of the (first) argument for hashtag replacement.\n+     * @return A {@link Template} with one argument.\n+     *\/\n+    static <A> OneArgs<A> make(String arg0Name, Function<A, TemplateBody> body) {\n+        return new OneArgs<>(arg0Name, body);\n+    }\n+\n+    \/**\n+     * Creates a {@link Template} with two arguments.\n+     * See {@link #body} for more details about how to construct a {@link Template} with {@link Token}s.\n+     *\n+     * <p>\n+     * Here an example with template arguments {@code 'a'} and {@code 'b'}, captured once as string names\n+     * for use in hashtag replacements, and captured once as lambda arguments with the corresponding types\n+     * of the generic arguments.\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", \"b\", (Integer a, String b) -> body(\n+     *     \"\"\"\n+     *     Multi-line string or other tokens.\n+     *     We can use the hashtag replacement #a and #b to directly insert the String value of a and b.\n+     *     \"\"\",\n+     *     \"We can also use the captured parameter of a and b: \" + a + \" and \" + b\n+     * ));\n+     * }\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param <A> Type of the first argument.\n+     * @param arg0Name The name of the first argument for hashtag replacement.\n+     * @param <B> Type of the second argument.\n+     * @param arg1Name The name of the second argument for hashtag replacement.\n+     * @return A {@link Template} with two arguments.\n+     *\/\n+    static <A, B> TwoArgs<A, B> make(String arg0Name, String arg1Name, BiFunction<A, B, TemplateBody> body) {\n+        return new TwoArgs<>(arg0Name, arg1Name, body);\n+    }\n+\n+    \/**\n+     * Interface for function with three arguments.\n+     *\n+     * @param <T> Type of the first argument.\n+     * @param <U> Type of the second argument.\n+     * @param <V> Type of the third argument.\n+     * @param <R> Type of the return value.\n+     *\/\n+    @FunctionalInterface\n+    public interface TriFunction<T, U, V, R> {\n+\n+        \/**\n+         * Function definition for the three argument functions.\n+         *\n+         * @param t The first argument.\n+         * @param u The second argument.\n+         * @param v The third argument.\n+         * @return Return value of the three argument function.\n+         *\/\n+        R apply(T t, U u, V v);\n+    }\n+\n+    \/**\n+     * Creates a {@link Template} with three arguments.\n+     * See {@link #body} for more details about how to construct a {@link Template} with {@link Token}s.\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param <A> Type of the first argument.\n+     * @param arg0Name The name of the first argument for hashtag replacement.\n+     * @param <B> Type of the second argument.\n+     * @param arg1Name The name of the second argument for hashtag replacement.\n+     * @param <C> Type of the third argument.\n+     * @param arg2Name The name of the third argument for hashtag replacement.\n+     * @return A {@link Template} with three arguments.\n+     *\/\n+    static <A, B, C> ThreeArgs<A, B, C> make(String arg0Name, String arg1Name, String arg2Name, TriFunction<A, B, C, TemplateBody> body) {\n+        return new ThreeArgs<>(arg0Name, arg1Name, arg2Name, body);\n+    }\n+\n+    \/**\n+     * A {@link Template} with no arguments.\n+     *\n+     * @param function The {@link Supplier} that creates the {@link TemplateBody}.\n+     *\/\n+    record ZeroArgs(Supplier<TemplateBody> function) implements Template {\n+        TemplateBody instantiate() {\n+            return function.get();\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateWithArgs} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation, and it can also be used with\n+         * {@link TemplateWithArgs#render} to render the template to a {@link String}\n+         * directly.\n+         *\n+         * @return The template all (zero) arguments applied.\n+         *\/\n+        public TemplateWithArgs withArgs() {\n+            return new TemplateWithArgs.ZeroArgsUse(this);\n+        }\n+    }\n+\n+\n+    \/**\n+     * A {@link Template} with one argument.\n+     *\n+     * @param arg0Name The name of the (first) argument, used for hashtag replacements in the {@link Template}.\n+     * @param <A> The type of the (first) argument.\n+     * @param function The {@link Function} that creates the {@link TemplateBody} given the template argument.\n+     *\/\n+    record OneArgs<A>(String arg0Name, Function<A, TemplateBody> function) implements Template {\n+        TemplateBody instantiate(A a) {\n+            return function.apply(a);\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateWithArgs} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation, and it can also be used with\n+         * {@link TemplateWithArgs#render} to render the template to a {@link String}\n+         * directly.\n+         *\n+         * @param a The value for the (first) argument.\n+         * @return The template its argument applied.\n+         *\/\n+        public TemplateWithArgs withArgs(A a) {\n+            return new TemplateWithArgs.OneArgsUse<>(this, a);\n+        }\n+    }\n+\n+    \/**\n+     * A {@link Template} with two arguments.\n+     *\n+     * @param arg0Name The name of the first argument, used for hashtag replacements in the {@link Template}.\n+     * @param arg1Name The name of the second argument, used for hashtag replacements in the {@link Template}.\n+     * @param <A> The type of the first argument.\n+     * @param <B> The type of the second argument.\n+     * @param function The {@link BiFunction} that creates the {@link TemplateBody} given the template arguments.\n+     *\/\n+    record TwoArgs<A, B>(String arg0Name, String arg1Name,\n+                         BiFunction<A, B, TemplateBody> function) implements Template {\n+        TemplateBody instantiate(A a, B b) {\n+            return function.apply(a, b);\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateWithArgs} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation, and it can also be used with\n+         * {@link TemplateWithArgs#render} to render the template to a {@link String}\n+         * directly.\n+         *\n+         * @param a The value for the first argument.\n+         * @param b The value for the second argument.\n+         * @return The template all (two) arguments applied.\n+         *\/\n+        public TemplateWithArgs withArgs(A a, B b) {\n+            return new TemplateWithArgs.TwoArgsUse<>(this, a, b);\n+        }\n+    }\n+\n+    \/**\n+     * A {@link Template} with three arguments.\n+     *\n+     * @param arg0Name The name of the first argument, used for hashtag replacements in the {@link Template}.\n+     * @param arg1Name The name of the second argument, used for hashtag replacements in the {@link Template}.\n+     * @param arg2Name The name of the third argument, used for hashtag replacements in the {@link Template}.\n+     * @param <A> The type of the first argument.\n+     * @param <B> The type of the second argument.\n+     * @param <C> The type of the third argument.\n+     * @param function The function with three arguments that creates the {@link TemplateBody} given the template arguments.\n+     *\/\n+    record ThreeArgs<A, B, C>(String arg0Name, String arg1Name, String arg2Name,\n+                              TriFunction<A, B, C, TemplateBody> function) implements Template {\n+        TemplateBody instantiate(A a, B b, C c) {\n+            return function.apply(a, b, c);\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateWithArgs} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation, and it can also be used with\n+         * {@link TemplateWithArgs#render} to render the template to a {@link String}\n+         * directly.\n+         *\n+         * @param a The value for the first argument.\n+         * @param b The value for the second argument.\n+         * @param c The value for the third argument.\n+         * @return The template all (three) arguments applied.\n+         *\/\n+        public TemplateWithArgs withArgs(A a, B b, C c) {\n+            return new TemplateWithArgs.ThreeArgsUse<>(this, a, b, c);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a {@link TemplateBody} from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (e.g. {@link Integer}), any {@link Token}, or {@link List}s\n+     * of any of these.\n+     *\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> body(\n+     *     \"\"\"\n+     *     Multi-line string\n+     *     \"\"\",\n+     *     \"normal string \", Integer.valueOf(3), Float.valueOf(1.5f),\n+     *     List.of(\"abc\", \"def\"),\n+     *     nestedTemplate.withArgs(42)\n+     * ));\n+     * }\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s,boxed primitive types\n+     *               (e.g. {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link TemplateBody} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static TemplateBody body(Object... tokens) {\n+        return new TemplateBody(Token.parse(tokens));\n+    }\n+\n+    \/**\n+     * Retrieves the dollar replacement of the {@code 'name'} for the\n+     * current {@link Template} that is being instanciated. It returns the same\n+     * dollar replacement as the string use {@code \"$name\"}.\n+     *\n+     * Here an example where a {@link Template} creates a local variable {@code 'var'},\n+     * with an implicit dollar replacement, and then captures that dollar replacement\n+     * using {@link #$} for the use inside a nested template.\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> body(\n+     *     \"\"\"\n+     *     int $var = 42;\n+     *     \"\"\",\n+     *     otherTemplate.withArgs($(\"var\"))\n+     * ));\n+     * }\n+     *\n+     * @param name The {@link String} name of the name.\n+     * @return The dollar replacement for the {@code 'name'}.\n+     *\/\n+    static String $(String name) {\n+        return Renderer.getCurrent().$(name);\n+    }\n+\n+    \/**\n+     * Define a hashtag replacement for {@code \"#key\"}, with a specific value.\n+     *\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", (Integer a) -> body(\n+     *     let(\"b\", a * 5),\n+     *     \"\"\"\n+     *     System.out.prinln(\"Use a and b with hashtag replacement: #a and #b\");\n+     *     \"\"\"\n+     * ));\n+     * }\n+     *\n+     * @param key Name for the hashtag replacement.\n+     * @param value The value that the hashtag is replaced with.\n+     * @return A token that does nothing, so that the {@link #let} cal can easily be put in a list of tokens\n+     *         inside a {@link Template#body}.\n+     * @throws RendererException if there is a duplicate hashtag {@code key}.\n+     *\/\n+    static Token let(String key, Object value) {\n+        Renderer.getCurrent().addHashtagReplacement(key, value);\n+        return new NothingToken();\n+    }\n+\n+    \/**\n+     * Define a hashtag replacement for {@code \"#key\"}, with a specific value, which is also captured\n+     * by the provided {@code 'function'} with type {@code <T>}.\n+     *\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", (Integer a) -> let(\"b\", a * 2, (Integer b) -> body(\n+     *     \"\"\"\n+     *     System.out.prinln(\"Use a and b with hashtag replacement: #a and #b\");\n+     *     \"\"\",\n+     *     \"System.out.println(\\\"Use a and b as capture variables:\\\" + a + \" and \" + b + \");\\n\"\n+     * )));\n+     * }\n+     *\n+     * @param key Name for the hashtag replacement.\n+     * @param value The value that the hashtag is replaced with.\n+     * @param <T> The type of the value.\n+     * @param function The function that is applied with the provided {@code 'value'}.\n+     * @return A token that does nothing, so that the {@link #let} cal can easily be put in a list of tokens\n+     *         inside a {@link Template#body}.\n+     * @throws RendererException if there is a duplicate hashtag {@code key}.\n+     *\/\n+    static <T> TemplateBody let(String key, T value, Function<T, TemplateBody> function) {\n+        Renderer.getCurrent().addHashtagReplacement(key, value);\n+        return function.apply(value);\n+    }\n+\n+    \/**\n+     * Default amount of fuel for {@link TemplateWithArgs#render}. It guides the nesting depth of {@link Template}s.\n+     *\/\n+    public final static float DEFAULT_FUEL = 100.0f;\n+\n+    \/**\n+     * The default amount of fuel spent per {@link Template}. It is suptracted from the current {@link #fuel} at every\n+     * nesting level, and once the {@link #fuel} reaches zero, the nesting is supposed to terminate.\n+     *\/\n+    public final static float DEFAULT_FUEL_COST = 10.0f;\n+\n+    \/**\n+     * The current remaining fuel for nested {@link Template}s. Every level of {@link Template} nestig\n+     * subtracts a certain amount of fuel, and when it reaches zero, {@link Template}s are supposed to\n+     * stop nesting, if possible. This is not a hard rule, but a guide, and a mechanism to ensure\n+     * termination in recursive {@link Template} instantiations.\n+     *\n+     * <p>\n+     * Example of a recursive {@link Template}, which checks the remaining {@link #fuel} at every level,\n+     * and terminates if it reaches zero. It also demonstrates the use of {@link TemplateBinding} for\n+     * the recursive use of {@link Template}s. We {@link TemplateWithArgs#render} with {@code 30} total fuel, and spending {@code 5} fuel at each recursion level.\n+     * {@snippet lang=java :\n+     * var binding = new TemplateBinding<Template.OneArgs<Integer>>();\n+     * var template = Template.make(\"depth\", (Integer depth) -> body(\n+     *     setFuelCost(5.0f),\n+     *     let(\"fuel\", fuel()),\n+     *     \"\"\"\n+     *     System.out.println(\"Currently at depth #depth with fuel #fuel\");\n+     *     \"\"\"\n+     *     (fuel() > 0) ? binding.get().withArgs(depth + 1)\n+     *                    \"\/\/ terminate\\n\"\n+     * ));\n+     * binding.bind(template);\n+     * String code = template.withArgs(0).render(30.0f);\n+     * }\n+     *\n+     * @return The amount of fuel left for nested {@link Template} use.\n+     *\/\n+    static float fuel() {\n+        return Renderer.getCurrent().fuel();\n+    }\n+\n+    \/**\n+     * Changes the amount of fuel used for the current {@link Template}, where the default is\n+     * {@link Template#DEFAULT_FUEL_COST}.\n+     *\n+     * @param fuelCost The amount of fuel used for the current {@link Template}.\n+     * @return A token for convenient use in {@link Template#body}.\n+     *\/\n+    static Token setFuelCost(float fuelCost) {\n+        Renderer.getCurrent().setFuelCost(fuelCost);\n+        return new NothingToken();\n+    }\n+\n+    \/**\n+     * Add a {@link Name} in the current code frame.\n+     * Note that there can be duplicate definitions, and they simply increase\n+     * the {@link #weighNames} weight, and increase the probability of sampling\n+     * the name with {@link #sampleName}.\n+     *\n+     * @param name The {@link Name} to be added to the current code frame.\n+     * @return The token that performs the defining action.\n+     *\/\n+    static Token addName(Name name) {\n+        return new AddNameToken(name);\n+    }\n+\n+    \/**\n+     * Weight the {@link Name}s for the specified {@link Name.Type}.\n+     *\n+     * @param type The type of the names to weigh.\n+     * @param onlyMutable Determines if we weigh the mutable names or all.\n+     * @return The weight of names for the specified parameters.\n+     *\/\n+    static long weighNames(Name.Type type, boolean onlyMutable) {\n+        return Renderer.getCurrent().weighNames(type, onlyMutable);\n+    }\n+\n+    \/**\n+     * Sample a random name for the specified type.\n+     *\n+     * @param type The type of the names to sample from.\n+     * @param onlyMutable Determines if we sample from the mutable names or all.\n+     * @return The sampled name.\n+     *\/\n+    static Name sampleName(Name.Type type, boolean onlyMutable) {\n+        return Renderer.getCurrent().sampleName(type, onlyMutable);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Template.java","additions":496,"deletions":0,"binary":false,"changes":496,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * To facilitate recursive uses of {@link Template}s, e.g. where a template uses\n+ * itself, where a template needs to be referenced before it is fully defined,\n+ * one can use the indirection of a {@link TemplateBinding}. The {@link TemplateBinding}\n+ * is allocated first without any {@link Template} bound to it yet. At this stage,\n+ * it can be used with {@link #get} inside a {@link Template}. Later, we can {@link #bind}\n+ * a {@link Template} to the binding, such that {@link #get} returns that bound\n+ * {@link Template}.\n+ *\n+ * @param <T> Type of the template.\n+ *\/\n+public class TemplateBinding<T extends Template> {\n+    private T template = null;\n+\n+    \/**\n+     * Creates a new {@link TemplateBinding} that has no {@link Template} bound to it yet.\n+     *\/\n+    public TemplateBinding() {}\n+\n+    \/**\n+     * Retrieve the {@link Template} that was previously bound to the binding.\n+     *\n+     * @return The {@link Template} that was previously bound with {@link #bind}.\n+     * @throws RendererException if no {@link Template} was bound yet.\n+     *\/\n+    public T get() {\n+        if (template == null) {\n+            throw new RendererException(\"Cannot 'get' before 'bind'.\");\n+        }\n+        return template;\n+    }\n+\n+\n+    \/**\n+     * Binds a {@link Template} for future reference using {@link #get}.\n+     *\n+     * @param template The {@link Template} to be bound.\n+     * @throws RendererException if a {@link Template} was already bound.\n+     *\/\n+    public void bind(T template) {\n+         if (this.template != null) {\n+            throw new RendererException(\"Duplicate 'bind' not allowed.\");\n+        }\n+        this.template = template;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateBinding.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * A {@link Template} generates a {@link TemplateBody}, which is a list of {@link Token}s,\n+ * which are then later rendered to {@link String}s.\n+ *\n+ * @param tokens The list of {@link Token}s that are later rendered to {@link String}s.\n+ *\/\n+public record TemplateBody(List<Token> tokens) {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateBody.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * The {@link TemplateFrame} is the frame for a {@link TemplateWithArgs}. It ensures\n+ * that each template use has its own unique {@link id} used to deconflict names\n+ * using {@link Template#$}. It also has a set of hashtag replacements, which combine the\n+ * key-value pairs from the template argument and the {@link Template#let} definitions.\n+ * The {@link parent} relationship provides a trace for the use chain of templates.\n+ * The {@link fuel} is reduced over this chain, to give a heuristic on how much time\n+ * is spend on the code from the template corrsponding to the frame, and to give a\n+ * termination criterion to avoid nesting templates too deeply.\n+ *\n+ * <p>\n+ * See also {@link CodeFrame} for more explanations about the frames.\n+ *\/\n+class TemplateFrame {\n+    final TemplateFrame parent;\n+    final int id;\n+    final Map<String, String> hashtagReplacements = new HashMap<>();\n+    final float fuel;\n+    float fuelCost;\n+\n+    public static TemplateFrame makeBase(int id, float fuel) {\n+        return new TemplateFrame(null, id, fuel, 0.0f);\n+    }\n+\n+    public static TemplateFrame make(TemplateFrame parent, int id) {\n+        return new TemplateFrame(parent, id, parent.fuel - parent.fuelCost, Template.DEFAULT_FUEL_COST);\n+    }\n+\n+    private TemplateFrame(TemplateFrame parent, int id, float fuel, float fuelCost) {\n+        this.parent = parent;\n+        this.id = id;\n+        this.fuel = fuel;\n+        this.fuelCost = fuelCost;\n+    }\n+\n+    public String $(String name) {\n+        return name + \"_\" + id;\n+    }\n+\n+    void addHashtagReplacement(String key, String value) {\n+        if (!hashtagReplacements.containsKey(key)) {\n+            hashtagReplacements.put(key, value);\n+            return;\n+        }\n+        throw new RendererException(\"Duplicate hashtag replacement for #\" + key);\n+    }\n+\n+    String getHashtagReplacement(String key) {\n+        if (hashtagReplacements.containsKey(key)) {\n+            return hashtagReplacements.get(key);\n+        }\n+        throw new RendererException(\"Missing hashtag replacement for #\" + key);\n+    }\n+\n+    void setFuelCost(float fuelCost) {\n+        this.fuelCost = fuelCost;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateFrame.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * Represents a {@link Template} with applied arguments, ready for instantiation, either\n+ * as a {@link Token} inside another {@link Template} or with {@link #render}.\n+ *\/\n+public sealed abstract class TemplateWithArgs implements Token\n+                                              permits TemplateWithArgs.ZeroArgsUse,\n+                                                      TemplateWithArgs.OneArgsUse,\n+                                                      TemplateWithArgs.TwoArgsUse,\n+                                                      TemplateWithArgs.ThreeArgsUse\n+{\n+    private TemplateWithArgs() {}\n+\n+    \/**\n+     * Represents a zero-argument {@link Template} with applied arguments, ready for instantiation\n+     * either as a {@link Token} inside another {@link Template} or with {@link #render}.\n+     *\/\n+    public static final class ZeroArgsUse extends TemplateWithArgs implements Token {\n+        private final Template.ZeroArgs zeroArgs;\n+\n+        ZeroArgsUse(Template.ZeroArgs zeroArgs) {\n+            this.zeroArgs = zeroArgs;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return zeroArgs.instantiate();\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {}\n+    }\n+\n+    \/**\n+     * Represents a one-argument {@link Template} with applied arguments, ready for instantiation\n+     * either as a {@link Token} inside another {@link Template} or with {@link #render}.\n+     *\n+     * @param <A> The type of the (first) argument.\n+     *\/\n+    public static final class OneArgsUse<A> extends TemplateWithArgs implements Token {\n+        private final Template.OneArgs<A> oneArgs;\n+        private final A a;\n+\n+        OneArgsUse(Template.OneArgs<A> oneArgs, A a) {\n+            this.oneArgs = oneArgs;\n+            this.a = a;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return oneArgs.instantiate(a);\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {\n+            visitor.visit(oneArgs.arg0Name(), a);\n+        }\n+    }\n+\n+    \/**\n+     * Represents a two-argument {@link Template} with applied arguments, ready for instantiation\n+     * either as a {@link Token} inside another {@link Template} or with {@link #render}.\n+     *\n+     * @param <A> The type of the first argument.\n+     * @param <B> The type of the second argument.\n+     *\/\n+    public static final class TwoArgsUse<A, B> extends TemplateWithArgs implements Token {\n+        private final Template.TwoArgs<A, B> twoArgs;\n+        private final A a;\n+        private final B b;\n+\n+        TwoArgsUse(Template.TwoArgs<A, B> twoArgs, A a, B b) {\n+            this.twoArgs = twoArgs;\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return twoArgs.instantiate(a, b);\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {\n+            visitor.visit(twoArgs.arg0Name(), a);\n+            visitor.visit(twoArgs.arg1Name(), b);\n+        }\n+    }\n+\n+    \/**\n+     * Represents a three-argument {@link Template} with applied arguments, ready for instantiation\n+     * either as a {@link Token} inside another {@link Template} or with {@link #render}.\n+     *\n+     * @param <A> The type of the first argument.\n+     * @param <B> The type of the second argument.\n+     * @param <C> The type of the second argument.\n+     *\/\n+    public static final class ThreeArgsUse<A, B, C> extends TemplateWithArgs implements Token {\n+        private final Template.ThreeArgs<A, B, C> threeArgs;\n+        private final A a;\n+        private final B b;\n+        private final C c;\n+\n+        ThreeArgsUse(Template.ThreeArgs<A, B, C> threeArgs, A a, B b, C c) {\n+            this.threeArgs = threeArgs;\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return threeArgs.instantiate(a, b, c);\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {\n+            visitor.visit(threeArgs.arg0Name(), a);\n+            visitor.visit(threeArgs.arg1Name(), b);\n+            visitor.visit(threeArgs.arg2Name(), c);\n+        }\n+    }\n+\n+    abstract TemplateBody instantiate();\n+\n+    @FunctionalInterface\n+    interface ArgumentVisitor {\n+        void visit(String name, Object value);\n+    }\n+\n+    abstract void visitArguments(ArgumentVisitor visitor);\n+\n+    \/**\n+     * Renders the {@link Template} with applied arguments to a {@link String}.\n+     *\n+     * @return The {@link Template} rendered to a {@link String}.\n+     *\/\n+    public final String render() {\n+        return Renderer.render(this);\n+    }\n+\n+    \/**\n+     * Renders the {@link Template} with applied arguments to a {@link String}.\n+     *\n+     * @param fuel The amount of fuel provided for recursive {@link Template} instantiations.\n+     * @return The {@link Template} rendered to a {@link String}.\n+     *\/\n+    public final String render(float fuel) {\n+        return Renderer.render(this, fuel);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateWithArgs.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * The {@link Template#body} and {@link Hook#set} are given a list of tokens, which are either\n+ * {@link Token}s or {@link String}s or some permitted boxed primitives. These are then parsed\n+ * and all non {@link Token}s are converted to {@link StringToken}s. The parsing also flattens\n+ * {@link List}s.\n+ *\/\n+sealed interface Token permits StringToken,\n+                               TemplateWithArgs,\n+                               TemplateWithArgs.ZeroArgsUse,\n+                               TemplateWithArgs.OneArgsUse,\n+                               TemplateWithArgs.TwoArgsUse,\n+                               TemplateWithArgs.ThreeArgsUse,\n+                               HookSetToken,\n+                               HookInsertToken,\n+                               AddNameToken,\n+                               NothingToken\n+{\n+    static List<Token> parse(Object[] objects) {\n+        if (objects == null) {\n+            throw new IllegalArgumentException(\"Unexpected tokens: null\");\n+        }\n+        List<Token> outputList = new ArrayList<Token>();\n+        parseToken(Arrays.asList(objects), outputList);\n+        return outputList;\n+    }\n+\n+    private static void parseList(List<Object> inputList, List<Token> outputList) {\n+        for (Object o : inputList) {\n+            parseToken(o, outputList);\n+        }\n+    }\n+\n+    private static void parseToken(Object o, List<Token> outputList) {\n+        if (o == null) {\n+            throw new IllegalArgumentException(\"Unexpected token: null\");\n+        }\n+        switch (o) {\n+            case Token t   -> outputList.add(t);\n+            case String s  -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Integer s -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Long s    -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Double s  -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Float s   -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Boolean s -> outputList.add(new StringToken(Renderer.format(s)));\n+            case List l    -> parseList(l, outputList);\n+            default -> throw new IllegalArgumentException(\"Unexpected token: \" + o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Token.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import compiler.lib.template_framework.Hook;\n+\n+\/**\n+ * Provides a hook for class and method scopes, to be used in Templates.\n+ *\/\n+public abstract class Hooks {\n+    private Hooks() {} \/\/ Avoid instanciation and need for documentation.\n+\n+    \/**\n+     * Template {@link Hook} used by the Template Library for class scopes, to insert\n+     * fields and methods.\n+     *\/\n+    public static final Hook CLASS_HOOK = new Hook(\"Class\");\n+\n+    \/**\n+     * Template {@link Hook} used by the Template Library for method scopes, to insert\n+     * local variables, and computations for local variables at the beginning of a\n+     * method.\n+     *\/\n+    public static final Hook METHOD_HOOK = new Hook(\"Method\");\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Hooks.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test simple use of Templates with the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.examples.TestSimple\n+ *\/\n+\n+package template_framework.examples;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import static compiler.lib.template_framework.Template.body;\n+\n+public class TestSimple {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate());\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ Object ret = p.xyz.InnterTest.test();\n+        Object ret = comp.invoke(\"p.xyz.InnerTest\", \"test\", new Object[] {});\n+        System.out.println(\"res: \" + ret);\n+\n+        \/\/ Check that the return value is the sum of the two arguments.\n+        if ((42 + 7) != (int)ret) {\n+            throw new RuntimeException(\"Unexpected result\");\n+        }\n+    }\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate() {\n+        \/\/ Create a Template with two arguments.\n+        var template = Template.make(\"arg1\", \"arg2\", (Integer arg1, String arg2) -> body(\n+            \"\"\"\n+            package p.xyz;\n+            public class InnerTest {\n+                public static int test() {\n+                    return #arg1 + #arg2;\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Use the template with two arguments, and render it to a String.\n+        return template.withArgs(42, \"7\").render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestSimple.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,539 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Demonstrate the use of Templates with the Compile Framework.\n+ *          It displays the use of most features in the Template Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.examples.TestTutorial\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import compiler.lib.compile_framework.*;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.Hook;\n+import compiler.lib.template_framework.TemplateBinding;\n+import compiler.lib.template_framework.Name;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.$;\n+import static compiler.lib.template_framework.Template.fuel;\n+import static compiler.lib.template_framework.Template.addName;\n+import static compiler.lib.template_framework.Template.sampleName;\n+import static compiler.lib.template_framework.Template.weighNames;\n+\n+import compiler.lib.template_framework.library.Hooks;\n+\n+public class TestTutorial {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add java source files.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest1\", generateWithListOfTokens());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest2\", generateWithTemplateArguments());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest3\", generateWithHashtagAndDollarReplacements());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest4\", generateWithCustomHooks());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest5\", generateWithLibraryHooks());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest6\", generateWithRecursionAndBindingsAndFuel());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest7\", generateWithNames());\n+\n+        \/\/ Compile the source files.\n+        comp.compile();\n+\n+        \/\/ Object ret = p.xyz.InnterTest1.main();\n+        comp.invoke(\"p.xyz.InnerTest1\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest2\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest3\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest4\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest5\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest6\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest7\", \"main\", new Object[] {});\n+    }\n+\n+    \/\/ This example shows the use of various Tokens.\n+    public static String generateWithListOfTokens() {\n+        \/\/ A Template is essencially a function \/ lambda that produces a\n+        \/\/ token body, which is a list of Tokens that are concatenated.\n+        var templateClass = Template.make(() -> body(\n+            \/\/ The \"body\" method is filled by a sequence of \"Tokens\".\n+            \/\/ This can be Strings and multi-line Strings, but also\n+            \/\/ boxed primitives.\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest1 {\n+                public static void main() {\n+                    System.out.println(\"Hello World!\");\n+            \"\"\",\n+            \"int a = \", Integer.valueOf(1), \";\\n\",\n+            \"float b = \", Float.valueOf(1.5f), \";\\n\",\n+            \/\/ Special Float values are \"smartly\" formatted!\n+            \"float nan = \", Float.valueOf(Float.POSITIVE_INFINITY), \";\\n\",\n+            \"boolean c = \", Boolean.valueOf(true), \";\\n\",\n+            \/\/ Lists of Tokens are also allowed:\n+            List.of(\"int \", \"d = 5\", \";\\n\"),\n+            \/\/ That can be great for streaming \/ mapping over an existing list:\n+            List.of(3, 5, 7, 11).stream().map(i -> \"System.out.println(\" + i + \");\\n\").toList(),\n+            \"\"\"\n+                    System.out.println(a + \" \" + b + \" \" + nan + \" \" + c + \" \" + d);\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ This example shows the use of Templates, with and without arguments.\n+    public static String generateWithTemplateArguments() {\n+        \/\/ A Template with no arguments.\n+        var templateHello = Template.make(() -> body(\n+            \"\"\"\n+            System.out.println(\"Hello\");\n+            \"\"\"\n+        ));\n+\n+        \/\/ A Template with a single Integer argument.\n+        var templateCompare = Template.make(\"arg\", (Integer arg) -> body(\n+            \"System.out.println(\", arg, \");\\n\",  \/\/ capture arg via lambda argument\n+            \"System.out.println(#arg);\\n\",       \/\/ capture arg via hashtag replacement\n+            \"if (#arg != \", arg, \") { throw new RuntimeException(\\\"mismatch\\\"); }\\n\"\n+        ));\n+\n+        \/\/ A Template that creates the body of the Class and main method, and then\n+        \/\/ uses the two Templates above inside it.\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest2 {\n+                public static void main() {\n+            \"\"\",\n+                    templateHello.withArgs(),\n+                    templateCompare.withArgs(7),\n+                    templateCompare.withArgs(42),\n+            \"\"\"\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ Example with hashtag replacements (arguments and let), and $-name renamings.\n+    \/\/ Note: hashtag replacements are a workaround for the missing string templates.\n+    \/\/       If we had string templates, we could just capture the typed lambda\n+    \/\/       arguments, and use them directly in the String via string templating.\n+    public static String generateWithHashtagAndDollarReplacements() {\n+        var template1 = Template.make(\"x\", (Integer x) -> body(\n+            \/\/ We have the \"#x\" hashtag replacement from the argument capture above.\n+            \/\/ Additionally, we can define \"#con\" as a hashtag replacement from let:\n+            let(\"con\", 3 * x),\n+            \/\/ In the code below, we use \"var\" as a local variable. But if we were\n+            \/\/ to instantiate this template twice, the names could conflict. Hence,\n+            \/\/ we automatically rename the names that have a $ prepended.\n+            \"\"\"\n+            int $var = #con;\n+            System.out.println(\"T1: #x, #con, \" + $var);\n+            \"\"\"\n+        ));\n+\n+        var template2 = Template.make(\"x\", (Integer x) ->\n+            \/\/ Sometimes it can be helpful to not just create a hashtag replacement\n+            \/\/ with let, but also to capture the variable.\n+            let(\"y\", 11 * x, y ->\n+                body(\n+                    \"\"\"\n+                    System.out.println(\"T2: #x, #y\");\n+                    \"\"\",\n+                    template1.withArgs(y)\n+                )\n+            )\n+        );\n+\n+        \/\/ This template generates an int variable and assigns it a value.\n+        \/\/ Together with template4, we see that each template has a unique renaming\n+        \/\/ for a $-name replacement.\n+        var template3 = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            int #name = #value; \/\/ Note: $var is not #name\n+            \"\"\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"\"\"\n+            \/\/ We will define the variable $var:\n+            \"\"\",\n+            \/\/ We can capture the $-name programmatically, and pass it to other templates:\n+            template3.withArgs($(\"var\"), 42),\n+            \"\"\"\n+            if ($var != 42) { throw new RuntimeException(\"Wrong value!\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest3 {\n+                public static void main() {\n+            \"\"\",\n+                    template1.withArgs(1),\n+                    template1.withArgs(7),\n+                    template2.withArgs(2),\n+                    template2.withArgs(5),\n+                    template4.withArgs(),\n+            \"\"\"\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ In this example, we look at the use of Hooks.\n+    public static String generateWithCustomHooks() {\n+        \/\/ We can define a custom hook.\n+        \/\/ Note: generally we prefer using the pre-defined CLASS_HOOK and METHOD_HOOK from the library,\n+        \/\/       when ever possible. See also the example after this one.\n+        var myHook = new Hook(\"MyHook\");\n+\n+        var template1 = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            public static int #name = #value;\n+            \"\"\"\n+        ));\n+\n+        var template2 = Template.make(\"x\", (Integer x) -> body(\n+            \"\"\"\n+            \/\/ Let us go back to the hook, and define a field named $field...\n+            \"\"\",\n+            myHook.insert(template1.withArgs($(\"field\"), x)),\n+            \"\"\"\n+            System.out.println(\"$field: \" + $field);\n+            if ($field != #x) { throw new RuntimeException(\"Wrong value!\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest4 {\n+            \"\"\",\n+            \/\/ We set a Hook outside the main method, but inside the Class.\n+            \/\/ The Hook is set for the Tokens inside the set braces.\n+            \/\/ As long as the hook is set, we can insert code into the hook,\n+            \/\/ here we can define static fields for example.\n+            myHook.set(\n+                \"\"\"\n+                public static void main() {\n+                \"\"\",\n+                    template2.withArgs(5),\n+                    template2.withArgs(7),\n+                \"\"\"\n+                }\n+                \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ We saw the use of custom hooks above, but now we look at the use of CLASS_HOOK and METHOD_HOOK\n+    \/\/ from the Temlate Library.\n+    public static String generateWithLibraryHooks() {\n+        var templateStaticField = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            static { System.out.println(\"Defining static field #name\"); }\n+            public static int #name = #value;\n+            \"\"\"\n+        ));\n+\n+        var templateLocalVariable = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            System.out.println(\"Defining local variable #name\");\n+            int #name = #value;\n+            \"\"\"\n+        ));\n+\n+        var templateMethodBody = Template.make(() -> body(\n+            \"\"\"\n+            \/\/ Let's define a local variable $var and a static field $field.\n+            \"\"\",\n+            Hooks.CLASS_HOOK.insert(templateStaticField.withArgs($(\"field\"), 5)),\n+            Hooks.METHOD_HOOK.insert(templateLocalVariable.withArgs($(\"var\"), 11)),\n+            \"\"\"\n+            System.out.println(\"$field: \" + $field);\n+            System.out.println(\"$var: \" + $var);\n+            if ($field * $var != 55) { throw new RuntimeException(\"Wrong value!\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest5 {\n+            \"\"\",\n+            \/\/ Class Hook for fields.\n+            Hooks.CLASS_HOOK.set(\n+                \"\"\"\n+                public static void main() {\n+                \"\"\",\n+                \/\/ Method Hook for local variables, and earlier computations.\n+                Hooks.METHOD_HOOK.set(\n+                    \"\"\"\n+                    \/\/ This is the beginning of the \"main\" method body.\n+                    System.out.println(\"Welcome to main!\");\n+                    \"\"\",\n+                    templateMethodBody.withArgs(),\n+                    \"\"\"\n+                    System.out.println(\"Going to call other...\");\n+                    other();\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+\n+                private static void other() {\n+                \"\"\",\n+                \/\/ Have a separate method hook for other, so that it can insert\n+                \/\/ its own local variables.\n+                Hooks.METHOD_HOOK.set(\n+                    \"\"\"\n+                    System.out.println(\"Welcome to other!\");\n+                    \"\"\",\n+                    templateMethodBody.withArgs(),\n+                    \"\"\"\n+                    System.out.println(\"Done with other.\");\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+                \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ This example shows the use of bindings to allow cyclic references of Templates,\n+    \/\/ allowing recursive template generation. We also show the use of fuel to limit\n+    \/\/ recursion.\n+    public static String generateWithRecursionAndBindingsAndFuel() {\n+        \/\/ Binding allows the use of template1 inside of template1, via the binding indirection.\n+        var binding1 = new TemplateBinding<Template.OneArgs<Integer>>();\n+        var template1 = Template.make(\"depth\", (Integer depth) -> body(\n+            let(\"fuel\", fuel()),\n+            \"\"\"\n+            System.out.println(\"At depth #depth with fuel #fuel.\");\n+            \"\"\",\n+            \/\/ We cannot yet use template1 directly, as it is being defined.\n+            \/\/ So we use binding1 instead.\n+            \/\/ For every recursion depth, some fuel is automatically subtracted\n+            \/\/ so that the fuel slowly depletes with the depth.\n+            \/\/ We keep the recursion going until the fuel is depleted.\n+            (fuel() > 0) ? binding1.get().withArgs(depth + 1)\n+                        : \"System.out.println(\\\"Fuel depleted.\\\");\\n\",\n+            \"\"\"\n+            System.out.println(\"Exit depth #depth.\");\n+            \"\"\"\n+        ));\n+        binding1.bind(template1);\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest6 {\n+                public static void main() {\n+                    System.out.println(\"Welcome to main!\");\n+                    \"\"\",\n+                    template1.withArgs(0),\n+                    \"\"\"\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+\n+    \/\/ In the example below (\"generateWithNames\"), we see the use of Names to add\n+    \/\/ variables and fields to code scopes, and then sample from those variables\n+    \/\/ and fields. Every Name has a Name.Type, which we now define for int and long.\n+    private record MyPrimitive(String name) implements Name.Type {\n+        @Override\n+        public boolean isSubtypeOf(Name.Type other) {\n+            return other instanceof MyPrimitive(String n) && n == name();\n+        }\n+\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyPrimitive myInt = new MyPrimitive(\"int\");\n+    private static final MyPrimitive myLong = new MyPrimitive(\"long\");\n+\n+    \/\/ Example with names, i.e. addName, weighNames, and sampleName.\n+    \/\/ These can be used to add variables and fields to code scopes, and then sample\n+    \/\/ from the available variables and fields later.\n+    public static String generateWithNames() {\n+        var templateSample = Template.make(\"type\", (Name.Type type) -> body(\n+            let(\"name\", sampleName(type, false).name()),\n+            \"\"\"\n+            System.out.println(\"Sampling type #type: #name = \" + #name);\n+            \"\"\"\n+        ));\n+\n+        var templateStaticField = Template.make(\"type\", (Name.Type type) -> body(\n+            addName(new Name($(\"field\"), type, true, 1)),\n+            \"\"\"\n+            public static #type $field = 0;\n+            \"\"\"\n+        ));\n+\n+        var templateLocalVariable = Template.make(\"type\", (Name.Type type) -> body(\n+            addName(new Name($(\"var\"), type, true, 1)),\n+            \"\"\"\n+            #type $var = 0;\n+            \"\"\"\n+        ));\n+\n+        var templateStatus = Template.make(() -> body(\n+            let(\"ints\", weighNames(myInt, false)),\n+            let(\"longs\", weighNames(myLong, false)),\n+            \"\"\"\n+            System.out.println(\"Status: #ints ints, #longs longs.\");\n+            \"\"\"\n+        ));\n+\n+        var templateMain = Template.make(() -> body(\n+            \"\"\"\n+            System.out.println(\"Starting inside main...\");\n+            \"\"\",\n+            templateStatus.withArgs(),\n+            Hooks.METHOD_HOOK.insert(templateLocalVariable.withArgs(myInt)),\n+            Hooks.METHOD_HOOK.insert(templateLocalVariable.withArgs(myLong)),\n+            Hooks.CLASS_HOOK.insert(templateStaticField.withArgs(myInt)),\n+            Hooks.CLASS_HOOK.insert(templateStaticField.withArgs(myLong)),\n+            templateStatus.withArgs(),\n+            \/\/ We should see a mix if fields and variables sampled.\n+            Collections.nCopies(5, templateSample.withArgs(myInt)),\n+            Collections.nCopies(5, templateSample.withArgs(myLong)),\n+            templateStatus.withArgs(),\n+            \"\"\"\n+            System.out.println(\"Finishing inside main.\");\n+            \"\"\"\n+        ));\n+\n+        var templateOther = Template.make(() -> body(\n+            \"\"\"\n+            System.out.println(\"Starting inside other...\");\n+            \"\"\",\n+            templateStatus.withArgs(),\n+            \/\/ We still have all the field definitions from main.\n+            Collections.nCopies(5, templateSample.withArgs(myInt)),\n+            Collections.nCopies(5, templateSample.withArgs(myLong)),\n+            templateStatus.withArgs(),\n+            \"\"\"\n+            System.out.println(\"Finishing inside other.\");\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest7 {\n+            \"\"\",\n+            \/\/ Class Hook for fields.\n+            Hooks.CLASS_HOOK.set(\n+                \"\"\"\n+                public static void main() {\n+                \"\"\",\n+                \/\/ Method Hook for local variables, and earlier computations.\n+                Hooks.METHOD_HOOK.set(\n+                    \"\"\"\n+                    \/\/ This is the beginning of the \"main\" method body.\n+                    System.out.println(\"Welcome to main!\");\n+                    \"\"\",\n+                    templateMain.withArgs(),\n+                    \"\"\"\n+                    System.out.println(\"Going to call other...\");\n+                    other();\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+\n+                private static void other() {\n+                \"\"\",\n+                \/\/ Have a separate method hook for other, so that it can insert\n+                \/\/ its own local variables.\n+                Hooks.METHOD_HOOK.set(\n+                    \"\"\"\n+                    System.out.println(\"Welcome to other!\");\n+                    \"\"\",\n+                    templateOther.withArgs(),\n+                    \"\"\"\n+                    System.out.println(\"Done with other.\");\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+                \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.withArgs().render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":539,"deletions":0,"binary":false,"changes":539,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test formatting of Integer, Long, Float and Double.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.tests.TestFormat\n+ *\/\n+\n+package template_framework.tests;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.generators.*;\n+import compiler.lib.verify.*;\n+import compiler.lib.template_framework.Template;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+public class TestFormat {\n+    record FormatInfo(int id, String type, Object value) {}\n+\n+    public static void main(String[] args) {\n+        List<FormatInfo> list = new ArrayList();\n+\n+        for (int i = 0; i < 1000; i++) {\n+            int v = Generators.G.ints().next();\n+            list.add(new FormatInfo(i, \"int\", v));\n+        }\n+\n+        for (int i = 1000; i < 2000; i++) {\n+            long v = Generators.G.longs().next();\n+            list.add(new FormatInfo(i, \"long\", v));\n+        }\n+\n+        for (int i = 2000; i < 3000; i++) {\n+            float v = Generators.G.floats().next();\n+            list.add(new FormatInfo(i, \"float\", v));\n+        }\n+\n+        for (int i = 3000; i < 4000; i++) {\n+            double v = Generators.G.doubles().next();\n+            list.add(new FormatInfo(i, \"double\", v));\n+        }\n+\n+        CompileFramework comp = new CompileFramework();\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(list));\n+        comp.compile();\n+\n+        \/\/ Run each of the \"get\" methods, and check the result.\n+        for (FormatInfo info : list) {\n+            Object ret1 = comp.invoke(\"p.xyz.InnerTest\", \"get_let_\" + info.id, new Object[] {});\n+            Object ret2 = comp.invoke(\"p.xyz.InnerTest\", \"get_token_\" + info.id, new Object[] {});\n+            System.out.println(\"id: \" + info.id + \" -> \" + info.value + \" == \" + ret1 + \" == \" + ret2);\n+            Verify.checkEQ(ret1, info.value);\n+            Verify.checkEQ(ret2, info.value);\n+        }\n+    }\n+\n+    private static String generate(List<FormatInfo> list) {\n+        \/\/ Generate 2 \"get\" methods, one that formats via \"let\" (hashtag), the other via direct token.\n+        var template1 = Template.make(\"info\", (FormatInfo info) -> body(\n+            let(\"id\", info.id()),\n+            let(\"type\", info.type()),\n+            let(\"value\", info.value()),\n+            \"\"\"\n+            public static #type get_let_#id() { return #value; }\n+            \"\"\",\n+            \"public static #type get_token_#id() { return \", info.value(), \"; }\\n\"\n+        ));\n+\n+        \/\/ For each FormatInfo in list, generate the \"get\" methods inside InnerTest class.\n+        var template2 = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+            public class InnerTest {\n+            \"\"\",\n+            list.stream().map(info -> template1.withArgs(info)).toList(),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        return template2.withArgs().render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestFormat.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,1267 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test some basic Template instantiations. We do not necessarily generate correct\n+ *          java code, we just test that the code generation deterministically creates the\n+ *          expected String.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.tests.TestTemplate\n+ *\/\n+\n+package template_framework.tests;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.HashSet;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.Name;\n+import compiler.lib.template_framework.Hook;\n+import compiler.lib.template_framework.TemplateBinding;\n+import compiler.lib.template_framework.RendererException;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.$;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.fuel;\n+import static compiler.lib.template_framework.Template.setFuelCost;\n+import static compiler.lib.template_framework.Template.addName;\n+import static compiler.lib.template_framework.Template.weighNames;\n+import static compiler.lib.template_framework.Template.sampleName;\n+\n+public class TestTemplate {\n+    interface FailingTest {\n+        void run();\n+    }\n+\n+    private record MyPrimitive(String name) implements Name.Type {\n+        @Override\n+        public boolean isSubtypeOf(Name.Type other) {\n+            return other instanceof MyPrimitive(String n) && n == name();\n+        }\n+\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyPrimitive myInt = new MyPrimitive(\"int\");\n+    private static final MyPrimitive myLong = new MyPrimitive(\"long\");\n+\n+    public static void main(String[] args) {\n+        testSingleLine();\n+        testMultiLine();\n+        testBodyTokens();\n+        testWithOneArguments();\n+        testWithTwoArguments();\n+        testWithThreeArguments();\n+        testNested();\n+        testHookSimple();\n+        testHookIsSet();\n+        testHookNested();\n+        testHookWithNestedTemplates();\n+        testHookRecursion();\n+        testDollar();\n+        testLet();\n+        testSelector();\n+        testRecursion();\n+        testFuel();\n+        testFuelCustom();\n+        testNames();\n+        testNames2();\n+        testNames3();\n+        testListArgument();\n+\n+        expectRendererException(() -> testFailingNestedRendering(), \"Nested render not allowed.\");\n+        expectRendererException(() -> $(\"name\"),                          \"A Template method such as\");\n+        expectRendererException(() -> let(\"x\",\"y\"),                       \"A Template method such as\");\n+        expectRendererException(() -> fuel(),                             \"A Template method such as\");\n+        expectRendererException(() -> setFuelCost(1.0f),                  \"A Template method such as\");\n+        expectRendererException(() -> weighNames(myInt, true),            \"A Template method such as\");\n+        expectRendererException(() -> sampleName(myInt, true),            \"A Template method such as\");\n+        expectRendererException(() -> (new Hook(\"abc\")).isSet(),          \"A Template method such as\");\n+        expectRendererException(() -> testFailingHook(), \"Hook 'Hook1' was referenced but not found!\");\n+        expectRendererException(() -> testFailingSample(), \"No variable of type 'int'.\");\n+        expectRendererException(() -> testFailingHashtag1(), \"Duplicate hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingHashtag2(), \"Duplicate hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingHashtag3(), \"Duplicate hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingHashtag4(), \"Missing hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingBinding1(), \"Duplicate 'bind' not allowed.\");\n+        expectRendererException(() -> testFailingBinding2(), \"Cannot 'get' before 'bind'.\");\n+        expectIllegalArgumentException(() -> body(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> body(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> body(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        Hook hook1 = new Hook(\"Hook1\");\n+        expectIllegalArgumentException(() -> hook1.set(null),         \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> hook1.set(\"x\", null),    \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> hook1.set(hook1),        \"Unexpected token:\");\n+    }\n+\n+    public static void testSingleLine() {\n+        var template = Template.make(() -> body(\"Hello World!\"));\n+        String code = template.withArgs().render();\n+        checkEQ(code, \"Hello World!\");\n+    }\n+\n+    public static void testMultiLine() {\n+        var template = Template.make(() -> body(\n+            \"\"\"\n+            Code on more\n+            than a single line\n+            \"\"\"\n+        ));\n+        String code = template.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            Code on more\n+            than a single line\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testBodyTokens() {\n+        \/\/ We can fill the body with Objects of different types, and they get concatenated.\n+        \/\/ Lists get flattened into the body.\n+        var template = Template.make(() -> body(\n+            \"start \",\n+            Integer.valueOf(1),\n+            Long.valueOf(2),\n+            Double.valueOf(3.4),\n+            Float.valueOf(5.6f),\n+            List.of(\" \", 1, \" and \", 2),\n+            \" end\"\n+        ));\n+        String code = template.withArgs().render();\n+        checkEQ(code, \"start 12L3.45.6f 1 and 2 end\");\n+    }\n+\n+    public static void testWithOneArguments() {\n+        \/\/ Capture String argument via String name.\n+        var template1 = Template.make(\"a\", (String a) -> body(\"start #a end\"));\n+        checkEQ(template1.withArgs(\"x\").render(), \"start x end\");\n+        checkEQ(template1.withArgs(\"a\").render(), \"start a end\");\n+        checkEQ(template1.withArgs(\"\" ).render(), \"start  end\");\n+\n+        \/\/ Capture String argument via typed lambda argument.\n+        var template2 = Template.make(\"a\", (String a) -> body(\"start \", a, \" end\"));\n+        checkEQ(template2.withArgs(\"x\").render(), \"start x end\");\n+        checkEQ(template2.withArgs(\"a\").render(), \"start a end\");\n+        checkEQ(template2.withArgs(\"\" ).render(), \"start  end\");\n+\n+        \/\/ Capture Integer argument via String name.\n+        var template3 = Template.make(\"a\", (Integer a) -> body(\"start #a end\"));\n+        checkEQ(template3.withArgs(0  ).render(), \"start 0 end\");\n+        checkEQ(template3.withArgs(22 ).render(), \"start 22 end\");\n+        checkEQ(template3.withArgs(444).render(), \"start 444 end\");\n+\n+        \/\/ Capture Integer argument via templated lambda argument.\n+        var template4 = Template.make(\"a\", (Integer a) -> body(\"start \", a, \" end\"));\n+        checkEQ(template4.withArgs(0  ).render(), \"start 0 end\");\n+        checkEQ(template4.withArgs(22 ).render(), \"start 22 end\");\n+        checkEQ(template4.withArgs(444).render(), \"start 444 end\");\n+\n+        \/\/ Test Strings with backslashes:\n+        var template5 = Template.make(\"a\", (String a) -> body(\"start #a \" + a + \" end\"));\n+        checkEQ(template5.withArgs(\"\/\").render(), \"start \/ \/ end\");\n+        checkEQ(template5.withArgs(\"\\\\\").render(), \"start \\\\ \\\\ end\");\n+        checkEQ(template5.withArgs(\"\\\\\\\\\").render(), \"start \\\\\\\\ \\\\\\\\ end\");\n+    }\n+\n+    public static void testWithTwoArguments() {\n+        \/\/ Capture 2 String arguments via String names.\n+        var template1 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\"start #a1 #a2 end\"));\n+        checkEQ(template1.withArgs(\"x\", \"y\").render(), \"start x y end\");\n+        checkEQ(template1.withArgs(\"a\", \"b\").render(), \"start a b end\");\n+        checkEQ(template1.withArgs(\"\",  \"\" ).render(), \"start   end\");\n+\n+        \/\/ Capture 2 String arguments via typed lambda arguments.\n+        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\"start \", a1, \" \", a2, \" end\"));\n+        checkEQ(template2.withArgs(\"x\", \"y\").render(), \"start x y end\");\n+        checkEQ(template2.withArgs(\"a\", \"b\").render(), \"start a b end\");\n+        checkEQ(template2.withArgs(\"\",  \"\" ).render(), \"start   end\");\n+\n+        \/\/ Capture 2 Integer arguments via String names.\n+        var template3 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> body(\"start #a1 #a2 end\"));\n+        checkEQ(template3.withArgs(0,   1  ).render(), \"start 0 1 end\");\n+        checkEQ(template3.withArgs(22,  33 ).render(), \"start 22 33 end\");\n+        checkEQ(template3.withArgs(444, 555).render(), \"start 444 555 end\");\n+\n+        \/\/ Capture 2 Integer arguments via templated lambda arguments.\n+        var template4 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> body(\"start \", a1, \" \", a2, \" end\"));\n+        checkEQ(template4.withArgs(0,   1  ).render(), \"start 0 1 end\");\n+        checkEQ(template4.withArgs(22,  33 ).render(), \"start 22 33 end\");\n+        checkEQ(template4.withArgs(444, 555).render(), \"start 444 555 end\");\n+    }\n+\n+    public static void testWithThreeArguments() {\n+        \/\/ Capture 3 String arguments via String names.\n+        var template1 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> body(\"start #a1 #a2 #a3 end\"));\n+        checkEQ(template1.withArgs(\"x\", \"y\", \"z\").render(), \"start x y z end\");\n+        checkEQ(template1.withArgs(\"a\", \"b\", \"c\").render(), \"start a b c end\");\n+        checkEQ(template1.withArgs(\"\",  \"\", \"\" ).render(),  \"start    end\");\n+\n+        \/\/ Capture 3 String arguments via typed lambda arguments.\n+        var template2 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> body(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n+        checkEQ(template1.withArgs(\"x\", \"y\", \"z\").render(), \"start x y z end\");\n+        checkEQ(template1.withArgs(\"a\", \"b\", \"c\").render(), \"start a b c end\");\n+        checkEQ(template1.withArgs(\"\",  \"\", \"\" ).render(),  \"start    end\");\n+\n+        \/\/ Capture 3 Integer arguments via String names.\n+        var template3 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> body(\"start #a1 #a2 #a3 end\"));\n+        checkEQ(template3.withArgs(0,   1  , 2  ).render(), \"start 0 1 2 end\");\n+        checkEQ(template3.withArgs(22,  33 , 44 ).render(), \"start 22 33 44 end\");\n+        checkEQ(template3.withArgs(444, 555, 666).render(), \"start 444 555 666 end\");\n+\n+        \/\/ Capture 2 Integer arguments via templated lambda arguments.\n+        var template4 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> body(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n+        checkEQ(template3.withArgs(0,   1  , 2  ).render(), \"start 0 1 2 end\");\n+        checkEQ(template3.withArgs(22,  33 , 44 ).render(), \"start 22 33 44 end\");\n+        checkEQ(template3.withArgs(444, 555, 666).render(), \"start 444 555 666 end\");\n+    }\n+\n+    public static void testNested() {\n+        var template1 = Template.make(() -> body(\"proton\"));\n+\n+        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\n+            \"electron #a1\\n\",\n+            \"neutron #a2\\n\"\n+        ));\n+\n+        var template3 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\n+            \"Universe \", template1.withArgs(), \" {\\n\",\n+                template2.withArgs(\"up\", \"down\"),\n+                template2.withArgs(a1, a2),\n+            \"}\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            template3.withArgs(\"low\", \"high\"),\n+            \"{\\n\",\n+                template3.withArgs(\"42\", \"24\"),\n+            \"}\"\n+        ));\n+\n+        String code = template4.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            Universe proton {\n+            electron up\n+            neutron down\n+            electron low\n+            neutron high\n+            }\n+            {\n+            Universe proton {\n+            electron up\n+            neutron down\n+            electron 42\n+            neutron 24\n+            }\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookSimple() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\"Hello\\n\"));\n+\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            hook1.set(\n+                \"World\\n\",\n+                hook1.insert(template1.withArgs())\n+            ),\n+            \"}\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            Hello\n+            World\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookIsSet() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template0 = Template.make(() -> body(\"isSet: \", hook1.isSet(), \"\\n\"));\n+\n+        var template1 = Template.make(() -> body(\"Hello\\n\", template0.withArgs()));\n+\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            template0.withArgs(),\n+            hook1.set(\n+                \"World\\n\",\n+                template0.withArgs(),\n+                hook1.insert(template1.withArgs())\n+            ),\n+            template0.withArgs(),\n+            \"}\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            isSet: false\n+            Hello\n+            isSet: true\n+            World\n+            isSet: true\n+            isSet: false\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookNested() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+\n+        \/\/ Test nested use of hooks in the same template.\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            hook1.set(), \/\/ empty\n+            \"zero\\n\",\n+            hook1.set(\n+                template1.withArgs(\"one\"),\n+                template1.withArgs(\"two\"),\n+                hook1.insert(template1.withArgs(\"intoHook1a\")),\n+                hook1.insert(template1.withArgs(\"intoHook1b\")),\n+                template1.withArgs(\"three\"),\n+                hook1.set(\n+                    template1.withArgs(\"four\"),\n+                    hook1.insert(template1.withArgs(\"intoHook1c\")),\n+                    template1.withArgs(\"five\")\n+                ),\n+                template1.withArgs(\"six\"),\n+                hook1.set(), \/\/ empty\n+                template1.withArgs(\"seven\"),\n+                hook1.insert(template1.withArgs(\"intoHook1d\")),\n+                template1.withArgs(\"eight\"),\n+                hook1.set(\n+                    template1.withArgs(\"nine\"),\n+                    hook1.insert(template1.withArgs(\"intoHook1e\")),\n+                    template1.withArgs(\"ten\")\n+                ),\n+                template1.withArgs(\"eleven\")\n+            ),\n+            \"}\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            zero\n+            x intoHook1a x\n+            x intoHook1b x\n+            x intoHook1d x\n+            x one x\n+            x two x\n+            x three x\n+            x intoHook1c x\n+            x four x\n+            x five x\n+            x six x\n+            x seven x\n+            x eight x\n+            x intoHook1e x\n+            x nine x\n+            x ten x\n+            x eleven x\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookWithNestedTemplates() {\n+        var hook1 = new Hook(\"Hook1\");\n+        var hook2 = new Hook(\"Hook2\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+\n+        var template2 = Template.make(\"b\", (String b) -> body(\n+            \"{\\n\",\n+            template1.withArgs(b + \"A\"),\n+            hook1.insert(template1.withArgs(b + \"B\")),\n+            hook2.insert(template1.withArgs(b + \"C\")),\n+            template1.withArgs(b + \"D\"),\n+            hook1.set(\n+                template1.withArgs(b + \"E\"),\n+                hook1.insert(template1.withArgs(b + \"F\")),\n+                hook2.insert(template1.withArgs(b + \"G\")),\n+                template1.withArgs(b + \"H\"),\n+                hook2.set(\n+                    template1.withArgs(b + \"I\"),\n+                    hook1.insert(template1.withArgs(b + \"J\")),\n+                    hook2.insert(template1.withArgs(b + \"K\")),\n+                    template1.withArgs(b + \"L\")\n+                ),\n+                template1.withArgs(b + \"M\"),\n+                hook1.insert(template1.withArgs(b + \"N\")),\n+                hook2.insert(template1.withArgs(b + \"O\")),\n+                template1.withArgs(b + \"O\")\n+            ),\n+            template1.withArgs(b + \"P\"),\n+            hook1.insert(template1.withArgs(b + \"Q\")),\n+            hook2.insert(template1.withArgs(b + \"R\")),\n+            template1.withArgs(b + \"S\"),\n+            \"}\\n\"\n+        ));\n+\n+        \/\/ Test use of hooks across templates.\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            \"base-A\\n\",\n+            hook1.set(\n+                \"base-B\\n\",\n+                hook2.set(\n+                    \"base-C\\n\",\n+                    template2.withArgs(\"sub-\"),\n+                    \"base-D\\n\"\n+                ),\n+                \"base-E\\n\"\n+            ),\n+            \"base-F\\n\",\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            base-A\n+            x sub-B x\n+            x sub-Q x\n+            base-B\n+            x sub-C x\n+            x sub-G x\n+            x sub-O x\n+            x sub-R x\n+            base-C\n+            {\n+            x sub-A x\n+            x sub-D x\n+            x sub-F x\n+            x sub-J x\n+            x sub-N x\n+            x sub-E x\n+            x sub-H x\n+            x sub-K x\n+            x sub-I x\n+            x sub-L x\n+            x sub-M x\n+            x sub-O x\n+            x sub-P x\n+            x sub-S x\n+            }\n+            base-D\n+            base-E\n+            base-F\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookRecursion() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+\n+        var template2 = Template.make(\"b\", (String b) -> body(\n+            \"<\\n\",\n+            template1.withArgs(b + \"A\"),\n+            hook1.insert(template1.withArgs(b + \"B\")), \/\/ sub-B is rendered before template2.\n+            template1.withArgs(b + \"C\"),\n+            \"inner-hook-start\\n\",\n+            hook1.set(\n+                \"inner-hook-end\\n\",\n+                template1.withArgs(b + \"E\"),\n+                hook1.insert(template1.withArgs(b + \"E\")),\n+                template1.withArgs(b + \"F\")\n+            ),\n+            \">\\n\"\n+        ));\n+\n+        \/\/ Test use of hooks across templates.\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            \"hook-start\\n\",\n+            hook1.set(\n+                \"hook-end\\n\",\n+                hook1.insert(template2.withArgs(\"sub-\")),\n+                \"base-C\\n\"\n+            ),\n+            \"base-D\\n\",\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            hook-start\n+            x sub-B x\n+            <\n+            x sub-A x\n+            x sub-C x\n+            inner-hook-start\n+            x sub-E x\n+            inner-hook-end\n+            x sub-E x\n+            x sub-F x\n+            >\n+            hook-end\n+            base-C\n+            base-D\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDollar() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x $name #a x\\n\"));\n+\n+        var template2 = Template.make(\"a\", (String a) -> body(\n+            \"{\\n\",\n+            \"y $name #a y\\n\",\n+            template1.withArgs($(\"name\")),\n+            \"}\\n\"\n+        ));\n+\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            \"$name\\n\",\n+            \"$name\", \"\\n\",\n+            \"z $name z\\n\",\n+            \"z$name z\\n\",\n+            template1.withArgs(\"name\"),     \/\/ does not capture -> literal \"$name\"\n+            template1.withArgs(\"$name\"),    \/\/ does not capture -> literal \"$name\"\n+            template1.withArgs($(\"name\")),  \/\/ capture replacement name \"name_1\"\n+            hook1.set(\n+                \"$name\\n\"\n+            ),\n+            \"break\\n\",\n+            hook1.set(\n+                \"one\\n\",\n+                hook1.insert(template1.withArgs($(\"name\"))),\n+                \"two\\n\",\n+                template1.withArgs($(\"name\")),\n+                \"three\\n\",\n+                hook1.insert(template2.withArgs($(\"name\"))),\n+                \"four\\n\"\n+            ),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            name_1\n+            name_1\n+            z name_1 z\n+            zname_1 z\n+            x name_2 name x\n+            x name_3 $name x\n+            x name_4 name_1 x\n+            name_1\n+            break\n+            x name_5 name_1 x\n+            {\n+            y name_7 name_1 y\n+            x name_8 name_7 x\n+            }\n+            one\n+            two\n+            x name_6 name_1 x\n+            three\n+            four\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testLet() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\n+            \"{\\n\",\n+            \"y #a y\\n\",\n+            let(\"b\", \"<\" + a + \">\"),\n+            \"y #b y\\n\",\n+            \"}\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"a\", (Integer a) -> let(\"b\", a * 10, b ->\n+            body(\n+                let(\"c\", b * 3),\n+                \"abc = #a #b #c\\n\"\n+            )\n+        ));\n+\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            let(\"x\", \"abc\"),\n+            template1.withArgs(\"alpha\"),\n+            \"break\\n\",\n+            \"x1 = #x\\n\",\n+            hook1.set(\n+                \"x2 = #x\\n\", \/\/ leaks inside\n+                template1.withArgs(\"beta\"),\n+                let(\"y\", \"one\"),\n+                \"y1 = #y\\n\"\n+            ),\n+            \"break\\n\",\n+            \"y2 = #y\\n\", \/\/ leaks outside\n+            \"break\\n\",\n+            template2.withArgs(5),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            {\n+            y alpha y\n+            y <alpha> y\n+            }\n+            break\n+            x1 = abc\n+            x2 = abc\n+            {\n+            y beta y\n+            y <beta> y\n+            }\n+            y1 = one\n+            break\n+            y2 = one\n+            break\n+            abc = 5 50 150\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testSelector() {\n+        var template1 = Template.make(\"a\", (String a) -> body(\n+            \"<\\n\",\n+            \"x #a x\\n\",\n+            \">\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"a\", (String a) -> body(\n+            \"<\\n\",\n+            \"y #a y\\n\",\n+            \">\\n\"\n+        ));\n+\n+        var template3 = Template.make(\"a\", (Integer a) -> body(\n+            \"[\\n\",\n+            \"z #a z\\n\",\n+            \/\/ Select which template should be used:\n+            a > 0 ? template1.withArgs(\"A_\" + a)\n+                  : template2.withArgs(\"B_\" + a),\n+            \"]\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"{\\n\",\n+            template3.withArgs(-1),\n+            \"break\\n\",\n+            template3.withArgs(0),\n+            \"break\\n\",\n+            template3.withArgs(1),\n+            \"break\\n\",\n+            template3.withArgs(2),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template4.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [\n+            z -1 z\n+            <\n+            y B_-1 y\n+            >\n+            ]\n+            break\n+            [\n+            z 0 z\n+            <\n+            y B_0 y\n+            >\n+            ]\n+            break\n+            [\n+            z 1 z\n+            <\n+            x A_1 x\n+            >\n+            ]\n+            break\n+            [\n+            z 2 z\n+            <\n+            x A_2 x\n+            >\n+            ]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testRecursion() {\n+        \/\/ Binding allows use of template1 inside template1, via the Binding indirection.\n+        var binding1 = new TemplateBinding<Template.OneArgs<Integer>>();\n+\n+        var template1 = Template.make(\"i\", (Integer i) -> body(\n+            \"[ #i\\n\",\n+            \/\/ We cannot yet use the template1 directly, as it is being defined.\n+            \/\/ So we use binding1 instead.\n+            i < 0 ? \"done\\n\" : binding1.get().withArgs(i - 1),\n+            \"] #i\\n\"\n+        ));\n+        binding1.bind(template1);\n+\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            \/\/ Now, we can use template1 normally, as it is already defined.\n+            template1.withArgs(3),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [ 3\n+            [ 2\n+            [ 1\n+            [ 0\n+            [ -1\n+            done\n+            ] -1\n+            ] 0\n+            ] 1\n+            ] 2\n+            ] 3\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFuel() {\n+        var template1 = Template.make(() -> body(\n+            let(\"f\", fuel()),\n+\n+            \"<#f>\\n\"\n+        ));\n+\n+        \/\/ Binding allows use of template2 inside template2, via the Binding indirection.\n+        var binding2 = new TemplateBinding<Template.OneArgs<Integer>>();\n+        var template2 = Template.make(\"i\", (Integer i) -> body(\n+            let(\"f\", fuel()),\n+\n+            \"[ #i #f\\n\",\n+            template1.withArgs(),\n+            fuel() <= 60.f ? \"done\" : binding2.get().withArgs(i - 1),\n+            \"] #i #f\\n\"\n+        ));\n+        binding2.bind(template2);\n+\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            template2.withArgs(3),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [ 3 90.0f\n+            <80.0f>\n+            [ 2 80.0f\n+            <70.0f>\n+            [ 1 70.0f\n+            <60.0f>\n+            [ 0 60.0f\n+            <50.0f>\n+            done] 0 60.0f\n+            ] 1 70.0f\n+            ] 2 80.0f\n+            ] 3 90.0f\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFuelCustom() {\n+        var template1 = Template.make(() -> body(\n+            setFuelCost(2.0f),\n+            let(\"f\", fuel()),\n+\n+            \"<#f>\\n\"\n+        ));\n+\n+        \/\/ Binding allows use of template2 inside template2, via the Binding indirection.\n+        var binding2 = new TemplateBinding<Template.OneArgs<Integer>>();\n+        var template2 = Template.make(\"i\", (Integer i) -> body(\n+            setFuelCost(3.0f),\n+            let(\"f\", fuel()),\n+\n+            \"[ #i #f\\n\",\n+            template1.withArgs(),\n+            fuel() <= 5.f ? \"done\\n\" : binding2.get().withArgs(i - 1),\n+            \"] #i #f\\n\"\n+        ));\n+        binding2.bind(template2);\n+\n+        var template3 = Template.make(() -> body(\n+            setFuelCost(5.0f),\n+            let(\"f\", fuel()),\n+\n+            \"{ #f\\n\",\n+            template2.withArgs(3),\n+            \"} #f\\n\"\n+        ));\n+\n+        String code = template3.withArgs().render(20.0f);\n+        String expected =\n+            \"\"\"\n+            { 20.0f\n+            [ 3 15.0f\n+            <12.0f>\n+            [ 2 12.0f\n+            <9.0f>\n+            [ 1 9.0f\n+            <6.0f>\n+            [ 0 6.0f\n+            <3.0f>\n+            [ -1 3.0f\n+            <0.0f>\n+            done\n+            ] -1 3.0f\n+            ] 0 6.0f\n+            ] 1 9.0f\n+            ] 2 12.0f\n+            ] 3 15.0f\n+            } 20.0f\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testNames() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\n+            \"[\", weighNames(myInt, true), \"]\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"name\", \"type\", (String name, Name.Type type) -> body(\n+            addName(new Name(name, type, true, 1)),\n+            \"define #type #name\\n\",\n+            template1.withArgs()\n+        ));\n+\n+        var template3 = Template.make(() -> body(\n+            \"<\\n\",\n+            hook1.insert(template2.withArgs($(\"name\"), myInt)),\n+            \"$name = 5\\n\",\n+            \">\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"{\\n\",\n+            template1.withArgs(),\n+            hook1.set(\n+                template1.withArgs(),\n+                \"something\\n\",\n+                template3.withArgs(),\n+                \"more\\n\",\n+                template1.withArgs(),\n+                \"more\\n\",\n+                template2.withArgs($(\"name\"), myInt),\n+                \"more\\n\",\n+                template1.withArgs()\n+            ),\n+            template1.withArgs(),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template4.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [0L]\n+            define int name_4\n+            [1L]\n+            [0L]\n+            something\n+            <\n+            name_4 = 5\n+            >\n+            more\n+            [1L]\n+            more\n+            define int name_1\n+            [2L]\n+            more\n+            [1L]\n+            [0L]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testNames2() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"type\", (Name.Type type) -> body(\n+            \"[#type: \", weighNames(type, true), \" and \", weighNames(type, false), \"]\\n\"\n+        ));\n+\n+\n+        var template2 = Template.make(\"name\", \"type\", (String name, Name.Type type) -> body(\n+            addName(new Name(name, type, true, 1)),\n+            \"define mutable #type #name\\n\",\n+            template1.withArgs(type)\n+        ));\n+\n+        var template3 = Template.make(\"name\", \"type\", (String name, Name.Type type) -> body(\n+            addName(new Name(name, type, false, 1)),\n+            \"define immutable #type #name\\n\",\n+            template1.withArgs(type)\n+        ));\n+\n+        var template4 = Template.make(\"type\", (Name.Type type) -> body(\n+            \"{ $store\\n\",\n+            hook1.insert(template2.withArgs($(\"name\"), type)),\n+            \"$name = 5\\n\",\n+            \"} $store\\n\"\n+        ));\n+\n+        var template5 = Template.make(\"type\", (Name.Type type) -> body(\n+            \"{ $load\\n\",\n+            hook1.insert(template3.withArgs($(\"name\"), type)),\n+            \"blackhole($name)\\n\",\n+            \"} $load\\n\"\n+        ));\n+\n+        var template6 = Template.make(\"type\", (Name.Type type) -> body(\n+            let(\"v\", sampleName(type, true).name()),\n+            \"{ $sample\\n\",\n+            \"#v = 7\\n\",\n+            \"} $sample\\n\"\n+        ));\n+\n+        var template7 = Template.make(\"type\", (Name.Type type) -> body(\n+            let(\"v\", sampleName(type, false).name()),\n+            \"{ $sample\\n\",\n+            \"blackhole(#v)\\n\",\n+            \"} $sample\\n\"\n+        ));\n+\n+        var template8 = Template.make(() -> body(\n+            \"class $X {\\n\",\n+            template1.withArgs(myInt),\n+            hook1.set(\n+                \"begin $body\\n\",\n+                template1.withArgs(myInt),\n+                \"start with immutable\\n\",\n+                template5.withArgs(myInt),\n+                \"then load from it\\n\",\n+                template7.withArgs(myInt),\n+                template1.withArgs(myInt),\n+                \"now make something mutable\\n\",\n+                template4.withArgs(myInt),\n+                \"then store to it\\n\",\n+                template6.withArgs(myInt),\n+                template1.withArgs(myInt)\n+            ),\n+            template1.withArgs(myInt),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template8.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            class X_1 {\n+            [int: 0L and 0L]\n+            define immutable int name_4\n+            [int: 0L and 1L]\n+            define mutable int name_9\n+            [int: 1L and 2L]\n+            begin body_1\n+            [int: 0L and 0L]\n+            start with immutable\n+            { load_4\n+            blackhole(name_4)\n+            } load_4\n+            then load from it\n+            { sample_7\n+            blackhole(name_4)\n+            } sample_7\n+            [int: 0L and 1L]\n+            now make something mutable\n+            { store_9\n+            name_9 = 5\n+            } store_9\n+            then store to it\n+            { sample_12\n+            name_9 = 7\n+            } sample_12\n+            [int: 1L and 2L]\n+            [int: 0L and 0L]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testNames3() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"type\", (Name.Type type) -> body(\n+            \"[#type: \", weighNames(type, true), \" and \", weighNames(type, false), \"]\\n\"\n+        ));\n+\n+        \/\/ Example that shows that addName runs before any code gets generated.\n+        \/\/ To avoid this behaviour, you have to wrap the addName in their own template.\n+        var template2 = Template.make(() -> body(\n+            \"class $Y {\\n\",\n+            template1.withArgs(myInt),\n+            hook1.set(\n+                \"begin $body\\n\",\n+                template1.withArgs(myInt),\n+                \"define mutable\\n\",\n+                addName(new Name($(\"v1\"), myInt, true, 1)),\n+                template1.withArgs(myInt),\n+                \"define immutable\\n\",\n+                addName(new Name($(\"v1\"), myInt, false, 1)),\n+                template1.withArgs(myInt)\n+            ),\n+            template1.withArgs(myInt),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+        String expected =\n+            \"\"\"\n+            class Y_1 {\n+            [int: 0L and 0L]\n+            begin body_1\n+            [int: 0L and 0L]\n+            define mutable\n+            [int: 1L and 1L]\n+            define immutable\n+            [int: 1L and 2L]\n+            [int: 0L and 0L]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    record MyItem(Name.Type type, String op) {}\n+\n+    public static void testListArgument() {\n+        var template1 = Template.make(\"item\", (MyItem item) -> body(\n+            let(\"type\", item.type()),\n+            let(\"op\", item.op()),\n+            \"#type apply #op\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"list\", (List<MyItem> list) -> body(\n+            \"class $Z {\\n\",\n+            \/\/ Use template1 for every item in the list.\n+            list.stream().map(item -> template1.withArgs(item)).toList(),\n+            \"}\\n\"\n+        ));\n+\n+        List<MyItem> list = List.of(new MyItem(myInt, \"+\"),\n+                                    new MyItem(myInt, \"-\"),\n+                                    new MyItem(myInt, \"*\"),\n+                                    new MyItem(myInt, \"\/\"),\n+                                    new MyItem(myLong, \"+\"),\n+                                    new MyItem(myLong, \"-\"),\n+                                    new MyItem(myLong, \"*\"),\n+                                    new MyItem(myLong, \"\/\"));\n+\n+        String code = template2.withArgs(list).render();\n+        String expected =\n+            \"\"\"\n+            class Z_1 {\n+            int apply +\n+            int apply -\n+            int apply *\n+            int apply \/\n+            long apply +\n+            long apply -\n+            long apply *\n+            long apply \/\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFailingNestedRendering() {\n+        var template1 = Template.make(() -> body(\n+            \"alpha\\n\"\n+        ));\n+\n+        var template2 = Template.make(() -> body(\n+            \"beta\\n\",\n+            \/\/ Nested \"render\" call not allowed!\n+            template1.withArgs().render(),\n+            \"gamma\\n\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+    }\n+\n+    public static void testFailingHook() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\n+            \"alpha\\n\"\n+        ));\n+\n+        var template2 = Template.make(() -> body(\n+            \"beta\\n\",\n+            \/\/ Use hook without hook1.set\n+            hook1.insert(template1.withArgs()),\n+            \"gamma\\n\"\n+        ));\n+\n+        String code = template2.withArgs().render();\n+    }\n+\n+    public static void testFailingSample() {\n+        var template1 = Template.make(() -> body(\n+            let(\"v\", sampleName(myInt, true).name()),\n+            \"v is #v\\n\"\n+        ));\n+\n+        String code = template1.withArgs().render();\n+    }\n+\n+    public static void testFailingHashtag1() {\n+        var template1 = Template.make(\"a\", \"a\", (String _, String _) -> body(\n+            \"nothing\\n\"\n+        ));\n+\n+        String code = template1.withArgs(\"x\", \"y\").render();\n+    }\n+\n+    public static void testFailingHashtag2() {\n+        var template1 = Template.make(\"a\", (String _) -> body(\n+            let(\"a\", \"x\"),\n+            \"nothing\\n\"\n+        ));\n+\n+        String code = template1.withArgs(\"y\").render();\n+    }\n+\n+    public static void testFailingHashtag3() {\n+        var template1 = Template.make(() -> body(\n+            let(\"a\", \"x\"),\n+            let(\"a\", \"y\"),\n+            \"nothing\\n\"\n+        ));\n+\n+        String code = template1.withArgs().render();\n+    }\n+\n+    public static void testFailingHashtag4() {\n+        var template1 = Template.make(() -> body(\n+            \"#a\\n\"\n+        ));\n+\n+        String code = template1.withArgs().render();\n+    }\n+\n+    public static void testFailingBinding1() {\n+        var binding = new TemplateBinding<Template.ZeroArgs>();\n+        var template1 = Template.make(() -> body(\n+            \"nothing\\n\"\n+        ));\n+        binding.bind(template1);\n+        binding.bind(template1);\n+    }\n+\n+    public static void testFailingBinding2() {\n+        var binding = new TemplateBinding<Template.ZeroArgs>();\n+        var template1 = Template.make(() -> body(\n+            \"nothing\\n\",\n+            binding.get().withArgs()\n+        ));\n+        String code = template1.withArgs().render();\n+    }\n+\n+    public static void expectRendererException(FailingTest test, String errorPrefix) {\n+        try {\n+            test.run();\n+            System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+            throw new RuntimeException(\"Should have thrown!\");\n+        } catch(RendererException e) {\n+            if (!e.getMessage().startsWith(errorPrefix)) {\n+                System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+                System.out.println(\"got: \" + e.getMessage());\n+                throw new RuntimeException(\"Prefix mismatch\", e);\n+            }\n+        }\n+    }\n+\n+    public static void expectIllegalArgumentException(FailingTest test, String errorPrefix) {\n+        try {\n+            test.run();\n+            System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+            throw new RuntimeException(\"Should have thrown!\");\n+        } catch(IllegalArgumentException e) {\n+            if (!e.getMessage().startsWith(errorPrefix)) {\n+                System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+                System.out.println(\"got: \" + e.getMessage());\n+                throw new RuntimeException(\"Prefix mismatch\", e);\n+            }\n+        }\n+    }\n+\n+    public static void checkEQ(String code, String expected) {\n+        if (!code.equals(expected)) {\n+            System.out.println(\"\\\"\" + code + \"\\\"\");\n+            System.out.println(\"\\\"\" + expected + \"\\\"\");\n+            throw new RuntimeException(\"Template rendering mismatch!\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestTemplate.java","additions":1267,"deletions":0,"binary":false,"changes":1267,"status":"added"}]}