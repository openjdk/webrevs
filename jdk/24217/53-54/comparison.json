{"files":[{"patch":"@@ -67,13 +67,13 @@\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest1\",   generateWithListOfTokens());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest2\",   generateWithTemplateArguments());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest3\",   generateWithHashtagAndDollarReplacements());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest3b\",  generateWithHashtagAndDollarReplacements2());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest4\",   generateWithCustomHooks());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest5\",   generateWithLibraryHooks());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest6\",   generateWithRecursionAndBindingsAndFuel());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest7\",   generateWithDataNamesSimple());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest8\",   generateWithDataNamesForFieldsAndVariables());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest9\",   generateWithDataNamesForFuzzing());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest10\",  generateWithStructuralNamesForMethods());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest11a\", generateWithDataNamesAndScopes1());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest11b\", generateWithDataNamesAndScopes2());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest1\",  generateWithListOfTokens());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest2\",  generateWithTemplateArguments());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest3\",  generateWithHashtagAndDollarReplacements());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest3b\", generateWithHashtagAndDollarReplacements2());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest4\",  generateWithCustomHooks());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest5\",  generateWithLibraryHooks());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest6\",  generateWithRecursionAndBindingsAndFuel());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest7\",  generateWithDataNamesSimple());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest8\",  generateWithDataNamesForFieldsAndVariables());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9a\", generateWithDataNamesAndScopes1());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9b\", generateWithDataNamesAndScopes2());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest10\", generateWithDataNamesForFuzzing());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest11\", generateWithStructuralNamesForMethods());\n@@ -88,13 +88,13 @@\n-        comp.invoke(\"p.xyz.InnerTest1\",   \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest2\",   \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest3\",   \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest3b\",  \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest4\",   \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest5\",   \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest6\",   \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest7\",   \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest8\",   \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest9\",   \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest10\",  \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest11a\", \"main\", new Object[] {});\n-        comp.invoke(\"p.xyz.InnerTest11b\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest1\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest2\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest3\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest3b\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest4\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest5\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest6\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest7\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest8\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest9a\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest9b\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest10\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest11\", \"main\", new Object[] {});\n@@ -748,0 +748,201 @@\n+    \/\/ Let us have a closer look at how DataNames interact with scopes created by\n+    \/\/ Templates and Hooks. Additionally, we see how the execution order of the\n+    \/\/ lambdas and token evaluation affects the availability of DataNames.\n+    \/\/\n+    \/\/ We inject the results directly into verification inside the code, so it\n+    \/\/ is relatively simple to see what the expected results are.\n+    \/\/\n+    \/\/ For simplicity, we define a simple \"list\" function. It collects all\n+    \/\/ field and variable names, and immediately returns the comma separated\n+    \/\/ list of the names. We can use that to visualize the available names\n+    \/\/ at any point.\n+    public static String listNames() {\n+        return \"{\" + String.join(\", \", dataNames(MUTABLE).exactOf(myInt).toList()\n+                                       .stream().map(DataName::name).toList()) + \"}\";\n+    }\n+\n+    \/\/ Even simpler: count the available variable and return the count immediately.\n+    public static int countNames() {\n+        return dataNames(MUTABLE).exactOf(myInt).count();\n+    }\n+\n+    \/\/ Having defined these helper methods, let us start with the first example.\n+    \/\/ You should start reading this example bottum-up, starting at\n+    \/\/ templateClass, then going to templateMain and last to templateInnner.\n+    public static String generateWithDataNamesAndScopes1() {\n+\n+        var templateInner = Template.make(() -> body(\n+            \/\/ We just got called from the templateMain. All tokens from there\n+            \/\/ are already evaluated, so \"v1\" is now available:\n+            let(\"l1\", listNames()),\n+            \"\"\"\n+            if (!\"{v1}\".equals(\"#l1\")) { throw new RuntimeException(\"l1 should have been '{v1}' but was '#l1'\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateMain = Template.make(() -> body(\n+            \/\/ So far, no names were defined. We expect \"c1\" to be zero.\n+            let(\"c1\", countNames()),\n+            \"\"\"\n+            if (#c1 != 0) { throw new RuntimeException(\"c1 was not zero but #c1\"); }\n+            \"\"\",\n+            \/\/ We now add a local variable \"v1\" to the scope of this templateMain.\n+            \/\/ This only generates a token, and does not immediately add the name.\n+            \/\/ The name is only added once we evaluate the tokens, and arrive at\n+            \/\/ this particular token.\n+            addDataName(\"v1\", myInt, MUTABLE),\n+            \/\/ We count again with \"c2\". The variable \"v1\" is at this point still\n+            \/\/ in token form, hence it is not yet made available while executing\n+            \/\/ the template lambda of templateMain.\n+            let(\"c2\", countNames()),\n+            \"\"\"\n+            if (#c2 != 0) { throw new RuntimeException(\"c2 was not zero but #c2\"); }\n+            \"\"\",\n+            \/\/ But now we call an inner Template. This is added as a TemplateToken.\n+            \/\/ This means it is not evaluated immediately, but only once we evaluate\n+            \/\/ the tokens. By that time, all tokens from above are already evaluated\n+            \/\/ and we see that \"v1\" is available.\n+            templateInner.asToken()\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest9a {\n+            \"\"\",\n+            Hooks.CLASS_HOOK.anchor(\n+            \"\"\"\n+                public static void main() {\n+            \"\"\",\n+                Hooks.METHOD_HOOK.anchor(\n+                    templateMain.asToken()\n+                ),\n+            \"\"\"\n+                }\n+            \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ Now that we understand this simple example, we go to a more complicated one\n+    \/\/ where we use Hook.insert. Just as above, you should read this example\n+    \/\/ bottom-up, starting at templateClass.\n+    public static String generateWithDataNamesAndScopes2() {\n+\n+        var templateFields = Template.make(() -> body(\n+            \/\/ We were just called from templateMain. But the code is not\n+            \/\/ generated into the main scope, rather into the class scope\n+            \/\/ out in templateClass.\n+            \/\/ Let us now add a field \"f1\".\n+            addDataName(\"f1\", myInt, MUTABLE),\n+            \/\/ And let's also generate the code for it.\n+            \"\"\"\n+            public static int f1 = 42;\n+            \"\"\",\n+            \/\/ But why is this DataName now availabe inside the scope of\n+            \/\/ templateInner? Does that not mean that \"f1\" escapes this\n+            \/\/ templateFields here? Yes it does!\n+            \/\/ For normal template nesting, the names do not escape the\n+            \/\/ scope of the nested template. But this here is no normal\n+            \/\/ template nesting, rather it is an insertion into a Hook,\n+            \/\/ and we treat those differently. We make the scope of the\n+            \/\/ inserted templateFields transparent, so that any added\n+            \/\/ DataNames are added to the scope of the Hook we just\n+            \/\/ inserted into, i.e. the CLASS_HOOK. This is very important,\n+            \/\/ if we did not make that scope transparent, we could not\n+            \/\/ add any DataNames to the class scope any more, and we could\n+            \/\/ not add any fields that would be available in the class\n+            \/\/ scope.\n+            Hooks.METHOD_HOOK.anchor(\n+                \/\/ We now create a separate scope. This one is not the\n+                \/\/ template scope from above, and it is not transparent.\n+                \/\/ Hence, \"f2\" will not be available outside of this\n+                \/\/ scope.\n+                addDataName(\"f2\", myInt, MUTABLE),\n+                \/\/ And let's also generate the code for it.\n+                \"\"\"\n+                public static int f2 = 666;\n+                \"\"\"\n+                \/\/ Similarly, if we called any nested Template here,\n+                \/\/ and added DataNames inside, this would happen inside\n+                \/\/ nested scopes that are not transparent. If one wanted\n+                \/\/ to add names to the CLASS_HOOK from there, one would\n+                \/\/ have to do another Hook.insert, and make sure that\n+                \/\/ the names are added from the outermost scope of that\n+                \/\/ inserted Template, because only that outermost scope\n+                \/\/ is transparent to the CLASS_HOOK.\n+            )\n+        ));\n+\n+        var templateInner = Template.make(() -> body(\n+            \/\/ We just got called from the templateMain. All tokens from there\n+            \/\/ are already evaluated, so there should be some fields available.\n+            \/\/ We can see field \"f1\".\n+            let(\"l1\", listNames()),\n+            \"\"\"\n+            if (!\"{f1}\".equals(\"#l1\")) { throw new RuntimeException(\"l1 should have been '{f1}' but was '#l1'\"); }\n+            \"\"\"\n+            \/\/ Now go and have a look at templateFields, to understand how that\n+            \/\/ field was added, and why not any others.\n+        ));\n+\n+        var templateMain = Template.make(() -> body(\n+            \/\/ So far, no names were defined. We expect \"c1\" to be zero.\n+            let(\"c1\", countNames()),\n+            \"\"\"\n+            if (#c1 != 0) { throw new RuntimeException(\"c1 was not zero but #c1\"); }\n+            \"\"\",\n+            \/\/ We would now like to add some fields to the class scope, out in the\n+            \/\/ templateClass. This creates a token, which is only evaluated after\n+            \/\/ the completion of the templateMain lambda. Before you go and look\n+            \/\/ at templateFields, just assume that it does add some fields, and\n+            \/\/ continue reading in templateMain.\n+            Hooks.CLASS_HOOK.insert(templateFields.asToken()),\n+            \/\/ We count again with \"c2\". The fields we wanted to add above are not\n+            \/\/ yet available, because the token is not yet evaluated. Hence, we\n+            \/\/ still only count zero names.\n+            let(\"c2\", countNames()),\n+            \"\"\"\n+            if (#c2 != 0) { throw new RuntimeException(\"c2 was not zero but #c2\"); }\n+            \"\"\",\n+            \/\/ Now we call an inner Template. This also creates a token, and so it\n+            \/\/ is not evaluated immediately. And by the time this token is evaluated\n+            \/\/ the tokens from above are already evaluated, and so the fields should\n+            \/\/ be available. Go have a look at templateInner now.\n+            templateInner.asToken()\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest9b {\n+            \"\"\",\n+            Hooks.CLASS_HOOK.anchor(\n+            \"\"\"\n+                public static void main() {\n+            \"\"\",\n+                Hooks.METHOD_HOOK.anchor(\n+                    templateMain.asToken()\n+                ),\n+            \"\"\"\n+                }\n+            \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+\n@@ -820,1 +1021,1 @@\n-            public class InnerTest9 {\n+            public class InnerTest10 {\n@@ -928,1 +1129,1 @@\n-            public class InnerTest10 {\n+            public class InnerTest11 {\n@@ -964,200 +1165,0 @@\n-\n-    \/\/ Let us have a closer look at how DataNames interact with scopes created by\n-    \/\/ Templates and Hooks. Additionally, we see how the execution order of the\n-    \/\/ lambdas and token evaluation affects the availability of DataNames.\n-    \/\/\n-    \/\/ We inject the results directly into verification inside the code, so it\n-    \/\/ is relatively simple to see what the expected results are.\n-    \/\/\n-    \/\/ For simplicity, we define a simple \"list\" function. It collects all\n-    \/\/ field and variable names, and immediately returns the comma separated\n-    \/\/ list of the names. We can use that to visualize the available names\n-    \/\/ at any point.\n-    public static String listNames() {\n-        return \"{\" + String.join(\", \", dataNames(MUTABLE).exactOf(myInt).toList()\n-                                       .stream().map(DataName::name).toList()) + \"}\";\n-    }\n-\n-    \/\/ Even simpler: count the available variable and return the count immediately.\n-    public static int countNames() {\n-        return dataNames(MUTABLE).exactOf(myInt).count();\n-    }\n-\n-    \/\/ Having defined these helper methods, let us start with the first example.\n-    \/\/ You should start reading this example bottum-up, starting at\n-    \/\/ templateClass, then going to templateMain and last to templateInnner.\n-    public static String generateWithDataNamesAndScopes1() {\n-\n-        var templateInner = Template.make(() -> body(\n-            \/\/ We just got called from the templateMain. All tokens from there\n-            \/\/ are already evaluated, so \"v1\" is now available:\n-            let(\"l1\", listNames()),\n-            \"\"\"\n-            if (!\"{v1}\".equals(\"#l1\")) { throw new RuntimeException(\"l1 should have been '{v1}' but was '#l1'\"); }\n-            \"\"\"\n-        ));\n-\n-        var templateMain = Template.make(() -> body(\n-            \/\/ So far, no names were defined. We expect \"c1\" to be zero.\n-            let(\"c1\", countNames()),\n-            \"\"\"\n-            if (#c1 != 0) { throw new RuntimeException(\"c1 was not zero but #c1\"); }\n-            \"\"\",\n-            \/\/ We now add a local variable \"v1\" to the scope of this templateMain.\n-            \/\/ This only generates a token, and does not immediately add the name.\n-            \/\/ The name is only added once we evaluate the tokens, and arrive at\n-            \/\/ this particular token.\n-            addDataName(\"v1\", myInt, MUTABLE),\n-            \/\/ We count again with \"c2\". The variable \"v1\" is at this point still\n-            \/\/ in token form, hence it is not yet made available while executing\n-            \/\/ the template lambda of templateMain.\n-            let(\"c2\", countNames()),\n-            \"\"\"\n-            if (#c2 != 0) { throw new RuntimeException(\"c2 was not zero but #c2\"); }\n-            \"\"\",\n-            \/\/ But now we call an inner Template. This is added as a TemplateToken.\n-            \/\/ This means it is not evaluated immediately, but only once we evaluate\n-            \/\/ the tokens. By that time, all tokens from above are already evaluated\n-            \/\/ and we see that \"v1\" is available.\n-            templateInner.asToken()\n-        ));\n-\n-        var templateClass = Template.make(() -> body(\n-            \"\"\"\n-            package p.xyz;\n-\n-            public class InnerTest11a {\n-            \"\"\",\n-            Hooks.CLASS_HOOK.anchor(\n-            \"\"\"\n-                public static void main() {\n-            \"\"\",\n-                Hooks.METHOD_HOOK.anchor(\n-                    templateMain.asToken()\n-                ),\n-            \"\"\"\n-                }\n-            \"\"\"\n-            ),\n-            \"\"\"\n-            }\n-            \"\"\"\n-        ));\n-\n-        \/\/ Render templateClass to String.\n-        return templateClass.render();\n-    }\n-\n-    \/\/ Now that we understand this simple example, we go to a more complicated one\n-    \/\/ where we use Hook.insert. Just as above, you should read this example\n-    \/\/ bottom-up, starting at templateClass.\n-    public static String generateWithDataNamesAndScopes2() {\n-\n-        var templateFields = Template.make(() -> body(\n-            \/\/ We were just called from templateMain. But the code is not\n-            \/\/ generated into the main scope, rather into the class scope\n-            \/\/ out in templateClass.\n-            \/\/ Let us now add a field \"f1\".\n-            addDataName(\"f1\", myInt, MUTABLE),\n-            \/\/ And let's also generate the code for it.\n-            \"\"\"\n-            public static int f1 = 42;\n-            \"\"\",\n-            \/\/ But why is this DataName now availabe inside the scope of\n-            \/\/ templateInner? Does that not mean that \"f1\" escapes this\n-            \/\/ templateFields here? Yes it does!\n-            \/\/ For normal template nesting, the names do not escape the\n-            \/\/ scope of the nested template. But this here is no normal\n-            \/\/ template nesting, rather it is an insertion into a Hook,\n-            \/\/ and we treat those differently. We make the scope of the\n-            \/\/ inserted templateFields transparent, so that any added\n-            \/\/ DataNames are added to the scope of the Hook we just\n-            \/\/ inserted into, i.e. the CLASS_HOOK. This is very important,\n-            \/\/ if we did not make that scope transparent, we could not\n-            \/\/ add any DataNames to the class scope any more, and we could\n-            \/\/ not add any fields that would be available in the class\n-            \/\/ scope.\n-            Hooks.METHOD_HOOK.anchor(\n-                \/\/ We now create a separate scope. This one is not the\n-                \/\/ template scope from above, and it is not transparent.\n-                \/\/ Hence, \"f2\" will not be available outside of this\n-                \/\/ scope.\n-                addDataName(\"f2\", myInt, MUTABLE),\n-                \/\/ And let's also generate the code for it.\n-                \"\"\"\n-                public static int f2 = 666;\n-                \"\"\"\n-                \/\/ Similarly, if we called any nested Template here,\n-                \/\/ and added DataNames inside, this would happen inside\n-                \/\/ nested scopes that are not transparent. If one wanted\n-                \/\/ to add names to the CLASS_HOOK from there, one would\n-                \/\/ have to do another Hook.insert, and make sure that\n-                \/\/ the names are added from the outermost scope of that\n-                \/\/ inserted Template, because only that outermost scope\n-                \/\/ is transparent to the CLASS_HOOK.\n-            )\n-        ));\n-\n-        var templateInner = Template.make(() -> body(\n-            \/\/ We just got called from the templateMain. All tokens from there\n-            \/\/ are already evaluated, so there should be some fields available.\n-            \/\/ We can see field \"f1\".\n-            let(\"l1\", listNames()),\n-            \"\"\"\n-            if (!\"{f1}\".equals(\"#l1\")) { throw new RuntimeException(\"l1 should have been '{f1}' but was '#l1'\"); }\n-            \"\"\"\n-            \/\/ Now go and have a look at templateFields, to understand how that\n-            \/\/ field was added, and why not any others.\n-        ));\n-\n-        var templateMain = Template.make(() -> body(\n-            \/\/ So far, no names were defined. We expect \"c1\" to be zero.\n-            let(\"c1\", countNames()),\n-            \"\"\"\n-            if (#c1 != 0) { throw new RuntimeException(\"c1 was not zero but #c1\"); }\n-            \"\"\",\n-            \/\/ We would now like to add some fields to the class scope, out in the\n-            \/\/ templateClass. This creates a token, which is only evaluated after\n-            \/\/ the completion of the templateMain lambda. Before you go and look\n-            \/\/ at templateFields, just assume that it does add some fields, and\n-            \/\/ continue reading in templateMain.\n-            Hooks.CLASS_HOOK.insert(templateFields.asToken()),\n-            \/\/ We count again with \"c2\". The fields we wanted to add above are not\n-            \/\/ yet available, because the token is not yet evaluated. Hence, we\n-            \/\/ still only count zero names.\n-            let(\"c2\", countNames()),\n-            \"\"\"\n-            if (#c2 != 0) { throw new RuntimeException(\"c2 was not zero but #c2\"); }\n-            \"\"\",\n-            \/\/ Now we call an inner Template. This also creates a token, and so it\n-            \/\/ is not evaluated immediately. And by the time this token is evaluated\n-            \/\/ the tokens from above are already evaluated, and so the fields should\n-            \/\/ be available. Go have a look at templateInner now.\n-            templateInner.asToken()\n-        ));\n-\n-        var templateClass = Template.make(() -> body(\n-            \"\"\"\n-            package p.xyz;\n-\n-            public class InnerTest11b {\n-            \"\"\",\n-            Hooks.CLASS_HOOK.anchor(\n-            \"\"\"\n-                public static void main() {\n-            \"\"\",\n-                Hooks.METHOD_HOOK.anchor(\n-                    templateMain.asToken()\n-                ),\n-            \"\"\"\n-                }\n-            \"\"\"\n-            ),\n-            \"\"\"\n-            }\n-            \"\"\"\n-        ));\n-\n-        \/\/ Render templateClass to String.\n-        return templateClass.render();\n-    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":229,"deletions":228,"binary":false,"changes":457,"status":"modified"}]}