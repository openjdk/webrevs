{"files":[{"patch":"@@ -2542,1 +2542,0 @@\n-    intptr_t super_check_offset = k->is_loaded() ? k->super_check_offset() : -1L;\n@@ -2547,2 +2546,1 @@\n-                                     failure_target, nullptr,\n-                                     RegisterOrConstant(super_check_offset));\n+                                     failure_target, nullptr);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -560,1 +560,6 @@\n-      __ check_klass_subtype_slow_path(Rsubklass, Rsuperklass, Rarray_ptr, Rlength, nullptr, &miss);\n+      __ check_klass_subtype_slow_path(Rsubklass,\n+                                       Rsuperklass,\n+                                       Rarray_ptr  \/* temp_reg  *\/,\n+                                       Rlength     \/* temp2_reg *\/,\n+                                       nullptr     \/* L_success *\/,\n+                                       &miss       \/* L_failure *\/);\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2984,1 +2984,3 @@\n-                                                   RegisterOrConstant super_check_offset) {\n+                                                   Register   super_check_offset) {\n+  \/\/ Input registers must not overlap.\n+  assert_different_registers(sub_klass, super_klass, temp1_reg, super_check_offset);\n@@ -2986,1 +2988,0 @@\n-  const int sc_offset  = in_bytes(Klass::secondary_super_cache_offset());\n@@ -2988,4 +2989,1 @@\n-\n-  bool must_load_sco = (super_check_offset.constant_or_zero() == -1);\n-  bool need_slow_path = (must_load_sco ||\n-                         super_check_offset.constant_or_zero() == sc_offset);\n+  bool must_load_sco = ! super_check_offset->is_valid();\n@@ -2994,5 +2992,1 @@\n-  assert_different_registers(sub_klass, super_klass, temp1_reg);\n-  if (super_check_offset.is_register()) {\n-    assert_different_registers(sub_klass, super_klass,\n-                               super_check_offset.as_register());\n-  } else if (must_load_sco) {\n+  if (must_load_sco) {\n@@ -3009,3 +3003,1 @@\n-  assert(label_nulls <= 1 ||\n-         (L_slow_path == &L_fallthrough && label_nulls <= 2 && !need_slow_path),\n-         \"at most one null in the batch, usually\");\n+  assert(label_nulls <= 1 || (L_slow_path == &L_fallthrough && label_nulls <= 2), \"at most one null in the batch, usually\");\n@@ -3026,1 +3018,1 @@\n-    super_check_offset = RegisterOrConstant(Rsuper_check_offset);\n+    super_check_offset = Rsuper_check_offset;\n@@ -3028,0 +3020,1 @@\n+\n@@ -3030,0 +3023,1 @@\n+  branch_optimized(Assembler::bcondEqual, *L_success);\n@@ -3047,17 +3041,3 @@\n-  if (super_check_offset.is_register()) {\n-    branch_optimized(Assembler::bcondEqual, *L_success);\n-    z_cfi(super_check_offset.as_register(), sc_offset);\n-    if (L_failure == &L_fallthrough) {\n-      branch_optimized(Assembler::bcondEqual, *L_slow_path);\n-    } else {\n-      branch_optimized(Assembler::bcondNotEqual, *L_failure);\n-      final_jmp(*L_slow_path);\n-    }\n-  } else if (super_check_offset.as_constant() == sc_offset) {\n-    \/\/ Need a slow path; fast failure is impossible.\n-    if (L_slow_path == &L_fallthrough) {\n-      branch_optimized(Assembler::bcondEqual, *L_success);\n-    } else {\n-      branch_optimized(Assembler::bcondNotEqual, *L_slow_path);\n-      final_jmp(*L_success);\n-    }\n+  z_cfi(super_check_offset, in_bytes(Klass::secondary_super_cache_offset()));\n+  if (L_failure == &L_fallthrough) {\n+    branch_optimized(Assembler::bcondEqual, *L_slow_path);\n@@ -3065,7 +3045,2 @@\n-    \/\/ No slow path; it's a fast decision.\n-    if (L_failure == &L_fallthrough) {\n-      branch_optimized(Assembler::bcondEqual, *L_success);\n-    } else {\n-      branch_optimized(Assembler::bcondNotEqual, *L_failure);\n-      final_jmp(*L_success);\n-    }\n+    branch_optimized(Assembler::bcondNotEqual, *L_failure);\n+    final_jmp(*L_slow_path);\n@@ -3075,1 +3050,0 @@\n-#undef local_brc\n@@ -3081,6 +3055,7 @@\n-void MacroAssembler::check_klass_subtype_slow_path(Register Rsubklass,\n-                                                   Register Rsuperklass,\n-                                                   Register Rarray_ptr,  \/\/ tmp\n-                                                   Register Rlength,     \/\/ tmp\n-                                                   Label* L_success,\n-                                                   Label* L_failure) {\n+void MacroAssembler::check_klass_subtype_slow_path_linear(Register Rsubklass,\n+                                                          Register Rsuperklass,\n+                                                          Register Rarray_ptr,  \/\/ tmp\n+                                                          Register Rlength,     \/\/ tmp\n+                                                          Label* L_success,\n+                                                          Label* L_failure,\n+                                                          bool set_cond_codes \/* unused *\/) {\n@@ -3109,1 +3084,1 @@\n-  BLOCK_COMMENT(\"check_klass_subtype_slow_path {\");\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path_linear {\");\n@@ -3137,1 +3112,1 @@\n-  \/\/ Cache load doesn't happen here. For speed it is directly emitted by the compiler.\n+  \/\/ Cache load doesn't happen here. For speed, it is directly emitted by the compiler.\n@@ -3141,2 +3116,3 @@\n-  z_stg(Rsuperklass, sc_offset, Rsubklass); \/\/ Save result to cache.\n-\n+  if (UseSecondarySupersCache) {\n+    z_stg(Rsuperklass, sc_offset, Rsubklass); \/\/ Save result to cache.\n+  }\n@@ -3147,1 +3123,0 @@\n-#undef local_brc\n@@ -3149,0 +3124,132 @@\n+  BLOCK_COMMENT(\"} check_klass_subtype_slow_path_linear\");\n+}\n+\n+\/\/ If Register r is invalid, remove a new register from\n+\/\/ available_regs, and add new register to regs_to_push.\n+Register MacroAssembler::allocate_if_noreg(Register r,\n+                                           RegSetIterator<Register> &available_regs,\n+                                           RegSet &regs_to_push) {\n+  if (!r->is_valid()) {\n+    r = *available_regs++;\n+    regs_to_push += r;\n+  }\n+  return r;\n+}\n+\n+\/\/ check_klass_subtype_slow_path_table() looks for super_klass in the\n+\/\/ hash table belonging to super_klass, branching to L_success or\n+\/\/ L_failure as appropriate. This is essentially a shim which\n+\/\/ allocates registers as necessary and then calls\n+\/\/ lookup_secondary_supers_table() to do the work. Any of the temp\n+\/\/ regs may be noreg, in which case this logic will choose some\n+\/\/ registers push and pop them from the stack.\n+void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n+                                                         Register super_klass,\n+                                                         Register temp_reg,\n+                                                         Register temp2_reg,\n+                                                         Register temp3_reg,\n+                                                         Register temp4_reg,\n+                                                         Register result_reg,\n+                                                         Label* L_success,\n+                                                         Label* L_failure,\n+                                                         bool set_cond_codes) {\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path_table {\");\n+\n+  RegSet temps = RegSet::of(temp_reg, temp2_reg, temp3_reg, temp4_reg);\n+\n+  assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg, temp4_reg);\n+\n+  Label L_fallthrough;\n+  int label_nulls = 0;\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n+\n+  RegSetIterator<Register> available_regs\n+  \/\/ Z_R0 will be used to hold Z_R15(Z_SP) while pushing a new frame, So don't use that here.\n+  \/\/ Z_R1 is will be used to hold r_bitmap in lookup_secondary_supers_table_var, so can't be used\n+  \/\/ Z_R2, Z_R3, Z_R4 will be used in secondary_supers_verify, for the failure reporting\n+    = (RegSet::range(Z_R0, Z_R15) - temps - sub_klass - super_klass - Z_R1_scratch - Z_R0_scratch - Z_R2 - Z_R3 - Z_R4).begin();\n+\n+  RegSet pushed_regs;\n+\n+  temp_reg  = allocate_if_noreg(temp_reg,  available_regs, pushed_regs);\n+  temp2_reg = allocate_if_noreg(temp2_reg, available_regs, pushed_regs);\n+  temp3_reg = allocate_if_noreg(temp3_reg, available_regs, pushed_regs);;\n+  temp4_reg = allocate_if_noreg(temp4_reg, available_regs, pushed_regs);\n+  result_reg = allocate_if_noreg(result_reg, available_regs, pushed_regs);\n+\n+  const int frame_size = pushed_regs.size() * BytesPerWord + frame::z_abi_160_size;\n+\n+  \/\/ Push & save registers\n+  {\n+    int i = 0;\n+    save_return_pc();\n+    push_frame(frame_size);\n+\n+    for (auto it = pushed_regs.begin(); *it != noreg; i++) {\n+      z_stg(*it++, i * BytesPerWord + frame::z_abi_160_size, Z_SP);\n+    }\n+    assert(i * BytesPerWord + frame::z_abi_160_size == frame_size, \"sanity\");\n+  }\n+\n+  lookup_secondary_supers_table_var(sub_klass,\n+                                    super_klass,\n+                                    temp_reg, temp2_reg, temp3_reg, temp4_reg, result_reg);\n+\n+  z_cghi(result_reg, 0);\n+\n+  {\n+    int i = 0;\n+    for (auto it = pushed_regs.begin(); *it != noreg; ++i) {\n+      z_lg(*it++, i * BytesPerWord + frame::z_abi_160_size, Z_SP);\n+    }\n+    assert(i * BytesPerWord + frame::z_abi_160_size == frame_size, \"sanity\");\n+    pop_frame();\n+    restore_return_pc();\n+  }\n+\n+  \/\/ NB! Callers may assume that, when set_cond_codes is true, this\n+  \/\/ code sets temp2_reg to a nonzero value.\n+  if (set_cond_codes) {\n+    z_lghi(temp2_reg, 1);\n+  }\n+\n+  branch_optimized(bcondNotEqual, *L_failure);\n+\n+  if(L_success != &L_fallthrough) {\n+    z_bru(*L_success);\n+  }\n+\n+  bind(L_fallthrough);\n+  BLOCK_COMMENT(\"} check_klass_subtype_slow_path_table\");\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp_reg,\n+                                                   Register temp2_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure,\n+                                                   bool set_cond_codes) {\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path {\");\n+  if (UseSecondarySupersTable) {\n+    check_klass_subtype_slow_path_table(sub_klass,\n+                                        super_klass,\n+                                        temp_reg,\n+                                        temp2_reg,\n+                                        \/*temp3*\/noreg,\n+                                        \/*temp4*\/noreg,\n+                                        \/*result*\/noreg,\n+                                        L_success,\n+                                        L_failure,\n+                                        set_cond_codes);\n+  } else {\n+    check_klass_subtype_slow_path_linear(sub_klass,\n+                                         super_klass,\n+                                         temp_reg,\n+                                         temp2_reg,\n+                                         L_success,\n+                                         L_failure,\n+                                         set_cond_codes);\n+  }\n@@ -3209,8 +3316,8 @@\n-void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n-                                                   Register r_super_klass,\n-                                                   Register r_temp1,\n-                                                   Register r_temp2,\n-                                                   Register r_temp3,\n-                                                   Register r_temp4,\n-                                                   Register r_result,\n-                                                   u1 super_klass_slot) {\n+void MacroAssembler::lookup_secondary_supers_table_const(Register r_sub_klass,\n+                                                         Register r_super_klass,\n+                                                         Register r_temp1,\n+                                                         Register r_temp2,\n+                                                         Register r_temp3,\n+                                                         Register r_temp4,\n+                                                         Register r_result,\n+                                                         u1 super_klass_slot) {\n@@ -3219,1 +3326,1 @@\n-  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table_const {\");\n@@ -3294,1 +3401,1 @@\n-  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table_const\");\n@@ -3302,0 +3409,110 @@\n+\/\/ At runtime, return 0 in result if r_super_klass is a superclass of\n+\/\/ r_sub_klass, otherwise return nonzero. Use this version of\n+\/\/ lookup_secondary_supers_table() if you don't know ahead of time\n+\/\/ which superclass will be searched for. Used by interpreter and\n+\/\/ runtime stubs. It is larger and has somewhat greater latency than\n+\/\/ the version above, which takes a constant super_klass_slot.\n+void MacroAssembler::lookup_secondary_supers_table_var(Register r_sub_klass,\n+                                                       Register r_super_klass,\n+                                                       Register temp1,\n+                                                       Register temp2,\n+                                                       Register temp3,\n+                                                       Register temp4,\n+                                                       Register result) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, temp3, temp4, result, Z_R1_scratch);\n+\n+  Label L_done, L_failure;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table_var {\");\n+\n+  const Register\n+    r_array_index = temp3,\n+    slot          = temp4, \/\/ NOTE: \"slot\" can't be Z_R0 otherwise z_sllg and z_rllg instructions below will mess up!!!!\n+    r_bitmap      = Z_R1_scratch;\n+\n+  z_llgc(slot, Address(r_super_klass, Klass::hash_slot_offset()));\n+\n+  \/\/ Initialize r_result with 0 (indicating success). If searching fails, r_result will be loaded\n+  \/\/ with 1 (failure) at the end of this method.\n+  clear_reg(result, true \/* whole_reg *\/, false \/* set_cc *\/); \/\/ result = 0\n+\n+  z_lg(r_bitmap, Address(r_sub_klass, Klass::secondary_supers_bitmap_offset()));\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  z_xilf(slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1)); \/\/ slot ^ 63 === 63 - slot (mod 64)\n+  z_sllg(r_array_index, r_bitmap, \/*d2 = *\/ 0, \/* b2 = *\/ slot);\n+\n+  testbit(r_array_index, Klass::SECONDARY_SUPERS_TABLE_SIZE - 1);\n+  branch_optimized(bcondAllZero, L_failure);\n+\n+  const Register\n+    r_array_base   = temp1,\n+    r_array_length = temp2;\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  \/\/ NOTE: Z_R1_scratch is holding bitmap (look above for r_bitmap). So let's try to save it.\n+  \/\/       On the other hand, r_array_base\/temp1 is free at current moment (look at the load operation below).\n+  pop_count_long(r_array_index, r_array_index, temp1); \/\/ kills r_array_base\/temp1 on machines older than z15\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  \/\/ We will consult the secondary-super array.\n+  z_lg(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+  z_sllg(r_array_index, r_array_index, LogBytesPerWord); \/\/ scale, r_array_index is loaded by popcnt above\n+\n+  z_cg(r_super_klass, Address(r_array_base, r_array_index));\n+  branch_optimized(bcondEqual, L_done); \/\/ found a match\n+\n+  \/\/ Note: this is a small hack:\n+  \/\/\n+  \/\/ The operation \"(slot ^ 63) === 63 - slot (mod 64)\" has already been performed above.\n+  \/\/ Since we lack a rotate-right instruction, we achieve the same effect by rotating left\n+  \/\/ by \"64 - slot\" positions. This produces the result equivalent to a right rotation by \"slot\" positions.\n+  \/\/\n+  \/\/ => initial slot value\n+  \/\/ => slot = 63 - slot        \/\/ done above with that z_xilf instruction\n+  \/\/ => slot = 64 - slot        \/\/ need to do for rotating right by \"slot\" positions\n+  \/\/ => slot = 64 - (63 - slot)\n+  \/\/ => slot = slot - 63 + 64\n+  \/\/ => slot = slot + 1\n+  \/\/\n+  \/\/ So instead of rotating-left by 64-slot times, we can, for now, just rotate left by slot+1 and it would be fine.\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 1.\n+  z_aghi(slot, 1); \/\/ slot = slot + 1\n+\n+  z_rllg(r_bitmap, r_bitmap, \/*d2=*\/ 0, \/*b2=*\/ slot);\n+  testbit(r_bitmap, 1);\n+  branch_optimized(bcondAllZero, L_failure);\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the logic we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index,\n+                                          r_bitmap, \/*temp=*\/ r_array_length, result, \/*is_stub*\/false);\n+\n+  \/\/ pass whatever we got from slow path\n+  z_bru(L_done);\n+\n+  bind(L_failure);\n+  z_lghi(result, 1); \/\/ load 1 to represent failure\n+\n+  bind(L_done);\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table_var\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                  temp1, temp2, temp3);\n+  }\n+}\n+\n@@ -3309,0 +3526,1 @@\n+                                                             Register r_temp,\n@@ -3310,2 +3528,2 @@\n-                                                             Register r_temp1) {\n-  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, r_result, r_temp1);\n+                                                             bool is_stub) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, r_result, r_temp);\n@@ -3314,1 +3532,1 @@\n-    r_array_length = r_temp1,\n+    r_array_length = r_temp,\n@@ -3317,1 +3535,3 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+  if(is_stub) {\n+    LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+  }\n@@ -3346,2 +3566,4 @@\n-    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n-    \/\/ eventually terminates.\n+    \/\/ As long as the bitmap is not completely full,\n+    \/\/ array_length == popcount(bitmap). The array_length check above\n+    \/\/ guarantees there are 0s in the bitmap, so the loop eventually\n+    \/\/ terminates.\n@@ -3420,2 +3642,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n-\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":289,"deletions":69,"binary":false,"changes":358,"status":"modified"},{"patch":"@@ -697,1 +697,1 @@\n-                                     RegisterOrConstant super_check_offset = RegisterOrConstant(-1));\n+                                     Register super_check_offset = noreg);\n@@ -709,1 +709,28 @@\n-                                     Label* L_failure);\n+                                     Label* L_failure,\n+                                     bool set_cond_codes = false);\n+\n+  void check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                            Register super_klass,\n+                                            Register temp_reg,\n+                                            Register temp2_reg,\n+                                            Label* L_success,\n+                                            Label* L_failure,\n+                                            bool set_cond_codes = false);\n+\n+  void check_klass_subtype_slow_path_table(Register sub_klass,\n+                                           Register super_klass,\n+                                           Register temp_reg,\n+                                           Register temp2_reg,\n+                                           Register temp3_reg,\n+                                           Register temp4_reg,\n+                                           Register result_reg,\n+                                           Label* L_success,\n+                                           Label* L_failure,\n+                                           bool set_cond_codes = false);\n+\n+  \/\/ If r is valid, return r.\n+  \/\/ If r is invalid, remove a register r2 from available_regs, add r2\n+  \/\/ to regs_to_push, then return r2.\n+  Register allocate_if_noreg(const Register r,\n+                             RegSetIterator<Register> &available_regs,\n+                             RegSet &regs_to_push);\n@@ -713,8 +740,17 @@\n-  void lookup_secondary_supers_table(Register r_sub_klass,\n-                                     Register r_super_klass,\n-                                     Register r_temp1,\n-                                     Register r_temp2,\n-                                     Register r_temp3,\n-                                     Register r_temp4,\n-                                     Register r_result,\n-                                     u1 super_klass_slot);\n+  \/\/ Secondary subtype checking\n+  void lookup_secondary_supers_table_var(Register sub_klass,\n+                                         Register r_super_klass,\n+                                         Register temp1,\n+                                         Register temp2,\n+                                         Register temp3,\n+                                         Register temp4,\n+                                         Register result);\n+\n+  void lookup_secondary_supers_table_const(Register r_sub_klass,\n+                                           Register r_super_klass,\n+                                           Register r_temp1,\n+                                           Register r_temp2,\n+                                           Register r_temp3,\n+                                           Register r_temp4,\n+                                           Register r_result,\n+                                           u1 super_klass_slot);\n@@ -726,0 +762,1 @@\n+                                               Register r_temp,\n@@ -727,1 +764,1 @@\n-                                               Register r_temp1);\n+                                               bool is_stub);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -9982,0 +9982,1 @@\n+  predicate(!UseSecondarySupersTable);\n@@ -9983,1 +9984,1 @@\n-  ins_cost(10 * DEFAULT_COST);\n+  ins_cost(20 * DEFAULT_COST); \/\/ slightly larger than the next version\n@@ -9994,0 +9995,24 @@\n+\/\/ Two versions of partialSubtypeCheck, both used when we need to\n+\/\/ search for a super class in the secondary supers array. The first\n+\/\/ is used when we don't know _a priori_ the class being searched\n+\/\/ for. The second, far more common, is used when we do know: this is\n+\/\/ used for instanceof, checkcast, and any case where C2 can determine\n+\/\/ it by constant propagation.\n+instruct partialSubtypeCheckVarSuper(rarg2RegP sub, rarg3RegP super,\n+                                     r11TempRegP result,\n+                                     rarg1RegP temp1, rarg4RegP temp2, rarg5RegP temp3, r10TempRegP temp4,\n+                                     flagsReg pcc) %{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL pcc, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n+  ins_cost(10 * DEFAULT_COST); \/\/ slightly larger than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+  ins_encode %{\n+    __ lookup_secondary_supers_table_var($sub$$Register, $super$$Register,\n+                                         $temp1$$Register, $temp2$$Register, $temp3$$Register, $temp4$$Register,\n+                                         $result$$Register);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\n@@ -10000,1 +10025,1 @@\n-  ins_cost(7 * DEFAULT_COST); \/\/ needs to be less than competing nodes\n+  ins_cost(5 * DEFAULT_COST); \/\/ smaller than the next version\n@@ -10006,3 +10031,3 @@\n-      __ lookup_secondary_supers_table($sub$$Register, $super$$Register,\n-                                                 $temp1$$Register, $temp2$$Register, $temp3$$Register,\n-                                                 $temp4$$Register, $result$$Register, super_klass_slot);\n+      __ lookup_secondary_supers_table_const($sub$$Register, $super$$Register,\n+                                             $temp1$$Register, $temp2$$Register, $temp3$$Register,\n+                                             $temp4$$Register, $result$$Register, super_klass_slot);\n@@ -10020,15 +10045,0 @@\n-instruct partialSubtypeCheck_vs_zero(flagsReg pcc, rarg2RegP sub, rarg3RegP super, immP0 zero,\n-                                     rarg1RegP index, rarg4RegP scratch1, rarg5RegP scratch2) %{\n-  match(Set pcc (CmpI (PartialSubtypeCheck sub super) zero));\n-  effect(KILL scratch1, KILL scratch2, KILL index);\n-  ins_cost(10 * DEFAULT_COST);\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n-  format %{ \"CALL   PartialSubtypeCheck_vs_zero\\n\" %}\n-  ins_encode %{\n-    AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());\n-    __ load_const_optimized(Z_ARG4, stub_address);\n-    __ z_basr(Z_R14, Z_ARG4);\n-  %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":30,"deletions":20,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -638,3 +638,3 @@\n-    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n-                                     r_array_base, r_array_length, r_array_index,\n-                                     r_bitmap, r_result, super_klass_index);\n+    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                           r_array_base, r_array_length, r_array_index,\n+                                           r_bitmap, r_result, super_klass_index);\n@@ -662,1 +662,1 @@\n-                                               r_array_index, r_bitmap, r_result, r_temp1);\n+                                               r_array_index, r_bitmap, r_temp1, r_result, \/* is_stub *\/ true);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}