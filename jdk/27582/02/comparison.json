{"files":[{"patch":"@@ -93,1 +93,0 @@\n-runtime\/Thread\/AsyncExceptionOnMonitorEnter.java 0000000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,6 @@\n+    \/\/ Avoid using CountDownLatch or similar objects that require unparking the\n+    \/\/ main thread. Otherwise, if the main thread is run as a virtual thread, the\n+    \/\/ async exception could be sent while the target is still executing FJP logic.\n+    public volatile boolean started = false;\n+    public volatile boolean gotMonitor = false;\n+\n@@ -48,2 +54,0 @@\n-    private static boolean firstWorker = true;\n-    private static Semaphore sem = new Semaphore(0);\n@@ -62,0 +66,1 @@\n+            started = true;\n@@ -63,4 +68,1 @@\n-                if (firstWorker) {\n-                    firstWorker = false;\n-                    sem.release();\n-                }\n+                gotMonitor = true;\n@@ -77,1 +79,0 @@\n-        boolean savedFirst = false;\n@@ -79,0 +80,1 @@\n+            started = true;\n@@ -80,1 +82,1 @@\n-            if (retCode != 0 && firstWorker) {\n+            if (retCode != 0) {\n@@ -83,6 +85,2 @@\n-            if (firstWorker) {\n-                firstWorker = false;\n-                savedFirst = true;\n-                sem.release();\n-            }\n-            Thread.sleep(1000);\n+            gotMonitor = true;\n+            Thread.sleep(500);\n@@ -90,1 +88,1 @@\n-            if (retCode != 0 && savedFirst) {\n+            if (retCode != 0) {\n@@ -136,2 +134,1 @@\n-                \/\/ Start firstWorker worker and wait until monitor is acquired\n-                firstWorker = true;\n+                \/\/ Start first worker and wait until monitor is acquired\n@@ -139,1 +136,3 @@\n-                sem.acquire();\n+                while (!worker1.gotMonitor) {\n+                    Thread.sleep(1);\n+                }\n@@ -144,1 +143,3 @@\n-                Thread.sleep(300);\n+                while (!worker2.started) {\n+                    Thread.sleep(10);\n+                }\n@@ -153,0 +154,2 @@\n+                    \/\/ Give time to throw exception\n+                    Thread.sleep(10);\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionOnMonitorEnter.java","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -52,1 +52,4 @@\n-    public CountDownLatch startSyncObj = new CountDownLatch(1);\n+    \/\/ Avoid using CountDownLatch or similar objects that require unparking the\n+    \/\/ main thread. Otherwise, if the main thread is run as a virtual thread, the\n+    \/\/ async exception could be sent while the target is still executing FJP logic.\n+    public volatile boolean started = false;\n@@ -54,1 +57,0 @@\n-    private boolean firstEntry = true;\n@@ -80,0 +82,1 @@\n+            started = true;\n@@ -93,6 +96,0 @@\n-            if (firstEntry) {\n-                \/\/ Tell main thread we have started.\n-                startSyncObj.countDown();\n-                firstEntry = false;\n-            }\n-\n@@ -131,1 +128,3 @@\n-                thread.startSyncObj.await();\n+                while (!thread.started) {\n+                    Thread.sleep(1);\n+                }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"}]}