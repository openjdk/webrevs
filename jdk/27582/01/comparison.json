{"files":[{"patch":"@@ -93,1 +93,0 @@\n-runtime\/Thread\/AsyncExceptionOnMonitorEnter.java 0000000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,6 @@\n+    \/\/ Avoid using CountDownLatch or similar objects that require unparking the\n+    \/\/ main thread. Otherwise, if the main thread is run as a virtual thread, the\n+    \/\/ async exception could be sent while the target is still executing FJP logic.\n+    public volatile boolean started = false;\n+    public volatile boolean gotMonitor = false;\n+\n@@ -48,2 +54,0 @@\n-    private static boolean firstWorker = true;\n-    private static Semaphore sem = new Semaphore(0);\n@@ -62,0 +66,1 @@\n+            started = true;\n@@ -63,4 +68,1 @@\n-                if (firstWorker) {\n-                    firstWorker = false;\n-                    sem.release();\n-                }\n+                gotMonitor = true;\n@@ -77,1 +79,0 @@\n-        boolean savedFirst = false;\n@@ -79,0 +80,1 @@\n+            started = true;\n@@ -80,1 +82,1 @@\n-            if (retCode != 0 && firstWorker) {\n+            if (retCode != 0) {\n@@ -83,5 +85,1 @@\n-            if (firstWorker) {\n-                firstWorker = false;\n-                savedFirst = true;\n-                sem.release();\n-            }\n+            gotMonitor = true;\n@@ -90,1 +88,1 @@\n-            if (retCode != 0 && savedFirst) {\n+            if (retCode != 0) {\n@@ -96,0 +94,2 @@\n+        } finally {\n+            exitRawMonitor();\n@@ -136,2 +136,1 @@\n-                \/\/ Start firstWorker worker and wait until monitor is acquired\n-                firstWorker = true;\n+                \/\/ Start first worker and wait until monitor is acquired\n@@ -139,1 +138,3 @@\n-                sem.acquire();\n+                while (!worker1.gotMonitor) {\n+                    Thread.sleep(1);\n+                }\n@@ -144,1 +145,3 @@\n-                Thread.sleep(300);\n+                while (!worker2.started) {\n+                    Thread.sleep(10);\n+                }\n@@ -146,0 +149,1 @@\n+                boolean first_iteration = true;\n@@ -148,3 +152,4 @@\n-                    if (TEST_MODE != 1) {\n-                        \/\/ Don't stop() worker1 with JVMTI raw monitors since if the monitor is\n-                        \/\/ not released worker2 will deadlock on enter\n+                    if (first_iteration || TEST_MODE != 1) {\n+                        \/\/ Don't stop() worker1 with JVMTI raw monitors more than once because\n+                        \/\/ the exception could be thrown at the finally clause before releasing\n+                        \/\/ the monitor, causing worker2 to deadlock on enter.\n@@ -152,0 +157,1 @@\n+                        first_iteration = false;\n@@ -153,0 +159,2 @@\n+                    \/\/ Give time to throw exception\n+                    Thread.sleep(10);\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionOnMonitorEnter.java","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -52,1 +52,4 @@\n-    public CountDownLatch startSyncObj = new CountDownLatch(1);\n+    \/\/ Avoid using CountDownLatch or similar objects that require unparking the\n+    \/\/ main thread. Otherwise, if the main thread is run as a virtual thread, the\n+    \/\/ async exception could be sent while the target is still executing FJP logic.\n+    public volatile boolean started = false;\n@@ -54,1 +57,0 @@\n-    private boolean firstEntry = true;\n@@ -80,0 +82,1 @@\n+            started = true;\n@@ -93,6 +96,0 @@\n-            if (firstEntry) {\n-                \/\/ Tell main thread we have started.\n-                startSyncObj.countDown();\n-                firstEntry = false;\n-            }\n-\n@@ -131,1 +128,3 @@\n-                thread.startSyncObj.await();\n+                while (!thread.started) {\n+                    Thread.sleep(1);\n+                }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"}]}