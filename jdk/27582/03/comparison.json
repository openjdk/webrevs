{"files":[{"patch":"@@ -48,0 +48,6 @@\n+    \/\/ Avoid using CountDownLatch or similar objects that require unparking the\n+    \/\/ main thread. Otherwise, if the main thread is run as a virtual thread, the\n+    \/\/ async exception could be sent while the target is still executing FJP logic.\n+    public volatile boolean started = false;\n+    public volatile boolean gotMonitor = false;\n+\n@@ -49,2 +55,0 @@\n-    private static boolean firstWorker = true;\n-    private static Semaphore sem = new Semaphore(0);\n@@ -63,0 +67,1 @@\n+            started = true;\n@@ -64,4 +69,1 @@\n-                if (firstWorker) {\n-                    firstWorker = false;\n-                    sem.release();\n-                }\n+                gotMonitor = true;\n@@ -78,1 +80,0 @@\n-        boolean savedFirst = false;\n@@ -80,0 +81,1 @@\n+            started = true;\n@@ -81,1 +83,1 @@\n-            if (retCode != 0 && firstWorker) {\n+            if (retCode != 0) {\n@@ -84,6 +86,2 @@\n-            if (firstWorker) {\n-                firstWorker = false;\n-                savedFirst = true;\n-                sem.release();\n-            }\n-            Thread.sleep(1000);\n+            gotMonitor = true;\n+            Thread.sleep(500);\n@@ -91,1 +89,1 @@\n-            if (retCode != 0 && savedFirst) {\n+            if (retCode != 0) {\n@@ -137,2 +135,1 @@\n-                \/\/ Start firstWorker worker and wait until monitor is acquired\n-                firstWorker = true;\n+                \/\/ Start first worker and wait until monitor is acquired\n@@ -140,1 +137,3 @@\n-                sem.acquire();\n+                while (!worker1.gotMonitor) {\n+                    Thread.sleep(1);\n+                }\n@@ -145,1 +144,3 @@\n-                Thread.sleep(300);\n+                while (!worker2.started) {\n+                    Thread.sleep(10);\n+                }\n@@ -154,0 +155,2 @@\n+                    \/\/ Give time to throw exception\n+                    Thread.sleep(10);\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionOnMonitorEnter.java","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -52,1 +52,4 @@\n-    public CountDownLatch startSyncObj = new CountDownLatch(1);\n+    \/\/ Avoid using CountDownLatch or similar objects that require unparking the\n+    \/\/ main thread. Otherwise, if the main thread is run as a virtual thread, the\n+    \/\/ async exception could be sent while the target is still executing FJP logic.\n+    public volatile boolean started = false;\n@@ -54,1 +57,0 @@\n-    private boolean firstEntry = true;\n@@ -80,0 +82,1 @@\n+            started = true;\n@@ -90,2 +93,2 @@\n-            Integer myLocalCount = 1;\n-            Integer myLocalCount2 = 1;\n+            int myLocalCount = 1;\n+            int myLocalCount2 = 1;\n@@ -93,7 +96,1 @@\n-            if (firstEntry) {\n-                \/\/ Tell main thread we have started.\n-                startSyncObj.countDown();\n-                firstEntry = false;\n-            }\n-\n-            while(myLocalCount > 0) {\n+            while (myLocalCount > 0) {\n@@ -131,1 +128,3 @@\n-                thread.startSyncObj.await();\n+                while (!thread.started) {\n+                    Thread.sleep(1);\n+                }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionTest.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"}]}