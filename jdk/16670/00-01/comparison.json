{"files":[{"patch":"@@ -3766,2 +3766,1 @@\n-      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-      __ sve_vector_extend($dst$$FloatRegister, size,\n+      __ sve_vector_extend($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n@@ -3787,2 +3786,1 @@\n-      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-      __ sve_vector_extend($dst$$FloatRegister, size,\n+      __ sve_vector_extend($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n@@ -3799,2 +3797,3 @@\n-    assert(Matcher::vector_element_basic_type(this) == T_LONG, \"must be\");\n-    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(bt == T_LONG, \"must be\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2324,4 +2324,6 @@\n-\n-instruct vzeroExtBtoX(vReg dst, vReg src) %{\n-  match(Set dst (VectorUCastB2X src));\n-  format %{ \"vzeroExtBtoX $dst, $src\" %}\n+dnl VECTOR_ZERO_EXTEND($1,      $2,     $3,      $4,       $5        $6,        $7,         )\n+dnl VECTOR_ZERO_EXTEND(op_name, dst_bt, src_bt,  dst_size, src_size, assertion, neon_comment)\n+define(`VECTOR_ZERO_EXTEND', `\n+instruct vzeroExt$1toX(vReg dst, vReg src) %{\n+  match(Set dst (VectorUCast`$1'2X src));\n+  format %{ \"vzeroExt$1toX $dst, $src\" %}\n@@ -2330,1 +2332,1 @@\n-    assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"must be\");\n+    assert($6, \"must be\");\n@@ -2333,3 +2335,3 @@\n-      \/\/ 4B to 4S\/4I, 8B to 8S\n-      __ neon_vector_extend($dst$$FloatRegister, bt, length_in_bytes,\n-                            $src$$FloatRegister, T_BYTE, \/* is_unsigned *\/ true);\n+      \/\/ $7\n+      __ neon_vector_extend($dst$$FloatRegister, $2, length_in_bytes,\n+                            $src$$FloatRegister, $3, \/* is_unsigned *\/ true);\n@@ -2338,3 +2340,2 @@\n-      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-      __ sve_vector_extend($dst$$FloatRegister, size,\n-                           $src$$FloatRegister, __ B, \/* is_unsigned *\/ true);\n+      __ sve_vector_extend($dst$$FloatRegister, __ $4,\n+                           $src$$FloatRegister, __ $5, \/* is_unsigned *\/ true);\n@@ -2344,41 +2345,4 @@\n-%}\n-\n-instruct vzeroExtStoX(vReg dst, vReg src) %{\n-  match(Set dst (VectorUCastS2X src));\n-  format %{ \"vzeroExtStoX $dst, $src\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    assert(bt == T_INT || bt == T_LONG, \"must be\");\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      \/\/ 4S to 4I\n-      __ neon_vector_extend($dst$$FloatRegister, T_INT, length_in_bytes,\n-                            $src$$FloatRegister, T_SHORT, \/* is_unsigned *\/ true);\n-    } else {\n-      assert(UseSVE > 0, \"must be sve\");\n-      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-      __ sve_vector_extend($dst$$FloatRegister, size,\n-                           $src$$FloatRegister, __ H, \/* is_unsigned *\/ true);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vzeroExtItoX(vReg dst, vReg src) %{\n-  match(Set dst (VectorUCastI2X src));\n-  format %{ \"vzeroExtItoX $dst, $src\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_element_basic_type(this) == T_LONG, \"must be\");\n-    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      \/\/ 2I to 2L\n-      __ neon_vector_extend($dst$$FloatRegister, T_LONG, length_in_bytes,\n-                            $src$$FloatRegister, T_INT, \/* is_unsigned *\/ true);\n-    } else {\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_vector_extend($dst$$FloatRegister, __ D,\n-                           $src$$FloatRegister, __ S, \/* is_unsigned *\/ true);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n+%}')dnl\n+VECTOR_ZERO_EXTEND(B, bt,     T_BYTE,  elemType_to_regVariant(bt), B, bt == T_SHORT || bt == T_INT || bt == T_LONG, `4B to 4S\/4I, 8B to 8S')\n+VECTOR_ZERO_EXTEND(S, T_INT,  T_SHORT, elemType_to_regVariant(bt), H, bt == T_INT || bt == T_LONG,                  `4S to 4I')\n+VECTOR_ZERO_EXTEND(I, T_LONG, T_INT,   D,                          S, bt == T_LONG,                                 `2I to 2L')\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":16,"deletions":52,"binary":false,"changes":68,"status":"modified"}]}