{"files":[{"patch":"@@ -3751,0 +3751,62 @@\n+\/\/ ---------------------------- Vector zero extend --------------------------------\n+\n+instruct vzeroExtBtoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorUCastB2X src));\n+  format %{ \"vzeroExtBtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"must be\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4B to 4S\/4I, 8B to 8S\n+      __ neon_vector_extend($dst$$FloatRegister, bt, length_in_bytes,\n+                            $src$$FloatRegister, T_BYTE, \/* is_unsigned *\/ true);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_vector_extend($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                           $src$$FloatRegister, __ B, \/* is_unsigned *\/ true);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vzeroExtStoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorUCastS2X src));\n+  format %{ \"vzeroExtStoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(bt == T_INT || bt == T_LONG, \"must be\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4S to 4I\n+      __ neon_vector_extend($dst$$FloatRegister, T_INT, length_in_bytes,\n+                            $src$$FloatRegister, T_SHORT, \/* is_unsigned *\/ true);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_vector_extend($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                           $src$$FloatRegister, __ H, \/* is_unsigned *\/ true);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vzeroExtItoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorUCastI2X src));\n+  format %{ \"vzeroExtItoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(bt == T_LONG, \"must be\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 2I to 2L\n+      __ neon_vector_extend($dst$$FloatRegister, T_LONG, length_in_bytes,\n+                            $src$$FloatRegister, T_INT, \/* is_unsigned *\/ true);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_vector_extend($dst$$FloatRegister, __ D,\n+                           $src$$FloatRegister, __ S, \/* is_unsigned *\/ true);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2323,0 +2323,27 @@\n+\/\/ ---------------------------- Vector zero extend --------------------------------\n+dnl VECTOR_ZERO_EXTEND($1,      $2,     $3,      $4,       $5        $6,        $7,         )\n+dnl VECTOR_ZERO_EXTEND(op_name, dst_bt, src_bt,  dst_size, src_size, assertion, neon_comment)\n+define(`VECTOR_ZERO_EXTEND', `\n+instruct vzeroExt$1toX(vReg dst, vReg src) %{\n+  match(Set dst (VectorUCast`$1'2X src));\n+  format %{ \"vzeroExt$1toX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert($6, \"must be\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ $7\n+      __ neon_vector_extend($dst$$FloatRegister, $2, length_in_bytes,\n+                            $src$$FloatRegister, $3, \/* is_unsigned *\/ true);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_vector_extend($dst$$FloatRegister, __ $4,\n+                           $src$$FloatRegister, __ $5, \/* is_unsigned *\/ true);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+VECTOR_ZERO_EXTEND(B, bt,     T_BYTE,  elemType_to_regVariant(bt), B, bt == T_SHORT || bt == T_INT || bt == T_LONG, `4B to 4S\/4I, 8B to 8S')\n+VECTOR_ZERO_EXTEND(S, T_INT,  T_SHORT, elemType_to_regVariant(bt), H, bt == T_INT || bt == T_LONG,                  `4S to 4I')\n+VECTOR_ZERO_EXTEND(I, T_LONG, T_INT,   D,                          S, bt == T_LONG,                                 `2I to 2L')\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1340,0 +1340,3 @@\n+typedef void (C2_MacroAssembler::* xtl_insn)(FloatRegister Vd, Assembler::SIMD_Arrangement Ta,\n+                                             FloatRegister Vn, Assembler::SIMD_Arrangement Tb);\n+\n@@ -1343,1 +1346,2 @@\n-                                           FloatRegister src, BasicType src_bt) {\n+                                           FloatRegister src, BasicType src_bt, bool is_unsigned) {\n+  xtl_insn ext = is_unsigned ? &C2_MacroAssembler::uxtl : &C2_MacroAssembler::sxtl;\n@@ -1348,1 +1352,1 @@\n-      sxtl(dst, T8H, src, T8B);\n+      (this->*ext)(dst, T8H, src, T8B);\n@@ -1352,2 +1356,2 @@\n-      sxtl(dst, T8H, src, T8B);\n-      sxtl(dst, T4S, dst, T4H);\n+      (this->*ext)(dst, T8H, src, T8B);\n+      (this->*ext)(dst, T4S, dst, T4H);\n@@ -1358,1 +1362,1 @@\n-    sxtl(dst, T4S, src, T4H);\n+    (this->*ext)(dst, T4S, src, T4H);\n@@ -1362,1 +1366,1 @@\n-    sxtl(dst, T2D, src, T2S);\n+    (this->*ext)(dst, T2D, src, T2S);\n@@ -1395,0 +1399,3 @@\n+typedef void (C2_MacroAssembler::* unpklo_insn)(FloatRegister Zd, Assembler::SIMD_RegVariant T,\n+                                                FloatRegister Zn);\n+\n@@ -1396,1 +1403,2 @@\n-                                          FloatRegister src, SIMD_RegVariant src_size) {\n+                                          FloatRegister src, SIMD_RegVariant src_size,\n+                                          bool is_unsigned) {\n@@ -1398,0 +1406,3 @@\n+\n+  unpklo_insn unpklo = is_unsigned ? &C2_MacroAssembler::sve_uunpklo : &C2_MacroAssembler::sve_sunpklo;\n+\n@@ -1401,1 +1412,1 @@\n-      sve_sunpklo(dst, H, src);\n+      (this->*unpklo)(dst, H, src);\n@@ -1404,2 +1415,2 @@\n-      sve_sunpklo(dst, H, src);\n-      sve_sunpklo(dst, S, dst);\n+      (this->*unpklo)(dst, H, src);\n+      (this->*unpklo)(dst, S, dst);\n@@ -1408,3 +1419,3 @@\n-      sve_sunpklo(dst, H, src);\n-      sve_sunpklo(dst, S, dst);\n-      sve_sunpklo(dst, D, dst);\n+      (this->*unpklo)(dst, H, src);\n+      (this->*unpklo)(dst, S, dst);\n+      (this->*unpklo)(dst, D, dst);\n@@ -1417,1 +1428,1 @@\n-      sve_sunpklo(dst, S, src);\n+      (this->*unpklo)(dst, S, src);\n@@ -1419,2 +1430,2 @@\n-      sve_sunpklo(dst, S, src);\n-      sve_sunpklo(dst, D, dst);\n+      (this->*unpklo)(dst, S, src);\n+      (this->*unpklo)(dst, D, dst);\n@@ -1423,1 +1434,1 @@\n-    sve_sunpklo(dst, D, src);\n+    (this->*unpklo)(dst, D, src);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-                          FloatRegister src, BasicType src_bt);\n+                          FloatRegister src, BasicType src_bt, bool is_unsigned = false);\n@@ -103,1 +103,1 @@\n-                         FloatRegister src, SIMD_RegVariant src_size);\n+                         FloatRegister src, SIMD_RegVariant src_size, bool is_unsigned = false);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1617,1 +1617,1 @@\n-class RoundVFNode : public VectorNode {\n+class VectorCastHF2FNode : public VectorCastNode {\n@@ -1619,2 +1619,2 @@\n-  RoundVFNode(Node* in, const TypeVect* vt) :VectorNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_FLOAT, \"must be float\");\n+  VectorCastHF2FNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n@@ -1625,1 +1625,1 @@\n-class VectorUCastB2XNode : public VectorCastNode {\n+class VectorCastF2HFNode : public VectorCastNode {\n@@ -1627,2 +1627,2 @@\n-  VectorUCastB2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be byte\");\n+  VectorCastF2HFNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_FLOAT, \"must be float\");\n@@ -1633,1 +1633,3 @@\n-class RoundVDNode : public VectorNode {\n+\/\/ So far, VectorUCastNode can only be used in Vector API unsigned extensions\n+\/\/ between integral types. E.g., extending byte to float is not supported now.\n+class VectorUCastB2XNode : public VectorCastNode {\n@@ -1635,2 +1637,5 @@\n-  RoundVDNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE, \"must be double\");\n+  VectorUCastB2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be byte\");\n+    assert(vt->element_basic_type() == T_SHORT ||\n+           vt->element_basic_type() == T_INT ||\n+           vt->element_basic_type() == T_LONG, \"must be\");\n@@ -1645,0 +1650,2 @@\n+    assert(vt->element_basic_type() == T_INT ||\n+           vt->element_basic_type() == T_LONG, \"must be\");\n@@ -1649,1 +1656,1 @@\n-class VectorCastHF2FNode : public VectorCastNode {\n+class VectorUCastI2XNode : public VectorCastNode {\n@@ -1651,2 +1658,3 @@\n-  VectorCastHF2FNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  VectorUCastI2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_INT, \"must be int\");\n+    assert(vt->element_basic_type() == T_LONG, \"must be\");\n@@ -1657,1 +1665,1 @@\n-class VectorCastF2HFNode : public VectorCastNode {\n+class RoundVFNode : public VectorNode {\n@@ -1659,1 +1667,1 @@\n-  VectorCastF2HFNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+  RoundVFNode(Node* in, const TypeVect* vt) :VectorNode(in, vt) {\n@@ -1665,1 +1673,1 @@\n-class VectorUCastI2XNode : public VectorCastNode {\n+class RoundVDNode : public VectorNode {\n@@ -1667,2 +1675,2 @@\n-  VectorUCastI2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_INT, \"must be int\");\n+  RoundVDNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE, \"must be double\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,1 +231,68 @@\n-            makePair(DSPEC512, FSPEC256)\n+            makePair(DSPEC512, FSPEC256),\n+\n+            makePair(BSPEC64, SSPEC64, true),\n+            makePair(BSPEC64, SSPEC128, true),\n+            makePair(BSPEC64, SSPEC256, true),\n+            makePair(BSPEC64, SSPEC512, true),\n+            makePair(BSPEC64, ISPEC128, true),\n+            makePair(BSPEC64, ISPEC256, true),\n+            makePair(BSPEC64, ISPEC512, true),\n+            makePair(BSPEC64, LSPEC256, true),\n+            makePair(BSPEC64, LSPEC512, true),\n+            makePair(BSPEC128, SSPEC64, true),\n+            makePair(BSPEC128, SSPEC128, true),\n+            makePair(BSPEC128, SSPEC256, true),\n+            makePair(BSPEC128, SSPEC512, true),\n+            makePair(BSPEC128, ISPEC128, true),\n+            makePair(BSPEC128, ISPEC256, true),\n+            makePair(BSPEC128, ISPEC512, true),\n+            makePair(BSPEC128, LSPEC256, true),\n+            makePair(BSPEC128, LSPEC512, true),\n+            makePair(BSPEC256, SSPEC64, true),\n+            makePair(BSPEC256, SSPEC128, true),\n+            makePair(BSPEC256, SSPEC256, true),\n+            makePair(BSPEC256, SSPEC512, true),\n+            makePair(BSPEC256, ISPEC128, true),\n+            makePair(BSPEC256, ISPEC256, true),\n+            makePair(BSPEC256, ISPEC512, true),\n+            makePair(BSPEC256, LSPEC256, true),\n+            makePair(BSPEC256, LSPEC512, true),\n+            makePair(BSPEC512, SSPEC64, true),\n+            makePair(BSPEC512, SSPEC128, true),\n+            makePair(BSPEC512, SSPEC256, true),\n+            makePair(BSPEC512, SSPEC512, true),\n+            makePair(BSPEC512, ISPEC128, true),\n+            makePair(BSPEC512, ISPEC256, true),\n+            makePair(BSPEC512, ISPEC512, true),\n+            makePair(BSPEC512, LSPEC256, true),\n+            makePair(BSPEC512, LSPEC512, true),\n+\n+            makePair(SSPEC64, ISPEC128, true),\n+            makePair(SSPEC64, ISPEC256, true),\n+            makePair(SSPEC64, ISPEC512, true),\n+            makePair(SSPEC64, LSPEC256, true),\n+            makePair(SSPEC64, LSPEC512, true),\n+            makePair(SSPEC128, ISPEC128, true),\n+            makePair(SSPEC128, ISPEC256, true),\n+            makePair(SSPEC128, ISPEC512, true),\n+            makePair(SSPEC128, LSPEC256, true),\n+            makePair(SSPEC128, LSPEC512, true),\n+            makePair(SSPEC256, ISPEC128, true),\n+            makePair(SSPEC256, ISPEC256, true),\n+            makePair(SSPEC256, ISPEC512, true),\n+            makePair(SSPEC256, LSPEC256, true),\n+            makePair(SSPEC256, LSPEC512, true),\n+            makePair(SSPEC512, ISPEC128, true),\n+            makePair(SSPEC512, ISPEC256, true),\n+            makePair(SSPEC512, ISPEC512, true),\n+            makePair(SSPEC512, LSPEC256, true),\n+            makePair(SSPEC512, LSPEC512, true),\n+\n+            makePair(ISPEC64, LSPEC128, true),\n+            makePair(ISPEC64, LSPEC256, true),\n+            makePair(ISPEC128, LSPEC128, true),\n+            makePair(ISPEC128, LSPEC256, true),\n+            makePair(ISPEC256, LSPEC128, true),\n+            makePair(ISPEC256, LSPEC256, true),\n+            makePair(ISPEC512, LSPEC128, true),\n+            makePair(ISPEC512, LSPEC256, true)\n@@ -260,1 +327,11 @@\n-            makePair(DSPEC128, FSPEC64)\n+            makePair(DSPEC128, FSPEC64),\n+\n+            makePair(BSPEC64, SSPEC64, true),\n+            makePair(BSPEC64, SSPEC128, true),\n+            makePair(BSPEC64, ISPEC128, true),\n+            makePair(BSPEC128, SSPEC64, true),\n+            makePair(BSPEC128, SSPEC128, true),\n+            makePair(BSPEC128, ISPEC128, true),\n+            makePair(SSPEC64, ISPEC128, true),\n+            makePair(SSPEC128, ISPEC128, true),\n+            makePair(ISPEC64, LSPEC128, true)\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/TestCastMethods.java","additions":80,"deletions":3,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/\/\n+\/\/ Copyright (c) 2023, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorZeroExtend {\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_PREFERRED;\n+    private static final int LENGTH = 128;\n+    private static final Random RD = new Random();\n+    private static byte[] ba;\n+    private static short[] sa;\n+    private static int[] ia;\n+    private static long[] la;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        la = new long[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = (byte) RD.nextInt();\n+            sa[i] = (short) RD.nextInt();\n+            ia[i] = RD.nextInt();\n+            la[i] = RD.nextLong();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte2Short() {\n+      for (int i = 0; i < B_SPECIES.loopBound(LENGTH); i += B_SPECIES.length()) {\n+          ByteVector va = ByteVector.fromArray(B_SPECIES, ba, i);\n+          ShortVector vb = (ShortVector) va.convertShape(ZERO_EXTEND_B2S, S_SPECIES, 0);\n+          vb.intoArray(sa, 0);\n+      }\n+    }\n+\n+    @Benchmark\n+    public void byte2Int() {\n+      for (int i = 0; i < B_SPECIES.loopBound(LENGTH); i += B_SPECIES.length()) {\n+          ByteVector va = ByteVector.fromArray(B_SPECIES, ba, i);\n+          IntVector vb = (IntVector) va.convertShape(ZERO_EXTEND_B2I, I_SPECIES, 0);\n+          vb.intoArray(ia, 0);\n+      }\n+    }\n+\n+    @Benchmark\n+    public void byte2Long() {\n+      for (int i = 0; i < B_SPECIES.loopBound(LENGTH); i += B_SPECIES.length()) {\n+          ByteVector va = ByteVector.fromArray(B_SPECIES, ba, i);\n+          LongVector vb = (LongVector) va.convertShape(ZERO_EXTEND_B2L, L_SPECIES, 0);\n+          vb.intoArray(la, 0);\n+      }\n+    }\n+\n+    @Benchmark\n+    public void short2Int() {\n+      for (int i = 0; i < S_SPECIES.loopBound(LENGTH); i += S_SPECIES.length()) {\n+          ShortVector va = ShortVector.fromArray(S_SPECIES, sa, i);\n+          IntVector vb = (IntVector) va.convertShape(ZERO_EXTEND_S2I, I_SPECIES, 0);\n+          vb.intoArray(ia, 0);\n+      }\n+    }\n+\n+    @Benchmark\n+    public void short2Long() {\n+      for (int i = 0; i < S_SPECIES.loopBound(LENGTH); i += S_SPECIES.length()) {\n+          ShortVector va = ShortVector.fromArray(S_SPECIES, sa, i);\n+          LongVector vb = (LongVector) va.convertShape(ZERO_EXTEND_S2L, L_SPECIES, 0);\n+          vb.intoArray(la, 0);\n+      }\n+    }\n+\n+    @Benchmark\n+    public void int2Long() {\n+      for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+          IntVector va = IntVector.fromArray(I_SPECIES, ia, i);\n+          LongVector vb = (LongVector) va.convertShape(ZERO_EXTEND_I2L, L_SPECIES, 0);\n+          vb.intoArray(la, 0);\n+      }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorZeroExtend.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}