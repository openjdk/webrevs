{"files":[{"patch":"@@ -3751,0 +3751,62 @@\n+\/\/ ---------------------------- Vector zero extend --------------------------------\n+\n+instruct vzeroExtBtoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorUCastB2X src));\n+  format %{ \"vzeroExtBtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"must be\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4B to 4S\/4I, 8B to 8S\n+      __ neon_vector_extend($dst$$FloatRegister, bt, length_in_bytes,\n+                            $src$$FloatRegister, T_BYTE, \/* is_unsigned *\/ true);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_vector_extend($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                           $src$$FloatRegister, __ B, \/* is_unsigned *\/ true);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vzeroExtStoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorUCastS2X src));\n+  format %{ \"vzeroExtStoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(bt == T_INT || bt == T_LONG, \"must be\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4S to 4I\n+      __ neon_vector_extend($dst$$FloatRegister, T_INT, length_in_bytes,\n+                            $src$$FloatRegister, T_SHORT, \/* is_unsigned *\/ true);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_vector_extend($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                           $src$$FloatRegister, __ H, \/* is_unsigned *\/ true);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vzeroExtItoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorUCastI2X src));\n+  format %{ \"vzeroExtItoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(bt == T_LONG, \"must be\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 2I to 2L\n+      __ neon_vector_extend($dst$$FloatRegister, T_LONG, length_in_bytes,\n+                            $src$$FloatRegister, T_INT, \/* is_unsigned *\/ true);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_vector_extend($dst$$FloatRegister, __ D,\n+                           $src$$FloatRegister, __ S, \/* is_unsigned *\/ true);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2323,0 +2323,27 @@\n+\/\/ ---------------------------- Vector zero extend --------------------------------\n+dnl VECTOR_ZERO_EXTEND($1,      $2,     $3,      $4,       $5        $6,        $7,         )\n+dnl VECTOR_ZERO_EXTEND(op_name, dst_bt, src_bt,  dst_size, src_size, assertion, neon_comment)\n+define(`VECTOR_ZERO_EXTEND', `\n+instruct vzeroExt$1toX(vReg dst, vReg src) %{\n+  match(Set dst (VectorUCast`$1'2X src));\n+  format %{ \"vzeroExt$1toX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert($6, \"must be\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ $7\n+      __ neon_vector_extend($dst$$FloatRegister, $2, length_in_bytes,\n+                            $src$$FloatRegister, $3, \/* is_unsigned *\/ true);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_vector_extend($dst$$FloatRegister, __ $4,\n+                           $src$$FloatRegister, __ $5, \/* is_unsigned *\/ true);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+VECTOR_ZERO_EXTEND(B, bt,     T_BYTE,  elemType_to_regVariant(bt), B, bt == T_SHORT || bt == T_INT || bt == T_LONG, `4B to 4S\/4I, 8B to 8S')\n+VECTOR_ZERO_EXTEND(S, T_INT,  T_SHORT, elemType_to_regVariant(bt), H, bt == T_INT || bt == T_LONG,                  `4S to 4I')\n+VECTOR_ZERO_EXTEND(I, T_LONG, T_INT,   D,                          S, bt == T_LONG,                                 `2I to 2L')\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2199,2 +2199,0 @@\n-  enum sign_kind { SIGNED, UNSIGNED };\n-\n@@ -2202,21 +2200,1 @@\n-  void _xcvtf_scalar_integer(sign_kind sign, unsigned sz,\n-                             FloatRegister Rd, FloatRegister Rn) {\n-    starti;\n-    f(0b01, 31, 30), f(sign == SIGNED ? 0 : 1, 29);\n-    f(0b111100, 27, 23), f((sz >> 1) & 1, 22), f(0b100001110110, 21, 10);\n-    rf(Rn, 5), rf(Rd, 0);\n-  }\n-\n-public:\n-#define INSN(NAME, sign, sz)                        \\\n-  void NAME(FloatRegister Rd, FloatRegister Rn) {   \\\n-    _xcvtf_scalar_integer(sign, sz, Rd, Rn);        \\\n-  }\n-\n-  INSN(scvtfs, SIGNED, 0);\n-  INSN(scvtfd, SIGNED, 1);\n-\n-#undef INSN\n-\n-private:\n-  void _xcvtf_vector_integer(sign_kind sign, SIMD_Arrangement T,\n+  void _xcvtf_vector_integer(bool is_unsigned, SIMD_Arrangement T,\n@@ -2226,1 +2204,1 @@\n-    f(0, 31), f(T & 1, 30), f(sign == SIGNED ? 0 : 1, 29);\n+    f(0, 31), f(T & 1, 30), f(is_unsigned ? 1 : 0, 29);\n@@ -2232,0 +2210,1 @@\n+\n@@ -2233,1 +2212,1 @@\n-    _xcvtf_vector_integer(SIGNED, T, Rd, Rn);\n+    _xcvtf_vector_integer(\/* is_unsigned *\/ false, T, Rd, Rn);\n@@ -2994,2 +2973,2 @@\n-private:\n-  void _xshll(sign_kind sign, FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, SIMD_Arrangement Tb, int shift) {\n+protected:\n+  void _xshll(bool is_unsigned, FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, SIMD_Arrangement Tb, int shift) {\n@@ -3005,1 +2984,1 @@\n-    f(0, 31), f(Tb & 1, 30), f(sign == SIGNED ? 0 : 1, 29), f(0b011110, 28, 23);\n+    f(0, 31), f(Tb & 1, 30), f(is_unsigned ? 1 : 0, 29), f(0b011110, 28, 23);\n@@ -3013,1 +2992,1 @@\n-    _xshll(UNSIGNED, Vd, Ta, Vn, Tb, shift);\n+    _xshll(\/* is_unsigned *\/ true, Vd, Ta, Vn, Tb, shift);\n@@ -3018,1 +2997,1 @@\n-    _xshll(UNSIGNED, Vd, Ta, Vn, Tb, shift);\n+    _xshll(\/* is_unsigned *\/ true, Vd, Ta, Vn, Tb, shift);\n@@ -3027,1 +3006,1 @@\n-    _xshll(SIGNED, Vd, Ta, Vn, Tb, shift);\n+    _xshll(\/* is_unsigned *\/ false, Vd, Ta, Vn, Tb, shift);\n@@ -3032,1 +3011,1 @@\n-    _xshll(SIGNED, Vd, Ta, Vn, Tb, shift);\n+    _xshll(\/* is_unsigned *\/ false, Vd, Ta, Vn, Tb, shift);\n@@ -3865,6 +3844,13 @@\n-#define INSN(NAME, op) \\\n-  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn) { \\\n-    starti;                                                          \\\n-    assert(T != B && T != Q, \"invalid size\");                        \\\n-    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1100, 21, 18);          \\\n-    f(op, 17, 16), f(0b001110, 15, 10), rf(Zn, 5), rf(Zd, 0);        \\\n+protected:\n+  void _sve_xunpk(bool is_unsigned, bool is_high, FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn) {\n+    starti;\n+    assert(T != B && T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1100, 21, 18);\n+    f(is_unsigned ? 1 : 0, 17), f(is_high ? 1 : 0, 16),\n+    f(0b001110, 15, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+public:\n+#define INSN(NAME, is_unsigned, is_high)                                  \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn) {      \\\n+    _sve_xunpk(is_unsigned, is_high, Zd, T, Zn);                          \\\n@@ -3873,4 +3859,4 @@\n-  INSN(sve_uunpkhi, 0b11); \/\/ Signed unpack and extend half of vector - high half\n-  INSN(sve_uunpklo, 0b10); \/\/ Signed unpack and extend half of vector - low half\n-  INSN(sve_sunpkhi, 0b01); \/\/ Unsigned unpack and extend half of vector - high half\n-  INSN(sve_sunpklo, 0b00); \/\/ Unsigned unpack and extend half of vector - low half\n+  INSN(sve_uunpkhi, true,  true ); \/\/ Unsigned unpack and extend half of vector - high half\n+  INSN(sve_uunpklo, true,  false); \/\/ Unsigned unpack and extend half of vector - low half\n+  INSN(sve_sunpkhi, false, true ); \/\/ Signed unpack and extend half of vector - high half\n+  INSN(sve_sunpklo, false, false); \/\/ Signed unpack and extend half of vector - low half\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":28,"deletions":42,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1343,1 +1343,1 @@\n-                                           FloatRegister src, BasicType src_bt) {\n+                                           FloatRegister src, BasicType src_bt, bool is_unsigned) {\n@@ -1347,2 +1347,1 @@\n-      assert(dst_vlen_in_bytes == 8 || dst_vlen_in_bytes == 16, \"unsupported\");\n-      sxtl(dst, T8H, src, T8B);\n+      _xshll(is_unsigned, dst, T8H, src, T8B, 0);\n@@ -1352,2 +1351,2 @@\n-      sxtl(dst, T8H, src, T8B);\n-      sxtl(dst, T4S, dst, T4H);\n+      _xshll(is_unsigned, dst, T8H, src, T8B, 0);\n+      _xshll(is_unsigned, dst, T4S, dst, T4H, 0);\n@@ -1358,1 +1357,1 @@\n-    sxtl(dst, T4S, src, T4H);\n+    _xshll(is_unsigned, dst, T4S, src, T4H, 0);\n@@ -1362,1 +1361,1 @@\n-    sxtl(dst, T2D, src, T2S);\n+    _xshll(is_unsigned, dst, T2D, src, T2S, 0);\n@@ -1396,1 +1395,2 @@\n-                                          FloatRegister src, SIMD_RegVariant src_size) {\n+                                          FloatRegister src, SIMD_RegVariant src_size,\n+                                          bool is_unsigned) {\n@@ -1398,0 +1398,1 @@\n+\n@@ -1401,1 +1402,1 @@\n-      sve_sunpklo(dst, H, src);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, H, src);\n@@ -1404,2 +1405,2 @@\n-      sve_sunpklo(dst, H, src);\n-      sve_sunpklo(dst, S, dst);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, H, src);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, S, dst);\n@@ -1408,3 +1409,3 @@\n-      sve_sunpklo(dst, H, src);\n-      sve_sunpklo(dst, S, dst);\n-      sve_sunpklo(dst, D, dst);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, H, src);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, S, dst);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, D, dst);\n@@ -1417,1 +1418,1 @@\n-      sve_sunpklo(dst, S, src);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, S, src);\n@@ -1419,2 +1420,2 @@\n-      sve_sunpklo(dst, S, src);\n-      sve_sunpklo(dst, D, dst);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, S, src);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, D, dst);\n@@ -1423,1 +1424,1 @@\n-    sve_sunpklo(dst, D, src);\n+    _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, D, src);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-                          FloatRegister src, BasicType src_bt);\n+                          FloatRegister src, BasicType src_bt, bool is_unsigned = false);\n@@ -103,1 +103,1 @@\n-                         FloatRegister src, SIMD_RegVariant src_size);\n+                         FloatRegister src, SIMD_RegVariant src_size, bool is_unsigned = false);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1617,1 +1617,1 @@\n-class RoundVFNode : public VectorNode {\n+class VectorCastHF2FNode : public VectorCastNode {\n@@ -1619,2 +1619,2 @@\n-  RoundVFNode(Node* in, const TypeVect* vt) :VectorNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_FLOAT, \"must be float\");\n+  VectorCastHF2FNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n@@ -1625,1 +1625,1 @@\n-class VectorUCastB2XNode : public VectorCastNode {\n+class VectorCastF2HFNode : public VectorCastNode {\n@@ -1627,2 +1627,2 @@\n-  VectorUCastB2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be byte\");\n+  VectorCastF2HFNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_FLOAT, \"must be float\");\n@@ -1633,1 +1633,3 @@\n-class RoundVDNode : public VectorNode {\n+\/\/ So far, VectorUCastNode can only be used in Vector API unsigned extensions\n+\/\/ between integral types. E.g., extending byte to float is not supported now.\n+class VectorUCastB2XNode : public VectorCastNode {\n@@ -1635,2 +1637,5 @@\n-  RoundVDNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE, \"must be double\");\n+  VectorUCastB2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be byte\");\n+    assert(vt->element_basic_type() == T_SHORT ||\n+           vt->element_basic_type() == T_INT ||\n+           vt->element_basic_type() == T_LONG, \"must be\");\n@@ -1645,0 +1650,2 @@\n+    assert(vt->element_basic_type() == T_INT ||\n+           vt->element_basic_type() == T_LONG, \"must be\");\n@@ -1649,1 +1656,1 @@\n-class VectorCastHF2FNode : public VectorCastNode {\n+class VectorUCastI2XNode : public VectorCastNode {\n@@ -1651,2 +1658,3 @@\n-  VectorCastHF2FNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  VectorUCastI2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_INT, \"must be int\");\n+    assert(vt->element_basic_type() == T_LONG, \"must be\");\n@@ -1657,1 +1665,1 @@\n-class VectorCastF2HFNode : public VectorCastNode {\n+class RoundVFNode : public VectorNode {\n@@ -1659,1 +1667,1 @@\n-  VectorCastF2HFNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+  RoundVFNode(Node* in, const TypeVect* vt) :VectorNode(in, vt) {\n@@ -1665,1 +1673,1 @@\n-class VectorUCastI2XNode : public VectorCastNode {\n+class RoundVDNode : public VectorNode {\n@@ -1667,2 +1675,2 @@\n-  VectorUCastI2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_INT, \"must be int\");\n+  RoundVDNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE, \"must be double\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,1 +231,68 @@\n-            makePair(DSPEC512, FSPEC256)\n+            makePair(DSPEC512, FSPEC256),\n+\n+            makePair(BSPEC64, SSPEC64, true),\n+            makePair(BSPEC64, SSPEC128, true),\n+            makePair(BSPEC64, SSPEC256, true),\n+            makePair(BSPEC64, SSPEC512, true),\n+            makePair(BSPEC64, ISPEC128, true),\n+            makePair(BSPEC64, ISPEC256, true),\n+            makePair(BSPEC64, ISPEC512, true),\n+            makePair(BSPEC64, LSPEC256, true),\n+            makePair(BSPEC64, LSPEC512, true),\n+            makePair(BSPEC128, SSPEC64, true),\n+            makePair(BSPEC128, SSPEC128, true),\n+            makePair(BSPEC128, SSPEC256, true),\n+            makePair(BSPEC128, SSPEC512, true),\n+            makePair(BSPEC128, ISPEC128, true),\n+            makePair(BSPEC128, ISPEC256, true),\n+            makePair(BSPEC128, ISPEC512, true),\n+            makePair(BSPEC128, LSPEC256, true),\n+            makePair(BSPEC128, LSPEC512, true),\n+            makePair(BSPEC256, SSPEC64, true),\n+            makePair(BSPEC256, SSPEC128, true),\n+            makePair(BSPEC256, SSPEC256, true),\n+            makePair(BSPEC256, SSPEC512, true),\n+            makePair(BSPEC256, ISPEC128, true),\n+            makePair(BSPEC256, ISPEC256, true),\n+            makePair(BSPEC256, ISPEC512, true),\n+            makePair(BSPEC256, LSPEC256, true),\n+            makePair(BSPEC256, LSPEC512, true),\n+            makePair(BSPEC512, SSPEC64, true),\n+            makePair(BSPEC512, SSPEC128, true),\n+            makePair(BSPEC512, SSPEC256, true),\n+            makePair(BSPEC512, SSPEC512, true),\n+            makePair(BSPEC512, ISPEC128, true),\n+            makePair(BSPEC512, ISPEC256, true),\n+            makePair(BSPEC512, ISPEC512, true),\n+            makePair(BSPEC512, LSPEC256, true),\n+            makePair(BSPEC512, LSPEC512, true),\n+\n+            makePair(SSPEC64, ISPEC128, true),\n+            makePair(SSPEC64, ISPEC256, true),\n+            makePair(SSPEC64, ISPEC512, true),\n+            makePair(SSPEC64, LSPEC256, true),\n+            makePair(SSPEC64, LSPEC512, true),\n+            makePair(SSPEC128, ISPEC128, true),\n+            makePair(SSPEC128, ISPEC256, true),\n+            makePair(SSPEC128, ISPEC512, true),\n+            makePair(SSPEC128, LSPEC256, true),\n+            makePair(SSPEC128, LSPEC512, true),\n+            makePair(SSPEC256, ISPEC128, true),\n+            makePair(SSPEC256, ISPEC256, true),\n+            makePair(SSPEC256, ISPEC512, true),\n+            makePair(SSPEC256, LSPEC256, true),\n+            makePair(SSPEC256, LSPEC512, true),\n+            makePair(SSPEC512, ISPEC128, true),\n+            makePair(SSPEC512, ISPEC256, true),\n+            makePair(SSPEC512, ISPEC512, true),\n+            makePair(SSPEC512, LSPEC256, true),\n+            makePair(SSPEC512, LSPEC512, true),\n+\n+            makePair(ISPEC64, LSPEC128, true),\n+            makePair(ISPEC64, LSPEC256, true),\n+            makePair(ISPEC128, LSPEC128, true),\n+            makePair(ISPEC128, LSPEC256, true),\n+            makePair(ISPEC256, LSPEC128, true),\n+            makePair(ISPEC256, LSPEC256, true),\n+            makePair(ISPEC512, LSPEC128, true),\n+            makePair(ISPEC512, LSPEC256, true)\n@@ -260,1 +327,11 @@\n-            makePair(DSPEC128, FSPEC64)\n+            makePair(DSPEC128, FSPEC64),\n+\n+            makePair(BSPEC64, SSPEC64, true),\n+            makePair(BSPEC64, SSPEC128, true),\n+            makePair(BSPEC64, ISPEC128, true),\n+            makePair(BSPEC128, SSPEC64, true),\n+            makePair(BSPEC128, SSPEC128, true),\n+            makePair(BSPEC128, ISPEC128, true),\n+            makePair(SSPEC64, ISPEC128, true),\n+            makePair(SSPEC128, ISPEC128, true),\n+            makePair(ISPEC64, LSPEC128, true)\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/TestCastMethods.java","additions":80,"deletions":3,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/\/\n+\/\/ Copyright (c) 2023, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorZeroExtend {\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_PREFERRED;\n+    private static final int LENGTH = 128;\n+    private static final Random RD = new Random();\n+    private static byte[] ba;\n+    private static short[] sa;\n+    private static int[] ia;\n+    private static long[] la;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        la = new long[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = (byte) RD.nextInt();\n+            sa[i] = (short) RD.nextInt();\n+            ia[i] = RD.nextInt();\n+            la[i] = RD.nextLong();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte2Short() {\n+      for (int i = 0; i < B_SPECIES.loopBound(LENGTH); i += B_SPECIES.length()) {\n+          ByteVector va = ByteVector.fromArray(B_SPECIES, ba, i);\n+          ShortVector vb = (ShortVector) va.convertShape(ZERO_EXTEND_B2S, S_SPECIES, 0);\n+          vb.intoArray(sa, 0);\n+      }\n+    }\n+\n+    @Benchmark\n+    public void byte2Int() {\n+      for (int i = 0; i < B_SPECIES.loopBound(LENGTH); i += B_SPECIES.length()) {\n+          ByteVector va = ByteVector.fromArray(B_SPECIES, ba, i);\n+          IntVector vb = (IntVector) va.convertShape(ZERO_EXTEND_B2I, I_SPECIES, 0);\n+          vb.intoArray(ia, 0);\n+      }\n+    }\n+\n+    @Benchmark\n+    public void byte2Long() {\n+      for (int i = 0; i < B_SPECIES.loopBound(LENGTH); i += B_SPECIES.length()) {\n+          ByteVector va = ByteVector.fromArray(B_SPECIES, ba, i);\n+          LongVector vb = (LongVector) va.convertShape(ZERO_EXTEND_B2L, L_SPECIES, 0);\n+          vb.intoArray(la, 0);\n+      }\n+    }\n+\n+    @Benchmark\n+    public void short2Int() {\n+      for (int i = 0; i < S_SPECIES.loopBound(LENGTH); i += S_SPECIES.length()) {\n+          ShortVector va = ShortVector.fromArray(S_SPECIES, sa, i);\n+          IntVector vb = (IntVector) va.convertShape(ZERO_EXTEND_S2I, I_SPECIES, 0);\n+          vb.intoArray(ia, 0);\n+      }\n+    }\n+\n+    @Benchmark\n+    public void short2Long() {\n+      for (int i = 0; i < S_SPECIES.loopBound(LENGTH); i += S_SPECIES.length()) {\n+          ShortVector va = ShortVector.fromArray(S_SPECIES, sa, i);\n+          LongVector vb = (LongVector) va.convertShape(ZERO_EXTEND_S2L, L_SPECIES, 0);\n+          vb.intoArray(la, 0);\n+      }\n+    }\n+\n+    @Benchmark\n+    public void int2Long() {\n+      for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+          IntVector va = IntVector.fromArray(I_SPECIES, ia, i);\n+          LongVector vb = (LongVector) va.convertShape(ZERO_EXTEND_I2L, L_SPECIES, 0);\n+          vb.intoArray(la, 0);\n+      }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorZeroExtend.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}