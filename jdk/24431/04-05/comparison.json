{"files":[{"patch":"@@ -1491,1 +1491,1 @@\n-  evex_prefix_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x03, no_flags);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x03, no_flags);\n@@ -1728,1 +1728,1 @@\n-  evex_prefix_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x23, no_flags);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x23, no_flags);\n@@ -2702,1 +2702,1 @@\n-  evex_prefix_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, (unsigned char)0xAF, no_flags, true \/* is_map1 *\/);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, (unsigned char)0xAF, no_flags, true \/* is_map1 *\/);\n@@ -4616,1 +4616,1 @@\n-  evex_prefix_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x0B, no_flags);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x0B, no_flags);\n@@ -7281,1 +7281,1 @@\n-  evex_prefix_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x2B, no_flags);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x2B, no_flags);\n@@ -7606,1 +7606,1 @@\n-  evex_prefix_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x33, no_flags);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x33, no_flags);\n@@ -7647,1 +7647,1 @@\n-  evex_prefix_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x32, no_flags, false \/* is_map1 *\/, EVEX_8bit);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_8bit, 0x32, no_flags);\n@@ -7676,1 +7676,1 @@\n-  evex_prefix_ndd_and_int8(dst, src1, src2, VEX_SIMD_66, VEX_OPCODE_0F_3C, 0x33, no_flags, false \/* is_map1 *\/, EVEX_16bit);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_66, VEX_OPCODE_0F_3C, EVEX_16bit, 0x33, no_flags);\n@@ -13646,9 +13646,1 @@\n-void Assembler::evex_prefix_ndd_and_int8_common(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc, int b1, bool no_flags, int input_size_in_bits, bool vex_w) {\n-  InstructionAttr attributes(AVX_128bit, vex_w, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, input_size_in_bits);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), pre, opc, &attributes, no_flags);\n-  emit_int8(b1);\n-  emit_operand(src1, src2, 0);\n-}\n-\n-void Assembler::evex_prefix_ndd_and_int8(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc, int b1, bool no_flags, bool is_map1, int input_size_in_bits) {\n+void Assembler::evex_ndd_and_int8(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc, int input_size_in_bits, int b1, bool no_flags, bool is_map1) {\n@@ -13656,2 +13648,10 @@\n-    if (input_size_in_bits == EVEX_16bit) {\n-      emit_int8(0x66);\n+    if (input_size_in_bits == EVEX_64bit) {\n+      emit_prefix_and_int8(get_prefixq(src2, dst, is_map1), b1);\n+    }\n+    else {\n+      \/\/ For 32-bit, 16-bit and 8-bit\n+      if (input_size_in_bits == EVEX_16bit) {\n+        emit_int8(0x66);\n+      }\n+      prefix(src2, dst, false, is_map1);\n+      emit_int8(b1);\n@@ -13659,2 +13659,0 @@\n-    prefix(src2, dst, false, is_map1);\n-    emit_int8(b1);\n@@ -13664,2 +13662,0 @@\n-  evex_prefix_ndd_and_int8_common(dst, src1, src2, pre, opc, b1, no_flags, input_size_in_bits, \/* vex_w *\/ false);\n-}\n@@ -13667,7 +13663,6 @@\n-void Assembler::evex_prefixq_ndd_and_int8(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc, int b1, bool no_flags, bool is_map1) {\n-  if (is_demotable(no_flags, dst->encoding(), src1->encoding())) {\n-    emit_prefix_and_int8(get_prefixq(src2, dst, is_map1), b1);\n-    emit_operand(dst, src2, 0);\n-    return;\n-  }\n-  evex_prefix_ndd_and_int8_common(dst, src1, src2, pre, opc, b1, no_flags, EVEX_64bit, \/* vex_w *\/ true);\n+  bool vex_w = (input_size_in_bits == EVEX_64bit) ? true : false;\n+  InstructionAttr attributes(AVX_128bit, vex_w, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, input_size_in_bits);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), pre, opc, &attributes, no_flags);\n+  emit_int8(b1);\n+  emit_operand(src1, src2, 0);\n@@ -15301,1 +15296,1 @@\n-  evex_prefixq_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x03, no_flags);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x03, no_flags);\n@@ -15400,1 +15395,1 @@\n-  evex_prefixq_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x23, no_flags);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x23, no_flags);\n@@ -15885,1 +15880,1 @@\n-  evex_prefixq_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, (unsigned char)0xAF, no_flags, true \/* is_map1 *\/);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, (unsigned char)0xAF, no_flags, true \/* is_map1 *\/);\n@@ -16304,1 +16299,1 @@\n-  evex_prefixq_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x0B, no_flags);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x0B, no_flags);\n@@ -16989,1 +16984,1 @@\n-  evex_prefixq_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x2B, no_flags);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x2B, no_flags);\n@@ -17078,1 +17073,1 @@\n-  evex_prefixq_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, 0x33, no_flags);\n+  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x33, no_flags);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":31,"deletions":36,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -800,8 +800,2 @@\n-  void evex_prefix_ndd_and_int8_common(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc,\n-                       int b1, bool no_flags, int input_size_in_bits, bool vex_w);\n-\n-  void evex_prefix_ndd_and_int8(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc,\n-                       int b1, bool no_flags = false, bool is_map1 = false, int input_size_in_bits = EVEX_32bit);\n-\n-  void evex_prefixq_ndd_and_int8(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc,\n-                       int b1, bool no_flags = false, bool is_map1 = false);\n+  void evex_ndd_and_int8(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc,\n+                       int input_size_in_bits, int b1, bool no_flags = false, bool is_map1 = false);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -8541,1 +8541,0 @@\n-  predicate(!UseAPX);\n@@ -8553,14 +8552,0 @@\n-instruct mulI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulI src1 src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eimull($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"}]}