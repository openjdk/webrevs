{"files":[{"patch":"@@ -1414,2 +1414,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_arith_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags, 0x81, 0xC0, src, imm32);\n+  evex_prefix_arith(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x81, 0xC0, no_flags);\n@@ -1427,1 +1426,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x03, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x03, no_flags);\n@@ -1639,2 +1638,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_arith_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags, 0x81, 0xE0, src, imm32);\n+  evex_prefix_arith(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x81, 0xE0, no_flags);\n@@ -1659,1 +1657,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x23, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x23, no_flags);\n@@ -1818,2 +1816,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_and_int16_ndd(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, 0x40 | cc, 0xC0, false);\n+  evex_opcode_prefix_and_encode_swap(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x40 | cc, false \/* no_flags *\/, true \/* is_map1 *\/);\n@@ -1831,3 +1828,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  evex_prefix_int8_operand_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, (0x40 | cc));\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, (0x40 | cc) , false \/* no_flags *\/, true \/* is_map1 *\/);\n@@ -2522,2 +2517,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_and_int16_ndd(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, 0xAF, 0xC0, no_flags);\n+  evex_opcode_prefix_and_encode_swap(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, EVEX_32bit, 0xAF, no_flags, true \/* is_map1 *\/);\n@@ -2567,2 +2561,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_and_int16_nf(dst->encoding(), src->encoding(), value, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  evex_opcode_prefix_and_encode(dst->encoding(), src->encoding(), value, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, EVEX_32bit, no_flags);\n@@ -2580,1 +2573,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, (unsigned char)0xAF, no_flags, true \/* is_map1 *\/);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, (unsigned char)0xAF, no_flags, true \/* is_map1 *\/);\n@@ -4439,2 +4432,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_arith_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags, 0x81, 0xC8, src, imm32);\n+  evex_prefix_arith(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x81, 0xC8, no_flags);\n@@ -4452,1 +4444,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x0B, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x0B, no_flags);\n@@ -6807,2 +6799,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_int16_ndd(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, 0xA5, 0xC0, no_flags);\n+  evex_opcode_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, EVEX_32bit, 0xA5, no_flags, true \/* is_map1 *\/);\n@@ -6817,2 +6808,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_int24_ndd(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, 0xA4, 0xC0, 0x24, no_flags);\n+  evex_opcode_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, EVEX_32bit, 0xA4, no_flags, true \/* is_map1 *\/);\n@@ -6827,2 +6817,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_int16_ndd(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, 0xAD, 0xC0, no_flags);\n+  evex_opcode_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, EVEX_32bit, 0xAD, no_flags, true \/* is_map1 *\/);\n@@ -6837,2 +6826,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_int24_ndd(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, 0xAC, 0xC0, 0x2C, no_flags);\n+  evex_opcode_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, EVEX_32bit, 0xAC, no_flags, true \/* is_map1 *\/);\n@@ -6847,2 +6835,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_int24_ndd(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, 0xA4, 0xC0, 0x24, no_flags, true);\n+  evex_opcode_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, EVEX_64bit, 0xA4, no_flags, true \/* is_map1 *\/);\n@@ -6857,2 +6844,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_int24_ndd(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, 0xAC, 0xC0, 0x2C, no_flags, true);\n+  evex_opcode_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), imm8, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, EVEX_64bit, 0xAC, no_flags, true \/* is_map1 *\/);\n@@ -6974,2 +6960,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_arith_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags, 0x81, 0xE8, src, imm32);\n+  evex_prefix_arith(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x81, 0xE8, no_flags);\n@@ -6999,1 +6984,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x2B, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x2B, no_flags);\n@@ -7301,2 +7286,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_arith_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags, 0x81, 0xF0, src, imm32);\n+  evex_prefix_arith(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x81, 0xF0, no_flags);\n@@ -7314,1 +7298,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x33, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_32bit, 0x33, no_flags);\n@@ -7355,1 +7339,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_8bit, 0x32, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_8bit, 0x32, no_flags);\n@@ -7384,1 +7368,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_66, VEX_OPCODE_0F_3C, EVEX_16bit, 0x33, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_66, VEX_OPCODE_0F_3C, EVEX_16bit, 0x33, no_flags);\n@@ -12871,1 +12855,2 @@\n-void Assembler::evex_ndd_and_int8(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc, int input_size_in_bits, int b1, bool no_flags, bool is_map1) {\n+void Assembler::evex_prefix_int8_operand(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc,\n+                                         int size, int b1, bool no_flags, bool is_map1) {\n@@ -12873,1 +12858,1 @@\n-    if (input_size_in_bits == EVEX_64bit) {\n+    if (size == EVEX_64bit) {\n@@ -12878,1 +12863,1 @@\n-      if (input_size_in_bits == EVEX_16bit) {\n+      if (size == EVEX_16bit) {\n@@ -12884,2 +12869,6 @@\n-    emit_operand(dst, src2, 0);\n-    return;\n+  } else {\n+    bool vex_w = (size == EVEX_64bit) ? true : false;\n+    InstructionAttr attributes(AVX_128bit, vex_w, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, size);\n+    evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), pre, opc, &attributes, no_flags);\n+    emit_int8(b1);\n@@ -12887,6 +12876,0 @@\n-\n-  bool vex_w = (input_size_in_bits == EVEX_64bit) ? true : false;\n-  InstructionAttr attributes(AVX_128bit, vex_w, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, input_size_in_bits);\n-  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), pre, opc, &attributes, no_flags);\n-  emit_int8(b1);\n@@ -12958,2 +12941,2 @@\n-void Assembler::evex_opcode_and_int16_nf(int dst_enc, int src_enc, int value, VexSimdPrefix pre, VexOpcode opc,\n-                                         InstructionAttr *attributes, bool no_flags, bool use_prefixq) {\n+void Assembler::evex_opcode_prefix_and_encode(int dst_enc, int src_enc, int value, VexSimdPrefix pre, VexOpcode opc,\n+                                              int size, bool no_flags) {\n@@ -12961,0 +12944,1 @@\n+  bool is_prefixq = (size == EVEX_64bit) ? true : false;\n@@ -12962,1 +12946,1 @@\n-    encode = use_prefixq ? prefixq_and_encode(dst_enc, src_enc) : prefix_and_encode(dst_enc, src_enc);\n+    encode = is_prefixq ? prefixq_and_encode(dst_enc, src_enc) : prefix_and_encode(dst_enc, src_enc);\n@@ -12965,2 +12949,4 @@\n-    attributes->set_is_evex_instruction();\n-    encode = vex_prefix_and_encode(dst_enc, 0, src_enc, pre, opc, attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ false, no_flags);\n+    InstructionAttr attributes(AVX_128bit, is_prefixq, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, size);\n+    attributes.set_is_evex_instruction();\n+    encode = vex_prefix_and_encode(dst_enc, 0, src_enc, pre, opc, &attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ false, no_flags);\n@@ -12995,6 +12981,11 @@\n-void Assembler::evex_opcode_int24_ndd(int dst_enc, int nds_enc, int src_enc, int8_t imm8, VexSimdPrefix pre, VexOpcode opc,\n-                                      InstructionAttr *attributes, int byte1, int byte2, int byte1_ndd, bool no_flags, bool use_prefixq, bool is_map1) {\n-  bool demote = is_demotable(no_flags, dst_enc, nds_enc);\n-  int encode = evex_prefix_and_encode_ndd(demote, src_enc, dst_enc, nds_enc, pre, opc, attributes, no_flags, use_prefixq, is_map1);\n-  if (demote) {\n-    return emit_opcode_prefix_and_encoding((unsigned char)byte1, byte2, encode, imm8);\n+void Assembler::evex_opcode_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, int8_t imm8, VexSimdPrefix pre, VexOpcode opc,\n+                                              int size, int byte1, bool no_flags, bool is_map1) {\n+  bool is_prefixq = (size == EVEX_64bit) ? true : false;\n+  if (is_demotable(no_flags, dst_enc, nds_enc)) {\n+    int encode = is_prefixq ? prefixq_and_encode(src_enc, dst_enc, is_map1) : prefix_and_encode(src_enc, dst_enc, is_map1);\n+    emit_opcode_prefix_and_encoding((unsigned char)byte1, 0xC0, encode, imm8);\n+  } else {\n+    InstructionAttr attributes(AVX_128bit, is_prefixq, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, size);\n+    int encode = evex_prefix_and_encode_ndd(src_enc, dst_enc, nds_enc, pre, opc, &attributes, no_flags);\n+    emit_int24(byte1 & ~0x80, (0xC0 | encode), imm8);\n@@ -13002,1 +12993,0 @@\n-  emit_int24(byte1_ndd, (byte2 | encode), imm8);\n@@ -13005,3 +12995,14 @@\n-void Assembler::emit_demotable_int16(bool demote, int byte1, int byte2, int encode) {\n-  if (demote) {\n-    return emit_opcode_prefix_and_encoding((unsigned char)byte1, byte2, encode);\n+void Assembler::evex_opcode_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                              int size, int byte1, bool no_flags, bool is_map1) {\n+  bool is_prefixq = (size == EVEX_64bit);\n+  if (is_demotable(no_flags, dst_enc, nds_enc)) {\n+    if (pre == VEX_SIMD_66) {\n+      emit_int8(0x66);\n+    }\n+    int encode = is_prefixq ? prefixq_and_encode(src_enc, dst_enc, is_map1) : prefix_and_encode(src_enc, dst_enc, is_map1);\n+    emit_opcode_prefix_and_encoding((unsigned char)byte1, 0xC0, encode);\n+  } else {\n+    InstructionAttr attributes(AVX_128bit, is_prefixq, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    attributes.set_is_evex_instruction();\n+    int encode = vex_prefix_and_encode(src_enc, dst_enc, nds_enc, pre, opc, &attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+    emit_int16(byte1, (0xC0 | encode));\n@@ -13009,8 +13010,0 @@\n-  emit_int16(byte1, (byte2 | encode));\n-}\n-\n-void Assembler::evex_opcode_int16_ndd(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n-                                      InstructionAttr *attributes, int byte1, int byte2, bool no_flags, bool use_prefixq, bool is_map1) {\n-  bool demote = is_demotable(no_flags, dst_enc, nds_enc);\n-  int encode = evex_prefix_and_encode_ndd(demote, src_enc, dst_enc, nds_enc, pre, opc, attributes, no_flags, use_prefixq, is_map1);\n-  emit_demotable_int16(demote, byte1, byte2, encode);\n@@ -13019,10 +13012,4 @@\n-void Assembler::evex_opcode_and_int16_ndd(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n-                                          InstructionAttr *attributes, int byte1, int byte2, bool no_flags, bool use_prefixq, bool is_map1) {\n-  bool demote = is_demotable(no_flags, dst_enc, nds_enc);\n-  int encode = evex_prefix_and_encode_ndd(demote, nds_enc, dst_enc, src_enc, pre, opc, attributes, no_flags, use_prefixq, is_map1);\n-  emit_demotable_int16(demote, byte1, byte2, encode);\n-}\n-\n-int Assembler::evex_prefix_and_encode_ndd(bool demote, int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n-                                          InstructionAttr *attributes, bool no_flags, bool use_prefixq, bool is_map1) {\n-  if (demote) {\n+void Assembler::evex_opcode_prefix_and_encode_swap(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                                   int size, int byte1, bool no_flags, bool is_map1) {\n+  bool is_prefixq = (size == EVEX_64bit);\n+  if (is_demotable(no_flags, dst_enc, nds_enc)) {\n@@ -13032,1 +13019,7 @@\n-    return use_prefixq ? prefixq_and_encode(dst_enc, src_enc, is_map1) : prefix_and_encode(dst_enc, src_enc, is_map1);\n+    int encode = is_prefixq ? prefixq_and_encode(dst_enc, src_enc, is_map1) : prefix_and_encode(dst_enc, src_enc, is_map1);\n+    emit_opcode_prefix_and_encoding((unsigned char)byte1, 0xC0, encode);\n+  } else {\n+    InstructionAttr attributes(AVX_128bit, is_prefixq, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    attributes.set_is_evex_instruction();\n+    int encode = vex_prefix_and_encode(nds_enc, dst_enc, src_enc, pre, opc, &attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+    emit_int16(byte1, (0xC0 | encode));\n@@ -13034,2 +13027,0 @@\n-  attributes->set_is_evex_instruction();\n-  return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n@@ -13040,2 +13031,8 @@\n-  bool demote = is_demotable(no_flags, dst_enc, nds_enc);\n-  return evex_prefix_and_encode_ndd(demote, dst_enc, nds_enc, src_enc, pre, opc, attributes, no_flags, use_prefixq);\n+  if (is_demotable(no_flags, dst_enc, nds_enc)) {\n+    if (pre == VEX_SIMD_66) {\n+      emit_int8(0x66);\n+    }\n+    return use_prefixq ? prefixq_and_encode(dst_enc, src_enc) : prefix_and_encode(dst_enc, src_enc);\n+  }\n+  attributes->set_is_evex_instruction();\n+  return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n@@ -13066,2 +13063,4 @@\n-void Assembler::evex_prefix_and_encode_arith_ndd(int dst_enc, int nds_enc, VexSimdPrefix pre, VexOpcode opc,\n-                                                 InstructionAttr *attributes, bool no_flags, int op1, int op2, Register dst, int32_t imm32, bool use_prefixq) {\n+void Assembler::evex_prefix_arith(Register dst, Register nds, int32_t imm32, VexSimdPrefix pre, VexOpcode opc,\n+                                  int size, int op1, int op2, bool no_flags) {\n+  int dst_enc = dst->encoding();\n+  int nds_enc = nds->encoding();\n@@ -13070,5 +13069,8 @@\n-    use_prefixq ? prefixq_and_encode(dst_enc) : prefix_and_encode(dst_enc);\n-  }\n-  else {\n-    attributes->set_is_evex_instruction();\n-    vex_prefix_and_encode(0, dst_enc, nds_enc, pre, opc, attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+    (size == EVEX_64bit) ? prefixq_and_encode(dst_enc) : prefix_and_encode(dst_enc);\n+  } else {\n+    bool vex_w = (size == EVEX_64bit) ? true : false;\n+    InstructionAttr attributes(AVX_128bit, vex_w, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    \/\/attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, size);\n+    attributes.set_is_evex_instruction();\n+    vex_prefix_and_encode(0, dst_enc, nds_enc, pre, opc, &attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+\n@@ -13076,1 +13078,1 @@\n-  emit_arith(op1, op2, dst, imm32, demote);\n+  emit_arith(op1, op2, nds, imm32, demote);\n@@ -14567,2 +14569,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_arith_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags, 0x81, 0xC0, src, imm32, true);\n+  evex_prefix_arith(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x81, 0xC0, no_flags);\n@@ -14579,1 +14580,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x03, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x03, no_flags);\n@@ -14665,2 +14666,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_arith_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags, 0x81, 0xE0, src, imm32, true);\n+  evex_prefix_arith(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x81, 0xE0, no_flags);\n@@ -14677,1 +14677,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x23, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x23, no_flags);\n@@ -14842,2 +14842,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_and_int16_ndd(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, 0x40 | cc, 0xC0, false, true);\n+  evex_opcode_prefix_and_encode_swap(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x40 | cc, false \/* no_flags *\/, true \/* is_map1 *\/);\n@@ -14855,3 +14854,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  evex_prefix_int8_operand_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, (0x40 | cc), true);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, (0x40 | cc) , false \/* no_flags *\/, true \/* is_map1 *\/);\n@@ -15054,2 +15051,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_and_int16_ndd(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, 0xAF, 0xC0, no_flags, true);\n+  evex_opcode_prefix_and_encode_swap(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, EVEX_64bit, 0xAF, no_flags, true \/* is_map1 *\/);\n@@ -15110,2 +15106,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_opcode_and_int16_nf(dst->encoding(), src->encoding(), value, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, &attributes, no_flags, true);\n+  evex_opcode_prefix_and_encode(dst->encoding(), src->encoding(), value, VEX_SIMD_NONE, \/* MAP4 *\/VEX_OPCODE_0F_3C, EVEX_64bit, no_flags);\n@@ -15133,1 +15128,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, (unsigned char)0xAF, no_flags, true \/* is_map1 *\/);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, (unsigned char)0xAF, no_flags, true \/* is_map1 *\/);\n@@ -15524,2 +15519,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_arith_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags, 0x81, 0xC8, src, imm32, true);\n+  evex_prefix_arith(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x81, 0xC8, no_flags);\n@@ -15547,1 +15541,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x0B, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x0B, no_flags);\n@@ -16205,2 +16199,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_arith_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags, 0x81, 0xE8, src, imm32, true);\n+  evex_prefix_arith(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x81, 0xE8, no_flags);\n@@ -16229,1 +16222,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x2B, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x2B, no_flags);\n@@ -16318,1 +16311,1 @@\n-  evex_ndd_and_int8(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x33, no_flags);\n+  evex_prefix_int8_operand(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x33, no_flags);\n@@ -16327,2 +16320,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  evex_prefix_and_encode_arith_ndd(dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags, 0x81, 0xF0, src, imm32, true);\n+  evex_prefix_arith(dst, src, imm32, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, EVEX_64bit, 0x81, 0xF0, no_flags);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":113,"deletions":121,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -778,2 +778,2 @@\n-  void evex_ndd_and_int8(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc,\n-                       int input_size_in_bits, int b1, bool no_flags = false, bool is_map1 = false);\n+  void evex_prefix_int8_operand(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc,\n+                                int size, int b1, bool no_flags = false, bool is_map1 = false);\n@@ -791,3 +791,0 @@\n-  int  evex_prefix_and_encode_ndd(bool demote, int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n-                                  InstructionAttr *attributes, bool no_flags, bool use_prefixq, bool is_map1 = false);\n-\n@@ -806,2 +803,2 @@\n-  void evex_prefix_and_encode_arith_ndd(int dst_enc, int nds_enc, VexSimdPrefix pre, VexOpcode opc,\n-                                        InstructionAttr *attributes, bool no_flags, int op1, int op2, Register dst, int32_t imm32, bool use_prefixq = false);\n+  void evex_prefix_arith(Register dst, Register nds, int32_t imm32, VexSimdPrefix pre, VexOpcode opc,\n+                         int size, int op1, int op2, bool no_flags);\n@@ -809,2 +806,2 @@\n-  void evex_opcode_int16_ndd(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n-                             InstructionAttr *attributes, int byte1, int byte2, bool no_flags, bool use_prefixq = false, bool is_map1 = true);\n+  void evex_prefix_int8_operand_ndd(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc,\n+                                    InstructionAttr *attributes, int byte1, bool use_prefixq = false, bool no_flags = false, bool is_map1 = true);\n@@ -812,2 +809,2 @@\n-  void evex_opcode_and_int16_ndd(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n-                                 InstructionAttr *attributes, int byte1, int byte2, bool no_flags, bool use_prefixq = false, bool is_map1 = true);\n+  void evex_opcode_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                     int size, int byte1, bool no_flags, bool is_map1 = false);\n@@ -815,2 +812,2 @@\n-  void evex_opcode_int24_ndd(int dst_enc, int nds_enc, int src_enc, int8_t imm8, VexSimdPrefix pre, VexOpcode opc,\n-                             InstructionAttr *attributes, int byte1, int byte2, int byte1_ndd, bool no_flags, bool use_prefixq = false, bool is_map1 = true);\n+  void evex_opcode_prefix_and_encode_swap(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                          int size, int byte1, bool no_flags, bool is_map1 = false);\n@@ -818,2 +815,2 @@\n-  void evex_prefix_int8_operand_ndd(Register dst, Register src1, Address src2, VexSimdPrefix pre, VexOpcode opc,\n-                                    InstructionAttr *attributes, int byte1, bool use_prefixq = false, bool no_flags = false, bool is_map1 = true);\n+  void evex_opcode_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, int8_t imm8, VexSimdPrefix pre, VexOpcode opc,\n+                                     int size, int byte1, bool no_flags, bool is_map1 = false);\n@@ -821,2 +818,2 @@\n-  void evex_opcode_and_int16_nf(int dst_enc, int src_enc, int value, VexSimdPrefix pre, VexOpcode opc,\n-                                InstructionAttr *attributes, bool no_flags, bool use_prefixq = false);\n+  void evex_opcode_prefix_and_encode(int dst_enc, int src_enc, int value, VexSimdPrefix pre, VexOpcode opc,\n+                                     int size, bool no_flags);\n@@ -832,1 +829,0 @@\n-  void emit_demotable_int16(bool demote, int byte1, int byte2, int encode);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"}]}