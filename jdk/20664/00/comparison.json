{"files":[{"patch":"@@ -245,0 +245,2 @@\n+    case vmIntrinsics::_Continuation_pin:\n+    case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,0 +603,2 @@\n+  do_intrinsic(_Continuation_pin,          jdk_internal_vm_Continuation, pin_name, void_method_signature, F_SN)         \\\n+  do_intrinsic(_Continuation_unpin,        jdk_internal_vm_Continuation, unpin_name, void_method_signature, F_SN)       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -409,0 +409,2 @@\n+  template(pin_name,                                  \"pin\")                                      \\\n+  template(unpin_name,                                \"unpin\")                                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -734,0 +734,2 @@\n+  case vmIntrinsics::_Continuation_pin:\n+  case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -485,0 +485,3 @@\n+  case vmIntrinsics::_Continuation_pin:          return inline_native_Continuation_pin();\n+  case vmIntrinsics::_Continuation_unpin:        return inline_native_Continuation_unpin();\n+\n@@ -3718,0 +3721,96 @@\n+\/\/------------------------inline_native_Continuation_pin and unpin-----------\n+\n+\/\/ Shared implementation routine for both pin and unpin.\n+bool LibraryCallKit::inline_native_Continuation_pinning_shared_impl(bool unpin) {\n+  enum { _true_path = 1, _false_path = 2, PATH_LIMIT };\n+\n+  \/\/ Save input memory.\n+  Node* input_memory_state = reset_memory();\n+  set_all_memory(input_memory_state);\n+\n+  \/\/ TLS\n+  Node* tls_ptr = _gvn.transform(new ThreadLocalNode());\n+  Node* last_continuation_offset = basic_plus_adr(top(), tls_ptr, in_bytes(JavaThread::cont_entry_offset()));\n+  Node* last_continuation = make_load(control(), last_continuation_offset, last_continuation_offset->get_ptr_type(), T_ADDRESS, MemNode::unordered);\n+\n+  \/\/ Null check the last continuation object.\n+  Node* continuation_cmp_null = _gvn.transform(new CmpPNode(last_continuation, null()));\n+  Node* test_continuation_not_equal_null = _gvn.transform(new BoolNode(continuation_cmp_null, BoolTest::ne));\n+  IfNode* iff_continuation_not_equal_null = create_and_map_if(control(), test_continuation_not_equal_null, PROB_MAX, COUNT_UNKNOWN);\n+\n+  \/\/ False path, last continuation is null.\n+  Node* continuation_is_null = _gvn.transform(new IfFalseNode(iff_continuation_not_equal_null));\n+\n+  \/\/ True path, last continuation is not null.\n+  Node* continuation_is_not_null = _gvn.transform(new IfTrueNode(iff_continuation_not_equal_null));\n+\n+  set_control(continuation_is_not_null);\n+\n+  \/\/ Load the pin count from the last continuation.\n+  Node* pin_count_offset = basic_plus_adr(top(), last_continuation, in_bytes(ContinuationEntry::pin_count_offset()));\n+  Node* pin_count = make_load(control(), pin_count_offset, TypeInt::INT, T_INT, MemNode::unordered);\n+\n+  \/\/ The loaded pin count is compared against a context specific rhs for over\/underflow detection.\n+  Node* pin_count_rhs;\n+  if (unpin) {\n+    pin_count_rhs = _gvn.intcon(0);\n+  } else {\n+    pin_count_rhs = _gvn.intcon(UINT32_MAX);\n+  }\n+  Node* pin_count_cmp = _gvn.transform(new CmpUNode(_gvn.transform(pin_count), pin_count_rhs));\n+  Node* test_pin_count_over_underflow = _gvn.transform(new BoolNode(pin_count_cmp, BoolTest::eq));\n+  IfNode* iff_pin_count_over_underflow = create_and_map_if(control(), test_pin_count_over_underflow, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ False branch, no pin count over\/underflow. Increment or decrement pin count and store back.\n+  Node* valid_pin_count = _gvn.transform(new IfFalseNode(iff_pin_count_over_underflow));\n+  set_control(valid_pin_count);\n+\n+  Node* next_pin_count;\n+  if (unpin) {\n+    next_pin_count = _gvn.transform(new SubINode(pin_count, _gvn.intcon(1)));\n+  } else {\n+    next_pin_count = _gvn.transform(new AddINode(pin_count, _gvn.intcon(1)));\n+  }\n+\n+  Node* updated_pin_count_memory = store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  \/\/ True branch, pin count over\/underflow.\n+  Node* pin_count_over_underflow = _gvn.transform(new IfTrueNode(iff_pin_count_over_underflow));\n+  {\n+    \/\/ Deoptimize and reexecute in the interpreter to throw IllegalStateException for pin count over\/underflow.\n+    PreserveJVMState pjvms(this);\n+    PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n+    set_control(pin_count_over_underflow);\n+    set_all_memory(input_memory_state);\n+    uncommon_trap_exact(Deoptimization::Reason_intrinsic,\n+                        Deoptimization::Action_reinterpret);\n+    assert(stopped(), \"invariant\");\n+  }\n+\n+  \/\/ Result of top level CFG and Memory.\n+  RegionNode* result_rgn = new RegionNode(PATH_LIMIT);\n+  record_for_igvn(result_rgn);\n+  PhiNode* result_mem = new PhiNode(result_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  record_for_igvn(result_mem);\n+\n+  result_rgn->init_req(_true_path, _gvn.transform(valid_pin_count));\n+  result_rgn->init_req(_false_path, _gvn.transform(continuation_is_null));\n+  result_mem->init_req(_true_path, _gvn.transform(updated_pin_count_memory));\n+  result_mem->init_req(_false_path, _gvn.transform(input_memory_state));\n+\n+  \/\/ Set output state.\n+  set_control(_gvn.transform(result_rgn));\n+  set_all_memory(_gvn.transform(result_mem));\n+\n+  return true;\n+}\n+\n+bool LibraryCallKit::inline_native_Continuation_pin() {\n+  return inline_native_Continuation_pinning_shared_impl(false);\n+}\n+\n+bool LibraryCallKit::inline_native_Continuation_unpin() {\n+  return inline_native_Continuation_pinning_shared_impl(true);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -245,0 +245,4 @@\n+  bool inline_native_Continuation_pinning_shared_impl(bool unpin);\n+  bool inline_native_Continuation_pin();\n+  bool inline_native_Continuation_unpin();\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  uint _pin_count;\n+  uint32_t _pin_count;\n@@ -111,1 +111,1 @@\n-    if (_pin_count == UINT_MAX) return false;\n+    if (_pin_count == UINT32_MAX) return false;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,0 +430,1 @@\n+    @IntrinsicCandidate\n@@ -437,0 +438,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}