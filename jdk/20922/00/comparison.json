{"files":[{"patch":"@@ -95,1 +95,1 @@\n-    lightweight_lock(Roop, Rmark, Rscratch, slow_int);\n+    lightweight_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  compiler_fast_lock_lightweight_object(flag, obj, tmp1, tmp2, tmp3);\n+  compiler_fast_lock_lightweight_object(flag, obj, box, tmp1, tmp2, tmp3);\n@@ -47,1 +47,1 @@\n-  compiler_fast_unlock_lightweight_object(flag, obj, tmp1, tmp2, tmp3);\n+  compiler_fast_unlock_lightweight_object(flag, obj, box, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -971,1 +971,1 @@\n-      lightweight_lock(object, header, tmp, slow_case);\n+      lightweight_lock(monitor, object, header, tmp, slow_case);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2733,3 +2733,3 @@\n-void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register tmp1,\n-                                                           Register tmp2, Register tmp3) {\n-  assert_different_registers(obj, tmp1, tmp2, tmp3);\n+void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n+                                                           Register tmp1, Register tmp2, Register tmp3) {\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3);\n@@ -2745,0 +2745,6 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    li(tmp1, 0);\n+    std(tmp1, in_bytes(BasicObjectLock::lock_offset()) + BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+  }\n+\n@@ -2785,1 +2791,1 @@\n-    \/\/ Try to lock. Transition lock bits 0b00 => 0b01\n+    \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n@@ -2800,5 +2806,4 @@\n-    if (!UseObjectMonitorTable) {\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register tagged_monitor = mark;\n-      const uintptr_t monitor_tag = markWord::monitor_value;\n-      const Register owner_addr = tmp2;\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register owner_addr = tmp2;\n+    Label monitor_locked;\n@@ -2806,0 +2811,1 @@\n+    if (!UseObjectMonitorTable) {\n@@ -2807,20 +2813,1 @@\n-      addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n-\n-      \/\/ CAS owner (null => current thread).\n-      cmpxchgd(\/*flag=*\/flag,\n-              \/*current_value=*\/t,\n-              \/*compare_value=*\/(intptr_t)0,\n-              \/*exchange_value=*\/R16_thread,\n-              \/*where=*\/owner_addr,\n-              MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-              MacroAssembler::cmpxchgx_hint_acquire_lock());\n-      beq(flag, locked);\n-\n-      \/\/ Check if recursive.\n-      cmpd(flag, t, R16_thread);\n-      bne(flag, slow_path);\n-\n-      \/\/ Recursive.\n-      ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n-      addi(tmp1, tmp1, 1);\n-      std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+      addi(owner_addr, mark, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n@@ -2828,3 +2815,29 @@\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      \/\/ Set flag to NE\n-      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      Label monitor_found;\n+      Register cache_addr = tmp2;\n+\n+      \/\/ Load cache address\n+      addi(cache_addr, R16_thread, in_bytes(JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ld(tmp3, 0, cache_addr);\n+        cmpd(CCR0, tmp3, obj);\n+        beq(CCR0, monitor_found);\n+        addi(cache_addr, cache_addr, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ld(tmp3, 0, cache_addr);\n+      cmpd(CCR0, tmp3, obj);\n+      beq(CCR0, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      addi(cache_addr, cache_addr, in_bytes(OMCache::oop_to_oop_difference()));\n+      cmpdi(CCR1, tmp3, 0);\n+      bne(CCR1, loop);\n+      \/\/ Cache Miss, CCR0.NE set from cmp above\n@@ -2832,0 +2845,30 @@\n+\n+      bind(monitor_found);\n+      ld(mark, in_bytes(OMCache::oop_to_monitor_difference()), cache_addr);\n+\n+      \/\/ Compute owner address.\n+      addi(owner_addr, mark, in_bytes(ObjectMonitor::owner_offset()));\n+    }\n+\n+    \/\/ CAS owner (null => current thread).\n+    cmpxchgd(\/*flag=*\/flag,\n+            \/*current_value=*\/t,\n+            \/*compare_value=*\/(intptr_t)0,\n+            \/*exchange_value=*\/R16_thread,\n+            \/*where=*\/owner_addr,\n+            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+            MacroAssembler::cmpxchgx_hint_acquire_lock());\n+    beq(flag, monitor_locked);\n+\n+    \/\/ Check if recursive.\n+    cmpd(flag, t, R16_thread);\n+    bne(flag, slow_path);\n+\n+    \/\/ Recursive.\n+    ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    addi(tmp1, tmp1, 1);\n+    std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      std(mark, BasicLock::object_monitor_cache_offset_in_bytes(), box);\n@@ -2854,2 +2897,2 @@\n-void MacroAssembler::compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register obj, Register tmp1,\n-                                                             Register tmp2, Register tmp3) {\n+void MacroAssembler::compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n+                                                             Register tmp1, Register tmp2, Register tmp3) {\n@@ -2950,4 +2993,3 @@\n-    if (!UseObjectMonitorTable) {\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register monitor = mark;\n-      const uintptr_t monitor_tag = markWord::monitor_value;\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register monitor = mark;\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n@@ -2955,0 +2997,1 @@\n+    if (!UseObjectMonitorTable) {\n@@ -2957,0 +3000,6 @@\n+    } else {\n+      ld(monitor, BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+      \/\/ null check with Flags == NE, no valid pointer below alignof(ObjectMonitor*)\n+      cmpldi(CCR0, monitor, checked_cast<uint8_t>(alignof(ObjectMonitor*)));\n+      blt(CCR0, slow_path);\n+    }\n@@ -2958,2 +3007,2 @@\n-      const Register recursions = tmp2;\n-      Label not_recursive;\n+    const Register recursions = tmp2;\n+    Label not_recursive;\n@@ -2961,4 +3010,4 @@\n-      \/\/ Check if recursive.\n-      ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-      addic_(recursions, recursions, -1);\n-      blt(CCR0, not_recursive);\n+    \/\/ Check if recursive.\n+    ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+    addic_(recursions, recursions, -1);\n+    blt(CCR0, not_recursive);\n@@ -2966,4 +3015,4 @@\n-      \/\/ Recursive unlock.\n-      std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n-      b(unlocked);\n+    \/\/ Recursive unlock.\n+    std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n+    b(unlocked);\n@@ -2971,1 +3020,1 @@\n-      bind(not_recursive);\n+    bind(not_recursive);\n@@ -2973,2 +3022,2 @@\n-      Label release_;\n-      const Register t2 = tmp2;\n+    Label release_;\n+    const Register t2 = tmp2;\n@@ -2976,6 +3025,6 @@\n-      \/\/ Check if the entry lists are empty.\n-      ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n-      ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n-      orr(t, t, t2);\n-      cmpdi(flag, t, 0);\n-      beq(flag, release_);\n+    \/\/ Check if the entry lists are empty.\n+    ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n+    ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n+    orr(t, t, t2);\n+    cmpdi(flag, t, 0);\n+    beq(flag, release_);\n@@ -2983,5 +3032,5 @@\n-      \/\/ The owner may be anonymous and we removed the last obj entry in\n-      \/\/ the lock-stack. This loses the information about the owner.\n-      \/\/ Write the thread to the owner field so the runtime knows the owner.\n-      std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-      b(slow_path);\n+    \/\/ The owner may be anonymous and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    b(slow_path);\n@@ -2989,11 +3038,5 @@\n-      bind(release_);\n-      \/\/ Set owner to null.\n-      release();\n-      \/\/ t contains 0\n-      std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-    } else {\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      \/\/ Set flag to NE\n-      crxor(flag, Assembler::equal, flag, Assembler::equal);\n-      b(slow_path);\n-    }\n+    bind(release_);\n+    \/\/ Set owner to null.\n+    release();\n+    \/\/ t contains 0\n+    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n@@ -4643,1 +4686,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register box, Register obj, Register t1, Register t2, Label& slow) {\n@@ -4645,1 +4688,1 @@\n-  assert_different_registers(obj, t1, t2);\n+  assert_different_registers(box, obj, t1, t2);\n@@ -4652,0 +4695,6 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    li(t, 0);\n+    std(t, in_bytes(BasicObjectLock::lock_offset()) + BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+  }\n+\n@@ -4672,1 +4721,1 @@\n-  \/\/ Try to lock. Transition lock bits 0b00 => 0b01\n+  \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":125,"deletions":76,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -657,1 +657,1 @@\n-  void lightweight_lock(Register obj, Register t1, Register t2, Label& slow);\n+  void lightweight_lock(Register box, Register obj, Register t1, Register t2, Label& slow);\n@@ -678,2 +678,2 @@\n-  void compiler_fast_lock_lightweight_object(ConditionRegister flag, Register oop, Register tmp1,\n-                                             Register tmp2, Register tmp3);\n+  void compiler_fast_lock_lightweight_object(ConditionRegister flag, Register oop, Register box,\n+                                             Register tmp1, Register tmp2, Register tmp3);\n@@ -681,2 +681,2 @@\n-  void compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register oop, Register tmp1,\n-                                               Register tmp2, Register tmp3);\n+  void compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register oop, Register box,\n+                                               Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -12109,1 +12109,1 @@\n-instruct cmpFastLockLightweight(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{\n+instruct cmpFastLockLightweight(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR1 cr1) %{\n@@ -12112,1 +12112,1 @@\n-  effect(TEMP tmp1, TEMP tmp2);\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr1);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2402,1 +2402,1 @@\n-      __ compiler_fast_lock_lightweight_object(CCR0, r_oop, r_temp_1, r_temp_2, r_temp_3);\n+      __ compiler_fast_lock_lightweight_object(CCR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n@@ -2608,1 +2608,1 @@\n-      __ compiler_fast_unlock_lightweight_object(CCR0, r_oop, r_temp_1, r_temp_2, r_temp_3);\n+      __ compiler_fast_unlock_lightweight_object(CCR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(RISCV64)\n+#if defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64)\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}