{"files":[{"patch":"@@ -95,1 +95,1 @@\n-    lightweight_lock(Roop, Rmark, Rscratch, slow_int);\n+    lightweight_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  compiler_fast_lock_lightweight_object(flag, obj, tmp1, tmp2, tmp3);\n+  compiler_fast_lock_lightweight_object(flag, obj, box, tmp1, tmp2, tmp3);\n@@ -47,1 +47,1 @@\n-  compiler_fast_unlock_lightweight_object(flag, obj, tmp1, tmp2, tmp3);\n+  compiler_fast_unlock_lightweight_object(flag, obj, box, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -971,1 +971,1 @@\n-      lightweight_lock(object, header, tmp, slow_case);\n+      lightweight_lock(monitor, object, header, tmp, slow_case);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2733,3 +2733,3 @@\n-void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register tmp1,\n-                                                           Register tmp2, Register tmp3) {\n-  assert_different_registers(obj, tmp1, tmp2, tmp3);\n+void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n+                                                           Register tmp1, Register tmp2, Register tmp3) {\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3);\n@@ -2745,0 +2745,6 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    li(tmp1, 0);\n+    std(tmp1, in_bytes(BasicObjectLock::lock_offset()) + BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+  }\n+\n@@ -2748,2 +2754,2 @@\n-    testbitdi(flag, R0, tmp1, exact_log2(KlassFlags::_misc_is_value_based_class));\n-    bne(flag, slow_path);\n+    testbitdi(CCR0, R0, tmp1, exact_log2(KlassFlags::_misc_is_value_based_class));\n+    bne(CCR0, slow_path);\n@@ -2764,2 +2770,2 @@\n-    cmplwi(flag, top, LockStack::end_offset() - 1);\n-    bgt(flag, slow_path);\n+    cmplwi(CCR0, top, LockStack::end_offset() - 1);\n+    bgt(CCR0, slow_path);\n@@ -2773,2 +2779,2 @@\n-    cmpd(flag, obj, t);\n-    beq(flag, push);\n+    cmpd(CCR0, obj, t);\n+    beq(CCR0, push);\n@@ -2779,3 +2785,3 @@\n-    cmpldi(flag, t, markWord::unlocked_value);\n-    bgt(flag, inflated);\n-    bne(flag, slow_path);\n+    cmpldi(CCR0, t, markWord::unlocked_value);\n+    bgt(CCR0, inflated);\n+    bne(CCR0, slow_path);\n@@ -2785,1 +2791,1 @@\n-    \/\/ Try to lock. Transition lock bits 0b00 => 0b01\n+    \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n@@ -2800,0 +2806,6 @@\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register monitor = mark;\n+    const Register owner_addr = tmp2;\n+    Label monitor_locked;\n+\n@@ -2801,4 +2813,36 @@\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register tagged_monitor = mark;\n-      const uintptr_t monitor_tag = markWord::monitor_value;\n-      const Register owner_addr = tmp2;\n+      \/\/ Compute owner address.\n+      addi(owner_addr, mark, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n+    } else {\n+      Label monitor_found;\n+      Register cache_addr = tmp2;\n+\n+      \/\/ Load cache address\n+      addi(cache_addr, R16_thread, in_bytes(JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ld(tmp3, 0, cache_addr);\n+        cmpd(CCR0, tmp3, obj);\n+        beq(CCR0, monitor_found);\n+        addi(cache_addr, cache_addr, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ld(tmp3, 0, cache_addr);\n+      cmpd(CCR0, tmp3, obj);\n+      beq(CCR0, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      addi(cache_addr, cache_addr, in_bytes(OMCache::oop_to_oop_difference()));\n+      cmpdi(CCR1, tmp3, 0);\n+      bne(CCR1, loop);\n+      \/\/ Cache Miss, CCR0.NE set from cmp above\n+      b(slow_path);\n+\n+      bind(monitor_found);\n+      ld(monitor, in_bytes(OMCache::oop_to_monitor_difference()), cache_addr);\n@@ -2807,17 +2851,20 @@\n-      addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n-\n-      \/\/ CAS owner (null => current thread).\n-      cmpxchgd(\/*flag=*\/flag,\n-              \/*current_value=*\/t,\n-              \/*compare_value=*\/(intptr_t)0,\n-              \/*exchange_value=*\/R16_thread,\n-              \/*where=*\/owner_addr,\n-              MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-              MacroAssembler::cmpxchgx_hint_acquire_lock());\n-      beq(flag, locked);\n-\n-      \/\/ Check if recursive.\n-      cmpd(flag, t, R16_thread);\n-      bne(flag, slow_path);\n-\n-      \/\/ Recursive.\n+      addi(owner_addr, monitor, in_bytes(ObjectMonitor::owner_offset()));\n+    }\n+\n+    \/\/ CAS owner (null => current thread).\n+    cmpxchgd(\/*flag=*\/CCR0,\n+            \/*current_value=*\/t,\n+            \/*compare_value=*\/(intptr_t)0,\n+            \/*exchange_value=*\/R16_thread,\n+            \/*where=*\/owner_addr,\n+            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+            MacroAssembler::cmpxchgx_hint_acquire_lock());\n+    beq(CCR0, monitor_locked);\n+\n+    \/\/ Check if recursive.\n+    cmpd(CCR0, t, R16_thread);\n+    bne(CCR0, slow_path);\n+\n+    \/\/ Recursive.\n+    if (!UseObjectMonitorTable) {\n+      assert_different_registers(tmp1, owner_addr);\n@@ -2828,4 +2875,9 @@\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      \/\/ Set flag to NE\n-      crxor(flag, Assembler::equal, flag, Assembler::equal);\n-      b(slow_path);\n+      assert_different_registers(tmp2, monitor);\n+      ld(tmp2, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      addi(tmp2, tmp2, 1);\n+      std(tmp2, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+    }\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      std(monitor, BasicLock::object_monitor_cache_offset_in_bytes(), box);\n@@ -2841,1 +2893,1 @@\n-  beq(flag, flag_correct);\n+  beq(CCR0, flag_correct);\n@@ -2847,1 +2899,1 @@\n-  bne(flag, flag_correct);\n+  bne(CCR0, flag_correct);\n@@ -2854,2 +2906,2 @@\n-void MacroAssembler::compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register obj, Register tmp1,\n-                                                             Register tmp2, Register tmp3) {\n+void MacroAssembler::compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n+                                                             Register tmp1, Register tmp2, Register tmp3) {\n@@ -2877,1 +2929,1 @@\n-    cmpd(flag, obj, t);\n+    cmpd(CCR0, obj, t);\n@@ -2879,1 +2931,1 @@\n-    bne(flag, inflated_load_monitor);\n+    bne(CCR0, inflated_load_monitor);\n@@ -2892,2 +2944,2 @@\n-    cmpd(flag, obj, t);\n-    beq(flag, unlocked);\n+    cmpd(CCR0, obj, t);\n+    beq(CCR0, unlocked);\n@@ -2944,2 +2996,2 @@\n-    cmpd(flag, obj, t);\n-    bne(flag, inflated);\n+    cmpd(CCR0, obj, t);\n+    bne(CCR0, inflated);\n@@ -2950,4 +3002,3 @@\n-    if (!UseObjectMonitorTable) {\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register monitor = mark;\n-      const uintptr_t monitor_tag = markWord::monitor_value;\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register monitor = mark;\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n@@ -2955,0 +3006,1 @@\n+    if (!UseObjectMonitorTable) {\n@@ -2957,0 +3009,6 @@\n+    } else {\n+      ld(monitor, BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+      \/\/ null check with Flags == NE, no valid pointer below alignof(ObjectMonitor*)\n+      cmpldi(CCR0, monitor, checked_cast<uint8_t>(alignof(ObjectMonitor*)));\n+      blt(CCR0, slow_path);\n+    }\n@@ -2958,2 +3016,2 @@\n-      const Register recursions = tmp2;\n-      Label not_recursive;\n+    const Register recursions = tmp2;\n+    Label not_recursive;\n@@ -2961,4 +3019,4 @@\n-      \/\/ Check if recursive.\n-      ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-      addic_(recursions, recursions, -1);\n-      blt(CCR0, not_recursive);\n+    \/\/ Check if recursive.\n+    ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+    addic_(recursions, recursions, -1);\n+    blt(CCR0, not_recursive);\n@@ -2966,4 +3024,4 @@\n-      \/\/ Recursive unlock.\n-      std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n-      b(unlocked);\n+    \/\/ Recursive unlock.\n+    std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n+    b(unlocked);\n@@ -2971,1 +3029,1 @@\n-      bind(not_recursive);\n+    bind(not_recursive);\n@@ -2973,2 +3031,2 @@\n-      Label release_;\n-      const Register t2 = tmp2;\n+    Label release_;\n+    const Register t2 = tmp2;\n@@ -2976,6 +3034,6 @@\n-      \/\/ Check if the entry lists are empty.\n-      ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n-      ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n-      orr(t, t, t2);\n-      cmpdi(flag, t, 0);\n-      beq(flag, release_);\n+    \/\/ Check if the entry lists are empty.\n+    ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n+    ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n+    orr(t, t, t2);\n+    cmpdi(CCR0, t, 0);\n+    beq(CCR0, release_);\n@@ -2983,5 +3041,5 @@\n-      \/\/ The owner may be anonymous and we removed the last obj entry in\n-      \/\/ the lock-stack. This loses the information about the owner.\n-      \/\/ Write the thread to the owner field so the runtime knows the owner.\n-      std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-      b(slow_path);\n+    \/\/ The owner may be anonymous and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    b(slow_path);\n@@ -2989,11 +3047,5 @@\n-      bind(release_);\n-      \/\/ Set owner to null.\n-      release();\n-      \/\/ t contains 0\n-      std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-    } else {\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      \/\/ Set flag to NE\n-      crxor(flag, Assembler::equal, flag, Assembler::equal);\n-      b(slow_path);\n-    }\n+    bind(release_);\n+    \/\/ Set owner to null.\n+    release();\n+    \/\/ t contains 0\n+    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n@@ -3008,1 +3060,1 @@\n-  beq(flag, flag_correct);\n+  beq(CCR0, flag_correct);\n@@ -3014,1 +3066,1 @@\n-  bne(flag, flag_correct);\n+  bne(CCR0, flag_correct);\n@@ -4643,1 +4695,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register box, Register obj, Register t1, Register t2, Label& slow) {\n@@ -4645,1 +4697,1 @@\n-  assert_different_registers(obj, t1, t2);\n+  assert_different_registers(box, obj, t1, t2);\n@@ -4652,0 +4704,6 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    li(t, 0);\n+    std(t, in_bytes(BasicObjectLock::lock_offset()) + BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+  }\n+\n@@ -4672,1 +4730,1 @@\n-  \/\/ Try to lock. Transition lock bits 0b00 => 0b01\n+  \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":150,"deletions":92,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -657,1 +657,1 @@\n-  void lightweight_lock(Register obj, Register t1, Register t2, Label& slow);\n+  void lightweight_lock(Register box, Register obj, Register t1, Register t2, Label& slow);\n@@ -678,2 +678,2 @@\n-  void compiler_fast_lock_lightweight_object(ConditionRegister flag, Register oop, Register tmp1,\n-                                             Register tmp2, Register tmp3);\n+  void compiler_fast_lock_lightweight_object(ConditionRegister flag, Register oop, Register box,\n+                                             Register tmp1, Register tmp2, Register tmp3);\n@@ -681,2 +681,2 @@\n-  void compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register oop, Register tmp1,\n-                                               Register tmp2, Register tmp3);\n+  void compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register oop, Register box,\n+                                               Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -12109,1 +12109,1 @@\n-instruct cmpFastLockLightweight(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{\n+instruct cmpFastLockLightweight(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, flagsRegCR1 cr1) %{\n@@ -12112,1 +12112,1 @@\n-  effect(TEMP tmp1, TEMP tmp2);\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr1);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2402,1 +2402,1 @@\n-      __ compiler_fast_lock_lightweight_object(CCR0, r_oop, r_temp_1, r_temp_2, r_temp_3);\n+      __ compiler_fast_lock_lightweight_object(CCR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n@@ -2608,1 +2608,1 @@\n-      __ compiler_fast_unlock_lightweight_object(CCR0, r_oop, r_temp_1, r_temp_2, r_temp_3);\n+      __ compiler_fast_unlock_lightweight_object(CCR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(RISCV64)\n+#if defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64)\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}