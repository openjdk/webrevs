{"files":[{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -372,0 +373,36 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ helper for -XX:+OptimizeImplicitExceptions\n+ciInstanceKlass* ciEnv::exception_instanceKlass_for_reason(Deoptimization::DeoptReason reason, bool is_aastore) {\n+  Symbol* ex_symbol = NULL;\n+  switch (reason) {\n+  case Deoptimization::Reason_null_check:\n+    ex_symbol = vmSymbols::java_lang_NullPointerException();\n+    break;\n+  case Deoptimization::Reason_div0_check:\n+    ex_symbol = vmSymbols::java_lang_ArithmeticException();\n+    break;\n+  case Deoptimization::Reason_range_check:\n+    ex_symbol = vmSymbols::java_lang_ArrayIndexOutOfBoundsException();\n+    break;\n+  case Deoptimization::Reason_class_check:\n+    if (is_aastore) {\n+      ex_symbol = vmSymbols::java_lang_ArrayStoreException();\n+    } else {\n+      ex_symbol = vmSymbols::java_lang_ClassCastException();\n+    }\n+    break;\n+  default:\n+    break;\n+  }\n+  ciInstanceKlass* ex_ciInstKlass = NULL;\n+  if (ex_symbol != NULL) {\n+    VM_ENTRY_MARK;\n+    InstanceKlass* ex_instKlass = SystemDictionary::find_instance_klass(ex_symbol, Handle(), Handle());\n+    if (ex_instKlass != NULL) {\n+      ex_ciInstKlass = get_instance_klass(ex_instKlass);\n+    }\n+  }\n+  return ex_ciInstKlass;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -394,0 +395,2 @@\n+  ciInstanceKlass* exception_instanceKlass_for_reason(Deoptimization::DeoptReason reason, bool is_aastore);\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1033,2 +1033,2 @@\n-  if (method() == NULL) {\n-    return true; \/\/ call into runtime or uncommon trap\n+  if (method() == NULL || _implicit_exception_init) {\n+    return true; \/\/ call into runtime or uncommon trap or implicit exception <init>\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -680,0 +680,3 @@\n+  bool    _implicit_exception_init;\/\/ <init> call for an implicitly created exception\n+                                   \/\/ if -XX:+OptimizeImplicitExceptions. This also\n+                                   \/\/ overrides the symbolic call site info from bytecode.\n@@ -688,0 +691,1 @@\n+      _implicit_exception_init(false),\n@@ -703,0 +707,2 @@\n+  void  set_implicit_exception_init(bool f){ _implicit_exception_init = f; }\n+  bool  implicit_exception_init() const    { return _implicit_exception_init; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -623,0 +623,35 @@\n+  if (treat_throw_as_hot && OptimizeImplicitExceptions) {\n+    ciInstanceKlass* ex_ciInstKlass =\n+      env()->exception_instanceKlass_for_reason(reason, java_bc() == Bytecodes::_aastore);\n+    if (ex_ciInstKlass != NULL) {\n+      const TypeKlassPtr *ex_type = TypeKlassPtr::make(ex_ciInstKlass);\n+      kill_dead_locals();\n+      Node* ex_node = new_instance(makecon(ex_type), NULL, NULL, true);\n+      set_argument(0, ex_node);\n+      ciMethod* init = ex_ciInstKlass->find_method(ciSymbol::make(\"<init>\"), ciSymbol::make(\"()V\"));\n+\n+      \/\/ The following code is modeled after:\n+      \/\/ DirectCallGenerator* cg = CallGenerator::for_direct_call(init);\n+      \/\/ JVMState *new_jvms = cg->generate(sync_jvms());\n+      \/\/ We can't use that code directly because it assumes at various places that we're\n+      \/\/ at an invoke bytecode which is in genaral not the case for implicit exceptions.\n+\n+      GraphKit kit(sync_jvms());\n+      address target = SharedRuntime::get_resolve_opt_virtual_call_stub();\n+\n+      CallStaticJavaNode *call = new CallStaticJavaNode(kit.C, TypeFunc::make(init), target, init);\n+      call->set_optimized_virtual(true);\n+      call->set_implicit_exception_init(true);\n+      kit.set_arguments_for_java_call(call);\n+      kit.set_edges_for_java_call(call, false, false);\n+      Node *ret = kit.set_results_for_java_call(call, false);\n+      kit.push_node(init->return_type()->basic_type(), ret);\n+      JVMState *new_jvms = kit.transfer_exceptions_into_jvms();\n+\n+      add_exception_states_from(new_jvms);\n+      set_jvms(new_jvms);\n+      add_exception_state(make_exception_state(ex_node));\n+      return;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -938,0 +938,3 @@\n+  bool      _implicit_exception_init;\/\/ <init> call for an implicitly created exception\n+                                     \/\/ if -XX:+OptimizeImplicitExceptions. This also\n+                                     \/\/ overrides the symbolic call site info from bytecode.\n@@ -941,1 +944,1 @@\n-  MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false) {\n+  MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false), _implicit_exception_init(false) {\n@@ -948,1 +951,1 @@\n-    if (_override_symbolic_info) {\n+    if (_override_symbolic_info || _implicit_exception_init) {\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1258,0 +1258,1 @@\n+      mcall_java->_implicit_exception_init = call_java->implicit_exception_init();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -645,0 +645,4 @@\n+  product(bool, OptimizeImplicitExceptions, true, DIAGNOSTIC,               \\\n+          \"Create implicit, 'non-hot' exceptions right in compiled code \"   \\\n+          \"rather than deoptimizing and resorting back to the interpreter\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1089,3 +1089,11 @@\n-  Bytecode_invoke bytecode(caller, bci);\n-  int bytecode_index = bytecode.index();\n-  bc = bytecode.invoke_code();\n+  Bytecode_invoke bytecode = Bytecode_invoke_check(caller, bci);\n+  int bytecode_index = -1;\n+  if (bytecode.is_valid()) {\n+    \/\/ This is the normal case for invoke* bytecodes\n+    bytecode_index = bytecode.index();\n+    bc = bytecode.invoke_code();\n+  } else {\n+    \/\/ This is for implicit exceptions with -XX:+OptimizeImplicitExceptions\n+    \/\/ where we create an artificial call to *Exception::<init>()\n+    bc = Bytecodes::_invokespecial;\n+  }\n@@ -1094,1 +1102,1 @@\n-  if (attached_method.not_null()) {\n+  if (attached_method.not_null() && bytecode.is_valid()) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class ImplicitExceptions {\n+    static final int ASCII_SIZE = 128;\n+    static final boolean[] ASCII_ALPHA = new boolean[ASCII_SIZE];\n+    static final int testStringLengthLog = 7;\n+    static final int TestStringLenghtMask = (1 << testStringLengthLog) - 1;\n+    static final char[] testString = new char[1 << testStringLengthLog];\n+    int iterator = 0;\n+\n+    @Param({\"0.0\", \"0.33\", \"0.66\", \"1.00\"})\n+    public double exceptionProbability;\n+\n+    @Setup\n+    public void init() {\n+        for (int i = 0; i < ASCII_SIZE; i++) {\n+            if (i >= 'a' && i <= 'z' || i >= 'A' && i <= 'Z') {\n+              ASCII_ALPHA[i] = true;\n+            }\n+        }\n+        Random rnd = new Random();\n+        rnd.setSeed(Long.getLong(\"random.seed\", 42L));\n+        for (int i = 0; i < testString.length; i++) {\n+            if (rnd.nextDouble() < exceptionProbability) {\n+              testString[i] = 0xbad; \/\/ Something bigger than ASCII_SIZE\n+            }\n+            else {\n+              testString[i] = (char)rnd.nextInt(ASCII_SIZE);\n+            }\n+        }\n+    }\n+\n+    public boolean isAlphaWithExceptions(int c) {\n+        try {\n+            return ASCII_ALPHA[c];\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            return false;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench() {\n+        isAlphaWithExceptions(testString[iterator++ & TestStringLenghtMask]);\n+        \/\/if (++iterator == Long.MAX_VALUE) {\n+        \/\/    iterator = 0;\n+        \/\/}\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/ImplicitExceptions.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}