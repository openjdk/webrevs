{"files":[{"patch":"@@ -950,5 +950,19 @@\n-  \/\/ Concurrent weak root processing\n-  ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_work);\n-  ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_weak_roots_work);\n-  ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots_work);\n-  heap->workers()->run_task(&task);\n+  {\n+    \/\/ Concurrent weak root processing\n+    ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_work);\n+    ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_weak_roots_work);\n+    ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots_work);\n+    heap->workers()->run_task(&task);\n+  }\n+\n+  {\n+    \/\/ It is possible for mutators executing the load reference barrier to have\n+    \/\/ loaded an oop through a weak handle that has since been nulled out by\n+    \/\/ weak root processing. Handshaking here forces them to complete the\n+    \/\/ barrier before the GC cycle continues and does something that would\n+    \/\/ change the evaluation of the barrier (for example, resetting the TAMS\n+    \/\/ on trashed regions could make an oop appear to be marked _after_ the\n+    \/\/ region has been recycled).\n+    ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_rendezvous);\n+    heap->rendezvous_threads(\"Shenandoah Concurrent Weak Roots\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-  _abbreviated(false) {\n+  _abbreviated(false),\n+  _consecutive_degen_with_bad_progress(0) {\n@@ -304,3 +305,18 @@\n-  \/\/ Check for futility and fail. There is no reason to do several back-to-back Degenerated cycles,\n-  \/\/ because that probably means the heap is overloaded and\/or fragmented.\n-  if (!metrics.is_good_progress()) {\n+  \/\/ The most common scenario for lack of good progress following a degenerated GC is an accumulation of floating\n+  \/\/ garbage during the most recently aborted concurrent GC effort.  With generational GC, it is far more effective to\n+  \/\/ reclaim this floating garbage with another degenerated cycle (which focuses on young generation and might require\n+  \/\/ a pause of 200 ms) rather than a full GC cycle (which may require over 2 seconds with a 10 GB old generation).\n+  \/\/\n+  \/\/ In generational mode, we'll only upgrade to full GC if we've done two degen cycles in a row and both indicated\n+  \/\/ bad progress.  In non-generational mode, we'll preserve the original behavior, which is to upgrade to full\n+  \/\/ immediately following a degenerated cycle with bad progress.  This preserves original behavior of non-generational\n+  \/\/ Shenandoah so as to avoid introducing \"surprising new behavior.\"  It also makes less sense with non-generational\n+  \/\/ Shenandoah to replace a full GC with a degenerated GC, because both have similar pause times in non-generational\n+  \/\/ mode.\n+  if (!metrics.is_good_progress(_generation)) {\n+    _consecutive_degen_with_bad_progress++;\n+  } else {\n+    _consecutive_degen_with_bad_progress = 0;\n+  }\n+  if (!heap->mode()->is_generational() ||\n+      ((heap->shenandoah_policy()->consecutive_degenerated_gc_count() > 1) && (_consecutive_degen_with_bad_progress >= 2))) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  size_t _consecutive_degen_with_bad_progress;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -438,0 +438,3 @@\n+  \/\/ Note that capacity is the number of regions that had available memory at most recent rebuild.  It is not the\n+  \/\/ entire size of the young or global generation.  (Regions within the generation that were fully utilized at time of\n+  \/\/ rebuild are not counted as part of capacity.)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  if (metrics.is_good_progress()) {\n+  if (metrics.is_good_progress(heap->global_generation())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,13 @@\n-bool ShenandoahMetricsSnapshot::is_good_progress() {\n+\/\/ For degenerated GC, generation is Young in generational mode, Global in non-generational mode.\n+\/\/ For full GC, generation is always Global.\n+\/\/\n+\/\/ Note that the size of the chosen collection set is proportional to the relevant generation's collection set.\n+\/\/ Note also that the generation size may change following selection of the collection set, as a side effect\n+\/\/ of evacuation.  Evacuation may promote objects, causing old to grow and young to shrink.  Or this may be a\n+\/\/ mixed evacuation.  When old regions are evacuated, this typically allows young to expand.  In all of these\n+\/\/ various scenarios, the purpose of asking is_good_progress() is to determine if there is enough memory available\n+\/\/ within young generation to justify making an attempt to perform a concurrent collection.  For this reason, we'll\n+\/\/ use the current size of the generation (which may not be different than when the collection set was chosen) to\n+\/\/ assess how much free memory we require in order to consider the most recent GC to have had good progress.\n+\n+bool ShenandoahMetricsSnapshot::is_good_progress(ShenandoahGeneration* generation) {\n@@ -48,2 +60,8 @@\n-  size_t free_actual   = _heap->free_set()->available();\n-  size_t free_expected = _heap->max_capacity() \/ 100 * ShenandoahCriticalFreeThreshold;\n+  ShenandoahFreeSet* free_set = _heap->free_set();\n+  size_t free_actual   = free_set->available();\n+\n+  \/\/ ShenandoahCriticalFreeThreshold is expressed as a percentage.  We multiple this percentage by 1\/100th\n+  \/\/ of the generation capacity to determine whether the available memory within the generation exceeds the\n+  \/\/ critical threshold.\n+  size_t free_expected = (generation->max_capacity() \/ 100) * ShenandoahCriticalFreeThreshold;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  bool is_good_progress();\n+  bool is_good_progress(ShenandoahGeneration *generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}