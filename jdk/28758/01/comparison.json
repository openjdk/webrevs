{"files":[{"patch":"@@ -69,1 +69,2 @@\n-    const bool alloc_failure_pending = ShenandoahCollectorPolicy::is_allocation_failure(cancelled_cause);\n+    const bool alloc_failure_pending = ShenandoahCollectorPolicy::is_allocation_failure(cancelled_cause) ||\n+                                       ShenandoahCollectorPolicy::is_allocation_failure(_requested_gc_cause.load_relaxed());\n@@ -71,2 +72,5 @@\n-    const GCCause::Cause requested_gc_cause = _requested_gc_cause;\n-\n+    const GCCause::Cause requested_gc_cause = _requested_gc_cause.load_relaxed();\n+    if (is_gc_requested) {\n+      _gc_requested.unset();\n+      _requested_gc_cause.store_relaxed(GCCause::_no_gc);\n+    }\n@@ -172,2 +176,3 @@\n-      \/\/ If this cycle completed without being cancelled, notify waiters about it\n-      if (!heap->cancelled_gc()) {\n+      \/\/ If this cycle completed without being cancelled, or alloc_failure_pending is true(degen),\n+      \/\/ notify waiters about it\n+      if (!heap->cancelled_gc() || alloc_failure_pending) {\n@@ -233,2 +238,6 @@\n-    MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n-    ml.wait(sleep);\n+    {\n+      MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+      if (_requested_gc_cause.load_relaxed() == GCCause::_no_gc) {\n+        ml.wait(sleep);\n+      }\n+    }\n@@ -236,0 +245,4 @@\n+\n+  \/\/ In case any threads are waiting for a cycle to happen, notify them so they observe the shutdown.\n+  notify_gc_waiters();\n+  notify_alloc_failure_waiters();\n@@ -349,1 +362,2 @@\n-void ShenandoahControlThread::notify_control_thread(GCCause::Cause cause) {\n+void ShenandoahControlThread::notify_control_thread(GCCause::Cause cause, ShenandoahGeneration* generation) {\n+  assert(generation->is_global(), \"Must be\");\n@@ -354,1 +368,1 @@\n-  _requested_gc_cause = cause;\n+  _requested_gc_cause.store_relaxed(cause);\n@@ -359,0 +373,4 @@\n+void ShenandoahControlThread::notify_control_thread(GCCause::Cause cause) {\n+  notify_control_thread(cause, ShenandoahHeap::heap()->global_generation());\n+}\n+\n@@ -394,1 +412,0 @@\n-  _gc_requested.unset();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -44,2 +45,2 @@\n-  ShenandoahSharedFlag _gc_requested;\n-  GCCause::Cause       _requested_gc_cause;\n+  ShenandoahSharedFlag               _gc_requested;\n+  Atomic<GCCause::Cause>             _requested_gc_cause;\n@@ -58,0 +59,2 @@\n+  \/\/ Sets the requested cause and flag and notifies the control thread\n+  void notify_control_thread(GCCause::Cause cause, ShenandoahGeneration* generation) override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    request_gc(cause);\n+    notify_control_thread(cause, heap->mode()->is_generational() ? reinterpret_cast<ShenandoahGeneration *>(heap->young_generation()) : heap->global_generation());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class ShenandoahGeneration;\n+\n@@ -65,0 +67,3 @@\n+ \/\/ Sets the requested cause and flag and notifies the control thread\n+  virtual void notify_control_thread(GCCause::Cause cause, ShenandoahGeneration* generation) { }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-      if (_requested_gc_cause == GCCause::_no_gc) {\n+      if (_requested_gc_cause.load_relaxed() == GCCause::_no_gc) {\n@@ -99,1 +99,1 @@\n-  _requested_gc_cause = GCCause::_shenandoah_stop_vm;\n+  _requested_gc_cause.store_relaxed(GCCause::_shenandoah_stop_vm);\n@@ -118,1 +118,1 @@\n-    request.cause = _requested_gc_cause;\n+    request.cause = _requested_gc_cause.load_relaxed();\n@@ -123,1 +123,1 @@\n-    _requested_gc_cause = GCCause::_no_gc;\n+    _requested_gc_cause.store_relaxed(GCCause::_no_gc);\n@@ -648,1 +648,1 @@\n-                          GCCause::to_string(_requested_gc_cause),\n+                          GCCause::to_string(_requested_gc_cause.load_relaxed()),\n@@ -673,2 +673,3 @@\n-      if (_requested_gc_cause != GCCause::_no_gc) {\n-        log_debug(gc, thread)(\"Reject request for concurrent gc because another gc is pending: %s\", GCCause::to_string(_requested_gc_cause));\n+      GCCause::Cause requested_gc_cause = _requested_gc_cause.load_relaxed();\n+      if (requested_gc_cause != GCCause::_no_gc) {\n+        log_debug(gc, thread)(\"Reject request for concurrent gc because another gc is pending: %s\", GCCause::to_string(requested_gc_cause));\n@@ -699,1 +700,1 @@\n-  _requested_gc_cause = cause;\n+  _requested_gc_cause.store_relaxed(cause);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -66,1 +67,1 @@\n-  GCCause::Cause  _requested_gc_cause;\n+  Atomic<GCCause::Cause> _requested_gc_cause;\n@@ -140,1 +141,1 @@\n-  void notify_control_thread(GCCause::Cause cause, ShenandoahGeneration* generation);\n+  void notify_control_thread(GCCause::Cause cause, ShenandoahGeneration* generation) override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}