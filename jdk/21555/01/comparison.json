{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,0 @@\n-    public static final int IO_REPARSE_TAG_SYMLINK              = 0xA000000C;\n@@ -77,0 +76,2 @@\n+    public static final int IO_REPARSE_TAG_MOUNT_POINT          = 0xA0000003;\n+    public static final int IO_REPARSE_TAG_SYMLINK              = 0xA000000C;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -418,1 +418,2 @@\n-        return reparseTag == IO_REPARSE_TAG_SYMLINK;\n+        return (reparseTag == IO_REPARSE_TAG_SYMLINK ||\n+                reparseTag == IO_REPARSE_TAG_MOUNT_POINT);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileAttributes.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-            \/\/ Driver specifier\n+            \/\/ Drive specifier\n@@ -317,2 +317,2 @@\n-             *     USHORT  ReparseDataLength;\n-             *     USHORT  Reserved;\n+             *     USHORT ReparseDataLength;\n+             *     USHORT Reserved;\n@@ -321,4 +321,5 @@\n-             *             USHORT  SubstituteNameOffset;\n-             *             USHORT  SubstituteNameLength;\n-             *             USHORT  PrintNameOffset;\n-             *             USHORT  PrintNameLength;\n+             *             USHORT SubstituteNameOffset;\n+             *             USHORT SubstituteNameLength;\n+             *             USHORT PrintNameOffset;\n+             *             USHORT PrintNameLength;\n+             *             ULONG  Flags;\n@@ -328,4 +329,4 @@\n-             *             USHORT  SubstituteNameOffset;\n-             *             USHORT  SubstituteNameLength;\n-             *             USHORT  PrintNameOffset;\n-             *             USHORT  PrintNameLength;\n+             *             USHORT SubstituteNameOffset;\n+             *             USHORT SubstituteNameLength;\n+             *             USHORT PrintNameOffset;\n+             *             USHORT PrintNameLength;\n@@ -341,3 +342,0 @@\n-            final short OFFSETOF_PATHOFFSET = 8;\n-            final short OFFSETOF_PATHLENGTH = 10;\n-            final short OFFSETOF_PATHBUFFER = 16 + 4;   \/\/ check this\n@@ -346,1 +344,2 @@\n-            if (tag != IO_REPARSE_TAG_SYMLINK) {\n+            if (!(tag == IO_REPARSE_TAG_SYMLINK ||\n+                  tag == IO_REPARSE_TAG_MOUNT_POINT)) {\n@@ -351,0 +350,9 @@\n+            final short OFFSETOF_PATHOFFSET = 8;\n+            final short OFFSETOF_PATHLENGTH = 10;\n+            final short OFFSETOF_PATHBUFFER;\n+            if (tag == IO_REPARSE_TAG_SYMLINK)\n+                \/\/ add 4 for SymbolicLinkReparseBuffer.Flags\n+                OFFSETOF_PATHBUFFER = 16 + 4;\n+            else \/\/ IO_REPARSE_TAG_MOUNT_POINT\n+                OFFSETOF_PATHBUFFER = 16;\n+\n@@ -367,0 +375,15 @@\n+\n+            if (tag == IO_REPARSE_TAG_MOUNT_POINT) {\n+                \/\/ check that target specifies an absolute path but not\n+                \/\/ whether it resolves to a directory. if it is not a\n+                \/\/ directory junction then it is likely a volume junction\n+                \/\/ which we do not treat as equivalent to a symbolic link\n+                char c0 = target.charAt(0);\n+                if (!(c0 <= 'z' && c0 >= 'a' || c0 <= 'Z' && c0 >= 'A') ||\n+                    target.charAt(1) != ':' || target.charAt(2) != '\\\\') {\n+                    String pathname = path.getPathForExceptionMessage();\n+                    throw new NotLinkException(pathname, target,\n+                        \"Reparse point is not a directory junction\");\n+                }\n+            }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":38,"deletions":15,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.DosFileAttributeView;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 1234567\n+ * @summary Verifies java.io support for Windows directory junctions\n+ * @requires os.family == \"windows\"\n+ * @library \/test\/lib\n+ * @run junit\/othervm\/native Junctions\n+ *\/\n+@TestMethodOrder(OrderAnnotation.class)\n+@EnabledOnOs(OS.WINDOWS)\n+public class Junctions {\n+    private static final String SOME_WORDS = \"Voici des mots\";\n+\n+    private static final String DIR = \"dir\";\n+    private static final String SUB = \"sub\";\n+    private static final String FILE = \"file.txt\";\n+    private static final String JUNCTION = \"junction\";\n+    private static final String RENAMED = \"renamed\";\n+\n+    private static File dir = new File(DIR);\n+    private static File sub = new File(dir, SUB);\n+    private static File file = new File(sub, FILE);\n+    private static File junction = new File(JUNCTION); \/\/ junction -> dir\\sub\n+    private static File renamed = new File(RENAMED); \/\/ renamed -> dir\\sub\n+\n+    \/\/ Create DIR\\SUB\\FILE\n+    @BeforeAll\n+    static void before() throws IOException {\n+        assertTrue(sub.mkdirs());\n+        assertTrue(file.createNewFile());\n+    }\n+\n+    \/\/ Create JUNCTION -> DIR\\SUB\n+    @Test\n+    @Order(1)\n+    void createJunction() throws IOException {\n+        assertTrue(FileUtils.createDirectoryJunction(JUNCTION, sub.toString()));\n+        assertTrue(junction.exists());\n+    }\n+\n+    \/\/ Verify that output to linked file ends up in file\n+    @Test\n+    @Order(2)\n+    void write() throws IOException {\n+        File linkedFile = new File(junction, FILE);\n+        try (FileOutputStream fos = new FileOutputStream(linkedFile)) {\n+            fos.write(SOME_WORDS.getBytes());\n+        }\n+        try (FileInputStream fis = new FileInputStream(file)) {\n+            byte[] b = new byte[SOME_WORDS.length()];\n+            fis.read(b);\n+            assertEquals(SOME_WORDS, new String(b));\n+        }\n+    }\n+\n+    \/\/ Verify that input from linked file is as expected\n+    @Test\n+    @Order(3)\n+    void read() throws IOException {\n+        File linkedFile = new File(junction, FILE);\n+        try (FileInputStream fis = new FileInputStream(linkedFile)) {\n+            byte[] b = new byte[SOME_WORDS.length()];\n+            fis.read(b);\n+            assertEquals(SOME_WORDS, new String(b));\n+        }\n+    }\n+\n+    \/\/ Verify that the junction is not hidden\n+    @Test\n+    @Order(4)\n+    void isNotHidden() throws IOException {\n+        assertFalse(junction.isHidden());\n+    }\n+\n+    \/\/ Hide the junction target and verify that the junction is hidden\n+    @Test\n+    @Order(5)\n+    void isHidden() throws IOException {\n+        DosFileAttributeView dview = Files.getFileAttributeView(sub.toPath(),\n+            DosFileAttributeView.class);\n+        dview.setHidden(true);\n+        assertTrue(junction.isHidden());\n+        dview.setHidden(false);\n+        assertFalse(junction.isHidden());\n+    }\n+\n+    \/\/ Rename the junction and verify the non-existence of the old junction,\n+    \/\/ the existence of the new one, and the target of the new onw\n+    @Test\n+    @Order(6)\n+    void rename() throws IOException {\n+        assertTrue(junction.renameTo(renamed));\n+        assertFalse(junction.exists());\n+        assertTrue(renamed.exists());\n+        File linkedFile = new File(renamed, FILE);\n+        try (FileInputStream fis = new FileInputStream(linkedFile)) {\n+            byte[] b = new byte[SOME_WORDS.length()];\n+            fis.read(b);\n+            assertEquals(SOME_WORDS, new String(b));\n+        }\n+    }\n+\n+    \/\/ Delete the renamed junction and verify that the target still exists\n+    @Test\n+    @Order(7)\n+    void delete() throws IOException {\n+        assertTrue(renamed.exists());\n+        assertTrue(renamed.delete());\n+        assertFalse(renamed.exists());\n+        assertTrue(sub.exists());\n+    }\n+\n+    @Test\n+    @Order(8)\n+    void junctionToJunction() throws IOException {\n+        File j1 = new File(\"jcn1\");\n+        File j2 = new File(dir, \"jcn2\");\n+        FileUtils.createDirectoryJunction(j2.toString(), sub.toString());\n+        FileUtils.createDirectoryJunction(j1.toString(), j2.toString());\n+        File linkedFile = new File(j1, FILE);\n+        try (FileInputStream fis = new FileInputStream(linkedFile)) {\n+            byte[] b = new byte[SOME_WORDS.length()];\n+            fis.read(b);\n+            assertEquals(SOME_WORDS, new String(b));\n+        } finally {\n+            j1.delete();\n+            j2.delete();\n+        }\n+    }\n+\n+    @Test\n+    @Order(9)\n+    void linkToJunction() throws IOException {\n+        Path link = Path.of(\"link\");\n+        File junc = new File(dir, \"junc\");\n+        try {\n+            Files.createSymbolicLink(link, junc.toPath());\n+        } catch (IOException ioe) {\n+            if (ioe.getMessage().contains(\"privilege\"))\n+                Assumptions.assumeFalse(true, \"No privilege to create links\");\n+            else\n+                throw ioe;\n+        }\n+        FileUtils.createDirectoryJunction(junc.toString(), sub.toString());\n+        File linkedFile = new File(link.toFile(), FILE);\n+        try (FileInputStream fis = new FileInputStream(linkedFile)) {\n+            byte[] b = new byte[SOME_WORDS.length()];\n+            fis.read(b);\n+            assertEquals(SOME_WORDS, new String(b));\n+        } finally {\n+            Files.delete(link);\n+            junc.delete();\n+        }\n+    }\n+\n+    @AfterAll\n+    static void after() {\n+        file.delete();\n+        sub.delete();\n+        dir.delete();\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/etc\/Junctions.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.DosFileAttributes;\n+import java.nio.file.attribute.DosFileAttributeView;\n+import java.util.Set;\n+import static java.nio.file.StandardOpenOption.*;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 1234567\n+ * @summary Verifies java.io support for Windows directory junctions\n+ * @requires os.family == \"windows\"\n+ * @library \/test\/lib\n+ * @run junit\/othervm\/native Junctions\n+ *\/\n+@TestMethodOrder(OrderAnnotation.class)\n+@EnabledOnOs(OS.WINDOWS)\n+public class Junctions {\n+    private static final String SOME_WORDS = \"Voici des mots\";\n+\n+    private static final String DIR = \"dir\";\n+    private static final String SUB = \"sub\";\n+    private static final String FILE = \"file.txt\";\n+    private static final String JUNCTION = \"junction\";\n+    private static final String RENAMED = \"renamed\";\n+\n+    private static Path dir = Path.of(DIR);\n+    private static Path sub = dir.resolve(SUB);\n+    private static Path file = sub.resolve(FILE);\n+    private static Path junction = Path.of(JUNCTION); \/\/ junction -> dir\\sub\n+    private static Path renamed = Path.of(RENAMED); \/\/ renamed -> dir\\sub\n+\n+    \/\/ Create DIR\\SUB\\FILE\n+    @BeforeAll\n+    static void before() throws IOException {\n+        assertTrue(Files.exists(Files.createDirectories(sub)));\n+        assertTrue(Files.exists(Files.createFile(file)));\n+    }\n+\n+    \/\/ Create JUNCTION -> DIR\\SUB\n+    @Test\n+    @Order(1)\n+    void createJunction() throws IOException {\n+        assertTrue(FileUtils.createDirectoryJunction(JUNCTION, sub.toString()));\n+        assertTrue(Files.exists(junction));\n+    }\n+\n+    \/\/ Verify that output to linked file ends up in file\n+    @Test\n+    @Order(2)\n+    void write() throws IOException {\n+        Path linkedFile = junction.resolve(FILE);\n+        try (FileChannel fc = FileChannel.open(linkedFile, WRITE)) {\n+            fc.write(ByteBuffer.wrap(SOME_WORDS.getBytes()));\n+        }\n+        try (FileChannel fc = FileChannel.open(file, READ)) {\n+            byte[] b = new byte[SOME_WORDS.length()];\n+            ByteBuffer buf = ByteBuffer.wrap(b);\n+            fc.read(buf);\n+            assertEquals(SOME_WORDS, new String(b));\n+        }\n+    }\n+\n+    \/\/ Verify that input from linked file is as expected\n+    @Test\n+    @Order(3)\n+    void read() throws IOException {\n+        Path linkedFile = junction.resolve(FILE);\n+        try (FileChannel fc = FileChannel.open(linkedFile, READ)) {\n+            byte[] b = new byte[SOME_WORDS.length()];\n+            ByteBuffer buf = ByteBuffer.wrap(b);\n+            fc.read(buf);\n+            assertEquals(SOME_WORDS, new String(b));\n+        }\n+    }\n+\n+    \/\/ Verify that the junction is not hidden\n+    @Test\n+    @Order(4)\n+    void isNotHidden() throws IOException {\n+        DosFileAttributeView dview = Files.getFileAttributeView(junction,\n+            DosFileAttributeView.class);\n+        DosFileAttributes dattr = dview.readAttributes();\n+        assertFalse(dattr.isHidden());\n+        dview = Files.getFileAttributeView(junction, DosFileAttributeView.class,\n+            LinkOption.NOFOLLOW_LINKS);\n+        dattr = dview.readAttributes();\n+        assertFalse(dattr.isHidden());\n+    }\n+\n+    \/\/ Hide the junction target and verify that the junction is hidden\n+    @Test\n+    @Order(5)\n+    void isHidden() throws IOException {\n+        DosFileAttributeView sview = Files.getFileAttributeView(sub,\n+            DosFileAttributeView.class);\n+        sview.setHidden(true);\n+        DosFileAttributeView jview = Files.getFileAttributeView(junction,\n+            DosFileAttributeView.class);\n+        DosFileAttributes jattr = jview.readAttributes();\n+        assertTrue(jattr.isHidden());\n+        sview.setHidden(false);\n+        jview = Files.getFileAttributeView(junction,\n+            DosFileAttributeView.class);\n+        jattr = jview.readAttributes();\n+        assertFalse(jattr.isHidden());\n+    }\n+\n+    \/\/ Rename the junction and verify the non-existence of the old junction,\n+    \/\/ the existence of the new one, and the target of the new onw\n+    @Test\n+    @Order(6)\n+    void move() throws IOException {\n+        Files.move(junction, renamed);\n+        assertTrue(Files.notExists(junction));\n+        assertTrue(Files.exists(renamed));\n+        Path linkedFile = renamed.resolve(FILE);\n+        try (FileChannel fc = FileChannel.open(linkedFile, READ)) {\n+            byte[] b = new byte[SOME_WORDS.length()];\n+            fc.read(ByteBuffer.wrap(b));\n+            assertEquals(SOME_WORDS, new String(b));\n+        }\n+    }\n+\n+    \/\/ Delete the renamed junction and verify that the target still exists\n+    @Test\n+    @Order(7)\n+    void delete() throws IOException {\n+        assertTrue(Files.exists(renamed));\n+        Files.delete(renamed);\n+        assertTrue(Files.notExists(renamed));\n+        assertTrue(Files.exists(sub));\n+    }\n+\n+    @Test\n+    @Order(8)\n+    void junctionToJunction() throws IOException {\n+        Path j1 = Path.of(\"jcn1\");\n+        Path j2 = dir.resolve(\"jcn2\");\n+        FileUtils.createDirectoryJunction(j2.toString(), sub.toString());\n+        FileUtils.createDirectoryJunction(j1.toString(), j2.toString());\n+        Path linkedFile = j1.resolve(FILE);\n+        try (FileChannel fc = FileChannel.open(linkedFile, READ)) {\n+            byte[] b = new byte[SOME_WORDS.length()];\n+            fc.read(ByteBuffer.wrap(b));\n+            assertEquals(SOME_WORDS, new String(b));\n+        } finally {\n+            Files.deleteIfExists(j1);\n+            Files.deleteIfExists(j2);\n+        }\n+    }\n+\n+    @Test\n+    @Order(9)\n+    void linkToJunction() throws IOException {\n+        Path link = Path.of(\"link\");\n+        Path junc = dir.resolve(\"junc\");\n+        try {\n+            Files.createSymbolicLink(link, junc);\n+        } catch (IOException ioe) {\n+            if (ioe.getMessage().contains(\"privilege\"))\n+                Assumptions.assumeFalse(true, \"No privilege to create links\");\n+            else\n+                throw ioe;\n+        }\n+        FileUtils.createDirectoryJunction(junc.toString(), sub.toString());\n+        Path linkedFile = link.resolve(FILE);\n+        try (FileChannel fc = FileChannel.open(linkedFile, READ)) {\n+            byte[] b = new byte[SOME_WORDS.length()];\n+            fc.read(ByteBuffer.wrap(b));\n+            assertEquals(SOME_WORDS, new String(b));\n+        } finally {\n+            Files.deleteIfExists(link);\n+            Files.deleteIfExists(junc);\n+        }\n+    }\n+\n+    @Test\n+    @Order(10)\n+    void readSymbolicLink() throws IOException {\n+        Path junc = dir.resolve(\"junc\");\n+        try {\n+            FileUtils.createDirectoryJunction(junc.toString(), sub.toString());\n+            Path subAbs = sub.toAbsolutePath();\n+            Path target = Files.readSymbolicLink(junc);\n+            assertEquals(subAbs, target);\n+        } finally {\n+            Files.deleteIfExists(junc);\n+        }\n+    }\n+\n+    @Test\n+    @Order(11)\n+    void takeAWalk() throws IOException {\n+        Path juncdir = dir.resolve(\"juncdir\");\n+        Path juncfile = dir.resolve(\"juncfile\");\n+        try {\n+            FileUtils.createDirectoryJunction(juncdir.toString(), sub.toString());\n+            FileUtils.createDirectoryJunction(juncfile.toString(), file.toString());\n+            Path path = dir.toAbsolutePath();\n+            Path parent = path.getParent();\n+            System.out.println(\"path: \" + path + \"\\nparent: \" + parent);\n+            Files.walkFileTree(parent,\n+                Set.of(FileVisitOption.FOLLOW_LINKS),\n+                1000,\n+                new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir,\n+                                                         BasicFileAttributes attrs) {\n+                    System.out.println(\"Visiting directory \" + dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult visitFile(Path file,\n+                                                 BasicFileAttributes attrs) {\n+                    System.out.println(\"Visiting file \" + file);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } finally {\n+            Files.deleteIfExists(juncdir);\n+            Files.deleteIfExists(juncfile);\n+        }\n+    }\n+\n+    @AfterAll\n+    static void after() throws IOException {\n+        Files.delete(file);\n+        Files.delete(sub);\n+        Files.delete(dir);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/Junctions.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.io.File;\n@@ -36,0 +37,1 @@\n+import java.nio.file.LinkOption;\n@@ -418,0 +420,20 @@\n+    \/\/ Create a link from \"junction\" to the real path of \"target\"\n+    public static boolean createDirectoryJunction(String junction, String target)\n+        throws IOException\n+    {\n+        \/\/ Convert \"target\" to its real path\n+        target = new File(target).getAbsolutePath().toString();\n+\n+        \/\/ Create a directory junction or a symbolic link\n+        if (IS_WINDOWS) {\n+            if (!nativeLibLoaded) {\n+                System.loadLibrary(\"FileUtils\");\n+                nativeLibLoaded = true;\n+            }\n+            return createWinDirectoryJunction(junction, target);\n+        } else {\n+            Files.createSymbolicLink(Path.of(junction), Path.of(target));\n+            return Files.exists(Path.of(junction), LinkOption.NOFOLLOW_LINKS);\n+        }\n+    }\n+\n@@ -419,0 +441,2 @@\n+    private static native boolean createWinDirectoryJunction(String junction,\n+        String target) throws IOException;\n","filename":"test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include \"jni_util.h\"\n+#include <string.h>\n@@ -31,0 +33,8 @@\n+#include <fileapi.h>\n+#include <handleapi.h>\n+#include <ioapiset.h>\n+#include <winioctl.h>\n+#include <errhandlingapi.h>\n+\n+\/\/ Based on Microsoft documentation\n+#define MAX_REPARSE_BUFFER_SIZE 16384\n@@ -32,1 +42,31 @@\n-JNIEXPORT jlong JNICALL Java_jdk_test_lib_util_FileUtils_getWinProcessHandleCount(JNIEnv *env)\n+\/\/ Unavailable in standard header files:\n+\/\/ copied from Microsoft documentation\n+typedef struct _REPARSE_DATA_BUFFER {\n+    ULONG  ReparseTag;\n+    USHORT ReparseDataLength;\n+    USHORT Reserved;\n+    union {\n+        struct {\n+            USHORT SubstituteNameOffset;\n+            USHORT SubstituteNameLength;\n+            USHORT PrintNameOffset;\n+            USHORT PrintNameLength;\n+            ULONG  Flags;\n+            WCHAR  PathBuffer[1];\n+        } SymbolicLinkReparseBuffer;\n+        struct {\n+            USHORT SubstituteNameOffset;\n+            USHORT SubstituteNameLength;\n+            USHORT PrintNameOffset;\n+            USHORT PrintNameLength;\n+            WCHAR  PathBuffer[1];\n+        } MountPointReparseBuffer;\n+        struct {\n+            UCHAR DataBuffer[1];\n+        } GenericReparseBuffer;\n+    } DUMMYUNIONNAME;\n+} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;\n+\n+JNIEXPORT jlong JNICALL\n+Java_jdk_test_lib_util_FileUtils_getWinProcessHandleCount\n+    (JNIEnv* env)\n@@ -43,0 +83,112 @@\n+void throwIOExceptionWithLastError(JNIEnv* env) {\n+#define BUFSIZE 256\n+    DWORD errval;\n+    WCHAR buf[BUFSIZE];\n+\n+    if ((errval = GetLastError()) != 0) {\n+        jsize n = FormatMessageW(\n+            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n+            NULL, errval, 0, buf, BUFSIZE, NULL);\n+\n+        jclass ioExceptionClass = (*env)->FindClass(env, \"java\/io\/IOException\");\n+        (*env)->ThrowNew(env, ioExceptionClass, (const char*) buf);\n+    }\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_test_lib_util_FileUtils_createWinDirectoryJunction\n+    (JNIEnv* env, jclass unused, jstring sjunction, jstring starget)\n+{\n+    const jshort bpc = sizeof(wchar_t); \/\/ bytes per character\n+    HANDLE hJunction = INVALID_HANDLE_VALUE;\n+\n+    const jchar* junction = (*env)->GetStringChars(env, sjunction, NULL);\n+    const jchar* target   = (*env)->GetStringChars(env, starget, NULL);\n+    if (junction == NULL || target == NULL) {\n+        jclass npeClass = (*env)->FindClass(env, \"java\/lang\/NullPointerException\");\n+        (*env)->ThrowNew(env, npeClass, NULL);\n+        goto err;\n+    }\n+\n+    USHORT wlen = (USHORT)wcslen(target);\n+    USHORT blen = (USHORT)(wlen * sizeof(wchar_t));\n+\n+    void* lpInBuffer = calloc(MAX_REPARSE_BUFFER_SIZE, sizeof(char));\n+    if (lpInBuffer == NULL) {\n+        jclass oomeClass = (*env)->FindClass(env, \"java\/lang\/OutOfMemoryError\");\n+        (*env)->ThrowNew(env, oomeClass, NULL);\n+        goto err;\n+    }\n+\n+    if (CreateDirectoryW(junction, NULL) == 0) {\n+        throwIOExceptionWithLastError(env);\n+        goto err;\n+    }\n+\n+    hJunction = CreateFileW(junction, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,\n+        FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+    if (hJunction == INVALID_HANDLE_VALUE) {\n+        throwIOExceptionWithLastError(env);\n+        goto err;\n+    }\n+\n+    PREPARSE_DATA_BUFFER reparseBuffer = (PREPARSE_DATA_BUFFER)lpInBuffer;\n+    reparseBuffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n+    reparseBuffer->Reserved = 0;\n+    WCHAR* prefix = L\"\\\\??\\\\\";\n+    USHORT prefixLength = (USHORT)(bpc * wcslen(prefix));\n+    reparseBuffer->MountPointReparseBuffer.SubstituteNameOffset = 0;\n+    reparseBuffer->MountPointReparseBuffer.SubstituteNameLength =\n+        prefixLength + blen;\n+    reparseBuffer->MountPointReparseBuffer.PrintNameOffset =\n+        prefixLength + blen + sizeof(WCHAR);\n+    reparseBuffer->MountPointReparseBuffer.PrintNameLength = blen;\n+    memcpy(&reparseBuffer->MountPointReparseBuffer.PathBuffer,\n+        prefix, prefixLength);\n+    memcpy(&reparseBuffer->MountPointReparseBuffer.PathBuffer[prefixLength\/bpc],\n+        target, blen);\n+    memcpy(&reparseBuffer->MountPointReparseBuffer.PathBuffer[prefixLength\/bpc + blen\/bpc + 1],\n+        target, blen);\n+    reparseBuffer->ReparseDataLength =\n+        (USHORT)(sizeof(reparseBuffer->MountPointReparseBuffer) +\n+        prefixLength + bpc*blen + bpc);\n+    DWORD nInBufferSize = FIELD_OFFSET(REPARSE_DATA_BUFFER,\n+        MountPointReparseBuffer) + reparseBuffer->ReparseDataLength;\n+    BOOL result = DeviceIoControl(hJunction, FSCTL_SET_REPARSE_POINT,\n+                                  lpInBuffer, nInBufferSize,\n+                                  NULL, 0, NULL, NULL);\n+\n+    (*env)->ReleaseStringChars(env, sjunction, junction);\n+    (*env)->ReleaseStringChars(env, starget, target);\n+    free(lpInBuffer);\n+    lpInBuffer = NULL;\n+\n+    if (result == 0) {\n+        throwIOExceptionWithLastError(env);\n+        goto err;\n+    }\n+\n+    if (CloseHandle(hJunction) == 0) {\n+        throwIOExceptionWithLastError(env);\n+        goto err;\n+    }\n+\n+    return JNI_TRUE;\n+\n+err:\n+    if (junction != NULL) {\n+        (*env)->ReleaseStringChars(env, sjunction, junction);\n+        if (target != NULL) {\n+            (*env)->ReleaseStringChars(env, starget, target);\n+            if (lpInBuffer != NULL) {\n+                free(lpInBuffer);\n+                if (hJunction != INVALID_HANDLE_VALUE) {\n+                    \/\/ Ignore any error in CloseHandle\n+                    CloseHandle(hJunction);\n+                }\n+            }\n+        }\n+    }\n+    return JNI_FALSE;\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/libFileUtils.c","additions":154,"deletions":2,"binary":false,"changes":156,"status":"modified"}]}