{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,13 @@\n+ * @implNote\n+ * The JDK's {@code WatchService} implementations buffer up to 512 pending\n+ * events for each registered watchable object. If this limit is exceeded,\n+ * pending events are discarded and the special\n+ * {@link StandardWatchEventKinds#OVERFLOW OVERFLOW} event is queued. This\n+ * special event is the trigger to re-examine the state of the object, e.g.\n+ * scan a watched directory to get an updated list of the files in the\n+ * directory. The limit for the pending events can be changed from its default\n+ * with the system property {@code jdk.nio.file.WatchService.maxEventsPerPoll}\n+ * set to a value that parses as a positive integer. This may be useful in\n+ * environments where there is a high volume of changes and where the impact\n+ * of discarded events is high.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/WatchService.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,3 @@\n+import jdk.internal.util.ArraysSupport;\n+import sun.security.action.GetPropertyAction;\n+\n@@ -37,0 +40,2 @@\n+    private static final int DEFAULT_MAX_EVENT_LIST_SIZE = 512;\n+\n@@ -38,1 +43,1 @@\n-     * Maximum size of event list (in the future this may be tunable)\n+     * Maximum size of event list before dropping events and signalling OVERFLOW\n@@ -40,1 +45,18 @@\n-    static final int MAX_EVENT_LIST_SIZE    = 512;\n+    static final int MAX_EVENT_LIST_SIZE;\n+    static {\n+        String rawValue = GetPropertyAction.privilegedGetProperty(\n+            \"jdk.nio.file.WatchService.maxEventsPerPoll\",\n+            String.valueOf(DEFAULT_MAX_EVENT_LIST_SIZE));\n+        int intValue;\n+        try {\n+            \/\/ Clamp to max array length to signal OVERFLOW and drop events\n+            \/\/ before OOMing.\n+            intValue = Math.clamp(\n+                Long.decode(rawValue),\n+                1,\n+                ArraysSupport.SOFT_MAX_ARRAY_LENGTH);\n+        } catch (NumberFormatException e) {\n+            intValue = DEFAULT_MAX_EVENT_LIST_SIZE;\n+        }\n+        MAX_EVENT_LIST_SIZE = intValue;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractWatchKey.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8330077\n+ * @summary Tests WatchService behavior with more entries in a watched directory\n+ *     than the default event limit\n+ * @library ..\n+ * @run main\/othervm LotsOfEntries 600 fail\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=invalid LotsOfEntries 600 fail\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=-5 LotsOfEntries 5 fail\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=5 LotsOfEntries 5 pass\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=5 LotsOfEntries 6 fail\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=700 LotsOfEntries 600 pass\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=3000000000 LotsOfEntries 600 pass\n+ *\/\n+\n+import java.nio.file.*;\n+import static java.nio.file.StandardWatchEventKinds.*;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+public class LotsOfEntries {\n+\n+    static void testCreateLotsOfEntries(Path dir, int numEvents, boolean fail) throws Exception {\n+        try (WatchService watcher = FileSystems.getDefault().newWatchService()) {\n+            System.out.format(\"register %s for events\\n\", dir);\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE);\n+\n+            System.out.format(\"create %d entries\\n\", numEvents);\n+            Set<Path> entries = new HashSet<>();\n+            for (int i = 0; i < numEvents; i++) {\n+                Path entry = dir.resolve(\"entry\" + i);\n+                entries.add(entry);\n+                Files.createFile(entry);\n+            }\n+\n+            \/\/ Wait for all events to be signalled - the timeout is long to\n+            \/\/ allow for polling implementations. Since we specifically want to\n+            \/\/ test the maximum number of events buffered for a single\n+            \/\/ WatchKey#pollEvents call, we need to poll on the WatchService\n+            \/\/ repeatedly until all (not just some) events have been signalled.\n+            System.out.println(\"poll watcher...\");\n+            WatchKey signalledKey;\n+            do {\n+              signalledKey = watcher.poll(10, TimeUnit.SECONDS);\n+              if (signalledKey != null && signalledKey != key) {\n+                throw new RuntimeException(\"Unexpected key returned from poll\");\n+              }\n+            } while (signalledKey != null);\n+\n+            if (fail) {\n+                System.out.println(\"poll expecting overflow...\");\n+                var events = key.pollEvents();\n+                if (events.size() != 1) {\n+                    throw new RuntimeException(\n+                        \"Expected overflow event, got: \" + toString(events));\n+                }\n+                if (!events.getFirst().kind().equals(OVERFLOW)) {\n+                    throw new RuntimeException(\n+                        \"Expected overflow event, got: \" + toString(events));\n+                }\n+            } else {\n+                System.out.println(\"poll not expecting overflow...\");\n+                List<WatchEvent<?>> events = key.pollEvents();\n+                Set<Path> contexts = events.stream()\n+                    .map(WatchEvent::context)\n+                    .map(Path.class::cast)\n+                    .map(entry -> dir.resolve(entry))\n+                    .collect(Collectors.toSet());\n+                if (!entries.equals(contexts)) {\n+                    throw new RuntimeException(\n+                        \"Expected events on: \" + entries + \", got: \" + toString(events));\n+                }\n+            }\n+        }\n+    }\n+\n+    static String toString(List<WatchEvent<?>> events) {\n+        return events.stream()\n+            .map(LotsOfEntries::toString)\n+            .collect(Collectors.joining(\", \"));\n+    }\n+\n+    static String toString(WatchEvent event) {\n+        return String.format(\"%s(%d): %s\", event.kind(), event.count(), event.context());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path dir = TestUtil.createTemporaryDirectory();\n+        int numEvents = Integer.parseInt(args[0]);\n+        boolean fail = args[1].equals(\"fail\");\n+        try {\n+            testCreateLotsOfEntries(dir, numEvents, fail);\n+        } finally {\n+            TestUtil.removeAll(dir);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/WatchService\/LotsOfEntries.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}