{"files":[{"patch":"@@ -49,4 +49,5 @@\n- * designated non-static {@code volatile int} fields of designated classes.\n- * This class is designed for use in atomic data structures in which\n- * several fields of the same node are independently subject to atomic\n- * updates.\n+ * designated non-static {@code volatile int} fields of designated\n+ * classes, providing a subset of the functionality of class {@link\n+ * VarHandle} that should be used instead.  This class is designed for\n+ * use in atomic data structures in which several fields of the same\n+ * node are independently subject to atomic updates.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,4 +49,5 @@\n- * designated non-static {@code volatile long} fields of designated classes.\n- * This class is designed for use in atomic data structures in which\n- * several fields of the same node are independently subject to atomic\n- * updates.\n+ * designated non-static {@code volatile long} fields of designated\n+ * classes, providing a subset of the functionality of class {@link\n+ * VarHandle} that should be used instead.  This class is designed for\n+ * use in atomic data structures in which several fields of the same\n+ * node are independently subject to atomic updates.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,5 +49,6 @@\n- * designated non-static {@code volatile} reference fields of designated\n- * classes.  This class is designed for use in atomic data structures\n- * in which several reference fields of the same node are\n- * independently subject to atomic updates. For example, a tree node\n- * might be declared as\n+ * designated non-static {@code volatile} reference fields of\n+ * designated classes, providing a subset of the functionality of\n+ * class {@link VarHandle} that should be used instead.  This class\n+ * may be used in atomic data structures in which several reference\n+ * fields of the same node are independently subject to atomic\n+ * updates. For example, a tree node might be declared as\n@@ -71,0 +72,16 @@\n+ * However, it is preferable to use {@link VarHandle}:\n+ * <pre> {@code\n+ * class Node {\n+ *   private volatile Node left, right;\n+ *\n+ *   private static final VarHandle LEFT = MethodHandles.lookup().\n+ *      findVarHandle(Node.class, \"left\", Node.class);\n+ *   private static final VarHandle RIGHT = MethodHandles.lookup().\n+ *      findVarHandle(Node.class, \"right\", Node.class);\n+ *   Node getLeft() { return left; }\n+ *   boolean compareAndSetLeft(Node expect, Node update) {\n+ *     return LEFT.compareAndSet(this, expect, update);\n+ *   }\n+ *   \/\/ ... and so on\n+ * }}<\/pre>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"}]}