{"files":[{"patch":"@@ -43,1 +43,1 @@\n- * and return a task object that can be used to cancel or check\n+ * and return {@link ScheduledFuture} objects that can be used to cancel or check\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ScheduledExecutorService.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-     * await completion of in-progress offer.  Upon return, this\n+     * await completion of in-progress offers.  Upon return, this\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SubmissionPublisher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-     *               the owner of this object's monitor.\n+     *               the owner of the object's monitor.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/TimeUnit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+ * import java.lang.invoke.VarHandle;\n+ * import java.lang.invoke.MethodHandles;\n@@ -75,12 +77,14 @@\n- *   private volatile Node left, right;\n- *\n- *   private static final VarHandle LEFT = MethodHandles.lookup().\n- *      findVarHandle(Node.class, \"left\", Node.class);\n- *   private static final VarHandle RIGHT = MethodHandles.lookup().\n- *      findVarHandle(Node.class, \"right\", Node.class);\n- *   Node getLeft() { return left; }\n- *   boolean compareAndSetLeft(Node expect, Node update) {\n- *     return LEFT.compareAndSet(this, expect, update);\n- *   }\n- *   \/\/ ... and so on\n- * }}<\/pre>\n+ *  private volatile Node left, right;\n+ *  private static final VarHandle LEFT, RIGHT;\n+ *  Node getLeft() { return left; }\n+ *  boolean compareAndSetLeft(Node expect, Node update) {\n+ *    return LEFT.compareAndSet(this, expect, update);\n+ *  }\n+ *  \/\/ ... and so on\n+ *  static { try {\n+ *    MethodHandles.Lookup l = MethodHandles.lookup();\n+ *    LEFT  = l.findVarHandle(Node.class, \"left\", Node.class);\n+ *    RIGHT = l.findVarHandle(Node.class, \"right\", Node.class);\n+ *   } catch (ReflectiveOperationException e) {\n+ *     throw new ExceptionInInitializerError(e);\n+ * }}}<\/pre>\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -794,1 +794,1 @@\n-         * any thread at the time of invocation.\n+         * another thread at the time of invocation.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,1 +225,3 @@\n- * <\/ul>\n+ * <li> These properties extend to other iteration-based\n+ * operations. In particular, {@link Object#equals} is almost never\n+ * useful unless both collections are known to be quiescent.  <\/ul>\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}