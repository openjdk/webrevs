{"files":[{"patch":"@@ -53,0 +53,20 @@\n+ * <p>Cancellation of a Future need not abruptly terminate its\n+ * computation. Method {@code cancel} causes {@code isCancelled()} to\n+ * return {@code true} unless already {@code isDone()}; in either case\n+ * {@code isDone()} subsequently reports {@code true}. This suppresses\n+ * execution by an {@link ExecutorService} if not already started.\n+ * There are several options for suppressing unnecessary computation\n+ * or unblocking a running Future that will not generate a\n+ * result. When task bodies are simple and short, no special attention\n+ * is warranted.  Computational methods in Future-aware code bodies\n+ * (for example {@link ForkJoinTask}, {@link FutureTask}) may inspect\n+ * their own {@code isDone()} status before or while engaging in\n+ * expensive computations. In blocking I\/O or communication contexts,\n+ * the optional {@code mayInterruptIfRunning} argument of {@code\n+ * cancel} may be used to support conventions that tasks should\n+ * unblock and exit when {@link Thread#interrupted}, whether checked\n+ * inside a task body or as a response to an {@link\n+ * InterruptedException}.  It is still preferable to additionally\n+ * check {@code isDone()} status when possible to avoid unintended\n+ * effects of other uses of {@link Thread#interrupt}.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Future.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}