{"files":[{"patch":"@@ -375,0 +375,2 @@\n+  _ref_processor = nullptr;\n+\n@@ -618,0 +620,6 @@\n+void DefNewGeneration::ref_processor_init() {\n+  assert(_ref_processor == nullptr, \"a reference processor already exists\");\n+  assert(!_reserved.is_empty(), \"empty generation?\");\n+  _span_based_discoverer.set_span(_reserved);\n+  _ref_processor = new ReferenceProcessor(&_span_based_discoverer);    \/\/ a vanilla reference processor\n+}\n@@ -723,5 +731,0 @@\n-  _gc_timer->register_gc_start();\n-  _gc_tracer->report_gc_start(heap->gc_cause(), _gc_timer->gc_start());\n-\n-  _old_gen = heap->old_gen();\n-\n@@ -737,0 +740,5 @@\n+  _gc_timer->register_gc_start();\n+  _gc_tracer->report_gc_start(heap->gc_cause(), _gc_timer->gc_start());\n+  _ref_processor->start_discovery(clear_all_soft_refs);\n+\n+  _old_gen = heap->old_gen();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-protected:\n@@ -62,0 +61,4 @@\n+  \/\/ (\"Weak\") Reference processing support\n+  SpanSubjectToDiscoveryClosure _span_based_discoverer;\n+  ReferenceProcessor* _ref_processor;\n+\n@@ -165,0 +168,4 @@\n+  \/\/ allocate and initialize (\"weak\") refs processing support\n+  void ref_processor_init();\n+  ReferenceProcessor* const ref_processor() { return _ref_processor; }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-void GenMarkSweep::invoke_at_safepoint(ReferenceProcessor* rp, bool clear_all_softrefs) {\n+void GenMarkSweep::invoke_at_safepoint(bool clear_all_softrefs) {\n@@ -76,5 +76,0 @@\n-  \/\/ hook up weak ref data so it can be used during Mark-Sweep\n-  assert(ref_processor() == nullptr, \"no stomping\");\n-  assert(rp != nullptr, \"should be non-null\");\n-  set_ref_processor(rp);\n-\n@@ -136,3 +131,0 @@\n-  \/\/ refs processing: clean slate\n-  set_ref_processor(nullptr);\n-\n@@ -185,0 +177,2 @@\n+  ref_processor()->start_discovery(clear_all_softrefs);\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  static void invoke_at_safepoint(ReferenceProcessor* rp, bool clear_all_softrefs);\n+  static void invoke_at_safepoint(bool clear_all_softrefs);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,4 +36,0 @@\n-#include \"oops\/instanceClassLoaderKlass.inline.hpp\"\n-#include \"oops\/instanceKlass.inline.hpp\"\n-#include \"oops\/instanceMirrorKlass.inline.hpp\"\n-#include \"oops\/instanceRefKlass.inline.hpp\"\n@@ -44,1 +40,0 @@\n-#include \"utilities\/macros.hpp\"\n@@ -56,1 +51,0 @@\n-ReferenceProcessor*     MarkSweep::_ref_processor   = nullptr;\n@@ -60,0 +54,3 @@\n+AlwaysTrueClosure   MarkSweep::_always_true_closure;\n+ReferenceProcessor* MarkSweep::_ref_processor;\n+\n@@ -171,5 +168,0 @@\n-void MarkSweep::set_ref_processor(ReferenceProcessor* rp) {\n-  _ref_processor = rp;\n-  mark_and_push_closure.set_ref_discoverer(_ref_processor);\n-}\n-\n@@ -255,0 +247,5 @@\n+\n+  \/\/ The Full GC operates on the entire heap so all objects should be subject\n+  \/\/ to discovery, hence the _always_true_closure.\n+  MarkSweep::_ref_processor = new ReferenceProcessor(&_always_true_closure);\n+  mark_and_push_closure.set_ref_discoverer(_ref_processor);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/referenceProcessor.hpp\"\n@@ -38,1 +39,0 @@\n-class ReferenceProcessor;\n@@ -107,1 +107,1 @@\n-  \/\/ Reference processing (used in ...follow_contents)\n+  static AlwaysTrueClosure               _always_true_closure;\n@@ -135,1 +135,0 @@\n-  static void set_ref_processor(ReferenceProcessor* rp);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -440,5 +440,0 @@\n-  \/\/ Temporarily expand the span of our ref processor, so\n-  \/\/ refs discovery is over the entire heap, not just this generation\n-  ReferenceProcessorSpanMutator\n-    x(ref_processor(), gch->reserved_region());\n-\n@@ -453,1 +448,1 @@\n-  GenMarkSweep::invoke_at_safepoint(ref_processor(), clear_all_soft_refs);\n+  GenMarkSweep::invoke_at_safepoint(clear_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -192,1 +192,0 @@\n-  ref_processing_init();\n@@ -196,0 +195,2 @@\n+  def_new_gen->ref_processor_init();\n+\n@@ -205,5 +206,0 @@\n-void GenCollectedHeap::ref_processing_init() {\n-  _young_gen->ref_processor_init();\n-  _old_gen->ref_processor_init();\n-}\n-\n@@ -458,10 +454,0 @@\n-    \/\/ Note on ref discovery: For what appear to be historical reasons,\n-    \/\/ GCH enables and disabled (by enqueuing) refs discovery.\n-    \/\/ In the future this should be moved into the generation's\n-    \/\/ collect method so that ref discovery and enqueueing concerns\n-    \/\/ are local to a generation. The collect method could return\n-    \/\/ an appropriate indication in the case that notification on\n-    \/\/ the ref lock was needed. This will make the treatment of\n-    \/\/ weak refs more uniform (and indeed remove such concerns\n-    \/\/ from GCH). XXX\n-\n@@ -469,7 +455,0 @@\n-    \/\/ We want to discover references, but not process them yet.\n-    \/\/ This mode is disabled in process_discovered_references if the\n-    \/\/ generation does some collection work, or in\n-    \/\/ enqueue_discovered_references if the generation returns\n-    \/\/ without doing any work.\n-    ReferenceProcessor* rp = gen->ref_processor();\n-    rp->start_discovery(clear_soft_refs);\n@@ -478,3 +457,0 @@\n-\n-    rp->disable_discovery();\n-    rp->verify_no_references_recorded();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":2,"deletions":26,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -97,3 +97,0 @@\n-  \/\/ Initialize (\"weak\") refs processing support\n-  void ref_processing_init();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,2 +45,1 @@\n-  _gc_manager(nullptr),\n-  _ref_processor(nullptr) {\n+  _gc_manager(nullptr) {\n@@ -73,9 +72,0 @@\n-\/\/ By default we get a single threaded default reference processor;\n-\/\/ generations needing multi-threaded refs processing or discovery override this method.\n-void Generation::ref_processor_init() {\n-  assert(_ref_processor == nullptr, \"a reference processor already exists\");\n-  assert(!_reserved.is_empty(), \"empty generation?\");\n-  _span_based_discoverer.set_span(_reserved);\n-  _ref_processor = new ReferenceProcessor(&_span_based_discoverer);    \/\/ a vanilla reference processor\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -89,4 +89,0 @@\n-  \/\/ (\"Weak\") Reference processing support\n-  SpanSubjectToDiscoveryClosure _span_based_discoverer;\n-  ReferenceProcessor* _ref_processor;\n-\n@@ -119,6 +115,0 @@\n-  \/\/ allocate and initialize (\"weak\") refs processing support\n-  void ref_processor_init();\n-  void set_ref_processor(ReferenceProcessor* rp) {\n-    assert(_ref_processor == nullptr, \"clobbering existing _ref_processor\");\n-    _ref_processor = rp;\n-  }\n@@ -365,3 +355,0 @@\n-  \/\/ Reference Processing accessor\n-  ReferenceProcessor* const ref_processor() { return _ref_processor; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-void ReferenceProcessor::enable_discovery(bool check_no_refs) {\n+void ReferenceProcessor::enable_discovery() {\n@@ -80,4 +80,2 @@\n-  if (check_no_refs) {\n-    \/\/ Verify that the discovered lists are empty\n-    verify_no_references_recorded();\n-  }\n+  \/\/ Verify that the discovered lists are empty\n+  verify_no_references_recorded();\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-  void enable_discovery(bool check_no_refs = true);\n+  void enable_discovery();\n@@ -448,3 +448,0 @@\n-  SpanSubjectToDiscoveryClosure(MemRegion span) : BoolObjectClosure(), _span(span) { }\n-\n-  MemRegion span() const { return _span; }\n@@ -479,22 +476,0 @@\n-\/\/ A utility class to temporarily mutate the span of the\n-\/\/ given ReferenceProcessor in the scope that contains it.\n-class ReferenceProcessorSpanMutator : StackObj {\n-  ReferenceProcessor* _rp;\n-  SpanSubjectToDiscoveryClosure _discoverer;\n-  BoolObjectClosure* _old_discoverer;\n-\n-public:\n-  ReferenceProcessorSpanMutator(ReferenceProcessor* rp,\n-                                MemRegion span):\n-    _rp(rp),\n-    _discoverer(span),\n-    _old_discoverer(rp->is_subject_to_discovery_closure()) {\n-\n-    rp->set_is_subject_to_discovery_closure(&_discoverer);\n-  }\n-\n-  ~ReferenceProcessorSpanMutator() {\n-    _rp->set_is_subject_to_discovery_closure(_old_discoverer);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"}]}