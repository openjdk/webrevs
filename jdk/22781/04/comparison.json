{"files":[{"patch":"@@ -85,1 +85,1 @@\n- *\n+ * <p>\n@@ -101,1 +101,1 @@\n- *\n+ * <p>\n@@ -108,2 +108,2 @@\n- * @author      Robi Khan\n- * @since       1.3\n+ * @author Robi Khan\n+ * @since 1.3\n@@ -117,0 +117,1 @@\n+    private static Rectangle[] allScreenBounds;\n@@ -123,4 +124,4 @@\n-     * @throws  AWTException if the platform configuration does not allow\n-     * low-level input control.  This exception is always thrown when\n-     * GraphicsEnvironment.isHeadless() returns true\n-     * @see     java.awt.GraphicsEnvironment#isHeadless\n+     * @throws AWTException if the platform configuration does not allow\n+     *                      low-level input control.  This exception is always thrown when\n+     *                      GraphicsEnvironment.isHeadless() returns true\n+     * @see java.awt.GraphicsEnvironment#isHeadless\n@@ -131,1 +132,1 @@\n-            .getDefaultScreenDevice());\n+                .getDefaultScreenDevice());\n@@ -148,9 +149,9 @@\n-     * @param screen    A screen GraphicsDevice indicating the coordinate\n-     *                  system the Robot will operate in.\n-     * @throws  AWTException if the platform configuration does not allow\n-     * low-level input control.  This exception is always thrown when\n-     * GraphicsEnvironment.isHeadless() returns true.\n-     * @throws  IllegalArgumentException if {@code screen} is not a screen\n-     *          GraphicsDevice.\n-     * @see     java.awt.GraphicsEnvironment#isHeadless\n-     * @see     GraphicsDevice\n+     * @param screen A screen GraphicsDevice indicating the coordinate\n+     *               system the Robot will operate in.\n+     * @throws AWTException             if the platform configuration does not allow\n+     *                                  low-level input control.  This exception is always thrown when\n+     *                                  GraphicsEnvironment.isHeadless() returns true.\n+     * @throws IllegalArgumentException if {@code screen} is not a screen\n+     *                                  GraphicsDevice.\n+     * @see java.awt.GraphicsEnvironment#isHeadless\n+     * @see GraphicsDevice\n@@ -167,1 +168,1 @@\n-            peer = ((ComponentFactory)toolkit).createRobot(screen);\n+            peer = ((ComponentFactory) toolkit).createRobot(screen);\n@@ -170,0 +171,5 @@\n+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        GraphicsDevice[] gs = ge.getScreenDevices();\n+        for (int i = 0; i < gs.length; i++) {\n+            allScreenBounds[i] = gs[i].getDefaultConfiguration().getBounds();\n+        }\n@@ -177,1 +183,1 @@\n-        if (Toolkit.getDefaultToolkit().areExtraMouseButtonsEnabled()){\n+        if (Toolkit.getDefaultToolkit().areExtraMouseButtonsEnabled()) {\n@@ -179,3 +185,3 @@\n-                final int buttonsNumber = ((SunToolkit)(Toolkit.getDefaultToolkit())).getNumberOfButtons();\n-                for (int i = 0; i < buttonsNumber; i++){\n-                    tmpMask |= InputEvent.getMaskForButton(i+1);\n+                final int buttonsNumber = ((SunToolkit) (Toolkit.getDefaultToolkit())).getNumberOfButtons();\n+                for (int i = 0; i < buttonsNumber; i++) {\n+                    tmpMask |= InputEvent.getMaskForButton(i + 1);\n@@ -185,6 +191,6 @@\n-        tmpMask |= InputEvent.BUTTON1_MASK|\n-            InputEvent.BUTTON2_MASK|\n-            InputEvent.BUTTON3_MASK|\n-            InputEvent.BUTTON1_DOWN_MASK|\n-            InputEvent.BUTTON2_DOWN_MASK|\n-            InputEvent.BUTTON3_DOWN_MASK;\n+        tmpMask |= InputEvent.BUTTON1_MASK |\n+                InputEvent.BUTTON2_MASK |\n+                InputEvent.BUTTON3_MASK |\n+                InputEvent.BUTTON1_DOWN_MASK |\n+                InputEvent.BUTTON2_DOWN_MASK |\n+                InputEvent.BUTTON3_DOWN_MASK;\n@@ -217,2 +223,2 @@\n-     * @param x         X position\n-     * @param y         Y position\n+     * @param x X position\n+     * @param y Y position\n@@ -221,1 +227,31 @@\n-        peer.mouseMove(x, y);\n+        int leastXDiff = Integer.MAX_VALUE;\n+        int leastYDiff = Integer.MAX_VALUE;\n+        int finX, finY;\n+\n+        for (Rectangle screenBounds : allScreenBounds) {\n+            int closestX = Math.min(Math.max(x, screenBounds.x), screenBounds.x + screenBounds.width);\n+            int closestY = Math.min(Math.max(y, screenBounds.y), screenBounds.y + screenBounds.height);\n+\n+            int currXDiff = Math.abs(x - closestX);\n+            int currYDiff = Math.abs(y - closestY);\n+\n+            if ((currXDiff == 0) && (currYDiff == 0)) {\n+                finX = x;\n+                finY = y;\n+                break;\n+            } else if (currXDiff < leastXDiff) {\n+                finX = closestX;\n+                finY = closestY;\n+                leastXDiff = currXDiff;\n+                leastYDiff = currYDiff;\n+            } else if (currYDiff < leastYDiff) {\n+                finX = closestX;\n+                finY = closestY;\n+                leastXDiff = currXDiff;\n+                leastYDiff = currYDiff;\n+            }\n+        }\n+\n+        peer.mouseMove(finX, finY);\n+\/\/        peer.mouseMove(Math.min(Math.max(x, screenBounds.x), screenBounds.x + screenBounds.width),\n+\/\/                Math.min(Math.max(y, screenBounds.y), screenBounds.y + screenBounds.height));\n@@ -230,37 +266,37 @@\n-     * mouse button masks.\n-     * <p>\n-     * It is allowed to use only a combination of valid values as a {@code buttons} parameter.\n-     * A valid combination consists of {@code InputEvent.BUTTON1_DOWN_MASK},\n-     * {@code InputEvent.BUTTON2_DOWN_MASK}, {@code InputEvent.BUTTON3_DOWN_MASK}\n-     * and values returned by the\n-     * {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)} method.\n-     *\n-     * The valid combination also depends on a\n-     * {@link Toolkit#areExtraMouseButtonsEnabled() Toolkit.areExtraMouseButtonsEnabled()} value as follows:\n-     * <ul>\n-     * <li> If support for extended mouse buttons is\n-     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n-     * then it is allowed to use only the following standard button masks:\n-     * {@code InputEvent.BUTTON1_DOWN_MASK}, {@code InputEvent.BUTTON2_DOWN_MASK},\n-     * {@code InputEvent.BUTTON3_DOWN_MASK}.\n-     * <li> If support for extended mouse buttons is\n-     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n-     * then it is allowed to use the standard button masks\n-     * and masks for existing extended mouse buttons, if the mouse has more then three buttons.\n-     * In that way, it is allowed to use the button masks corresponding to the buttons\n-     * in the range from 1 to {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}.\n-     * <br>\n-     * It is recommended to use the {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)}\n-     * method to obtain the mask for any mouse button by its number.\n-     * <\/ul>\n-     * <p>\n-     * The following standard button masks are also accepted:\n-     * <ul>\n-     * <li>{@code InputEvent.BUTTON1_MASK}\n-     * <li>{@code InputEvent.BUTTON2_MASK}\n-     * <li>{@code InputEvent.BUTTON3_MASK}\n-     * <\/ul>\n-     * However, it is recommended to use {@code InputEvent.BUTTON1_DOWN_MASK},\n-     * {@code InputEvent.BUTTON2_DOWN_MASK},  {@code InputEvent.BUTTON3_DOWN_MASK} instead.\n-     * Either extended {@code _DOWN_MASK} or old {@code _MASK} values\n-     * should be used, but both those models should not be mixed.\n+     *                mouse button masks.\n+     *                <p>\n+     *                It is allowed to use only a combination of valid values as a {@code buttons} parameter.\n+     *                A valid combination consists of {@code InputEvent.BUTTON1_DOWN_MASK},\n+     *                {@code InputEvent.BUTTON2_DOWN_MASK}, {@code InputEvent.BUTTON3_DOWN_MASK}\n+     *                and values returned by the\n+     *                {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)} method.\n+     *                <p>\n+     *                The valid combination also depends on a\n+     *                {@link Toolkit#areExtraMouseButtonsEnabled() Toolkit.areExtraMouseButtonsEnabled()} value as follows:\n+     *                <ul>\n+     *                <li> If support for extended mouse buttons is\n+     *                {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n+     *                then it is allowed to use only the following standard button masks:\n+     *                {@code InputEvent.BUTTON1_DOWN_MASK}, {@code InputEvent.BUTTON2_DOWN_MASK},\n+     *                {@code InputEvent.BUTTON3_DOWN_MASK}.\n+     *                <li> If support for extended mouse buttons is\n+     *                {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n+     *                then it is allowed to use the standard button masks\n+     *                and masks for existing extended mouse buttons, if the mouse has more then three buttons.\n+     *                In that way, it is allowed to use the button masks corresponding to the buttons\n+     *                in the range from 1 to {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}.\n+     *                <br>\n+     *                It is recommended to use the {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)}\n+     *                method to obtain the mask for any mouse button by its number.\n+     *                <\/ul>\n+     *                <p>\n+     *                The following standard button masks are also accepted:\n+     *                <ul>\n+     *                <li>{@code InputEvent.BUTTON1_MASK}\n+     *                <li>{@code InputEvent.BUTTON2_MASK}\n+     *                <li>{@code InputEvent.BUTTON3_MASK}\n+     *                <\/ul>\n+     *                However, it is recommended to use {@code InputEvent.BUTTON1_DOWN_MASK},\n+     *                {@code InputEvent.BUTTON2_DOWN_MASK},  {@code InputEvent.BUTTON3_DOWN_MASK} instead.\n+     *                Either extended {@code _DOWN_MASK} or old {@code _MASK} values\n+     *                should be used, but both those models should not be mixed.\n@@ -268,1 +304,1 @@\n-     *         and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n+     *                                  and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n@@ -270,1 +306,1 @@\n-     *         that does not exist on the mouse and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n+     *                                  that does not exist on the mouse and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n@@ -287,37 +323,37 @@\n-     * mouse button masks.\n-     * <p>\n-     * It is allowed to use only a combination of valid values as a {@code buttons} parameter.\n-     * A valid combination consists of {@code InputEvent.BUTTON1_DOWN_MASK},\n-     * {@code InputEvent.BUTTON2_DOWN_MASK}, {@code InputEvent.BUTTON3_DOWN_MASK}\n-     * and values returned by the\n-     * {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)} method.\n-     *\n-     * The valid combination also depends on a\n-     * {@link Toolkit#areExtraMouseButtonsEnabled() Toolkit.areExtraMouseButtonsEnabled()} value as follows:\n-     * <ul>\n-     * <li> If the support for extended mouse buttons is\n-     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n-     * then it is allowed to use only the following standard button masks:\n-     * {@code InputEvent.BUTTON1_DOWN_MASK}, {@code InputEvent.BUTTON2_DOWN_MASK},\n-     * {@code InputEvent.BUTTON3_DOWN_MASK}.\n-     * <li> If the support for extended mouse buttons is\n-     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n-     * then it is allowed to use the standard button masks\n-     * and masks for existing extended mouse buttons, if the mouse has more then three buttons.\n-     * In that way, it is allowed to use the button masks corresponding to the buttons\n-     * in the range from 1 to {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}.\n-     * <br>\n-     * It is recommended to use the {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)}\n-     * method to obtain the mask for any mouse button by its number.\n-     * <\/ul>\n-     * <p>\n-     * The following standard button masks are also accepted:\n-     * <ul>\n-     * <li>{@code InputEvent.BUTTON1_MASK}\n-     * <li>{@code InputEvent.BUTTON2_MASK}\n-     * <li>{@code InputEvent.BUTTON3_MASK}\n-     * <\/ul>\n-     * However, it is recommended to use {@code InputEvent.BUTTON1_DOWN_MASK},\n-     * {@code InputEvent.BUTTON2_DOWN_MASK},  {@code InputEvent.BUTTON3_DOWN_MASK} instead.\n-     * Either extended {@code _DOWN_MASK} or old {@code _MASK} values\n-     * should be used, but both those models should not be mixed.\n+     *                mouse button masks.\n+     *                <p>\n+     *                It is allowed to use only a combination of valid values as a {@code buttons} parameter.\n+     *                A valid combination consists of {@code InputEvent.BUTTON1_DOWN_MASK},\n+     *                {@code InputEvent.BUTTON2_DOWN_MASK}, {@code InputEvent.BUTTON3_DOWN_MASK}\n+     *                and values returned by the\n+     *                {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)} method.\n+     *                <p>\n+     *                The valid combination also depends on a\n+     *                {@link Toolkit#areExtraMouseButtonsEnabled() Toolkit.areExtraMouseButtonsEnabled()} value as follows:\n+     *                <ul>\n+     *                <li> If the support for extended mouse buttons is\n+     *                {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n+     *                then it is allowed to use only the following standard button masks:\n+     *                {@code InputEvent.BUTTON1_DOWN_MASK}, {@code InputEvent.BUTTON2_DOWN_MASK},\n+     *                {@code InputEvent.BUTTON3_DOWN_MASK}.\n+     *                <li> If the support for extended mouse buttons is\n+     *                {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n+     *                then it is allowed to use the standard button masks\n+     *                and masks for existing extended mouse buttons, if the mouse has more then three buttons.\n+     *                In that way, it is allowed to use the button masks corresponding to the buttons\n+     *                in the range from 1 to {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}.\n+     *                <br>\n+     *                It is recommended to use the {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)}\n+     *                method to obtain the mask for any mouse button by its number.\n+     *                <\/ul>\n+     *                <p>\n+     *                The following standard button masks are also accepted:\n+     *                <ul>\n+     *                <li>{@code InputEvent.BUTTON1_MASK}\n+     *                <li>{@code InputEvent.BUTTON2_MASK}\n+     *                <li>{@code InputEvent.BUTTON3_MASK}\n+     *                <\/ul>\n+     *                However, it is recommended to use {@code InputEvent.BUTTON1_DOWN_MASK},\n+     *                {@code InputEvent.BUTTON2_DOWN_MASK},  {@code InputEvent.BUTTON3_DOWN_MASK} instead.\n+     *                Either extended {@code _DOWN_MASK} or old {@code _MASK} values\n+     *                should be used, but both those models should not be mixed.\n@@ -325,1 +361,1 @@\n-     *         and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n+     *                                  and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n@@ -327,1 +363,1 @@\n-     *         that does not exist on the mouse and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n+     *                                  that does not exist on the mouse and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n@@ -341,1 +377,1 @@\n-        if ( (buttons|LEGAL_BUTTON_MASK) != LEGAL_BUTTON_MASK ) {\n+        if ((buttons | LEGAL_BUTTON_MASK) != LEGAL_BUTTON_MASK) {\n@@ -349,4 +385,3 @@\n-     * @param wheelAmt  number of \"notches\" to move the mouse wheel\n-     *                  Negative values indicate movement up\/away from the user,\n-     *                  positive values indicate movement down\/towards the user.\n-     *\n+     * @param wheelAmt number of \"notches\" to move the mouse wheel\n+     *                 Negative values indicate movement up\/away from the user,\n+     *                 positive values indicate movement down\/towards the user.\n@@ -368,5 +403,5 @@\n-     * @param   keycode Key to press (e.g. {@code KeyEvent.VK_A})\n-     * @throws  IllegalArgumentException if {@code keycode} is not\n-     *          a valid key\n-     * @see     #keyRelease(int)\n-     * @see     java.awt.event.KeyEvent\n+     * @param keycode Key to press (e.g. {@code KeyEvent.VK_A})\n+     * @throws IllegalArgumentException if {@code keycode} is not\n+     *                                  a valid key\n+     * @see #keyRelease(int)\n+     * @see java.awt.event.KeyEvent\n@@ -387,5 +422,5 @@\n-     * @param   keycode Key to release (e.g. {@code KeyEvent.VK_A})\n-     * @throws  IllegalArgumentException if {@code keycode} is not a\n-     *          valid key\n-     * @see  #keyPress(int)\n-     * @see     java.awt.event.KeyEvent\n+     * @param keycode Key to release (e.g. {@code KeyEvent.VK_A})\n+     * @throws IllegalArgumentException if {@code keycode} is not a\n+     *                                  valid key\n+     * @see #keyPress(int)\n+     * @see java.awt.event.KeyEvent\n@@ -417,0 +452,6 @@\n+     *\n+     * @param x X position of pixel\n+     * @param y Y position of pixel\n+     * @return Color of the pixel\n+     * @throws SecurityException if access to the screen is denied\n+     *                           by the desktop environment\n@@ -421,6 +462,0 @@\n-     *\n-     * @param   x       X position of pixel\n-     * @param   y       Y position of pixel\n-     * @throws  SecurityException if access to the screen is denied\n-     *          by the desktop environment\n-     * @return  Color of the pixel\n@@ -430,1 +465,1 @@\n-                                                    : toDeviceSpace(x, y);\n+                : toDeviceSpace(x, y);\n@@ -442,0 +477,7 @@\n+     *\n+     * @param screenRect Rect to capture in screen coordinates\n+     * @return The captured image\n+     * @throws IllegalArgumentException if {@code screenRect} width and height\n+     *                                  are not greater than zero\n+     * @throws SecurityException        if access to the screen is denied\n+     *                                  by the desktop environment\n@@ -446,7 +488,0 @@\n-     *\n-     * @param   screenRect      Rect to capture in screen coordinates\n-     * @return  The captured image\n-     * @throws  IllegalArgumentException if {@code screenRect} width and height\n-     *          are not greater than zero\n-     * @throws  SecurityException if access to the screen is denied\n-     *          by the desktop environment\n@@ -490,6 +525,0 @@\n-     * @param   screenRect     Rect to capture in screen coordinates\n-     * @return  The captured image\n-     * @throws  IllegalArgumentException if {@code screenRect} width and height\n-     *          are not greater than zero\n-     * @throws  SecurityException if access to the screen is denied\n-     *          by the desktop environment\n@@ -497,0 +526,6 @@\n+     * @param screenRect Rect to capture in screen coordinates\n+     * @return The captured image\n+     * @throws IllegalArgumentException if {@code screenRect} width and height\n+     *                                  are not greater than zero\n+     * @throws SecurityException        if access to the screen is denied\n+     *                                  by the desktop environment\n@@ -500,1 +535,1 @@\n-            createMultiResolutionScreenCapture(Rectangle screenRect) {\n+    createMultiResolutionScreenCapture(Rectangle screenRect) {\n@@ -507,1 +542,1 @@\n-            createCompatibleImage(Rectangle screenRect, boolean isHiDPI) {\n+    createCompatibleImage(Rectangle screenRect, boolean isHiDPI) {\n@@ -604,1 +639,1 @@\n-            if(!isHiDPI) {\n+            if (!isHiDPI) {\n@@ -635,0 +670,1 @@\n+     *\n@@ -644,1 +680,2 @@\n-     * @param   isOn    Whether {@code waitForIdle} is automatically invoked\n+     *\n+     * @param isOn Whether {@code waitForIdle} is automatically invoked\n@@ -671,1 +708,1 @@\n-     * @param  ms the delay duration in milliseconds\n+     * @param ms the delay duration in milliseconds\n@@ -673,1 +710,1 @@\n-     *         is not between 0 and 60,000 milliseconds inclusive\n+     *                                  is not between 0 and 60,000 milliseconds inclusive\n@@ -695,1 +732,1 @@\n-     * @param  ms time to sleep in milliseconds\n+     * @param ms time to sleep in milliseconds\n@@ -697,1 +734,1 @@\n-     *         and {@code 60,000} milliseconds inclusive\n+     *                                  and {@code 60,000} milliseconds inclusive\n@@ -719,1 +756,2 @@\n-     * @throws  IllegalThreadStateException if called on the AWT event dispatching thread\n+     *\n+     * @throws IllegalThreadStateException if called on the AWT event dispatching thread\n@@ -736,1 +774,1 @@\n-     * @return  the string representation.\n+     * @return the string representation.\n@@ -740,1 +778,1 @@\n-        String params = \"autoDelay = \"+getAutoDelay()+\", \"+\"autoWaitForIdle = \"+isAutoWaitForIdle();\n+        String params = \"autoDelay = \" + getAutoDelay() + \", \" + \"autoWaitForIdle = \" + isAutoWaitForIdle();\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Robot.java","additions":194,"deletions":156,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Robot;\n+\n+\/*\n+ * @test\n+ * @bug 8345538\n+ * @summary Tests mouseMove clamping to screen bounds when set to move offscreen\n+ * @key headful\n+ * @run main MouseMoveOffScreen\n+ *\/\n+\n+public class MouseMoveOffScreen {\n+    private static final Point STARTING_LOC = new Point(200, 200);\n+    private static final Point OFF_SCREEN_LOC = new Point(20000, 200);\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        robot.mouseMove(STARTING_LOC.x, STARTING_LOC.y);\n+        robot.delay(500);\n+        robot.mouseMove(OFF_SCREEN_LOC.x, OFF_SCREEN_LOC.y);\n+        robot.delay(500);\n+\n+        if (MouseInfo.getPointerInfo().getLocation() == null) {\n+            throw new RuntimeException(\"Test Failed, getLocation returned null.\");\n+        }\n+        Point currLoc = MouseInfo.getPointerInfo().getLocation();\n+        System.out.println(\"Current mouse location: \" + currLoc);\n+        if (currLoc.equals(OFF_SCREEN_LOC)) {\n+            throw new RuntimeException(\"Test Failed, robot moved mouse off screen.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Robot\/MouseMoveOffScreen.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"}]}