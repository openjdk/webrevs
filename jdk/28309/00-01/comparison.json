{"files":[{"patch":"@@ -10603,1 +10603,1 @@\n-instruct cmovF_cmpP(fRegF dst, fRegF src, iRegN op1, iRegN op2, cmpOp cop) %{\n+instruct cmovF_cmpP(fRegF dst, fRegF src, iRegP op1, iRegP op2, cmpOp cop) %{\n@@ -10743,1 +10743,1 @@\n-instruct cmovD_cmpP(fRegD dst, fRegD src, iRegN op1, iRegN op2, cmpOp cop) %{\n+instruct cmovD_cmpP(fRegD dst, fRegD src, iRegP op1, iRegP op2, cmpOp cop) %{\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @summary Test conditional move + compare object.\n+ * @requires vm.simpleArch == \"riscv64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestScalarConditionalMoveCmpObj\n+ *\/\n+\n+public class TestScalarConditionalMoveCmpObj {\n+    final private static int SIZE = 1024;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+UseCompressedOops\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-UseCompressedOops\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+UseCompressedOops\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-UseCompressedOops\");\n+    }\n+\n+    \/\/ Object comparison\n+    \/\/    O for I\n+    private int cmoveOEQforI(Object a, Object b, int c, int d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private int cmoveONEforI(Object a, Object b, int c, int d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    \/\/    O for L\n+    private long cmoveOEQforL(Object a, Object b, long c, long d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private long cmoveONEforL(Object a, Object b, long c, long d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    \/\/    O for F\n+    private float cmoveOEQforF(Object a, Object b, float c, float d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private float cmoveONEforF(Object a, Object b, float c, float d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    \/\/    O for D\n+    private double cmoveOEQforD(Object a, Object b, double c, double d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private double cmoveONEforD(Object a, Object b, double c, double d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    \/\/ Tests shows CMoveI is generated, so let @IR verify CMOVE_I.\n+    \/\/\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveOEQforI(Object[] a, Object[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveONEforI(Object[] a, Object[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ So far, CMoveL is not guaranteed to be generated, so @IR not verify CMOVE_L.\n+    \/\/ TODO: enable CMOVE_L verification when it's guaranteed to generate CMOVE_L.\n+    \/\/\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_P, \">0\"},\n+    \/\/     applyIf = {\"UseCompressedOops\", \"false\"})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_N, \">0\"},\n+    \/\/     applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveOEQforL(Object[] a, Object[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_P, \">0\"},\n+    \/\/     applyIf = {\"UseCompressedOops\", \"false\"})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_N, \">0\"},\n+    \/\/     applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveONEforL(Object[] a, Object[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveOEQforF(Object[] a, Object[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveONEforF(Object[] a, Object[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveOEQforD(Object[] a, Object[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveONEforD(Object[] a, Object[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Warmup(0)\n+    @Run(test = {\/\/ Object\n+                 \"testCMoveOEQforI\",\n+                 \"testCMoveONEforI\",\n+                 \"testCMoveOEQforL\",\n+                 \"testCMoveONEforL\",\n+                 \"testCMoveOEQforF\",\n+                 \"testCMoveONEforF\",\n+                 \"testCMoveOEQforD\",\n+                 \"testCMoveONEforD\",\n+                })\n+    private void testCMove_runner_two() {\n+        Object[] aO = new Object[SIZE];\n+        Object[] bO = new Object[SIZE];\n+        int[] cI = new int[SIZE];\n+        int[] dI = new int[SIZE];\n+        int[] rI = new int[SIZE];\n+        long[] cL = new long[SIZE];\n+        long[] dL = new long[SIZE];\n+        long[] rL = new long[SIZE];\n+        float[] cF = new float[SIZE];\n+        float[] dF = new float[SIZE];\n+        float[] rF = new float[SIZE];\n+        double[] cD = new double[SIZE];\n+        double[] dD = new double[SIZE];\n+        double[] rD = new double[SIZE];\n+\n+        init(aO);\n+        shuffle(aO, bO);\n+        init(cL);\n+        init(dL);\n+        init(cF);\n+        init(dF);\n+        init(cD);\n+        init(dD);\n+\n+        testCMoveOEQforI(aO, bO, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveOEQforI(aO[i], bO[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveONEforI(aO, bO, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveONEforI(aO[i], bO[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveOEQforL(aO, bO, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveOEQforL(aO[i], bO[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveONEforL(aO, bO, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveONEforL(aO[i], bO[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveOEQforF(aO, bO, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveOEQforF(aO[i], bO[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveONEforF(aO, bO, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveONEforF(aO[i], bO[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveOEQforD(aO, bO, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveOEQforD(aO[i], bO[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveONEforD(aO, bO, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveONEforD(aO[i], bO[i], cD[i], dD[i]));\n+        }\n+\n+    }\n+\n+    private static void init(Object[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = new Object();\n+        }\n+    }\n+\n+    private static void shuffle(Object[] a, Object[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+        Random rand = new Random();\n+        for (int i = 0; i < SIZE; i++) {\n+            if (rand.nextInt(5) == 0) {\n+                Object t = b[i];\n+                b[i] = b[SIZE-1-i];\n+                b[SIZE-1-i] = t;\n+            }\n+        }\n+    }\n+\n+    private static void init(int[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n+    private static void init(long[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+    }\n+\n+    private static void init(float[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = switch(RANDOM.nextInt() % 20) {\n+                case 0  -> Float.NaN;\n+                case 1  -> 0;\n+                case 2  -> 1;\n+                case 3  -> Float.POSITIVE_INFINITY;\n+                case 4  -> Float.NEGATIVE_INFINITY;\n+                case 5  -> Float.MAX_VALUE;\n+                case 6  -> Float.MIN_VALUE;\n+                case 7, 8, 9 -> RANDOM.nextFloat();\n+                default -> Float.intBitsToFloat(RANDOM.nextInt());\n+            };\n+        }\n+    }\n+\n+    private static void init(double[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = switch(RANDOM.nextInt() % 20) {\n+                case 0  -> Double.NaN;\n+                case 1  -> 0;\n+                case 2  -> 1;\n+                case 3  -> Double.POSITIVE_INFINITY;\n+                case 4  -> Double.NEGATIVE_INFINITY;\n+                case 5  -> Double.MAX_VALUE;\n+                case 6  -> Double.MIN_VALUE;\n+                case 7, 8, 9 -> RANDOM.nextDouble();\n+                default -> Double.longBitsToDouble(RANDOM.nextLong());\n+            };\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestScalarConditionalMoveCmpObj.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"}]}