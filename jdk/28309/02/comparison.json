{"files":[{"patch":"@@ -2070,0 +2070,79 @@\n+void C2_MacroAssembler::enc_cmove_fp_cmp(int cmpFlag, Register op1, Register op2,\n+                        FloatRegister dst, FloatRegister src, bool is_single) {\n+  bool is_unsigned = (cmpFlag & unsigned_branch_mask) == unsigned_branch_mask;\n+  int op_select = cmpFlag & (~unsigned_branch_mask);\n+\n+  switch (op_select) {\n+    case BoolTest::eq:\n+      cmov_fp_eq(op1, op2, dst, src, is_single);\n+      break;\n+    case BoolTest::ne:\n+      cmov_fp_ne(op1, op2, dst, src, is_single);\n+      break;\n+    case BoolTest::le:\n+      if (is_unsigned) {\n+        cmov_fp_leu(op1, op2, dst, src, is_single);\n+      } else {\n+        cmov_fp_le(op1, op2, dst, src, is_single);\n+      }\n+      break;\n+    case BoolTest::ge:\n+      if (is_unsigned) {\n+        cmov_fp_geu(op1, op2, dst, src, is_single);\n+      } else {\n+        cmov_fp_ge(op1, op2, dst, src, is_single);\n+      }\n+      break;\n+    case BoolTest::lt:\n+      if (is_unsigned) {\n+        cmov_fp_ltu(op1, op2, dst, src, is_single);\n+      } else {\n+        cmov_fp_lt(op1, op2, dst, src, is_single);\n+      }\n+      break;\n+    case BoolTest::gt:\n+      if (is_unsigned) {\n+        cmov_fp_gtu(op1, op2, dst, src, is_single);\n+      } else {\n+        cmov_fp_gt(op1, op2, dst, src, is_single);\n+      }\n+      break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::enc_cmove_fp_cmp_fp(int cmpFlag,\n+                           FloatRegister op1, FloatRegister op2,\n+                           FloatRegister dst, FloatRegister src,\n+                           bool cmp_single, bool cmov_single) {\n+  int op_select = cmpFlag & (~unsigned_branch_mask);\n+\n+  switch (op_select) {\n+    case BoolTest::eq:\n+      cmov_fp_cmp_fp_eq(op1, op2, dst, src, cmp_single, cmov_single);\n+      break;\n+    case BoolTest::ne:\n+      cmov_fp_cmp_fp_ne(op1, op2, dst, src, cmp_single, cmov_single);\n+      break;\n+    case BoolTest::le:\n+      cmov_fp_cmp_fp_le(op1, op2, dst, src, cmp_single, cmov_single);\n+      break;\n+    case BoolTest::ge:\n+      assert(false, \"Should go to BoolTest::le case\");\n+      ShouldNotReachHere();\n+      break;\n+    case BoolTest::lt:\n+      cmov_fp_cmp_fp_lt(op1, op2, dst, src, cmp_single, cmov_single);\n+      break;\n+    case BoolTest::gt:\n+      assert(false, \"Should go to BoolTest::lt case\");\n+      ShouldNotReachHere();\n+      break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -135,0 +135,7 @@\n+  void enc_cmove_fp_cmp(int cmpFlag, Register op1, Register op2,\n+                        FloatRegister dst, FloatRegister src, bool is_single);\n+\n+  void enc_cmove_fp_cmp_fp(int cmpFlag, FloatRegister op1, FloatRegister op2,\n+                           FloatRegister dst, FloatRegister src,\n+                           bool cmp_single, bool cmov_single);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1236,1 +1236,113 @@\n-\/\/ ----------- cmove, compare float -----------\n+\/\/ ----------- cmove float\/double -----------\n+\n+void MacroAssembler::cmov_fp_eq(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single) {\n+  Label no_set;\n+  bne(cmp1, cmp2, no_set);\n+  if (is_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_fp_ne(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single) {\n+  Label no_set;\n+  beq(cmp1, cmp2, no_set);\n+  if (is_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_fp_le(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single) {\n+  Label no_set;\n+  bgt(cmp1, cmp2, no_set);\n+  if (is_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_fp_leu(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single) {\n+  Label no_set;\n+  bgtu(cmp1, cmp2, no_set);\n+  if (is_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_fp_ge(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single) {\n+  Label no_set;\n+  blt(cmp1, cmp2, no_set);\n+  if (is_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_fp_geu(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single) {\n+  Label no_set;\n+  bltu(cmp1, cmp2, no_set);\n+  if (is_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_fp_lt(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single) {\n+  Label no_set;\n+  bge(cmp1, cmp2, no_set);\n+  if (is_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_fp_ltu(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single) {\n+  Label no_set;\n+  bgeu(cmp1, cmp2, no_set);\n+  if (is_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_fp_gt(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single) {\n+  Label no_set;\n+  ble(cmp1, cmp2, no_set);\n+  if (is_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_fp_gtu(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single) {\n+  Label no_set;\n+  bleu(cmp1, cmp2, no_set);\n+  if (is_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+\/\/ ----------- cmove, compare float\/double -----------\n@@ -1394,0 +1506,104 @@\n+\/\/ ----------- cmove float\/double, compare float\/double -----------\n+\n+\/\/ Move src to dst only if cmp1 == cmp2,\n+\/\/ otherwise leave dst unchanged, including the case where one of them is NaN.\n+\/\/ Clarification:\n+\/\/   java code      :  cmp1 != cmp2 ? dst : src\n+\/\/   transformed to :  CMove dst, (cmp1 eq cmp2), dst, src\n+void MacroAssembler::cmov_fp_cmp_fp_eq(FloatRegister cmp1, FloatRegister cmp2,\n+                                       FloatRegister dst, FloatRegister src,\n+                                       bool cmp_single, bool cmov_single) {\n+  Label no_set;\n+  if (cmp_single) {\n+    \/\/ jump if cmp1 != cmp2, including the case of NaN\n+    \/\/ not jump (i.e. move src to dst) if cmp1 == cmp2\n+    float_bne(cmp1, cmp2, no_set);\n+  } else {\n+    double_bne(cmp1, cmp2, no_set);\n+  }\n+  if (cmov_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+\/\/ Keep dst unchanged only if cmp1 == cmp2,\n+\/\/ otherwise move src to dst, including the case where one of them is NaN.\n+\/\/ Clarification:\n+\/\/   java code      :  cmp1 == cmp2 ? dst : src\n+\/\/   transformed to :  CMove dst, (cmp1 ne cmp2), dst, src\n+void MacroAssembler::cmov_fp_cmp_fp_ne(FloatRegister cmp1, FloatRegister cmp2,\n+                                       FloatRegister dst, FloatRegister src,\n+                                       bool cmp_single, bool cmov_single) {\n+  Label no_set;\n+  if (cmp_single) {\n+    \/\/ jump if cmp1 == cmp2\n+    \/\/ not jump (i.e. move src to dst) if cmp1 != cmp2, including the case of NaN\n+    float_beq(cmp1, cmp2, no_set);\n+  } else {\n+    double_beq(cmp1, cmp2, no_set);\n+  }\n+  if (cmov_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+\/\/ When cmp1 <= cmp2 or any of them is NaN then dst = src, otherwise, dst = dst\n+\/\/ Clarification\n+\/\/   scenario 1:\n+\/\/     java code      :  cmp2 < cmp1 ? dst : src\n+\/\/     transformed to :  CMove dst, (cmp1 le cmp2), dst, src\n+\/\/   scenario 2:\n+\/\/     java code      :  cmp1 > cmp2 ? dst : src\n+\/\/     transformed to :  CMove dst, (cmp1 le cmp2), dst, src\n+void MacroAssembler::cmov_fp_cmp_fp_le(FloatRegister cmp1, FloatRegister cmp2,\n+                                       FloatRegister dst, FloatRegister src,\n+                                       bool cmp_single, bool cmov_single) {\n+  Label no_set;\n+  if (cmp_single) {\n+    \/\/ jump if cmp1 > cmp2\n+    \/\/ not jump (i.e. move src to dst) if cmp1 <= cmp2 or either is NaN\n+    float_bgt(cmp1, cmp2, no_set);\n+  } else {\n+    double_bgt(cmp1, cmp2, no_set);\n+  }\n+  if (cmov_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n+\/\/ When cmp1 < cmp2 or any of them is NaN then dst = src, otherwise, dst = dst\n+\/\/ Clarification\n+\/\/   scenario 1:\n+\/\/     java code      :  cmp2 <= cmp1 ? dst : src\n+\/\/     transformed to :  CMove dst, (cmp1 lt cmp2), dst, src\n+\/\/   scenario 2:\n+\/\/     java code      :  cmp1 >= cmp2 ? dst : src\n+\/\/     transformed to :  CMove dst, (cmp1 lt cmp2), dst, src\n+void MacroAssembler::cmov_fp_cmp_fp_lt(FloatRegister cmp1, FloatRegister cmp2,\n+                                       FloatRegister dst, FloatRegister src,\n+                                       bool cmp_single, bool cmov_single) {\n+  Label no_set;\n+  if (cmp_single) {\n+    \/\/ jump if cmp1 >= cmp2\n+    \/\/ not jump (i.e. move src to dst) if cmp1 < cmp2 or either is NaN\n+    float_bge(cmp1, cmp2, no_set);\n+  } else {\n+    double_bge(cmp1, cmp2, no_set);\n+  }\n+  if (cmov_single) {\n+    fmv_s(dst, src);\n+  } else {\n+    fmv_d(dst, src);\n+  }\n+  bind(no_set);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":217,"deletions":1,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -668,0 +668,16 @@\n+  void cmov_fp_eq(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single);\n+  void cmov_fp_ne(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single);\n+  void cmov_fp_le(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single);\n+  void cmov_fp_leu(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single);\n+  void cmov_fp_ge(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single);\n+  void cmov_fp_geu(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single);\n+  void cmov_fp_lt(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single);\n+  void cmov_fp_ltu(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single);\n+  void cmov_fp_gt(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single);\n+  void cmov_fp_gtu(Register cmp1, Register cmp2, FloatRegister dst, FloatRegister src, bool is_single);\n+\n+  void cmov_fp_cmp_fp_eq(FloatRegister cmp1, FloatRegister cmp2, FloatRegister dst, FloatRegister src, bool cmp_single, bool cmov_single);\n+  void cmov_fp_cmp_fp_ne(FloatRegister cmp1, FloatRegister cmp2, FloatRegister dst, FloatRegister src, bool cmp_single, bool cmov_single);\n+  void cmov_fp_cmp_fp_le(FloatRegister cmp1, FloatRegister cmp2, FloatRegister dst, FloatRegister src, bool cmp_single, bool cmov_single);\n+  void cmov_fp_cmp_fp_lt(FloatRegister cmp1, FloatRegister cmp2, FloatRegister dst, FloatRegister src, bool cmp_single, bool cmov_single);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1944,2 +1944,0 @@\n-    case Op_CMoveF:\n-    case Op_CMoveD:\n@@ -10482,0 +10480,280 @@\n+\/\/ --------- CMoveF ---------\n+\n+instruct cmovF_cmpI(fRegF dst, fRegF src, iRegI op1, iRegI op2, cmpOp cop) %{\n+  match(Set dst (CMoveF (Binary cop (CmpI op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveF $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovF_cmpI\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), true \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovF_cmpU(fRegF dst, fRegF src, iRegI op1, iRegI op2, cmpOpU cop) %{\n+  match(Set dst (CMoveF (Binary cop (CmpU op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveF $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovF_cmpU\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), true \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovF_cmpL(fRegF dst, fRegF src, iRegL op1, iRegL op2, cmpOp cop) %{\n+  match(Set dst (CMoveF (Binary cop (CmpL op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveF $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovF_cmpL\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), true \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovF_cmpUL(fRegF dst, fRegF src, iRegL op1, iRegL op2, cmpOpU cop) %{\n+  match(Set dst (CMoveF (Binary cop (CmpUL op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveF $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovF_cmpUL\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), true \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovF_cmpF(fRegF dst, fRegF src, fRegF op1, fRegF op2, cmpOp cop) %{\n+  match(Set dst (CMoveF (Binary cop (CmpF op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveF $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovF_cmpF\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp_fp($cop$$cmpcode,\n+                    as_FloatRegister($op1$$reg), as_FloatRegister($op2$$reg),\n+                    as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                    true \/* cmp_single *\/, true \/* cmov_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovF_cmpD(fRegF dst, fRegF src, fRegD op1, fRegD op2, cmpOp cop) %{\n+  match(Set dst (CMoveF (Binary cop (CmpD op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveF $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovF_cmpD\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp_fp($cop$$cmpcode | C2_MacroAssembler::double_branch_mask,\n+                    as_FloatRegister($op1$$reg), as_FloatRegister($op2$$reg),\n+                    as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                    false \/* cmp_single *\/, true \/* cmov_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovF_cmpN(fRegF dst, fRegF src, iRegN op1, iRegN op2, cmpOp cop) %{\n+  match(Set dst (CMoveF (Binary cop (CmpN op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveF $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovF_cmpN\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), true \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovF_cmpP(fRegF dst, fRegF src, iRegP op1, iRegP op2, cmpOp cop) %{\n+  match(Set dst (CMoveF (Binary cop (CmpP op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveF $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovF_cmpP\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), true \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+\/\/ --------- CMoveD ---------\n+\n+instruct cmovD_cmpI(fRegD dst, fRegD src, iRegI op1, iRegI op2, cmpOp cop) %{\n+  match(Set dst (CMoveD (Binary cop (CmpI op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveD $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovD_cmpI\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), false \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovD_cmpU(fRegD dst, fRegD src, iRegI op1, iRegI op2, cmpOpU cop) %{\n+  match(Set dst (CMoveD (Binary cop (CmpU op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveD $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovD_cmpU\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), false \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovD_cmpL(fRegD dst, fRegD src, iRegL op1, iRegL op2, cmpOp cop) %{\n+  match(Set dst (CMoveD (Binary cop (CmpL op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveD $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovD_cmpL\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), false \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovD_cmpUL(fRegD dst, fRegD src, iRegL op1, iRegL op2, cmpOpU cop) %{\n+  match(Set dst (CMoveD (Binary cop (CmpUL op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveD $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovD_cmpUL\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), false \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovD_cmpF(fRegD dst, fRegD src, fRegF op1, fRegF op2, cmpOp cop) %{\n+  match(Set dst (CMoveD (Binary cop (CmpF op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveD $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovD_cmpF\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp_fp($cop$$cmpcode,\n+                    as_FloatRegister($op1$$reg), as_FloatRegister($op2$$reg),\n+                    as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                    true \/* cmp_single *\/, false \/* cmov_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovD_cmpD(fRegD dst, fRegD src, fRegD op1, fRegD op2, cmpOp cop) %{\n+  match(Set dst (CMoveD (Binary cop (CmpD op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveD $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovD_cmpD\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp_fp($cop$$cmpcode | C2_MacroAssembler::double_branch_mask,\n+                    as_FloatRegister($op1$$reg), as_FloatRegister($op2$$reg),\n+                    as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                    false \/* cmp_single *\/, false \/* cmov_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovD_cmpN(fRegD dst, fRegD src, iRegN op1, iRegN op2, cmpOp cop) %{\n+  match(Set dst (CMoveD (Binary cop (CmpN op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveD $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovD_cmpN\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), false \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovD_cmpP(fRegD dst, fRegD src, iRegP op1, iRegP op2, cmpOp cop) %{\n+  match(Set dst (CMoveD (Binary cop (CmpP op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveD $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovD_cmpP\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_fp_cmp($cop$$cmpcode | C2_MacroAssembler::unsigned_branch_mask,\n+                 as_Register($op1$$reg), as_Register($op2$$reg),\n+                 as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), false \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":280,"deletions":2,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -0,0 +1,3819 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Arm Limited. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8289422 8306088 8313720\n+ * @key randomness\n+ * @summary Auto-vectorization enhancement to support vector conditional move.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestConditionalMove\n+ *\/\n+\n+public class TestConditionalMove {\n+    final private static int SIZE = 1024;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        \/\/ Vectorizaion: +UseCMoveUnconditionally, +UseVectorCmov\n+        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+\n+        \/\/ Scalar: +UseCMoveUnconditionally, -UseVectorCmov\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\");\n+    }\n+\n+    \/\/ Compare 2 values, and pick one of them\n+    private float cmoveFloatGT(float a, float b) {\n+        return (a > b) ? a : b;\n+    }\n+\n+    private float cmoveFloatGTSwap(float a, float b) {\n+        return (b > a) ? a : b;\n+    }\n+\n+    private float cmoveFloatLT(float a, float b) {\n+        return (a < b) ? a : b;\n+    }\n+\n+    private float cmoveFloatLTSwap(float a, float b) {\n+        return (b < a) ? a : b;\n+    }\n+\n+    private float cmoveFloatEQ(float a, float b) {\n+        return (a == b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleLE(double a, double b) {\n+        return (a <= b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleLESwap(double a, double b) {\n+        return (b <= a) ? a : b;\n+    }\n+\n+    private double cmoveDoubleGE(double a, double b) {\n+        return (a >= b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleGESwap(double a, double b) {\n+        return (b >= a) ? a : b;\n+    }\n+\n+    private double cmoveDoubleNE(double a, double b) {\n+        return (a != b) ? a : b;\n+    }\n+\n+    \/\/ Extensions: compare 2 values, and pick from 2 consts\n+    private float cmoveFGTforFConst(float a, float b) {\n+        return (a > b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFGEforFConst(float a, float b) {\n+        return (a >= b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFLTforFConst(float a, float b) {\n+        return (a < b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFLEforFConst(float a, float b) {\n+        return (a <= b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFEQforFConst(float a, float b) {\n+        return (a == b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFNEQforFConst(float a, float b) {\n+        return (a != b) ? 0.1f : -0.1f;\n+    }\n+\n+    private double cmoveDGTforDConst(double a, double b) {\n+        return (a > b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDGEforDConst(double a, double b) {\n+        return (a >= b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDLTforDConst(double a, double b) {\n+        return (a < b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDLEforDConst(double a, double b) {\n+        return (a <= b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDEQforDConst(double a, double b) {\n+        return (a == b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDNEQforDConst(double a, double b) {\n+        return (a != b) ? 0.1 : -0.1;\n+    }\n+\n+    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n+    \/\/ Signed comparison: I\/L\n+    \/\/    I for I\n+    private int cmoveIEQforI(int a, int b, int c, int d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private int cmoveINEforI(int a, int b, int c, int d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private int cmoveIGTforI(int a, int b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private int cmoveIGEforI(int a, int b, int c, int d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private int cmoveILTforI(int a, int b, int c, int d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private int cmoveILEforI(int a, int b, int c, int d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for L\n+    private long cmoveIEQforL(int a, int b, long c, long d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private long cmoveINEforL(int a, int b, long c, long d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private long cmoveIGTforL(int a, int b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveIGEforL(int a, int b, long c, long d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private long cmoveILTforL(int a, int b, long c, long d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private long cmoveILEforL(int a, int b, long c, long d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for F\n+    private float cmoveIEQforF(int a, int b, float c, float d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private float cmoveINEforF(int a, int b, float c, float d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private float cmoveIGTforF(int a, int b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveIGEforF(int a, int b, float c, float d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private float cmoveILTforF(int a, int b, float c, float d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private float cmoveILEforF(int a, int b, float c, float d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for D\n+    private double cmoveIEQforD(int a, int b, double c, double d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private double cmoveINEforD(int a, int b, double c, double d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private double cmoveIGTforD(int a, int b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveIGEforD(int a, int b, double c, double d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private double cmoveILTforD(int a, int b, double c, double d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private double cmoveILEforD(int a, int b, double c, double d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for I\n+    private int cmoveLEQforI(long a, long b, int c, int d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private int cmoveLNEforI(long a, long b, int c, int d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private int cmoveLGTforI(long a, long b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private int cmoveLGEforI(long a, long b, int c, int d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private int cmoveLLTforI(long a, long b, int c, int d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private int cmoveLLEforI(long a, long b, int c, int d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for L\n+    private long cmoveLEQforL(long a, long b, long c, long d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private long cmoveLNEforL(long a, long b, long c, long d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private long cmoveLGTforL(long a, long b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveLGEforL(long a, long b, long c, long d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private long cmoveLLTforL(long a, long b, long c, long d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private long cmoveLLEforL(long a, long b, long c, long d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for F\n+    private float cmoveLEQforF(long a, long b, float c, float d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private float cmoveLNEforF(long a, long b, float c, float d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private float cmoveLGTforF(long a, long b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveLGEforF(long a, long b, float c, float d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private float cmoveLLTforF(long a, long b, float c, float d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private float cmoveLLEforF(long a, long b, float c, float d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for D\n+    private double cmoveLEQforD(long a, long b, double c, double d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private double cmoveLNEforD(long a, long b, double c, double d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private double cmoveLGTforD(long a, long b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveLGEforD(long a, long b, double c, double d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private double cmoveLLTforD(long a, long b, double c, double d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private double cmoveLLEforD(long a, long b, double c, double d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/ Unsigned comparison: I\/L\n+    \/\/    I for I\n+    private int cmoveUIEQforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private int cmoveUINEforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private int cmoveUIGTforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private int cmoveUIGEforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private int cmoveUILTforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private int cmoveUILEforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    I for L\n+    private long cmoveUIEQforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private long cmoveUINEforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private long cmoveUIGTforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private long cmoveUIGEforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private long cmoveUILTforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private long cmoveUILEforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    I for F\n+    private float cmoveUIEQforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private float cmoveUINEforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private float cmoveUIGTforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private float cmoveUIGEforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private float cmoveUILTforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private float cmoveUILEforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    I for D\n+    private double cmoveUIEQforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private double cmoveUINEforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private double cmoveUIGTforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private double cmoveUIGEforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private double cmoveUILTforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private double cmoveUILEforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for I\n+    private int cmoveULEQforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private int cmoveULNEforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private int cmoveULGTforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private int cmoveULGEforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private int cmoveULLTforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private int cmoveULLEforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for L\n+    private long cmoveULEQforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private long cmoveULNEforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private long cmoveULGTforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private long cmoveULGEforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private long cmoveULLTforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private long cmoveULLEforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for F\n+    private float cmoveULEQforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private float cmoveULNEforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private float cmoveULGTforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private float cmoveULGEforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private float cmoveULLTforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private float cmoveULLEforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for D\n+    private double cmoveULEQforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private double cmoveULNEforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private double cmoveULGTforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private double cmoveULGEforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private double cmoveULLTforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private double cmoveULLEforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/ Float comparison\n+    private int cmoveFGTforI(float a, float b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveFGTforL(float a, float b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveFGTforF(float a, float b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveFGTforD(float a, float b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    \/\/ Double comparison\n+    private int cmoveDGTforI(double a, double b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveDGTforL(double a, double b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveDGTforF(double a, double b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveDGTforD(double a, double b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    \/\/ Compare 2 values, and pick one of them\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVFGT(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVFGTSwap(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] > a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVFLT(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVFLTSwap(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] < a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVFEQ(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] == b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVDLE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVDLESwap(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] <= a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVDGE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVDGESwap(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] >= a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVDNE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] != b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    \/\/ Extensions: compare 2 values, and pick from 2 consts\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGEforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFLTforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFLEforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFEQforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] == b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFNEQforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] != b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfAnd = {\"UseCompactObjectHeaders\", \"false\", \"UseVectorCmov\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                    IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                    IRNode.VECTOR_BLEND_F, \">0\",\n+                    IRNode.STORE_VECTOR, \">0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseVectorCmov\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFLTforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] < b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] < b[i+1]) ? 0.1f : -0.1f;\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n+            \/\/ -> vectorize                                         -> no vectorization\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfAnd = {\"UseCompactObjectHeaders\", \"false\", \"UseVectorCmov\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                    IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                    IRNode.VECTOR_BLEND_F, \">0\",\n+                    IRNode.STORE_VECTOR, \">0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseVectorCmov\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFLEforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n+            \/\/ -> vectorize                                         -> no vectorization\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \"=0\",\n+                  IRNode.VECTOR_BLEND_F, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFYYforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \"=0\",\n+                  IRNode.VECTOR_BLEND_F, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFXXforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGTforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGEforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDLTforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDLEforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDEQforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] == b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDNEQforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] != b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDLTforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] < b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] < b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDLEforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \"=0\",\n+                  IRNode.VECTOR_BLEND_D, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDYYforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \"=0\",\n+                  IRNode.VECTOR_BLEND_D, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDXXforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n+    \/\/ Note:\n+    \/\/   To guarantee that CMove is introduced, I need to perform the loads before the branch. To ensure they\n+    \/\/   do not float down into the branches, I compute a value, and store it to r2 (same as r, except that the\n+    \/\/   compilation does not know that).\n+    \/\/   So far, vectorization only works for CMoveF\/D, with same data-width comparison (F\/I for F, D\/L for D).\n+    \/\/   TODO: enable CMOVE_I\/L verification when it's guaranteed to generate CMOVE_I\/L, JDK-8371984.\n+    \/\/\n+    \/\/ Signed comparison: I\/L\n+    \/\/     I fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo F\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo D\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo F\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo D\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ Unsigned comparison: I\/L\n+    \/\/     I fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo F\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo D\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo F\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo D\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_F, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforI(float[] a, float[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_F, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforL(float[] a, float[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforF(float[] a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforD(float[] a, float[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_D, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGTforI(double[] a, double[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_D, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGTforL(double[] a, double[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGTforF(double[] a, double[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGTforD(double[] a, double[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ Use some constants in the comparison\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforFCmpCon1(float a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < b.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforFCmpCon2(float[] a, float b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ A case that is currently not supported and is not expected to vectorize\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveVDUnsupported() {\n+        double[] doublec = new double[SIZE];\n+        int seed = 1001;\n+        for (int i = 0; i < doublec.length; i++) {\n+            doublec[i] = (i % 2 == 0) ? seed + i : seed - i;\n+        }\n+    }\n+\n+    @Warmup(0)\n+    @Run(test = {\"testCMoveVFGT\", \"testCMoveVFLT\",\"testCMoveVDLE\", \"testCMoveVDGE\", \"testCMoveVFEQ\", \"testCMoveVDNE\",\n+                 \"testCMoveVFGTSwap\", \"testCMoveVFLTSwap\",\"testCMoveVDLESwap\", \"testCMoveVDGESwap\",\n+                 \"testCMoveFGTforFConst\", \"testCMoveFGEforFConst\", \"testCMoveFLTforFConst\",\n+                 \"testCMoveFLEforFConst\", \"testCMoveFEQforFConst\", \"testCMoveFNEQforFConst\",\n+                 \"testCMoveDGTforDConst\", \"testCMoveDGEforDConst\", \"testCMoveDLTforDConst\",\n+                 \"testCMoveDLEforDConst\", \"testCMoveDEQforDConst\", \"testCMoveDNEQforDConst\",\n+                 \"testCMoveFLTforFConstH2\", \"testCMoveFLEforFConstH2\",\n+                 \"testCMoveFYYforFConstH2\", \"testCMoveFXXforFConstH2\",\n+                 \"testCMoveDLTforDConstH2\", \"testCMoveDLEforDConstH2\",\n+                 \"testCMoveDYYforDConstH2\", \"testCMoveDXXforDConstH2\"})\n+    private void testCMove_runner() {\n+        float[] floata = new float[SIZE];\n+        float[] floatb = new float[SIZE];\n+        float[] floatc = new float[SIZE];\n+        double[] doublea = new double[SIZE];\n+        double[] doubleb = new double[SIZE];\n+        double[] doublec = new double[SIZE];\n+\n+        init(floata);\n+        init(floatb);\n+        init(doublea);\n+        init(doubleb);\n+\n+        testCMoveVFGT(floata, floatb, floatc);\n+        testCMoveVDLE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatGT(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleLE(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFLT(floata, floatb, floatc);\n+        testCMoveVDGE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatLT(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleGE(doublea[i], doubleb[i]));\n+        }\n+\n+        \/\/ Ensure we frequently have equals\n+        for (int i = 0; i < SIZE; i++) {\n+            if (i % 3 == 0) {\n+                floatb[i] = floata[i];\n+                doubleb[i] = doublea[i];\n+            }\n+        }\n+\n+        testCMoveVFEQ(floata, floatb, floatc);\n+        testCMoveVDNE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatEQ(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleNE(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFGTSwap(floata, floatb, floatc);\n+        testCMoveVDLESwap(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatGTSwap(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleLESwap(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFLTSwap(floata, floatb, floatc);\n+        testCMoveVDGESwap(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatLTSwap(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleGESwap(doublea[i], doubleb[i]));\n+        }\n+\n+        \/\/ Extensions: compare 2 values, and pick from 2 consts\n+        testCMoveFGTforFConst(floata, floatb, floatc);\n+        testCMoveDGTforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFGTforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDGTforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFGEforFConst(floata, floatb, floatc);\n+        testCMoveDGEforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFGEforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDGEforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFLTforFConst(floata, floatb, floatc);\n+        testCMoveDLTforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFLEforFConst(floata, floatb, floatc);\n+        testCMoveDLEforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFEQforFConst(floata, floatb, floatc);\n+        testCMoveDEQforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFEQforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDEQforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFNEQforFConst(floata, floatb, floatc);\n+        testCMoveDNEQforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFNEQforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDNEQforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        \/\/ Hand-unrolled (H2) examples:\n+        testCMoveFLTforFConstH2(floata, floatb, floatc);\n+        testCMoveDLTforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFLEforFConstH2(floata, floatb, floatc);\n+        testCMoveDLEforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFYYforFConstH2(floata, floatb, floatc);\n+        testCMoveDYYforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i+=2) {\n+            Asserts.assertEquals(floatc[i+0], cmoveFLEforFConst(floata[i+0], floatb[i+0]));\n+            Asserts.assertEquals(doublec[i+0], cmoveDLEforDConst(doublea[i+0], doubleb[i+0]));\n+            Asserts.assertEquals(floatc[i+1], cmoveFLTforFConst(floata[i+1], floatb[i+1]));\n+            Asserts.assertEquals(doublec[i+1], cmoveDLTforDConst(doublea[i+1], doubleb[i+1]));\n+        }\n+\n+        testCMoveFXXforFConstH2(floata, floatb, floatc);\n+        testCMoveDXXforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i+=2) {\n+            Asserts.assertEquals(floatc[i+0], cmoveFLTforFConst(floata[i+0], floatb[i+0]));\n+            Asserts.assertEquals(doublec[i+0], cmoveDLTforDConst(doublea[i+0], doubleb[i+0]));\n+            Asserts.assertEquals(floatc[i+1], cmoveFLEforFConst(floata[i+1], floatb[i+1]));\n+            Asserts.assertEquals(doublec[i+1], cmoveDLEforDConst(doublea[i+1], doubleb[i+1]));\n+        }\n+    }\n+\n+    @Warmup(0)\n+    @Run(test = {\/\/ Signed\n+                 \/\/     I for I\n+                 \"testCMoveIEQforI\",\n+                 \"testCMoveINEforI\",\n+                 \"testCMoveIGTforI\",\n+                 \"testCMoveIGEforI\",\n+                 \"testCMoveILTforI\",\n+                 \"testCMoveILEforI\",\n+                 \/\/     I for L\n+                 \"testCMoveIEQforL\",\n+                 \"testCMoveINEforL\",\n+                 \"testCMoveIGTforL\",\n+                 \"testCMoveIGEforL\",\n+                 \"testCMoveILTforL\",\n+                 \"testCMoveILEforL\",\n+                 \/\/     I for F\n+                 \"testCMoveIEQforF\",\n+                 \"testCMoveINEforF\",\n+                 \"testCMoveIGTforF\",\n+                 \"testCMoveIGEforF\",\n+                 \"testCMoveILTforF\",\n+                 \"testCMoveILEforF\",\n+                 \/\/     I for D\n+                 \"testCMoveIEQforD\",\n+                 \"testCMoveINEforD\",\n+                 \"testCMoveIGTforD\",\n+                 \"testCMoveIGEforD\",\n+                 \"testCMoveILTforD\",\n+                 \"testCMoveILEforD\",\n+                 \/\/     L for I\n+                 \"testCMoveLEQforI\",\n+                 \"testCMoveLNEforI\",\n+                 \"testCMoveLGTforI\",\n+                 \"testCMoveLGEforI\",\n+                 \"testCMoveLLTforI\",\n+                 \"testCMoveLLEforI\",\n+                 \/\/     L for L\n+                 \"testCMoveLEQforL\",\n+                 \"testCMoveLNEforL\",\n+                 \"testCMoveLGTforL\",\n+                 \"testCMoveLGEforL\",\n+                 \"testCMoveLLTforL\",\n+                 \"testCMoveLLEforL\",\n+                 \/\/     L for F\n+                 \"testCMoveLEQforF\",\n+                 \"testCMoveLNEforF\",\n+                 \"testCMoveLGTforF\",\n+                 \"testCMoveLGEforF\",\n+                 \"testCMoveLLTforF\",\n+                 \"testCMoveLLEforF\",\n+                 \/\/     L for D\n+                 \"testCMoveLEQforD\",\n+                 \"testCMoveLNEforD\",\n+                 \"testCMoveLGTforD\",\n+                 \"testCMoveLGEforD\",\n+                 \"testCMoveLLTforD\",\n+                 \"testCMoveLLEforD\",\n+                 \/\/ Unsigned\n+                 \/\/     I for I\n+                 \"testCMoveUIEQforI\",\n+                 \"testCMoveUINEforI\",\n+                 \"testCMoveUIGTforI\",\n+                 \"testCMoveUIGEforI\",\n+                 \"testCMoveUILTforI\",\n+                 \"testCMoveUILEforI\",\n+                 \/\/     I for L\n+                 \"testCMoveUIEQforL\",\n+                 \"testCMoveUINEforL\",\n+                 \"testCMoveUIGTforL\",\n+                 \"testCMoveUIGEforL\",\n+                 \"testCMoveUILTforL\",\n+                 \"testCMoveUILEforL\",\n+                 \/\/     I for F\n+                 \"testCMoveUIEQforF\",\n+                 \"testCMoveUINEforF\",\n+                 \"testCMoveUIGTforF\",\n+                 \"testCMoveUIGEforF\",\n+                 \"testCMoveUILTforF\",\n+                 \"testCMoveUILEforF\",\n+                 \/\/     I for D\n+                 \"testCMoveUIEQforD\",\n+                 \"testCMoveUINEforD\",\n+                 \"testCMoveUIGTforD\",\n+                 \"testCMoveUIGEforD\",\n+                 \"testCMoveUILTforD\",\n+                 \"testCMoveUILEforD\",\n+                 \/\/     L for I\n+                 \"testCMoveULEQforI\",\n+                 \"testCMoveULNEforI\",\n+                 \"testCMoveULGTforI\",\n+                 \"testCMoveULGEforI\",\n+                 \"testCMoveULLTforI\",\n+                 \"testCMoveULLEforI\",\n+                 \/\/     L for L\n+                 \"testCMoveULEQforL\",\n+                 \"testCMoveULNEforL\",\n+                 \"testCMoveULGTforL\",\n+                 \"testCMoveULGEforL\",\n+                 \"testCMoveULLTforL\",\n+                 \"testCMoveULLEforL\",\n+                 \/\/     L for F\n+                 \"testCMoveULEQforF\",\n+                 \"testCMoveULNEforF\",\n+                 \"testCMoveULGTforF\",\n+                 \"testCMoveULGEforF\",\n+                 \"testCMoveULLTforF\",\n+                 \"testCMoveULLEforF\",\n+                 \/\/     L for D\n+                 \"testCMoveULEQforD\",\n+                 \"testCMoveULNEforD\",\n+                 \"testCMoveULGTforD\",\n+                 \"testCMoveULGEforD\",\n+                 \"testCMoveULLTforD\",\n+                 \"testCMoveULLEforD\",\n+                 \/\/ Float\n+                 \"testCMoveFGTforI\",\n+                 \"testCMoveFGTforL\",\n+                 \"testCMoveFGTforF\",\n+                 \"testCMoveFGTforD\",\n+                 \"testCMoveDGTforI\",\n+                 \"testCMoveDGTforL\",\n+                 \"testCMoveDGTforF\",\n+                 \"testCMoveDGTforD\",\n+                 \"testCMoveFGTforFCmpCon1\",\n+                 \"testCMoveFGTforFCmpCon2\"})\n+    private void testCMove_runner_two() {\n+        int[] aI = new int[SIZE];\n+        int[] bI = new int[SIZE];\n+        int[] cI = new int[SIZE];\n+        int[] dI = new int[SIZE];\n+        int[] rI = new int[SIZE];\n+        long[] aL = new long[SIZE];\n+        long[] bL = new long[SIZE];\n+        long[] cL = new long[SIZE];\n+        long[] dL = new long[SIZE];\n+        long[] rL = new long[SIZE];\n+        float[] aF = new float[SIZE];\n+        float[] bF = new float[SIZE];\n+        float[] cF = new float[SIZE];\n+        float[] dF = new float[SIZE];\n+        float[] rF = new float[SIZE];\n+        double[] aD = new double[SIZE];\n+        double[] bD = new double[SIZE];\n+        double[] cD = new double[SIZE];\n+        double[] dD = new double[SIZE];\n+        double[] rD = new double[SIZE];\n+\n+        init(aI);\n+        init(bI);\n+        init(cI);\n+        init(dI);\n+        init(aL);\n+        init(bL);\n+        init(cL);\n+        init(dL);\n+        init(aF);\n+        init(bF);\n+        init(cF);\n+        init(dF);\n+        init(aD);\n+        init(bD);\n+        init(cD);\n+        init(dD);\n+\n+        \/\/ Signed\n+        \/\/     I for I\n+        testCMoveIEQforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIEQforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveINEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveINEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveIGTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIGTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveIGEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIGEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveILTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveILTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveILEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveILEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     I for L\n+        testCMoveIEQforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIEQforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveINEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveINEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveIGTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIGTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveIGEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIGEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveILTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveILTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveILEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveILEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     I for F\n+        testCMoveIEQforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIEQforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveINEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveINEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveIGTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIGTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveIGEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIGEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveILTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveILTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveILEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveILEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     I for D\n+        testCMoveIEQforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIEQforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveINEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveINEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveIGTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIGTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveIGEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIGEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveILTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveILTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveILEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveILEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/     L for I\n+        testCMoveLEQforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLEQforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLNEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLNEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLGTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLGTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLGEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLGEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLLTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLLTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLLEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLLEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     L for L\n+        testCMoveLEQforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLEQforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLNEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLNEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLGTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLGTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLGEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLGEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLLTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLLTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLLEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLLEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     L for F\n+        testCMoveLEQforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLEQforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLNEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLNEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLGTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLGTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLGEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLGEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLLTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLLTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLLEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLLEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     L for D\n+        testCMoveLEQforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLEQforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLNEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLNEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLGTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLGTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLGEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLGEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLLTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLLTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLLEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLLEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/ Unsigned\n+        \/\/     I for I\n+        testCMoveUIEQforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIEQforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUINEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUINEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUIGTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIGTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUIGEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIGEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUILTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUILTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUILEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUILEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     I for L\n+        testCMoveUIEQforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIEQforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUINEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUINEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUIGTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIGTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUIGEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIGEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUILTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUILTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUILEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUILEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     I for F\n+        testCMoveUIEQforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIEQforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUINEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUINEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUIGTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIGTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUIGEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIGEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUILTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUILTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUILEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUILEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     I for D\n+        testCMoveUIEQforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIEQforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUINEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUINEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUIGTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIGTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUIGEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIGEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUILTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUILTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUILEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUILEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/     L for I\n+        testCMoveULEQforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULEQforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULNEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULNEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULGTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULGTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULGEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULGEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULLTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULLTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULLEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULLEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     L for L\n+        testCMoveULEQforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULEQforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULNEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULNEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULGTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULGTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULGEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULGEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULLTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULLTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULLEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULLEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     L for F\n+        testCMoveULEQforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULEQforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULNEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULNEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULGTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULGTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULGEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULGEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULLTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULLTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULLEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULLEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     L for D\n+        testCMoveULEQforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULEQforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULNEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULNEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULGTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULGTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULGEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULGEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULLTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULLTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULLEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULLEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/ Float\n+        testCMoveFGTforI(aF, bF, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveFGTforI(aF[i], bF[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveFGTforL(aF, bF, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveFGTforL(aF[i], bF[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveFGTforF(aF, bF, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveFGTforD(aF, bF, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveFGTforD(aF[i], bF[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveDGTforI(aD, bD, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveDGTforI(aD[i], bD[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveDGTforL(aD, bD, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveDGTforL(aD[i], bD[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveDGTforF(aD, bD, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveDGTforF(aD[i], bD[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveDGTforD(aD, bD, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveDGTforD(aD[i], bD[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/ Use some constants\/invariants in the comparison\n+        testCMoveFGTforFCmpCon1(aF[0], bF, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[0], bF[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveFGTforFCmpCon2(aF, bF[0], cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[0], cF[i], dF[i]));\n+        }\n+    }\n+\n+    private static void init(int[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n+    private static void init(long[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+    }\n+\n+    private static void init(float[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = switch(RANDOM.nextInt() % 20) {\n+                case 0  -> Float.NaN;\n+                case 1  -> 0;\n+                case 2  -> 1;\n+                case 3  -> Float.POSITIVE_INFINITY;\n+                case 4  -> Float.NEGATIVE_INFINITY;\n+                case 5  -> Float.MAX_VALUE;\n+                case 6  -> Float.MIN_VALUE;\n+                case 7, 8, 9 -> RANDOM.nextFloat();\n+                default -> Float.intBitsToFloat(RANDOM.nextInt());\n+            };\n+        }\n+    }\n+\n+    private static void init(double[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = switch(RANDOM.nextInt() % 20) {\n+                case 0  -> Double.NaN;\n+                case 1  -> 0;\n+                case 2  -> 1;\n+                case 3  -> Double.POSITIVE_INFINITY;\n+                case 4  -> Double.NEGATIVE_INFINITY;\n+                case 5  -> Double.MAX_VALUE;\n+                case 6  -> Double.MIN_VALUE;\n+                case 7, 8, 9 -> RANDOM.nextDouble();\n+                default -> Double.longBitsToDouble(RANDOM.nextLong());\n+            };\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestConditionalMove.java","additions":3819,"deletions":0,"binary":false,"changes":3819,"status":"added"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @summary Test conditional move + compare object.\n+ * @requires vm.simpleArch == \"riscv64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestScalarConditionalMoveCmpObj\n+ *\/\n+\n+public class TestScalarConditionalMoveCmpObj {\n+    final private static int SIZE = 1024;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+UseCompressedOops\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-UseCompressedOops\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+UseCompressedOops\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-UseCompressedOops\");\n+    }\n+\n+    \/\/ Object comparison\n+    \/\/    O for I\n+    private int cmoveOEQforI(Object a, Object b, int c, int d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private int cmoveONEforI(Object a, Object b, int c, int d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    \/\/    O for L\n+    private long cmoveOEQforL(Object a, Object b, long c, long d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private long cmoveONEforL(Object a, Object b, long c, long d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    \/\/    O for F\n+    private float cmoveOEQforF(Object a, Object b, float c, float d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private float cmoveONEforF(Object a, Object b, float c, float d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    \/\/    O for D\n+    private double cmoveOEQforD(Object a, Object b, double c, double d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private double cmoveONEforD(Object a, Object b, double c, double d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    \/\/ Tests shows CMoveI is generated, so let @IR verify CMOVE_I.\n+    \/\/\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveOEQforI(Object[] a, Object[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveONEforI(Object[] a, Object[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ So far, CMoveL is not guaranteed to be generated, so @IR not verify CMOVE_L.\n+    \/\/ TODO: enable CMOVE_L verification when it's guaranteed to generate CMOVE_L.\n+    \/\/\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_P, \">0\"},\n+    \/\/     applyIf = {\"UseCompressedOops\", \"false\"})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_N, \">0\"},\n+    \/\/     applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveOEQforL(Object[] a, Object[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_P, \">0\"},\n+    \/\/     applyIf = {\"UseCompressedOops\", \"false\"})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_N, \">0\"},\n+    \/\/     applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveONEforL(Object[] a, Object[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveOEQforF(Object[] a, Object[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveONEforF(Object[] a, Object[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveOEQforD(Object[] a, Object[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_P, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_N, \">0\"},\n+        applyIf = {\"UseCompressedOops\", \"true\"})\n+    private static void testCMoveONEforD(Object[] a, Object[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Warmup(0)\n+    @Run(test = {\/\/ Object\n+                 \"testCMoveOEQforI\",\n+                 \"testCMoveONEforI\",\n+                 \"testCMoveOEQforL\",\n+                 \"testCMoveONEforL\",\n+                 \"testCMoveOEQforF\",\n+                 \"testCMoveONEforF\",\n+                 \"testCMoveOEQforD\",\n+                 \"testCMoveONEforD\",\n+                })\n+    private void testCMove_runner_two() {\n+        Object[] aO = new Object[SIZE];\n+        Object[] bO = new Object[SIZE];\n+        int[] cI = new int[SIZE];\n+        int[] dI = new int[SIZE];\n+        int[] rI = new int[SIZE];\n+        long[] cL = new long[SIZE];\n+        long[] dL = new long[SIZE];\n+        long[] rL = new long[SIZE];\n+        float[] cF = new float[SIZE];\n+        float[] dF = new float[SIZE];\n+        float[] rF = new float[SIZE];\n+        double[] cD = new double[SIZE];\n+        double[] dD = new double[SIZE];\n+        double[] rD = new double[SIZE];\n+\n+        init(aO);\n+        shuffle(aO, bO);\n+        init(cL);\n+        init(dL);\n+        init(cF);\n+        init(dF);\n+        init(cD);\n+        init(dD);\n+\n+        testCMoveOEQforI(aO, bO, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveOEQforI(aO[i], bO[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveONEforI(aO, bO, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveONEforI(aO[i], bO[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveOEQforL(aO, bO, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveOEQforL(aO[i], bO[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveONEforL(aO, bO, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveONEforL(aO[i], bO[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveOEQforF(aO, bO, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveOEQforF(aO[i], bO[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveONEforF(aO, bO, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveONEforF(aO[i], bO[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveOEQforD(aO, bO, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveOEQforD(aO[i], bO[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveONEforD(aO, bO, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveONEforD(aO[i], bO[i], cD[i], dD[i]));\n+        }\n+\n+    }\n+\n+    private static void init(Object[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = new Object();\n+        }\n+    }\n+\n+    private static void shuffle(Object[] a, Object[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+        Random rand = new Random();\n+        for (int i = 0; i < SIZE; i++) {\n+            if (rand.nextInt(5) == 0) {\n+                Object t = b[i];\n+                b[i] = b[SIZE-1-i];\n+                b[SIZE-1-i] = t;\n+            }\n+        }\n+    }\n+\n+    private static void init(int[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n+    private static void init(long[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+    }\n+\n+    private static void init(float[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = switch(RANDOM.nextInt() % 20) {\n+                case 0  -> Float.NaN;\n+                case 1  -> 0;\n+                case 2  -> 1;\n+                case 3  -> Float.POSITIVE_INFINITY;\n+                case 4  -> Float.NEGATIVE_INFINITY;\n+                case 5  -> Float.MAX_VALUE;\n+                case 6  -> Float.MIN_VALUE;\n+                case 7, 8, 9 -> RANDOM.nextFloat();\n+                default -> Float.intBitsToFloat(RANDOM.nextInt());\n+            };\n+        }\n+    }\n+\n+    private static void init(double[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = switch(RANDOM.nextInt() % 20) {\n+                case 0  -> Double.NaN;\n+                case 1  -> 0;\n+                case 2  -> 1;\n+                case 3  -> Double.POSITIVE_INFINITY;\n+                case 4  -> Double.NEGATIVE_INFINITY;\n+                case 5  -> Double.MAX_VALUE;\n+                case 6  -> Double.MIN_VALUE;\n+                case 7, 8, 9 -> RANDOM.nextDouble();\n+                default -> Double.longBitsToDouble(RANDOM.nextLong());\n+            };\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestScalarConditionalMoveCmpObj.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"},{"patch":"@@ -1,3216 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2.irTests;\n-\n-import compiler.lib.ir_framework.*;\n-import java.util.Random;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-\n-\/*\n- * @test\n- * @bug 8289422 8306088 8313720\n- * @key randomness\n- * @summary Auto-vectorization enhancement to support vector conditional move.\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.irTests.TestVectorConditionalMove\n- *\/\n-\n-public class TestVectorConditionalMove {\n-    final private static int SIZE = 1024;\n-    private static final Random RANDOM = Utils.getRandomInstance();\n-\n-    public static void main(String[] args) {\n-        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n-                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n-                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n-                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n-                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n-    }\n-\n-    \/\/ Compare 2 values, and pick one of them\n-    private float cmoveFloatGT(float a, float b) {\n-        return (a > b) ? a : b;\n-    }\n-\n-    private float cmoveFloatGTSwap(float a, float b) {\n-        return (b > a) ? a : b;\n-    }\n-\n-    private float cmoveFloatLT(float a, float b) {\n-        return (a < b) ? a : b;\n-    }\n-\n-    private float cmoveFloatLTSwap(float a, float b) {\n-        return (b < a) ? a : b;\n-    }\n-\n-    private float cmoveFloatEQ(float a, float b) {\n-        return (a == b) ? a : b;\n-    }\n-\n-    private double cmoveDoubleLE(double a, double b) {\n-        return (a <= b) ? a : b;\n-    }\n-\n-    private double cmoveDoubleLESwap(double a, double b) {\n-        return (b <= a) ? a : b;\n-    }\n-\n-    private double cmoveDoubleGE(double a, double b) {\n-        return (a >= b) ? a : b;\n-    }\n-\n-    private double cmoveDoubleGESwap(double a, double b) {\n-        return (b >= a) ? a : b;\n-    }\n-\n-    private double cmoveDoubleNE(double a, double b) {\n-        return (a != b) ? a : b;\n-    }\n-\n-    \/\/ Extensions: compare 2 values, and pick from 2 consts\n-    private float cmoveFGTforFConst(float a, float b) {\n-        return (a > b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFGEforFConst(float a, float b) {\n-        return (a >= b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFLTforFConst(float a, float b) {\n-        return (a < b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFLEforFConst(float a, float b) {\n-        return (a <= b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFEQforFConst(float a, float b) {\n-        return (a == b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFNEQforFConst(float a, float b) {\n-        return (a != b) ? 0.1f : -0.1f;\n-    }\n-\n-    private double cmoveDGTforDConst(double a, double b) {\n-        return (a > b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDGEforDConst(double a, double b) {\n-        return (a >= b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDLTforDConst(double a, double b) {\n-        return (a < b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDLEforDConst(double a, double b) {\n-        return (a <= b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDEQforDConst(double a, double b) {\n-        return (a == b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDNEQforDConst(double a, double b) {\n-        return (a != b) ? 0.1 : -0.1;\n-    }\n-\n-    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n-    \/\/ Signed comparison: I\/L\n-    \/\/    I for I\n-    private int cmoveIEQforI(int a, int b, int c, int d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private int cmoveINEforI(int a, int b, int c, int d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private int cmoveIGTforI(int a, int b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private int cmoveIGEforI(int a, int b, int c, int d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private int cmoveILTforI(int a, int b, int c, int d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private int cmoveILEforI(int a, int b, int c, int d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    I for L\n-    private long cmoveIEQforL(int a, int b, long c, long d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private long cmoveINEforL(int a, int b, long c, long d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private long cmoveIGTforL(int a, int b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveIGEforL(int a, int b, long c, long d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private long cmoveILTforL(int a, int b, long c, long d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private long cmoveILEforL(int a, int b, long c, long d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    I for F\n-    private float cmoveIEQforF(int a, int b, float c, float d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private float cmoveINEforF(int a, int b, float c, float d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private float cmoveIGTforF(int a, int b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveIGEforF(int a, int b, float c, float d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private float cmoveILTforF(int a, int b, float c, float d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private float cmoveILEforF(int a, int b, float c, float d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    I for D\n-    private double cmoveIEQforD(int a, int b, double c, double d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private double cmoveINEforD(int a, int b, double c, double d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private double cmoveIGTforD(int a, int b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveIGEforD(int a, int b, double c, double d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private double cmoveILTforD(int a, int b, double c, double d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private double cmoveILEforD(int a, int b, double c, double d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for I\n-    private int cmoveLEQforI(long a, long b, int c, int d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private int cmoveLNEforI(long a, long b, int c, int d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private int cmoveLGTforI(long a, long b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private int cmoveLGEforI(long a, long b, int c, int d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private int cmoveLLTforI(long a, long b, int c, int d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private int cmoveLLEforI(long a, long b, int c, int d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for L\n-    private long cmoveLEQforL(long a, long b, long c, long d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private long cmoveLNEforL(long a, long b, long c, long d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private long cmoveLGTforL(long a, long b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveLGEforL(long a, long b, long c, long d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private long cmoveLLTforL(long a, long b, long c, long d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private long cmoveLLEforL(long a, long b, long c, long d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for F\n-    private float cmoveLEQforF(long a, long b, float c, float d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private float cmoveLNEforF(long a, long b, float c, float d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private float cmoveLGTforF(long a, long b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveLGEforF(long a, long b, float c, float d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private float cmoveLLTforF(long a, long b, float c, float d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private float cmoveLLEforF(long a, long b, float c, float d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for D\n-    private double cmoveLEQforD(long a, long b, double c, double d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private double cmoveLNEforD(long a, long b, double c, double d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private double cmoveLGTforD(long a, long b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveLGEforD(long a, long b, double c, double d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private double cmoveLLTforD(long a, long b, double c, double d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private double cmoveLLEforD(long a, long b, double c, double d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/ Unsigned comparison: I\/L\n-    \/\/    I for I\n-    private int cmoveUIEQforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private int cmoveUINEforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private int cmoveUIGTforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private int cmoveUIGEforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private int cmoveUILTforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private int cmoveUILEforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    I for L\n-    private long cmoveUIEQforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private long cmoveUINEforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private long cmoveUIGTforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private long cmoveUIGEforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private long cmoveUILTforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private long cmoveUILEforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    I for F\n-    private float cmoveUIEQforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private float cmoveUINEforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private float cmoveUIGTforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private float cmoveUIGEforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private float cmoveUILTforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private float cmoveUILEforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    I for D\n-    private double cmoveUIEQforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private double cmoveUINEforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private double cmoveUIGTforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private double cmoveUIGEforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private double cmoveUILTforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private double cmoveUILEforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for I\n-    private int cmoveULEQforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private int cmoveULNEforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private int cmoveULGTforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private int cmoveULGEforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private int cmoveULLTforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private int cmoveULLEforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for L\n-    private long cmoveULEQforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private long cmoveULNEforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private long cmoveULGTforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private long cmoveULGEforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private long cmoveULLTforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private long cmoveULLEforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for F\n-    private float cmoveULEQforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private float cmoveULNEforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private float cmoveULGTforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private float cmoveULGEforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private float cmoveULLTforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private float cmoveULLEforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for D\n-    private double cmoveULEQforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private double cmoveULNEforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private double cmoveULGTforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private double cmoveULGEforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private double cmoveULLTforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private double cmoveULLEforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/ Float comparison\n-    private int cmoveFGTforI(float a, float b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveFGTforL(float a, float b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveFGTforF(float a, float b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveFGTforD(float a, float b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private int cmoveDGTforI(double a, double b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveDGTforL(double a, double b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveDGTforF(double a, double b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveDGTforD(double a, double b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    \/\/ Compare 2 values, and pick one of them\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveVFGT(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] > b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveVFGTSwap(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] > a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveVFLT(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] < b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveVFLTSwap(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] < a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveVFEQ(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] == b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveVDLE(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] <= b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveVDLESwap(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] <= a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveVDGE(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] >= b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveVDGESwap(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] >= a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveVDNE(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] != b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    \/\/ Extensions: compare 2 values, and pick from 2 consts\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFGTforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] > b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFGEforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] >= b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFLTforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] < b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFLEforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] <= b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFEQforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] == b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFNEQforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] != b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFLTforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] < b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] < b[i+1]) ? 0.1f : -0.1f;\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n-            \/\/ -> vectorize                                         -> no vectorization\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFLEforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n-            \/\/ -> vectorize                                         -> no vectorization\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"=0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \"=0\",\n-                  IRNode.VECTOR_BLEND_F, \"=0\",\n-                  IRNode.STORE_VECTOR, \"=0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFYYforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"=0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \"=0\",\n-                  IRNode.VECTOR_BLEND_F, \"=0\",\n-                  IRNode.STORE_VECTOR, \"=0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFXXforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDGTforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] > b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDGEforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] >= b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDLTforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] < b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDLEforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] <= b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDEQforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] == b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDNEQforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] != b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDLTforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] < b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] < b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDLEforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"=0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \"=0\",\n-                  IRNode.VECTOR_BLEND_D, \"=0\",\n-                  IRNode.STORE_VECTOR, \"=0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDYYforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"=0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \"=0\",\n-                  IRNode.VECTOR_BLEND_D, \"=0\",\n-                  IRNode.STORE_VECTOR, \"=0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDXXforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n-    \/\/ Note:\n-    \/\/   To guarantee that CMove is introduced, I need to perform the loads before the branch. To ensure they\n-    \/\/   do not float down into the branches, I compute a value, and store it to r2 (same as r, except that the\n-    \/\/   compilation does not know that).\n-    \/\/   So far, vectorization only works for CMoveF\/D, with same data-width comparison (F\/I for F, D\/L for D).\n-    \/\/ Signed comparison: I\/L\n-    \/\/     I fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo F\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo D\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo F\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo D\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/ Unsigned comparison: I\/L\n-    \/\/     I fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo F\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveUIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveUINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveUIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveUILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveUILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo D\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo F\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo D\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveFGTforI(float[] a, float[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveFGTforL(float[] a, float[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFGTforF(float[] a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveFGTforD(float[] a, float[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveDGTforI(double[] a, double[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveDGTforL(double[] a, double[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveDGTforF(double[] a, double[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveDGTforD(double[] a, double[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/ Use some constants in the comparison\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFGTforFCmpCon1(float a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < b.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveFGTforFCmpCon2(float[] a, float b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/ A case that is currently not supported and is not expected to vectorize\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveVDUnsupported() {\n-        double[] doublec = new double[SIZE];\n-        int seed = 1001;\n-        for (int i = 0; i < doublec.length; i++) {\n-            doublec[i] = (i % 2 == 0) ? seed + i : seed - i;\n-        }\n-    }\n-\n-    @Warmup(0)\n-    @Run(test = {\"testCMoveVFGT\", \"testCMoveVFLT\",\"testCMoveVDLE\", \"testCMoveVDGE\", \"testCMoveVFEQ\", \"testCMoveVDNE\",\n-                 \"testCMoveVFGTSwap\", \"testCMoveVFLTSwap\",\"testCMoveVDLESwap\", \"testCMoveVDGESwap\",\n-                 \"testCMoveFGTforFConst\", \"testCMoveFGEforFConst\", \"testCMoveFLTforFConst\",\n-                 \"testCMoveFLEforFConst\", \"testCMoveFEQforFConst\", \"testCMoveFNEQforFConst\",\n-                 \"testCMoveDGTforDConst\", \"testCMoveDGEforDConst\", \"testCMoveDLTforDConst\",\n-                 \"testCMoveDLEforDConst\", \"testCMoveDEQforDConst\", \"testCMoveDNEQforDConst\",\n-                 \"testCMoveFLTforFConstH2\", \"testCMoveFLEforFConstH2\",\n-                 \"testCMoveFYYforFConstH2\", \"testCMoveFXXforFConstH2\",\n-                 \"testCMoveDLTforDConstH2\", \"testCMoveDLEforDConstH2\",\n-                 \"testCMoveDYYforDConstH2\", \"testCMoveDXXforDConstH2\"})\n-    private void testCMove_runner() {\n-        float[] floata = new float[SIZE];\n-        float[] floatb = new float[SIZE];\n-        float[] floatc = new float[SIZE];\n-        double[] doublea = new double[SIZE];\n-        double[] doubleb = new double[SIZE];\n-        double[] doublec = new double[SIZE];\n-\n-        init(floata);\n-        init(floatb);\n-        init(doublea);\n-        init(doubleb);\n-\n-        testCMoveVFGT(floata, floatb, floatc);\n-        testCMoveVDLE(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatGT(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleLE(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveVFLT(floata, floatb, floatc);\n-        testCMoveVDGE(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatLT(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleGE(doublea[i], doubleb[i]));\n-        }\n-\n-        \/\/ Ensure we frequently have equals\n-        for (int i = 0; i < SIZE; i++) {\n-            if (i % 3 == 0) {\n-                floatb[i] = floata[i];\n-                doubleb[i] = doublea[i];\n-            }\n-        }\n-\n-        testCMoveVFEQ(floata, floatb, floatc);\n-        testCMoveVDNE(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatEQ(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleNE(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveVFGTSwap(floata, floatb, floatc);\n-        testCMoveVDLESwap(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatGTSwap(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleLESwap(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveVFLTSwap(floata, floatb, floatc);\n-        testCMoveVDGESwap(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatLTSwap(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleGESwap(doublea[i], doubleb[i]));\n-        }\n-\n-        \/\/ Extensions: compare 2 values, and pick from 2 consts\n-        testCMoveFGTforFConst(floata, floatb, floatc);\n-        testCMoveDGTforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFGTforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDGTforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFGEforFConst(floata, floatb, floatc);\n-        testCMoveDGEforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFGEforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDGEforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFLTforFConst(floata, floatb, floatc);\n-        testCMoveDLTforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFLEforFConst(floata, floatb, floatc);\n-        testCMoveDLEforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFEQforFConst(floata, floatb, floatc);\n-        testCMoveDEQforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFEQforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDEQforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFNEQforFConst(floata, floatb, floatc);\n-        testCMoveDNEQforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFNEQforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDNEQforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        \/\/ Hand-unrolled (H2) examples:\n-        testCMoveFLTforFConstH2(floata, floatb, floatc);\n-        testCMoveDLTforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFLEforFConstH2(floata, floatb, floatc);\n-        testCMoveDLEforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFYYforFConstH2(floata, floatb, floatc);\n-        testCMoveDYYforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i+=2) {\n-            Asserts.assertEquals(floatc[i+0], cmoveFLEforFConst(floata[i+0], floatb[i+0]));\n-            Asserts.assertEquals(doublec[i+0], cmoveDLEforDConst(doublea[i+0], doubleb[i+0]));\n-            Asserts.assertEquals(floatc[i+1], cmoveFLTforFConst(floata[i+1], floatb[i+1]));\n-            Asserts.assertEquals(doublec[i+1], cmoveDLTforDConst(doublea[i+1], doubleb[i+1]));\n-        }\n-\n-        testCMoveFXXforFConstH2(floata, floatb, floatc);\n-        testCMoveDXXforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i+=2) {\n-            Asserts.assertEquals(floatc[i+0], cmoveFLTforFConst(floata[i+0], floatb[i+0]));\n-            Asserts.assertEquals(doublec[i+0], cmoveDLTforDConst(doublea[i+0], doubleb[i+0]));\n-            Asserts.assertEquals(floatc[i+1], cmoveFLEforFConst(floata[i+1], floatb[i+1]));\n-            Asserts.assertEquals(doublec[i+1], cmoveDLEforDConst(doublea[i+1], doubleb[i+1]));\n-        }\n-    }\n-\n-    @Warmup(0)\n-    @Run(test = {\/\/ Signed\n-                 \/\/     I for I\n-                 \"testCMoveIEQforI\",\n-                 \"testCMoveINEforI\",\n-                 \"testCMoveIGTforI\",\n-                 \"testCMoveIGEforI\",\n-                 \"testCMoveILTforI\",\n-                 \"testCMoveILEforI\",\n-                 \/\/     I for L\n-                 \"testCMoveIEQforL\",\n-                 \"testCMoveINEforL\",\n-                 \"testCMoveIGTforL\",\n-                 \"testCMoveIGEforL\",\n-                 \"testCMoveILTforL\",\n-                 \"testCMoveILEforL\",\n-                 \/\/     I for F\n-                 \"testCMoveIEQforF\",\n-                 \"testCMoveINEforF\",\n-                 \"testCMoveIGTforF\",\n-                 \"testCMoveIGEforF\",\n-                 \"testCMoveILTforF\",\n-                 \"testCMoveILEforF\",\n-                 \/\/     I for D\n-                 \"testCMoveIEQforD\",\n-                 \"testCMoveINEforD\",\n-                 \"testCMoveIGTforD\",\n-                 \"testCMoveIGEforD\",\n-                 \"testCMoveILTforD\",\n-                 \"testCMoveILEforD\",\n-                 \/\/     L for I\n-                 \"testCMoveLEQforI\",\n-                 \"testCMoveLNEforI\",\n-                 \"testCMoveLGTforI\",\n-                 \"testCMoveLGEforI\",\n-                 \"testCMoveLLTforI\",\n-                 \"testCMoveLLEforI\",\n-                 \/\/     L for L\n-                 \"testCMoveLEQforL\",\n-                 \"testCMoveLNEforL\",\n-                 \"testCMoveLGTforL\",\n-                 \"testCMoveLGEforL\",\n-                 \"testCMoveLLTforL\",\n-                 \"testCMoveLLEforL\",\n-                 \/\/     L for F\n-                 \"testCMoveLEQforF\",\n-                 \"testCMoveLNEforF\",\n-                 \"testCMoveLGTforF\",\n-                 \"testCMoveLGEforF\",\n-                 \"testCMoveLLTforF\",\n-                 \"testCMoveLLEforF\",\n-                 \/\/     L for D\n-                 \"testCMoveLEQforD\",\n-                 \"testCMoveLNEforD\",\n-                 \"testCMoveLGTforD\",\n-                 \"testCMoveLGEforD\",\n-                 \"testCMoveLLTforD\",\n-                 \"testCMoveLLEforD\",\n-                 \/\/ Unsigned\n-                 \/\/     I for I\n-                 \"testCMoveUIEQforI\",\n-                 \"testCMoveUINEforI\",\n-                 \"testCMoveUIGTforI\",\n-                 \"testCMoveUIGEforI\",\n-                 \"testCMoveUILTforI\",\n-                 \"testCMoveUILEforI\",\n-                 \/\/     I for L\n-                 \"testCMoveUIEQforL\",\n-                 \"testCMoveUINEforL\",\n-                 \"testCMoveUIGTforL\",\n-                 \"testCMoveUIGEforL\",\n-                 \"testCMoveUILTforL\",\n-                 \"testCMoveUILEforL\",\n-                 \/\/     I for F\n-                 \"testCMoveUIEQforF\",\n-                 \"testCMoveUINEforF\",\n-                 \"testCMoveUIGTforF\",\n-                 \"testCMoveUIGEforF\",\n-                 \"testCMoveUILTforF\",\n-                 \"testCMoveUILEforF\",\n-                 \/\/     I for D\n-                 \"testCMoveUIEQforD\",\n-                 \"testCMoveUINEforD\",\n-                 \"testCMoveUIGTforD\",\n-                 \"testCMoveUIGEforD\",\n-                 \"testCMoveUILTforD\",\n-                 \"testCMoveUILEforD\",\n-                 \/\/     L for I\n-                 \"testCMoveULEQforI\",\n-                 \"testCMoveULNEforI\",\n-                 \"testCMoveULGTforI\",\n-                 \"testCMoveULGEforI\",\n-                 \"testCMoveULLTforI\",\n-                 \"testCMoveULLEforI\",\n-                 \/\/     L for L\n-                 \"testCMoveULEQforL\",\n-                 \"testCMoveULNEforL\",\n-                 \"testCMoveULGTforL\",\n-                 \"testCMoveULGEforL\",\n-                 \"testCMoveULLTforL\",\n-                 \"testCMoveULLEforL\",\n-                 \/\/     L for F\n-                 \"testCMoveULEQforF\",\n-                 \"testCMoveULNEforF\",\n-                 \"testCMoveULGTforF\",\n-                 \"testCMoveULGEforF\",\n-                 \"testCMoveULLTforF\",\n-                 \"testCMoveULLEforF\",\n-                 \/\/     L for D\n-                 \"testCMoveULEQforD\",\n-                 \"testCMoveULNEforD\",\n-                 \"testCMoveULGTforD\",\n-                 \"testCMoveULGEforD\",\n-                 \"testCMoveULLTforD\",\n-                 \"testCMoveULLEforD\",\n-                 \/\/ Float\n-                 \"testCMoveFGTforI\",\n-                 \"testCMoveFGTforL\",\n-                 \"testCMoveFGTforF\",\n-                 \"testCMoveFGTforD\",\n-                 \"testCMoveDGTforI\",\n-                 \"testCMoveDGTforL\",\n-                 \"testCMoveDGTforF\",\n-                 \"testCMoveDGTforD\",\n-                 \"testCMoveFGTforFCmpCon1\",\n-                 \"testCMoveFGTforFCmpCon2\"})\n-    private void testCMove_runner_two() {\n-        int[] aI = new int[SIZE];\n-        int[] bI = new int[SIZE];\n-        int[] cI = new int[SIZE];\n-        int[] dI = new int[SIZE];\n-        int[] rI = new int[SIZE];\n-        long[] aL = new long[SIZE];\n-        long[] bL = new long[SIZE];\n-        long[] cL = new long[SIZE];\n-        long[] dL = new long[SIZE];\n-        long[] rL = new long[SIZE];\n-        float[] aF = new float[SIZE];\n-        float[] bF = new float[SIZE];\n-        float[] cF = new float[SIZE];\n-        float[] dF = new float[SIZE];\n-        float[] rF = new float[SIZE];\n-        double[] aD = new double[SIZE];\n-        double[] bD = new double[SIZE];\n-        double[] cD = new double[SIZE];\n-        double[] dD = new double[SIZE];\n-        double[] rD = new double[SIZE];\n-\n-        init(aI);\n-        init(bI);\n-        init(cI);\n-        init(dI);\n-        init(aL);\n-        init(bL);\n-        init(cL);\n-        init(dL);\n-        init(aF);\n-        init(bF);\n-        init(cF);\n-        init(dF);\n-        init(aD);\n-        init(bD);\n-        init(cD);\n-        init(dD);\n-\n-        \/\/ Signed\n-        \/\/     I for I\n-        testCMoveIEQforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveIEQforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveINEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveINEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveIGTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveIGTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveIGEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveIGEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveILTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveILTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveILEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveILEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     I for L\n-        testCMoveIEQforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveIEQforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveINEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveINEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveIGTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveIGTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveIGEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveIGEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveILTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveILTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveILEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveILEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     I for F\n-        testCMoveIEQforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveIEQforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveINEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveINEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveIGTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveIGTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveIGEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveIGEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveILTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveILTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveILEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveILEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     I for D\n-        testCMoveIEQforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveIEQforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveINEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveINEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveIGTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveIGTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveIGEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveIGEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveILTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveILTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveILEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveILEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/     L for I\n-        testCMoveLEQforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLEQforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLNEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLNEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLGTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLGTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLGEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLGEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLLTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLLTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLLEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLLEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     L for L\n-        testCMoveLEQforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLEQforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLNEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLNEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLGTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLGTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLGEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLGEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLLTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLLTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLLEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLLEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     L for F\n-        testCMoveLEQforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLEQforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLNEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLNEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLGTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLGTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLGEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLGEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLLTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLLTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLLEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLLEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     L for D\n-        testCMoveLEQforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLEQforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLNEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLNEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLGTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLGTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLGEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLGEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLLTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLLTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLLEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLLEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/ Unsigned\n-        \/\/     I for I\n-        testCMoveUIEQforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUIEQforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUINEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUINEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUIGTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUIGTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUIGEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUIGEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUILTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUILTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUILEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUILEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     I for L\n-        testCMoveUIEQforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUIEQforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUINEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUINEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUIGTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUIGTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUIGEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUIGEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUILTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUILTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUILEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUILEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     I for F\n-        testCMoveUIEQforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUIEQforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUINEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUINEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUIGTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUIGTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUIGEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUIGEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUILTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUILTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUILEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUILEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     I for D\n-        testCMoveUIEQforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUIEQforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUINEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUINEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUIGTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUIGTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUIGEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUIGEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUILTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUILTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUILEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUILEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/     L for I\n-        testCMoveULEQforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULEQforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULNEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULNEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULGTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULGTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULGEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULGEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULLTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULLTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULLEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULLEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     L for L\n-        testCMoveULEQforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULEQforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULNEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULNEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULGTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULGTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULGEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULGEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULLTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULLTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULLEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULLEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     L for F\n-        testCMoveULEQforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULEQforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULNEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULNEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULGTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULGTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULGEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULGEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULLTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULLTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULLEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULLEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     L for D\n-        testCMoveULEQforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULEQforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULNEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULNEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULGTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULGTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULGEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULGEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULLTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULLTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULLEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULLEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/ Float\n-        testCMoveFGTforI(aF, bF, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveFGTforI(aF[i], bF[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveFGTforL(aF, bF, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveFGTforL(aF[i], bF[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveFGTforF(aF, bF, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveFGTforD(aF, bF, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveFGTforD(aF[i], bF[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveDGTforI(aD, bD, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveDGTforI(aD[i], bD[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveDGTforL(aD, bD, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveDGTforL(aD[i], bD[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveDGTforF(aD, bD, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveDGTforF(aD[i], bD[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveDGTforD(aD, bD, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveDGTforD(aD[i], bD[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/ Use some constants\/invariants in the comparison\n-        testCMoveFGTforFCmpCon1(aF[0], bF, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[0], bF[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveFGTforFCmpCon2(aF, bF[0], cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[0], cF[i], dF[i]));\n-        }\n-    }\n-\n-    private static void init(int[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = RANDOM.nextInt();\n-        }\n-    }\n-\n-    private static void init(long[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = RANDOM.nextLong();\n-        }\n-    }\n-\n-    private static void init(float[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = switch(RANDOM.nextInt() % 20) {\n-                case 0  -> Float.NaN;\n-                case 1  -> 0;\n-                case 2  -> 1;\n-                case 3  -> Float.POSITIVE_INFINITY;\n-                case 4  -> Float.NEGATIVE_INFINITY;\n-                case 5  -> Float.MAX_VALUE;\n-                case 6  -> Float.MIN_VALUE;\n-                case 7, 8, 9 -> RANDOM.nextFloat();\n-                default -> Float.intBitsToFloat(RANDOM.nextInt());\n-            };\n-        }\n-    }\n-\n-    private static void init(double[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = switch(RANDOM.nextInt() % 20) {\n-                case 0  -> Double.NaN;\n-                case 1  -> 0;\n-                case 2  -> 1;\n-                case 3  -> Double.POSITIVE_INFINITY;\n-                case 4  -> Double.NEGATIVE_INFINITY;\n-                case 5  -> Double.MAX_VALUE;\n-                case 6  -> Double.MIN_VALUE;\n-                case 7, 8, 9 -> RANDOM.nextDouble();\n-                default -> Double.longBitsToDouble(RANDOM.nextLong());\n-            };\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":0,"deletions":3216,"binary":false,"changes":3216,"status":"deleted"},{"patch":"@@ -548,0 +548,10 @@\n+    public static final String CMOVE_F = PREFIX + \"CMOVE_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_F, \"CMoveF\");\n+    }\n+\n+    public static final String CMOVE_D = PREFIX + \"CMOVE_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_D, \"CMoveD\");\n+    }\n+\n@@ -553,0 +563,15 @@\n+    public static final String CMOVE_L = PREFIX + \"CMOVE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_L, \"CMoveL\");\n+    }\n+\n+    public static final String CMP_F = PREFIX + \"CMP_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_F, \"CmpF\");\n+    }\n+\n+    public static final String CMP_D = PREFIX + \"CMP_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_D, \"CmpD\");\n+    }\n+\n@@ -588,0 +613,5 @@\n+    public static final String CMP_N = PREFIX + \"CMP_N\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_N, \"CmpN\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -47,6 +47,2 @@\n-    Object[] resObject;\n-    Object ro1;\n-    Object ro2;\n-    Object[] resClass;\n-    Class rc1;\n-    Class rc2;\n+    float[] resFloat;\n+    double[] resDouble;\n@@ -61,6 +57,2 @@\n-        resObject = new Object[INVOCATIONS];\n-        ro1 = new Object();\n-        ro2 = new Object();\n-        resClass = new Class[INVOCATIONS];\n-        rc1 = Float.class;\n-        rc2 = Double.class;\n+        resFloat = new float[INVOCATIONS];\n+        resDouble = new double[INVOCATIONS];\n@@ -89,0 +81,1 @@\n+    @Benchmark\n@@ -101,0 +94,28 @@\n+\n+    @Benchmark\n+    public void equalClassResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (c1[i] == c2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualClassResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (c1[i] != c2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalClassResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (c1[i] == c2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualClassResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (c1[i] != c2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ClassComparison.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -40,12 +40,8 @@\n-    float[] f1;\n-    double[] d1;\n-    float[] f2;\n-    double[] d2;\n-    int[] res;\n-    long[] resLong;\n-    Object[] resObject;\n-    Object ro1;\n-    Object ro2;\n-    Class[] resClass;\n-    Class rc1;\n-    Class rc2;\n+    static final float[] f1 = new float[INVOCATIONS];\n+    static final double[] d1 = new double[INVOCATIONS];\n+    static final float[] f2 = new float[INVOCATIONS];\n+    static final double[] d2 = new double[INVOCATIONS];\n+    static final int[] res = new int[INVOCATIONS];;\n+    static final long[] resLong = new long[INVOCATIONS];\n+    static final float[] resFloat = new float[INVOCATIONS];\n+    static final double[] resDouble = new double[INVOCATIONS];\n@@ -56,12 +52,0 @@\n-        f1 = new float[INVOCATIONS];\n-        d1 = new double[INVOCATIONS];\n-        f2 = new float[INVOCATIONS];\n-        d2 = new double[INVOCATIONS];\n-        res = new int[INVOCATIONS];\n-        resLong = new long[INVOCATIONS];\n-        resObject = new Object[INVOCATIONS];\n-        ro1 = new Object();\n-        ro2 = new Object();\n-        resClass = new Class[INVOCATIONS];\n-        rc1 = Float.class;\n-        rc2 = Double.class;\n@@ -277,0 +261,144 @@\n+\n+    \/\/ --------- result: float ---------\n+\n+    @Benchmark\n+    public void equalFloatResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (f1[i] == f2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalDoubleResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (d1[i] == d2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessFloatResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (f1[i] < f2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessDoubleResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (d1[i] < d2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualFloatResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (f1[i] <= f2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualDoubleResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (d1[i] <= d2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterFloatResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (f1[i] > f2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterDoubleResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (d1[i] > d2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualFloatResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (f1[i] >= f2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualDoubleResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (d1[i] >= d2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    \/\/ --------- result: double ---------\n+\n+    @Benchmark\n+    public void equalFloatResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (f1[i] == f2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalDoubleResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (d1[i] == d2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessFloatResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (f1[i] < f2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessDoubleResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (d1[i] < d2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualFloatResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (f1[i] <= f2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualDoubleResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (d1[i] <= d2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterFloatResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (f1[i] > f2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterDoubleResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (d1[i] > d2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualFloatResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (f1[i] >= f2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualDoubleResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (d1[i] >= d2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FPComparison.java","additions":152,"deletions":24,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -45,6 +45,2 @@\n-    Object[] resObject;\n-    Object ro1;\n-    Object ro2;\n-    Object[] resClass;\n-    Class rc1;\n-    Class rc2;\n+    float[] resFloat;\n+    double[] resDouble;\n@@ -59,6 +55,2 @@\n-        resObject = new Object[INVOCATIONS];\n-        ro1 = new Object();\n-        ro2 = new Object();\n-        resClass = new Class[INVOCATIONS];\n-        rc1 = Float.class;\n-        rc2 = Double.class;\n+        resFloat = new float[INVOCATIONS];\n+        resDouble = new double[INVOCATIONS];\n@@ -71,0 +63,3 @@\n+    \/\/ --------- result: int ---------\n+    \/\/      Signed comparison\n+\n@@ -113,0 +108,45 @@\n+    \/\/      Unsigned comparison\n+\n+    @Benchmark\n+    public void equalIntegerUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Integer.compareUnsigned(i1[i], i2[i]) == 0 ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualIntegerUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Integer.compareUnsigned(i1[i], i2[i]) != 0 ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessIntegerUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Integer.compareUnsigned(i1[i], i2[i]) < 0 ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualIntegerUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Integer.compareUnsigned(i1[i], i2[i]) <= 0 ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterIntegerUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Integer.compareUnsigned(i1[i], i2[i]) > 0 ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualIntegerUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Integer.compareUnsigned(i1[i], i2[i]) >= 0 ? 1 : 2;\n+        }\n+    }\n+\n+\n@@ -114,0 +154,1 @@\n+    \/\/      Signed comparison\n@@ -115,0 +156,1 @@\n+    @Benchmark\n@@ -128,0 +170,1 @@\n+    @Benchmark\n@@ -141,0 +184,1 @@\n+    @Benchmark\n@@ -153,0 +197,222 @@\n+\n+    \/\/      Unsigned comparison\n+\n+    @Benchmark\n+    public void equalIntegerUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Integer.compareUnsigned(i1[i], i2[i]) == 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualIntegerUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Integer.compareUnsigned(i1[i], i2[i]) != 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessIntegerUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Integer.compareUnsigned(i1[i], i2[i]) < 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualIntegerUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Integer.compareUnsigned(i1[i], i2[i]) <= 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterIntegerUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Integer.compareUnsigned(i1[i], i2[i]) > 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualIntegerUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Integer.compareUnsigned(i1[i], i2[i]) >= 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    \/\/ --------- result: float ---------\n+    \/\/      Signed comparison\n+\n+    @Benchmark\n+    public void equalIntegerResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (i1[i] == i2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualIntegerResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (i1[i] != i2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessIntegerResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (i1[i] < i2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualIntegerResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (i1[i] <= i2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterIntegerResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (i1[i] > i2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualIntegerResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (i1[i] >= i2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    \/\/      Unsigned comparison\n+\n+    @Benchmark\n+    public void equalIntegerUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Integer.compareUnsigned(i1[i], i2[i]) == 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualIntegerUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Integer.compareUnsigned(i1[i], i2[i]) != 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessIntegerUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Integer.compareUnsigned(i1[i], i2[i]) < 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualIntegerUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Integer.compareUnsigned(i1[i], i2[i]) <= 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterIntegerUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Integer.compareUnsigned(i1[i], i2[i]) > 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualIntegerUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Integer.compareUnsigned(i1[i], i2[i]) >= 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    \/\/ --------- result: double ---------\n+    \/\/      Signed comparison\n+\n+    @Benchmark\n+    public void equalIntegerResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (i1[i] == i2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualIntegerResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (i1[i] != i2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessIntegerResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (i1[i] < i2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualIntegerResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (i1[i] <= i2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterIntegerResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (i1[i] > i2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualIntegerResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (i1[i] >= i2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    \/\/      Unsigned comparison\n+\n+    @Benchmark\n+    public void equalIntegerUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Integer.compareUnsigned(i1[i], i2[i]) == 0 ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualIntegerUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Integer.compareUnsigned(i1[i], i2[i]) != 0 ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessIntegerUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Integer.compareUnsigned(i1[i], i2[i]) < 0 ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualIntegerUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Integer.compareUnsigned(i1[i], i2[i]) <= 0 ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterIntegerUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Integer.compareUnsigned(i1[i], i2[i]) > 0 ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualIntegerUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Integer.compareUnsigned(i1[i], i2[i]) >= 0 ? 0.1 : 0.2;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerComparison.java","additions":278,"deletions":12,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -44,6 +44,2 @@\n-    Object[] resObject;\n-    Object ro1;\n-    Object ro2;\n-    Object[] resClass;\n-    Class rc1;\n-    Class rc2;\n+    float[] resFloat;\n+    double[] resDouble;\n@@ -58,6 +54,2 @@\n-        resObject = new Object[INVOCATIONS];\n-        ro1 = new Object();\n-        ro2 = new Object();\n-        resClass = new Class[INVOCATIONS];\n-        rc1 = Float.class;\n-        rc2 = Double.class;\n+        resFloat = new float[INVOCATIONS];\n+        resDouble = new double[INVOCATIONS];\n@@ -70,0 +62,3 @@\n+    \/\/ --------- result: int ---------\n+    \/\/      Signed comparison\n+\n@@ -112,0 +107,44 @@\n+    \/\/      Unsigned comparison\n+\n+    @Benchmark\n+    public void equalLongUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Long.compareUnsigned(l1[i], l2[i]) == 0 ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualLongUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Long.compareUnsigned(l1[i], l2[i]) != 0 ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessLongUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Long.compareUnsigned(l1[i], l2[i]) < 0 ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualLongUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Long.compareUnsigned(l1[i], l2[i]) <= 0 ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterLongUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Long.compareUnsigned(l1[i], l2[i]) > 0 ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualLongUnsigned() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Long.compareUnsigned(l1[i], l2[i]) >= 0 ? 1 : 2;\n+        }\n+    }\n+\n@@ -113,0 +152,1 @@\n+    \/\/      Signed comparison\n@@ -114,0 +154,1 @@\n+    @Benchmark\n@@ -127,0 +168,1 @@\n+    @Benchmark\n@@ -140,0 +182,1 @@\n+    @Benchmark\n@@ -152,0 +195,222 @@\n+\n+    \/\/      Unsigned comparison\n+\n+    @Benchmark\n+    public void equalLongUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Long.compareUnsigned(l1[i], l2[i]) == 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualLongUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Long.compareUnsigned(l1[i], l2[i]) != 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessLongUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Long.compareUnsigned(l1[i], l2[i]) < 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualLongUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Long.compareUnsigned(l1[i], l2[i]) <= 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterLongUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Long.compareUnsigned(l1[i], l2[i]) > 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualLongUnsignedResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = Long.compareUnsigned(l1[i], l2[i]) >= 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    \/\/ --------- result: float ---------\n+    \/\/      Signed comparison\n+\n+    @Benchmark\n+    public void equalLongResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (l1[i] == l2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualLongResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (l1[i] != l2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessLongResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (l1[i] < l2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualLongResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (l1[i] <= l2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterLongResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (l1[i] > l2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualLongResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (l1[i] >= l2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    \/\/      Unsigned comparison\n+\n+    @Benchmark\n+    public void equalLongUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Long.compareUnsigned(l1[i], l2[i]) == 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualLongUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Long.compareUnsigned(l1[i], l2[i]) != 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessLongUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Long.compareUnsigned(l1[i], l2[i]) < 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualLongUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Long.compareUnsigned(l1[i], l2[i]) <= 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterLongUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Long.compareUnsigned(l1[i], l2[i]) > 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualLongUnsignedResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = Long.compareUnsigned(l1[i], l2[i]) >= 0 ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    \/\/ --------- result: double ---------\n+    \/\/      Signed comparison\n+\n+    @Benchmark\n+    public void equalLongResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (l1[i] == l2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualLongResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (l1[i] != l2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessLongResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (l1[i] < l2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualLongResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (l1[i] <= l2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterLongResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (l1[i] > l2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualLongResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (l1[i] >= l2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    \/\/      Unsigned comparison\n+\n+    @Benchmark\n+    public void equalLongUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Long.compareUnsigned(l1[i], l2[i]) == 0 ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualLongUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Long.compareUnsigned(l1[i], l2[i]) != 0 ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessLongUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Long.compareUnsigned(l1[i], l2[i]) < 0 ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualLongUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Long.compareUnsigned(l1[i], l2[i]) <= 0 ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterLongUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Long.compareUnsigned(l1[i], l2[i]) > 0 ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualLongUnsignedResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = Long.compareUnsigned(l1[i], l2[i]) >= 0 ? 0.1 : 0.2;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongComparison.java","additions":277,"deletions":12,"binary":false,"changes":289,"status":"modified"},{"patch":"@@ -47,6 +47,2 @@\n-    Object[] resObject;\n-    Object ro1;\n-    Object ro2;\n-    Object[] resClass;\n-    Class rc1;\n-    Class rc2;\n+    float[] resFloat;\n+    double[] resDouble;\n@@ -61,6 +57,2 @@\n-        resObject = new Object[INVOCATIONS];\n-        ro1 = new Object();\n-        ro2 = new Object();\n-        resClass = new Class[INVOCATIONS];\n-        rc1 = Float.class;\n-        rc2 = Double.class;\n+        resFloat = new float[INVOCATIONS];\n+        resDouble = new double[INVOCATIONS];\n@@ -89,0 +81,1 @@\n+    @Benchmark\n@@ -101,0 +94,28 @@\n+\n+    @Benchmark\n+    public void equalObjecResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (o1[i] == o2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualObjecResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (o1[i] != o2[i]) ? 0.1f : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalObjecResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (o1[i] == o2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualObjecResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (o1[i] != o2[i]) ? 0.1 : 0.2;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/PointerComparison.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"}]}