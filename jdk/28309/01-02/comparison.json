{"files":[{"patch":"@@ -0,0 +1,3819 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Arm Limited. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8289422 8306088 8313720\n+ * @key randomness\n+ * @summary Auto-vectorization enhancement to support vector conditional move.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestConditionalMove\n+ *\/\n+\n+public class TestConditionalMove {\n+    final private static int SIZE = 1024;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        \/\/ Vectorizaion: +UseCMoveUnconditionally, +UseVectorCmov\n+        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+\n+        \/\/ Scalar: +UseCMoveUnconditionally, -UseVectorCmov\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\");\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n+                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\");\n+    }\n+\n+    \/\/ Compare 2 values, and pick one of them\n+    private float cmoveFloatGT(float a, float b) {\n+        return (a > b) ? a : b;\n+    }\n+\n+    private float cmoveFloatGTSwap(float a, float b) {\n+        return (b > a) ? a : b;\n+    }\n+\n+    private float cmoveFloatLT(float a, float b) {\n+        return (a < b) ? a : b;\n+    }\n+\n+    private float cmoveFloatLTSwap(float a, float b) {\n+        return (b < a) ? a : b;\n+    }\n+\n+    private float cmoveFloatEQ(float a, float b) {\n+        return (a == b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleLE(double a, double b) {\n+        return (a <= b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleLESwap(double a, double b) {\n+        return (b <= a) ? a : b;\n+    }\n+\n+    private double cmoveDoubleGE(double a, double b) {\n+        return (a >= b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleGESwap(double a, double b) {\n+        return (b >= a) ? a : b;\n+    }\n+\n+    private double cmoveDoubleNE(double a, double b) {\n+        return (a != b) ? a : b;\n+    }\n+\n+    \/\/ Extensions: compare 2 values, and pick from 2 consts\n+    private float cmoveFGTforFConst(float a, float b) {\n+        return (a > b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFGEforFConst(float a, float b) {\n+        return (a >= b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFLTforFConst(float a, float b) {\n+        return (a < b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFLEforFConst(float a, float b) {\n+        return (a <= b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFEQforFConst(float a, float b) {\n+        return (a == b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFNEQforFConst(float a, float b) {\n+        return (a != b) ? 0.1f : -0.1f;\n+    }\n+\n+    private double cmoveDGTforDConst(double a, double b) {\n+        return (a > b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDGEforDConst(double a, double b) {\n+        return (a >= b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDLTforDConst(double a, double b) {\n+        return (a < b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDLEforDConst(double a, double b) {\n+        return (a <= b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDEQforDConst(double a, double b) {\n+        return (a == b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDNEQforDConst(double a, double b) {\n+        return (a != b) ? 0.1 : -0.1;\n+    }\n+\n+    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n+    \/\/ Signed comparison: I\/L\n+    \/\/    I for I\n+    private int cmoveIEQforI(int a, int b, int c, int d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private int cmoveINEforI(int a, int b, int c, int d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private int cmoveIGTforI(int a, int b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private int cmoveIGEforI(int a, int b, int c, int d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private int cmoveILTforI(int a, int b, int c, int d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private int cmoveILEforI(int a, int b, int c, int d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for L\n+    private long cmoveIEQforL(int a, int b, long c, long d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private long cmoveINEforL(int a, int b, long c, long d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private long cmoveIGTforL(int a, int b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveIGEforL(int a, int b, long c, long d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private long cmoveILTforL(int a, int b, long c, long d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private long cmoveILEforL(int a, int b, long c, long d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for F\n+    private float cmoveIEQforF(int a, int b, float c, float d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private float cmoveINEforF(int a, int b, float c, float d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private float cmoveIGTforF(int a, int b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveIGEforF(int a, int b, float c, float d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private float cmoveILTforF(int a, int b, float c, float d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private float cmoveILEforF(int a, int b, float c, float d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for D\n+    private double cmoveIEQforD(int a, int b, double c, double d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private double cmoveINEforD(int a, int b, double c, double d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private double cmoveIGTforD(int a, int b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveIGEforD(int a, int b, double c, double d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private double cmoveILTforD(int a, int b, double c, double d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private double cmoveILEforD(int a, int b, double c, double d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for I\n+    private int cmoveLEQforI(long a, long b, int c, int d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private int cmoveLNEforI(long a, long b, int c, int d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private int cmoveLGTforI(long a, long b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private int cmoveLGEforI(long a, long b, int c, int d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private int cmoveLLTforI(long a, long b, int c, int d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private int cmoveLLEforI(long a, long b, int c, int d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for L\n+    private long cmoveLEQforL(long a, long b, long c, long d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private long cmoveLNEforL(long a, long b, long c, long d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private long cmoveLGTforL(long a, long b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveLGEforL(long a, long b, long c, long d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private long cmoveLLTforL(long a, long b, long c, long d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private long cmoveLLEforL(long a, long b, long c, long d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for F\n+    private float cmoveLEQforF(long a, long b, float c, float d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private float cmoveLNEforF(long a, long b, float c, float d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private float cmoveLGTforF(long a, long b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveLGEforF(long a, long b, float c, float d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private float cmoveLLTforF(long a, long b, float c, float d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private float cmoveLLEforF(long a, long b, float c, float d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for D\n+    private double cmoveLEQforD(long a, long b, double c, double d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private double cmoveLNEforD(long a, long b, double c, double d) {\n+        return (a != b) ? c : d;\n+    }\n+\n+    private double cmoveLGTforD(long a, long b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveLGEforD(long a, long b, double c, double d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private double cmoveLLTforD(long a, long b, double c, double d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private double cmoveLLEforD(long a, long b, double c, double d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/ Unsigned comparison: I\/L\n+    \/\/    I for I\n+    private int cmoveUIEQforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private int cmoveUINEforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private int cmoveUIGTforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private int cmoveUIGEforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private int cmoveUILTforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private int cmoveUILEforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    I for L\n+    private long cmoveUIEQforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private long cmoveUINEforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private long cmoveUIGTforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private long cmoveUIGEforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private long cmoveUILTforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private long cmoveUILEforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    I for F\n+    private float cmoveUIEQforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private float cmoveUINEforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private float cmoveUIGTforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private float cmoveUIGEforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private float cmoveUILTforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private float cmoveUILEforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    I for D\n+    private double cmoveUIEQforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private double cmoveUINEforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private double cmoveUIGTforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private double cmoveUIGEforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private double cmoveUILTforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private double cmoveUILEforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for I\n+    private int cmoveULEQforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private int cmoveULNEforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private int cmoveULGTforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private int cmoveULGEforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private int cmoveULLTforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private int cmoveULLEforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for L\n+    private long cmoveULEQforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private long cmoveULNEforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private long cmoveULGTforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private long cmoveULGEforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private long cmoveULLTforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private long cmoveULLEforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for F\n+    private float cmoveULEQforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private float cmoveULNEforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private float cmoveULGTforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private float cmoveULGEforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private float cmoveULLTforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private float cmoveULLEforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for D\n+    private double cmoveULEQforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private double cmoveULNEforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n+    private double cmoveULGTforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private double cmoveULGEforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private double cmoveULLTforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private double cmoveULLEforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/ Float comparison\n+    private int cmoveFGTforI(float a, float b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveFGTforL(float a, float b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveFGTforF(float a, float b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveFGTforD(float a, float b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    \/\/ Double comparison\n+    private int cmoveDGTforI(double a, double b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveDGTforL(double a, double b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveDGTforF(double a, double b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveDGTforD(double a, double b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    \/\/ Compare 2 values, and pick one of them\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVFGT(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVFGTSwap(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] > a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVFLT(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVFLTSwap(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] < a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVFEQ(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] == b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVDLE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVDLESwap(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] <= a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVDGE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVDGESwap(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] >= a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveVDNE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] != b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    \/\/ Extensions: compare 2 values, and pick from 2 consts\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGEforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFLTforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFLEforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFEQforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] == b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFNEQforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] != b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfAnd = {\"UseCompactObjectHeaders\", \"false\", \"UseVectorCmov\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                    IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                    IRNode.VECTOR_BLEND_F, \">0\",\n+                    IRNode.STORE_VECTOR, \">0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseVectorCmov\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFLTforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] < b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] < b[i+1]) ? 0.1f : -0.1f;\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n+            \/\/ -> vectorize                                         -> no vectorization\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfAnd = {\"UseCompactObjectHeaders\", \"false\", \"UseVectorCmov\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                    IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                    IRNode.VECTOR_BLEND_F, \">0\",\n+                    IRNode.STORE_VECTOR, \">0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseVectorCmov\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFLEforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n+            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n+            \/\/ -> vectorize                                         -> no vectorization\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \"=0\",\n+                  IRNode.VECTOR_BLEND_F, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFYYforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \"=0\",\n+                  IRNode.VECTOR_BLEND_F, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFXXforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGTforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGEforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDLTforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDLEforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDEQforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] == b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDNEQforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] != b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDLTforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] < b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] < b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDLEforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \"=0\",\n+                  IRNode.VECTOR_BLEND_D, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDYYforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \"=0\",\n+                  IRNode.VECTOR_BLEND_D, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDXXforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n+    \/\/ Note:\n+    \/\/   To guarantee that CMove is introduced, I need to perform the loads before the branch. To ensure they\n+    \/\/   do not float down into the branches, I compute a value, and store it to r2 (same as r, except that the\n+    \/\/   compilation does not know that).\n+    \/\/   So far, vectorization only works for CMoveF\/D, with same data-width comparison (F\/I for F, D\/L for D).\n+    \/\/   TODO: enable CMOVE_I\/L verification when it's guaranteed to generate CMOVE_I\/L, JDK-8371984.\n+    \/\/\n+    \/\/ Signed comparison: I\/L\n+    \/\/     I fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo F\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo D\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo F\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveLLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo D\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ Unsigned comparison: I\/L\n+    \/\/     I fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo F\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+            applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo D\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveUILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo F\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveULLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo D\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_F, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforI(float[] a, float[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_F, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforL(float[] a, float[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforF(float[] a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforD(float[] a, float[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_D, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGTforI(double[] a, double[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_D, \">0\"},\n+    \/\/     applyIf = {\"UseVectorCmov\", \"false\"},\n+    \/\/     applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGTforL(double[] a, double[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGTforF(double[] a, double[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveDGTforD(double[] a, double[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ Use some constants in the comparison\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforFCmpCon1(float a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < b.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIf = {\"UseVectorCmov\", \"true\"})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseVectorCmov\", \"false\"})\n+    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"},\n+        applyIf = {\"UseVectorCmov\", \"false\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"})\n+    private static void testCMoveFGTforFCmpCon2(float[] a, float b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ A case that is currently not supported and is not expected to vectorize\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveVDUnsupported() {\n+        double[] doublec = new double[SIZE];\n+        int seed = 1001;\n+        for (int i = 0; i < doublec.length; i++) {\n+            doublec[i] = (i % 2 == 0) ? seed + i : seed - i;\n+        }\n+    }\n+\n+    @Warmup(0)\n+    @Run(test = {\"testCMoveVFGT\", \"testCMoveVFLT\",\"testCMoveVDLE\", \"testCMoveVDGE\", \"testCMoveVFEQ\", \"testCMoveVDNE\",\n+                 \"testCMoveVFGTSwap\", \"testCMoveVFLTSwap\",\"testCMoveVDLESwap\", \"testCMoveVDGESwap\",\n+                 \"testCMoveFGTforFConst\", \"testCMoveFGEforFConst\", \"testCMoveFLTforFConst\",\n+                 \"testCMoveFLEforFConst\", \"testCMoveFEQforFConst\", \"testCMoveFNEQforFConst\",\n+                 \"testCMoveDGTforDConst\", \"testCMoveDGEforDConst\", \"testCMoveDLTforDConst\",\n+                 \"testCMoveDLEforDConst\", \"testCMoveDEQforDConst\", \"testCMoveDNEQforDConst\",\n+                 \"testCMoveFLTforFConstH2\", \"testCMoveFLEforFConstH2\",\n+                 \"testCMoveFYYforFConstH2\", \"testCMoveFXXforFConstH2\",\n+                 \"testCMoveDLTforDConstH2\", \"testCMoveDLEforDConstH2\",\n+                 \"testCMoveDYYforDConstH2\", \"testCMoveDXXforDConstH2\"})\n+    private void testCMove_runner() {\n+        float[] floata = new float[SIZE];\n+        float[] floatb = new float[SIZE];\n+        float[] floatc = new float[SIZE];\n+        double[] doublea = new double[SIZE];\n+        double[] doubleb = new double[SIZE];\n+        double[] doublec = new double[SIZE];\n+\n+        init(floata);\n+        init(floatb);\n+        init(doublea);\n+        init(doubleb);\n+\n+        testCMoveVFGT(floata, floatb, floatc);\n+        testCMoveVDLE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatGT(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleLE(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFLT(floata, floatb, floatc);\n+        testCMoveVDGE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatLT(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleGE(doublea[i], doubleb[i]));\n+        }\n+\n+        \/\/ Ensure we frequently have equals\n+        for (int i = 0; i < SIZE; i++) {\n+            if (i % 3 == 0) {\n+                floatb[i] = floata[i];\n+                doubleb[i] = doublea[i];\n+            }\n+        }\n+\n+        testCMoveVFEQ(floata, floatb, floatc);\n+        testCMoveVDNE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatEQ(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleNE(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFGTSwap(floata, floatb, floatc);\n+        testCMoveVDLESwap(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatGTSwap(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleLESwap(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFLTSwap(floata, floatb, floatc);\n+        testCMoveVDGESwap(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatLTSwap(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleGESwap(doublea[i], doubleb[i]));\n+        }\n+\n+        \/\/ Extensions: compare 2 values, and pick from 2 consts\n+        testCMoveFGTforFConst(floata, floatb, floatc);\n+        testCMoveDGTforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFGTforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDGTforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFGEforFConst(floata, floatb, floatc);\n+        testCMoveDGEforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFGEforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDGEforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFLTforFConst(floata, floatb, floatc);\n+        testCMoveDLTforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFLEforFConst(floata, floatb, floatc);\n+        testCMoveDLEforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFEQforFConst(floata, floatb, floatc);\n+        testCMoveDEQforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFEQforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDEQforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFNEQforFConst(floata, floatb, floatc);\n+        testCMoveDNEQforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFNEQforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDNEQforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        \/\/ Hand-unrolled (H2) examples:\n+        testCMoveFLTforFConstH2(floata, floatb, floatc);\n+        testCMoveDLTforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFLEforFConstH2(floata, floatb, floatc);\n+        testCMoveDLEforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFYYforFConstH2(floata, floatb, floatc);\n+        testCMoveDYYforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i+=2) {\n+            Asserts.assertEquals(floatc[i+0], cmoveFLEforFConst(floata[i+0], floatb[i+0]));\n+            Asserts.assertEquals(doublec[i+0], cmoveDLEforDConst(doublea[i+0], doubleb[i+0]));\n+            Asserts.assertEquals(floatc[i+1], cmoveFLTforFConst(floata[i+1], floatb[i+1]));\n+            Asserts.assertEquals(doublec[i+1], cmoveDLTforDConst(doublea[i+1], doubleb[i+1]));\n+        }\n+\n+        testCMoveFXXforFConstH2(floata, floatb, floatc);\n+        testCMoveDXXforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i+=2) {\n+            Asserts.assertEquals(floatc[i+0], cmoveFLTforFConst(floata[i+0], floatb[i+0]));\n+            Asserts.assertEquals(doublec[i+0], cmoveDLTforDConst(doublea[i+0], doubleb[i+0]));\n+            Asserts.assertEquals(floatc[i+1], cmoveFLEforFConst(floata[i+1], floatb[i+1]));\n+            Asserts.assertEquals(doublec[i+1], cmoveDLEforDConst(doublea[i+1], doubleb[i+1]));\n+        }\n+    }\n+\n+    @Warmup(0)\n+    @Run(test = {\/\/ Signed\n+                 \/\/     I for I\n+                 \"testCMoveIEQforI\",\n+                 \"testCMoveINEforI\",\n+                 \"testCMoveIGTforI\",\n+                 \"testCMoveIGEforI\",\n+                 \"testCMoveILTforI\",\n+                 \"testCMoveILEforI\",\n+                 \/\/     I for L\n+                 \"testCMoveIEQforL\",\n+                 \"testCMoveINEforL\",\n+                 \"testCMoveIGTforL\",\n+                 \"testCMoveIGEforL\",\n+                 \"testCMoveILTforL\",\n+                 \"testCMoveILEforL\",\n+                 \/\/     I for F\n+                 \"testCMoveIEQforF\",\n+                 \"testCMoveINEforF\",\n+                 \"testCMoveIGTforF\",\n+                 \"testCMoveIGEforF\",\n+                 \"testCMoveILTforF\",\n+                 \"testCMoveILEforF\",\n+                 \/\/     I for D\n+                 \"testCMoveIEQforD\",\n+                 \"testCMoveINEforD\",\n+                 \"testCMoveIGTforD\",\n+                 \"testCMoveIGEforD\",\n+                 \"testCMoveILTforD\",\n+                 \"testCMoveILEforD\",\n+                 \/\/     L for I\n+                 \"testCMoveLEQforI\",\n+                 \"testCMoveLNEforI\",\n+                 \"testCMoveLGTforI\",\n+                 \"testCMoveLGEforI\",\n+                 \"testCMoveLLTforI\",\n+                 \"testCMoveLLEforI\",\n+                 \/\/     L for L\n+                 \"testCMoveLEQforL\",\n+                 \"testCMoveLNEforL\",\n+                 \"testCMoveLGTforL\",\n+                 \"testCMoveLGEforL\",\n+                 \"testCMoveLLTforL\",\n+                 \"testCMoveLLEforL\",\n+                 \/\/     L for F\n+                 \"testCMoveLEQforF\",\n+                 \"testCMoveLNEforF\",\n+                 \"testCMoveLGTforF\",\n+                 \"testCMoveLGEforF\",\n+                 \"testCMoveLLTforF\",\n+                 \"testCMoveLLEforF\",\n+                 \/\/     L for D\n+                 \"testCMoveLEQforD\",\n+                 \"testCMoveLNEforD\",\n+                 \"testCMoveLGTforD\",\n+                 \"testCMoveLGEforD\",\n+                 \"testCMoveLLTforD\",\n+                 \"testCMoveLLEforD\",\n+                 \/\/ Unsigned\n+                 \/\/     I for I\n+                 \"testCMoveUIEQforI\",\n+                 \"testCMoveUINEforI\",\n+                 \"testCMoveUIGTforI\",\n+                 \"testCMoveUIGEforI\",\n+                 \"testCMoveUILTforI\",\n+                 \"testCMoveUILEforI\",\n+                 \/\/     I for L\n+                 \"testCMoveUIEQforL\",\n+                 \"testCMoveUINEforL\",\n+                 \"testCMoveUIGTforL\",\n+                 \"testCMoveUIGEforL\",\n+                 \"testCMoveUILTforL\",\n+                 \"testCMoveUILEforL\",\n+                 \/\/     I for F\n+                 \"testCMoveUIEQforF\",\n+                 \"testCMoveUINEforF\",\n+                 \"testCMoveUIGTforF\",\n+                 \"testCMoveUIGEforF\",\n+                 \"testCMoveUILTforF\",\n+                 \"testCMoveUILEforF\",\n+                 \/\/     I for D\n+                 \"testCMoveUIEQforD\",\n+                 \"testCMoveUINEforD\",\n+                 \"testCMoveUIGTforD\",\n+                 \"testCMoveUIGEforD\",\n+                 \"testCMoveUILTforD\",\n+                 \"testCMoveUILEforD\",\n+                 \/\/     L for I\n+                 \"testCMoveULEQforI\",\n+                 \"testCMoveULNEforI\",\n+                 \"testCMoveULGTforI\",\n+                 \"testCMoveULGEforI\",\n+                 \"testCMoveULLTforI\",\n+                 \"testCMoveULLEforI\",\n+                 \/\/     L for L\n+                 \"testCMoveULEQforL\",\n+                 \"testCMoveULNEforL\",\n+                 \"testCMoveULGTforL\",\n+                 \"testCMoveULGEforL\",\n+                 \"testCMoveULLTforL\",\n+                 \"testCMoveULLEforL\",\n+                 \/\/     L for F\n+                 \"testCMoveULEQforF\",\n+                 \"testCMoveULNEforF\",\n+                 \"testCMoveULGTforF\",\n+                 \"testCMoveULGEforF\",\n+                 \"testCMoveULLTforF\",\n+                 \"testCMoveULLEforF\",\n+                 \/\/     L for D\n+                 \"testCMoveULEQforD\",\n+                 \"testCMoveULNEforD\",\n+                 \"testCMoveULGTforD\",\n+                 \"testCMoveULGEforD\",\n+                 \"testCMoveULLTforD\",\n+                 \"testCMoveULLEforD\",\n+                 \/\/ Float\n+                 \"testCMoveFGTforI\",\n+                 \"testCMoveFGTforL\",\n+                 \"testCMoveFGTforF\",\n+                 \"testCMoveFGTforD\",\n+                 \"testCMoveDGTforI\",\n+                 \"testCMoveDGTforL\",\n+                 \"testCMoveDGTforF\",\n+                 \"testCMoveDGTforD\",\n+                 \"testCMoveFGTforFCmpCon1\",\n+                 \"testCMoveFGTforFCmpCon2\"})\n+    private void testCMove_runner_two() {\n+        int[] aI = new int[SIZE];\n+        int[] bI = new int[SIZE];\n+        int[] cI = new int[SIZE];\n+        int[] dI = new int[SIZE];\n+        int[] rI = new int[SIZE];\n+        long[] aL = new long[SIZE];\n+        long[] bL = new long[SIZE];\n+        long[] cL = new long[SIZE];\n+        long[] dL = new long[SIZE];\n+        long[] rL = new long[SIZE];\n+        float[] aF = new float[SIZE];\n+        float[] bF = new float[SIZE];\n+        float[] cF = new float[SIZE];\n+        float[] dF = new float[SIZE];\n+        float[] rF = new float[SIZE];\n+        double[] aD = new double[SIZE];\n+        double[] bD = new double[SIZE];\n+        double[] cD = new double[SIZE];\n+        double[] dD = new double[SIZE];\n+        double[] rD = new double[SIZE];\n+\n+        init(aI);\n+        init(bI);\n+        init(cI);\n+        init(dI);\n+        init(aL);\n+        init(bL);\n+        init(cL);\n+        init(dL);\n+        init(aF);\n+        init(bF);\n+        init(cF);\n+        init(dF);\n+        init(aD);\n+        init(bD);\n+        init(cD);\n+        init(dD);\n+\n+        \/\/ Signed\n+        \/\/     I for I\n+        testCMoveIEQforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIEQforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveINEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveINEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveIGTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIGTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveIGEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIGEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveILTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveILTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveILEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveILEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     I for L\n+        testCMoveIEQforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIEQforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveINEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveINEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveIGTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIGTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveIGEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIGEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveILTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveILTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveILEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveILEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     I for F\n+        testCMoveIEQforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIEQforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveINEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveINEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveIGTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIGTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveIGEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIGEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveILTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveILTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveILEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveILEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     I for D\n+        testCMoveIEQforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIEQforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveINEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveINEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveIGTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIGTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveIGEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIGEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveILTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveILTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveILEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveILEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/     L for I\n+        testCMoveLEQforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLEQforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLNEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLNEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLGTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLGTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLGEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLGEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLLTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLLTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLLEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLLEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     L for L\n+        testCMoveLEQforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLEQforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLNEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLNEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLGTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLGTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLGEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLGEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLLTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLLTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLLEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLLEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     L for F\n+        testCMoveLEQforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLEQforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLNEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLNEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLGTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLGTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLGEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLGEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLLTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLLTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLLEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLLEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     L for D\n+        testCMoveLEQforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLEQforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLNEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLNEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLGTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLGTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLGEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLGEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLLTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLLTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLLEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLLEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/ Unsigned\n+        \/\/     I for I\n+        testCMoveUIEQforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIEQforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUINEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUINEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUIGTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIGTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUIGEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIGEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUILTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUILTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUILEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUILEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     I for L\n+        testCMoveUIEQforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIEQforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUINEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUINEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUIGTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIGTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUIGEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIGEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUILTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUILTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUILEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUILEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     I for F\n+        testCMoveUIEQforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIEQforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUINEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUINEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUIGTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIGTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUIGEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIGEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUILTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUILTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUILEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUILEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     I for D\n+        testCMoveUIEQforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIEQforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUINEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUINEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUIGTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIGTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUIGEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIGEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUILTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUILTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUILEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUILEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/     L for I\n+        testCMoveULEQforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULEQforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULNEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULNEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULGTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULGTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULGEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULGEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULLTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULLTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULLEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULLEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     L for L\n+        testCMoveULEQforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULEQforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULNEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULNEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULGTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULGTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULGEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULGEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULLTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULLTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULLEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULLEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     L for F\n+        testCMoveULEQforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULEQforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULNEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULNEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULGTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULGTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULGEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULGEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULLTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULLTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULLEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULLEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     L for D\n+        testCMoveULEQforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULEQforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULNEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULNEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULGTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULGTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULGEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULGEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULLTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULLTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULLEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULLEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/ Float\n+        testCMoveFGTforI(aF, bF, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveFGTforI(aF[i], bF[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveFGTforL(aF, bF, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveFGTforL(aF[i], bF[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveFGTforF(aF, bF, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveFGTforD(aF, bF, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveFGTforD(aF[i], bF[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveDGTforI(aD, bD, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveDGTforI(aD[i], bD[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveDGTforL(aD, bD, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveDGTforL(aD[i], bD[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveDGTforF(aD, bD, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveDGTforF(aD[i], bD[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveDGTforD(aD, bD, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveDGTforD(aD[i], bD[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/ Use some constants\/invariants in the comparison\n+        testCMoveFGTforFCmpCon1(aF[0], bF, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[0], bF[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveFGTforFCmpCon2(aF, bF[0], cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[0], cF[i], dF[i]));\n+        }\n+    }\n+\n+    private static void init(int[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n+    private static void init(long[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+    }\n+\n+    private static void init(float[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = switch(RANDOM.nextInt() % 20) {\n+                case 0  -> Float.NaN;\n+                case 1  -> 0;\n+                case 2  -> 1;\n+                case 3  -> Float.POSITIVE_INFINITY;\n+                case 4  -> Float.NEGATIVE_INFINITY;\n+                case 5  -> Float.MAX_VALUE;\n+                case 6  -> Float.MIN_VALUE;\n+                case 7, 8, 9 -> RANDOM.nextFloat();\n+                default -> Float.intBitsToFloat(RANDOM.nextInt());\n+            };\n+        }\n+    }\n+\n+    private static void init(double[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = switch(RANDOM.nextInt() % 20) {\n+                case 0  -> Double.NaN;\n+                case 1  -> 0;\n+                case 2  -> 1;\n+                case 3  -> Double.POSITIVE_INFINITY;\n+                case 4  -> Double.NEGATIVE_INFINITY;\n+                case 5  -> Double.MAX_VALUE;\n+                case 6  -> Double.MIN_VALUE;\n+                case 7, 8, 9 -> RANDOM.nextDouble();\n+                default -> Double.longBitsToDouble(RANDOM.nextLong());\n+            };\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestConditionalMove.java","additions":3819,"deletions":0,"binary":false,"changes":3819,"status":"added"},{"patch":"@@ -1,3072 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2025, Arm Limited. All rights reserved.\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2025, Rivos Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2.irTests;\n-\n-import compiler.lib.ir_framework.*;\n-import java.util.Random;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-\n-\/*\n- * @test\n- * @summary Test conditional move.\n- * @requires vm.simpleArch == \"riscv64\"\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.irTests.TestScalarConditionalMove\n- *\/\n-\n-public class TestScalarConditionalMove {\n-    final private static int SIZE = 1024;\n-    private static final Random RANDOM = Utils.getRandomInstance();\n-\n-    public static void main(String[] args) {\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\");\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:-UseVectorCmov\",\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\");\n-    }\n-\n-    \/\/ Compare 2 values, and pick one of them\n-    private float cmoveFloatGT(float a, float b) {\n-        return (a > b) ? a : b;\n-    }\n-\n-    private float cmoveFloatGTSwap(float a, float b) {\n-        return (b > a) ? a : b;\n-    }\n-\n-    private float cmoveFloatLT(float a, float b) {\n-        return (a < b) ? a : b;\n-    }\n-\n-    private float cmoveFloatLTSwap(float a, float b) {\n-        return (b < a) ? a : b;\n-    }\n-\n-    private float cmoveFloatEQ(float a, float b) {\n-        return (a == b) ? a : b;\n-    }\n-\n-    private double cmoveDoubleLE(double a, double b) {\n-        return (a <= b) ? a : b;\n-    }\n-\n-    private double cmoveDoubleLESwap(double a, double b) {\n-        return (b <= a) ? a : b;\n-    }\n-\n-    private double cmoveDoubleGE(double a, double b) {\n-        return (a >= b) ? a : b;\n-    }\n-\n-    private double cmoveDoubleGESwap(double a, double b) {\n-        return (b >= a) ? a : b;\n-    }\n-\n-    private double cmoveDoubleNE(double a, double b) {\n-        return (a != b) ? a : b;\n-    }\n-\n-    \/\/ Extensions: compare 2 values, and pick from 2 consts\n-    private float cmoveFGTforFConst(float a, float b) {\n-        return (a > b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFGEforFConst(float a, float b) {\n-        return (a >= b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFLTforFConst(float a, float b) {\n-        return (a < b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFLEforFConst(float a, float b) {\n-        return (a <= b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFEQforFConst(float a, float b) {\n-        return (a == b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFNEQforFConst(float a, float b) {\n-        return (a != b) ? 0.1f : -0.1f;\n-    }\n-\n-    private double cmoveDGTforDConst(double a, double b) {\n-        return (a > b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDGEforDConst(double a, double b) {\n-        return (a >= b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDLTforDConst(double a, double b) {\n-        return (a < b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDLEforDConst(double a, double b) {\n-        return (a <= b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDEQforDConst(double a, double b) {\n-        return (a == b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDNEQforDConst(double a, double b) {\n-        return (a != b) ? 0.1 : -0.1;\n-    }\n-\n-    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n-    \/\/ Signed comparison: I\/L\n-    \/\/    I for I\n-    private int cmoveIEQforI(int a, int b, int c, int d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private int cmoveINEforI(int a, int b, int c, int d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private int cmoveIGTforI(int a, int b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private int cmoveIGEforI(int a, int b, int c, int d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private int cmoveILTforI(int a, int b, int c, int d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private int cmoveILEforI(int a, int b, int c, int d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    I for L\n-    private long cmoveIEQforL(int a, int b, long c, long d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private long cmoveINEforL(int a, int b, long c, long d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private long cmoveIGTforL(int a, int b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveIGEforL(int a, int b, long c, long d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private long cmoveILTforL(int a, int b, long c, long d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private long cmoveILEforL(int a, int b, long c, long d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    I for F\n-    private float cmoveIEQforF(int a, int b, float c, float d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private float cmoveINEforF(int a, int b, float c, float d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private float cmoveIGTforF(int a, int b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveIGEforF(int a, int b, float c, float d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private float cmoveILTforF(int a, int b, float c, float d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private float cmoveILEforF(int a, int b, float c, float d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    I for D\n-    private double cmoveIEQforD(int a, int b, double c, double d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private double cmoveINEforD(int a, int b, double c, double d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private double cmoveIGTforD(int a, int b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveIGEforD(int a, int b, double c, double d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private double cmoveILTforD(int a, int b, double c, double d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private double cmoveILEforD(int a, int b, double c, double d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for I\n-    private int cmoveLEQforI(long a, long b, int c, int d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private int cmoveLNEforI(long a, long b, int c, int d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private int cmoveLGTforI(long a, long b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private int cmoveLGEforI(long a, long b, int c, int d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private int cmoveLLTforI(long a, long b, int c, int d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private int cmoveLLEforI(long a, long b, int c, int d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for L\n-    private long cmoveLEQforL(long a, long b, long c, long d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private long cmoveLNEforL(long a, long b, long c, long d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private long cmoveLGTforL(long a, long b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveLGEforL(long a, long b, long c, long d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private long cmoveLLTforL(long a, long b, long c, long d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private long cmoveLLEforL(long a, long b, long c, long d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for F\n-    private float cmoveLEQforF(long a, long b, float c, float d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private float cmoveLNEforF(long a, long b, float c, float d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private float cmoveLGTforF(long a, long b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveLGEforF(long a, long b, float c, float d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private float cmoveLLTforF(long a, long b, float c, float d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private float cmoveLLEforF(long a, long b, float c, float d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for D\n-    private double cmoveLEQforD(long a, long b, double c, double d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private double cmoveLNEforD(long a, long b, double c, double d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private double cmoveLGTforD(long a, long b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveLGEforD(long a, long b, double c, double d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private double cmoveLLTforD(long a, long b, double c, double d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private double cmoveLLEforD(long a, long b, double c, double d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/ Unsigned comparison: I\/L\n-    \/\/    I for I\n-    private int cmoveUIEQforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private int cmoveUINEforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private int cmoveUIGTforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private int cmoveUIGEforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private int cmoveUILTforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private int cmoveUILEforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    I for L\n-    private long cmoveUIEQforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private long cmoveUINEforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private long cmoveUIGTforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private long cmoveUIGEforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private long cmoveUILTforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private long cmoveUILEforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    I for F\n-    private float cmoveUIEQforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private float cmoveUINEforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private float cmoveUIGTforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private float cmoveUIGEforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private float cmoveUILTforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private float cmoveUILEforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    I for D\n-    private double cmoveUIEQforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private double cmoveUINEforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private double cmoveUIGTforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private double cmoveUIGEforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private double cmoveUILTforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private double cmoveUILEforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for I\n-    private int cmoveULEQforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private int cmoveULNEforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private int cmoveULGTforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private int cmoveULGEforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private int cmoveULLTforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private int cmoveULLEforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for L\n-    private long cmoveULEQforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private long cmoveULNEforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private long cmoveULGTforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private long cmoveULGEforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private long cmoveULLTforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private long cmoveULLEforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for F\n-    private float cmoveULEQforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private float cmoveULNEforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private float cmoveULGTforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private float cmoveULGEforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private float cmoveULLTforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private float cmoveULLEforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for D\n-    private double cmoveULEQforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private double cmoveULNEforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private double cmoveULGTforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private double cmoveULGEforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private double cmoveULLTforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private double cmoveULLEforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/ Float comparison\n-    private int cmoveFGTforI(float a, float b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveFGTforL(float a, float b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveFGTforF(float a, float b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveFGTforD(float a, float b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private int cmoveDGTforI(double a, double b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveDGTforL(double a, double b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveDGTforF(double a, double b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveDGTforD(double a, double b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    \/\/ Compare 2 values, and pick one of them\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveVFGT(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] > b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveVFGTSwap(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] > a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveVFLT(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] < b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveVFLTSwap(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] < a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveVFEQ(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] == b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveVDLE(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] <= b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveVDLESwap(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] <= a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveVDGE(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] >= b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveVDGESwap(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] >= a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveVDNE(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] != b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    \/\/ Extensions: compare 2 values, and pick from 2 consts\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFGTforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] > b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFGEforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] >= b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFLTforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] < b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFLEforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] <= b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFEQforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] == b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFNEQforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] != b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFLTforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] < b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] < b[i+1]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFLEforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFYYforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFXXforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDGTforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] > b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDGEforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] >= b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDLTforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] < b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDLEforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] <= b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDEQforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] == b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDNEQforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] != b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDLTforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] < b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] < b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDLEforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDYYforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDXXforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n-    \/\/ Note:\n-    \/\/   To guarantee that CMove is introduced, I need to perform the loads before the branch. To ensure they\n-    \/\/   do not float down into the branches, I compute a value, and store it to r2 (same as r, except that the\n-    \/\/   compilation does not know that).\n-    \/\/   So far, CMoveI\/L is not guaranteed to be generated, so @IR not verify CMOVE_I\/L.\n-    \/\/\n-    \/\/ Signed comparison: I\/L\n-    \/\/     I fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo F\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo D\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_I, \">0\"})\n-    private static void testCMoveLEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo F\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo D\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_L, \">0\"})\n-    private static void testCMoveLLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/ Unsigned comparison: I\/L\n-    \/\/     I fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo F\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo D\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_U, \">0\"})\n-    private static void testCMoveUILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo F\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo D\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_UL, \">0\"})\n-    private static void testCMoveULLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFGTforI(float[] a, float[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFGTforL(float[] a, float[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFGTforF(float[] a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFGTforD(float[] a, float[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_I, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDGTforI(double[] a, double[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ @IR(counts = {IRNode.CMOVE_L, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDGTforL(double[] a, double[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDGTforF(double[] a, double[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_D, \">0\", IRNode.CMP_D, \">0\"})\n-    private static void testCMoveDGTforD(double[] a, double[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/ Use some constants in the comparison\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFGTforFCmpCon1(float a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < b.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    @IR(counts = {IRNode.CMOVE_F, \">0\", IRNode.CMP_F, \">0\"})\n-    private static void testCMoveFGTforFCmpCon2(float[] a, float b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/ A case that is currently not supported and is not expected to vectorize\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveVDUnsupported() {\n-        double[] doublec = new double[SIZE];\n-        int seed = 1001;\n-        for (int i = 0; i < doublec.length; i++) {\n-            doublec[i] = (i % 2 == 0) ? seed + i : seed - i;\n-        }\n-    }\n-\n-    @Warmup(0)\n-    @Run(test = {\"testCMoveVFGT\", \"testCMoveVFLT\",\"testCMoveVDLE\", \"testCMoveVDGE\", \"testCMoveVFEQ\", \"testCMoveVDNE\",\n-                 \"testCMoveVFGTSwap\", \"testCMoveVFLTSwap\",\"testCMoveVDLESwap\", \"testCMoveVDGESwap\",\n-                 \"testCMoveFGTforFConst\", \"testCMoveFGEforFConst\", \"testCMoveFLTforFConst\",\n-                 \"testCMoveFLEforFConst\", \"testCMoveFEQforFConst\", \"testCMoveFNEQforFConst\",\n-                 \"testCMoveDGTforDConst\", \"testCMoveDGEforDConst\", \"testCMoveDLTforDConst\",\n-                 \"testCMoveDLEforDConst\", \"testCMoveDEQforDConst\", \"testCMoveDNEQforDConst\",\n-                 \"testCMoveFLTforFConstH2\", \"testCMoveFLEforFConstH2\",\n-                 \"testCMoveFYYforFConstH2\", \"testCMoveFXXforFConstH2\",\n-                 \"testCMoveDLTforDConstH2\", \"testCMoveDLEforDConstH2\",\n-                 \"testCMoveDYYforDConstH2\", \"testCMoveDXXforDConstH2\"})\n-    private void testCMove_runner() {\n-        float[] floata = new float[SIZE];\n-        float[] floatb = new float[SIZE];\n-        float[] floatc = new float[SIZE];\n-        double[] doublea = new double[SIZE];\n-        double[] doubleb = new double[SIZE];\n-        double[] doublec = new double[SIZE];\n-\n-        init(floata);\n-        init(floatb);\n-        init(doublea);\n-        init(doubleb);\n-\n-        testCMoveVFGT(floata, floatb, floatc);\n-        testCMoveVDLE(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatGT(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleLE(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveVFLT(floata, floatb, floatc);\n-        testCMoveVDGE(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatLT(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleGE(doublea[i], doubleb[i]));\n-        }\n-\n-        \/\/ Ensure we frequently have equals\n-        for (int i = 0; i < SIZE; i++) {\n-            if (i % 3 == 0) {\n-                floatb[i] = floata[i];\n-                doubleb[i] = doublea[i];\n-            }\n-        }\n-\n-        testCMoveVFEQ(floata, floatb, floatc);\n-        testCMoveVDNE(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatEQ(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleNE(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveVFGTSwap(floata, floatb, floatc);\n-        testCMoveVDLESwap(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatGTSwap(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleLESwap(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveVFLTSwap(floata, floatb, floatc);\n-        testCMoveVDGESwap(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatLTSwap(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleGESwap(doublea[i], doubleb[i]));\n-        }\n-\n-        \/\/ Extensions: compare 2 values, and pick from 2 consts\n-        testCMoveFGTforFConst(floata, floatb, floatc);\n-        testCMoveDGTforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFGTforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDGTforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFGEforFConst(floata, floatb, floatc);\n-        testCMoveDGEforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFGEforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDGEforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFLTforFConst(floata, floatb, floatc);\n-        testCMoveDLTforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFLEforFConst(floata, floatb, floatc);\n-        testCMoveDLEforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFEQforFConst(floata, floatb, floatc);\n-        testCMoveDEQforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFEQforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDEQforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFNEQforFConst(floata, floatb, floatc);\n-        testCMoveDNEQforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFNEQforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDNEQforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        \/\/ Hand-unrolled (H2) examples:\n-        testCMoveFLTforFConstH2(floata, floatb, floatc);\n-        testCMoveDLTforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFLEforFConstH2(floata, floatb, floatc);\n-        testCMoveDLEforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFYYforFConstH2(floata, floatb, floatc);\n-        testCMoveDYYforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i+=2) {\n-            Asserts.assertEquals(floatc[i+0], cmoveFLEforFConst(floata[i+0], floatb[i+0]));\n-            Asserts.assertEquals(doublec[i+0], cmoveDLEforDConst(doublea[i+0], doubleb[i+0]));\n-            Asserts.assertEquals(floatc[i+1], cmoveFLTforFConst(floata[i+1], floatb[i+1]));\n-            Asserts.assertEquals(doublec[i+1], cmoveDLTforDConst(doublea[i+1], doubleb[i+1]));\n-        }\n-\n-        testCMoveFXXforFConstH2(floata, floatb, floatc);\n-        testCMoveDXXforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i+=2) {\n-            Asserts.assertEquals(floatc[i+0], cmoveFLTforFConst(floata[i+0], floatb[i+0]));\n-            Asserts.assertEquals(doublec[i+0], cmoveDLTforDConst(doublea[i+0], doubleb[i+0]));\n-            Asserts.assertEquals(floatc[i+1], cmoveFLEforFConst(floata[i+1], floatb[i+1]));\n-            Asserts.assertEquals(doublec[i+1], cmoveDLEforDConst(doublea[i+1], doubleb[i+1]));\n-        }\n-    }\n-\n-    @Warmup(0)\n-    @Run(test = {\/\/ Signed\n-                 \/\/     I for I\n-                 \"testCMoveIEQforI\",\n-                 \"testCMoveINEforI\",\n-                 \"testCMoveIGTforI\",\n-                 \"testCMoveIGEforI\",\n-                 \"testCMoveILTforI\",\n-                 \"testCMoveILEforI\",\n-                 \/\/     I for L\n-                 \"testCMoveIEQforL\",\n-                 \"testCMoveINEforL\",\n-                 \"testCMoveIGTforL\",\n-                 \"testCMoveIGEforL\",\n-                 \"testCMoveILTforL\",\n-                 \"testCMoveILEforL\",\n-                 \/\/     I for F\n-                 \"testCMoveIEQforF\",\n-                 \"testCMoveINEforF\",\n-                 \"testCMoveIGTforF\",\n-                 \"testCMoveIGEforF\",\n-                 \"testCMoveILTforF\",\n-                 \"testCMoveILEforF\",\n-                 \/\/     I for D\n-                 \"testCMoveIEQforD\",\n-                 \"testCMoveINEforD\",\n-                 \"testCMoveIGTforD\",\n-                 \"testCMoveIGEforD\",\n-                 \"testCMoveILTforD\",\n-                 \"testCMoveILEforD\",\n-                 \/\/     L for I\n-                 \"testCMoveLEQforI\",\n-                 \"testCMoveLNEforI\",\n-                 \"testCMoveLGTforI\",\n-                 \"testCMoveLGEforI\",\n-                 \"testCMoveLLTforI\",\n-                 \"testCMoveLLEforI\",\n-                 \/\/     L for L\n-                 \"testCMoveLEQforL\",\n-                 \"testCMoveLNEforL\",\n-                 \"testCMoveLGTforL\",\n-                 \"testCMoveLGEforL\",\n-                 \"testCMoveLLTforL\",\n-                 \"testCMoveLLEforL\",\n-                 \/\/     L for F\n-                 \"testCMoveLEQforF\",\n-                 \"testCMoveLNEforF\",\n-                 \"testCMoveLGTforF\",\n-                 \"testCMoveLGEforF\",\n-                 \"testCMoveLLTforF\",\n-                 \"testCMoveLLEforF\",\n-                 \/\/     L for D\n-                 \"testCMoveLEQforD\",\n-                 \"testCMoveLNEforD\",\n-                 \"testCMoveLGTforD\",\n-                 \"testCMoveLGEforD\",\n-                 \"testCMoveLLTforD\",\n-                 \"testCMoveLLEforD\",\n-                 \/\/ Unsigned\n-                 \/\/     I for I\n-                 \"testCMoveUIEQforI\",\n-                 \"testCMoveUINEforI\",\n-                 \"testCMoveUIGTforI\",\n-                 \"testCMoveUIGEforI\",\n-                 \"testCMoveUILTforI\",\n-                 \"testCMoveUILEforI\",\n-                 \/\/     I for L\n-                 \"testCMoveUIEQforL\",\n-                 \"testCMoveUINEforL\",\n-                 \"testCMoveUIGTforL\",\n-                 \"testCMoveUIGEforL\",\n-                 \"testCMoveUILTforL\",\n-                 \"testCMoveUILEforL\",\n-                 \/\/     I for F\n-                 \"testCMoveUIEQforF\",\n-                 \"testCMoveUINEforF\",\n-                 \"testCMoveUIGTforF\",\n-                 \"testCMoveUIGEforF\",\n-                 \"testCMoveUILTforF\",\n-                 \"testCMoveUILEforF\",\n-                 \/\/     I for D\n-                 \"testCMoveUIEQforD\",\n-                 \"testCMoveUINEforD\",\n-                 \"testCMoveUIGTforD\",\n-                 \"testCMoveUIGEforD\",\n-                 \"testCMoveUILTforD\",\n-                 \"testCMoveUILEforD\",\n-                 \/\/     L for I\n-                 \"testCMoveULEQforI\",\n-                 \"testCMoveULNEforI\",\n-                 \"testCMoveULGTforI\",\n-                 \"testCMoveULGEforI\",\n-                 \"testCMoveULLTforI\",\n-                 \"testCMoveULLEforI\",\n-                 \/\/     L for L\n-                 \"testCMoveULEQforL\",\n-                 \"testCMoveULNEforL\",\n-                 \"testCMoveULGTforL\",\n-                 \"testCMoveULGEforL\",\n-                 \"testCMoveULLTforL\",\n-                 \"testCMoveULLEforL\",\n-                 \/\/     L for F\n-                 \"testCMoveULEQforF\",\n-                 \"testCMoveULNEforF\",\n-                 \"testCMoveULGTforF\",\n-                 \"testCMoveULGEforF\",\n-                 \"testCMoveULLTforF\",\n-                 \"testCMoveULLEforF\",\n-                 \/\/     L for D\n-                 \"testCMoveULEQforD\",\n-                 \"testCMoveULNEforD\",\n-                 \"testCMoveULGTforD\",\n-                 \"testCMoveULGEforD\",\n-                 \"testCMoveULLTforD\",\n-                 \"testCMoveULLEforD\",\n-                 \/\/ Float\n-                 \"testCMoveFGTforI\",\n-                 \"testCMoveFGTforL\",\n-                 \"testCMoveFGTforF\",\n-                 \"testCMoveFGTforD\",\n-                 \"testCMoveDGTforI\",\n-                 \"testCMoveDGTforL\",\n-                 \"testCMoveDGTforF\",\n-                 \"testCMoveDGTforD\",\n-                 \"testCMoveFGTforFCmpCon1\",\n-                 \"testCMoveFGTforFCmpCon2\"})\n-    private void testCMove_runner_two() {\n-        int[] aI = new int[SIZE];\n-        int[] bI = new int[SIZE];\n-        int[] cI = new int[SIZE];\n-        int[] dI = new int[SIZE];\n-        int[] rI = new int[SIZE];\n-        long[] aL = new long[SIZE];\n-        long[] bL = new long[SIZE];\n-        long[] cL = new long[SIZE];\n-        long[] dL = new long[SIZE];\n-        long[] rL = new long[SIZE];\n-        float[] aF = new float[SIZE];\n-        float[] bF = new float[SIZE];\n-        float[] cF = new float[SIZE];\n-        float[] dF = new float[SIZE];\n-        float[] rF = new float[SIZE];\n-        double[] aD = new double[SIZE];\n-        double[] bD = new double[SIZE];\n-        double[] cD = new double[SIZE];\n-        double[] dD = new double[SIZE];\n-        double[] rD = new double[SIZE];\n-\n-        init(aI);\n-        init(bI);\n-        init(cI);\n-        init(dI);\n-        init(aL);\n-        init(bL);\n-        init(cL);\n-        init(dL);\n-        init(aF);\n-        init(bF);\n-        init(cF);\n-        init(dF);\n-        init(aD);\n-        init(bD);\n-        init(cD);\n-        init(dD);\n-\n-        \/\/ Signed\n-        \/\/     I for I\n-        testCMoveIEQforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveIEQforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveINEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveINEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveIGTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveIGTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveIGEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveIGEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveILTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveILTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveILEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveILEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     I for L\n-        testCMoveIEQforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveIEQforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveINEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveINEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveIGTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveIGTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveIGEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveIGEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveILTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveILTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveILEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveILEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     I for F\n-        testCMoveIEQforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveIEQforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveINEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveINEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveIGTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveIGTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveIGEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveIGEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveILTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveILTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveILEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveILEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     I for D\n-        boolean passed = true;\n-        testCMoveIEQforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveIEQforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-        Asserts.assertEquals(passed, true);\n-\n-        testCMoveINEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveINEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveIGTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveIGTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveIGEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveIGEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveILTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveILTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveILEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveILEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/     L for I\n-        testCMoveLEQforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLEQforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLNEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLNEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLGTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLGTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLGEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLGEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLLTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLLTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLLEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLLEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     L for L\n-        testCMoveLEQforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLEQforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLNEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLNEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLGTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLGTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLGEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLGEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLLTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLLTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLLEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLLEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     L for F\n-        testCMoveLEQforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLEQforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLNEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLNEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLGTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLGTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLGEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLGEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLLTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLLTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLLEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLLEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     L for D\n-        testCMoveLEQforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLEQforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLNEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLNEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLGTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLGTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLGEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLGEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLLTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLLTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLLEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLLEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/ Unsigned\n-        \/\/     I for I\n-        testCMoveUIEQforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUIEQforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUINEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUINEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUIGTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUIGTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUIGEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUIGEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUILTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUILTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUILEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUILEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     I for L\n-        testCMoveUIEQforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUIEQforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUINEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUINEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUIGTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUIGTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUIGEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUIGEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUILTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUILTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUILEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUILEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     I for F\n-        testCMoveUIEQforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUIEQforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUINEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUINEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUIGTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUIGTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUIGEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUIGEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUILTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUILTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUILEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUILEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     I for D\n-        testCMoveUIEQforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUIEQforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUINEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUINEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUIGTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUIGTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUIGEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUIGEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUILTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUILTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUILEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUILEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/     L for I\n-        testCMoveULEQforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULEQforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULNEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULNEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULGTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULGTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULGEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULGEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULLTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULLTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULLEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULLEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     L for L\n-        testCMoveULEQforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULEQforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULNEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULNEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULGTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULGTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULGEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULGEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULLTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULLTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULLEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULLEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     L for F\n-        testCMoveULEQforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULEQforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULNEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULNEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULGTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULGTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULGEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULGEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULLTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULLTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULLEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULLEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     L for D\n-        testCMoveULEQforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULEQforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULNEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULNEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULGTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULGTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULGEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULGEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULLTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULLTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULLEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULLEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/ Float\n-        testCMoveFGTforI(aF, bF, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveFGTforI(aF[i], bF[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveFGTforL(aF, bF, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveFGTforL(aF[i], bF[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveFGTforF(aF, bF, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveFGTforD(aF, bF, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveFGTforD(aF[i], bF[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveDGTforI(aD, bD, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveDGTforI(aD[i], bD[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveDGTforL(aD, bD, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveDGTforL(aD[i], bD[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveDGTforF(aD, bD, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveDGTforF(aD[i], bD[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveDGTforD(aD, bD, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveDGTforD(aD[i], bD[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/ Use some constants\/invariants in the comparison\n-        testCMoveFGTforFCmpCon1(aF[0], bF, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[0], bF[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveFGTforFCmpCon2(aF, bF[0], cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[0], cF[i], dF[i]));\n-        }\n-    }\n-\n-    private static void init(int[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = RANDOM.nextInt();\n-        }\n-    }\n-\n-    private static void init(long[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = RANDOM.nextLong();\n-        }\n-    }\n-\n-    private static void init(float[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = switch(RANDOM.nextInt() % 20) {\n-                case 0  -> Float.NaN;\n-                case 1  -> 0;\n-                case 2  -> 1;\n-                case 3  -> Float.POSITIVE_INFINITY;\n-                case 4  -> Float.NEGATIVE_INFINITY;\n-                case 5  -> Float.MAX_VALUE;\n-                case 6  -> Float.MIN_VALUE;\n-                case 7, 8, 9 -> RANDOM.nextFloat();\n-                default -> Float.intBitsToFloat(RANDOM.nextInt());\n-            };\n-        }\n-    }\n-\n-    private static void init(double[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = switch(RANDOM.nextInt() % 20) {\n-                case 0  -> Double.NaN;\n-                case 1  -> 0;\n-                case 2  -> 1;\n-                case 3  -> Double.POSITIVE_INFINITY;\n-                case 4  -> Double.NEGATIVE_INFINITY;\n-                case 5  -> Double.MAX_VALUE;\n-                case 6  -> Double.MIN_VALUE;\n-                case 7, 8, 9 -> RANDOM.nextDouble();\n-                default -> Double.longBitsToDouble(RANDOM.nextLong());\n-            };\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestScalarConditionalMove.java","additions":0,"deletions":3072,"binary":false,"changes":3072,"status":"deleted"},{"patch":"@@ -1,3218 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2025, Arm Limited. All rights reserved.\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2025, Rivos Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2.irTests;\n-\n-import compiler.lib.ir_framework.*;\n-import java.util.Random;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-\n-\/*\n- * @test\n- * @bug 8289422 8306088 8313720\n- * @key randomness\n- * @summary Auto-vectorization enhancement to support vector conditional move.\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.irTests.TestVectorConditionalMove\n- *\/\n-\n-public class TestVectorConditionalMove {\n-    final private static int SIZE = 1024;\n-    private static final Random RANDOM = Utils.getRandomInstance();\n-\n-    public static void main(String[] args) {\n-        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n-                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n-                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n-                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n-                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n-    }\n-\n-    \/\/ Compare 2 values, and pick one of them\n-    private float cmoveFloatGT(float a, float b) {\n-        return (a > b) ? a : b;\n-    }\n-\n-    private float cmoveFloatGTSwap(float a, float b) {\n-        return (b > a) ? a : b;\n-    }\n-\n-    private float cmoveFloatLT(float a, float b) {\n-        return (a < b) ? a : b;\n-    }\n-\n-    private float cmoveFloatLTSwap(float a, float b) {\n-        return (b < a) ? a : b;\n-    }\n-\n-    private float cmoveFloatEQ(float a, float b) {\n-        return (a == b) ? a : b;\n-    }\n-\n-    private double cmoveDoubleLE(double a, double b) {\n-        return (a <= b) ? a : b;\n-    }\n-\n-    private double cmoveDoubleLESwap(double a, double b) {\n-        return (b <= a) ? a : b;\n-    }\n-\n-    private double cmoveDoubleGE(double a, double b) {\n-        return (a >= b) ? a : b;\n-    }\n-\n-    private double cmoveDoubleGESwap(double a, double b) {\n-        return (b >= a) ? a : b;\n-    }\n-\n-    private double cmoveDoubleNE(double a, double b) {\n-        return (a != b) ? a : b;\n-    }\n-\n-    \/\/ Extensions: compare 2 values, and pick from 2 consts\n-    private float cmoveFGTforFConst(float a, float b) {\n-        return (a > b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFGEforFConst(float a, float b) {\n-        return (a >= b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFLTforFConst(float a, float b) {\n-        return (a < b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFLEforFConst(float a, float b) {\n-        return (a <= b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFEQforFConst(float a, float b) {\n-        return (a == b) ? 0.1f : -0.1f;\n-    }\n-\n-    private float cmoveFNEQforFConst(float a, float b) {\n-        return (a != b) ? 0.1f : -0.1f;\n-    }\n-\n-    private double cmoveDGTforDConst(double a, double b) {\n-        return (a > b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDGEforDConst(double a, double b) {\n-        return (a >= b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDLTforDConst(double a, double b) {\n-        return (a < b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDLEforDConst(double a, double b) {\n-        return (a <= b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDEQforDConst(double a, double b) {\n-        return (a == b) ? 0.1 : -0.1;\n-    }\n-\n-    private double cmoveDNEQforDConst(double a, double b) {\n-        return (a != b) ? 0.1 : -0.1;\n-    }\n-\n-    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n-    \/\/ Signed comparison: I\/L\n-    \/\/    I for I\n-    private int cmoveIEQforI(int a, int b, int c, int d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private int cmoveINEforI(int a, int b, int c, int d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private int cmoveIGTforI(int a, int b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private int cmoveIGEforI(int a, int b, int c, int d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private int cmoveILTforI(int a, int b, int c, int d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private int cmoveILEforI(int a, int b, int c, int d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    I for L\n-    private long cmoveIEQforL(int a, int b, long c, long d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private long cmoveINEforL(int a, int b, long c, long d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private long cmoveIGTforL(int a, int b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveIGEforL(int a, int b, long c, long d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private long cmoveILTforL(int a, int b, long c, long d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private long cmoveILEforL(int a, int b, long c, long d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    I for F\n-    private float cmoveIEQforF(int a, int b, float c, float d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private float cmoveINEforF(int a, int b, float c, float d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private float cmoveIGTforF(int a, int b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveIGEforF(int a, int b, float c, float d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private float cmoveILTforF(int a, int b, float c, float d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private float cmoveILEforF(int a, int b, float c, float d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    I for D\n-    private double cmoveIEQforD(int a, int b, double c, double d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private double cmoveINEforD(int a, int b, double c, double d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private double cmoveIGTforD(int a, int b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveIGEforD(int a, int b, double c, double d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private double cmoveILTforD(int a, int b, double c, double d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private double cmoveILEforD(int a, int b, double c, double d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for I\n-    private int cmoveLEQforI(long a, long b, int c, int d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private int cmoveLNEforI(long a, long b, int c, int d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private int cmoveLGTforI(long a, long b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private int cmoveLGEforI(long a, long b, int c, int d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private int cmoveLLTforI(long a, long b, int c, int d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private int cmoveLLEforI(long a, long b, int c, int d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for L\n-    private long cmoveLEQforL(long a, long b, long c, long d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private long cmoveLNEforL(long a, long b, long c, long d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private long cmoveLGTforL(long a, long b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveLGEforL(long a, long b, long c, long d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private long cmoveLLTforL(long a, long b, long c, long d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private long cmoveLLEforL(long a, long b, long c, long d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for F\n-    private float cmoveLEQforF(long a, long b, float c, float d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private float cmoveLNEforF(long a, long b, float c, float d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private float cmoveLGTforF(long a, long b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveLGEforF(long a, long b, float c, float d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private float cmoveLLTforF(long a, long b, float c, float d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private float cmoveLLEforF(long a, long b, float c, float d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/    L for D\n-    private double cmoveLEQforD(long a, long b, double c, double d) {\n-        return (a == b) ? c : d;\n-    }\n-\n-    private double cmoveLNEforD(long a, long b, double c, double d) {\n-        return (a != b) ? c : d;\n-    }\n-\n-    private double cmoveLGTforD(long a, long b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveLGEforD(long a, long b, double c, double d) {\n-        return (a >= b) ? c : d;\n-    }\n-\n-    private double cmoveLLTforD(long a, long b, double c, double d) {\n-        return (a < b) ? c : d;\n-    }\n-\n-    private double cmoveLLEforD(long a, long b, double c, double d) {\n-        return (a <= b) ? c : d;\n-    }\n-\n-    \/\/ Unsigned comparison: I\/L\n-    \/\/    I for I\n-    private int cmoveUIEQforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private int cmoveUINEforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private int cmoveUIGTforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private int cmoveUIGEforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private int cmoveUILTforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private int cmoveUILEforI(int a, int b, int c, int d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    I for L\n-    private long cmoveUIEQforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private long cmoveUINEforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private long cmoveUIGTforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private long cmoveUIGEforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private long cmoveUILTforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private long cmoveUILEforL(int a, int b, long c, long d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    I for F\n-    private float cmoveUIEQforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private float cmoveUINEforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private float cmoveUIGTforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private float cmoveUIGEforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private float cmoveUILTforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private float cmoveUILEforF(int a, int b, float c, float d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    I for D\n-    private double cmoveUIEQforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private double cmoveUINEforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private double cmoveUIGTforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private double cmoveUIGEforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private double cmoveUILTforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private double cmoveUILEforD(int a, int b, double c, double d) {\n-        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for I\n-    private int cmoveULEQforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private int cmoveULNEforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private int cmoveULGTforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private int cmoveULGEforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private int cmoveULLTforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private int cmoveULLEforI(long a, long b, int c, int d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for L\n-    private long cmoveULEQforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private long cmoveULNEforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private long cmoveULGTforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private long cmoveULGEforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private long cmoveULLTforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private long cmoveULLEforL(long a, long b, long c, long d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for F\n-    private float cmoveULEQforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private float cmoveULNEforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private float cmoveULGTforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private float cmoveULGEforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private float cmoveULLTforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private float cmoveULLEforF(long a, long b, float c, float d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/    L for D\n-    private double cmoveULEQforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) == 0 ? c : d;\n-    }\n-\n-    private double cmoveULNEforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) != 0 ? c : d;\n-    }\n-\n-    private double cmoveULGTforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) > 0 ? c : d;\n-    }\n-\n-    private double cmoveULGEforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n-    }\n-\n-    private double cmoveULLTforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) < 0 ? c : d;\n-    }\n-\n-    private double cmoveULLEforD(long a, long b, double c, double d) {\n-        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n-    }\n-\n-    \/\/ Float comparison\n-    private int cmoveFGTforI(float a, float b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveFGTforL(float a, float b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveFGTforF(float a, float b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveFGTforD(float a, float b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private int cmoveDGTforI(double a, double b, int c, int d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private long cmoveDGTforL(double a, double b, long c, long d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private float cmoveDGTforF(double a, double b, float c, float d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    private double cmoveDGTforD(double a, double b, double c, double d) {\n-        return (a > b) ? c : d;\n-    }\n-\n-    \/\/ Compare 2 values, and pick one of them\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveVFGT(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] > b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveVFGTSwap(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] > a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveVFLT(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] < b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveVFLTSwap(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] < a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveVFEQ(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] == b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveVDLE(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] <= b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveVDLESwap(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] <= a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveVDGE(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] >= b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveVDGESwap(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (b[i] >= a[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveVDNE(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] != b[i]) ? a[i] : b[i];\n-        }\n-    }\n-\n-    \/\/ Extensions: compare 2 values, and pick from 2 consts\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFGTforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] > b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFGEforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] >= b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFLTforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] < b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFLEforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] <= b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFEQforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] == b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFNEQforFConst(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] != b[i]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFLTforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] < b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] < b[i+1]) ? 0.1f : -0.1f;\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n-            \/\/ -> vectorize                                         -> no vectorization\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFLEforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n-            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n-            \/\/ UseCompactObjectHeaders=false                        UseCompactObjectHeaders=true\n-            \/\/ adr = base + 16 + 8*i      ->  always                adr = base + 12 + 8*i      ->  never\n-            \/\/ -> vectorize                                         -> no vectorization\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"=0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \"=0\",\n-                  IRNode.VECTOR_BLEND_F, \"=0\",\n-                  IRNode.STORE_VECTOR, \"=0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFYYforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"=0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \"=0\",\n-                  IRNode.VECTOR_BLEND_F, \"=0\",\n-                  IRNode.STORE_VECTOR, \"=0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFXXforFConstH2(float[] a, float[] b, float[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1f : -0.1f;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDGTforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] > b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDGEforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] >= b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDLTforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] < b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDLEforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] <= b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDEQforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] == b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDNEQforDConst(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i++) {\n-            c[i] = (a[i] != b[i]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDLTforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] < b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] < b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDLEforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"=0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \"=0\",\n-                  IRNode.VECTOR_BLEND_D, \"=0\",\n-                  IRNode.STORE_VECTOR, \"=0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDYYforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"=0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \"=0\",\n-                  IRNode.VECTOR_BLEND_D, \"=0\",\n-                  IRNode.STORE_VECTOR, \"=0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDXXforDConstH2(double[] a, double[] b, double[] c) {\n-        for (int i = 0; i < a.length; i+=2) {\n-            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1 : -0.1;\n-            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n-        }\n-    }\n-\n-    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n-    \/\/ Note:\n-    \/\/   To guarantee that CMove is introduced, I need to perform the loads before the branch. To ensure they\n-    \/\/   do not float down into the branches, I compute a value, and store it to r2 (same as r, except that the\n-    \/\/   compilation does not know that).\n-    \/\/   So far, vectorization only works for CMoveF\/D, with same data-width comparison (F\/I for F, D\/L for D).\n-    \/\/\n-    \/\/ Signed comparison: I\/L\n-    \/\/     I fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo F\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo D\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo F\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveLLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo D\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] == b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] != b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] >= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] < b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] <= b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/ Unsigned comparison: I\/L\n-    \/\/     I fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo F\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveUIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveUINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveUIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveUILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveUILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     I fo D\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo I\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo L\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo F\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveULLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    \/\/     L fo D\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveULLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveFGTforI(float[] a, float[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveFGTforL(float[] a, float[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFGTforF(float[] a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveFGTforD(float[] a, float[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveDGTforI(double[] a, double[] b, int[] c, int[] d, int[] r, int[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            int cc = c[i];\n-            int dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveDGTforL(double[] a, double[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveDGTforF(double[] a, double[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n-                  IRNode.VECTOR_BLEND_D, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveDGTforD(double[] a, double[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/ Use some constants in the comparison\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFGTforFCmpCon1(float a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < b.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n-                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n-                  IRNode.VECTOR_BLEND_F, \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    private static void testCMoveFGTforFCmpCon2(float[] a, float b, float[] c, float[] d, float[] r, float[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b) ? cc : dd;\n-        }\n-    }\n-\n-    \/\/ A case that is currently not supported and is not expected to vectorize\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveVDUnsupported() {\n-        double[] doublec = new double[SIZE];\n-        int seed = 1001;\n-        for (int i = 0; i < doublec.length; i++) {\n-            doublec[i] = (i % 2 == 0) ? seed + i : seed - i;\n-        }\n-    }\n-\n-    @Warmup(0)\n-    @Run(test = {\"testCMoveVFGT\", \"testCMoveVFLT\",\"testCMoveVDLE\", \"testCMoveVDGE\", \"testCMoveVFEQ\", \"testCMoveVDNE\",\n-                 \"testCMoveVFGTSwap\", \"testCMoveVFLTSwap\",\"testCMoveVDLESwap\", \"testCMoveVDGESwap\",\n-                 \"testCMoveFGTforFConst\", \"testCMoveFGEforFConst\", \"testCMoveFLTforFConst\",\n-                 \"testCMoveFLEforFConst\", \"testCMoveFEQforFConst\", \"testCMoveFNEQforFConst\",\n-                 \"testCMoveDGTforDConst\", \"testCMoveDGEforDConst\", \"testCMoveDLTforDConst\",\n-                 \"testCMoveDLEforDConst\", \"testCMoveDEQforDConst\", \"testCMoveDNEQforDConst\",\n-                 \"testCMoveFLTforFConstH2\", \"testCMoveFLEforFConstH2\",\n-                 \"testCMoveFYYforFConstH2\", \"testCMoveFXXforFConstH2\",\n-                 \"testCMoveDLTforDConstH2\", \"testCMoveDLEforDConstH2\",\n-                 \"testCMoveDYYforDConstH2\", \"testCMoveDXXforDConstH2\"})\n-    private void testCMove_runner() {\n-        float[] floata = new float[SIZE];\n-        float[] floatb = new float[SIZE];\n-        float[] floatc = new float[SIZE];\n-        double[] doublea = new double[SIZE];\n-        double[] doubleb = new double[SIZE];\n-        double[] doublec = new double[SIZE];\n-\n-        init(floata);\n-        init(floatb);\n-        init(doublea);\n-        init(doubleb);\n-\n-        testCMoveVFGT(floata, floatb, floatc);\n-        testCMoveVDLE(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatGT(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleLE(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveVFLT(floata, floatb, floatc);\n-        testCMoveVDGE(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatLT(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleGE(doublea[i], doubleb[i]));\n-        }\n-\n-        \/\/ Ensure we frequently have equals\n-        for (int i = 0; i < SIZE; i++) {\n-            if (i % 3 == 0) {\n-                floatb[i] = floata[i];\n-                doubleb[i] = doublea[i];\n-            }\n-        }\n-\n-        testCMoveVFEQ(floata, floatb, floatc);\n-        testCMoveVDNE(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatEQ(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleNE(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveVFGTSwap(floata, floatb, floatc);\n-        testCMoveVDLESwap(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatGTSwap(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleLESwap(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveVFLTSwap(floata, floatb, floatc);\n-        testCMoveVDGESwap(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFloatLTSwap(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDoubleGESwap(doublea[i], doubleb[i]));\n-        }\n-\n-        \/\/ Extensions: compare 2 values, and pick from 2 consts\n-        testCMoveFGTforFConst(floata, floatb, floatc);\n-        testCMoveDGTforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFGTforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDGTforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFGEforFConst(floata, floatb, floatc);\n-        testCMoveDGEforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFGEforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDGEforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFLTforFConst(floata, floatb, floatc);\n-        testCMoveDLTforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFLEforFConst(floata, floatb, floatc);\n-        testCMoveDLEforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFEQforFConst(floata, floatb, floatc);\n-        testCMoveDEQforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFEQforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDEQforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFNEQforFConst(floata, floatb, floatc);\n-        testCMoveDNEQforDConst(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFNEQforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDNEQforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        \/\/ Hand-unrolled (H2) examples:\n-        testCMoveFLTforFConstH2(floata, floatb, floatc);\n-        testCMoveDLTforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFLEforFConstH2(floata, floatb, floatc);\n-        testCMoveDLEforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n-            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n-        }\n-\n-        testCMoveFYYforFConstH2(floata, floatb, floatc);\n-        testCMoveDYYforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i+=2) {\n-            Asserts.assertEquals(floatc[i+0], cmoveFLEforFConst(floata[i+0], floatb[i+0]));\n-            Asserts.assertEquals(doublec[i+0], cmoveDLEforDConst(doublea[i+0], doubleb[i+0]));\n-            Asserts.assertEquals(floatc[i+1], cmoveFLTforFConst(floata[i+1], floatb[i+1]));\n-            Asserts.assertEquals(doublec[i+1], cmoveDLTforDConst(doublea[i+1], doubleb[i+1]));\n-        }\n-\n-        testCMoveFXXforFConstH2(floata, floatb, floatc);\n-        testCMoveDXXforDConstH2(doublea, doubleb, doublec);\n-        for (int i = 0; i < SIZE; i+=2) {\n-            Asserts.assertEquals(floatc[i+0], cmoveFLTforFConst(floata[i+0], floatb[i+0]));\n-            Asserts.assertEquals(doublec[i+0], cmoveDLTforDConst(doublea[i+0], doubleb[i+0]));\n-            Asserts.assertEquals(floatc[i+1], cmoveFLEforFConst(floata[i+1], floatb[i+1]));\n-            Asserts.assertEquals(doublec[i+1], cmoveDLEforDConst(doublea[i+1], doubleb[i+1]));\n-        }\n-    }\n-\n-    @Warmup(0)\n-    @Run(test = {\/\/ Signed\n-                 \/\/     I for I\n-                 \"testCMoveIEQforI\",\n-                 \"testCMoveINEforI\",\n-                 \"testCMoveIGTforI\",\n-                 \"testCMoveIGEforI\",\n-                 \"testCMoveILTforI\",\n-                 \"testCMoveILEforI\",\n-                 \/\/     I for L\n-                 \"testCMoveIEQforL\",\n-                 \"testCMoveINEforL\",\n-                 \"testCMoveIGTforL\",\n-                 \"testCMoveIGEforL\",\n-                 \"testCMoveILTforL\",\n-                 \"testCMoveILEforL\",\n-                 \/\/     I for F\n-                 \"testCMoveIEQforF\",\n-                 \"testCMoveINEforF\",\n-                 \"testCMoveIGTforF\",\n-                 \"testCMoveIGEforF\",\n-                 \"testCMoveILTforF\",\n-                 \"testCMoveILEforF\",\n-                 \/\/     I for D\n-                 \"testCMoveIEQforD\",\n-                 \"testCMoveINEforD\",\n-                 \"testCMoveIGTforD\",\n-                 \"testCMoveIGEforD\",\n-                 \"testCMoveILTforD\",\n-                 \"testCMoveILEforD\",\n-                 \/\/     L for I\n-                 \"testCMoveLEQforI\",\n-                 \"testCMoveLNEforI\",\n-                 \"testCMoveLGTforI\",\n-                 \"testCMoveLGEforI\",\n-                 \"testCMoveLLTforI\",\n-                 \"testCMoveLLEforI\",\n-                 \/\/     L for L\n-                 \"testCMoveLEQforL\",\n-                 \"testCMoveLNEforL\",\n-                 \"testCMoveLGTforL\",\n-                 \"testCMoveLGEforL\",\n-                 \"testCMoveLLTforL\",\n-                 \"testCMoveLLEforL\",\n-                 \/\/     L for F\n-                 \"testCMoveLEQforF\",\n-                 \"testCMoveLNEforF\",\n-                 \"testCMoveLGTforF\",\n-                 \"testCMoveLGEforF\",\n-                 \"testCMoveLLTforF\",\n-                 \"testCMoveLLEforF\",\n-                 \/\/     L for D\n-                 \"testCMoveLEQforD\",\n-                 \"testCMoveLNEforD\",\n-                 \"testCMoveLGTforD\",\n-                 \"testCMoveLGEforD\",\n-                 \"testCMoveLLTforD\",\n-                 \"testCMoveLLEforD\",\n-                 \/\/ Unsigned\n-                 \/\/     I for I\n-                 \"testCMoveUIEQforI\",\n-                 \"testCMoveUINEforI\",\n-                 \"testCMoveUIGTforI\",\n-                 \"testCMoveUIGEforI\",\n-                 \"testCMoveUILTforI\",\n-                 \"testCMoveUILEforI\",\n-                 \/\/     I for L\n-                 \"testCMoveUIEQforL\",\n-                 \"testCMoveUINEforL\",\n-                 \"testCMoveUIGTforL\",\n-                 \"testCMoveUIGEforL\",\n-                 \"testCMoveUILTforL\",\n-                 \"testCMoveUILEforL\",\n-                 \/\/     I for F\n-                 \"testCMoveUIEQforF\",\n-                 \"testCMoveUINEforF\",\n-                 \"testCMoveUIGTforF\",\n-                 \"testCMoveUIGEforF\",\n-                 \"testCMoveUILTforF\",\n-                 \"testCMoveUILEforF\",\n-                 \/\/     I for D\n-                 \"testCMoveUIEQforD\",\n-                 \"testCMoveUINEforD\",\n-                 \"testCMoveUIGTforD\",\n-                 \"testCMoveUIGEforD\",\n-                 \"testCMoveUILTforD\",\n-                 \"testCMoveUILEforD\",\n-                 \/\/     L for I\n-                 \"testCMoveULEQforI\",\n-                 \"testCMoveULNEforI\",\n-                 \"testCMoveULGTforI\",\n-                 \"testCMoveULGEforI\",\n-                 \"testCMoveULLTforI\",\n-                 \"testCMoveULLEforI\",\n-                 \/\/     L for L\n-                 \"testCMoveULEQforL\",\n-                 \"testCMoveULNEforL\",\n-                 \"testCMoveULGTforL\",\n-                 \"testCMoveULGEforL\",\n-                 \"testCMoveULLTforL\",\n-                 \"testCMoveULLEforL\",\n-                 \/\/     L for F\n-                 \"testCMoveULEQforF\",\n-                 \"testCMoveULNEforF\",\n-                 \"testCMoveULGTforF\",\n-                 \"testCMoveULGEforF\",\n-                 \"testCMoveULLTforF\",\n-                 \"testCMoveULLEforF\",\n-                 \/\/     L for D\n-                 \"testCMoveULEQforD\",\n-                 \"testCMoveULNEforD\",\n-                 \"testCMoveULGTforD\",\n-                 \"testCMoveULGEforD\",\n-                 \"testCMoveULLTforD\",\n-                 \"testCMoveULLEforD\",\n-                 \/\/ Float\n-                 \"testCMoveFGTforI\",\n-                 \"testCMoveFGTforL\",\n-                 \"testCMoveFGTforF\",\n-                 \"testCMoveFGTforD\",\n-                 \"testCMoveDGTforI\",\n-                 \"testCMoveDGTforL\",\n-                 \"testCMoveDGTforF\",\n-                 \"testCMoveDGTforD\",\n-                 \"testCMoveFGTforFCmpCon1\",\n-                 \"testCMoveFGTforFCmpCon2\"})\n-    private void testCMove_runner_two() {\n-        int[] aI = new int[SIZE];\n-        int[] bI = new int[SIZE];\n-        int[] cI = new int[SIZE];\n-        int[] dI = new int[SIZE];\n-        int[] rI = new int[SIZE];\n-        long[] aL = new long[SIZE];\n-        long[] bL = new long[SIZE];\n-        long[] cL = new long[SIZE];\n-        long[] dL = new long[SIZE];\n-        long[] rL = new long[SIZE];\n-        float[] aF = new float[SIZE];\n-        float[] bF = new float[SIZE];\n-        float[] cF = new float[SIZE];\n-        float[] dF = new float[SIZE];\n-        float[] rF = new float[SIZE];\n-        double[] aD = new double[SIZE];\n-        double[] bD = new double[SIZE];\n-        double[] cD = new double[SIZE];\n-        double[] dD = new double[SIZE];\n-        double[] rD = new double[SIZE];\n-\n-        init(aI);\n-        init(bI);\n-        init(cI);\n-        init(dI);\n-        init(aL);\n-        init(bL);\n-        init(cL);\n-        init(dL);\n-        init(aF);\n-        init(bF);\n-        init(cF);\n-        init(dF);\n-        init(aD);\n-        init(bD);\n-        init(cD);\n-        init(dD);\n-\n-        \/\/ Signed\n-        \/\/     I for I\n-        testCMoveIEQforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveIEQforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveINEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveINEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveIGTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveIGTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveIGEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveIGEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveILTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveILTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveILEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveILEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     I for L\n-        testCMoveIEQforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveIEQforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveINEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveINEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveIGTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveIGTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveIGEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveIGEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveILTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveILTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveILEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveILEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     I for F\n-        testCMoveIEQforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveIEQforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveINEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveINEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveIGTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveIGTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveIGEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveIGEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveILTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveILTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveILEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveILEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     I for D\n-        testCMoveIEQforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveIEQforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveINEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveINEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveIGTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveIGTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveIGEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveIGEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveILTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveILTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveILEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveILEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/     L for I\n-        testCMoveLEQforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLEQforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLNEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLNEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLGTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLGTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLGEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLGEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLLTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLLTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveLLEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveLLEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     L for L\n-        testCMoveLEQforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLEQforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLNEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLNEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLGTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLGTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLGEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLGEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLLTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLLTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveLLEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveLLEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     L for F\n-        testCMoveLEQforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLEQforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLNEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLNEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLGTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLGTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLGEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLGEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLLTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLLTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveLLEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveLLEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     L for D\n-        testCMoveLEQforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLEQforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLNEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLNEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLGTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLGTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLGEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLGEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLLTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLLTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveLLEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveLLEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/ Unsigned\n-        \/\/     I for I\n-        testCMoveUIEQforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUIEQforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUINEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUINEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUIGTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUIGTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUIGEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUIGEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUILTforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUILTforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveUILEforI(aI, bI, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveUILEforI(aI[i], bI[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     I for L\n-        testCMoveUIEQforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUIEQforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUINEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUINEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUIGTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUIGTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUIGEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUIGEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUILTforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUILTforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveUILEforL(aI, bI, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveUILEforL(aI[i], bI[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     I for F\n-        testCMoveUIEQforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUIEQforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUINEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUINEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUIGTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUIGTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUIGEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUIGEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUILTforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUILTforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveUILEforF(aI, bI, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveUILEforF(aI[i], bI[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     I for D\n-        testCMoveUIEQforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUIEQforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUINEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUINEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUIGTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUIGTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUIGEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUIGEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUILTforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUILTforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveUILEforD(aI, bI, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveUILEforD(aI[i], bI[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/     L for I\n-        testCMoveULEQforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULEQforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULNEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULNEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULGTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULGTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULGEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULGEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULLTforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULLTforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveULLEforI(aL, bL, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveULLEforI(aL[i], bL[i], cI[i], dI[i]));\n-        }\n-\n-        \/\/     L for L\n-        testCMoveULEQforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULEQforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULNEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULNEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULGTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULGTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULGEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULGEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULLTforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULLTforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveULLEforL(aL, bL, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveULLEforL(aL[i], bL[i], cL[i], dL[i]));\n-        }\n-\n-        \/\/     L for F\n-        testCMoveULEQforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULEQforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULNEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULNEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULGTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULGTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULGEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULGEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULLTforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULLTforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveULLEforF(aL, bL, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveULLEforF(aL[i], bL[i], cF[i], dF[i]));\n-        }\n-\n-        \/\/     L for D\n-        testCMoveULEQforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULEQforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULNEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULNEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULGTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULGTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULGEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULGEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULLTforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULLTforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveULLEforD(aL, bL, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveULLEforD(aL[i], bL[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/ Float\n-        testCMoveFGTforI(aF, bF, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveFGTforI(aF[i], bF[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveFGTforL(aF, bF, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveFGTforL(aF[i], bF[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveFGTforF(aF, bF, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveFGTforD(aF, bF, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveFGTforD(aF[i], bF[i], cD[i], dD[i]));\n-        }\n-\n-        testCMoveDGTforI(aD, bD, cI, dI, rI, rI);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rI[i], cmoveDGTforI(aD[i], bD[i], cI[i], dI[i]));\n-        }\n-\n-        testCMoveDGTforL(aD, bD, cL, dL, rL, rL);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rL[i], cmoveDGTforL(aD[i], bD[i], cL[i], dL[i]));\n-        }\n-\n-        testCMoveDGTforF(aD, bD, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveDGTforF(aD[i], bD[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveDGTforD(aD, bD, cD, dD, rD, rD);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rD[i], cmoveDGTforD(aD[i], bD[i], cD[i], dD[i]));\n-        }\n-\n-        \/\/ Use some constants\/invariants in the comparison\n-        testCMoveFGTforFCmpCon1(aF[0], bF, cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[0], bF[i], cF[i], dF[i]));\n-        }\n-\n-        testCMoveFGTforFCmpCon2(aF, bF[0], cF, dF, rF, rF);\n-        for (int i = 0; i < SIZE; i++) {\n-            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[0], cF[i], dF[i]));\n-        }\n-    }\n-\n-    private static void init(int[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = RANDOM.nextInt();\n-        }\n-    }\n-\n-    private static void init(long[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = RANDOM.nextLong();\n-        }\n-    }\n-\n-    private static void init(float[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = switch(RANDOM.nextInt() % 20) {\n-                case 0  -> Float.NaN;\n-                case 1  -> 0;\n-                case 2  -> 1;\n-                case 3  -> Float.POSITIVE_INFINITY;\n-                case 4  -> Float.NEGATIVE_INFINITY;\n-                case 5  -> Float.MAX_VALUE;\n-                case 6  -> Float.MIN_VALUE;\n-                case 7, 8, 9 -> RANDOM.nextFloat();\n-                default -> Float.intBitsToFloat(RANDOM.nextInt());\n-            };\n-        }\n-    }\n-\n-    private static void init(double[] a) {\n-        for (int i = 0; i < SIZE; i++) {\n-            a[i] = switch(RANDOM.nextInt() % 20) {\n-                case 0  -> Double.NaN;\n-                case 1  -> 0;\n-                case 2  -> 1;\n-                case 3  -> Double.POSITIVE_INFINITY;\n-                case 4  -> Double.NEGATIVE_INFINITY;\n-                case 5  -> Double.MAX_VALUE;\n-                case 6  -> Double.MIN_VALUE;\n-                case 7, 8, 9 -> RANDOM.nextDouble();\n-                default -> Double.longBitsToDouble(RANDOM.nextLong());\n-            };\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":0,"deletions":3218,"binary":false,"changes":3218,"status":"deleted"},{"patch":"@@ -613,0 +613,5 @@\n+    public static final String CMP_N = PREFIX + \"CMP_N\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_N, \"CmpN\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}