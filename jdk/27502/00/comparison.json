{"files":[{"patch":"@@ -46,1 +46,2 @@\n-  _degen_point(ShenandoahGC::_degenerated_outside_cycle) {\n+  _degen_point(ShenandoahGC::_degenerated_outside_cycle),\n+  _control_lock(Mutex::nosafepoint - 2, \"ShenandoahGCRequest_lock\", true) {\n@@ -231,1 +232,3 @@\n-    os::naked_short_sleep(sleep);\n+\n+    MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+    ml.wait(sleep);\n@@ -346,0 +349,10 @@\n+void ShenandoahControlThread::notify_control_thread(GCCause::Cause cause) {\n+  \/\/ Although setting gc request is under _controller_lock, the read side (run_service())\n+  \/\/ does not take the lock. We need to enforce following order, so that read side sees\n+  \/\/ latest requested gc cause when the flag is set.\n+  MonitorLocker controller(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  _requested_gc_cause = cause;\n+  _gc_requested.set();\n+  controller.notify();\n+}\n+\n@@ -357,2 +370,1 @@\n-    _requested_gc_cause = cause;\n-    _gc_requested.set();\n+    notify_control_thread(cause);\n@@ -375,6 +387,1 @@\n-    \/\/ Although setting gc request is under _gc_waiters_lock, but read side (run_service())\n-    \/\/ does not take the lock. We need to enforce following order, so that read side sees\n-    \/\/ latest requested gc cause when the flag is set.\n-    _requested_gc_cause = cause;\n-    _gc_requested.set();\n-\n+    notify_control_thread(cause);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+  \/\/ This lock is used to coordinate waking up the control thread\n+  Monitor _control_lock;\n+\n@@ -59,0 +62,2 @@\n+  \/\/ Sets the requested cause and flag and notifies the control thread\n+  void notify_control_thread(GCCause::Cause cause);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}