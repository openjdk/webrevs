{"files":[{"patch":"@@ -54,0 +54,9 @@\n+address NativeCall::destination() const {\n+  \/\/ Getting the destination of a call isn't safe because that call can\n+  \/\/ be getting patched while you're calling this.  There's only special\n+  \/\/ places where this can be called but not automatically verifiable by\n+  \/\/ checking which locks are held.  The solution is true atomic patching\n+  \/\/ on x86, nyi.\n+  return return_address() + displacement();\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -127,8 +127,1 @@\n-  address destination() const {\n-    \/\/ Getting the destination of a call isn't safe because that call can\n-    \/\/ be getting patched while you're calling this.  There's only special\n-    \/\/ places where this can be called but not automatically verifiable by\n-    \/\/ checking which locks are held.  The solution is true atomic patching\n-    \/\/ on x86, nyi.\n-    return return_address() + displacement();\n-  }\n+  address destination() const;\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"}]}