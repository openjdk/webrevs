{"files":[{"patch":"@@ -272,8 +272,6 @@\n-  HeapRootSegments() {}\n-  HeapRootSegments(size_t base_offset, int roots_count, int max_size_in_bytes, int max_size_in_elems) :\n-          _base_offset(base_offset),\n-          _count((roots_count + max_size_in_elems - 1) \/ max_size_in_elems),\n-          _roots_count(roots_count),\n-          _max_size_in_bytes(max_size_in_bytes),\n-          _max_size_in_elems(max_size_in_elems) {\n-    assert(is_power_of_2(_max_size_in_bytes), \"must be\");\n+  \/\/ Trivial copy assignments are allowed to copy the entire object representation.\n+  \/\/ We also inline this class into archive header. Therefore, it is important to make\n+  \/\/ sure any gaps in object representation are initialized to zeroes. This is why\n+  \/\/ constructors memset before doing field assignments.\n+  HeapRootSegments() {\n+    memset(this, 0, sizeof(*this));\n@@ -281,0 +279,13 @@\n+  HeapRootSegments(size_t base_offset, int roots_count, int max_size_in_bytes, int max_size_in_elems) {\n+    assert(is_power_of_2(max_size_in_bytes), \"must be\");\n+    memset(this, 0, sizeof(*this));\n+    _base_offset = base_offset;\n+    _count = (roots_count + max_size_in_elems - 1) \/ max_size_in_elems;\n+    _roots_count = roots_count;\n+    _max_size_in_bytes = max_size_in_bytes;\n+    _max_size_in_elems = max_size_in_elems;\n+  }\n+\n+  \/\/ This class is trivially copyable and assignable.\n+  HeapRootSegments(const HeapRootSegments&) = default;\n+  HeapRootSegments& operator=(const HeapRootSegments&) = default;\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"}]}