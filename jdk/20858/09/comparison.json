{"files":[{"patch":"@@ -1107,0 +1107,11 @@\n+    HeapRootSegments segments = heap_info->heap_root_segments();\n+    assert(segments.base_offset() == 0, \"Sanity\");\n+\n+    for (size_t seg_idx = 0; seg_idx < segments.count(); seg_idx++) {\n+      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n+      st.print_cr(PTR_FORMAT \": Heap roots segment [%d]\",\n+                  p2i(requested_start), segments.size_in_elems(seg_idx));\n+      start += segments.size_in_bytes(seg_idx);\n+    }\n+    log_heap_roots();\n+\n@@ -1117,6 +1128,0 @@\n-      } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n-        \/\/ HeapShared::roots() is copied specially, so it doesn't exist in\n-        \/\/ ArchiveHeapWriter::BufferOffsetToSourceObjectTable.\n-        \/\/ See ArchiveHeapWriter::copy_roots_to_buffer().\n-        st.print_cr(\"HeapShared::roots[%d]\", HeapShared::pending_roots()->length());\n-        byte_size = ArchiveHeapWriter::heap_roots_word_size() * BytesPerWord;\n@@ -1135,2 +1140,0 @@\n-      } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n-        log_heap_roots();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -377,2 +377,12 @@\n-    intptr_t roots_oop = bottom + FileMapInfo::current_info()->heap_roots_offset();\n-    HeapShared::init_roots(cast_to_oop(roots_oop));\n+\n+    \/\/ The heap roots are stored in one or more segments that are laid out consecutively.\n+    \/\/ The byte size of each segment (except for the last one) is max_size.\n+    HeapRootSegments segments = FileMapInfo::current_info()->heap_root_segments();\n+    int max_size = segments.max_size_in_bytes();\n+    HeapShared::init_root_segment_sizes(max_size);\n+    intptr_t first_segment_addr = bottom + segments.base_offset();\n+    for (size_t c = 0; c < segments.count(); c++) {\n+      oop segment_oop = cast_to_oop(first_segment_addr + (c * max_size));\n+      assert(segment_oop->is_objArray(), \"Must be\");\n+      HeapShared::add_root_segment((objArrayOop)segment_oop);\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-size_t ArchiveHeapWriter::_heap_roots_offset;\n@@ -57,1 +56,2 @@\n-size_t ArchiveHeapWriter::_heap_roots_word_size;\n+\/\/ Heap root segments\n+HeapRootSegments ArchiveHeapWriter::_heap_root_segments;\n@@ -167,4 +167,0 @@\n-oop ArchiveHeapWriter::heap_roots_requested_address() {\n-  return cast_to_oop(_requested_bottom + _heap_roots_offset);\n-}\n-\n@@ -189,9 +185,3 @@\n-void ArchiveHeapWriter::copy_roots_to_buffer(GrowableArrayCHeap<oop, mtClassShared>* roots) {\n-  Klass* k = Universe::objectArrayKlass(); \/\/ already relocated to point to archived klass\n-  int length = roots->length();\n-  _heap_roots_word_size = objArrayOopDesc::object_size(length);\n-  size_t byte_size = _heap_roots_word_size * HeapWordSize;\n-  if (byte_size >= MIN_GC_REGION_ALIGNMENT) {\n-    log_error(cds, heap)(\"roots array is too large. Please reduce the number of classes\");\n-    vm_exit(1);\n-  }\n+objArrayOop ArchiveHeapWriter::allocate_root_segment(size_t offset, int element_count) {\n+  HeapWord* mem = offset_to_buffered_address<HeapWord *>(offset);\n+  memset(mem, 0, objArrayOopDesc::object_size(element_count));\n@@ -199,4 +189,6 @@\n-  maybe_fill_gc_region_gap(byte_size);\n-\n-  size_t new_used = _buffer_used + byte_size;\n-  ensure_buffer_space(new_used);\n+  \/\/ The initialization code is copied from MemAllocator::finish and ObjArrayAllocator::initialize.\n+  oopDesc::set_mark(mem, markWord::prototype());\n+  oopDesc::release_set_klass(mem, Universe::objectArrayKlass());\n+  arrayOopDesc::set_length(mem, element_count);\n+  return objArrayOop(cast_to_oop(mem));\n+}\n@@ -204,10 +196,6 @@\n-  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_used);\n-  memset(mem, 0, byte_size);\n-  {\n-    \/\/ This is copied from MemAllocator::finish\n-    oopDesc::set_mark(mem, markWord::prototype());\n-    oopDesc::release_set_klass(mem, k);\n-  }\n-  {\n-    \/\/ This is copied from ObjArrayAllocator::initialize\n-    arrayOopDesc::set_length(mem, length);\n+void ArchiveHeapWriter::root_segment_at_put(objArrayOop segment, int index, oop root) {\n+  \/\/ Do not use arrayOop->obj_at_put(i, o) as arrayOop is outside the real heap!\n+  if (UseCompressedOops) {\n+    *segment->obj_at_addr<narrowOop>(index) = CompressedOops::encode(root);\n+  } else {\n+    *segment->obj_at_addr<oop>(index) = root;\n@@ -215,0 +203,1 @@\n+}\n@@ -216,8 +205,38 @@\n-  objArrayOop arrayOop = objArrayOop(cast_to_oop(mem));\n-  for (int i = 0; i < length; i++) {\n-    \/\/ Do not use arrayOop->obj_at_put(i, o) as arrayOop is outside of the real heap!\n-    oop o = roots->at(i);\n-    if (UseCompressedOops) {\n-      * arrayOop->obj_at_addr<narrowOop>(i) = CompressedOops::encode(o);\n-    } else {\n-      * arrayOop->obj_at_addr<oop>(i) = o;\n+void ArchiveHeapWriter::copy_roots_to_buffer(GrowableArrayCHeap<oop, mtClassShared>* roots) {\n+  \/\/ Depending on the number of classes we are archiving, a single roots array may be\n+  \/\/ larger than MIN_GC_REGION_ALIGNMENT. Roots are allocated first in the buffer, which\n+  \/\/ allows us to chop the large array into a series of \"segments\". Current layout\n+  \/\/ starts with zero or more segments exactly fitting MIN_GC_REGION_ALIGNMENT, and end\n+  \/\/ with a single segment that may be smaller than MIN_GC_REGION_ALIGNMENT.\n+  \/\/ This is simple and efficient. We do not need filler objects anywhere between the segments,\n+  \/\/ or immediately after the last segment. This allows starting the object dump immediately\n+  \/\/ after the roots.\n+\n+  assert((_buffer_used % MIN_GC_REGION_ALIGNMENT) == 0,\n+         \"Pre-condition: Roots start at aligned boundary: \" SIZE_FORMAT, _buffer_used);\n+\n+  int max_elem_count = ((MIN_GC_REGION_ALIGNMENT - arrayOopDesc::header_size_in_bytes()) \/ heapOopSize);\n+  assert(objArrayOopDesc::object_size(max_elem_count)*HeapWordSize == MIN_GC_REGION_ALIGNMENT,\n+         \"Should match exactly\");\n+\n+  HeapRootSegments segments(_buffer_used,\n+                            roots->length(),\n+                            MIN_GC_REGION_ALIGNMENT,\n+                            max_elem_count);\n+\n+  for (size_t seg_idx = 0; seg_idx < segments.count(); seg_idx++) {\n+    int size_elems = segments.size_in_elems(seg_idx);\n+    size_t size_bytes = segments.size_in_bytes(seg_idx);\n+\n+    size_t oop_offset = _buffer_used;\n+    _buffer_used = oop_offset + size_bytes;\n+    ensure_buffer_space(_buffer_used);\n+\n+    assert((oop_offset % MIN_GC_REGION_ALIGNMENT) == 0,\n+           \"Roots segment \" SIZE_FORMAT \" start is not aligned: \" SIZE_FORMAT,\n+           segments.count(), oop_offset);\n+\n+    int root_index = 0;\n+    objArrayOop seg_oop = allocate_root_segment(oop_offset, size_elems);\n+    for (int i = 0; i < size_elems; i++) {\n+      root_segment_at_put(seg_oop, i, roots->at(root_index++));\n@@ -225,0 +244,3 @@\n+\n+    log_info(cds, heap)(\"archived obj root segment [%d] = \" SIZE_FORMAT \" bytes, obj = \" PTR_FORMAT,\n+                        size_elems, size_bytes, p2i(seg_oop));\n@@ -226,1 +248,0 @@\n-  log_info(cds, heap)(\"archived obj roots[%d] = \" SIZE_FORMAT \" bytes, klass = %p, obj = %p\", length, byte_size, k, mem);\n@@ -228,2 +249,1 @@\n-  _heap_roots_offset = _buffer_used;\n-  _buffer_used = new_used;\n+  _heap_root_segments = segments;\n@@ -285,0 +305,4 @@\n+  \/\/ There could be multiple root segments, which we want to be aligned by region.\n+  \/\/ Putting them ahead of objects makes sure we waste no space.\n+  copy_roots_to_buffer(roots);\n+\n@@ -298,2 +322,0 @@\n-  copy_roots_to_buffer(roots);\n-\n@@ -458,1 +480,1 @@\n-  info->set_heap_roots_offset(_heap_roots_offset);\n+  info->set_heap_root_segments(_heap_root_segments);\n@@ -546,6 +568,0 @@\n-\/\/ Relocate an element in the buffered copy of HeapShared::roots()\n-template <typename T> void ArchiveHeapWriter::relocate_root_at(oop requested_roots, int index, CHeapBitMap* oopmap) {\n-  size_t offset = (size_t)((objArrayOop)requested_roots)->obj_at_offset<T>(index);\n-  relocate_field_in_buffer<T>((T*)(buffered_heap_roots_addr() + offset), oopmap);\n-}\n-\n@@ -603,4 +619,8 @@\n-  oop requested_roots = requested_obj_from_buffer_offset(_heap_roots_offset);\n-  update_header_for_requested_obj(requested_roots, nullptr, Universe::objectArrayKlass());\n-  int length = roots != nullptr ? roots->length() : 0;\n-  for (int i = 0; i < length; i++) {\n+  for (size_t seg_idx = 0; seg_idx < _heap_root_segments.count(); seg_idx++) {\n+    size_t seg_offset = _heap_root_segments.segment_offset(seg_idx);\n+\n+    objArrayOop requested_obj = (objArrayOop)requested_obj_from_buffer_offset(seg_offset);\n+    update_header_for_requested_obj(requested_obj, nullptr, Universe::objectArrayKlass());\n+    address buffered_obj = offset_to_buffered_address<address>(seg_offset);\n+    int length = _heap_root_segments.size_in_elems(seg_idx);\n+\n@@ -608,1 +628,4 @@\n-      relocate_root_at<narrowOop>(requested_roots, i, heap_info->oopmap());\n+      for (int i = 0; i < length; i++) {\n+        narrowOop* addr = (narrowOop*)(buffered_obj + objArrayOopDesc::obj_at_offset<narrowOop>(i));\n+        relocate_field_in_buffer<narrowOop>(addr, heap_info->oopmap());\n+      }\n@@ -610,1 +633,4 @@\n-      relocate_root_at<oop>(requested_roots, i, heap_info->oopmap());\n+      for (int i = 0; i < length; i++) {\n+        oop* addr = (oop*)(buffered_obj + objArrayOopDesc::obj_at_offset<oop>(i));\n+        relocate_field_in_buffer<oop>(addr, heap_info->oopmap());\n+      }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":81,"deletions":55,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-  size_t _heap_roots_offset;            \/\/ Offset of the HeapShared::roots() object, from the bottom\n-                                        \/\/ of the archived heap objects, in bytes.\n+  HeapRootSegments _heap_root_segments;\n@@ -60,2 +59,2 @@\n-  void set_heap_roots_offset(size_t n) { _heap_roots_offset = n; }\n-  size_t heap_roots_offset() const { return _heap_roots_offset; }\n+  void set_heap_root_segments(HeapRootSegments segments) { _heap_root_segments = segments; };\n+  HeapRootSegments heap_root_segments() { return _heap_root_segments; }\n@@ -133,3 +132,2 @@\n-  \/\/ The bottom of the copy of Heap::roots() inside this->_buffer.\n-  static size_t _heap_roots_offset;\n-  static size_t _heap_roots_word_size;\n+  \/\/ The heap root segments information.\n+  static HeapRootSegments _heap_root_segments;\n@@ -196,0 +194,2 @@\n+  static void root_segment_at_put(objArrayOop segment, int index, oop root);\n+  static objArrayOop allocate_root_segment(size_t offset, int element_count);\n@@ -222,1 +222,0 @@\n-  template <typename T> static void relocate_root_at(oop requested_roots, int index, CHeapBitMap* oopmap);\n@@ -237,7 +236,0 @@\n-  static oop heap_roots_requested_address(); \/\/ requested address of HeapShared::roots()\n-  static address buffered_heap_roots_addr() {\n-    return offset_to_buffered_address<address>(_heap_roots_offset);\n-  }\n-  static size_t heap_roots_word_size() {\n-    return _heap_roots_word_size;\n-  }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -372,0 +372,21 @@\n+\n+size_t HeapRootSegments::size_in_bytes(size_t seg_idx) {\n+  assert(seg_idx < _count, \"In range\");\n+  return objArrayOopDesc::object_size(size_in_elems(seg_idx)) * HeapWordSize;\n+}\n+\n+int HeapRootSegments::size_in_elems(size_t seg_idx) {\n+  assert(seg_idx < _count, \"In range\");\n+  if (seg_idx != _count - 1) {\n+    return _max_size_in_elems;\n+  } else {\n+    \/\/ Last slice, leftover\n+    return _roots_count % _max_size_in_elems;\n+  }\n+}\n+\n+size_t HeapRootSegments::segment_offset(size_t seg_idx) {\n+  assert(seg_idx < _count, \"In range\");\n+  return _base_offset + seg_idx * _max_size_in_bytes;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -253,0 +253,41 @@\n+class HeapRootSegments {\n+private:\n+  size_t _base_offset;\n+  size_t _count;\n+  int _roots_count;\n+  int _max_size_in_bytes;\n+  int _max_size_in_elems;\n+\n+public:\n+  size_t base_offset() { return _base_offset; }\n+  size_t count() { return _count; }\n+  int roots_count() { return _roots_count; }\n+  int max_size_in_bytes() { return _max_size_in_bytes; }\n+  int max_size_in_elems() { return _max_size_in_elems; }\n+\n+  size_t size_in_bytes(size_t seg_idx);\n+  int size_in_elems(size_t seg_idx);\n+  size_t segment_offset(size_t seg_idx);\n+\n+  \/\/ Trivial copy assignments are allowed to copy the entire object representation.\n+  \/\/ We also inline this class into archive header. Therefore, it is important to make\n+  \/\/ sure any gaps in object representation are initialized to zeroes. This is why\n+  \/\/ constructors memset before doing field assignments.\n+  HeapRootSegments() {\n+    memset(this, 0, sizeof(*this));\n+  }\n+  HeapRootSegments(size_t base_offset, int roots_count, int max_size_in_bytes, int max_size_in_elems) {\n+    assert(is_power_of_2(max_size_in_bytes), \"must be\");\n+    memset(this, 0, sizeof(*this));\n+    _base_offset = base_offset;\n+    _count = (roots_count + max_size_in_elems - 1) \/ max_size_in_elems;\n+    _roots_count = roots_count;\n+    _max_size_in_bytes = max_size_in_bytes;\n+    _max_size_in_elems = max_size_in_elems;\n+  }\n+\n+  \/\/ This class is trivially copyable and assignable.\n+  HeapRootSegments(const HeapRootSegments&) = default;\n+  HeapRootSegments& operator=(const HeapRootSegments&) = default;\n+};\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -292,1 +292,5 @@\n-  st->print_cr(\"- heap_roots_offset:              \" SIZE_FORMAT, _heap_roots_offset);\n+  st->print_cr(\"- heap_root_segments.roots_count: %d\" , _heap_root_segments.roots_count());\n+  st->print_cr(\"- heap_root_segments.base_offset: \" SIZE_FORMAT_X, _heap_root_segments.base_offset());\n+  st->print_cr(\"- heap_root_segments.count:       \" SIZE_FORMAT, _heap_root_segments.count());\n+  st->print_cr(\"- heap_root_segments.max_size_elems: %d\", _heap_root_segments.max_size_in_elems());\n+  st->print_cr(\"- heap_root_segments.max_size_bytes: %d\", _heap_root_segments.max_size_in_bytes());\n@@ -1650,1 +1654,1 @@\n-  header()->set_heap_roots_offset(heap_info->heap_roots_offset());\n+  header()->set_heap_root_segments(heap_info->heap_root_segments());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/archiveUtils.hpp\"\n@@ -228,2 +229,1 @@\n-  size_t _heap_roots_offset;            \/\/ Offset of the HeapShared::roots() object, from the bottom\n-                                        \/\/ of the archived heap objects, in bytes.\n+  HeapRootSegments _heap_root_segments; \/\/ Heap root segments info\n@@ -273,1 +273,1 @@\n-  size_t heap_roots_offset()               const { return _heap_roots_offset; }\n+  HeapRootSegments heap_root_segments()    const { return _heap_root_segments; }\n@@ -288,1 +288,1 @@\n-  void set_heap_roots_offset(size_t n)           { _heap_roots_offset = n; }\n+  void set_heap_root_segments(HeapRootSegments segments) { _heap_root_segments = segments; }\n@@ -388,1 +388,1 @@\n-  size_t  heap_roots_offset()  const { return header()->heap_roots_offset(); }\n+  HeapRootSegments heap_root_segments() const { return header()->heap_root_segments(); }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -136,1 +136,3 @@\n-OopHandle HeapShared::_roots;\n+GrowableArrayCHeap<OopHandle, mtClassShared>* HeapShared::_root_segments;\n+int HeapShared::_root_segment_max_size_shift;\n+int HeapShared::_root_segment_max_size_mask;\n@@ -228,1 +230,1 @@\n-objArrayOop HeapShared::roots() {\n+objArrayOop HeapShared::root_segment(int segment_idx) {\n@@ -238,3 +240,3 @@\n-  objArrayOop roots = (objArrayOop)_roots.resolve();\n-  assert(roots != nullptr, \"should have been initialized\");\n-  return roots;\n+  objArrayOop segment = (objArrayOop)_root_segments->at(segment_idx).resolve();\n+  assert(segment != nullptr, \"should have been initialized\");\n+  return segment;\n@@ -245,0 +247,2 @@\n+  assert(_root_segment_max_size_shift > 0, \"sanity\");\n+  assert(_root_segment_max_size_mask  > 0, \"sanity\");\n@@ -247,2 +251,4 @@\n-  assert(!_roots.is_empty(), \"must have loaded shared heap\");\n-  oop result = roots()->obj_at(index);\n+  assert(!_root_segments->is_empty(), \"must have loaded shared heap\");\n+  int seg_idx = index >> _root_segment_max_size_shift;\n+  int int_idx = index &  _root_segment_max_size_mask;\n+  oop result = root_segment(seg_idx)->obj_at(int_idx);\n@@ -259,0 +265,4 @@\n+    assert(_root_segment_max_size_shift > 0, \"sanity\");\n+    assert(_root_segment_max_size_mask  > 0, \"sanity\");\n+    int seg_idx = index >> _root_segment_max_size_shift;\n+    int int_idx = index &  _root_segment_max_size_mask;\n@@ -260,1 +270,1 @@\n-      oop old = roots()->obj_at(index);\n+      oop old = root_segment(seg_idx)->obj_at(int_idx);\n@@ -263,1 +273,1 @@\n-    roots()->obj_at_put(index, nullptr);\n+    root_segment(seg_idx)->obj_at_put(int_idx, nullptr);\n@@ -767,4 +777,5 @@\n-void HeapShared::init_roots(oop roots_oop) {\n-  if (roots_oop != nullptr) {\n-    assert(ArchiveHeapLoader::is_in_use(), \"must be\");\n-    _roots = OopHandle(Universe::vm_global(), roots_oop);\n+void HeapShared::add_root_segment(objArrayOop segment_oop) {\n+  assert(segment_oop != nullptr, \"must be\");\n+  assert(ArchiveHeapLoader::is_in_use(), \"must be\");\n+  if (_root_segments == nullptr) {\n+    _root_segments = new GrowableArrayCHeap<OopHandle, mtClassShared>(10);\n@@ -772,0 +783,7 @@\n+  _root_segments->push(OopHandle(Universe::vm_global(), segment_oop));\n+}\n+\n+void HeapShared::init_root_segment_sizes(int max_size) {\n+  assert(is_power_of_2(max_size), \"must be\");\n+  _root_segment_max_size_shift = log2i_exact(max_size);\n+  _root_segment_max_size_mask = max_size - 1;\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -293,1 +293,3 @@\n-  static OopHandle _roots;\n+  static GrowableArrayCHeap<OopHandle, mtClassShared>* _root_segments;\n+  static int _root_segment_max_size_shift;\n+  static int _root_segment_max_size_mask;\n@@ -402,1 +404,1 @@\n-  static objArrayOop roots();\n+  static objArrayOop root_segment(int segment_idx);\n@@ -425,1 +427,2 @@\n-  static void init_roots(oop roots_oop) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void add_root_segment(objArrayOop segment_oop) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void init_root_segment_sizes(int max_size) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}