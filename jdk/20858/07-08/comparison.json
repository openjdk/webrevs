{"files":[{"patch":"@@ -54,9 +54,0 @@\n-address NativeCall::destination() const {\n-  \/\/ Getting the destination of a call isn't safe because that call can\n-  \/\/ be getting patched while you're calling this.  There's only special\n-  \/\/ places where this can be called but not automatically verifiable by\n-  \/\/ checking which locks are held.  The solution is true atomic patching\n-  \/\/ on x86, nyi.\n-  return return_address() + displacement();\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -127,1 +127,8 @@\n-  address destination() const;\n+  address destination() const {\n+    \/\/ Getting the destination of a call isn't safe because that call can\n+    \/\/ be getting patched while you're calling this.  There's only special\n+    \/\/ places where this can be called but not automatically verifiable by\n+    \/\/ checking which locks are held.  The solution is true atomic patching\n+    \/\/ on x86, nyi.\n+    return return_address() + displacement();\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -374,0 +374,1 @@\n+  assert(seg_idx < _count, \"In range\");\n@@ -388,0 +389,1 @@\n+  assert(seg_idx < _count, \"In range\");\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-  st->print_cr(\"- heap_root_segments.base_offset: \" SIZE_FORMAT, _heap_root_segments.base_offset());\n+  st->print_cr(\"- heap_root_segments.base_offset: \" SIZE_FORMAT_X, _heap_root_segments.base_offset());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}