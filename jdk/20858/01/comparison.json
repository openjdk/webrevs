{"files":[{"patch":"@@ -1107,0 +1107,11 @@\n+    HeapRoots roots = heap_info->heap_roots();\n+    assert(roots.base_offset() == 0, \"Sanity\");\n+\n+    for (size_t seg_idx = 0; seg_idx < roots.segment_count(); seg_idx++) {\n+      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n+      st.print_cr(PTR_FORMAT \": Heap roots segment [%d]\",\n+               p2i(requested_start), roots.length_for_segment(seg_idx));\n+      start += roots.byte_size_for_segment(seg_idx);\n+    }\n+    log_heap_roots();\n+\n@@ -1117,6 +1128,0 @@\n-      } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n-        \/\/ HeapShared::roots() is copied specially, so it doesn't exist in\n-        \/\/ ArchiveHeapWriter::BufferOffsetToSourceObjectTable.\n-        \/\/ See ArchiveHeapWriter::copy_roots_to_buffer().\n-        st.print_cr(\"HeapShared::roots[%d]\", HeapShared::pending_roots()->length());\n-        byte_size = ArchiveHeapWriter::heap_roots_word_size() * BytesPerWord;\n@@ -1135,2 +1140,0 @@\n-      } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n-        log_heap_roots();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -377,2 +377,8 @@\n-    intptr_t roots_oop = bottom + FileMapInfo::current_info()->heap_roots_offset();\n-    HeapShared::init_roots(cast_to_oop(roots_oop));\n+\n+    HeapRoots roots = FileMapInfo::current_info()->heap_roots();\n+    size_t max_size = roots.segment_max_size_bytes();\n+    HeapShared::init_root_segment_max_size(max_size);\n+    intptr_t base_roots_oop = bottom + roots.base_offset();\n+    for (size_t c = 0; c < roots.segment_count(); c++) {\n+      HeapShared::add_root_segment(cast_to_oop(base_roots_oop + (c * max_size)));\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-size_t ArchiveHeapWriter::_heap_roots_offset;\n@@ -57,1 +56,2 @@\n-size_t ArchiveHeapWriter::_heap_roots_word_size;\n+\/\/ Heap root segments\n+HeapRoots ArchiveHeapWriter::_heap_roots;\n@@ -167,4 +167,0 @@\n-oop ArchiveHeapWriter::heap_roots_requested_address() {\n-  return cast_to_oop(_requested_bottom + _heap_roots_offset);\n-}\n-\n@@ -189,9 +185,3 @@\n-void ArchiveHeapWriter::copy_roots_to_buffer(GrowableArrayCHeap<oop, mtClassShared>* roots) {\n-  Klass* k = Universe::objectArrayKlass(); \/\/ already relocated to point to archived klass\n-  int length = roots->length();\n-  _heap_roots_word_size = objArrayOopDesc::object_size(length);\n-  size_t byte_size = _heap_roots_word_size * HeapWordSize;\n-  if (byte_size >= MIN_GC_REGION_ALIGNMENT) {\n-    log_error(cds, heap)(\"roots array is too large. Please reduce the number of classes\");\n-    vm_exit(1);\n-  }\n+objArrayOop ArchiveHeapWriter::manifest_root_segment(size_t offset, int element_count) {\n+  HeapWord* mem = offset_to_buffered_address<HeapWord *>(offset);\n+  memset(mem, 0, objArrayOopDesc::object_size(element_count));\n@@ -199,4 +189,6 @@\n-  maybe_fill_gc_region_gap(byte_size);\n-\n-  size_t new_used = _buffer_used + byte_size;\n-  ensure_buffer_space(new_used);\n+  \/\/ The initialization code is copied from MemAllocator::finish and ObjArrayAllocator::initialize.\n+  oopDesc::set_mark(mem, markWord::prototype());\n+  oopDesc::release_set_klass(mem, Universe::objectArrayKlass());\n+  arrayOopDesc::set_length(mem, element_count);\n+  return objArrayOop(cast_to_oop(mem));\n+}\n@@ -204,10 +196,6 @@\n-  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_used);\n-  memset(mem, 0, byte_size);\n-  {\n-    \/\/ This is copied from MemAllocator::finish\n-    oopDesc::set_mark(mem, markWord::prototype());\n-    oopDesc::release_set_klass(mem, k);\n-  }\n-  {\n-    \/\/ This is copied from ObjArrayAllocator::initialize\n-    arrayOopDesc::set_length(mem, length);\n+void ArchiveHeapWriter::root_segment_at_put(objArrayOop segment, int index, oop root) {\n+  \/\/ Do not use arrayOop->obj_at_put(i, o) as arrayOop is outside the real heap!\n+  if (UseCompressedOops) {\n+    *segment->obj_at_addr<narrowOop>(index) = CompressedOops::encode(root);\n+  } else {\n+    *segment->obj_at_addr<oop>(index) = root;\n@@ -215,0 +203,1 @@\n+}\n@@ -216,8 +205,38 @@\n-  objArrayOop arrayOop = objArrayOop(cast_to_oop(mem));\n-  for (int i = 0; i < length; i++) {\n-    \/\/ Do not use arrayOop->obj_at_put(i, o) as arrayOop is outside of the real heap!\n-    oop o = roots->at(i);\n-    if (UseCompressedOops) {\n-      * arrayOop->obj_at_addr<narrowOop>(i) = CompressedOops::encode(o);\n-    } else {\n-      * arrayOop->obj_at_addr<oop>(i) = o;\n+void ArchiveHeapWriter::copy_roots_to_buffer(GrowableArrayCHeap<oop, mtClassShared>* roots) {\n+  \/\/ Depending on the number of classes we are archiving, a single roots array may be\n+  \/\/ larger than MIN_GC_REGION_ALIGNMENT. Roots are allocated first in the buffer, which\n+  \/\/ allows us to chop the large array into a series of \"segments\". Current layout\n+  \/\/ starts with zero or more segments exactly fitting MIN_GC_REGION_ALIGNMENT, and end\n+  \/\/ with a single segment that may be smaller than MIN_GC_REGION_ALIGNMENT.\n+  \/\/ This is simple and efficient. We do not need filler objects anywhere between the segments,\n+  \/\/ or immediately after the last segment. This allows starting the object dump immediately\n+  \/\/ after the roots.\n+\n+  assert((_buffer_used % MIN_GC_REGION_ALIGNMENT) == 0,\n+         \"Pre-condition: Roots start at aligned boundary: \" SIZE_FORMAT, _buffer_used);\n+\n+  int max_elem_count = ((MIN_GC_REGION_ALIGNMENT - arrayOopDesc::header_size_in_bytes()) \/ heapOopSize);\n+  assert(objArrayOopDesc::object_size(max_elem_count)*HeapWordSize == MIN_GC_REGION_ALIGNMENT,\n+         \"Should match exactly\");\n+\n+  HeapRoots heap_roots(_buffer_used,\n+                       roots->length(),\n+                       MIN_GC_REGION_ALIGNMENT,\n+                       max_elem_count);\n+\n+  for (size_t seg_idx = 0; seg_idx < heap_roots.segment_count(); seg_idx++) {\n+    int elem_count = heap_roots.length_for_segment(seg_idx);\n+    size_t bytes_size = objArrayOopDesc::object_size(elem_count) * HeapWordSize;\n+\n+    size_t oop_offset = _buffer_used;\n+    _buffer_used = oop_offset + bytes_size;\n+    ensure_buffer_space(_buffer_used);\n+\n+    assert((oop_offset % MIN_GC_REGION_ALIGNMENT) == 0,\n+           \"Roots segment \" SIZE_FORMAT \" start is not aligned: \" SIZE_FORMAT,\n+           heap_roots.segment_count(), oop_offset);\n+\n+    int seg_start = heap_roots.segment_start_elems(seg_idx);\n+    objArrayOop seg_oop = manifest_root_segment(oop_offset, elem_count);\n+    for (int i = 0; i < elem_count; i++) {\n+      root_segment_at_put(seg_oop, i, roots->at(seg_start + i));\n@@ -225,0 +244,3 @@\n+\n+    log_info(cds, heap)(\"archived obj root segment [%d] = \" SIZE_FORMAT \" bytes, obj = \" PTR_FORMAT,\n+                        elem_count, bytes_size, p2i(seg_oop));\n@@ -226,1 +248,0 @@\n-  log_info(cds, heap)(\"archived obj roots[%d] = \" SIZE_FORMAT \" bytes, klass = %p, obj = %p\", length, byte_size, k, mem);\n@@ -228,2 +249,1 @@\n-  _heap_roots_offset = _buffer_used;\n-  _buffer_used = new_used;\n+  _heap_roots = heap_roots;\n@@ -285,0 +305,4 @@\n+  \/\/ There could be multiple root segments, which we want to be aligned by region.\n+  \/\/ Putting them ahead of objects makes sure we waste no space.\n+  copy_roots_to_buffer(roots);\n+\n@@ -298,2 +322,0 @@\n-  copy_roots_to_buffer(roots);\n-\n@@ -458,1 +480,1 @@\n-  info->set_heap_roots_offset(_heap_roots_offset);\n+  info->set_heap_roots(_heap_roots);\n@@ -546,6 +568,0 @@\n-\/\/ Relocate an element in the buffered copy of HeapShared::roots()\n-template <typename T> void ArchiveHeapWriter::relocate_root_at(oop requested_roots, int index, CHeapBitMap* oopmap) {\n-  size_t offset = (size_t)((objArrayOop)requested_roots)->obj_at_offset<T>(index);\n-  relocate_field_in_buffer<T>((T*)(buffered_heap_roots_addr() + offset), oopmap);\n-}\n-\n@@ -603,4 +619,8 @@\n-  oop requested_roots = requested_obj_from_buffer_offset(_heap_roots_offset);\n-  update_header_for_requested_obj(requested_roots, nullptr, Universe::objectArrayKlass());\n-  int length = roots != nullptr ? roots->length() : 0;\n-  for (int i = 0; i < length; i++) {\n+  for (size_t seg_idx = 0; seg_idx < _heap_roots.segment_count(); seg_idx++) {\n+    size_t seg_offset = _heap_roots.base_offset() + (seg_idx * MIN_GC_REGION_ALIGNMENT);\n+\n+    objArrayOop requested_obj = (objArrayOop)requested_obj_from_buffer_offset(seg_offset);\n+    update_header_for_requested_obj(requested_obj, nullptr, Universe::objectArrayKlass());\n+    address buffered_obj = offset_to_buffered_address<address>(seg_offset);\n+    int length = _heap_roots.length_for_segment(seg_idx);\n+\n@@ -608,1 +628,4 @@\n-      relocate_root_at<narrowOop>(requested_roots, i, heap_info->oopmap());\n+      for (int i = 0; i < length; i++) {\n+        narrowOop* addr = (narrowOop*)(buffered_obj + requested_obj->obj_at_offset<narrowOop>(i));\n+        relocate_field_in_buffer<narrowOop>(addr, heap_info->oopmap());\n+      }\n@@ -610,1 +633,4 @@\n-      relocate_root_at<oop>(requested_roots, i, heap_info->oopmap());\n+      for (int i = 0; i < length; i++) {\n+        oop* addr = (oop*)(buffered_obj + requested_obj->obj_at_offset<oop>(i));\n+        relocate_field_in_buffer<oop>(addr, heap_info->oopmap());\n+      }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":81,"deletions":55,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-  size_t _heap_roots_offset;            \/\/ Offset of the HeapShared::roots() object, from the bottom\n-                                        \/\/ of the archived heap objects, in bytes.\n+  HeapRoots _heap_roots;\n@@ -60,2 +59,2 @@\n-  void set_heap_roots_offset(size_t n) { _heap_roots_offset = n; }\n-  size_t heap_roots_offset() const { return _heap_roots_offset; }\n+  void set_heap_roots(HeapRoots roots) { _heap_roots = roots; };\n+  HeapRoots heap_roots() { return _heap_roots; }\n@@ -118,2 +117,1 @@\n-  \/\/ (TODO: Perhaps change to 256K to be compatible with Shenandoah)\n-  static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n+  static constexpr int MIN_GC_REGION_ALIGNMENT = 256 * K; \/\/ FIXME: Testing\n@@ -134,2 +132,1 @@\n-  static size_t _heap_roots_offset;\n-  static size_t _heap_roots_word_size;\n+  static HeapRoots _heap_roots;\n@@ -196,0 +193,2 @@\n+  static void root_segment_at_put(objArrayOop segment, int index, oop root);\n+  static objArrayOop manifest_root_segment(size_t offset, int element_count);\n@@ -222,1 +221,0 @@\n-  template <typename T> static void relocate_root_at(oop requested_roots, int index, CHeapBitMap* oopmap);\n@@ -237,7 +235,0 @@\n-  static oop heap_roots_requested_address(); \/\/ requested address of HeapShared::roots()\n-  static address buffered_heap_roots_addr() {\n-    return offset_to_buffered_address<address>(_heap_roots_offset);\n-  }\n-  static size_t heap_roots_word_size() {\n-    return _heap_roots_word_size;\n-  }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -372,0 +372,20 @@\n+\n+size_t HeapRoots::byte_size_for_segment(size_t seg_idx) {\n+  return objArrayOopDesc::object_size(length_for_segment(seg_idx)) * HeapWordSize;\n+}\n+\n+int HeapRoots::length_for_segment(size_t seg_idx) {\n+  assert(seg_idx < _segment_count, \"In range\");\n+  if (seg_idx != _segment_count - 1) {\n+    return (int)_segment_max_size_elems;\n+  } else {\n+    \/\/ Last slice, leftover\n+    return (int)(_roots_count % _segment_max_size_elems);\n+  }\n+}\n+\n+int HeapRoots::segment_start_elems(size_t seg_idx) {\n+  assert(seg_idx < _segment_count, \"In range\");\n+  return (int)(seg_idx * _segment_max_size_elems);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -253,0 +253,28 @@\n+class HeapRoots {\n+private:\n+  size_t _base_offset;\n+  size_t _roots_count;\n+  size_t _segment_count;\n+  size_t _segment_max_size_bytes;\n+  size_t _segment_max_size_elems;\n+\n+public:\n+  size_t segment_count() { return _segment_count; }\n+  size_t base_offset() { return _base_offset; }\n+  size_t segment_max_size_bytes() { return _segment_max_size_bytes; }\n+\n+  size_t byte_size_for_segment(size_t seg_idx);\n+  int length_for_segment(size_t seg_idx);\n+  int segment_start_elems(size_t seg_idx);\n+\n+  HeapRoots() {}\n+  HeapRoots(size_t base_offset, int root_count, int segment_max_size_bytes, int segment_max_size_elems) :\n+          _base_offset(base_offset),\n+          _roots_count(root_count),\n+          _segment_count((root_count + segment_max_size_elems - 1) \/ segment_max_size_elems),\n+          _segment_max_size_bytes(segment_max_size_bytes),\n+          _segment_max_size_elems(segment_max_size_elems) {}\n+\n+   void inc_segment_count() { _segment_count++; }\n+};\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-  st->print_cr(\"- heap_roots_offset:              \" SIZE_FORMAT, _heap_roots_offset);\n+  st->print_cr(\"- heap_roots_base_offset:         \" SIZE_FORMAT, _heap_roots.base_offset());\n@@ -1650,1 +1650,1 @@\n-  header()->set_heap_roots_offset(heap_info->heap_roots_offset());\n+  header()->set_heap_roots(heap_info->heap_roots());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/archiveUtils.hpp\"\n@@ -228,2 +229,1 @@\n-  size_t _heap_roots_offset;            \/\/ Offset of the HeapShared::roots() object, from the bottom\n-                                        \/\/ of the archived heap objects, in bytes.\n+  HeapRoots _heap_roots;                \/\/ Heap roots info\n@@ -273,1 +273,1 @@\n-  size_t heap_roots_offset()               const { return _heap_roots_offset; }\n+  HeapRoots heap_roots()                   const { return _heap_roots; }\n@@ -288,1 +288,1 @@\n-  void set_heap_roots_offset(size_t n)           { _heap_roots_offset = n; }\n+  void set_heap_roots(HeapRoots roots)      { _heap_roots = roots; }\n@@ -388,1 +388,1 @@\n-  size_t  heap_roots_offset()  const { return header()->heap_roots_offset(); }\n+  HeapRoots heap_roots()       const { return header()->heap_roots(); }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -136,1 +136,2 @@\n-OopHandle HeapShared::_roots;\n+GrowableArrayCHeap<OopHandle, mtClassShared>* HeapShared::_root_segments;\n+size_t HeapShared::_root_segment_max_size;\n@@ -228,1 +229,1 @@\n-objArrayOop HeapShared::roots() {\n+objArrayOop HeapShared::root_segment(int segment_idx) {\n@@ -238,1 +239,1 @@\n-  objArrayOop roots = (objArrayOop)_roots.resolve();\n+  objArrayOop roots = (objArrayOop)_root_segments->at(segment_idx).resolve();\n@@ -245,0 +246,1 @@\n+  assert(_root_segment_max_size > 0, \"sanity\");\n@@ -247,2 +249,4 @@\n-  assert(!_roots.is_empty(), \"must have loaded shared heap\");\n-  oop result = roots()->obj_at(index);\n+  assert(!_root_segments->is_empty(), \"must have loaded shared heap\");\n+  int seg_idx = index \/ (int)_root_segment_max_size;\n+  int int_idx = index % (int)_root_segment_max_size;\n+  oop result = root_segment(seg_idx)->obj_at(int_idx);\n@@ -259,0 +263,3 @@\n+    assert(_root_segment_max_size > 0, \"sanity\");\n+    int seg_idx = index \/ (int)_root_segment_max_size;\n+    int int_idx = index % (int)_root_segment_max_size;\n@@ -260,1 +267,1 @@\n-      oop old = roots()->obj_at(index);\n+      oop old = root_segment(seg_idx)->obj_at(int_idx);\n@@ -263,1 +270,1 @@\n-    roots()->obj_at_put(index, nullptr);\n+    root_segment(seg_idx)->obj_at_put(int_idx, nullptr);\n@@ -767,2 +774,2 @@\n-void HeapShared::init_roots(oop roots_oop) {\n-  if (roots_oop != nullptr) {\n+void HeapShared::add_root_segment(oop segment_oop) {\n+  if (segment_oop != nullptr) {\n@@ -770,1 +777,4 @@\n-    _roots = OopHandle(Universe::vm_global(), roots_oop);\n+    if (_root_segments == nullptr) {\n+      _root_segments = new GrowableArrayCHeap<OopHandle, mtClassShared>(10);\n+    }\n+    _root_segments->push(OopHandle(Universe::vm_global(), segment_oop));\n@@ -774,0 +784,4 @@\n+void HeapShared::init_root_segment_max_size(size_t size) {\n+  _root_segment_max_size = size;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -293,1 +293,2 @@\n-  static OopHandle _roots;\n+  static GrowableArrayCHeap<OopHandle, mtClassShared>* _root_segments;\n+  static size_t _root_segment_max_size;\n@@ -402,1 +403,1 @@\n-  static objArrayOop roots();\n+  static objArrayOop root_segment(int segment_idx);\n@@ -425,1 +426,2 @@\n-  static void init_roots(oop roots_oop) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void add_root_segment(oop segment_oop) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void init_root_segment_max_size(size_t size) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}