{"files":[{"patch":"@@ -1256,23 +1256,3 @@\n-                                        Register recv, Label* update_done) {\n-  for (uint i = 0; i < ReceiverTypeData::row_limit(); i++) {\n-    Label next_test;\n-    \/\/ See if the receiver is receiver[n].\n-    __ cmpptr(recv, Address(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));\n-    __ jccb(Assembler::notEqual, next_test);\n-    Address data_addr(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));\n-    __ addptr(data_addr, DataLayout::counter_increment);\n-    __ jmp(*update_done);\n-    __ bind(next_test);\n-  }\n-\n-  \/\/ Didn't find receiver; find next empty slot and fill it in\n-  for (uint i = 0; i < ReceiverTypeData::row_limit(); i++) {\n-    Label next_test;\n-    Address recv_addr(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));\n-    __ cmpptr(recv_addr, NULL_WORD);\n-    __ jccb(Assembler::notEqual, next_test);\n-    __ movptr(recv_addr, recv);\n-    __ movptr(Address(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);\n-    __ jmp(*update_done);\n-    __ bind(next_test);\n-  }\n+                                        Register recv) {\n+  int mdp_offset = md->byte_offset_of_slot(data, in_ByteSize(0));\n+  __ type_profile(recv, mdo, mdp_offset);\n@@ -1336,1 +1316,0 @@\n-    Label update_done;\n@@ -1339,6 +1318,1 @@\n-    type_profile_helper(mdo, md, data, recv, &update_done);\n-\n-    Address nonprofiled_receiver_count_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-    __ addptr(nonprofiled_receiver_count_addr, DataLayout::counter_increment);\n-\n-    __ bind(update_done);\n+    type_profile_helper(mdo, md, data, recv);\n@@ -1456,1 +1430,0 @@\n-      Label update_done;\n@@ -1459,5 +1432,1 @@\n-      type_profile_helper(mdo, md, data, recv, &update_done);\n-\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ addptr(counter_addr, DataLayout::counter_increment);\n-      __ bind(update_done);\n+      type_profile_helper(mdo, md, data, recv);\n@@ -2788,4 +2757,1 @@\n-      \/\/ dynamic tests on the receiver type\n-\n-      \/\/ NOTE: we should probably put a lock around this search to\n-      \/\/ avoid collisions by concurrent compilations\n+      \/\/ dynamic tests on the receiver type.\n@@ -2793,2 +2759,1 @@\n-      uint i;\n-      for (i = 0; i < VirtualCallData::row_limit(); i++) {\n+      for (uint i = 0; i < VirtualCallData::row_limit(); i++) {\n@@ -2802,16 +2767,3 @@\n-\n-      \/\/ Receiver type not found in profile data; select an empty slot\n-\n-      \/\/ Note that this is less efficient than it should be because it\n-      \/\/ always does a write to the receiver part of the\n-      \/\/ VirtualCallData rather than just the first time\n-      for (i = 0; i < VirtualCallData::row_limit(); i++) {\n-        ciKlass* receiver = vc_data->receiver(i);\n-        if (receiver == nullptr) {\n-          Address recv_addr(mdo, md->byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));\n-          __ mov_metadata(recv_addr, known_klass->constant_encoding(), rscratch1);\n-          Address data_addr(mdo, md->byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));\n-          __ addptr(data_addr, DataLayout::counter_increment);\n-          return;\n-        }\n-      }\n+      \/\/ Receiver type is not found in profile data.\n+      \/\/ Fall back to runtime helper to handle the rest at runtime.\n+      __ mov_metadata(recv, known_klass->constant_encoding());\n@@ -2820,7 +2772,0 @@\n-      Label update_done;\n-      type_profile_helper(mdo, md, data, recv, &update_done);\n-      \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n-      \/\/ Increment total counter to indicate polymorphic case.\n-      __ addptr(counter_addr, DataLayout::counter_increment);\n-\n-      __ bind(update_done);\n@@ -2828,0 +2773,1 @@\n+    type_profile_helper(mdo, md, data, recv);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":11,"deletions":65,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-                           Register recv, Label* update_done);\n+                           Register recv);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -517,1 +517,1 @@\n-\/\/      rcx, rdi\n+\/\/      rcx\n@@ -527,1 +527,1 @@\n-  profile_typecheck(rcx, Rsub_klass, rdi); \/\/ blows rcx, reloads rdi\n+  profile_typecheck(rcx, Rsub_klass); \/\/ blows rcx\n@@ -1323,1 +1323,0 @@\n-                                                     Register reg2,\n@@ -1343,1 +1342,1 @@\n-    record_klass_in_profile(receiver, mdp, reg2, true);\n+    type_profile(receiver, mdp, 0);\n@@ -1352,129 +1351,0 @@\n-\/\/ This routine creates a state machine for updating the multi-row\n-\/\/ type profile at a virtual call site (or other type-sensitive bytecode).\n-\/\/ The machine visits each row (of receiver\/count) until the receiver type\n-\/\/ is found, or until it runs out of rows.  At the same time, it remembers\n-\/\/ the location of the first empty row.  (An empty row records null for its\n-\/\/ receiver, and can be allocated for a newly-observed receiver type.)\n-\/\/ Because there are two degrees of freedom in the state, a simple linear\n-\/\/ search will not work; it must be a decision tree.  Hence this helper\n-\/\/ function is recursive, to generate the required tree structured code.\n-\/\/ It's the interpreter, so we are trading off code space for speed.\n-\/\/ See below for example code.\n-void InterpreterMacroAssembler::record_klass_in_profile_helper(\n-                                        Register receiver, Register mdp,\n-                                        Register reg2, int start_row,\n-                                        Label& done, bool is_virtual_call) {\n-  if (TypeProfileWidth == 0) {\n-    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-  } else {\n-    record_item_in_profile_helper(receiver, mdp, reg2, 0, done, TypeProfileWidth,\n-                                  &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset);\n-  }\n-}\n-\n-void InterpreterMacroAssembler::record_item_in_profile_helper(Register item, Register mdp, Register reg2, int start_row,\n-                                                              Label& done, int total_rows,\n-                                                              OffsetFunction item_offset_fn,\n-                                                              OffsetFunction item_count_offset_fn) {\n-  int last_row = total_rows - 1;\n-  assert(start_row <= last_row, \"must be work left to do\");\n-  \/\/ Test this row for both the item and for null.\n-  \/\/ Take any of three different outcomes:\n-  \/\/   1. found item => increment count and goto done\n-  \/\/   2. found null => keep looking for case 1, maybe allocate this cell\n-  \/\/   3. found something else => keep looking for cases 1 and 2\n-  \/\/ Case 3 is handled by a recursive call.\n-  for (int row = start_row; row <= last_row; row++) {\n-    Label next_test;\n-    bool test_for_null_also = (row == start_row);\n-\n-    \/\/ See if the item is item[n].\n-    int item_offset = in_bytes(item_offset_fn(row));\n-    test_mdp_data_at(mdp, item_offset, item,\n-                     (test_for_null_also ? reg2 : noreg),\n-                     next_test);\n-    \/\/ (Reg2 now contains the item from the CallData.)\n-\n-    \/\/ The item is item[n].  Increment count[n].\n-    int count_offset = in_bytes(item_count_offset_fn(row));\n-    increment_mdp_data_at(mdp, count_offset);\n-    jmp(done);\n-    bind(next_test);\n-\n-    if (test_for_null_also) {\n-      \/\/ Failed the equality check on item[n]...  Test for null.\n-      testptr(reg2, reg2);\n-      if (start_row == last_row) {\n-        \/\/ The only thing left to do is handle the null case.\n-        Label found_null;\n-        jccb(Assembler::zero, found_null);\n-        \/\/ Item did not match any saved item and there is no empty row for it.\n-        \/\/ Increment total counter to indicate polymorphic case.\n-        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-        jmp(done);\n-        bind(found_null);\n-        break;\n-      }\n-      Label found_null;\n-      \/\/ Since null is rare, make it be the branch-taken case.\n-      jcc(Assembler::zero, found_null);\n-\n-      \/\/ Put all the \"Case 3\" tests here.\n-      record_item_in_profile_helper(item, mdp, reg2, start_row + 1, done, total_rows,\n-                                    item_offset_fn, item_count_offset_fn);\n-\n-      \/\/ Found a null.  Keep searching for a matching item,\n-      \/\/ but remember that this is an empty (unused) slot.\n-      bind(found_null);\n-    }\n-  }\n-\n-  \/\/ In the fall-through case, we found no matching item, but we\n-  \/\/ observed the item[start_row] is null.\n-\n-  \/\/ Fill in the item field and increment the count.\n-  int item_offset = in_bytes(item_offset_fn(start_row));\n-  set_mdp_data_at(mdp, item_offset, item);\n-  int count_offset = in_bytes(item_count_offset_fn(start_row));\n-  movl(reg2, DataLayout::counter_increment);\n-  set_mdp_data_at(mdp, count_offset, reg2);\n-  if (start_row > 0) {\n-    jmp(done);\n-  }\n-}\n-\n-\/\/ Example state machine code for three profile rows:\n-\/\/   \/\/ main copy of decision tree, rooted at row[1]\n-\/\/   if (row[0].rec == rec) { row[0].incr(); goto done; }\n-\/\/   if (row[0].rec != nullptr) {\n-\/\/     \/\/ inner copy of decision tree, rooted at row[1]\n-\/\/     if (row[1].rec == rec) { row[1].incr(); goto done; }\n-\/\/     if (row[1].rec != nullptr) {\n-\/\/       \/\/ degenerate decision tree, rooted at row[2]\n-\/\/       if (row[2].rec == rec) { row[2].incr(); goto done; }\n-\/\/       if (row[2].rec != nullptr) { count.incr(); goto done; } \/\/ overflow\n-\/\/       row[2].init(rec); goto done;\n-\/\/     } else {\n-\/\/       \/\/ remember row[1] is empty\n-\/\/       if (row[2].rec == rec) { row[2].incr(); goto done; }\n-\/\/       row[1].init(rec); goto done;\n-\/\/     }\n-\/\/   } else {\n-\/\/     \/\/ remember row[0] is empty\n-\/\/     if (row[1].rec == rec) { row[1].incr(); goto done; }\n-\/\/     if (row[2].rec == rec) { row[2].incr(); goto done; }\n-\/\/     row[0].init(rec); goto done;\n-\/\/   }\n-\/\/   done:\n-\n-void InterpreterMacroAssembler::record_klass_in_profile(Register receiver,\n-                                                        Register mdp, Register reg2,\n-                                                        bool is_virtual_call) {\n-  assert(ProfileInterpreter, \"must be profiling\");\n-  Label done;\n-\n-  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done, is_virtual_call);\n-\n-  bind (done);\n-}\n-\n@@ -1540,1 +1410,1 @@\n-void InterpreterMacroAssembler::profile_typecheck(Register mdp, Register klass, Register reg2) {\n+void InterpreterMacroAssembler::profile_typecheck(Register mdp, Register klass) {\n@@ -1553,1 +1423,1 @@\n-      record_klass_in_profile(klass, mdp, reg2, false);\n+      type_profile(klass, mdp, 0);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":5,"deletions":135,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -224,10 +224,0 @@\n-  void record_klass_in_profile(Register receiver, Register mdp,\n-                               Register reg2, bool is_virtual_call);\n-  void record_klass_in_profile_helper(Register receiver, Register mdp,\n-                                      Register reg2, int start_row,\n-                                      Label& done, bool is_virtual_call);\n-  void record_item_in_profile_helper(Register item, Register mdp, Register reg2, int start_row,\n-                                     Label& done, int total_rows,\n-                                     OffsetFunction item_offset_fn,\n-                                     OffsetFunction item_count_offset_fn);\n-\n@@ -244,1 +234,0 @@\n-                            Register scratch2,\n@@ -248,1 +237,1 @@\n-  void profile_typecheck(Register mdp, Register klass, Register scratch);\n+  void profile_typecheck(Register mdp, Register klass);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4758,0 +4758,132 @@\n+void MacroAssembler::type_profile(Register recv, Register mdp, int mdp_offset) {\n+  int base_receiver_offset   = in_bytes(ReceiverTypeData::receiver_offset(0));\n+  int end_receiver_offset    = in_bytes(ReceiverTypeData::receiver_offset(ReceiverTypeData::row_limit()));\n+  int poly_count_offset      = in_bytes(CounterData::count_offset());\n+  int receiver_step          = in_bytes(ReceiverTypeData::receiver_offset(1)) - base_receiver_offset;\n+  int receiver_to_count_step = in_bytes(ReceiverTypeData::receiver_count_offset(0)) - base_receiver_offset;\n+\n+  \/\/ Adjust for MDP offsets. Slots are pointer-sized, so is the global offset.\n+  assert(is_aligned(mdp_offset, BytesPerWord), \"sanity\");\n+  base_receiver_offset += mdp_offset;\n+  end_receiver_offset  += mdp_offset;\n+  poly_count_offset    += mdp_offset;\n+\n+  \/\/ Scale down to optimize encoding. Slots are pointer-sized.\n+  assert(is_aligned(base_receiver_offset,   BytesPerWord), \"sanity\");\n+  assert(is_aligned(end_receiver_offset,    BytesPerWord), \"sanity\");\n+  assert(is_aligned(poly_count_offset,      BytesPerWord), \"sanity\");\n+  assert(is_aligned(receiver_step,          BytesPerWord), \"sanity\");\n+  assert(is_aligned(receiver_to_count_step, BytesPerWord), \"sanity\");\n+  base_receiver_offset   >>= LogBytesPerWord;\n+  end_receiver_offset    >>= LogBytesPerWord;\n+  poly_count_offset      >>= LogBytesPerWord;\n+  receiver_step          >>= LogBytesPerWord;\n+  receiver_to_count_step >>= LogBytesPerWord;\n+\n+#ifdef ASSERT\n+  \/\/ We are about to walk the MDO slots without asking for offsets.\n+  \/\/ Check that our math hits all the right spots.\n+  for (uint c = 0; c < ReceiverTypeData::row_limit(); c++) {\n+    int real_recv_offset  = mdp_offset + in_bytes(ReceiverTypeData::receiver_offset(c));\n+    int real_count_offset = mdp_offset + in_bytes(ReceiverTypeData::receiver_count_offset(c));\n+    int offset = base_receiver_offset + receiver_step*c;\n+    int count_offset = offset + receiver_to_count_step;\n+    assert((offset << LogBytesPerWord) == real_recv_offset, \"receiver slot math\");\n+    assert((count_offset << LogBytesPerWord) == real_count_offset, \"receiver count math\");\n+  }\n+  int real_poly_count_offset = mdp_offset + in_bytes(CounterData::count_offset());\n+  assert(poly_count_offset << LogBytesPerWord == real_poly_count_offset, \"poly counter math\");\n+#endif\n+\n+  \/\/ Corner case: no profile table. Increment poly counter and exit.\n+  if (ReceiverTypeData::row_limit() == 0) {\n+    addptr(Address(mdp, poly_count_offset, Address::times_ptr), DataLayout::counter_increment);\n+    return;\n+  }\n+\n+  Register offset = rscratch1;\n+  assert_different_registers(mdp, recv, offset);\n+\n+  Label L_loop, L_loop_nulls, L_found_recv, L_not_null, L_count_update;\n+\n+  \/\/ Optimistic: search for already set up receiver.\n+  movptr(offset, base_receiver_offset);\n+  bind(L_loop);\n+    cmpptr(recv, Address(mdp, offset, Address::times_ptr));\n+    jccb(Assembler::equal, L_found_recv);\n+  addptr(offset, receiver_step);\n+  cmpptr(offset, end_receiver_offset);\n+  jccb(Assembler::notEqual, L_loop);\n+\n+  \/\/ Receiver is not found in current profile. Search for the empty slot and try to claim it.\n+  \/\/ Since this claim is racy, we need to make sure that rows are only claimed once.\n+  \/\/ This makes sure we never overwrite a row for another receiver and never duplicate\n+  \/\/ the receivers in the list.\n+  \/\/ Note: It is tempting to combine this search with the optimistic loop above,\n+  \/\/ and claim the first nullptr slot without checking the rest of the table.\n+  \/\/ But, profiling code should tolerate free slots in MDO, for example, to allow cleaning up\n+  \/\/ rows for unloaded receivers.\n+  movptr(offset, base_receiver_offset);\n+  bind(L_loop_nulls);\n+    cmpptr(Address(mdp, offset, Address::times_ptr), NULL_WORD);\n+    jccb(Assembler::notEqual, L_not_null);\n+      \/\/ This code is tight on registers, and CAS wants RAX specifically,\n+      \/\/ so we need to shuffle registers a bit.\n+      Register temp_reg = noreg;\n+      Register recv_reg = recv;\n+      Address slot(mdp, offset, Address::times_ptr);\n+      if (recv == rax) {\n+        \/\/ Need to swap recv (RAX) with some other register.\n+        \/\/ Pick any register, as long as it does not carry offset\/mdp.\n+        temp_reg = (offset != rbx && mdp != rbx) ? rbx :\n+                   (offset != rcx && mdp != rcx) ? rcx :\n+                   rdx;\n+        push(temp_reg);\n+        movptr(temp_reg, recv);\n+        recv_reg = temp_reg;\n+      } else if (mdp == rax || offset == rax) {\n+        \/\/ Use the *other* register as temporary, collapse the address into it,\n+        \/\/ and use it as slot address.\n+        temp_reg = (mdp == rax) ? offset : mdp;\n+        push(temp_reg);\n+        lea(temp_reg, Address(mdp, offset, Address::times_ptr));\n+        slot = Address(temp_reg, 0);\n+      } else {\n+        \/\/ Nothing to do, just go with defaults.\n+        assert_different_registers(rax, mdp, recv, offset);\n+      }\n+      \/\/ CAS: null -> recv\n+      push(rax);\n+      xorptr(rax, rax);\n+      cmpxchgptr(recv_reg, slot);\n+      pop(rax);\n+      \/\/ All done. Restore recv\/temp regs, if needed.\n+      if (recv_reg != recv) {\n+        movptr(recv, recv_reg);\n+      }\n+      if (temp_reg != noreg) {\n+        pop(temp_reg);\n+      }\n+      \/\/ CAS failure means something had claimed the slot concurrently.\n+      \/\/ It can be the same receiver we want, or something else.\n+      \/\/ Fall-through to check the slot contents.\n+    bind(L_not_null);\n+    cmpptr(recv, Address(mdp, offset, Address::times_ptr));\n+    jccb(Assembler::equal, L_found_recv);\n+  addptr(offset, receiver_step);\n+  cmpptr(offset, end_receiver_offset);\n+  jccb(Assembler::notEqual, L_loop_nulls);\n+\n+  \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n+  \/\/ Increment poly counter instead.\n+  movptr(offset, poly_count_offset);\n+  jmpb(L_count_update);\n+\n+  bind(L_found_recv);\n+  addptr(offset, receiver_to_count_step);\n+\n+  bind(L_count_update);\n+  addptr(Address(mdp, offset, Address::times_ptr), DataLayout::counter_increment);\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -674,0 +674,2 @@\n+  void type_profile(Register recv, Register mdp, int mdp_offset);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3257,1 +3257,1 @@\n-  __ profile_virtual_call(rax, rlocals, rdx);\n+  __ profile_virtual_call(rax, rlocals);\n@@ -3398,1 +3398,1 @@\n-  __ profile_virtual_call(rdx, rbcp, rlocals);\n+  __ profile_virtual_call(rdx, rbcp);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}