{"files":[{"patch":"@@ -4809,5 +4809,0 @@\n-  \/\/ The update code uses CAS, which wants RAX register specifically, *and* it needs\n-  \/\/ other important registers untouched. Therefore, we need to shift any important\n-  \/\/ registers from RAX into some other spare register. If we have a spare register,\n-  \/\/ we are forced to save it on stack here. But since it implies RAX is in our use,\n-  \/\/ we can then save on RAX push\/pops near the CAS.\n@@ -4815,0 +4810,80 @@\n+\n+  Label L_loop_search_receiver, L_loop_search_empty;\n+  Label L_restart, L_found_recv, L_found_empty, L_polymorphic, L_count_update;\n+\n+  \/\/ The code here recognizes three major cases:\n+  \/\/   A. Fastest: receiver found in the table\n+  \/\/   B. Fast: no receiver in the table, and the table is full\n+  \/\/   C. Slow: no receiver in the table, free slots in the table\n+  \/\/\n+  \/\/ The performance of cases A and B is important, this is where bulk of the code\n+  \/\/ would end up executing. Well-behaved code, especially with larger TypeProfileWidth,\n+  \/\/ would almost exclusively be in case A. The case C performance is not essential,\n+  \/\/ its job is to deal with installation races. We need to make sure that rows are\n+  \/\/ only claimed once. This makes sure we never overwrite a row for another receiver\n+  \/\/ and never duplicate the receivers in the list.\n+  \/\/\n+  \/\/ It is tempting to combine these cases into a single loop, and claim the first\n+  \/\/ free slot without checking the rest of the table. But, profiling code should tolerate\n+  \/\/ free slots in MDO. Therefore, the receiver we need might be _after_ the free slot.\n+  \/\/ Therefore, we need to let at least full scan to complete, before trying to install\n+  \/\/ new slots.\n+  \/\/\n+  \/\/ This code is effectively:\n+  \/\/\n+  \/\/ restart:\n+  \/\/   \/\/ Fastest: receiver is already installed\n+  \/\/   for (i = 0; i < receiver_count(); i++) {\n+  \/\/     if (receiver(i) == recv) goto found_recv(i);\n+  \/\/   }\n+  \/\/\n+  \/\/   \/\/ Fast: no receiver, but profile is full\n+  \/\/   for (i = 0; i < receiver_count(); i++) {\n+  \/\/     if (receiver(i) == null) goto found_null(i);\n+  \/\/   }\n+  \/\/   goto polymorphic\n+  \/\/\n+  \/\/   \/\/ Slow: try to install receiver\n+  \/\/ found_null(i):\n+  \/\/   CAS(&receiver(i), null, recv);\n+  \/\/   goto restart\n+  \/\/\n+  \/\/ polymorphic:\n+  \/\/   count++;\n+  \/\/   return\n+  \/\/\n+  \/\/ found_recv(i):\n+  \/\/   *receiver_count(i)++\n+  \/\/\n+\n+  bind(L_restart);\n+\n+  \/\/ Fastest: receiver is already installed\n+  movptr(offset, base_receiver_offset);\n+  bind(L_loop_search_receiver);\n+    cmpptr(recv, Address(mdp, offset, Address::times_ptr));\n+    jccb(Assembler::equal, L_found_recv);\n+  addptr(offset, receiver_step);\n+  cmpptr(offset, end_receiver_offset);\n+  jccb(Assembler::notEqual, L_loop_search_receiver);\n+\n+  \/\/ Fast: no receiver, but profile is full\n+  movptr(offset, base_receiver_offset);\n+  bind(L_loop_search_empty);\n+    cmpptr(Address(mdp, offset, Address::times_ptr), NULL_WORD);\n+    jccb(Assembler::equal, L_found_empty);\n+  addptr(offset, receiver_step);\n+  cmpptr(offset, end_receiver_offset);\n+  jccb(Assembler::notEqual, L_loop_search_empty);\n+  jmpb(L_polymorphic);\n+\n+  \/\/ Slow: try to install receiver\n+  bind(L_found_empty);\n+\n+  \/\/ Atomically swing receiver slot: null -> recv.\n+  \/\/\n+  \/\/ The update code uses CAS, which wants RAX register specifically, *and* it needs\n+  \/\/ other important registers untouched, as they form the address. Therefore, we need\n+  \/\/ to shift any important registers from RAX into some other spare register. If we\n+  \/\/ have a spare register, we are forced to save it on stack here.\n+\n@@ -4816,0 +4891,2 @@\n+  Register shifted_mdp = mdp;\n+  Register shifted_recv = recv;\n@@ -4825,1 +4902,1 @@\n-      recv = spare_reg;\n+      shifted_recv = spare_reg;\n@@ -4829,1 +4906,1 @@\n-      mdp = spare_reg;\n+      shifted_mdp = spare_reg;\n@@ -4831,0 +4908,2 @@\n+  } else {\n+    push(rax);\n@@ -4834,1 +4913,1 @@\n-  assert_different_registers(rax, mdp, recv, offset);\n+  assert_different_registers(rax, shifted_mdp, shifted_recv, offset);\n@@ -4836,1 +4915,2 @@\n-  Label L_loop, L_loop_nulls, L_found_recv, L_not_null, L_count_update;\n+  xorptr(rax, rax);\n+  cmpxchgptr(shifted_recv, Address(shifted_mdp, offset, Address::times_ptr));\n@@ -4838,13 +4918,7 @@\n-  \/\/ Optimistic: search for already set up receiver.\n-  \/\/\n-  \/\/ This code is effectively:\n-  \/\/   for (i = 0; i < receiver_count(); i++) {\n-  \/\/     if (receiver(i) == recv)  goto found_recv;\n-  \/\/   }\n-  movptr(offset, base_receiver_offset);\n-  bind(L_loop);\n-    cmpptr(recv, Address(mdp, offset, Address::times_ptr));\n-    jccb(Assembler::equal, L_found_recv);\n-  addptr(offset, receiver_step);\n-  cmpptr(offset, end_receiver_offset);\n-  jccb(Assembler::notEqual, L_loop);\n+  \/\/ Unshift registers.\n+  if (recv == rax || mdp == rax) {\n+    movptr(rax, spare_reg);\n+    pop(spare_reg);\n+  } else {\n+    pop(rax);\n+  }\n@@ -4852,39 +4926,7 @@\n-  \/\/ Receiver is not found in current profile. Search for the empty slot and try to claim it.\n-  \/\/ Since this claim is racy, we need to make sure that rows are only claimed once.\n-  \/\/ This makes sure we never overwrite a row for another receiver and never duplicate\n-  \/\/ the receivers in the list.\n-  \/\/\n-  \/\/ This code is effectively:\n-  \/\/   for (i = 0; i < receiver_count(); i++) {\n-  \/\/     if (receiver(i) == null)  CAS(&receiver(i), null -> recv);\n-  \/\/     if (receiver(i) == recv)  goto found_recv;\n-  \/\/   }\n-  \/\/\n-  \/\/ Note: It is tempting to combine this search with the optimistic loop above,\n-  \/\/ and claim the first nullptr slot without checking the rest of the table.\n-  \/\/ But, profiling code should tolerate free slots in MDO, for example, to allow cleaning up\n-  \/\/ rows for unloaded receivers.\n-  \/\/\n-  movptr(offset, base_receiver_offset);\n-  bind(L_loop_nulls);\n-    cmpptr(Address(mdp, offset, Address::times_ptr), NULL_WORD);\n-    jccb(Assembler::notEqual, L_not_null);\n-      \/\/ Atomically swing receiver slot: null -> recv.\n-      \/\/ If we have not shifted anything from RAX, we better save and restore it here.\n-      if (spare_reg == noreg) {\n-        push(rax);\n-      }\n-      xorptr(rax, rax);\n-      cmpxchgptr(recv, Address(mdp, offset, Address::times_ptr));\n-      if (spare_reg == noreg) {\n-        pop(rax);\n-      }\n-      \/\/ CAS failure means something had claimed the slot concurrently.\n-      \/\/ It can be the same receiver we want, or something else.\n-      \/\/ Fall-through to check the slot contents.\n-    bind(L_not_null);\n-    cmpptr(recv, Address(mdp, offset, Address::times_ptr));\n-    jccb(Assembler::equal, L_found_recv);\n-  addptr(offset, receiver_step);\n-  cmpptr(offset, end_receiver_offset);\n-  jccb(Assembler::notEqual, L_loop_nulls);\n+  \/\/ CAS success means the slot now has the receiver we want. CAS failure means\n+  \/\/ something had claimed the slot concurrently: it can be the same receiver we want,\n+  \/\/ or something else. Since this is a slow path, we can optimize for code density,\n+  \/\/ and just restart the search from the beginning.\n+  jmpb(L_restart);\n+\n+  \/\/ Counter updates:\n@@ -4892,3 +4934,2 @@\n-  \/\/ Falling through from search\/install loops: receiver did not match any saved receiver,\n-  \/\/ and there is no empty row for it. Increment poly counter instead.\n-  \/\/ Effectively: offset = CounterData::count_offset();\n+  \/\/ Increment polymorphic counter instead of receiver slot.\n+  bind(L_polymorphic);\n@@ -4899,1 +4940,0 @@\n-  \/\/ Effectively: offset = &receiver_count[index_of(found_recv)] - mdp;\n@@ -4905,7 +4945,0 @@\n-\n-  \/\/ About to return to outer code: restore affected registers.\n-  \/\/ Taking this branch implies some important register was shifted from RAX.\n-  if (spare_reg != noreg) {\n-    movptr(rax, spare_reg);\n-    pop(spare_reg);\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":105,"deletions":72,"binary":false,"changes":177,"status":"modified"}]}