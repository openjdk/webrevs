{"files":[{"patch":"@@ -4819,6 +4819,7 @@\n-  \/\/ The performance of cases A and B is important, this is where bulk of the code\n-  \/\/ would end up executing. Well-behaved code, especially with larger TypeProfileWidth,\n-  \/\/ would almost exclusively be in case A. The case C performance is not essential,\n-  \/\/ its job is to deal with installation races. We need to make sure that rows are\n-  \/\/ only claimed once. This makes sure we never overwrite a row for another receiver\n-  \/\/ and never duplicate the receivers in the list.\n+  \/\/ The case A performance is most important, as perfectly-behaved code would end up\n+  \/\/ there, especially with larger TypeProfileWidth. The case B performance is\n+  \/\/ important as well, this is where bulk of code would land for normally megamorphic\n+  \/\/ cases. The case C performance is not essential, its job is to deal with installation\n+  \/\/ races, we optimize for code density instead. Case C needs to make sure that receiver\n+  \/\/ rows are only claimed once. This makes sure we never overwrite a row for another\n+  \/\/ receiver and never duplicate the receivers in the list, making profile type-accurate.\n@@ -4826,5 +4827,6 @@\n-  \/\/ It is tempting to combine these cases into a single loop, and claim the first\n-  \/\/ free slot without checking the rest of the table. But, profiling code should tolerate\n-  \/\/ free slots in MDO. Therefore, the receiver we need might be _after_ the free slot.\n-  \/\/ Therefore, we need to let at least full scan to complete, before trying to install\n-  \/\/ new slots.\n+  \/\/ It is very tempting to handle these cases in a single loop, and claim the first slot\n+  \/\/ without checking the rest of the table. But, profiling code should tolerate free slots\n+  \/\/ in the table, as class unloading can clear them. After such cleanup, the receiver\n+  \/\/ we need might be _after_ the free slot. Therefore, we need to let at least full scan\n+  \/\/ to complete, before trying to install new slots. Splitting the code in several tight\n+  \/\/ loops also helpfully optimizes for cases A and B.\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"}]}