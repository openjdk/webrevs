{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -732,1 +732,1 @@\n-        (fds[2] == -1 && pipe(err) < 0) ||\n+        (fds[2] == -1 && !redirectErrorStream && pipe(err) < 0) || \/\/ if not redirecting create the pipe\n@@ -738,0 +738,1 @@\n+\n@@ -767,0 +768,1 @@\n+        char * failMessage = \"unknown\";\n@@ -769,1 +771,1 @@\n-            throwInternalIOException(env, errno, \"vfork failed\", c->mode);\n+            failMessage = \"vfork failed\";\n@@ -772,1 +774,1 @@\n-            throwInternalIOException(env, errno, \"fork failed\", c->mode);\n+            failMessage = \"fork failed\";\n@@ -775,1 +777,1 @@\n-            throwInternalIOException(env, errno, \"posix_spawn failed\", c->mode);\n+            failMessage = \"posix_spawn failed\";\n@@ -778,0 +780,1 @@\n+        throwInternalIOException(env, errno, failMessage, c->mode);\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessImpl_md.c","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,4 @@\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -29,1 +30,0 @@\n-import java.io.File;\n@@ -32,0 +32,1 @@\n+import java.lang.ProcessHandle;\n@@ -34,0 +35,1 @@\n+import java.util.HashMap;\n@@ -35,0 +37,1 @@\n+import java.util.LinkedHashSet;\n@@ -37,0 +40,1 @@\n+import java.util.stream.Collectors;\n@@ -40,2 +44,2 @@\n- * @bug 8289643 8291760\n- * @requires (os.family == \"linux\" & !vm.musl)\n+ * @bug 8289643 8291760 8291986\n+ * @requires os.family == \"mac\" | (os.family == \"linux\" & !vm.musl)\n@@ -43,1 +47,1 @@\n- * @run testng\/othervm PipelineLeaksFD\n+ * @run junit\/othervm PipelineLeaksFD\n@@ -46,1 +50,0 @@\n-@Test\n@@ -48,2 +51,9 @@\n-    @DataProvider\n-    public Object[][] builders() {\n+\n+    private static final String OS_NAME = System.getProperty(\"os.name\", \"Unknown\");\n+\n+    private static final long MY_PID =  ProcessHandle.current().pid();\n+\n+    private static final boolean LSOF_AVAILABLE = checkForLSOF();\n+\n+    \/\/ Test cases for pipelines with a number of pipeline sequences\n+    public static Object[][] builders() {\n@@ -62,1 +72,19 @@\n-    @Test(dataProvider = \"builders\")\n+    \/\/ True if lsof is runnable and collect pipe usage.\n+    private static boolean lsofAvailable() {\n+        return LSOF_AVAILABLE;\n+    }\n+\n+    \/\/ Check if lsof is available\n+    private static boolean checkForLSOF() {\n+        try {\n+            pipesForPid(MY_PID);\n+            return true;\n+        } catch (IOException ioe) {\n+            System.err.println(\"Skipping: \" + ioe);\n+            return false;\n+        }\n+    }\n+\n+    @EnabledIf(\"lsofAvailable\")\n+    @ParameterizedTest\n+    @MethodSource(\"builders\")\n@@ -65,1 +93,1 @@\n-        Set<PipeRecord> pipesBefore = myPipes();\n+        Set<PipeRecord> pipesBefore = pipesForPid(MY_PID);\n@@ -67,2 +95,2 @@\n-            System.out.println(pipesBefore);\n-            Assert.fail(\"There should be at least 3 pipes before, (0, 1, 2)\");\n+            System.err.println(pipesBefore);\n+            fail(\"There should be at least 3 pipes before, (0, 1, 2)\");\n@@ -70,0 +98,1 @@\n+        printPipes(pipesBefore, \"Before start\");\n@@ -75,1 +104,1 @@\n-        try (Writer out = processes.get(0).outputWriter()) {\n+        try (Writer out = processes.getFirst().outputWriter()) {\n@@ -87,1 +116,1 @@\n-                Assert.assertEquals(outActual, expectedOut, \"stdout, process[ \" + i + \"]: \" + p);\n+                assertEquals(expectedOut, outActual, \"stdout, process[ \" + i + \"]: \" + p);\n@@ -90,1 +119,1 @@\n-                Assert.assertEquals(errActual, expectedErr, \"stderr, process[ \" + i + \"]: \" + p);\n+                assertEquals(expectedErr, errActual, \"stderr, process[ \" + i + \"]: \" + p);\n@@ -94,1 +123,1 @@\n-        processes.forEach(p -> waitForQuiet(p));\n+        processes.forEach(PipelineLeaksFD::waitForQuiet);\n@@ -96,1 +125,1 @@\n-        Set<PipeRecord> pipesAfter = myPipes();\n+        Set<PipeRecord> pipesAfter = pipesForPid(MY_PID);\n@@ -104,1 +133,33 @@\n-            Assert.fail(\"More or fewer pipes than expected\");\n+            fail(\"More or fewer pipes than expected\");\n+        }\n+    }\n+\n+    \/\/ Test redirectErrorStream, both true and false\n+    public static Object[][] redirectCases() {\n+        return new Object[][] {\n+                {true},\n+                {false},\n+        };\n+    }\n+\n+    \/\/ Test redirectErrorStream  (true\/false) has the right number of pipes in use\n+    @EnabledIf(\"lsofAvailable\")\n+    @ParameterizedTest()\n+    @MethodSource(\"redirectCases\")\n+    void checkRedirectErrorStream(boolean redirectError) throws IOException {\n+        try (Process p = new ProcessBuilder(\"cat\")\n+                .redirectErrorStream(redirectError)\n+                .start()) {\n+            System.err.printf(\"Parent PID; %d, Child Pid: %d\\n\", MY_PID, p.pid());\n+            final Set<PipeRecord> pipes = pipesForPid(p.pid());\n+            printPipes(pipes, \"Parent and waiting child pipes\");\n+            int uniquePipes = redirectError ? 8 : 9;\n+            assertEquals(uniquePipes, pipes.size(),\n+                    \"wrong number of pipes for redirect: \" + redirectError);\n+            String expectedTypeName = redirectError\n+                    ? \"java.lang.ProcessBuilder$NullInputStream\"\n+                    : \"java.lang.ProcessImpl$ProcessPipeInputStream\";\n+            assertEquals(expectedTypeName, p.getErrorStream().getClass().getName(),\n+                    \"errorStream type is incorrect\");\n+        } catch (IOException ioe) {\n+            fail(\"Process start\", ioe);\n@@ -109,2 +170,2 @@\n-        System.out.printf(\"%s: [%d]%n\", label, pipes.size());\n-        pipes.forEach(r -> System.out.printf(\"%-20s: %s%n\", r.fd(), r.link()));\n+        System.err.printf(\"%s: [%d]%n\", label, pipes.size());\n+        pipes.forEach(System.err::println);\n@@ -117,1 +178,1 @@\n-                System.out.println(\"non-zero exit status: \" + p);\n+                System.err.println(\"non-zero exit status: \" + p);\n@@ -124,1 +185,4 @@\n-     * Collect a Set of pairs of \/proc fd paths and the symbol links that are pipes.\n+     * Collect a Set of file descriptors and identifying information.\n+     * To identify the pipes in use the `lsof` command is invoked and output scrapped for\n+     * fd's, pids, unique identities of the pipes (to match with parent).\n+     * Files are used for `lsof` input and output to avoid creating pipes.\n@@ -127,14 +191,65 @@\n-    static Set<PipeRecord> myPipes() {\n-        Path path = Path.of(\"\/proc\/\" + ProcessHandle.current().pid() + \"\/fd\");\n-        Set<PipeRecord> pipes = new HashSet<>();\n-        File[] files = path.toFile().listFiles(f -> Files.isSymbolicLink(f.toPath()));\n-        if (files != null) {\n-            for (File file : files) {\n-                try {\n-                    Path link = Files.readSymbolicLink(file.toPath());\n-                    if (link.toString().startsWith(\"pipe:\")) {\n-                        pipes.add(new PipeRecord(file.toPath(), link));\n-                    }\n-                } catch (IOException ioe) {\n-                }\n-            }\n+    static Set<PipeRecord> pipesForPid(long pid) throws IOException {\n+        Path lsofEmptyInput = Files.createTempFile(\"lsof-\", \"empty\");\n+        Path lsofOutput = Files.createTempFile(\"lsof-\", \"tmp\");\n+        try (Process p = new ProcessBuilder(\"lsof\")\n+                .redirectOutput(lsofOutput.toFile())\n+                .redirectInput(lsofEmptyInput.toFile()) \/\/ empty input\n+                .redirectError(ProcessBuilder.Redirect.DISCARD) \/\/ ignored output\n+                .start()) {\n+            int status = p.waitFor();\n+            assertEquals(0, status, \"Process 'lsof' failed\");\n+\n+            List<String> lines = Files.readAllLines(lsofOutput);\n+            \/\/ Collect all the pipes for the processes (parent, waiting child)\n+            return lines.stream()\n+                    .map(PipelineLeaksFD::pipeFromLSOF)\n+                    .filter(pr -> pr != null &&\n+                            (pr.pid() == pid || pr.pid() == MY_PID))\n+                    .collect(Collectors.toCollection(LinkedHashSet::new));\n+        } catch (InterruptedException ie) {\n+            throw new IOException(\"Waiting for lsof exit interrupted\", ie);\n+        }\n+    }\n+\n+    \/\/ Return pipe records by parsing the appropriate platform specific `lsof` output.\n+    static PipeRecord pipeFromLSOF(String s) {\n+        return switch (OS_NAME) {\n+            case \"Linux\" -> pipeFromLinuxLSOF(s);\n+            case \"Mac OS X\" -> pipeFromMacLSOF(s);\n+            default -> throw new RuntimeException(\"lsof not supported on platform: \" + OS_NAME);\n+        };\n+    }\n+\n+    \/\/ Return Pipe from lsof output put, or null (on Mac OS X)\n+    \/\/ lsof      55221 rriggs    0      PIPE 0xc76402237956a5cb      16384  ->0xfcb0c07ae447908c\n+    \/\/ lsof      55221 rriggs    1      PIPE 0xb486e02f86da463e      16384  ->0xf94eacc85896b4e6\n+    static PipeRecord pipeFromMacLSOF(String s) {\n+        String[] fields = s.split(\"\\\\s+\");\n+        if (\"PIPE\".equals(fields[4])) {\n+            final int pid = Integer.parseInt(fields[1]);\n+            final String myKey = (fields.length > 5) ? fields[5] : \"\";\n+            final String otherKey = (fields.length > 7) ? fields[7].substring(2) : \"\";\n+            return PipeRecord.lookup(Integer.parseInt(fields[3]), myKey, otherKey, pid);\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Return Pipe from lsof output put, or null (on Linux)\n+    \/\/ java    7612 rriggs   14w  FIFO   0,12       0t0   117662267 pipe\n+    \/\/ java    7612 rriggs   15r  FIFO   0,12       0t0   117662268 pipe\n+    static PipeRecord pipeFromLinuxLSOF(String s) {\n+        String[] fields = s.split(\"\\\\s+\");\n+        if (\"FIFO\".equals(fields[4])) {\n+            final int pid = Integer.parseInt(fields[1]);\n+            final String key = (fields.length > 7) ? fields[7] : \"\";\n+            final int fdNum = Integer.parseInt(fields[3].substring(0, fields[3].length() - 1));\n+            return PipeRecord.lookup(fdNum, key, null, pid);\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Identify a pipe by pid, fd, and a key (unique across processes)\n+    \/\/ Mac OS X has separate keys for read and write sides, both are matched to the same \"name\"\n+    record PipeRecord(long pid, int fd, KeyedString myKey) {\n+        static PipeRecord lookup(int fd, String myKey, String otherKey, int pid) {\n+            return new PipeRecord(pid, fd, KeyedString.getKey(myKey, otherKey));\n@@ -142,1 +257,0 @@\n-        return pipes;\n@@ -145,1 +259,32 @@\n-    record PipeRecord(Path fd, Path link) { };\n+    \/\/ A unique name for a string with a count of uses\n+    \/\/ Used to associate pipe between parent and child.\n+    static class KeyedString {\n+        private static final HashMap<String, KeyedString> map = new HashMap<>();\n+        private static int nextInt = 1;\n+        private final String key;\n+        private final String name;\n+        private int count;\n+        KeyedString(String key, String name) {\n+            this.key = key;\n+            this.name = name;\n+            this.count = 0;\n+        }\n+\n+        KeyedString(String s) {\n+            String k = \"p\" + nextInt++;\n+            this(s, k);\n+        }\n+\n+        static KeyedString getKey(String key, String otherKey) {\n+            var k = map.computeIfAbsent(key, KeyedString::new);\n+            k.count++;\n+            if (otherKey != null) {\n+                map.putIfAbsent(otherKey, k);\n+            }\n+            return k;\n+        }\n+\n+        public String toString() {\n+            return name + \"(\" + count + \")\";\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/PipelineLeaksFD.java","additions":186,"deletions":41,"binary":false,"changes":227,"status":"modified"},{"patch":"","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/ProcessHandle\/TEST.properties","status":"copied"}]}