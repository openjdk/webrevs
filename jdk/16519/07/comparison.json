{"files":[{"patch":"@@ -992,1 +992,1 @@\n-  ObjectSynchronizer::monitors_iterate(&jmc, java_thread);\n+  ObjectSynchronizer::owned_monitors_iterate(&jmc, java_thread);\n@@ -1019,1 +1019,1 @@\n-  ObjectSynchronizer::monitors_iterate(&jmc, java_thread);\n+  ObjectSynchronizer::owned_monitors_iterate(&jmc, java_thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1852,1 +1852,1 @@\n-  return ObjectSynchronizer::request_deflate_idle_monitors();\n+  return ObjectSynchronizer::request_deflate_idle_monitors_from_wb();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    (void)ObjectSynchronizer::deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr);\n+    (void)ObjectSynchronizer::deflate_idle_monitors();\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,39 +66,0 @@\n-class ObjectMonitorsHashtable::PtrList :\n-  public LinkedListImpl<ObjectMonitor*,\n-                        AnyObj::C_HEAP, mtThread,\n-                        AllocFailStrategy::RETURN_NULL> {};\n-\n-class CleanupObjectMonitorsHashtable: StackObj {\n- public:\n-  bool do_entry(void*& key, ObjectMonitorsHashtable::PtrList*& list) {\n-    list->clear();  \/\/ clear the LinkListNodes\n-    delete list;    \/\/ then delete the LinkedList\n-    return true;\n-  }\n-};\n-\n-ObjectMonitorsHashtable::~ObjectMonitorsHashtable() {\n-  CleanupObjectMonitorsHashtable cleanup;\n-  _ptrs->unlink(&cleanup);  \/\/ cleanup the LinkedLists\n-  delete _ptrs;             \/\/ then delete the hash table\n-}\n-\n-void ObjectMonitorsHashtable::add_entry(void* key, ObjectMonitor* om) {\n-  ObjectMonitorsHashtable::PtrList* list = get_entry(key);\n-  if (list == nullptr) {\n-    \/\/ Create new list and add it to the hash table:\n-    list = new (mtThread) ObjectMonitorsHashtable::PtrList;\n-    add_entry(key, list);\n-  }\n-  list->add(om);  \/\/ Add the ObjectMonitor to the list.\n-  _om_count++;\n-}\n-\n-bool ObjectMonitorsHashtable::has_entry(void* key, ObjectMonitor* om) {\n-  ObjectMonitorsHashtable::PtrList* list = get_entry(key);\n-  if (list == nullptr || list->find(om) == nullptr) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -1102,6 +1063,4 @@\n-\/\/ Iterate ObjectMonitors where the owner == thread; this does NOT include\n-\/\/ ObjectMonitors where owner is set to a stack-lock address in thread.\n-\/\/\n-\/\/ This version of monitors_iterate() works with the in-use monitor list.\n-\/\/\n-void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure, JavaThread* thread) {\n+\/\/ Iterate ObjectMonitors owned by any thread and where the owner `filter`\n+\/\/ returns true.\n+template <typename OwnerFilter>\n+void ObjectSynchronizer::owned_monitors_iterate_filtered(MonitorClosure* closure, OwnerFilter filter) {\n@@ -1111,14 +1070,11 @@\n-    if (mid->owner() != thread) {\n-      \/\/ Not owned by the target thread and intentionally skips when owner\n-      \/\/ is set to a stack-lock address in the target thread.\n-      continue;\n-    }\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n-      \/\/ Only process with closure if the object is set.\n-\n-      \/\/ monitors_iterate() is only called at a safepoint or when the\n-      \/\/ target thread is suspended or when the target thread is\n-      \/\/ operating on itself. The current closures in use today are\n-      \/\/ only interested in an owned ObjectMonitor and ownership\n-      \/\/ cannot be dropped under the calling contexts so the\n-      \/\/ ObjectMonitor cannot be async deflated.\n+\n+    \/\/ This function is only called at a safepoint or when the\n+    \/\/ target thread is suspended or when the target thread is\n+    \/\/ operating on itself. The current closures in use today are\n+    \/\/ only interested in an owned ObjectMonitor and ownership\n+    \/\/ cannot be dropped under the calling contexts so the\n+    \/\/ ObjectMonitor cannot be async deflated.\n+    if (mid->has_owner() && filter(mid->owner_raw())) {\n+      assert(!mid->is_being_async_deflated(), \"Owned monitors should not be deflating\");\n+      assert(mid->object_peek() != nullptr, \"Owned monitors should not have a dead object\");\n+\n@@ -1130,23 +1086,11 @@\n-\/\/ This version of monitors_iterate() works with the specified linked list.\n-\/\/\n-void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure,\n-                                          ObjectMonitorsHashtable::PtrList* list,\n-                                          JavaThread* thread) {\n-  typedef LinkedListIterator<ObjectMonitor*> ObjectMonitorIterator;\n-  ObjectMonitorIterator iter(list->head());\n-  while (!iter.is_empty()) {\n-    ObjectMonitor* mid = *iter.next();\n-    \/\/ Owner set to a stack-lock address in thread should never be seen here:\n-    assert(mid->owner() == thread, \"must be\");\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n-      \/\/ Only process with closure if the object is set.\n-\n-      \/\/ monitors_iterate() is only called at a safepoint or when the\n-      \/\/ target thread is suspended or when the target thread is\n-      \/\/ operating on itself. The current closures in use today are\n-      \/\/ only interested in an owned ObjectMonitor and ownership\n-      \/\/ cannot be dropped under the calling contexts so the\n-      \/\/ ObjectMonitor cannot be async deflated.\n-      closure->do_monitor(mid);\n-    }\n-  }\n+\/\/ Iterate ObjectMonitors where the owner == thread; this does NOT include\n+\/\/ ObjectMonitors where owner is set to a stack-lock address in thread.\n+void ObjectSynchronizer::owned_monitors_iterate(MonitorClosure* closure, JavaThread* thread) {\n+  auto thread_filter = [&](void* owner) { return owner == thread; };\n+  return owned_monitors_iterate_filtered(closure, thread_filter);\n+}\n+\n+\/\/ Iterate ObjectMonitors owned by any thread.\n+void ObjectSynchronizer::owned_monitors_iterate(MonitorClosure* closure) {\n+  auto all_filter = [&](void* owner) { return true; };\n+  return owned_monitors_iterate_filtered(closure, all_filter);\n@@ -1259,1 +1203,7 @@\n-bool ObjectSynchronizer::request_deflate_idle_monitors() {\n+void ObjectSynchronizer::request_deflate_idle_monitors() {\n+  MonitorLocker ml(MonitorDeflation_lock, Mutex::_no_safepoint_check_flag);\n+  set_is_async_deflation_requested(true);\n+  ml.notify_all();\n+}\n+\n+bool ObjectSynchronizer::request_deflate_idle_monitors_from_wb() {\n@@ -1264,5 +1214,3 @@\n-  set_is_async_deflation_requested(true);\n-  {\n-    MonitorLocker ml(MonitorDeflation_lock, Mutex::_no_safepoint_check_flag);\n-    ml.notify_all();\n-  }\n+\n+  request_deflate_idle_monitors();\n+\n@@ -1585,7 +1533,0 @@\n-\/\/ If table != nullptr, we gather owned ObjectMonitors indexed by the\n-\/\/ owner in the table. Please note that ObjectMonitors where the owner\n-\/\/ is set to a stack-lock address are NOT associated with the JavaThread\n-\/\/ that holds that stack-lock. All of the current consumers of\n-\/\/ ObjectMonitorsHashtable info only care about JNI locked monitors and\n-\/\/ those do not have the owner set to a stack-lock address.\n-\/\/\n@@ -1593,2 +1534,1 @@\n-                                                elapsedTimer* timer_p,\n-                                                ObjectMonitorsHashtable* table) {\n+                                                elapsedTimer* timer_p) {\n@@ -1605,12 +1545,0 @@\n-    } else if (table != nullptr) {\n-      \/\/ The caller is interested in the owned ObjectMonitors. This does\n-      \/\/ not include when owner is set to a stack-lock address in thread.\n-      \/\/ This also does not capture unowned ObjectMonitors that cannot be\n-      \/\/ deflated because of a waiter.\n-      void* key = mid->owner();\n-      \/\/ Since deflate_idle_monitors() and deflate_monitor_list() can be\n-      \/\/ called more than once, we have to make sure the entry has not\n-      \/\/ already been added.\n-      if (key != nullptr && !table->has_entry(key, mid)) {\n-        table->add_entry(key, mid);\n-      }\n@@ -1660,3 +1588,2 @@\n-\/\/ ObjectMonitors. It is also called via do_final_audit_and_print_stats()\n-\/\/ and VM_ThreadDump::doit() by the VMThread.\n-size_t ObjectSynchronizer::deflate_idle_monitors(ObjectMonitorsHashtable* table) {\n+\/\/ ObjectMonitors. It is also called via do_final_audit_and_print_stats().\n+size_t ObjectSynchronizer::deflate_idle_monitors() {\n@@ -1687,1 +1614,1 @@\n-  size_t deflated_count = deflate_monitor_list(current, ls, &timer, table);\n+  size_t deflated_count = deflate_monitor_list(current, ls, &timer);\n@@ -1769,4 +1696,0 @@\n-    if (table != nullptr) {\n-      ls->print_cr(\"ObjectMonitorsHashtable: key_count=\" SIZE_FORMAT \", om_count=\" SIZE_FORMAT,\n-                   table->key_count(), table->om_count());\n-    }\n@@ -1825,1 +1748,1 @@\n-  ObjectSynchronizer::monitors_iterate(&rjmc, current);\n+  ObjectSynchronizer::owned_monitors_iterate(&rjmc, current);\n@@ -1882,1 +1805,1 @@\n-    while (deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr) > 0) {\n+    while (deflate_idle_monitors() > 0) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":42,"deletions":119,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -39,49 +39,0 @@\n-\/\/ Hash table of void* to a list of ObjectMonitor* owned by the JavaThread.\n-\/\/ The JavaThread's owner key is either a JavaThread* or a stack lock\n-\/\/ address in the JavaThread so we use \"void*\".\n-\/\/\n-class ObjectMonitorsHashtable {\n- private:\n-  static unsigned int ptr_hash(void* const& s1) {\n-    \/\/ 2654435761 = 2^32 * Phi (golden ratio)\n-    return (unsigned int)(((uint32_t)(uintptr_t)s1) * 2654435761u);\n-  }\n-\n- public:\n-  class PtrList;\n-\n- private:\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n-  \/\/ use 1031 which is the first prime after 1024.\n-  typedef ResourceHashtable<void*, PtrList*, 1031, AnyObj::C_HEAP, mtThread,\n-                            &ObjectMonitorsHashtable::ptr_hash> PtrTable;\n-  PtrTable* _ptrs;\n-  size_t _key_count;\n-  size_t _om_count;\n-\n- public:\n-  \/\/ ResourceHashtable is passed to various functions and populated in\n-  \/\/ different places so we allocate it using C_HEAP to make it immune\n-  \/\/ from any ResourceMarks that happen to be in the code paths.\n-  ObjectMonitorsHashtable() : _ptrs(new (mtThread) PtrTable), _key_count(0), _om_count(0) {}\n-\n-  ~ObjectMonitorsHashtable();\n-\n-  void add_entry(void* key, ObjectMonitor* om);\n-\n-  void add_entry(void* key, PtrList* list) {\n-    _ptrs->put(key, list);\n-    _key_count++;\n-  }\n-\n-  PtrList* get_entry(void* key) {\n-    PtrList** listpp = _ptrs->get(key);\n-    return (listpp == nullptr) ? nullptr : *listpp;\n-  }\n-\n-  bool has_entry(void* key, ObjectMonitor* om);\n-\n-  size_t key_count() { return _key_count; }\n-  size_t om_count() { return _om_count; }\n-};\n-\n@@ -175,0 +126,5 @@\n+  \/\/ Iterate ObjectMonitors owned by any thread and where the owner `filter`\n+  \/\/ returns true.\n+  template <typename OwnerFilter>\n+  static void owned_monitors_iterate_filtered(MonitorClosure* closure, OwnerFilter filter);\n+\n@@ -176,8 +132,5 @@\n-  \/\/ ObjectMonitors where owner is set to a stack lock address in thread:\n-  \/\/\n-  \/\/ This version of monitors_iterate() works with the in-use monitor list.\n-  static void monitors_iterate(MonitorClosure* m, JavaThread* thread);\n-  \/\/ This version of monitors_iterate() works with the specified linked list.\n-  static void monitors_iterate(MonitorClosure* closure,\n-                               ObjectMonitorsHashtable::PtrList* list,\n-                               JavaThread* thread);\n+  \/\/ ObjectMonitors where owner is set to a stack lock address in thread.\n+  static void owned_monitors_iterate(MonitorClosure* m, JavaThread* thread);\n+\n+  \/\/ Iterate ObjectMonitors owned by any thread.\n+  static void owned_monitors_iterate(MonitorClosure* closure);\n@@ -188,3 +141,3 @@\n-  \/\/ GC: we currently use aggressive monitor deflation policy\n-  \/\/ Basically we try to deflate all monitors that are not busy.\n-  static size_t deflate_idle_monitors(ObjectMonitorsHashtable* table);\n+  \/\/ We currently use aggressive monitor deflation policy;\n+  \/\/ basically we try to deflate all monitors that are not busy.\n+  static size_t deflate_idle_monitors();\n@@ -196,2 +149,1 @@\n-  static size_t deflate_monitor_list(Thread* current, LogStream* ls, elapsedTimer* timer_p,\n-                                     ObjectMonitorsHashtable* table);\n+  static size_t deflate_monitor_list(Thread* current, LogStream* ls, elapsedTimer* timer_p);\n@@ -207,1 +159,2 @@\n-  static bool request_deflate_idle_monitors();  \/\/ for whitebox test support\n+  static void request_deflate_idle_monitors();\n+  static bool request_deflate_idle_monitors_from_wb();  \/\/ for whitebox test support\n@@ -255,0 +208,7 @@\n+\/\/ Interface to visit monitors\n+class ObjectMonitorsView {\n+public:\n+  \/\/ Visit monitors that belong to the given thread\n+  virtual void visit(MonitorClosure* closure, JavaThread* thread) = 0;\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":23,"deletions":63,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -52,0 +53,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -268,0 +270,99 @@\n+\/\/ Hash table of void* to a list of ObjectMonitor* owned by the JavaThread.\n+\/\/ The JavaThread's owner key is either a JavaThread* or a stack lock\n+\/\/ address in the JavaThread so we use \"void*\".\n+\/\/\n+class ObjectMonitorsDump : public MonitorClosure, public ObjectMonitorsView {\n+ private:\n+  static unsigned int ptr_hash(void* const& s1) {\n+    \/\/ 2654435761 = 2^32 * Phi (golden ratio)\n+    return (unsigned int)(((uint32_t)(uintptr_t)s1) * 2654435761u);\n+  }\n+\n+ private:\n+  class ObjectMonitorLinkedList :\n+    public LinkedListImpl<ObjectMonitor*,\n+                          AnyObj::C_HEAP, mtThread,\n+                          AllocFailStrategy::RETURN_NULL> {};\n+\n+  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ use 1031 which is the first prime after 1024.\n+  typedef ResourceHashtable<void*, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n+                            &ObjectMonitorsDump::ptr_hash> PtrTable;\n+  PtrTable* _ptrs;\n+  size_t _key_count;\n+  size_t _om_count;\n+\n+  void add_list(void* key, ObjectMonitorLinkedList* list) {\n+    _ptrs->put(key, list);\n+    _key_count++;\n+  }\n+\n+  ObjectMonitorLinkedList* get_list(void* key) {\n+    ObjectMonitorLinkedList** listpp = _ptrs->get(key);\n+    return (listpp == nullptr) ? nullptr : *listpp;\n+  }\n+\n+  void add(ObjectMonitor* monitor) {\n+    void* key = monitor->owner();\n+\n+    ObjectMonitorLinkedList* list = get_list(key);\n+    if (list == nullptr) {\n+      \/\/ Create new list and add it to the hash table:\n+      list = new (mtThread) ObjectMonitorLinkedList;\n+      _ptrs->put(key, list);\n+      _key_count++;\n+    }\n+\n+    assert(list->find(monitor) == nullptr, \"Should not contain duplicates\");\n+    list->add(monitor);  \/\/ Add the ObjectMonitor to the list.\n+    _om_count++;\n+  }\n+\n+ public:\n+  \/\/ ResourceHashtable is passed to various functions and populated in\n+  \/\/ different places so we allocate it using C_HEAP to make it immune\n+  \/\/ from any ResourceMarks that happen to be in the code paths.\n+  ObjectMonitorsDump() : _ptrs(new (mtThread) PtrTable), _key_count(0), _om_count(0) {}\n+\n+  ~ObjectMonitorsDump() {\n+    class CleanupObjectMonitorsDump: StackObj {\n+     public:\n+      bool do_entry(void*& key, ObjectMonitorLinkedList*& list) {\n+        list->clear();  \/\/ clear the LinkListNodes\n+        delete list;    \/\/ then delete the LinkedList\n+        return true;\n+      }\n+    } cleanup;\n+\n+    _ptrs->unlink(&cleanup);  \/\/ cleanup the LinkedLists\n+    delete _ptrs;             \/\/ then delete the hash table\n+  }\n+\n+  \/\/ Implements MonitorClosure used to collect all owned monitors in the system\n+  void do_monitor(ObjectMonitor* monitor) override {\n+    assert(monitor->has_owner(), \"Expects only owned monitors\");\n+\n+    if (monitor->is_owner_anonymous()) {\n+      \/\/ There's no need to collect anonymous owned monitors\n+      \/\/ because the callers of this code is only interested\n+      \/\/ in JNI owned monitors.\n+      return;\n+    }\n+\n+    add(monitor);\n+  }\n+\n+  \/\/ Implements the ObjectMonitorsView interface\n+  void visit(MonitorClosure* closure, JavaThread* thread) override {\n+    ObjectMonitorLinkedList* list = get_list(thread);\n+    LinkedListIterator<ObjectMonitor*> iter(list != nullptr ? list->head() : nullptr);\n+    while (!iter.is_empty()) {\n+      ObjectMonitor* monitor = *iter.next();\n+      closure->do_monitor(monitor);\n+    }\n+  }\n+\n+  size_t key_count() { return _key_count; }\n+  size_t om_count() { return _om_count; }\n+};\n+\n@@ -282,2 +383,1 @@\n-  ObjectMonitorsHashtable table;\n-  ObjectMonitorsHashtable* tablep = nullptr;\n+  ObjectMonitorsDump object_monitors;\n@@ -285,7 +385,12 @@\n-    \/\/ The caller wants locked monitor information and that's expensive to gather\n-    \/\/ when there are a lot of inflated monitors. So we deflate idle monitors and\n-    \/\/ gather information about owned monitors at the same time.\n-    tablep = &table;\n-    while (ObjectSynchronizer::deflate_idle_monitors(tablep) > 0) {\n-      ; \/* empty *\/\n-    }\n+    \/\/ Gather information about owned monitors.\n+    ObjectSynchronizer::owned_monitors_iterate(&object_monitors);\n+\n+    \/\/ If there are many object monitors in the system then the above iteration\n+    \/\/ can start to take time. Be friendly to following thread dumps by telling\n+    \/\/ the MonitorDeflationThread to deflate monitors.\n+    \/\/\n+    \/\/ This is trying to be somewhat backwards compatible with the previous\n+    \/\/ implementation, which performed monitor deflation right here. We might\n+    \/\/ want to reconsider the need to trigger monitor deflation from the thread\n+    \/\/ dumping and instead maybe tweak the deflation heuristics.\n+    ObjectSynchronizer::request_deflate_idle_monitors();\n@@ -308,1 +413,1 @@\n-      snapshot_thread(jt, tcl, tablep);\n+      snapshot_thread(jt, tcl, &object_monitors);\n@@ -343,1 +448,1 @@\n-      snapshot_thread(jt, tcl, tablep);\n+      snapshot_thread(jt, tcl, &object_monitors);\n@@ -349,1 +454,1 @@\n-                                    ObjectMonitorsHashtable* table) {\n+                                    ObjectMonitorsView* monitors) {\n@@ -351,1 +456,1 @@\n-  snapshot->dump_stack_at_safepoint(_max_depth, _with_locked_monitors, table, false);\n+  snapshot->dump_stack_at_safepoint(_max_depth, _with_locked_monitors, monitors, false);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":118,"deletions":13,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class ObjectMonitorsHashtable;\n+class ObjectMonitorsView;\n@@ -207,1 +207,1 @@\n-                       ObjectMonitorsHashtable* table);\n+                       ObjectMonitorsView* monitors);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -690,1 +691,1 @@\n-void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth, ObjectMonitorsHashtable* table, bool full) {\n+void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth, ObjectMonitorsView* monitors, bool full) {\n@@ -726,11 +727,1 @@\n-    if (table != nullptr) {\n-      \/\/ Get the ObjectMonitors locked by the target thread, if any,\n-      \/\/ and does not include any where owner is set to a stack lock\n-      \/\/ address in the target thread:\n-      ObjectMonitorsHashtable::PtrList* list = table->get_entry(_thread);\n-      if (list != nullptr) {\n-        ObjectSynchronizer::monitors_iterate(&imc, list, _thread);\n-      }\n-    } else {\n-      ObjectSynchronizer::monitors_iterate(&imc, _thread);\n-    }\n+    monitors->visit(&imc, _thread);\n@@ -991,1 +982,1 @@\n-                                             ObjectMonitorsHashtable* table, bool full) {\n+                                             ObjectMonitorsView* monitors, bool full) {\n@@ -993,1 +984,1 @@\n-  _stack_trace->dump_stack_at_safepoint(max_depth, table, full);\n+  _stack_trace->dump_stack_at_safepoint(max_depth, monitors, full);\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-class ObjectMonitorsHashtable;\n+class ObjectMonitorsView;\n@@ -267,1 +267,1 @@\n-                                      ObjectMonitorsHashtable* table, bool full);\n+                                      ObjectMonitorsView* monitors, bool full);\n@@ -290,1 +290,1 @@\n-  void            dump_stack_at_safepoint(int max_depth, ObjectMonitorsHashtable* table, bool full);\n+  void            dump_stack_at_safepoint(int max_depth, ObjectMonitorsView* monitors, bool full);\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -391,0 +391,1 @@\n+ -runtime\/Monitor\/ConcurrentDeflation.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+\n+\/*\n+ * @test\n+ * @bug 8318757\n+ * @summary Test concurrent monitor deflation by MonitorDeflationThread and thread dumping\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:GuaranteedAsyncDeflationInterval=2000 -XX:LockingMode=0 ConcurrentDeflation\n+ *\/\n+\n+public class ConcurrentDeflation {\n+    public static final int TOTAL_RUN_TIME = 10 * 1000;\n+    public static Object[] monitors = new Object[1000];\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread threadDumper  = new Thread(() -> dumpThreads());\n+        threadDumper.start();\n+        Thread monitorCreator  = new Thread(() -> createMonitors());\n+        monitorCreator.start();\n+\n+        threadDumper.join();\n+        monitorCreator.join();\n+    }\n+\n+    static private void dumpThreads() {\n+        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n+        long startTime = System.currentTimeMillis();\n+        int dumpCount = 0;\n+\n+        while (System.currentTimeMillis() - startTime < TOTAL_RUN_TIME) {\n+            threadBean.dumpAllThreads(true, false);\n+            dumpCount++;\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException e) {}\n+        }\n+        System.out.println(\"Dumped all thread info \" + dumpCount + \" times\");\n+    }\n+\n+    static private void createMonitors() {\n+        int monitorCount = 0;\n+\n+        int index = 0;\n+        long startTime = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - startTime < TOTAL_RUN_TIME) {\n+            index = index++ % 1000;\n+            monitors[index] = new Object();\n+            synchronized (monitors[index]) {\n+            }\n+            monitorCount++;\n+        }\n+        System.out.println(\"Created \" + monitorCount + \" monitors\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/ConcurrentDeflation.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}