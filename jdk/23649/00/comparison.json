{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## The FreeType Project: Freetype v2.13.2\n+## The FreeType Project: Freetype v2.13.3\n@@ -24,19 +24,17 @@\n-Copyright (C) 1996-2023 by David Turner, Robert Wilhelm, and Werner Lemberg.\n-Copyright (C) 2007-2023 by Dereg Clegg and Michael Toftdal.\n-Copyright (C) 1996-2023 by Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.\n-Copyright (C) 2022-2023 by David Turner, Robert Wilhelm, Werner Lemberg, George Williams, and\n-Copyright (C) 2004-2023 by Masatake YAMATO and Redhat K.K.\n-Copyright (C) 2007-2023 by Derek Clegg and Michael Toftdal.\n-Copyright (C) 2003-2023 by Masatake YAMATO, Red Hat K.K.,\n-Copyright (C) 1996-2023 by David Turner, Robert Wilhelm, Werner Lemberg, and Dominik Röttsches.\n-Copyright (C) 2007-2023 by David Turner.\n-Copyright (C) 2022-2023 by David Turner, Robert Wilhelm, Werner Lemberg, and Moazin Khatti.\n-Copyright (C) 2007-2023 by Rahul Bhalerao <rahul.bhalerao@redhat.com>, <b.rahul.pm@gmail.com>.\n-Copyright (C) 2008-2023 by David Turner, Robert Wilhelm, Werner Lemberg, and suzuki toshiya.\n-Copyright (C) 2013-2023 by Google, Inc.\n-Copyright (C) 2019-2023 by Nikhil Ramakrishnan, David Turner, Robert Wilhelm, and Werner Lemberg.\n-Copyright (C) 2009-2023 by Oran Agra and Mickey Gabel.\n-Copyright (C) 2018-2023 by David Turner, Robert Wilhelm, Dominik Röttsches, and Werner Lemberg.\n-Copyright (C) 2004-2023 by David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.\n-\n-\n+Copyright (C) 1996-2024 by David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2007-2024 by Dereg Clegg and Michael Toftdal.\n+Copyright (C) 1996-2024 by Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2022-2024 by David Turner, Robert Wilhelm, Werner Lemberg, George Williams, and\n+Copyright (C) 2004-2024 by Masatake YAMATO and Redhat K.K.\n+Copyright (C) 2007-2024 by Derek Clegg and Michael Toftdal.\n+Copyright (C) 2003-2024 by Masatake YAMATO, Red Hat K.K.,\n+Copyright (C) 1996-2024 by David Turner, Robert Wilhelm, Werner Lemberg, and Dominik Röttsches.\n+Copyright (C) 2007-2024 by David Turner.\n+Copyright (C) 2022-2024 by David Turner, Robert Wilhelm, Werner Lemberg, and Moazin Khatti.\n+Copyright (C) 2007-2024 by Rahul Bhalerao <rahul.bhalerao@redhat.com>, <b.rahul.pm@gmail.com>.\n+Copyright (C) 2008-2024 by David Turner, Robert Wilhelm, Werner Lemberg, and suzuki toshiya.\n+Copyright (C) 2013-2024 by Google, Inc.\n+Copyright (C) 2019-2024 by Nikhil Ramakrishnan, David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2009-2024 by Oran Agra and Mickey Gabel.\n+Copyright (C) 2018-2024 by David Turner, Robert Wilhelm, Dominik Röttsches, and Werner Lemberg.\n+Copyright (C) 2004-2024 by David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.\n@@ -562,1 +560,1 @@\n-The below license applies to the following files:\n+The below applies to the following file(s):\n@@ -585,1 +583,1 @@\n-Copyright 2006-2014 Adobe Systems Incorporated.\n+Copyright (C) 2006-2014 Adobe Systems Incorporated.\n@@ -621,1 +619,1 @@\n-The below license applies to the following files:\n+The below applies to the following file(s):\n@@ -625,2 +623,2 @@\n-Copyright 2000 Computing Research Labs, New Mexico State University\n-Copyright 2001-2015\n+Copyright (C) 2000 Computing Research Labs, New Mexico State University\n+Copyright (C) 2001-2015\n","filename":"src\/java.desktop\/share\/legal\/freetype.md","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftconfig.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftheader.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -760,0 +760,16 @@\n+  \/**************************************************************************\n+   *\n+   * Option `TT_CONFIG_OPTION_GPOS_KERNING` enables a basic GPOS kerning\n+   * implementation (for TrueType fonts only).  With this defined, FreeType\n+   * is able to get kerning pair data from the GPOS 'kern' feature as well as\n+   * legacy 'kern' tables; without this defined, FreeType will only be able\n+   * to use legacy 'kern' tables.\n+   *\n+   * Note that FreeType does not support more advanced GPOS layout features;\n+   * even the 'kern' feature implemented here doesn't handle more\n+   * sophisticated kerning variants.  Use a higher-level library like\n+   * HarfBuzz instead for that.\n+   *\/\n+\/* #define TT_CONFIG_OPTION_GPOS_KERNING *\/\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftoption.h","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftstdlib.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/integer-types.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/mac-support.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2020-2023 by\n+ * Copyright (C) 2020-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/public-macros.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -1325,3 +1325,7 @@\n-   *     function always returns the vector (0,0).  Note that FreeType\n-   *     doesn't handle kerning data from the SFNT 'GPOS' table (as present\n-   *     in many OpenType fonts).\n+   *     function always returns the vector (0,0).\n+   *\n+   *     Note that for TrueType fonts only, FreeType supports both the 'kern'\n+   *     table and the basic, pair-wise kerning feature from the 'GPOS' table\n+   *     (with `TT_CONFIG_OPTION_GPOS_KERNING` enabled), though FreeType does\n+   *     not support the more advanced GPOS layout features; use a library\n+   *     like HarfBuzz for those instead.\n@@ -3770,7 +3774,5 @@\n-   *     This mode corresponds to 8-bit, single-channel signed distance field\n-   *     (SDF) bitmaps.  Each pixel in the SDF grid is the value from the\n-   *     pixel's position to the nearest glyph's outline.  The distances are\n-   *     calculated from the center of the pixel and are positive if they are\n-   *     filled by the outline (i.e., inside the outline) and negative\n-   *     otherwise.  Check the note below on how to convert the output values\n-   *     to usable data.\n+   *     The positive (unsigned) 8-bit bitmap values can be converted to the\n+   *     single-channel signed distance field (SDF) by subtracting 128, with\n+   *     the positive and negative results corresponding to the inside and\n+   *     the outside of a glyph contour, respectively.  The distance units are\n+   *     arbitrarily determined by an adjustable @spread property.\n@@ -3779,1 +3781,1 @@\n-   *   The selected render mode only affects vector glyphs of a font.\n+   *   The selected render mode only affects scalable vector glyphs of a font.\n@@ -3784,67 +3786,0 @@\n-   *   For @FT_RENDER_MODE_SDF the output bitmap buffer contains normalized\n-   *   distances that are packed into unsigned 8-bit values.  To get pixel\n-   *   values in floating point representation use the following pseudo-C\n-   *   code for the conversion.\n-   *\n-   *   ```\n-   *   \/\/ Load glyph and render using FT_RENDER_MODE_SDF,\n-   *   \/\/ then use the output buffer as follows.\n-   *\n-   *   ...\n-   *   FT_Byte  buffer = glyph->bitmap->buffer;\n-   *\n-   *\n-   *   for pixel in buffer\n-   *   {\n-   *     \/\/ `sd` is the signed distance and `spread` is the current spread;\n-   *     \/\/ the default spread is 2 and can be changed.\n-   *\n-   *     float  sd = (float)pixel - 128.0f;\n-   *\n-   *\n-   *     \/\/ Convert to pixel values.\n-   *     sd = ( sd \/ 128.0f ) * spread;\n-   *\n-   *     \/\/ Store `sd` in a buffer or use as required.\n-   *   }\n-   *\n-   *   ```\n-   *\n-   *   FreeType has two rasterizers for generating SDF, namely:\n-   *\n-   *   1. `sdf` for generating SDF directly from glyph's outline, and\n-   *\n-   *   2. `bsdf` for generating SDF from rasterized bitmaps.\n-   *\n-   *   Depending on the glyph type (i.e., outline or bitmap), one of the two\n-   *   rasterizers is chosen at runtime and used for generating SDFs.  To\n-   *   force the use of `bsdf` you should render the glyph with any of the\n-   *   FreeType's other rendering modes (e.g., `FT_RENDER_MODE_NORMAL`) and\n-   *   then re-render with `FT_RENDER_MODE_SDF`.\n-   *\n-   *   There are some issues with stability and possible failures of the SDF\n-   *   renderers (specifically `sdf`).\n-   *\n-   *   1. The `sdf` rasterizer is sensitive to really small features (e.g.,\n-   *      sharp turns that are less than 1~pixel) and imperfections in the\n-   *      glyph's outline, causing artifacts in the final output.\n-   *\n-   *   2. The `sdf` rasterizer has limited support for handling intersecting\n-   *      contours and *cannot* handle self-intersecting contours whatsoever.\n-   *      Self-intersection happens when a single connected contour\n-   *      intersects itself at some point; having these in your font\n-   *      definitely poses a problem to the rasterizer and cause artifacts,\n-   *      too.\n-   *\n-   *   3. Generating SDF for really small glyphs may result in undesirable\n-   *      output; the pixel grid (which stores distance information) becomes\n-   *      too coarse.\n-   *\n-   *   4. Since the output buffer is normalized, precision at smaller spreads\n-   *      is greater than precision at larger spread values because the\n-   *      output range of [0..255] gets mapped to a smaller SDF range.  A\n-   *      spread of~2 should be sufficient in most cases.\n-   *\n-   *   Points (1) and (2) can be avoided by using the `bsdf` rasterizer,\n-   *   which is more stable than the `sdf` rasterizer in general.\n-   *\n@@ -4061,3 +3996,20 @@\n-   *   Kerning for OpenType fonts implemented in a 'GPOS' table is not\n-   *   supported; use @FT_HAS_KERNING to find out whether a font has data\n-   *   that can be extracted with `FT_Get_Kerning`.\n+   *   Note that, for TrueType fonts only, this can extract data from both\n+   *   the 'kern' table and the basic, pair-wise kerning feature from the\n+   *   GPOS table (with `TT_CONFIG_OPTION_GPOS_KERNING` enabled), though\n+   *   FreeType does not support the more advanced GPOS layout features; use\n+   *   a library like HarfBuzz for those instead.  If a font has both a\n+   *   'kern' table and kern features of a GPOS table, the 'kern' table will\n+   *   be used.\n+   *\n+   *   Also note for right-to-left scripts, the functionality may differ for\n+   *   fonts with GPOS tables vs. 'kern' tables.  For GPOS, right-to-left\n+   *   fonts typically use both a placement offset and an advance for pair\n+   *   positioning, which this API does not support, so it would output\n+   *   kerning values of zero; though if the right-to-left font used only\n+   *   advances in GPOS pair positioning, then this API could output kerning\n+   *   values for it, but it would use `left_glyph` to mean the first glyph\n+   *   for that case.  Whereas 'kern' tables are always advance-only and\n+   *   always store the left glyph first.\n+   *\n+   *   Use @FT_HAS_KERNING to find out whether a font has data that can be\n+   *   extracted with `FT_Get_Kerning`.\n@@ -5225,1 +5177,1 @@\n-#define FREETYPE_PATCH  2\n+#define FREETYPE_PATCH  3\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/freetype.h","additions":35,"deletions":83,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2023 by\n+ * Copyright (C) 2008-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftadvanc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftbbox.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftbdf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftbitmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftcid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftcolor.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2024 by\n@@ -820,0 +820,74 @@\n+\n+  \/**************************************************************************\n+   *\n+   * @property:\n+   *   spread\n+   *\n+   * @description:\n+   *   This property of the 'sdf' and 'bsdf' renderers defines how the signed\n+   *   distance field (SDF) is represented in the output bitmap.  The output\n+   *   values are calculated as follows, '128 * ( SDF \/ spread + 1 )', with\n+   *   the result clamped to the 8-bit range [0..255].  Therefore, 'spread'\n+   *   is also the maximum euclidean distance from the edge after which the\n+   *   values are clamped.  The spread is specified in pixels with the\n+   *   default value of 8.  For accurate SDF texture mapping (interpolation),\n+   *   the spread should be large enough to accommodate the target grid unit.\n+   *\n+   * @example:\n+   *   The following example code demonstrates how to set the SDF spread\n+   *   (omitting the error handling).\n+   *\n+   *   ```\n+   *     FT_Library  library;\n+   *     FT_Int      spread = 2;\n+   *\n+   *\n+   *     FT_Init_FreeType( &library );\n+   *\n+   *     FT_Property_Set( library, \"sdf\", \"spread\", &spread );\n+   *   ```\n+   *\n+   * @note:\n+   *   FreeType has two rasterizers for generating SDF, namely:\n+   *\n+   *   1. `sdf` for generating SDF directly from glyph's outline, and\n+   *\n+   *   2. `bsdf` for generating SDF from rasterized bitmaps.\n+   *\n+   *   Depending on the glyph type (i.e., outline or bitmap), one of the two\n+   *   rasterizers is chosen at runtime and used for generating SDFs.  To\n+   *   force the use of `bsdf` you should render the glyph with any of the\n+   *   FreeType's other rendering modes (e.g., `FT_RENDER_MODE_NORMAL`) and\n+   *   then re-render with `FT_RENDER_MODE_SDF`.\n+   *\n+   *   There are some issues with stability and possible failures of the SDF\n+   *   renderers (specifically `sdf`).\n+   *\n+   *   1. The `sdf` rasterizer is sensitive to really small features (e.g.,\n+   *      sharp turns that are less than 1~pixel) and imperfections in the\n+   *      glyph's outline, causing artifacts in the final output.\n+   *\n+   *   2. The `sdf` rasterizer has limited support for handling intersecting\n+   *      contours and *cannot* handle self-intersecting contours whatsoever.\n+   *      Self-intersection happens when a single connected contour\n+   *      intersects itself at some point; having these in your font\n+   *      definitely poses a problem to the rasterizer and cause artifacts,\n+   *      too.\n+   *\n+   *   3. Generating SDF for really small glyphs may result in undesirable\n+   *      output; the pixel grid (which stores distance information) becomes\n+   *      too coarse.\n+   *\n+   *   4. Since the output buffer is normalized, precision at smaller spreads\n+   *      is greater than precision at larger spread values because the\n+   *      output range of [0..255] gets mapped to a smaller SDF range.  A\n+   *      spread of~2 should be sufficient in most cases.\n+   *\n+   *   Points (1) and (2) can be avoided by using the `bsdf` rasterizer,\n+   *   which is more stable than the `sdf` rasterizer in general.\n+   *\n+   * @since:\n+   *   2.11\n+   *\/\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftdriver.h","additions":75,"deletions":1,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fterrdef.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fterrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftfntfmt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftgasp.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftglyph.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftgzip.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -24,0 +24,5 @@\n+   * Note: This file can be used for `STANDALONE_` compilation of raster\n+   *       (B\/W) and smooth (anti-aliased) renderers.  Therefore, it must\n+   *       rely on standard variable types only instead of aliases in\n+   *       `fttypes.h`.\n+   *\n@@ -321,1 +326,1 @@\n-   *     the 'SCANMODE' instruction).\n+   *     the 'SCANTYPE' instruction).\n@@ -344,2 +349,2 @@\n-    short       n_contours;      \/* number of contours in glyph        *\/\n-    short       n_points;        \/* number of points in the glyph      *\/\n+    unsigned short   n_contours;  \/* number of contours in glyph        *\/\n+    unsigned short   n_points;    \/* number of points in the glyph      *\/\n@@ -347,3 +352,3 @@\n-    FT_Vector*  points;          \/* the outline's points               *\/\n-    char*       tags;            \/* the points flags                   *\/\n-    short*      contours;        \/* the contour end points             *\/\n+    FT_Vector*       points;      \/* the outline's points               *\/\n+    unsigned char*   tags;        \/* the points flags                   *\/\n+    unsigned short*  contours;    \/* the contour end points             *\/\n@@ -351,1 +356,1 @@\n-    int         flags;           \/* outline masks                      *\/\n+    int              flags;       \/* outline masks                      *\/\n@@ -359,2 +364,2 @@\n-#define FT_OUTLINE_CONTOURS_MAX  SHRT_MAX\n-#define FT_OUTLINE_POINTS_MAX    SHRT_MAX\n+#define FT_OUTLINE_CONTOURS_MAX  USHRT_MAX\n+#define FT_OUTLINE_POINTS_MAX    USHRT_MAX\n@@ -437,2 +442,2 @@\n-   *   OpenType specification (in file `ttinst1.doc`) how simple drop-outs,\n-   *   smart drop-outs, and stubs are defined.\n+   *   [OpenType specification](https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/tt_instructions#scantype)\n+   *   how simple drop-outs, smart drop-outs, and stubs are defined.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftimage.h","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftincrem.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftlcdfil.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftlist.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2020-2023 by\n+ * Copyright (C) 2020-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftlogging.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmac.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -22,0 +22,1 @@\n+#include <freetype\/freetype.h>\n@@ -23,1 +24,5 @@\n-#include <freetype\/t1tables.h>\n+#ifdef FREETYPE_H\n+#error \"freetype.h of FreeType 1 has been loaded!\"\n+#error \"Please fix the directory search order for header files\"\n+#error \"so that freetype.h of FreeType 2 is found first.\"\n+#endif\n@@ -56,0 +61,24 @@\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   T1_MAX_MM_XXX\n+   *\n+   * @description:\n+   *   Multiple Masters limits as defined in their specifications.\n+   *\n+   * @values:\n+   *   T1_MAX_MM_AXIS ::\n+   *     The maximum number of Multiple Masters axes.\n+   *\n+   *   T1_MAX_MM_DESIGNS ::\n+   *     The maximum number of Multiple Masters designs.\n+   *\n+   *   T1_MAX_MM_MAP_POINTS ::\n+   *     The maximum number of elements in a design map.\n+   *\n+   *\/\n+#define T1_MAX_MM_AXIS         4\n+#define T1_MAX_MM_DESIGNS     16\n+#define T1_MAX_MM_MAP_POINTS  20\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmm.h","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmodapi.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmoderr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -115,1 +115,1 @@\n-   *   degenerate segments to become non-degenrate and visible, like when\n+   *   degenerate segments to become non-degenerate and visible, like when\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftoutln.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftparams.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftrender.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsizes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsnames.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftstroke.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsynth.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsystem.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fttrigon.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fttypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/autohint.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/cffotypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -251,4 +251,4 @@\n-    FT_Pos    blue_values[14];\n-    FT_Pos    other_blues[10];\n-    FT_Pos    family_blues[14];\n-    FT_Pos    family_other_blues[10];\n+    FT_Fixed  blue_values[14];\n+    FT_Fixed  other_blues[10];\n+    FT_Fixed  family_blues[14];\n+    FT_Fixed  family_other_blues[10];\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/cfftypes.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2020-2023 by\n+ * Copyright (C) 2020-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/compiler-macros.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -418,1 +418,1 @@\n-#elif defined( _M_ARM64 ) || defined( _M_ARM )\n+#elif defined( _M_ARM64 ) || defined( _M_ARM ) || defined( _M_ARM64EC )\n@@ -458,0 +458,6 @@\n+#elif defined( __SunOS_5_11 )\n+\n+#include <string.h>\n+\n+#define FT_MSB( x )  ( fls( x ) - 1 )\n+\n@@ -492,2 +498,0 @@\n-#if 0\n-\n@@ -510,1 +514,2 @@\n-   *   This function is not very fast.\n+   *   This function is slow and should be avoided.  Consider @FT_Hypot or\n+   *   @FT_Vector_NormLen instead.\n@@ -512,4 +517,2 @@\n-  FT_BASE( FT_Int32 )\n-  FT_SqrtFixed( FT_Int32  x );\n-\n-#endif \/* 0 *\/\n+  FT_BASE( FT_UInt32 )\n+  FT_SqrtFixed( FT_UInt32  x );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftcalc.h","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftdebug.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftdrv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftgloadr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -374,2 +374,5 @@\n-#define FT_MEM_DUP( dst, address, size )                                    \\\n-          (dst) = ft_mem_dup( memory, (address), (FT_ULong)(size), &error )\n+#define FT_MEM_DUP( dst, address, size )                       \\\n+          FT_ASSIGNP_INNER( dst, ft_mem_dup( memory,           \\\n+                                             (address),        \\\n+                                             (FT_ULong)(size), \\\n+                                             &error ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftmemory.h","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2022-2023 by\n+ * Copyright (C) 2022-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftmmtypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -607,6 +607,0 @@\n-#define FT_SIZE_FACE( x )     FT_SIZE( x )->face\n-#define FT_SLOT_FACE( x )     FT_SLOT( x )->face\n-\n-#define FT_FACE_SLOT( x )     FT_FACE( x )->glyph\n-#define FT_FACE_SIZE( x )     FT_FACE( x )->size\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftobjs.h","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftpsprop.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftrfork.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftserv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftstream.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n@@ -67,0 +67,1 @@\n+FT_TRACE_DEF( ttgpos )    \/* GPOS handler            (ttgpos.c)   *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/fttrace.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftvalid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -228,0 +228,1 @@\n+    T1_FIELD_LOCATION_NONE = 0,\n@@ -252,0 +253,1 @@\n+    FT_UInt             len;          \/* field identifier length        *\/\n@@ -276,0 +278,1 @@\n+            sizeof ( _ident ) - 1,                          \\\n@@ -277,1 +280,1 @@\n-            0,                                              \\\n+            NULL,                                           \\\n@@ -286,0 +289,1 @@\n+            sizeof ( _ident ) - 1,                      \\\n@@ -295,0 +299,1 @@\n+            sizeof ( _ident ) - 1,                               \\\n@@ -296,1 +301,1 @@\n-            0,                                                   \\\n+            NULL,                                                \\\n@@ -306,0 +311,1 @@\n+            sizeof ( _ident ) - 1,                                \\\n@@ -307,1 +313,1 @@\n-            0,                                                    \\\n+            NULL,                                                 \\\n@@ -357,0 +363,7 @@\n+#define T1_FIELD_ZERO                                         \\\n+          {                                                   \\\n+            0,                                                \\\n+            NULL, T1_FIELD_LOCATION_NONE, T1_FIELD_TYPE_NONE, \\\n+            NULL, 0, 0, 0, 0, 0                               \\\n+          }\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/psaux.h","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/pshints.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svbdf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svcfftl.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svcid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svfntfmt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svgldict.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svgxval.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svkern.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2016-2023 by\n+ * Copyright (C) 2016-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svmetric.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svmm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svotval.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpfr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpostnm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2012-2023 by\n+ * Copyright (C) 2012-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svprop.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpscmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpsinfo.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svsfnt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svttcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svtteng.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svttglyf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svwinfnt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -927,0 +927,1 @@\n+    TT_Load_Table_Func  load_gpos;\n@@ -947,0 +948,2 @@\n+    TT_Face_GetKerningFunc  get_gpos_kerning;\n+\n@@ -1005,0 +1008,1 @@\n+          load_gpos_,                    \\\n@@ -1012,0 +1016,1 @@\n+          get_gpos_kerning_,             \\\n@@ -1053,0 +1058,1 @@\n+    load_gpos_,                          \\\n@@ -1060,0 +1066,1 @@\n+    get_gpos_kerning_,                   \\\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/sfnt.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2022-2023 by\n+ * Copyright (C) 2022-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/svginterface.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -24,1 +24,1 @@\n-#include <freetype\/t1tables.h>\n+#include <freetype\/ftmm.h>\n@@ -140,0 +140,48 @@\n+  \/* this structure is used to store the BlendDesignMap entry for an axis *\/\n+  typedef struct  PS_DesignMap_\n+  {\n+    FT_Byte    num_points;\n+    FT_Long*   design_points;\n+    FT_Fixed*  blend_points;\n+\n+  } PS_DesignMapRec, *PS_DesignMap;\n+\n+  \/* backward compatible definition *\/\n+  typedef PS_DesignMapRec  T1_DesignMap;\n+\n+\n+  typedef struct  PS_BlendRec_\n+  {\n+    FT_UInt          num_designs;\n+    FT_UInt          num_axis;\n+\n+    FT_String*       axis_names[T1_MAX_MM_AXIS];\n+    FT_Fixed*        design_pos[T1_MAX_MM_DESIGNS];\n+    PS_DesignMapRec  design_map[T1_MAX_MM_AXIS];\n+\n+    FT_Fixed*        weight_vector;\n+    FT_Fixed*        default_weight_vector;\n+\n+    PS_FontInfo      font_infos[T1_MAX_MM_DESIGNS + 1];\n+    PS_Private       privates  [T1_MAX_MM_DESIGNS + 1];\n+\n+    FT_ULong         blend_bitflags;\n+\n+    FT_BBox*         bboxes    [T1_MAX_MM_DESIGNS + 1];\n+\n+    \/* since 2.3.0 *\/\n+\n+    \/* undocumented, optional: the default design instance;   *\/\n+    \/* corresponds to default_weight_vector --                *\/\n+    \/* num_default_design_vector == 0 means it is not present *\/\n+    \/* in the font and associated metrics files               *\/\n+    FT_UInt          default_design_vector[T1_MAX_MM_DESIGNS];\n+    FT_UInt          num_default_design_vector;\n+\n+  } PS_BlendRec, *PS_Blend;\n+\n+\n+  \/* backward compatible definition *\/\n+  typedef PS_BlendRec  T1_Blend;\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/t1types.h","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -27,0 +27,1 @@\n+#include \"freetype\/fttypes.h\"\n@@ -1584,0 +1585,5 @@\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+    FT_Byte*              gpos_table;\n+    FT_Bool               gpos_kerning_available;\n+#endif\n+\n@@ -1652,1 +1658,1 @@\n-    FT_Short    max_contours;\n+    FT_UShort   max_contours;\n@@ -1654,1 +1660,1 @@\n-    FT_Short    n_contours;  \/* number of contours          *\/\n+    FT_UShort   n_contours;  \/* number of contours          *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/tttypes.h","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/wofftypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2022-2023 by\n+ * Copyright (C) 2022-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/otsvg.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -272,58 +272,0 @@\n-  \/* maximum number of Multiple Masters designs, as defined in the spec *\/\n-#define T1_MAX_MM_DESIGNS     16\n-\n-  \/* maximum number of Multiple Masters axes, as defined in the spec *\/\n-#define T1_MAX_MM_AXIS        4\n-\n-  \/* maximum number of elements in a design map *\/\n-#define T1_MAX_MM_MAP_POINTS  20\n-\n-\n-  \/* this structure is used to store the BlendDesignMap entry for an axis *\/\n-  typedef struct  PS_DesignMap_\n-  {\n-    FT_Byte    num_points;\n-    FT_Long*   design_points;\n-    FT_Fixed*  blend_points;\n-\n-  } PS_DesignMapRec, *PS_DesignMap;\n-\n-  \/* backward compatible definition *\/\n-  typedef PS_DesignMapRec  T1_DesignMap;\n-\n-\n-  typedef struct  PS_BlendRec_\n-  {\n-    FT_UInt          num_designs;\n-    FT_UInt          num_axis;\n-\n-    FT_String*       axis_names[T1_MAX_MM_AXIS];\n-    FT_Fixed*        design_pos[T1_MAX_MM_DESIGNS];\n-    PS_DesignMapRec  design_map[T1_MAX_MM_AXIS];\n-\n-    FT_Fixed*        weight_vector;\n-    FT_Fixed*        default_weight_vector;\n-\n-    PS_FontInfo      font_infos[T1_MAX_MM_DESIGNS + 1];\n-    PS_Private       privates  [T1_MAX_MM_DESIGNS + 1];\n-\n-    FT_ULong         blend_bitflags;\n-\n-    FT_BBox*         bboxes    [T1_MAX_MM_DESIGNS + 1];\n-\n-    \/* since 2.3.0 *\/\n-\n-    \/* undocumented, optional: the default design instance;   *\/\n-    \/* corresponds to default_weight_vector --                *\/\n-    \/* num_default_design_vector == 0 means it is not present *\/\n-    \/* in the font and associated metrics files               *\/\n-    FT_UInt          default_design_vector[T1_MAX_MM_DESIGNS];\n-    FT_UInt          num_default_design_vector;\n-\n-  } PS_BlendRec, *PS_Blend;\n-\n-\n-  \/* backward compatible definition *\/\n-  typedef PS_BlendRec  T1_Blend;\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/t1tables.h","additions":1,"deletions":59,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ttnameid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -841,2 +841,3 @@\n-   *   The format of `charmap`.  If `charmap` doesn't belong to an SFNT face,\n-   *   return -1.\n+   *   The format of `charmap`.  If `charmap` doesn't belong to an SFNT face\n+   *   (including the synthetic Unicode charmap sometimes created by\n+   *   FreeType), return -1.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/tttables.h","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/tttags.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/ft2build.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.cin","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-\/\/ Copyright (C) 2013-2023 by\n+\/\/ Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.dat","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.hin","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afcjk.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n@@ -87,1 +87,1 @@\n-    AF_CJKBlueRec  blues[AF_BLUE_STRINGSET_MAX];\n+    AF_CJKBlueRec  blues[AF_BLUE_STRINGSET_MAX_LEN];\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afcjk.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afcover.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afdummy.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afdummy.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2023 by\n+ * Copyright (C) 2005-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aferrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afglobal.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afglobal.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n@@ -982,2 +982,2 @@\n-        char*       tag           = outline->tags;\n-        FT_Short    endpoint      = outline->contours[0];\n+        FT_Byte*    tag           = outline->tags;\n+        FT_UShort   endpoint      = outline->contours[0];\n@@ -1049,4 +1049,4 @@\n-        AF_Point*  contour       = hints->contours;\n-        AF_Point*  contour_limit = contour + hints->num_contours;\n-        short*     end           = outline->contours;\n-        short      idx           = 0;\n+        AF_Point*   contour       = hints->contours;\n+        AF_Point*   contour_limit = contour + hints->num_contours;\n+        FT_UShort*  end           = outline->contours;\n+        FT_Int      idx           = 0;\n@@ -1058,1 +1058,1 @@\n-          idx        = (short)( end[0] + 1 );\n+          idx        = *end + 1;\n@@ -1295,1 +1295,1 @@\n-    char*       tag   = outline->tags;\n+    FT_Byte*    tag   = outline->tags;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afhints.c","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afhints.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afindic.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afindic.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n@@ -984,1 +984,1 @@\n-      AF_LatinBlue  blue_sorted[AF_BLUE_STRINGSET_MAX_LEN + 2];\n+      AF_LatinBlue  blue_sorted[AF_BLUE_STRINGSET_MAX_LEN];\n@@ -1266,2 +1266,1 @@\n-            dist  = FT_ABS( FT_MulFix( max_height, new_scale - scale ) );\n-            dist &= ~127;\n+            dist  = FT_MulFix( max_height, new_scale - scale );\n@@ -1269,1 +1268,1 @@\n-            if ( dist == 0 )\n+            if ( -128 < dist && dist < 128 )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aflatin.c","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n@@ -101,1 +101,1 @@\n-    AF_LatinBlueRec  blues[AF_BLUE_STRINGSET_MAX];\n+    AF_LatinBlueRec  blues[AF_BLUE_STRINGSET_MAX_LEN];\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aflatin.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afloader.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afloader.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n@@ -441,1 +441,1 @@\n-    FT_Memory  memory = module->root.library->memory;\n+    FT_Memory  memory = module->root.memory;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afmodule.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afmodule.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afranges.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afranges.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afscript.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afshaper.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afshaper.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afstyles.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aftypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afws-decl.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afws-iter.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2023 by\n+ * Copyright (C) 2008-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftadvanc.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2023 by\n+ * Copyright (C) 2008-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftbase.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -492,1 +492,1 @@\n-    if ( outline->n_points == 0 || outline->n_contours <= 0 )\n+    if ( outline->n_points == 0 || outline->n_contours == 0 )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftbbox.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftbitmap.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -72,7 +72,9 @@\n-#define FT_MOVE_SIGN( x, x_unsigned, s ) \\\n-  FT_BEGIN_STMNT                         \\\n-    if ( x < 0 )                         \\\n-    {                                    \\\n-      x_unsigned = 0U - (x_unsigned);    \\\n-      s          = -s;                   \\\n-    }                                    \\\n+#define FT_MOVE_SIGN( utype, x, x_unsigned, s ) \\\n+  FT_BEGIN_STMNT                                \\\n+    if ( x < 0 )                                \\\n+    {                                           \\\n+      x_unsigned = 0U - (utype)x;               \\\n+      s          = -s;                          \\\n+    }                                           \\\n+    else                                        \\\n+      x_unsigned = (utype)x;                    \\\n@@ -182,7 +184,3 @@\n-    a = (FT_UInt64)a_;\n-    b = (FT_UInt64)b_;\n-    c = (FT_UInt64)c_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n-    FT_MOVE_SIGN( c_, c, s );\n+    FT_MOVE_SIGN( FT_UInt64, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt64, b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt64, c_, c, s );\n@@ -211,7 +209,3 @@\n-    a = (FT_UInt64)a_;\n-    b = (FT_UInt64)b_;\n-    c = (FT_UInt64)c_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n-    FT_MOVE_SIGN( c_, c, s );\n+    FT_MOVE_SIGN( FT_UInt64, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt64, b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt64, c_, c, s );\n@@ -260,5 +254,2 @@\n-    a = (FT_UInt64)a_;\n-    b = (FT_UInt64)b_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt64, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt64, b_, b, s );\n@@ -425,7 +416,3 @@\n-    a = (FT_UInt32)a_;\n-    b = (FT_UInt32)b_;\n-    c = (FT_UInt32)c_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n-    FT_MOVE_SIGN( c_, c, s );\n+    FT_MOVE_SIGN( FT_UInt32, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt32, b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt32, c_, c, s );\n@@ -473,7 +460,3 @@\n-    a = (FT_UInt32)a_;\n-    b = (FT_UInt32)b_;\n-    c = (FT_UInt32)c_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n-    FT_MOVE_SIGN( c_, c, s );\n+    FT_MOVE_SIGN( FT_UInt32, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt32, b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt32, c_, c, s );\n@@ -578,5 +561,2 @@\n-    a = (FT_UInt32)a_;\n-    b = (FT_UInt32)b_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt32, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt32, b_, b, s );\n@@ -617,5 +597,2 @@\n-    a = (FT_UInt32)a_;\n-    b = (FT_UInt32)b_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt32, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt32, b_, b, s );\n@@ -832,5 +809,2 @@\n-    x = (FT_UInt32)x_;\n-    y = (FT_UInt32)y_;\n-\n-    FT_MOVE_SIGN( x_, x, sx );\n-    FT_MOVE_SIGN( y_, y, sy );\n+    FT_MOVE_SIGN( FT_UInt32, x_, x, sx );\n+    FT_MOVE_SIGN( FT_UInt32, y_, y, sy );\n@@ -916,2 +890,0 @@\n-#if 0\n-\n@@ -920,2 +892,2 @@\n-  FT_BASE_DEF( FT_Int32 )\n-  FT_SqrtFixed( FT_Int32  x )\n+  FT_BASE_DEF( FT_UInt32 )\n+  FT_SqrtFixed( FT_UInt32  v )\n@@ -923,3 +895,2 @@\n-    FT_UInt32  root, rem_hi, rem_lo, test_div;\n-    FT_Int     count;\n-\n+    if ( v == 0 )\n+      return 0;\n@@ -927,1 +898,1 @@\n-    root = 0;\n+#ifndef FT_INT64\n@@ -929,1 +900,6 @@\n-    if ( x > 0 )\n+    \/* Algorithm by Christophe Meessen (1993) with overflow fixed and     *\/\n+    \/* rounding added.  Any unsigned fixed 16.16 argument is acceptable.  *\/\n+    \/* However, this algorithm is slower than the Babylonian method with  *\/\n+    \/* a good initial guess.  We only use it for large 32-bit values when *\/\n+    \/* 64-bit computations are not desirable.                             *\/\n+    else if ( v > 0x10000U )\n@@ -931,3 +907,6 @@\n-      rem_hi = 0;\n-      rem_lo = (FT_UInt32)x;\n-      count  = 24;\n+      FT_UInt32  r = v >> 1;\n+      FT_UInt32  q = ( v & 1 ) << 15;\n+      FT_UInt32  b = 0x20000000;\n+      FT_UInt32  t;\n+\n+\n@@ -936,6 +915,2 @@\n-        rem_hi   = ( rem_hi << 2 ) | ( rem_lo >> 30 );\n-        rem_lo <<= 2;\n-        root   <<= 1;\n-        test_div = ( root << 1 ) + 1;\n-\n-        if ( rem_hi >= test_div )\n+        t = q + b;\n+        if ( r >= t )\n@@ -943,2 +918,2 @@\n-          rem_hi -= test_div;\n-          root   += 1;\n+          r -= t;\n+          q  = t + b;  \/* equivalent to q += 2*b *\/\n@@ -946,1 +921,6 @@\n-      } while ( --count );\n+        r <<= 1;\n+        b >>= 1;\n+\n+      } while ( b > 0x10 );  \/* exactly 25 cycles *\/\n+\n+      return ( q + 0x40 ) >> 7;\n@@ -948,0 +928,3 @@\n+    else\n+    {\n+      FT_UInt32  r = ( v << 16 ) - 1;\n@@ -949,2 +932,1 @@\n-    return (FT_Int32)root;\n-  }\n+#else \/* FT_INT64 *\/\n@@ -952,1 +934,21 @@\n-#endif \/* 0 *\/\n+    else\n+    {\n+      FT_UInt64  r = ( (FT_UInt64)v << 16 ) - 1;\n+\n+#endif \/* FT_INT64 *\/\n+\n+      FT_UInt32  q = 1 << ( ( 17 + FT_MSB( v ) ) >> 1 );\n+      FT_UInt32  t;\n+\n+\n+      \/* Babylonian method with rounded-up division *\/\n+      do\n+      {\n+        t = q;\n+        q = ( t + (FT_UInt32)( r \/ t ) + 1 ) >> 1;\n+\n+      } while ( q != t );  \/* less than 6 cycles *\/\n+\n+      return q;\n+    }\n+  }\n@@ -1097,5 +1099,2 @@\n-      scalar = (FT_UInt32)s[i];\n-      factor = (FT_UInt32)f[i];\n-\n-      FT_MOVE_SIGN( s[i], scalar, sign );\n-      FT_MOVE_SIGN( f[i], factor, sign );\n+      FT_MOVE_SIGN( FT_UInt32, s[i], scalar, sign );\n+      FT_MOVE_SIGN( FT_UInt32, f[i], factor, sign );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcalc.c","additions":84,"deletions":85,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcid.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcolor.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftdbgmem.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftdebug.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftfntfmt.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2023 by\n+ * Copyright (C) 2008-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftfstype.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftgasp.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n@@ -358,6 +358,3 @@\n-    FT_GlyphLoad  base;\n-    FT_GlyphLoad  current;\n-\n-    FT_Int        n_curr_contours;\n-    FT_Int        n_base_points;\n-    FT_Int        n;\n+    FT_Outline*  base;\n+    FT_Outline*  current;\n+    FT_Int       n;\n@@ -369,5 +366,2 @@\n-    base    = &loader->base;\n-    current = &loader->current;\n-\n-    n_curr_contours = current->outline.n_contours;\n-    n_base_points   = base->outline.n_points;\n+    base    = &loader->base.outline;\n+    current = &loader->current.outline;\n@@ -375,4 +369,3 @@\n-    base->outline.n_points =\n-      (short)( base->outline.n_points + current->outline.n_points );\n-    base->outline.n_contours =\n-      (short)( base->outline.n_contours + current->outline.n_contours );\n+    \/* adjust contours count in newest outline *\/\n+    for ( n = 0; n < current->n_contours; n++ )\n+      current->contours[n] += base->n_points;\n@@ -380,1 +373,2 @@\n-    base->num_subglyphs += current->num_subglyphs;\n+    base->n_points   += current->n_points;\n+    base->n_contours += current->n_contours;\n@@ -382,4 +376,1 @@\n-    \/* adjust contours count in newest outline *\/\n-    for ( n = 0; n < n_curr_contours; n++ )\n-      current->outline.contours[n] =\n-        (short)( current->outline.contours[n] + n_base_points );\n+    loader->base.num_subglyphs += loader->current.num_subglyphs;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftgloadr.c","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftglyph.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftinit.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftlcdfil.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -815,0 +815,1 @@\n+    FT_Long        count;\n@@ -824,0 +825,1 @@\n+    res_index        = 1;\n@@ -825,1 +827,2 @@\n-    for ( res_index = 1; ; res_index++ )\n+    count            = face_index;\n+    while ( count >= 0 )\n@@ -837,2 +840,2 @@\n-      if ( 0 <= face_index && face_index < num_faces_in_fond && error )\n-        error = FT_New_Face_From_FOND( library, fond, face_index, aface );\n+      if ( count < num_faces_in_fond )\n+        error = FT_New_Face_From_FOND( library, fond, count, aface );\n@@ -840,1 +843,2 @@\n-      face_index -= num_faces_in_fond;\n+      res_index++;\n+      count -= num_faces_in_fond;\n@@ -844,0 +848,1 @@\n+\n@@ -845,1 +850,5 @@\n-      (*aface)->num_faces = num_faces_in_res;\n+    {\n+      (*aface)->num_faces  = num_faces_in_res;\n+      (*aface)->face_index = face_index;\n+    }\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftmac.c","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftmm.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -2305,1 +2305,4 @@\n-        (*aface)->num_faces = count;\n+      {\n+        (*aface)->num_faces  = count;\n+        (*aface)->face_index = face_index_internal;\n+      }\n@@ -5794,1 +5797,1 @@\n-    if ( sfnt->get_colr_layer )\n+    if ( sfnt->get_colr_glyph_paint )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftobjs.c","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -56,1 +56,1 @@\n-    char*       tags;\n+    FT_Byte*    tags;\n@@ -335,2 +335,2 @@\n-    anoutline->n_points    = (FT_Short)numPoints;\n-    anoutline->n_contours  = (FT_Short)numContours;\n+    anoutline->n_points    = (FT_UShort)numPoints;\n+    anoutline->n_contours  = (FT_UShort)numContours;\n@@ -362,0 +362,2 @@\n+      FT_TRACE5(( \"FT_Outline_Check: contours = %d, points = %d\\n\",\n+                  n_contours, n_points ));\n@@ -367,1 +369,1 @@\n-      if ( n_points <= 0 || n_contours <= 0 )\n+      if ( n_points == 0 || n_contours == 0 )\n@@ -579,2 +581,2 @@\n-        char*  p = outline->tags + first;\n-        char*  q = outline->tags + last;\n+        FT_Byte*  p = outline->tags + first;\n+        FT_Byte*  q = outline->tags + last;\n@@ -585,1 +587,1 @@\n-          char  swap;\n+          FT_Byte  swap;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftoutln.c","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftpatent.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftpsprop.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftrfork.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftsnames.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2024 by\n@@ -766,1 +766,1 @@\n-          FT_UInt  len = fields->size;\n+          FT_Offset  len = fields->size;\n@@ -769,1 +769,1 @@\n-          if ( cursor + len > stream->limit )\n+          if ( len > (FT_Offset)( stream->limit - cursor ) )\n@@ -833,1 +833,1 @@\n-      \/* now, compute the signed value is necessary *\/\n+      \/* now, compute the signed value if necessary *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftstream.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n@@ -714,1 +714,1 @@\n-      FT_Byte*  write = (FT_Byte*)outline->tags + outline->n_points;\n+      FT_Byte*  write = outline->tags + outline->n_points;\n@@ -730,4 +730,4 @@\n-      FT_UInt    count = border->num_points;\n-      FT_Byte*   tags  = border->tags;\n-      FT_Short*  write = outline->contours + outline->n_contours;\n-      FT_Short   idx   = (FT_Short)outline->n_points;\n+      FT_UInt     count = border->num_points;\n+      FT_Byte*    tags  = border->tags;\n+      FT_UShort*  write = outline->contours + outline->n_contours;\n+      FT_UShort   idx   = outline->n_points;\n@@ -746,1 +746,1 @@\n-    outline->n_points += (short)border->num_points;\n+    outline->n_points += (FT_UShort)border->num_points;\n@@ -2053,1 +2053,1 @@\n-    char*       tags;\n+    FT_Byte*    tags;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftstroke.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftsynth.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftsystem.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/fttrigon.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/fttype1.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftutil.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffcmap.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffdrivr.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffdrivr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cfferrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffgload.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -1205,1 +1205,1 @@\n-          FT_Int16  start14, peak14, end14;\n+          FT_Int  start, peak, end;\n@@ -1208,3 +1208,3 @@\n-          if ( FT_READ_SHORT( start14 ) ||\n-               FT_READ_SHORT( peak14 )  ||\n-               FT_READ_SHORT( end14 )   )\n+          if ( FT_READ_SHORT( start ) ||\n+               FT_READ_SHORT( peak )  ||\n+               FT_READ_SHORT( end )   )\n@@ -1213,3 +1213,7 @@\n-          axis->startCoord = FT_fdot14ToFixed( start14 );\n-          axis->peakCoord  = FT_fdot14ToFixed( peak14 );\n-          axis->endCoord   = FT_fdot14ToFixed( end14 );\n+          \/* immediately tag invalid ranges with special peak = 0 *\/\n+          if ( ( start < 0 && end > 0 ) || start > peak || peak > end )\n+            peak = 0;\n+\n+          axis->startCoord = FT_fdot14ToFixed( start );\n+          axis->peakCoord  = FT_fdot14ToFixed( peak );\n+          axis->endCoord   = FT_fdot14ToFixed( end );\n@@ -1382,4 +1386,4 @@\n-      *subFont->blend_top++ = (FT_Byte)( sum >> 24 );\n-      *subFont->blend_top++ = (FT_Byte)( sum >> 16 );\n-      *subFont->blend_top++ = (FT_Byte)( sum >>  8 );\n-      *subFont->blend_top++ = (FT_Byte)sum;\n+      *subFont->blend_top++ = (FT_Byte)( (FT_UInt32)sum >> 24 );\n+      *subFont->blend_top++ = (FT_Byte)( (FT_UInt32)sum >> 16 );\n+      *subFont->blend_top++ = (FT_Byte)( (FT_UInt32)sum >>  8 );\n+      *subFont->blend_top++ = (FT_Byte)( (FT_UInt32)sum );\n@@ -1498,8 +1502,0 @@\n-        FT_Fixed         axisScalar;\n-\n-\n-        \/* compute the scalar contribution of this axis; *\/\n-        \/* ignore invalid ranges                         *\/\n-        if ( axis->startCoord > axis->peakCoord ||\n-             axis->peakCoord > axis->endCoord   )\n-          axisScalar = FT_FIXED_ONE;\n@@ -1507,4 +1503,0 @@\n-        else if ( axis->startCoord < 0 &&\n-                  axis->endCoord > 0   &&\n-                  axis->peakCoord != 0 )\n-          axisScalar = FT_FIXED_ONE;\n@@ -1512,3 +1504,5 @@\n-        \/* peak of 0 means ignore this axis *\/\n-        else if ( axis->peakCoord == 0 )\n-          axisScalar = FT_FIXED_ONE;\n+        \/* compute the scalar contribution of this axis *\/\n+        \/* with peak of 0 used for invalid axes         *\/\n+        if ( axis->peakCoord == NDV[j] ||\n+             axis->peakCoord == 0      )\n+          continue;\n@@ -1517,6 +1511,2 @@\n-        else if ( NDV[j] < axis->startCoord ||\n-                  NDV[j] > axis->endCoord   )\n-          axisScalar = 0;\n-\n-        \/* calculate a proportional factor *\/\n-        else\n+        else if ( NDV[j] <= axis->startCoord ||\n+                  NDV[j] >= axis->endCoord   )\n@@ -1524,8 +1514,2 @@\n-          if ( NDV[j] == axis->peakCoord )\n-            axisScalar = FT_FIXED_ONE;\n-          else if ( NDV[j] < axis->peakCoord )\n-            axisScalar = FT_DivFix( NDV[j] - axis->startCoord,\n-                                    axis->peakCoord - axis->startCoord );\n-          else\n-            axisScalar = FT_DivFix( axis->endCoord - NDV[j],\n-                                    axis->endCoord - axis->peakCoord );\n+          blend->BV[master] = 0;\n+          break;\n@@ -1534,2 +1518,9 @@\n-        \/* take product of all the axis scalars *\/\n-        blend->BV[master] = FT_MulFix( blend->BV[master], axisScalar );\n+        \/* adjust proportionally *\/\n+        else if ( NDV[j] < axis->peakCoord )\n+          blend->BV[master] = FT_MulDiv( blend->BV[master],\n+                                         NDV[j] - axis->startCoord,\n+                                         axis->peakCoord - axis->startCoord );\n+        else   \/* NDV[j] > axis->peakCoord ) *\/\n+          blend->BV[master] = FT_MulDiv( blend->BV[master],\n+                                         axis->endCoord - NDV[j],\n+                                         axis->endCoord - axis->peakCoord );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffload.c","additions":34,"deletions":43,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -45,0 +45,2 @@\n+#define CFF_fixedToInt( x )                          \\\n+          ( (FT_Short)( ( (x) + 0x8000U ) >> 16 ) )\n@@ -127,1 +129,1 @@\n-      priv->blue_values[n] = (FT_Short)cpriv->blue_values[n];\n+      priv->blue_values[n] = CFF_fixedToInt( cpriv->blue_values[n] );\n@@ -131,1 +133,1 @@\n-      priv->other_blues[n] = (FT_Short)cpriv->other_blues[n];\n+      priv->other_blues[n] = CFF_fixedToInt( cpriv->other_blues[n] );\n@@ -135,1 +137,1 @@\n-      priv->family_blues[n] = (FT_Short)cpriv->family_blues[n];\n+      priv->family_blues[n] = CFF_fixedToInt( cpriv->family_blues[n] );\n@@ -139,1 +141,2 @@\n-      priv->family_other_blues[n] = (FT_Short)cpriv->family_other_blues[n];\n+      priv->family_other_blues[n] =\n+        CFF_fixedToInt( cpriv->family_other_blues[n] );\n@@ -424,3 +427,1 @@\n-    FT_Int32  idx             = 0;\n-    FT_Int32  length          = (FT_Int32)ft_strlen( name ) + 1;\n-    FT_Bool   continue_search = 1;\n+    FT_UInt32  i = 0, idx = 0;\n@@ -429,1 +430,8 @@\n-    while ( continue_search )\n+    \/* six ASCII uppercase letters followed by a plus sign *\/\n+    while ( 'A' <= name[i] && name[i++] <= 'Z' &&\n+            'A' <= name[i] && name[i++] <= 'Z' &&\n+            'A' <= name[i] && name[i++] <= 'Z' &&\n+            'A' <= name[i] && name[i++] <= 'Z' &&\n+            'A' <= name[i] && name[i++] <= 'Z' &&\n+            'A' <= name[i] && name[i++] <= 'Z' &&\n+                              name[i++] == '+' )\n@@ -431,18 +439,1 @@\n-      if ( length >= 7 && name[6] == '+' )\n-      {\n-        for ( idx = 0; idx < 6; idx++ )\n-        {\n-          \/* ASCII uppercase letters *\/\n-          if ( !( 'A' <= name[idx] && name[idx] <= 'Z' ) )\n-            continue_search = 0;\n-        }\n-\n-        if ( continue_search )\n-        {\n-          for ( idx = 7; idx < length; idx++ )\n-            name[idx - 7] = name[idx];\n-          length -= 7;\n-        }\n-      }\n-      else\n-        continue_search = 0;\n+      idx = i;\n@@ -450,0 +441,3 @@\n+\n+    if ( idx )\n+      FT_MEM_MOVE( name, name + idx, ft_strlen( name + idx ) + 1 );\n@@ -459,1 +453,2 @@\n-    FT_Int32  family_name_length, style_name_length;\n+    FT_String*        f = family_name + ft_strlen( family_name );\n+    const FT_String*  s =  style_name + ft_strlen(  style_name );\n@@ -462,2 +457,4 @@\n-    family_name_length = (FT_Int32)ft_strlen( family_name );\n-    style_name_length  = (FT_Int32)ft_strlen( style_name );\n+    \/* compare strings moving backwards *\/\n+    while ( s > style_name )\n+      if ( f == family_name || *--s != *--f )\n+        return;\n@@ -465,30 +462,5 @@\n-    if ( family_name_length > style_name_length )\n-    {\n-      FT_Int  idx;\n-\n-\n-      for ( idx = 1; idx <= style_name_length; idx++ )\n-      {\n-        if ( family_name[family_name_length - idx] !=\n-             style_name[style_name_length - idx] )\n-          break;\n-      }\n-\n-      if ( idx > style_name_length )\n-      {\n-        \/* family_name ends with style_name; remove it *\/\n-        idx = family_name_length - style_name_length - 1;\n-\n-        \/* also remove special characters     *\/\n-        \/* between real family name and style *\/\n-        while ( idx > 0                     &&\n-                ( family_name[idx] == '-' ||\n-                  family_name[idx] == ' ' ||\n-                  family_name[idx] == '_' ||\n-                  family_name[idx] == '+' ) )\n-          idx--;\n-\n-        if ( idx > 0 )\n-          family_name[idx + 1] = '\\0';\n-      }\n-    }\n+    \/* terminate and remove special characters *\/\n+    do\n+      *f = '\\0';\n+    while ( f-- > family_name                                    &&\n+            ( *f == '-' || *f == ' ' || *f == '_' || *f == '+' ) );\n@@ -725,2 +697,1 @@\n-        if ( FT_HAS_MULTIPLE_MASTERS( cffface ) &&\n-             instance_index > 0                 )\n+        if ( FT_HAS_MULTIPLE_MASTERS( cffface ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffobjs.c","additions":33,"deletions":62,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -504,4 +504,4 @@\n-      FT_Fixed val = ( ( ( (FT_UInt32)*( d[0] + 1 ) << 24 ) |\n-                         ( (FT_UInt32)*( d[0] + 2 ) << 16 ) |\n-                         ( (FT_UInt32)*( d[0] + 3 ) <<  8 ) |\n-                           (FT_UInt32)*( d[0] + 4 )         ) );\n+      FT_Fixed val = (FT_Int32)( ( ( (FT_UInt32)*( d[0] + 1 ) << 24 ) |\n+                                   ( (FT_UInt32)*( d[0] + 2 ) << 16 ) |\n+                                   ( (FT_UInt32)*( d[0] + 3 ) <<  8 ) |\n+                                     (FT_UInt32)*( d[0] + 4 )         ) );\n@@ -1034,0 +1034,4 @@\n+#define CFF_FIELD_DELTA( code, name, max, id )                        \\\n+          CFF_FIELD_DELTA_KIND( code, name, max, id, cff_kind_delta )\n+#define CFF_FIELD_DELTA_FIXED( code, name, max, id )                        \\\n+          CFF_FIELD_DELTA_KIND( code, name, max, id, cff_kind_delta_fixed )\n@@ -1037,1 +1041,1 @@\n-#undef  CFF_FIELD_DELTA\n+#undef  CFF_FIELD_DELTA_KIND\n@@ -1067,1 +1071,1 @@\n-            0, 0, 0                       \\\n+            NULL, 0, 0                    \\\n@@ -1070,9 +1074,9 @@\n-#define CFF_FIELD_DELTA( code, name, max, id ) \\\n-          {                                    \\\n-            cff_kind_delta,                    \\\n-            code | CFFCODE,                    \\\n-            FT_FIELD_OFFSET( name ),           \\\n-            FT_FIELD_SIZE_DELTA( name ),       \\\n-            0,                                 \\\n-            max,                               \\\n-            FT_FIELD_OFFSET( num_ ## name )    \\\n+#define CFF_FIELD_DELTA_KIND( code, name, max, id, kind ) \\\n+          {                                               \\\n+            kind,                                         \\\n+            code | CFFCODE,                               \\\n+            FT_FIELD_OFFSET( name ),                      \\\n+            FT_FIELD_SIZE_DELTA( name ),                  \\\n+            NULL,                                         \\\n+            max,                                          \\\n+            FT_FIELD_OFFSET( num_ ## name )               \\\n@@ -1086,1 +1090,1 @@\n-    { 0, 0, 0, 0, 0, 0, 0 }\n+    { 0, 0, 0, 0, NULL, 0, 0 }\n@@ -1120,1 +1124,1 @@\n-            0, 0, 0,                      \\\n+            NULL, 0, 0,                   \\\n@@ -1124,10 +1128,10 @@\n-#define CFF_FIELD_DELTA( code, name, max, id ) \\\n-          {                                    \\\n-            cff_kind_delta,                    \\\n-            code | CFFCODE,                    \\\n-            FT_FIELD_OFFSET( name ),           \\\n-            FT_FIELD_SIZE_DELTA( name ),       \\\n-            0,                                 \\\n-            max,                               \\\n-            FT_FIELD_OFFSET( num_ ## name ),   \\\n-            id                                 \\\n+#define CFF_FIELD_DELTA_KIND( code, name, max, id, kind ) \\\n+          {                                               \\\n+            kind,                                         \\\n+            code | CFFCODE,                               \\\n+            FT_FIELD_OFFSET( name ),                      \\\n+            FT_FIELD_SIZE_DELTA( name ),                  \\\n+            NULL,                                         \\\n+            max,                                          \\\n+            FT_FIELD_OFFSET( num_ ## name ),              \\\n+            id                                            \\\n@@ -1141,1 +1145,1 @@\n-    { 0, 0, 0, 0, 0, 0, 0, 0 }\n+    { 0, 0, 0, 0, NULL, 0, 0, NULL }\n@@ -1359,1 +1363,2 @@\n-            if ( field->kind != cff_kind_delta && num_args < 1 )\n+            if ( field->kind != cff_kind_delta                       &&\n+                 field->kind != cff_kind_delta_fixed && num_args < 1 )\n@@ -1467,0 +1472,32 @@\n+                  num_args--;\n+                }\n+\n+                FT_TRACE4(( \"]\\n\" ));\n+              }\n+              break;\n+\n+            case cff_kind_delta_fixed:\n+              {\n+                FT_Byte*   qcount = (FT_Byte*)parser->object +\n+                                      field->count_offset;\n+\n+                FT_Byte**  data = parser->stack;\n+\n+\n+                if ( num_args > field->array_max )\n+                  num_args = field->array_max;\n+\n+                FT_TRACE4(( \" [\" ));\n+\n+                \/* store count *\/\n+                *qcount = (FT_Byte)num_args;\n+\n+                val = 0;\n+                while ( num_args > 0 )\n+                {\n+                  val = ADD_LONG( val, cff_parse_fixed( parser, data++ ) );\n+                  *(FT_Long*)q = val;\n+\n+                  FT_TRACE4(( \" %f\\n\", (double)val \/ 65536 ));\n+\n+                  q += field->size;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffparse.c","additions":67,"deletions":30,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -110,0 +110,1 @@\n+    cff_kind_delta_fixed,\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffparse.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -83,20 +83,20 @@\n-  CFF_FIELD_DELTA     ( 6,     blue_values, 14,        \"BlueValues\" )\n-  CFF_FIELD_DELTA     ( 7,     other_blues, 10,        \"OtherBlues\" )\n-  CFF_FIELD_DELTA     ( 8,     family_blues, 14,       \"FamilyBlues\" )\n-  CFF_FIELD_DELTA     ( 9,     family_other_blues, 10, \"FamilyOtherBlues\" )\n-  CFF_FIELD_FIXED_1000( 0x109, blue_scale,             \"BlueScale\" )\n-  CFF_FIELD_NUM       ( 0x10A, blue_shift,             \"BlueShift\" )\n-  CFF_FIELD_NUM       ( 0x10B, blue_fuzz,              \"BlueFuzz\" )\n-  CFF_FIELD_NUM       ( 10,    standard_width,         \"StdHW\" )\n-  CFF_FIELD_NUM       ( 11,    standard_height,        \"StdVW\" )\n-  CFF_FIELD_DELTA     ( 0x10C, snap_widths, 13,        \"StemSnapH\" )\n-  CFF_FIELD_DELTA     ( 0x10D, snap_heights, 13,       \"StemSnapV\" )\n-  CFF_FIELD_BOOL      ( 0x10E, force_bold,             \"ForceBold\" )\n-  CFF_FIELD_FIXED     ( 0x10F, force_bold_threshold,   \"ForceBoldThreshold\" )\n-  CFF_FIELD_NUM       ( 0x110, lenIV,                  \"lenIV\" )\n-  CFF_FIELD_NUM       ( 0x111, language_group,         \"LanguageGroup\" )\n-  CFF_FIELD_FIXED     ( 0x112, expansion_factor,       \"ExpansionFactor\" )\n-  CFF_FIELD_NUM       ( 0x113, initial_random_seed,    \"initialRandomSeed\" )\n-  CFF_FIELD_NUM       ( 19,    local_subrs_offset,     \"Subrs\" )\n-  CFF_FIELD_NUM       ( 20,    default_width,          \"defaultWidthX\" )\n-  CFF_FIELD_NUM       ( 21,    nominal_width,          \"nominalWidthX\" )\n+  CFF_FIELD_DELTA_FIXED( 6,     blue_values, 14,        \"BlueValues\" )\n+  CFF_FIELD_DELTA_FIXED( 7,     other_blues, 10,        \"OtherBlues\" )\n+  CFF_FIELD_DELTA_FIXED( 8,     family_blues, 14,       \"FamilyBlues\" )\n+  CFF_FIELD_DELTA_FIXED( 9,     family_other_blues, 10, \"FamilyOtherBlues\" )\n+  CFF_FIELD_FIXED_1000 ( 0x109, blue_scale,             \"BlueScale\" )\n+  CFF_FIELD_NUM        ( 0x10A, blue_shift,             \"BlueShift\" )\n+  CFF_FIELD_NUM        ( 0x10B, blue_fuzz,              \"BlueFuzz\" )\n+  CFF_FIELD_NUM        ( 10,    standard_width,         \"StdHW\" )\n+  CFF_FIELD_NUM        ( 11,    standard_height,        \"StdVW\" )\n+  CFF_FIELD_DELTA      ( 0x10C, snap_widths, 13,        \"StemSnapH\" )\n+  CFF_FIELD_DELTA      ( 0x10D, snap_heights, 13,       \"StemSnapV\" )\n+  CFF_FIELD_BOOL       ( 0x10E, force_bold,             \"ForceBold\" )\n+  CFF_FIELD_FIXED      ( 0x10F, force_bold_threshold,   \"ForceBoldThreshold\" )\n+  CFF_FIELD_NUM        ( 0x110, lenIV,                  \"lenIV\" )\n+  CFF_FIELD_NUM        ( 0x111, language_group,         \"LanguageGroup\" )\n+  CFF_FIELD_FIXED      ( 0x112, expansion_factor,       \"ExpansionFactor\" )\n+  CFF_FIELD_NUM        ( 0x113, initial_random_seed,    \"initialRandomSeed\" )\n+  CFF_FIELD_NUM        ( 19,    local_subrs_offset,     \"Subrs\" )\n+  CFF_FIELD_NUM        ( 20,    default_width,          \"defaultWidthX\" )\n+  CFF_FIELD_NUM        ( 21,    nominal_width,          \"nominalWidthX\" )\n@@ -132,16 +132,16 @@\n-  CFF_FIELD_DELTA     ( 6,     blue_values, 14,        \"BlueValues\" )\n-  CFF_FIELD_DELTA     ( 7,     other_blues, 10,        \"OtherBlues\" )\n-  CFF_FIELD_DELTA     ( 8,     family_blues, 14,       \"FamilyBlues\" )\n-  CFF_FIELD_DELTA     ( 9,     family_other_blues, 10, \"FamilyOtherBlues\" )\n-  CFF_FIELD_FIXED_1000( 0x109, blue_scale,             \"BlueScale\" )\n-  CFF_FIELD_NUM       ( 0x10A, blue_shift,             \"BlueShift\" )\n-  CFF_FIELD_NUM       ( 0x10B, blue_fuzz,              \"BlueFuzz\" )\n-  CFF_FIELD_NUM       ( 10,    standard_width,         \"StdHW\" )\n-  CFF_FIELD_NUM       ( 11,    standard_height,        \"StdVW\" )\n-  CFF_FIELD_DELTA     ( 0x10C, snap_widths, 13,        \"StemSnapH\" )\n-  CFF_FIELD_DELTA     ( 0x10D, snap_heights, 13,       \"StemSnapV\" )\n-  CFF_FIELD_NUM       ( 0x111, language_group,         \"LanguageGroup\" )\n-  CFF_FIELD_FIXED     ( 0x112, expansion_factor,       \"ExpansionFactor\" )\n-  CFF_FIELD_CALLBACK  ( 22,    vsindex,                \"vsindex\" )\n-  CFF_FIELD_BLEND     ( 23,                            \"blend\" )\n-  CFF_FIELD_NUM       ( 19,    local_subrs_offset,     \"Subrs\" )\n+  CFF_FIELD_DELTA_FIXED( 6,     blue_values, 14,        \"BlueValues\" )\n+  CFF_FIELD_DELTA_FIXED( 7,     other_blues, 10,        \"OtherBlues\" )\n+  CFF_FIELD_DELTA_FIXED( 8,     family_blues, 14,       \"FamilyBlues\" )\n+  CFF_FIELD_DELTA_FIXED( 9,     family_other_blues, 10, \"FamilyOtherBlues\" )\n+  CFF_FIELD_FIXED_1000 ( 0x109, blue_scale,             \"BlueScale\" )\n+  CFF_FIELD_NUM        ( 0x10A, blue_shift,             \"BlueShift\" )\n+  CFF_FIELD_NUM        ( 0x10B, blue_fuzz,              \"BlueFuzz\" )\n+  CFF_FIELD_NUM        ( 10,    standard_width,         \"StdHW\" )\n+  CFF_FIELD_NUM        ( 11,    standard_height,        \"StdVW\" )\n+  CFF_FIELD_DELTA      ( 0x10C, snap_widths, 13,        \"StemSnapH\" )\n+  CFF_FIELD_DELTA      ( 0x10D, snap_heights, 13,       \"StemSnapV\" )\n+  CFF_FIELD_NUM        ( 0x111, language_group,         \"LanguageGroup\" )\n+  CFF_FIELD_FIXED      ( 0x112, expansion_factor,       \"ExpansionFactor\" )\n+  CFF_FIELD_CALLBACK   ( 22,    vsindex,                \"vsindex\" )\n+  CFF_FIELD_BLEND      ( 23,                            \"blend\" )\n+  CFF_FIELD_NUM        ( 19,    local_subrs_offset,     \"Subrs\" )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cfftoken.h","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/ciderrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidgload.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -391,1 +391,1 @@\n-    { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }\n+    T1_FIELD_ZERO\n@@ -472,1 +472,1 @@\n-            for (;;)\n+            while ( keyword->len )\n@@ -474,1 +474,1 @@\n-              FT_Byte*  name;\n+              FT_Byte*  name = (FT_Byte*)keyword->ident;\n@@ -477,6 +477,2 @@\n-              name = (FT_Byte*)keyword->ident;\n-              if ( !name )\n-                break;\n-\n-              if ( cur[0] == name[0]                     &&\n-                   len == ft_strlen( (const char*)name ) )\n+              if ( keyword->len == len              &&\n+                   ft_memcmp( cur, name, len ) == 0 )\n@@ -484,17 +480,7 @@\n-                FT_UInt  n;\n-\n-\n-                for ( n = 1; n < len; n++ )\n-                  if ( cur[n] != name[n] )\n-                    break;\n-\n-                if ( n >= len )\n-                {\n-                  \/* we found it - run the parsing callback *\/\n-                  parser->root.error = cid_load_keyword( face,\n-                                                         loader,\n-                                                         keyword );\n-                  if ( parser->root.error )\n-                    return parser->root.error;\n-                  break;\n-                }\n+                \/* we found it - run the parsing callback *\/\n+                parser->root.error = cid_load_keyword( face,\n+                                                       loader,\n+                                                       keyword );\n+                if ( parser->root.error )\n+                  return parser->root.error;\n+                break;\n@@ -502,0 +488,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidload.c","additions":14,"deletions":27,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidobjs.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -93,3 +93,5 @@\n-  Again:\n-    \/* now, read the rest of the file until we find *\/\n-    \/* `StartData' or `\/sfnts'                      *\/\n+    if ( !stream->read ) {\n+      \/* just parse memory-based streams *\/\n+      offset = stream->size;\n+    }\n+    else\n@@ -97,0 +99,3 @@\n+      \/* Find the last `StartData` or `\/sfnts`.  The parser requires *\/\n+      \/* contiguous memory; attempt to pin as little as necessary.   *\/\n+\n@@ -122,1 +127,2 @@\n-      for ( offset = FT_STREAM_POS(); ; offset += 256 )\n+      offset = 0;\n+      while ( 1 )\n@@ -130,1 +136,1 @@\n-        if ( FT_STREAM_READ( p, read_len ) )\n+        if ( read_len && FT_STREAM_READ( p, read_len ) )\n@@ -144,2 +150,2 @@\n-            offset += (FT_ULong)( p - buffer ) + STARTDATA_LEN + 1;\n-            goto Found;\n+            offset = FT_STREAM_POS() - read_len - read_offset\n+                     + (FT_ULong)( p - buffer ) + STARTDATA_LEN + 1;\n@@ -150,2 +156,2 @@\n-            offset += (FT_ULong)( p - buffer ) + SFNTS_LEN + 1;\n-            goto Found;\n+            offset = FT_STREAM_POS() - read_len - read_offset\n+                     + (FT_ULong)( p - buffer ) + SFNTS_LEN + 1;\n@@ -155,1 +161,1 @@\n-        if ( read_offset + read_len < STARTDATA_LEN )\n+        if ( read_offset + read_len <= STARTDATA_LEN )\n@@ -157,1 +163,4 @@\n-          FT_TRACE2(( \"cid_parser_new: no `StartData' keyword found\\n\" ));\n+          if ( offset )\n+            goto Found;\n+\n+          FT_TRACE2(( \"cid_parser_new: no `StartData` keyword found\\n\" ));\n@@ -174,3 +183,3 @@\n-    \/* We have found the start of the binary data or the `\/sfnts' token. *\/\n-    \/* Now rewind and extract the frame corresponding to this PostScript *\/\n-    \/* section.                                                          *\/\n+    \/* We have found an efficient range to look for the binary data or    *\/\n+    \/* `\/sfnts' token.  Now rewind and extract the frame corresponding to *\/\n+    \/* this PostScript section.                                           *\/\n@@ -190,2 +199,2 @@\n-    \/* Finally, we check whether `StartData' or `\/sfnts' was real --  *\/\n-    \/* it could be in a comment or string.  We also get the arguments *\/\n+    \/* Find the first real `StartData' or `\/sfnts' -- the last one    *\/\n+    \/* could be in a comment or string.  We also get the arguments    *\/\n@@ -219,0 +228,1 @@\n+        FT_ULong     found_offset;\n@@ -237,0 +247,18 @@\n+        \/* set the real values for the parser, if different *\/\n+        found_offset = (FT_ULong)( cur - parser->postscript )\n+                       + STARTDATA_LEN + 1;\n+        if ( found_offset != offset )\n+        {\n+          FT_FRAME_RELEASE( parser->postscript );\n+\n+          ps_len = found_offset - base_offset;\n+          if ( FT_STREAM_SEEK( base_offset )                  ||\n+               FT_FRAME_EXTRACT( ps_len, parser->postscript ) )\n+            goto Exit;\n+\n+          parser->data_offset    = found_offset;\n+          parser->postscript_len = ps_len;\n+          parser->root.base      = parser->postscript;\n+          parser->root.cursor    = parser->postscript;\n+          parser->root.limit     = parser->root.cursor + ps_len;\n+        }\n@@ -254,5 +282,2 @@\n-    \/* we haven't found the correct `StartData'; go back and continue *\/\n-    \/* searching                                                      *\/\n-    FT_FRAME_RELEASE( parser->postscript );\n-    if ( !FT_STREAM_SEEK( offset ) )\n-      goto Again;\n+    FT_TRACE2(( \"cid_parser_new: no `StartData` token found\\n\" ));\n+    error = FT_THROW( Invalid_File_Format );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidparse.c","additions":47,"deletions":22,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidparse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidriver.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidtoken.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/afmparse.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/afmparse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2024 by\n@@ -20,0 +20,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -1755,1 +1756,1 @@\n-            args[0] = 46341;\n+            args[0] = 0xB504F4L;    \/* sqrt( 32768.0044 ) *\/\n@@ -1757,14 +1758,1 @@\n-          {\n-            FT_Fixed  root = args[0];\n-            FT_Fixed  new_root;\n-\n-\n-            for (;;)\n-            {\n-              new_root = ( root + FT_DivFix( args[0], root ) + 1 ) >> 1;\n-              if ( new_root == root )\n-                break;\n-              root = new_root;\n-            }\n-            args[0] = new_root;\n-          }\n+            args[0] = (FT_Fixed)FT_SqrtFixed( args[0] );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/cffdecode.c","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/cffdecode.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psauxerr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psauxmod.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psauxmod.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,8 +57,0 @@\n-  \/*\n-   * For blue values, the FreeType parser produces an array of integers,\n-   * while the Adobe CFF engine produces an array of fixed.\n-   * Define a macro to convert FreeType to fixed.\n-   *\/\n-#define cf2_blueToFixed( x )  cf2_intToFixed( x )\n-\n-\n@@ -81,4 +73,4 @@\n-    FT_Pos*  blueValues;\n-    FT_Pos*  otherBlues;\n-    FT_Pos*  familyBlues;\n-    FT_Pos*  familyOtherBlues;\n+    FT_Fixed*  blueValues;\n+    FT_Fixed*  otherBlues;\n+    FT_Fixed*  familyBlues;\n+    FT_Fixed*  familyOtherBlues;\n@@ -141,7 +133,7 @@\n-    if ( cf2_getLanguageGroup( decoder ) == 1                   &&\n-         ( numBlueValues == 0                                 ||\n-           ( numBlueValues == 4                             &&\n-             cf2_blueToFixed( blueValues[0] ) < emBoxBottom &&\n-             cf2_blueToFixed( blueValues[1] ) < emBoxBottom &&\n-             cf2_blueToFixed( blueValues[2] ) > emBoxTop    &&\n-             cf2_blueToFixed( blueValues[3] ) > emBoxTop    ) ) )\n+    if ( cf2_getLanguageGroup( decoder ) == 1     &&\n+         ( numBlueValues == 0                   ||\n+           ( numBlueValues == 4               &&\n+             blueValues[0] < emBoxBottom      &&\n+             blueValues[1] < emBoxBottom      &&\n+             blueValues[2] > emBoxTop         &&\n+             blueValues[3] > emBoxTop         ) ) )\n@@ -192,4 +184,2 @@\n-      blues->zone[blues->count].csBottomEdge =\n-        cf2_blueToFixed( blueValues[i] );\n-      blues->zone[blues->count].csTopEdge =\n-        cf2_blueToFixed( blueValues[i + 1] );\n+      blues->zone[blues->count].csBottomEdge = blueValues[i];\n+      blues->zone[blues->count].csTopEdge    = blueValues[i + 1];\n@@ -241,4 +231,2 @@\n-      blues->zone[blues->count].csBottomEdge =\n-        cf2_blueToFixed( otherBlues[i] );\n-      blues->zone[blues->count].csTopEdge =\n-        cf2_blueToFixed( otherBlues[i + 1] );\n+      blues->zone[blues->count].csBottomEdge = otherBlues[i];\n+      blues->zone[blues->count].csTopEdge    = otherBlues[i + 1];\n@@ -302,1 +290,1 @@\n-          flatFamilyEdge = cf2_blueToFixed( familyOtherBlues[j + 1] );\n+          flatFamilyEdge = familyOtherBlues[j + 1];\n@@ -320,1 +308,1 @@\n-          flatFamilyEdge = cf2_blueToFixed( familyBlues[1] );\n+          flatFamilyEdge = familyBlues[1];\n@@ -340,1 +328,1 @@\n-          flatFamilyEdge = cf2_blueToFixed( familyBlues[j] );\n+          flatFamilyEdge = familyBlues[j];\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psblues.c","additions":18,"deletions":30,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psconv.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psconv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-                     FT_Pos*     *data )\n+                     FT_Fixed*   *data )\n@@ -574,1 +574,1 @@\n-    *data  = (FT_Pos*)\n+    *data  = (FT_Fixed*)\n@@ -582,1 +582,1 @@\n-                     FT_Pos*     *data )\n+                     FT_Fixed*   *data )\n@@ -587,1 +587,1 @@\n-    *data  = (FT_Pos*)\n+    *data  = (FT_Fixed*)\n@@ -595,1 +595,1 @@\n-                      FT_Pos*     *data )\n+                      FT_Fixed*   *data )\n@@ -600,1 +600,1 @@\n-    *data  = (FT_Pos*)\n+    *data  = (FT_Fixed*)\n@@ -608,1 +608,1 @@\n-                           FT_Pos*     *data )\n+                           FT_Fixed*   *data )\n@@ -613,1 +613,1 @@\n-    *data  = (FT_Pos*)\n+    *data  = (FT_Fixed*)\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psft.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-                     FT_Pos*     *data );\n+                     FT_Fixed*   *data );\n@@ -99,1 +99,1 @@\n-                     FT_Pos*     *data );\n+                     FT_Fixed*   *data );\n@@ -103,1 +103,1 @@\n-                      FT_Pos*     *data );\n+                      FT_Fixed*   *data );\n@@ -107,1 +107,1 @@\n-                           FT_Pos*     *data );\n+                           FT_Fixed*   *data );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psft.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -431,0 +432,2 @@\n+    FT_TRACE6(( \" (\" ));\n+\n@@ -445,0 +448,2 @@\n+      FT_TRACE6(( \"%f \", (double)sum \/ 65536 ));\n+\n@@ -449,0 +454,2 @@\n+    FT_TRACE6(( \"blended)\\n\" ));\n+\n@@ -737,1 +744,1 @@\n-          FT_TRACE4(( \" blend\\n\" ));\n+          FT_TRACE4(( \" blend\" ));\n@@ -2278,17 +2285,1 @@\n-                    {\n-                      \/* use a start value that doesn't make *\/\n-                      \/* the algorithm's addition overflow   *\/\n-                      FT_Fixed  root = arg < 10 ? arg : arg >> 1;\n-                      FT_Fixed  new_root;\n-\n-\n-                      \/* Babylonian method *\/\n-                      for (;;)\n-                      {\n-                        new_root = ( root + FT_DivFix( arg, root ) + 1 ) >> 1;\n-                        if ( new_root == root )\n-                          break;\n-                        root = new_root;\n-                      }\n-                      arg = new_root;\n-                    }\n+                      arg = (CF2_F16Dot16)FT_SqrtFixed( (FT_UInt32)arg );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psintrp.c","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -26,0 +26,1 @@\n+#include \"psft.h\"\n@@ -203,1 +204,3 @@\n-    FT_MEM_COPY( table->block + table->cursor, object, length );\n+    \/* length == 0 also implies a NULL destination, so skip the copy call *\/\n+    if ( length > 0 )\n+      FT_MEM_COPY( table->block + table->cursor, object, length );\n@@ -1627,1 +1630,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;\n+      FT_Byte*    control = outline->tags   + outline->n_points;\n@@ -1680,2 +1683,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -1743,1 +1745,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points - 1;\n+      FT_Byte*    control = outline->tags   + outline->n_points - 1;\n@@ -1763,2 +1765,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -1902,1 +1903,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;\n+      FT_Byte*    control = outline->tags   + outline->n_points;\n@@ -1962,2 +1963,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -2022,1 +2022,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points - 1;\n+      FT_Byte*    control = outline->tags   + outline->n_points - 1;\n@@ -2042,2 +2042,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -2191,1 +2190,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;\n+      FT_Byte*    control = outline->tags   + outline->n_points;\n@@ -2270,2 +2269,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -2330,1 +2328,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points - 1;\n+      FT_Byte*    control = outline->tags   + outline->n_points - 1;\n@@ -2350,2 +2348,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -2466,1 +2463,1 @@\n-      cpriv->blue_values[n] = (FT_Pos)priv->blue_values[n];\n+      cpriv->blue_values[n] = cf2_intToFixed( priv->blue_values[n] );\n@@ -2470,1 +2467,1 @@\n-      cpriv->other_blues[n] = (FT_Pos)priv->other_blues[n];\n+      cpriv->other_blues[n] = cf2_intToFixed( priv->other_blues[n] );\n@@ -2474,1 +2471,1 @@\n-      cpriv->family_blues[n] = (FT_Pos)priv->family_blues[n];\n+      cpriv->family_blues[n] = cf2_intToFixed( priv->family_blues[n] );\n@@ -2478,1 +2475,2 @@\n-      cpriv->family_other_blues[n] = (FT_Pos)priv->family_other_blues[n];\n+      cpriv->family_other_blues[n] =\n+        cf2_intToFixed( priv->family_other_blues[n] );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psobjs.c","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1cmap.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1cmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1decode.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1decode.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n@@ -1121,1 +1121,1 @@\n-    char*       tags  = glyph->outline->tags;\n+    FT_Byte*    tags  = glyph->outline->tags;\n@@ -1174,2 +1174,2 @@\n-    glyph->num_points   = (FT_UInt)outline->n_points;\n-    glyph->num_contours = (FT_UInt)outline->n_contours;\n+    glyph->num_points   = outline->n_points;\n+    glyph->num_contours = outline->n_contours;\n@@ -1189,1 +1189,1 @@\n-        next  = (FT_UInt)outline->contours[n] + 1;\n+        next  = outline->contours[n] + 1;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshalgo.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshalgo.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshglob.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshglob.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshmod.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshmod.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshnterr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n@@ -809,1 +809,1 @@\n-                 FT_Long*  stems )\n+                 FT_Pos*   stems )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshrec.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshrec.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/psmodule.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/psmodule.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/psnamerr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2023 by\n+ * Copyright (C) 2005-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/pstables.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2005-2023 by\n+ * Copyright (C) 2005-2024 by\n@@ -95,21 +95,0 @@\n-  static FT_Long\n-  FT_MulDiv( FT_Long  a,\n-             FT_Long  b,\n-             FT_Long  c )\n-  {\n-    FT_Int   s;\n-    FT_Long  d;\n-\n-\n-    s = 1;\n-    if ( a < 0 ) { a = -a; s = -1; }\n-    if ( b < 0 ) { b = -b; s = -s; }\n-    if ( c < 0 ) { c = -c; s = -s; }\n-\n-    d = (FT_Long)( c > 0 ? ( (FT_Int64)a * b + ( c >> 1 ) ) \/ c\n-                         : 0x7FFFFFFFL );\n-\n-    return ( s > 0 ) ? d : -d;\n-  }\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftmisc.h","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -66,2 +66,1 @@\n-#include <freetype\/internal\/ftcalc.h> \/* for FT_MulDiv and FT_MulDiv_No_Round *\/\n-#include <freetype\/ftoutln.h>         \/* for FT_Outline_Get_CBox              *\/\n+#include <freetype\/internal\/ftcalc.h> \/* for FT_MulDiv_No_Round *\/\n@@ -118,6 +117,6 @@\n-   *   Note that when all profiles have been generated, the function\n-   *   Finalize_Profile_Table() is used to record, for each profile, its\n-   *   bottom-most scanline as well as the scanline above its upmost\n-   *   boundary.  These positions are called `y-turns' because they (sort\n-   *   of) correspond to local extrema.  They are stored in a sorted list\n-   *   built from the top of the render pool as a downwards stack:\n+   *   Note that, for all generated profiles, the function End_Profile()\n+   *   is used to record all their bottom-most scanlines as well as the\n+   *   scanline above their upmost boundary.  These positions are called\n+   *   `y-turns' because they (sort of) correspond to local extrema.\n+   *   They are stored in a sorted list built from the top of the render\n+   *   pool as a downwards stack:\n@@ -139,1 +138,1 @@\n-   *   handles the situation properly.\n+   *   handles the situation by bisecting the job and restarting.\n@@ -255,1 +254,0 @@\n-#define SMulDiv           FT_MulDiv\n@@ -308,10 +306,0 @@\n-\n-  typedef union  Alignment_\n-  {\n-    Long    l;\n-    void*   p;\n-    void  (*f)(void);\n-\n-  } Alignment, *PAlignment;\n-\n-\n@@ -330,0 +318,1 @@\n+#define Dropout           0x40U\n@@ -348,1 +337,0 @@\n-    FT_F26Dot6  X;           \/* current coordinate during sweep          *\/\n@@ -350,1 +338,6 @@\n-    PLong       offset;      \/* start of profile's data in render pool   *\/\n+    PProfile    next;        \/* next profile in same contour, used       *\/\n+                             \/* during drop-out control                  *\/\n+    Int         offset;      \/* bottom or currently scanned array index  *\/\n+    Int         height;      \/* profile's height in scanlines            *\/\n+    Int         start;       \/* profile's starting scanline, also use    *\/\n+                             \/* as activation counter                    *\/\n@@ -355,2 +348,1 @@\n-    Long        height;      \/* profile's height in scanlines            *\/\n-    Long        start;       \/* profile's starting scanline              *\/\n+                             \/* Bit 6: dropout detected                  *\/\n@@ -358,5 +350,3 @@\n-    Int         countL;      \/* number of lines to step before this      *\/\n-                             \/* profile becomes drawable                 *\/\n-\n-    PProfile    next;        \/* next profile in same contour, used       *\/\n-                             \/* during drop-out control                  *\/\n+    FT_F26Dot6  X;           \/* current coordinate during sweep          *\/\n+    Long        x[1];        \/* actually variable array of scanline      *\/\n+                             \/* intersections with `height` elements     *\/\n@@ -369,4 +359,0 @@\n-#define AlignProfileSize \\\n-  ( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) \/ sizeof ( Long ) )\n-\n-\n@@ -410,2 +396,2 @@\n-  Function_Sweep_Init( RAS_ARGS Short  min,\n-                                Short  max );\n+  Function_Sweep_Init( RAS_ARGS Int  min,\n+                                Int  max );\n@@ -414,1 +400,1 @@\n-  Function_Sweep_Span( RAS_ARGS Short       y,\n+  Function_Sweep_Span( RAS_ARGS Int         y,\n@@ -416,3 +402,1 @@\n-                                FT_F26Dot6  x2,\n-                                PProfile    left,\n-                                PProfile    right );\n+                                FT_F26Dot6  x2 );\n@@ -444,2 +428,1 @@\n-  \/* To mimick Windows, symmetric cases break down indepenently of the  *\/\n-  \/* precision.                                                         *\/\n+  \/* To mimic Windows, symmetric cases do not depend on the precision.  *\/\n@@ -465,1 +448,0 @@\n-    Int         precision_jitter;\n@@ -474,2 +456,0 @@\n-    Int         numTurns;           \/* number of Y-turns in outline        *\/\n-\n@@ -478,4 +458,0 @@\n-    UShort      bWidth;             \/* target bitmap width                 *\/\n-    PByte       bOrigin;            \/* target bitmap bottom-left origin    *\/\n-    PByte       bLine;              \/* target bitmap current line          *\/\n-\n@@ -486,0 +462,1 @@\n+    Int         numTurns;           \/* number of Y-turns in outline        *\/\n@@ -487,5 +464,0 @@\n-    Bool        fresh;              \/* signals a fresh new profile which   *\/\n-                                    \/* `start' field must be completed     *\/\n-    Bool        joint;              \/* signals that the last arc ended     *\/\n-                                    \/* exactly on a scanline.  Allows      *\/\n-                                    \/* removal of doublets                 *\/\n@@ -499,1 +471,0 @@\n-    FT_Bitmap   target;             \/* description of target bit\/pixmap    *\/\n@@ -502,0 +473,6 @@\n+    Int         bTop;               \/* target bitmap max line  index       *\/\n+    Int         bRight;             \/* target bitmap rightmost index       *\/\n+    Int         bPitch;             \/* target bitmap pitch                 *\/\n+    PByte       bOrigin;            \/* target bitmap bottom-left origin    *\/\n+    PByte       bLine;              \/* target bitmap current line          *\/\n+\n@@ -566,8 +543,0 @@\n-     * `precision_jitter' is an epsilon threshold used in\n-     * `Vertical_Sweep_Span' to deal with small imperfections in the Bezier\n-     * decomposition (after all, we are working with approximations only);\n-     * it avoids switching on additional pixels which would cause artifacts\n-     * otherwise.\n-     *\n-     * The value of `precision_jitter' has been determined heuristically.\n-     *\n@@ -580,1 +549,0 @@\n-      ras.precision_jitter = 30;\n@@ -586,1 +554,0 @@\n-      ras.precision_jitter = 2;\n@@ -589,2 +556,0 @@\n-    FT_TRACE6(( \"Set_High_Precision(%s)\\n\", High ? \"true\" : \"false\" ));\n-\n@@ -597,0 +562,57 @@\n+  \/**************************************************************************\n+   *\n+   * @Function:\n+   *   Insert_Y_Turn\n+   *\n+   * @Description:\n+   *   Insert a salient into the sorted list placed on top of the render\n+   *   pool.\n+   *\n+   * @Input:\n+   *   New y scanline position.\n+   *\n+   * @Return:\n+   *   SUCCESS on success.  FAILURE in case of overflow.\n+   *\/\n+  static Bool\n+  Insert_Y_Turns( RAS_ARGS Int  y,\n+                           Int  top )\n+  {\n+    Int    n       = ras.numTurns;\n+    PLong  y_turns = ras.maxBuff;\n+\n+\n+    \/* update top value *\/\n+    if ( n == 0 || top > y_turns[n] )\n+      y_turns[n] = top;\n+\n+    \/* look for first y value that is <= *\/\n+    while ( n-- && y < y_turns[n] )\n+      ;\n+\n+    \/* if it is <, simply insert it, ignore if == *\/\n+    if ( n < 0 || y > y_turns[n] )\n+    {\n+      ras.maxBuff--;\n+      if ( ras.maxBuff <= ras.top )\n+      {\n+        ras.error = FT_THROW( Raster_Overflow );\n+        return FAILURE;\n+      }\n+\n+      do\n+      {\n+        Int  y2 = (Int)y_turns[n];\n+\n+\n+        y_turns[n] = y;\n+        y = y2;\n+      } while ( n-- >= 0 );\n+\n+      ras.numTurns++;\n+    }\n+\n+    return SUCCESS;\n+  }\n+\n+\n@@ -609,4 +631,0 @@\n-   *   overshoot ::\n-   *     Whether the profile's unrounded start position\n-   *     differs by at least a half pixel.\n-   *\n@@ -618,2 +636,1 @@\n-  New_Profile( RAS_ARGS TStates  aState,\n-                        Bool     overshoot )\n+  New_Profile( RAS_ARGS TStates  aState )\n@@ -621,1 +638,4 @@\n-    if ( !ras.fProfile )\n+    Long  e;\n+\n+\n+    if ( !ras.cProfile || ras.cProfile->height )\n@@ -624,3 +644,1 @@\n-      ras.fProfile  = ras.cProfile;\n-      ras.top      += AlignProfileSize;\n-    }\n+      ras.top       = ras.cProfile->x;\n@@ -628,4 +646,8 @@\n-    if ( ras.top >= ras.maxBuff )\n-    {\n-      ras.error = FT_THROW( Raster_Overflow );\n-      return FAILURE;\n+      if ( ras.top >= ras.maxBuff )\n+      {\n+        FT_TRACE1(( \"overflow in New_Profile\\n\" ));\n+        ras.error = FT_THROW( Raster_Overflow );\n+        return FAILURE;\n+      }\n+\n+      ras.cProfile->height = 0;\n@@ -634,5 +656,0 @@\n-    ras.cProfile->start  = 0;\n-    ras.cProfile->height = 0;\n-    ras.cProfile->offset = ras.top;\n-    ras.cProfile->link   = (PProfile)0;\n-    ras.cProfile->next   = (PProfile)0;\n@@ -645,1 +662,1 @@\n-      if ( overshoot )\n+      if ( IS_BOTTOM_OVERSHOOT( ras.lastY ) )\n@@ -648,1 +665,1 @@\n-      FT_TRACE6(( \"  new ascending profile = %p\\n\", (void *)ras.cProfile ));\n+      e = CEILING( ras.lastY );\n@@ -652,1 +669,1 @@\n-      if ( overshoot )\n+      if ( IS_TOP_OVERSHOOT( ras.lastY ) )\n@@ -654,1 +671,2 @@\n-      FT_TRACE6(( \"  new descending profile = %p\\n\", (void *)ras.cProfile ));\n+\n+      e = FLOOR( ras.lastY );\n@@ -663,2 +681,12 @@\n-    if ( !ras.gProfile )\n-      ras.gProfile = ras.cProfile;\n+    if ( e > ras.maxY )\n+      e = ras.maxY;\n+    if ( e < ras.minY )\n+      e = ras.minY;\n+    ras.cProfile->start = (Int)TRUNC( e );\n+\n+    FT_TRACE7(( \"  new %s profile = %p, start = %d\\n\",\n+                aState == Ascending_State ? \"ascending\" : \"descending\",\n+                (void *)ras.cProfile, ras.cProfile->start ));\n+\n+    if ( ras.lastY == e )\n+      *ras.top++ = ras.lastX;\n@@ -667,2 +695,0 @@\n-    ras.fresh = TRUE;\n-    ras.joint = FALSE;\n@@ -680,6 +706,1 @@\n-   *   Finalize the current profile.\n-   *\n-   * @Input:\n-   *   overshoot ::\n-   *     Whether the profile's unrounded end position differs\n-   *     by at least a half pixel.\n+   *   Finalize the current profile and record y-turns.\n@@ -691,1 +712,1 @@\n-  End_Profile( RAS_ARGS Bool  overshoot )\n+  End_Profile( RAS_ARG )\n@@ -693,1 +714,3 @@\n-    Long  h;\n+    PProfile  p = ras.cProfile;\n+    Int       h = (Int)( ras.top - p->x );\n+    Int       bottom, top;\n@@ -696,2 +719,0 @@\n-    h = (Long)( ras.top - ras.cProfile->offset );\n-\n@@ -707,1 +728,2 @@\n-      PProfile  oldProfile;\n+      FT_TRACE7(( \"  ending profile %p, start = %2d, height = %+3d\\n\",\n+                  (void *)p, p->start, p->flags & Flow_Up ? h : -h ));\n@@ -709,0 +731,1 @@\n+      p->height = h;\n@@ -710,2 +733,4 @@\n-      FT_TRACE6(( \"  ending profile %p, start = %ld, height = %ld\\n\",\n-                  (void *)ras.cProfile, ras.cProfile->start, h ));\n+      if ( p->flags & Flow_Up )\n+      {\n+        if ( IS_TOP_OVERSHOOT( ras.lastY ) )\n+          p->flags |= Overshoot_Top;\n@@ -713,2 +738,6 @@\n-      ras.cProfile->height = h;\n-      if ( overshoot )\n+        bottom    = p->start;\n+        top       = bottom + h;\n+        p->offset = 0;\n+        p->X      = p->x[0];\n+      }\n+      else\n@@ -716,4 +745,8 @@\n-        if ( ras.cProfile->flags & Flow_Up )\n-          ras.cProfile->flags |= Overshoot_Top;\n-        else\n-          ras.cProfile->flags |= Overshoot_Bottom;\n+        if ( IS_BOTTOM_OVERSHOOT( ras.lastY ) )\n+          p->flags |= Overshoot_Bottom;\n+\n+        top       = p->start + 1;\n+        bottom    = top - h;\n+        p->start  = bottom;\n+        p->offset = h - 1;\n+        p->X      = p->x[h - 1];\n@@ -722,2 +755,2 @@\n-      oldProfile   = ras.cProfile;\n-      ras.cProfile = (PProfile)ras.top;\n+      if ( Insert_Y_Turns( RAS_VARS bottom, top ) )\n+        return FAILURE;\n@@ -725,1 +758,2 @@\n-      ras.top += AlignProfileSize;\n+      if ( !ras.gProfile )\n+        ras.gProfile = p;\n@@ -727,2 +761,3 @@\n-      ras.cProfile->height = 0;\n-      ras.cProfile->offset = ras.top;\n+      \/* preliminary values to be finalized *\/\n+      p->next = ras.gProfile;\n+      p->link = (PProfile)ras.top;\n@@ -730,1 +765,0 @@\n-      oldProfile->next = ras.cProfile;\n@@ -734,65 +768,0 @@\n-    if ( ras.top >= ras.maxBuff )\n-    {\n-      FT_TRACE1(( \"overflow in End_Profile\\n\" ));\n-      ras.error = FT_THROW( Raster_Overflow );\n-      return FAILURE;\n-    }\n-\n-    ras.joint = FALSE;\n-\n-    return SUCCESS;\n-  }\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @Function:\n-   *   Insert_Y_Turn\n-   *\n-   * @Description:\n-   *   Insert a salient into the sorted list placed on top of the render\n-   *   pool.\n-   *\n-   * @Input:\n-   *   New y scanline position.\n-   *\n-   * @Return:\n-   *   SUCCESS on success.  FAILURE in case of overflow.\n-   *\/\n-  static Bool\n-  Insert_Y_Turn( RAS_ARGS Int  y )\n-  {\n-    PLong  y_turns;\n-    Int    n;\n-\n-\n-    n       = ras.numTurns - 1;\n-    y_turns = ras.sizeBuff - ras.numTurns;\n-\n-    \/* look for first y value that is <= *\/\n-    while ( n >= 0 && y < y_turns[n] )\n-      n--;\n-\n-    \/* if it is <, simply insert it, ignore if == *\/\n-    if ( n >= 0 && y > y_turns[n] )\n-      do\n-      {\n-        Int  y2 = (Int)y_turns[n];\n-\n-\n-        y_turns[n] = y;\n-        y = y2;\n-      } while ( --n >= 0 );\n-\n-    if ( n < 0 )\n-    {\n-      ras.maxBuff--;\n-      if ( ras.maxBuff <= ras.top )\n-      {\n-        ras.error = FT_THROW( Raster_Overflow );\n-        return FAILURE;\n-      }\n-      ras.numTurns++;\n-      ras.sizeBuff[-ras.numTurns] = y;\n-    }\n-\n@@ -810,3 +779,0 @@\n-   *\n-   * @Return:\n-   *   SUCCESS on success.  FAILURE in case of overflow.\n@@ -814,1 +780,1 @@\n-  static Bool\n+  static void\n@@ -817,3 +783,3 @@\n-    UShort    n;\n-    PProfile  p;\n-\n+    UShort    n = ras.num_Profs;\n+    PProfile  p = ras.fProfile;\n+    PProfile  q;\n@@ -821,2 +787,0 @@\n-    n = ras.num_Profs;\n-    p = ras.fProfile;\n@@ -824,1 +788,2 @@\n-    if ( n > 1 && p )\n+    \/* there should be at least two profiles, up and down *\/\n+    while ( --n )\n@@ -826,3 +791,1 @@\n-      do\n-      {\n-        Int  bottom, top;\n+      q = p->link;\n@@ -830,0 +793,3 @@\n+      \/* fix the contour loop *\/\n+      if ( q->next == p->next )\n+        p->next = q;\n@@ -831,24 +797,1 @@\n-        if ( n > 1 )\n-          p->link = (PProfile)( p->offset + p->height );\n-        else\n-          p->link = NULL;\n-\n-        if ( p->flags & Flow_Up )\n-        {\n-          bottom = (Int)p->start;\n-          top    = (Int)( p->start + p->height - 1 );\n-        }\n-        else\n-        {\n-          bottom     = (Int)( p->start - p->height + 1 );\n-          top        = (Int)p->start;\n-          p->start   = bottom;\n-          p->offset += p->height - 1;\n-        }\n-\n-        if ( Insert_Y_Turn( RAS_VARS bottom )  ||\n-             Insert_Y_Turn( RAS_VARS top + 1 ) )\n-          return FAILURE;\n-\n-        p = p->link;\n-      } while ( --n );\n+      p = q;\n@@ -856,2 +799,0 @@\n-    else\n-      ras.fProfile = NULL;\n@@ -859,1 +800,2 @@\n-    return SUCCESS;\n+    \/* null-terminate *\/\n+    p->link = NULL;\n@@ -989,3 +931,3 @@\n-    Long   Dx, Dy;\n-    Int    e1, e2, f1, f2, size;     \/* XXX: is `Short' sufficient? *\/\n-    Long   Ix, Rx, Ax;\n+    Long  e, e2, Dx, Dy;\n+    Long  Ix, Rx, Ax;\n+    Int   size;\n@@ -996,4 +938,1 @@\n-    Dx = x2 - x1;\n-    Dy = y2 - y1;\n-\n-    if ( Dy <= 0 || y2 < miny || y1 > maxy )\n+    if ( y2 < miny || y1 > maxy )\n@@ -1002,13 +941,2 @@\n-    if ( y1 < miny )\n-    {\n-      \/* Take care: miny-y1 can be a very large value; we use     *\/\n-      \/*            a slow MulDiv function to avoid clipping bugs *\/\n-      x1 += SMulDiv( Dx, miny - y1, Dy );\n-      e1  = (Int)TRUNC( miny );\n-      f1  = 0;\n-    }\n-    else\n-    {\n-      e1 = (Int)TRUNC( y1 );\n-      f1 = (Int)FRAC( y1 );\n-    }\n+    e2 = y2 > maxy ? maxy : FLOOR( y2 );\n+    e  = y1 < miny ? miny : CEILING( y1 );\n@@ -1016,11 +944,2 @@\n-    if ( y2 > maxy )\n-    {\n-      \/* x2 += FMulDiv( Dx, maxy - y2, Dy );  UNNECESSARY *\/\n-      e2  = (Int)TRUNC( maxy );\n-      f2  = 0;\n-    }\n-    else\n-    {\n-      e2 = (Int)TRUNC( y2 );\n-      f2 = (Int)FRAC( y2 );\n-    }\n+    if ( y1 == e )\n+      e += ras.precision;\n@@ -1028,18 +947,2 @@\n-    if ( f1 > 0 )\n-    {\n-      if ( e1 == e2 )\n-        return SUCCESS;\n-      else\n-      {\n-        x1 += SMulDiv( Dx, ras.precision - f1, Dy );\n-        e1 += 1;\n-      }\n-    }\n-    else\n-      if ( ras.joint )\n-      {\n-        ras.top--;\n-        ras.joint = FALSE;\n-      }\n-\n-    ras.joint = (char)( f2 == 0 );\n+    if ( e2 < e )  \/* nothing to do *\/\n+      return SUCCESS;\n@@ -1047,5 +950,2 @@\n-    if ( ras.fresh )\n-    {\n-      ras.cProfile->start = e1;\n-      ras.fresh           = FALSE;\n-    }\n+    size = (Int)TRUNC( e2 - e ) + 1;\n+    top  = ras.top;\n@@ -1053,2 +953,1 @@\n-    size = e2 - e1 + 1;\n-    if ( ras.top + size >= ras.maxBuff )\n+    if ( top + size >= ras.maxBuff )\n@@ -1060,7 +959,4 @@\n-    if ( Dx > 0 )\n-    {\n-      Ix = SMulDiv_No_Round( ras.precision, Dx, Dy );\n-      Rx = ( ras.precision * Dx ) % Dy;\n-      Dx = 1;\n-    }\n-    else\n+    Dx = x2 - x1;\n+    Dy = y2 - y1;\n+\n+    if ( Dx == 0 )  \/* very easy *\/\n@@ -1068,3 +964,4 @@\n-      Ix = -SMulDiv_No_Round( ras.precision, -Dx, Dy );\n-      Rx = ( ras.precision * -Dx ) % Dy;\n-      Dx = -1;\n+      do\n+        *top++ = x1;\n+      while ( --size );\n+      goto Fin;\n@@ -1073,2 +970,3 @@\n-    Ax  = -Dy;\n-    top = ras.top;\n+    Ix     = SMulDiv_No_Round( e - y1, Dx, Dy );\n+    x1    += Ix;\n+    *top++ = x1;\n@@ -1076,1 +974,1 @@\n-    while ( size > 0 )\n+    if ( --size )\n@@ -1078,1 +976,4 @@\n-      *top++ = x1;\n+      Ax = Dx * ( e - y1 )    - Dy * Ix;  \/* remainder *\/\n+      Ix = FMulDiv( ras.precision, Dx, Dy );\n+      Rx = Dx * ras.precision - Dy * Ix;  \/* remainder *\/\n+      Dx = 1;\n@@ -1080,3 +981,8 @@\n-      x1 += Ix;\n-      Ax += Rx;\n-      if ( Ax >= 0 )\n+      if ( x2 < x1 )\n+      {\n+        Ax = -Ax;\n+        Rx = -Rx;\n+        Dx = -Dx;\n+      }\n+\n+      do\n@@ -1084,2 +990,8 @@\n-        Ax -= Dy;\n-        x1 += Dx;\n+        x1 += Ix;\n+        Ax += Rx;\n+        if ( Ax >= Dy )\n+        {\n+          Ax -= Dy;\n+          x1 += Dx;\n+        }\n+        *top++ = x1;\n@@ -1087,1 +999,1 @@\n-      size--;\n+      while ( --size );\n@@ -1090,0 +1002,1 @@\n+  Fin:\n@@ -1134,11 +1047,1 @@\n-    Bool  result, fresh;\n-\n-\n-    fresh  = ras.fresh;\n-\n-    result = Line_Up( RAS_VARS x1, -y1, x2, -y2, -maxy, -miny );\n-\n-    if ( fresh && !ras.fresh )\n-      ras.cProfile->start = -ras.cProfile->start;\n-\n-    return result;\n+    return Line_Up( RAS_VARS x1, -y1, x2, -y2, -maxy, -miny );\n@@ -1184,2 +1087,2 @@\n-    Long   y1, y2, e, e2, e0;\n-    Short  f1;\n+    Long  y1, y2, e, e2, dy;\n+    Long  dx, x2;\n@@ -1187,3 +1090,1 @@\n-    TPoint*  start_arc;\n-\n-    PLong top;\n+    PLong  top;\n@@ -1194,1 +1095,0 @@\n-    top = ras.top;\n@@ -1197,24 +1097,1 @@\n-      goto Fin;\n-\n-    e2 = FLOOR( y2 );\n-\n-    if ( e2 > maxy )\n-      e2 = maxy;\n-\n-    e0 = miny;\n-\n-    if ( y1 < miny )\n-      e = miny;\n-    else\n-    {\n-      e  = CEILING( y1 );\n-      f1 = (Short)( FRAC( y1 ) );\n-      e0 = e;\n-\n-      if ( f1 == 0 )\n-      {\n-        if ( ras.joint )\n-        {\n-          top--;\n-          ras.joint = FALSE;\n-        }\n+      return SUCCESS;\n@@ -1222,1 +1099,2 @@\n-        *top++ = arc[degree].x;\n+    e2 = y2 > maxy ? maxy : FLOOR( y2 );\n+    e  = y1 < miny ? miny : CEILING( y1 );\n@@ -1224,3 +1102,2 @@\n-        e += ras.precision;\n-      }\n-    }\n+    if ( y1 == e )\n+      e += ras.precision;\n@@ -1228,5 +1105,2 @@\n-    if ( ras.fresh )\n-    {\n-      ras.cProfile->start = TRUNC( e0 );\n-      ras.fresh = FALSE;\n-    }\n+    if ( e2 < e )  \/* nothing to do *\/\n+      return SUCCESS;\n@@ -1234,2 +1108,1 @@\n-    if ( e2 < e )\n-      goto Fin;\n+    top = ras.top;\n@@ -1239,1 +1112,0 @@\n-      ras.top   = top;\n@@ -1244,2 +1116,0 @@\n-    start_arc = arc;\n-\n@@ -1248,2 +1118,0 @@\n-      ras.joint = FALSE;\n-\n@@ -1251,0 +1119,1 @@\n+      x2 = arc[0].x;\n@@ -1254,2 +1123,7 @@\n-        y1 = arc[degree].y;\n-        if ( y2 - y1 >= ras.precision_step )\n+        dy = y2 - arc[degree].y;\n+        dx = x2 - arc[degree].x;\n+\n+        \/* split condition should be invariant of direction *\/\n+        if (  dy > ras.precision_step ||\n+              dx > ras.precision_step ||\n+             -dx > ras.precision_step )\n@@ -1262,2 +1136,2 @@\n-          *top++ = arc[degree].x + FMulDiv( arc[0].x - arc[degree].x,\n-                                            e - y1, y2 - y1 );\n+          *top++ = x2 - FMulDiv( y2 - e, dx, dy );\n+          e     += ras.precision;\n@@ -1265,1 +1139,0 @@\n-          e   += ras.precision;\n@@ -1272,4 +1145,2 @@\n-          ras.joint  = TRUE;\n-          *top++     = arc[0].x;\n-\n-          e += ras.precision;\n+          *top++ = x2;\n+          e     += ras.precision;\n@@ -1277,1 +1148,1 @@\n-        arc -= degree;\n+        arc   -= degree;\n@@ -1279,1 +1150,2 @@\n-    } while ( arc >= start_arc && e <= e2 );\n+    }\n+    while ( e <= e2 );\n@@ -1281,2 +1153,1 @@\n-  Fin:\n-    ras.top  = top;\n+    ras.top = top;\n@@ -1319,1 +1190,1 @@\n-    Bool     result, fresh;\n+    Bool  result;\n@@ -1328,2 +1199,0 @@\n-    fresh = ras.fresh;\n-\n@@ -1332,3 +1201,0 @@\n-    if ( fresh && !ras.fresh )\n-      ras.cProfile->start = -ras.cProfile->start;\n-\n@@ -1365,1 +1231,1 @@\n-    \/* First, detect a change of direction *\/\n+    TStates  state;\n@@ -1367,17 +1233,0 @@\n-    switch ( ras.state )\n-    {\n-    case Unknown_State:\n-      if ( y > ras.lastY )\n-      {\n-        if ( New_Profile( RAS_VARS Ascending_State,\n-                                   IS_BOTTOM_OVERSHOOT( ras.lastY ) ) )\n-          return FAILURE;\n-      }\n-      else\n-      {\n-        if ( y < ras.lastY )\n-          if ( New_Profile( RAS_VARS Descending_State,\n-                                     IS_TOP_OVERSHOOT( ras.lastY ) ) )\n-            return FAILURE;\n-      }\n-      break;\n@@ -1385,9 +1234,2 @@\n-    case Ascending_State:\n-      if ( y < ras.lastY )\n-      {\n-        if ( End_Profile( RAS_VARS IS_TOP_OVERSHOOT( ras.lastY ) ) ||\n-             New_Profile( RAS_VARS Descending_State,\n-                                   IS_TOP_OVERSHOOT( ras.lastY ) ) )\n-          return FAILURE;\n-      }\n-      break;\n+    if ( y == ras.lastY )\n+      goto Fin;\n@@ -1395,9 +1237,1 @@\n-    case Descending_State:\n-      if ( y > ras.lastY )\n-      {\n-        if ( End_Profile( RAS_VARS IS_BOTTOM_OVERSHOOT( ras.lastY ) ) ||\n-             New_Profile( RAS_VARS Ascending_State,\n-                                   IS_BOTTOM_OVERSHOOT( ras.lastY ) ) )\n-          return FAILURE;\n-      }\n-      break;\n+    \/* First, detect a change of direction *\/\n@@ -1405,2 +1239,12 @@\n-    default:\n-      ;\n+    state = ras.lastY < y ? Ascending_State : Descending_State;\n+\n+    if ( ras.state != state )\n+    {\n+      \/* finalize current profile if any *\/\n+      if ( ras.state != Unknown_State &&\n+           End_Profile( RAS_VAR )     )\n+        goto Fail;\n+\n+      \/* create a new profile *\/\n+      if ( New_Profile( RAS_VARS state ) )\n+        goto Fail;\n@@ -1411,1 +1255,1 @@\n-    switch ( ras.state )\n+    if ( state == Ascending_State )\n@@ -1413,1 +1257,0 @@\n-    case Ascending_State:\n@@ -1416,4 +1259,4 @@\n-        return FAILURE;\n-      break;\n-\n-    case Descending_State:\n+        goto Fail;\n+    }\n+    else\n+    {\n@@ -1422,5 +1265,1 @@\n-        return FAILURE;\n-      break;\n-\n-    default:\n-      ;\n+        goto Fail;\n@@ -1429,0 +1268,1 @@\n+  Fin:\n@@ -1431,1 +1271,0 @@\n-\n@@ -1433,0 +1272,3 @@\n+\n+  Fail:\n+    return FAILURE;\n@@ -1503,1 +1345,1 @@\n-      if ( y2 < ymin || y2 > ymax )\n+      if ( y2 < FLOOR( ymin ) || y2 > CEILING( ymax ) )\n@@ -1511,1 +1353,2 @@\n-        \/* this arc is flat, ignore it and pop it from the Bezier stack *\/\n+        \/* this arc is flat, advance position *\/\n+        \/* and pop it from the Bezier stack   *\/\n@@ -1513,0 +1356,3 @@\n+\n+        ras.lastX = x3;\n+        ras.lastY = y3;\n@@ -1521,5 +1367,0 @@\n-          Bool  o = ( state_bez == Ascending_State )\n-                      ? IS_BOTTOM_OVERSHOOT( y1 )\n-                      : IS_TOP_OVERSHOOT( y1 );\n-\n-\n@@ -1528,1 +1369,1 @@\n-               End_Profile( RAS_VARS o )  )\n+               End_Profile( RAS_VAR )     )\n@@ -1532,1 +1373,1 @@\n-          if ( New_Profile( RAS_VARS state_bez, o ) )\n+          if ( New_Profile( RAS_VARS state_bez ) )\n@@ -1548,0 +1389,3 @@\n+\n+        ras.lastX = x3;\n+        ras.lastY = y3;\n@@ -1552,3 +1396,0 @@\n-    ras.lastX = x3;\n-    ras.lastY = y3;\n-\n@@ -1651,1 +1492,1 @@\n-      if ( ymin2 < ymin1 || ymax2 > ymax1 )\n+      if ( ymin2 < FLOOR( ymin1 ) || ymax2 > CEILING( ymax1 ) )\n@@ -1659,1 +1500,2 @@\n-        \/* this arc is flat, ignore it and pop it from the Bezier stack *\/\n+        \/* this arc is flat, advance position *\/\n+        \/* and pop it from the Bezier stack   *\/\n@@ -1661,0 +1503,3 @@\n+\n+        ras.lastX = x4;\n+        ras.lastY = y4;\n@@ -1664,1 +1509,1 @@\n-        state_bez = ( y1 <= y4 ) ? Ascending_State : Descending_State;\n+        state_bez = y1 < y4 ? Ascending_State : Descending_State;\n@@ -1669,5 +1514,0 @@\n-          Bool  o = ( state_bez == Ascending_State )\n-                      ? IS_BOTTOM_OVERSHOOT( y1 )\n-                      : IS_TOP_OVERSHOOT( y1 );\n-\n-\n@@ -1676,1 +1516,1 @@\n-               End_Profile( RAS_VARS o )  )\n+               End_Profile( RAS_VAR )     )\n@@ -1679,1 +1519,1 @@\n-          if ( New_Profile( RAS_VARS state_bez, o ) )\n+          if ( New_Profile( RAS_VARS state_bez ) )\n@@ -1695,0 +1535,3 @@\n+\n+        ras.lastX = x4;\n+        ras.lastY = y4;\n@@ -1699,3 +1542,0 @@\n-    ras.lastX = x4;\n-    ras.lastY = y4;\n-\n@@ -1743,0 +1583,5 @@\n+   *\n+   * @Note:\n+   *   Unlike FT_Outline_Decompose(), this function handles the scanmode\n+   *   dropout tags in the individual contours.  Therefore, it cannot be\n+   *   replaced.\n@@ -1756,1 +1601,1 @@\n-    char*       tags;\n+    FT_Byte*    tags;\n@@ -1977,4 +1822,1 @@\n-    ras.joint    = FALSE;\n-    ras.fresh    = FALSE;\n-\n-    ras.maxBuff  = ras.sizeBuff - AlignProfileSize;\n+    ras.cProfile = NULL;\n@@ -1982,1 +1824,2 @@\n-    ras.numTurns = 0;\n+    ras.top      = ras.buff;\n+    ras.maxBuff  = ras.sizeBuff - 1;  \/* top reserve *\/\n@@ -1984,3 +1827,2 @@\n-    ras.cProfile         = (PProfile)ras.top;\n-    ras.cProfile->offset = ras.top;\n-    ras.num_Profs        = 0;\n+    ras.numTurns  = 0;\n+    ras.num_Profs = 0;\n@@ -1991,4 +1833,0 @@\n-      PProfile  lastProfile;\n-      Bool      o;\n-\n-\n@@ -2004,0 +1842,5 @@\n+      \/* Note that ras.gProfile can stay nil if the contour was *\/\n+      \/* too small to be drawn or degenerate.                   *\/\n+      if ( !ras.gProfile )\n+        continue;\n+\n@@ -2008,2 +1851,1 @@\n-        if ( ras.gProfile                        &&\n-             ( ras.gProfile->flags & Flow_Up ) ==\n+        if ( ( ras.gProfile->flags & Flow_Up ) ==\n@@ -2012,2 +1854,0 @@\n-        \/* Note that ras.gProfile can be nil if the contour was too small *\/\n-        \/* to be drawn.                                                   *\/\n@@ -2015,7 +1855,1 @@\n-      lastProfile = ras.cProfile;\n-      if ( ras.top != ras.cProfile->offset &&\n-           ( ras.cProfile->flags & Flow_Up ) )\n-        o = IS_TOP_OVERSHOOT( ras.lastY );\n-      else\n-        o = IS_BOTTOM_OVERSHOOT( ras.lastY );\n-      if ( End_Profile( RAS_VARS o ) )\n+      if ( End_Profile( RAS_VAR ) )\n@@ -2024,3 +1858,2 @@\n-      \/* close the `next profile in contour' linked list *\/\n-      if ( ras.gProfile )\n-        lastProfile->next = ras.gProfile;\n+      if ( !ras.fProfile )\n+        ras.fProfile = ras.gProfile;\n@@ -2029,2 +1862,2 @@\n-    if ( Finalize_Profile_Table( RAS_VAR ) )\n-      return FAILURE;\n+    if ( ras.fProfile )\n+      Finalize_Profile_Table( RAS_VAR );\n@@ -2032,1 +1865,1 @@\n-    return (Bool)( ras.top < ras.maxBuff ? SUCCESS : FAILURE );\n+    return SUCCESS;\n@@ -2045,13 +1878,0 @@\n-  \/**************************************************************************\n-   *\n-   * Init_Linked\n-   *\n-   *   Initializes an empty linked list.\n-   *\/\n-  static void\n-  Init_Linked( TProfileList*  l )\n-  {\n-    *l = NULL;\n-  }\n-\n-\n@@ -2062,1 +1882,1 @@\n-   *   Inserts a new profile in a linked list.\n+   *   Inserts a new profile in a linked list, sorted by coordinate.\n@@ -2076,1 +1896,1 @@\n-    while ( current )\n+    while ( current && current->X < x )\n@@ -2078,2 +1898,0 @@\n-      if ( x < current->X )\n-        break;\n@@ -2091,1 +1909,1 @@\n-   * DelOld\n+   * Increment\n@@ -2093,1 +1911,5 @@\n-   *   Removes an old profile from a linked list.\n+   *   Advances all profile in the list to the next scanline.  It also\n+   *   sorts the trace list in the unlikely case of profile crossing.\n+   *   The profiles are inserted in sorted order.  We might need a single\n+   *   swap to fix it when profiles (contours) cross.\n+   *   Bubble sort with immediate restart is good enough and simple.\n@@ -2096,2 +1918,2 @@\n-  DelOld( PProfileList    list,\n-          const PProfile  profile )\n+  Increment( PProfileList  list,\n+             Int           flow )\n@@ -2099,2 +1921,1 @@\n-    PProfile  *old, current;\n-\n+    PProfile  *old, current, next;\n@@ -2102,2 +1923,0 @@\n-    old     = list;\n-    current = *old;\n@@ -2105,1 +1924,3 @@\n-    while ( current )\n+    \/* First, set the new X coordinates and remove exhausted profiles *\/\n+    old = list;\n+    while ( *old )\n@@ -2107,1 +1928,2 @@\n-      if ( current == profile )\n+      current = *old;\n+      if ( --current->height )\n@@ -2109,2 +1931,3 @@\n-        *old = current->link;\n-        return;\n+        current->offset += flow;\n+        current->X       = current->x[current->offset];\n+        old = &current->link;\n@@ -2112,32 +1935,2 @@\n-\n-      old     = &current->link;\n-      current = *old;\n-    }\n-\n-    \/* we should never get there, unless the profile was not part of *\/\n-    \/* the list.                                                     *\/\n-  }\n-\n-\n-  \/**************************************************************************\n-   *\n-   * Sort\n-   *\n-   *   Sorts a trace list.  In 95%, the list is already sorted.  We need\n-   *   an algorithm which is fast in this case.  Bubble sort is enough\n-   *   and simple.\n-   *\/\n-  static void\n-  Sort( PProfileList  list )\n-  {\n-    PProfile  *old, current, next;\n-\n-\n-    \/* First, set the new X coordinate of each profile *\/\n-    current = *list;\n-    while ( current )\n-    {\n-      current->X       = *current->offset;\n-      current->offset += ( current->flags & Flow_Up ) ? 1 : -1;\n-      current->height--;\n-      current = current->link;\n+      else\n+        *old = current->link;  \/* remove *\/\n@@ -2146,1 +1939,1 @@\n-    \/* Then sort them *\/\n+    \/* Then make sure the list remains sorted *\/\n@@ -2153,3 +1946,1 @@\n-    next = current->link;\n-\n-    while ( next )\n+    while ( current->link )\n@@ -2157,0 +1948,2 @@\n+      next = current->link;\n+\n@@ -2160,4 +1953,1 @@\n-        current = *old;\n-\n-        if ( !current )\n-          return;\n+        current = next;\n@@ -2171,0 +1961,1 @@\n+        \/* this is likely the only necessary swap -- restart *\/\n@@ -2174,2 +1965,0 @@\n-\n-      next = current->link;\n@@ -2190,2 +1979,2 @@\n-  Vertical_Sweep_Init( RAS_ARGS Short  min,\n-                                Short  max )\n+  Vertical_Sweep_Init( RAS_ARGS Int  min,\n+                                Int  max )\n@@ -2196,1 +1985,1 @@\n-    ras.bLine = ras.bOrigin - min * ras.target.pitch;\n+    ras.bLine = ras.bOrigin - min * ras.bPitch;\n@@ -2201,1 +1990,1 @@\n-  Vertical_Sweep_Span( RAS_ARGS Short       y,\n+  Vertical_Sweep_Span( RAS_ARGS Int         y,\n@@ -2203,3 +1992,1 @@\n-                                FT_F26Dot6  x2,\n-                                PProfile    left,\n-                                PProfile    right )\n+                                FT_F26Dot6  x2 )\n@@ -2207,3 +1994,2 @@\n-    Long  e1, e2;\n-\n-    Int  dropOutControl = left->flags & 7;\n+    Int  e1 = (Int)TRUNC( CEILING( x1 ) );\n+    Int  e2 = (Int)TRUNC(   FLOOR( x2 ) );\n@@ -2212,2 +1998,0 @@\n-    FT_UNUSED( left );\n-    FT_UNUSED( right );\n@@ -2216,3 +2000,1 @@\n-    \/* in high-precision mode, we need 12 digits after the comma to *\/\n-    \/* represent multiples of 1\/(1<<12) = 1\/4096                    *\/\n-    FT_TRACE7(( \"  y=%d x=[% .12f;% .12f]\",\n+    FT_TRACE7(( \"  y=%d x=[% .*f;% .*f]\",\n@@ -2220,14 +2002,2 @@\n-                (double)x1 \/ (double)ras.precision,\n-                (double)x2 \/ (double)ras.precision ));\n-\n-    \/* Drop-out control *\/\n-\n-    e1 = CEILING( x1 );\n-    e2 = FLOOR( x2 );\n-\n-    \/* take care of the special case where both the left *\/\n-    \/* and right contour lie exactly on pixel centers    *\/\n-    if ( dropOutControl != 2                             &&\n-         x2 - x1 - ras.precision <= ras.precision_jitter &&\n-         e1 != x1 && e2 != x2                            )\n-      e2 = e1;\n+                ras.precision_bits, (double)x1 \/ (double)ras.precision,\n+                ras.precision_bits, (double)x2 \/ (double)ras.precision ));\n@@ -2235,4 +2005,1 @@\n-    e1 = TRUNC( e1 );\n-    e2 = TRUNC( e2 );\n-\n-    if ( e2 >= 0 && e1 < ras.bWidth )\n+    if ( e2 >= 0 && e1 <= ras.bRight )\n@@ -2240,1 +2007,1 @@\n-      Byte*  target;\n+      PByte  target;\n@@ -2242,2 +2009,1 @@\n-      Int   c1, c2;\n-      Byte  f1, f2;\n+      Int   c1, f1, c2, f2;\n@@ -2248,2 +2014,2 @@\n-      if ( e2 >= ras.bWidth )\n-        e2 = ras.bWidth - 1;\n+      if ( e2 > ras.bRight )\n+        e2 = ras.bRight;\n@@ -2251,1 +2017,1 @@\n-      FT_TRACE7(( \" -> x=[%ld;%ld]\", e1, e2 ));\n+      FT_TRACE7(( \" -> x=[%d;%d]\", e1, e2 ));\n@@ -2253,2 +2019,2 @@\n-      c1 = (Short)( e1 >> 3 );\n-      c2 = (Short)( e2 >> 3 );\n+      c1 = e1 >> 3;\n+      c2 = e2 >> 3;\n@@ -2256,2 +2022,2 @@\n-      f1 = (Byte)  ( 0xFF >> ( e1 & 7 ) );\n-      f2 = (Byte) ~( 0x7F >> ( e2 & 7 ) );\n+      f1 =  0xFF >> ( e1 & 7 );\n+      f2 = ~0x7F >> ( e2 & 7 );\n@@ -2283,1 +2049,1 @@\n-  Vertical_Sweep_Drop( RAS_ARGS Short       y,\n+  Vertical_Sweep_Drop( RAS_ARGS Int         y,\n@@ -2285,3 +2051,1 @@\n-                                FT_F26Dot6  x2,\n-                                PProfile    left,\n-                                PProfile    right )\n+                                FT_F26Dot6  x2 )\n@@ -2289,105 +2053,3 @@\n-    Long   e1, e2, pxl;\n-    Short  c1, f1;\n-\n-\n-    FT_TRACE7(( \"  y=%d x=[% .12f;% .12f]\",\n-                y,\n-                (double)x1 \/ (double)ras.precision,\n-                (double)x2 \/ (double)ras.precision ));\n-\n-    \/* Drop-out control *\/\n-\n-    \/*   e2            x2                    x1           e1   *\/\n-    \/*                                                         *\/\n-    \/*                 ^                     |                 *\/\n-    \/*                 |                     |                 *\/\n-    \/*   +-------------+---------------------+------------+    *\/\n-    \/*                 |                     |                 *\/\n-    \/*                 |                     v                 *\/\n-    \/*                                                         *\/\n-    \/* pixel         contour              contour       pixel  *\/\n-    \/* center                                           center *\/\n-\n-    \/* drop-out mode    scan conversion rules (as defined in OpenType) *\/\n-    \/* --------------------------------------------------------------- *\/\n-    \/*  0                1, 2, 3                                       *\/\n-    \/*  1                1, 2, 4                                       *\/\n-    \/*  2                1, 2                                          *\/\n-    \/*  3                same as mode 2                                *\/\n-    \/*  4                1, 2, 5                                       *\/\n-    \/*  5                1, 2, 6                                       *\/\n-    \/*  6, 7             same as mode 2                                *\/\n-\n-    e1  = CEILING( x1 );\n-    e2  = FLOOR  ( x2 );\n-    pxl = e1;\n-\n-    if ( e1 > e2 )\n-    {\n-      Int  dropOutControl = left->flags & 7;\n-\n-\n-      if ( e1 == e2 + ras.precision )\n-      {\n-        switch ( dropOutControl )\n-        {\n-        case 0: \/* simple drop-outs including stubs *\/\n-          pxl = e2;\n-          break;\n-\n-        case 4: \/* smart drop-outs including stubs *\/\n-          pxl = SMART( x1, x2 );\n-          break;\n-\n-        case 1: \/* simple drop-outs excluding stubs *\/\n-        case 5: \/* smart drop-outs excluding stubs  *\/\n-\n-          \/* Drop-out Control Rules #4 and #6 *\/\n-\n-          \/* The specification neither provides an exact definition *\/\n-          \/* of a `stub' nor gives exact rules to exclude them.     *\/\n-          \/*                                                        *\/\n-          \/* Here the constraints we use to recognize a stub.       *\/\n-          \/*                                                        *\/\n-          \/*  upper stub:                                           *\/\n-          \/*                                                        *\/\n-          \/*   - P_Left and P_Right are in the same contour         *\/\n-          \/*   - P_Right is the successor of P_Left in that contour *\/\n-          \/*   - y is the top of P_Left and P_Right                 *\/\n-          \/*                                                        *\/\n-          \/*  lower stub:                                           *\/\n-          \/*                                                        *\/\n-          \/*   - P_Left and P_Right are in the same contour         *\/\n-          \/*   - P_Left is the successor of P_Right in that contour *\/\n-          \/*   - y is the bottom of P_Left                          *\/\n-          \/*                                                        *\/\n-          \/* We draw a stub if the following constraints are met.   *\/\n-          \/*                                                        *\/\n-          \/*   - for an upper or lower stub, there is top or bottom *\/\n-          \/*     overshoot, respectively                            *\/\n-          \/*   - the covered interval is greater or equal to a half *\/\n-          \/*     pixel                                              *\/\n-\n-          \/* upper stub test *\/\n-          if ( left->next == right                &&\n-               left->height <= 0                  &&\n-               !( left->flags & Overshoot_Top   &&\n-                  x2 - x1 >= ras.precision_half ) )\n-            goto Exit;\n-\n-          \/* lower stub test *\/\n-          if ( right->next == left                 &&\n-               left->start == y                    &&\n-               !( left->flags & Overshoot_Bottom &&\n-                  x2 - x1 >= ras.precision_half  ) )\n-            goto Exit;\n-\n-          if ( dropOutControl == 1 )\n-            pxl = e2;\n-          else\n-            pxl = SMART( x1, x2 );\n-          break;\n-\n-        default: \/* modes 2, 3, 6, 7 *\/\n-          goto Exit;  \/* no drop-out control *\/\n-        }\n+    Int  e1 = (Int)TRUNC( x1 );\n+    Int  e2 = (Int)TRUNC( x2 );\n+    Int  c1, f1;\n@@ -2395,7 +2057,1 @@\n-        \/* undocumented but confirmed: If the drop-out would result in a  *\/\n-        \/* pixel outside of the bounding box, use the pixel inside of the *\/\n-        \/* bounding box instead                                           *\/\n-        if ( pxl < 0 )\n-          pxl = e1;\n-        else if ( TRUNC( pxl ) >= ras.bWidth )\n-          pxl = e2;\n+    FT_UNUSED( y );\n@@ -2403,2 +2059,0 @@\n-        \/* check that the other pixel isn't set *\/\n-        e1 = ( pxl == e1 ) ? e2 : e1;\n@@ -2406,1 +2060,5 @@\n-        e1 = TRUNC( e1 );\n+    \/* undocumented but confirmed: If the drop-out would result in a  *\/\n+    \/* pixel outside of the bounding box, use the pixel inside of the *\/\n+    \/* bounding box instead                                           *\/\n+    if ( e1 < 0 || e1 > ras.bRight )\n+      e1 = e2;\n@@ -2408,2 +2066,5 @@\n-        c1 = (Short)( e1 >> 3 );\n-        f1 = (Short)( e1 &  7 );\n+    \/* otherwise check that the other pixel isn't set *\/\n+    else if ( e2 >=0 && e2 <= ras.bRight )\n+    {\n+      c1 = e2 >> 3;\n+      f1 = 0x80 >> ( e2 & 7 );\n@@ -2411,6 +2072,2 @@\n-        if ( e1 >= 0 && e1 < ras.bWidth     &&\n-             ras.bLine[c1] & ( 0x80 >> f1 ) )\n-          goto Exit;\n-      }\n-      else\n-        goto Exit;\n+      if ( ras.bLine[c1] & f1 )\n+        return;\n@@ -2419,3 +2076,1 @@\n-    e1 = TRUNC( pxl );\n-\n-    if ( e1 >= 0 && e1 < ras.bWidth )\n+    if ( e1 >= 0 && e1 <= ras.bRight )\n@@ -2423,1 +2078,2 @@\n-      FT_TRACE7(( \" -> x=%ld\", e1 ));\n+      c1 = e1 >> 3;\n+      f1 = 0x80 >> ( e1 & 7 );\n@@ -2425,2 +2081,2 @@\n-      c1 = (Short)( e1 >> 3 );\n-      f1 = (Short)( e1 & 7 );\n+      FT_TRACE7(( \"  y=%d x=%d%s\\n\", y, e1,\n+                  ras.bLine[c1] & f1 ? \" redundant\" : \"\" ));\n@@ -2428,1 +2084,1 @@\n-      ras.bLine[c1] |= (char)( 0x80 >> f1 );\n+      ras.bLine[c1] |= f1;\n@@ -2430,3 +2086,0 @@\n-\n-  Exit:\n-    FT_TRACE7(( \" dropout=%d\\n\", left->flags & 7 ));\n@@ -2439,1 +2092,1 @@\n-    ras.bLine -= ras.target.pitch;\n+    ras.bLine -= ras.bPitch;\n@@ -2453,2 +2106,2 @@\n-  Horizontal_Sweep_Init( RAS_ARGS Short  min,\n-                                  Short  max )\n+  Horizontal_Sweep_Init( RAS_ARGS Int  min,\n+                                  Int  max )\n@@ -2464,1 +2117,1 @@\n-  Horizontal_Sweep_Span( RAS_ARGS Short       y,\n+  Horizontal_Sweep_Span( RAS_ARGS Int         y,\n@@ -2466,3 +2119,1 @@\n-                                  FT_F26Dot6  x2,\n-                                  PProfile    left,\n-                                  PProfile    right )\n+                                  FT_F26Dot6  x2 )\n@@ -2470,1 +2121,2 @@\n-    Long  e1, e2;\n+    Long  e1 = CEILING( x1 );\n+    Long  e2 =   FLOOR( x2 );\n@@ -2472,2 +2124,0 @@\n-    FT_UNUSED( left );\n-    FT_UNUSED( right );\n@@ -2475,2 +2125,1 @@\n-\n-    FT_TRACE7(( \"  x=%d y=[% .12f;% .12f]\",\n+    FT_TRACE7(( \"  x=%d y=[% .*f;% .*f]\",\n@@ -2478,2 +2127,2 @@\n-                (double)x1 \/ (double)ras.precision,\n-                (double)x2 \/ (double)ras.precision ));\n+                ras.precision_bits, (double)x1 \/ (double)ras.precision,\n+                ras.precision_bits, (double)x2 \/ (double)ras.precision ));\n@@ -2487,2 +2136,0 @@\n-    e1 = CEILING( x1 );\n-\n@@ -2493,1 +2140,1 @@\n-      if ( e1 >= 0 && (ULong)e1 < ras.target.rows )\n+      if ( e1 >= 0 && e1 <= ras.bTop )\n@@ -2495,1 +2142,1 @@\n-        Byte   f1;\n+        Int    f1;\n@@ -2499,2 +2146,2 @@\n-        bits = ras.bOrigin + ( y >> 3 ) - e1 * ras.target.pitch;\n-        f1   = (Byte)( 0x80 >> ( y & 7 ) );\n+        bits = ras.bOrigin + ( y >> 3 ) - e1 * ras.bPitch;\n+        f1   = 0x80 >> ( y & 7 );\n@@ -2509,2 +2156,0 @@\n-    e2 = FLOOR  ( x2 );\n-\n@@ -2515,1 +2160,1 @@\n-      if ( e2 >= 0 && (ULong)e2 < ras.target.rows )\n+      if ( e2 >= 0 && e2 <= ras.bTop )\n@@ -2517,1 +2162,1 @@\n-        Byte   f1;\n+        Int    f1;\n@@ -2521,2 +2166,2 @@\n-        bits = ras.bOrigin + ( y >> 3 ) - e2 * ras.target.pitch;\n-        f1   = (Byte)( 0x80 >> ( y & 7 ) );\n+        bits = ras.bOrigin + ( y >> 3 ) - e2 * ras.bPitch;\n+        f1   = 0x80 >> ( y & 7 );\n@@ -2536,1 +2181,1 @@\n-  Horizontal_Sweep_Drop( RAS_ARGS Short       y,\n+  Horizontal_Sweep_Drop( RAS_ARGS Int         y,\n@@ -2538,3 +2183,1 @@\n-                                  FT_F26Dot6  x2,\n-                                  PProfile    left,\n-                                  PProfile    right )\n+                                  FT_F26Dot6  x2 )\n@@ -2542,1 +2185,2 @@\n-    Long   e1, e2, pxl;\n+    Int    e1 = (Int)TRUNC( x1 );\n+    Int    e2 = (Int)TRUNC( x2 );\n@@ -2544,28 +2188,1 @@\n-    Byte   f1;\n-\n-\n-    FT_TRACE7(( \"  x=%d y=[% .12f;% .12f]\",\n-                y,\n-                (double)x1 \/ (double)ras.precision,\n-                (double)x2 \/ (double)ras.precision ));\n-\n-    \/* During the horizontal sweep, we only take care of drop-outs *\/\n-\n-    \/* e1     +       <-- pixel center *\/\n-    \/*        |                        *\/\n-    \/* x1  ---+-->    <-- contour      *\/\n-    \/*        |                        *\/\n-    \/*        |                        *\/\n-    \/* x2  <--+---    <-- contour      *\/\n-    \/*        |                        *\/\n-    \/*        |                        *\/\n-    \/* e2     +       <-- pixel center *\/\n-\n-    e1  = CEILING( x1 );\n-    e2  = FLOOR  ( x2 );\n-    pxl = e1;\n-\n-    if ( e1 > e2 )\n-    {\n-      Int  dropOutControl = left->flags & 7;\n-\n+    Int    f1;\n@@ -2573,35 +2190,0 @@\n-      if ( e1 == e2 + ras.precision )\n-      {\n-        switch ( dropOutControl )\n-        {\n-        case 0: \/* simple drop-outs including stubs *\/\n-          pxl = e2;\n-          break;\n-\n-        case 4: \/* smart drop-outs including stubs *\/\n-          pxl = SMART( x1, x2 );\n-          break;\n-\n-        case 1: \/* simple drop-outs excluding stubs *\/\n-        case 5: \/* smart drop-outs excluding stubs  *\/\n-          \/* see Vertical_Sweep_Drop for details *\/\n-\n-          \/* rightmost stub test *\/\n-          if ( left->next == right                &&\n-               left->height <= 0                  &&\n-               !( left->flags & Overshoot_Top   &&\n-                  x2 - x1 >= ras.precision_half ) )\n-            goto Exit;\n-\n-          \/* leftmost stub test *\/\n-          if ( right->next == left                 &&\n-               left->start == y                    &&\n-               !( left->flags & Overshoot_Bottom &&\n-                  x2 - x1 >= ras.precision_half  ) )\n-            goto Exit;\n-\n-          if ( dropOutControl == 1 )\n-            pxl = e2;\n-          else\n-            pxl = SMART( x1, x2 );\n-          break;\n@@ -2609,16 +2191,5 @@\n-        default: \/* modes 2, 3, 6, 7 *\/\n-          goto Exit;  \/* no drop-out control *\/\n-        }\n-\n-        \/* undocumented but confirmed: If the drop-out would result in a  *\/\n-        \/* pixel outside of the bounding box, use the pixel inside of the *\/\n-        \/* bounding box instead                                           *\/\n-        if ( pxl < 0 )\n-          pxl = e1;\n-        else if ( (ULong)( TRUNC( pxl ) ) >= ras.target.rows )\n-          pxl = e2;\n-\n-        \/* check that the other pixel isn't set *\/\n-        e1 = ( pxl == e1 ) ? e2 : e1;\n-\n-        e1 = TRUNC( e1 );\n+    \/* undocumented but confirmed: If the drop-out would result in a  *\/\n+    \/* pixel outside of the bounding box, use the pixel inside of the *\/\n+    \/* bounding box instead                                           *\/\n+    if ( e1 < 0 || e1 > ras.bTop )\n+      e1 = e2;\n@@ -2626,2 +2197,5 @@\n-        bits = ras.bOrigin + ( y >> 3 ) - e1 * ras.target.pitch;\n-        f1   = (Byte)( 0x80 >> ( y & 7 ) );\n+    \/* otherwise check that the other pixel isn't set *\/\n+    else if ( e2 >=0 && e2 <= ras.bTop )\n+    {\n+      bits = ras.bOrigin + ( y >> 3 ) - e2 * ras.bPitch;\n+      f1   = 0x80 >> ( y & 7 );\n@@ -2629,7 +2203,2 @@\n-        if ( e1 >= 0                     &&\n-             (ULong)e1 < ras.target.rows &&\n-             *bits & f1                  )\n-          goto Exit;\n-      }\n-      else\n-        goto Exit;\n+      if ( *bits & f1 )\n+        return;\n@@ -2638,3 +2207,1 @@\n-    e1 = TRUNC( pxl );\n-\n-    if ( e1 >= 0 && (ULong)e1 < ras.target.rows )\n+    if ( e1 >= 0 && e1 <= ras.bTop )\n@@ -2642,1 +2209,2 @@\n-      FT_TRACE7(( \" -> y=%ld\", e1 ));\n+      bits  = ras.bOrigin + ( y >> 3 ) - e1 * ras.bPitch;\n+      f1    = 0x80 >> ( y & 7 );\n@@ -2644,2 +2212,2 @@\n-      bits  = ras.bOrigin + ( y >> 3 ) - e1 * ras.target.pitch;\n-      f1    = (Byte)( 0x80 >> ( y & 7 ) );\n+      FT_TRACE7(( \"  x=%d y=%d%s\\n\", y, e1,\n+                  *bits & f1 ? \" redundant\" : \"\" ));\n@@ -2647,1 +2215,1 @@\n-      bits[0] |= f1;\n+      *bits |= f1;\n@@ -2649,3 +2217,0 @@\n-\n-  Exit:\n-    FT_TRACE7(( \" dropout=%d\\n\", left->flags & 7 ));\n@@ -2667,0 +2232,3 @@\n+   * Note that this routine is executed with the pool containing at least\n+   * two valid profiles (up and down) and two y-turns (top and bottom).\n+   *\n@@ -2669,1 +2237,1 @@\n-  static Bool\n+  static void\n@@ -2672,28 +2240,2 @@\n-    Short         y, y_change, y_height;\n-\n-    PProfile      P, Q, P_Left, P_Right;\n-\n-    Short         min_Y, max_Y, top, bottom, dropouts;\n-\n-    Long          x1, x2, xs, e1, e2;\n-\n-    TProfileList  waiting;\n-    TProfileList  draw_left, draw_right;\n-\n-\n-    \/* initialize empty linked lists *\/\n-\n-    Init_Linked( &waiting );\n-\n-    Init_Linked( &draw_left  );\n-    Init_Linked( &draw_right );\n-\n-    \/* first, compute min and max Y *\/\n-\n-    P     = ras.fProfile;\n-    max_Y = (Short)TRUNC( ras.minY );\n-    min_Y = (Short)TRUNC( ras.maxY );\n-\n-    while ( P )\n-    {\n-      Q = P->link;\n+    Int           min_Y, max_Y, dropouts;\n+    Int           y, y_turn;\n@@ -2701,2 +2243,1 @@\n-      bottom = (Short)P->start;\n-      top    = (Short)( P->start + P->height - 1 );\n+    PProfile      *Q, P, P_Left, P_Right;\n@@ -2704,4 +2245,3 @@\n-      if ( min_Y > bottom )\n-        min_Y = bottom;\n-      if ( max_Y < top )\n-        max_Y = top;\n+    TProfileList  waiting    = ras.fProfile;\n+    TProfileList  draw_left  = NULL;\n+    TProfileList  draw_right = NULL;\n@@ -2709,2 +2249,0 @@\n-      P->X = 0;\n-      InsNew( &waiting, P );\n@@ -2712,2 +2250,1 @@\n-      P = Q;\n-    }\n+    \/* use y_turns to set the drawing range *\/\n@@ -2715,6 +2252,2 @@\n-    \/* check the Y-turns *\/\n-    if ( ras.numTurns == 0 )\n-    {\n-      ras.error = FT_THROW( Invalid_Outline );\n-      return FAILURE;\n-    }\n+    min_Y = (Int)ras.maxBuff[0];\n+    max_Y = (Int)ras.maxBuff[ras.numTurns] - 1;\n@@ -2726,10 +2259,0 @@\n-    \/* then compute the distance of each profile from min_Y *\/\n-\n-    P = waiting;\n-\n-    while ( P )\n-    {\n-      P->countL = P->start - min_Y;\n-      P = P->link;\n-    }\n-\n@@ -2738,8 +2261,1 @@\n-    y        = min_Y;\n-    y_height = 0;\n-\n-    if ( ras.numTurns > 0                     &&\n-         ras.sizeBuff[-ras.numTurns] == min_Y )\n-      ras.numTurns--;\n-\n-    while ( ras.numTurns > 0 )\n+    for ( y = min_Y; y <= max_Y; )\n@@ -2747,3 +2263,1 @@\n-      \/* check waiting list for new activations *\/\n-\n-      P = waiting;\n+      \/* check waiting list for new profile activations *\/\n@@ -2751,1 +2265,2 @@\n-      while ( P )\n+      Q = &waiting;\n+      while ( *Q )\n@@ -2753,3 +2268,2 @@\n-        Q = P->link;\n-        P->countL -= y_height;\n-        if ( P->countL == 0 )\n+        P = *Q;\n+        if ( P->start == y )\n@@ -2757,1 +2271,1 @@\n-          DelOld( &waiting, P );\n+          *Q = P->link;  \/* remove *\/\n@@ -2759,0 +2273,2 @@\n+          \/* each active list contains profiles with the same flow *\/\n+          \/* left and right are arbitrary, correspond to TrueType  *\/\n@@ -2764,2 +2280,2 @@\n-\n-        P = Q;\n+        else\n+          Q = &P->link;\n@@ -2768,1 +2284,1 @@\n-      \/* sort the drawing lists *\/\n+      y_turn = (Int)*++ras.maxBuff;\n@@ -2770,7 +2286,1 @@\n-      Sort( &draw_left );\n-      Sort( &draw_right );\n-\n-      y_change = (Short)ras.sizeBuff[-ras.numTurns--];\n-      y_height = (Short)( y_change - y );\n-\n-      while ( y < y_change )\n+      do\n@@ -2787,2 +2297,4 @@\n-          x1 = P_Left ->X;\n-          x2 = P_Right->X;\n+          Long  x1 = P_Left ->X;\n+          Long  x2 = P_Right->X;\n+          Long  xs;\n+\n@@ -2790,0 +2302,2 @@\n+          \/* TrueType should have x2 > x1, but can be opposite *\/\n+          \/* by mistake or in CFF\/Type1, fix it then           *\/\n@@ -2797,2 +2311,2 @@\n-          e1 = FLOOR( x1 );\n-          e2 = CEILING( x2 );\n+          if ( CEILING( x1 ) <= FLOOR( x2 ) )\n+            ras.Proc_Sweep_Span( RAS_VARS y, x1, x2 );\n@@ -2800,2 +2314,2 @@\n-          if ( x2 - x1 <= ras.precision &&\n-               e1 != x1 && e2 != x2     )\n+          \/* otherwise, bottom ceiling > top floor, it is a drop-out *\/\n+          else\n@@ -2803,1 +2317,50 @@\n-            if ( e1 > e2 || e2 == e1 + ras.precision )\n+            Int  dropOutControl = P_Left->flags & 7;\n+\n+\n+            \/* Drop-out control *\/\n+\n+            \/*   e2            x2                    x1           e1   *\/\n+            \/*                                                         *\/\n+            \/*                 ^                     |                 *\/\n+            \/*                 |                     |                 *\/\n+            \/*   +-------------+---------------------+------------+    *\/\n+            \/*                 |                     |                 *\/\n+            \/*                 |                     v                 *\/\n+            \/*                                                         *\/\n+            \/* pixel         contour              contour       pixel  *\/\n+            \/* center                                           center *\/\n+\n+            \/* drop-out mode   scan conversion rules (OpenType specs)  *\/\n+            \/* ------------------------------------------------------- *\/\n+            \/*  bit 0          exclude stubs if set                    *\/\n+            \/*  bit 1          ignore drop-outs if set                 *\/\n+            \/*  bit 2          smart rounding if set                   *\/\n+\n+            if ( dropOutControl & 2 )\n+              goto Next_Pair;\n+\n+            \/* The specification neither provides an exact definition *\/\n+            \/* of a `stub' nor gives exact rules to exclude them.     *\/\n+            \/*                                                        *\/\n+            \/* Here the constraints we use to recognize a stub.       *\/\n+            \/*                                                        *\/\n+            \/*  upper stub:                                           *\/\n+            \/*                                                        *\/\n+            \/*   - P_Left and P_Right are in the same contour         *\/\n+            \/*   - P_Right is the successor of P_Left in that contour *\/\n+            \/*   - y is the top of P_Left and P_Right                 *\/\n+            \/*                                                        *\/\n+            \/*  lower stub:                                           *\/\n+            \/*                                                        *\/\n+            \/*   - P_Left and P_Right are in the same contour         *\/\n+            \/*   - P_Left is the successor of P_Right in that contour *\/\n+            \/*   - y is the bottom of P_Left                          *\/\n+            \/*                                                        *\/\n+            \/* We draw a stub if the following constraints are met.   *\/\n+            \/*                                                        *\/\n+            \/*   - for an upper or lower stub, there is top or bottom *\/\n+            \/*     overshoot, respectively                            *\/\n+            \/*   - the covered interval is greater or equal to a half *\/\n+            \/*     pixel                                              *\/\n+\n+            if ( dropOutControl & 1 )\n@@ -2805,14 +2368,14 @@\n-              Int  dropOutControl = P_Left->flags & 7;\n-\n-\n-              if ( dropOutControl != 2 )\n-              {\n-                \/* a drop-out was detected *\/\n-\n-                P_Left ->X = x1;\n-                P_Right->X = x2;\n-\n-                \/* mark profile for drop-out processing *\/\n-                P_Left->countL = 1;\n-                dropouts++;\n-              }\n+              \/* upper stub test *\/\n+              if ( P_Left->height == 1                &&\n+                   P_Left->next == P_Right            &&\n+                   !( P_Left->flags & Overshoot_Top   &&\n+                      x2 - x1 >= ras.precision_half   ) )\n+                goto Next_Pair;\n+\n+              \/* lower stub test *\/\n+              if ( P_Left->offset == 0                 &&\n+                   P_Right->next == P_Left             &&\n+                   !( P_Left->flags & Overshoot_Bottom &&\n+                      x2 - x1 >= ras.precision_half    ) )\n+                goto Next_Pair;\n+            }\n@@ -2820,1 +2383,10 @@\n-              goto Skip_To_Next;\n+            \/* select the pixel to set and the other pixel *\/\n+            if ( dropOutControl & 4 )\n+            {\n+              x2 = SMART( x1, x2 );\n+              x1 = x1 > x2 ? x2 + ras.precision : x2 - ras.precision;\n+            }\n+            else\n+            {\n+              x2 = FLOOR  ( x2 );\n+              x1 = CEILING( x1 );\n@@ -2822,1 +2394,0 @@\n-          }\n@@ -2824,1 +2395,2 @@\n-          ras.Proc_Sweep_Span( RAS_VARS y, x1, x2, P_Left, P_Right );\n+            P_Left ->X = x2;\n+            P_Right->X = x1;\n@@ -2826,1 +2398,4 @@\n-        Skip_To_Next:\n+            \/* mark profile for drop-out processing *\/\n+            P_Left->flags |= Dropout;\n+            dropouts++;\n+          }\n@@ -2828,0 +2403,1 @@\n+        Next_Pair:\n@@ -2832,11 +2408,3 @@\n-        \/* handle drop-outs _after_ the span drawing --       *\/\n-        \/* drop-out processing has been moved out of the loop *\/\n-        \/* for performance tuning                             *\/\n-        if ( dropouts > 0 )\n-          goto Scan_DropOuts;\n-\n-      Next_Line:\n-\n-        ras.Proc_Sweep_Step( RAS_VAR );\n-\n-        y++;\n+        \/* handle drop-outs _after_ the span drawing *\/\n+        P_Left  = draw_left;\n+        P_Right = draw_right;\n@@ -2844,1 +2412,1 @@\n-        if ( y < y_change )\n+        while ( dropouts )\n@@ -2846,126 +2414,3 @@\n-          Sort( &draw_left  );\n-          Sort( &draw_right );\n-        }\n-      }\n-\n-      \/* now finalize the profiles that need it *\/\n-\n-      P = draw_left;\n-      while ( P )\n-      {\n-        Q = P->link;\n-        if ( P->height == 0 )\n-          DelOld( &draw_left, P );\n-        P = Q;\n-      }\n-\n-      P = draw_right;\n-      while ( P )\n-      {\n-        Q = P->link;\n-        if ( P->height == 0 )\n-          DelOld( &draw_right, P );\n-        P = Q;\n-      }\n-    }\n-\n-    \/* for gray-scaling, flush the bitmap scanline cache *\/\n-    while ( y <= max_Y )\n-    {\n-      ras.Proc_Sweep_Step( RAS_VAR );\n-      y++;\n-    }\n-\n-    return SUCCESS;\n-\n-  Scan_DropOuts:\n-\n-    P_Left  = draw_left;\n-    P_Right = draw_right;\n-\n-    while ( P_Left && P_Right )\n-    {\n-      if ( P_Left->countL )\n-      {\n-        P_Left->countL = 0;\n-#if 0\n-        dropouts--;  \/* -- this is useful when debugging only *\/\n-#endif\n-        ras.Proc_Sweep_Drop( RAS_VARS y,\n-                                      P_Left->X,\n-                                      P_Right->X,\n-                                      P_Left,\n-                                      P_Right );\n-      }\n-\n-      P_Left  = P_Left->link;\n-      P_Right = P_Right->link;\n-    }\n-\n-    goto Next_Line;\n-  }\n-\n-\n-#ifdef STANDALONE_\n-\n-  \/**************************************************************************\n-   *\n-   * The following functions should only compile in stand-alone mode,\n-   * i.e., when building this component without the rest of FreeType.\n-   *\n-   *\/\n-\n-  \/**************************************************************************\n-   *\n-   * @Function:\n-   *   FT_Outline_Get_CBox\n-   *\n-   * @Description:\n-   *   Return an outline's `control box'.  The control box encloses all\n-   *   the outline's points, including Bézier control points.  Though it\n-   *   coincides with the exact bounding box for most glyphs, it can be\n-   *   slightly larger in some situations (like when rotating an outline\n-   *   that contains Bézier outside arcs).\n-   *\n-   *   Computing the control box is very fast, while getting the bounding\n-   *   box can take much more time as it needs to walk over all segments\n-   *   and arcs in the outline.  To get the latter, you can use the\n-   *   `ftbbox' component, which is dedicated to this single task.\n-   *\n-   * @Input:\n-   *   outline ::\n-   *     A pointer to the source outline descriptor.\n-   *\n-   * @Output:\n-   *   acbox ::\n-   *     The outline's control box.\n-   *\n-   * @Note:\n-   *   See @FT_Glyph_Get_CBox for a discussion of tricky fonts.\n-   *\/\n-\n-  static void\n-  FT_Outline_Get_CBox( const FT_Outline*  outline,\n-                       FT_BBox           *acbox )\n-  {\n-    if ( outline && acbox )\n-    {\n-      Long  xMin, yMin, xMax, yMax;\n-\n-\n-      if ( outline->n_points == 0 )\n-      {\n-        xMin = 0;\n-        yMin = 0;\n-        xMax = 0;\n-        yMax = 0;\n-      }\n-      else\n-      {\n-        FT_Vector*  vec   = outline->points;\n-        FT_Vector*  limit = vec + outline->n_points;\n-\n-\n-        xMin = xMax = vec->x;\n-        yMin = yMax = vec->y;\n-        vec++;\n+          if ( P_Left->flags & Dropout )\n+          {\n+            ras.Proc_Sweep_Drop( RAS_VARS y, P_Left->X, P_Right->X );\n@@ -2973,3 +2418,3 @@\n-        for ( ; vec < limit; vec++ )\n-        {\n-          Long  x, y;\n+            P_Left->flags &= ~Dropout;\n+            dropouts--;\n+          }\n@@ -2977,0 +2422,3 @@\n+          P_Left  = P_Left->link;\n+          P_Right = P_Right->link;\n+        }\n@@ -2978,3 +2426,1 @@\n-          x = vec->x;\n-          if ( x < xMin ) xMin = x;\n-          if ( x > xMax ) xMax = x;\n+        ras.Proc_Sweep_Step( RAS_VAR );\n@@ -2982,4 +2428,2 @@\n-          y = vec->y;\n-          if ( y < yMin ) yMin = y;\n-          if ( y > yMax ) yMax = y;\n-        }\n+        Increment( &draw_left,   1 );\n+        Increment( &draw_right, -1 );\n@@ -2987,4 +2431,1 @@\n-      acbox->xMin = xMin;\n-      acbox->xMax = xMax;\n-      acbox->yMin = yMin;\n-      acbox->yMax = yMax;\n+      while ( ++y < y_turn );\n@@ -2994,2 +2435,0 @@\n-#endif \/* STANDALONE_ *\/\n-\n@@ -3022,0 +2461,4 @@\n+    FT_TRACE6(( \"%s pass [%d..%d]\\n\",\n+                flipped ? \"Horizontal\" : \"Vertical\",\n+                y_min, y_max ));\n+\n@@ -3027,2 +2470,0 @@\n-      ras.top = ras.buff;\n-\n@@ -3041,0 +2482,3 @@\n+        FT_TRACE6(( \"band [%d..%d]: to be bisected\\n\",\n+                    y_min, y_max ));\n+\n@@ -3048,0 +2492,4 @@\n+        FT_TRACE6(( \"band [%d..%d]: %hd profiles; %td bytes remaining\\n\",\n+                    y_min, y_max, ras.num_Profs,\n+                    (char*)ras.maxBuff - (char*)ras.top ));\n+\n@@ -3049,2 +2497,1 @@\n-          if ( Draw_Sweep( RAS_VAR ) )\n-             return ras.error;\n+          Draw_Sweep( RAS_VAR );\n@@ -3079,0 +2526,1 @@\n+    Long      buffer[FT_MAX_BLACK_POOL];\n@@ -3081,0 +2529,3 @@\n+    ras.buff     = buffer;\n+    ras.sizeBuff = (&buffer)[1]; \/* Points to right after buffer. *\/\n+\n@@ -3084,0 +2535,2 @@\n+    ras.dropOutControl = 0;\n+\n@@ -3085,7 +2538,1 @@\n-      ras.dropOutControl = 2;\n-    else\n-    {\n-      if ( ras.outline.flags & FT_OUTLINE_SMART_DROPOUTS )\n-        ras.dropOutControl = 4;\n-      else\n-        ras.dropOutControl = 0;\n+      ras.dropOutControl |= 2;\n@@ -3093,3 +2540,2 @@\n-      if ( !( ras.outline.flags & FT_OUTLINE_INCLUDE_STUBS ) )\n-        ras.dropOutControl += 1;\n-    }\n+    if ( ras.outline.flags & FT_OUTLINE_SMART_DROPOUTS )\n+      ras.dropOutControl |= 4;\n@@ -3097,2 +2543,5 @@\n-    \/* Vertical Sweep *\/\n-    FT_TRACE7(( \"Vertical pass (ftraster)\\n\" ));\n+    if ( !( ras.outline.flags & FT_OUTLINE_INCLUDE_STUBS ) )\n+      ras.dropOutControl |= 1;\n+\n+    FT_TRACE6(( \"BW Raster: precision 1\/%d, dropout mode %d\\n\",\n+                ras.precision, ras.dropOutControl ));\n@@ -3100,0 +2549,1 @@\n+    \/* Vertical Sweep *\/\n@@ -3105,7 +2555,1 @@\n-    ras.bWidth  = (UShort)ras.target.width;\n-    ras.bOrigin = (Byte*)ras.target.buffer;\n-\n-    if ( ras.target.pitch > 0 )\n-      ras.bOrigin += (Long)( ras.target.rows - 1 ) * ras.target.pitch;\n-\n-    error = Render_Single_Pass( RAS_VARS 0, 0, (Int)ras.target.rows - 1 );\n+    error = Render_Single_Pass( RAS_VARS 0, 0, ras.bTop );\n@@ -3118,2 +2562,0 @@\n-      FT_TRACE7(( \"Horizontal pass (ftraster)\\n\" ));\n-\n@@ -3125,1 +2567,1 @@\n-      error = Render_Single_Pass( RAS_VARS 1, 0, (Int)ras.target.width - 1 );\n+      error = Render_Single_Pass( RAS_VARS 1, 0, ras.bRight );\n@@ -3236,2 +2678,0 @@\n-    Long  buffer[FT_MAX_BLACK_POOL];\n-\n@@ -3246,1 +2686,1 @@\n-    if ( outline->n_points == 0 || outline->n_contours <= 0 )\n+    if ( outline->n_points == 0 || outline->n_contours == 0 )\n@@ -3272,1 +2712,0 @@\n-    ras.target  = *target_map;\n@@ -3274,2 +2713,7 @@\n-    ras.buff     = buffer;\n-    ras.sizeBuff = (&buffer)[1]; \/* Points to right after buffer. *\/\n+    ras.bTop    =   (Int)target_map->rows - 1;\n+    ras.bRight  =   (Int)target_map->width - 1;\n+    ras.bPitch  =   (Int)target_map->pitch;\n+    ras.bOrigin = (PByte)target_map->buffer;\n+\n+    if ( ras.bPitch > 0 )\n+      ras.bOrigin += ras.bTop * ras.bPitch;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftraster.c","additions":597,"deletions":1153,"binary":false,"changes":1750,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftraster.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftrend1.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftrend1.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/rasterrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/pngshim.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/pngshim.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -52,0 +52,4 @@\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+#include \"ttgpos.h\"\n+#endif\n+\n@@ -1252,0 +1256,6 @@\n+#endif\n+\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+#define PUT_GPOS_KERNING( a )  a\n+#else\n+#define PUT_GPOS_KERNING( a )  NULL\n@@ -1277,0 +1287,2 @@\n+    PUT_GPOS_KERNING( tt_face_load_gpos ),\n+                            \/* TT_Load_Table_Func      load_gpos       *\/\n@@ -1295,0 +1307,3 @@\n+    PUT_GPOS_KERNING( tt_face_get_gpos_kerning ),\n+                           \/* TT_Face_GetKerningFunc  get_gpos_kerning *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfdriver.c","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfdriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sferrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -43,0 +43,4 @@\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+#include \"ttgpos.h\"\n+#endif\n+\n@@ -1029,0 +1033,4 @@\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+    LOAD_( gpos );\n+#endif\n+\n@@ -1122,1 +1130,5 @@\n-      if ( TT_FACE_HAS_KERNING( face ) )\n+      if ( TT_FACE_HAS_KERNING( face )\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+           || face->gpos_kerning_available\n+#endif\n+         )\n@@ -1473,0 +1485,5 @@\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+    \/* freeing the GPOS table *\/\n+    tt_face_done_gpos( face );\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfobjs.c","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -21,0 +21,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -152,0 +153,1 @@\n+         woff.num_tables >  0xFFFU                                ||\n@@ -172,1 +174,3 @@\n-      FT_UInt  searchRange, entrySelector, rangeShift, x;\n+      FT_Int  entrySelector = FT_MSB( woff.num_tables );\n+      FT_Int  searchRange   = ( 1 << entrySelector ) * 16;\n+      FT_Int  rangeShift    = woff.num_tables * 16 - searchRange;\n@@ -175,12 +179,0 @@\n-      x             = woff.num_tables;\n-      entrySelector = 0;\n-      while ( x )\n-      {\n-        x            >>= 1;\n-        entrySelector += 1;\n-      }\n-      entrySelector--;\n-\n-      searchRange = ( 1 << entrySelector ) * 16;\n-      rangeShift  = woff.num_tables * 16 - searchRange;\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff.c","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2023 by\n+ * Copyright (C) 2019-2024 by\n@@ -21,0 +21,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -292,1 +293,1 @@\n-    FT_ULong  v;\n+    FT_Int    shift;\n@@ -296,4 +297,1 @@\n-      checksum += ( (FT_ULong)buf[i    ] << 24 ) |\n-                  ( (FT_ULong)buf[i + 1] << 16 ) |\n-                  ( (FT_ULong)buf[i + 2] <<  8 ) |\n-                  ( (FT_ULong)buf[i + 3] <<  0 );\n+      checksum += FT_NEXT_ULONG( buf );\n@@ -301,8 +299,3 @@\n-    \/* If size is not aligned to 4, treat as if it is padded with 0s. *\/\n-    if ( size != aligned_size )\n-    {\n-      v = 0;\n-      for ( i = aligned_size ; i < size; ++i )\n-        v |= (FT_ULong)buf[i] << ( 24 - 8 * ( i & 3 ) );\n-      checksum += v;\n-    }\n+    \/* remaining bytes can be shifted and added one at a time *\/\n+    for ( shift = 24; i < size; i++, shift -= 8 )\n+      checksum += (FT_UInt32)FT_NEXT_BYTE( buf ) << shift;\n@@ -1802,1 +1795,0 @@\n-    FT_Byte*   sfnt_header;\n@@ -1856,0 +1848,1 @@\n+         woff2.num_tables >  0xFFFU                                 ||\n@@ -2146,0 +2139,7 @@\n+      if ( ttc_font->num_tables == 0 || ttc_font->num_tables > 0xFFFU )\n+      {\n+        FT_ERROR(( \"woff2_open_font: invalid WOFF2 CollectionFontEntry\\n\" ));\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+\n@@ -2201,5 +2201,0 @@\n-    sfnt_header = sfnt;\n-\n-    WRITE_ULONG( sfnt_header, woff2.flavor );\n-\n-    if ( woff2.num_tables )\n@@ -2207,1 +2202,1 @@\n-      FT_UInt  searchRange, entrySelector, rangeShift, x;\n+      FT_Byte*  sfnt_header = sfnt;\n@@ -2209,0 +2204,3 @@\n+      FT_Int  entrySelector = FT_MSB( woff2.num_tables );\n+      FT_Int  searchRange   = ( 1 << entrySelector ) * 16;\n+      FT_Int  rangeShift    = woff2.num_tables * 16 - searchRange;\n@@ -2210,11 +2208,0 @@\n-      x             = woff2.num_tables;\n-      entrySelector = 0;\n-      while ( x )\n-      {\n-        x            >>= 1;\n-        entrySelector += 1;\n-      }\n-      entrySelector--;\n-\n-      searchRange = ( 1 << entrySelector ) * 16;\n-      rangeShift  = ( woff2.num_tables * 16 ) - searchRange;\n@@ -2222,0 +2209,1 @@\n+      WRITE_ULONG ( sfnt_header, woff2.flavor );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff2.c","additions":20,"deletions":32,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2023 by\n+ * Copyright (C) 2019-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff2.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcmap.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2009-2023 by\n+ * Copyright (C) 2009-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcmapc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2024 by\n@@ -211,1 +211,1 @@\n-    if ( base_glyph_offset >= table_size )\n+    if ( table_size <= base_glyph_offset )\n@@ -213,2 +213,2 @@\n-    if ( colr->num_base_glyphs * BASE_GLYPH_SIZE >\n-           table_size - base_glyph_offset )\n+    if ( ( table_size - base_glyph_offset ) \/ BASE_GLYPH_SIZE\n+             < colr->num_base_glyphs )\n@@ -220,1 +220,1 @@\n-    if ( layer_offset >= table_size )\n+    if ( table_size <= layer_offset )\n@@ -222,1 +222,2 @@\n-    if ( colr->num_layers * LAYER_SIZE > table_size - layer_offset )\n+    if ( ( table_size - layer_offset ) \/ LAYER_SIZE\n+             < colr->num_layers )\n@@ -232,1 +233,1 @@\n-      if ( base_glyphs_offset_v1 >= table_size - 4 )\n+      if ( table_size - 4 <= base_glyphs_offset_v1 )\n@@ -238,2 +239,2 @@\n-      if ( num_base_glyphs_v1 * BASE_GLYPH_PAINT_RECORD_SIZE >\n-             table_size - base_glyphs_offset_v1 )\n+      if ( ( table_size - base_glyphs_offset_v1 ) \/ BASE_GLYPH_PAINT_RECORD_SIZE\n+               < num_base_glyphs_v1 )\n@@ -247,1 +248,1 @@\n-      if ( layer_offset_v1 >= table_size )\n+      if ( table_size <= layer_offset_v1 )\n@@ -252,1 +253,1 @@\n-        if ( layer_offset_v1 >= table_size - 4 )\n+        if ( table_size - 4 <= layer_offset_v1 )\n@@ -258,2 +259,2 @@\n-        if ( num_layers_v1 * LAYER_V1_LIST_PAINT_OFFSET_SIZE >\n-               table_size - layer_offset_v1 )\n+        if ( ( table_size - layer_offset_v1 ) \/ LAYER_V1_LIST_PAINT_OFFSET_SIZE\n+                < num_layers_v1 )\n@@ -282,1 +283,1 @@\n-      if ( clip_list_offset >= table_size )\n+      if ( table_size <= clip_list_offset )\n@@ -314,1 +315,1 @@\n-        if ( var_store_offset >= table_size )\n+        if ( table_size <= var_store_offset )\n@@ -664,0 +665,1 @@\n+      ENSURE_READ_BYTES( 5 );\n@@ -1281,1 +1283,2 @@\n-      FT_UInt  mid = min + ( max - min ) \/ 2;\n+      FT_UInt    mid = min + ( max - min ) \/ 2;\n+      FT_UShort  gid;\n@@ -1290,2 +1293,1 @@\n-      FT_UShort  gid = FT_NEXT_USHORT( p );\n-\n+      gid = FT_NEXT_USHORT( p );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcolr.c","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcolr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcpal.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcpal.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttkern.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttkern.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -1049,1 +1049,1 @@\n-    FT_Memory     memory = face->root.driver->root.memory;\n+    FT_Memory     memory = face->root.memory;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttload.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttmtx.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttmtx.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -207,2 +207,2 @@\n-      FT_ULong   p;\n-      FT_Byte*   strings;\n+      FT_Byte*   p;\n+      FT_Byte*   p_end;\n@@ -217,2 +217,2 @@\n-      strings = (FT_Byte*)( name_strings + num_names );\n-      if ( FT_STREAM_READ( strings, post_len ) )\n+      p = (FT_Byte*)( name_strings + num_names );\n+      if ( FT_STREAM_READ( p, post_len ) )\n@@ -221,0 +221,2 @@\n+      p_end = p + post_len;\n+\n@@ -222,1 +224,1 @@\n-      for ( p = 0, n = 0; p < post_len && n < num_names; n++ )\n+      for ( n = 0; p < p_end && n < num_names; n++ )\n@@ -224,1 +226,1 @@\n-        FT_UInt  len = strings[p];\n+        FT_UInt  len = *p;\n@@ -227,5 +229,3 @@\n-        if ( len > 63U )\n-        {\n-          error = FT_THROW( Invalid_File_Format );\n-          goto Fail;\n-        }\n+        \/* names in the Adobe Glyph List are shorter than 40 characters *\/\n+        if ( len >= 40U )\n+          FT_TRACE4(( \"load_format_20: unusual %u-char name found\\n\", len ));\n@@ -233,3 +233,3 @@\n-        strings[p]      = 0;\n-        name_strings[n] = strings + p + 1;\n-        p              += len + 1;\n+        *p++            = 0;\n+        name_strings[n] = p;\n+        p              += len;\n@@ -237,1 +237,1 @@\n-      strings[post_len] = 0;\n+      *p_end = 0;\n@@ -243,1 +243,1 @@\n-                    num_names - n ));\n+                    (FT_UShort)( num_names - n ) ));\n@@ -246,1 +246,1 @@\n-          name_strings[n] = strings + post_len;\n+          name_strings[n] = p_end;\n@@ -439,7 +439,2 @@\n-    if ( format == 0x00010000L )\n-    {\n-      if ( idx < 258 )                    \/* paranoid checking *\/\n-        *PSname = MAC_NAME( idx );\n-    }\n-    else if ( format == 0x00020000L ||\n-              format == 0x00025000L )\n+    if ( format == 0x00020000L ||\n+         format == 0x00025000L )\n@@ -469,0 +464,5 @@\n+    \/* version 1.0 is only valid with 258 glyphs *\/\n+    else if ( format == 0x00010000L              &&\n+              face->max_profile.numGlyphs == 258 )\n+      *PSname = MAC_NAME( idx );\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttpost.c","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttpost.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2023 by\n+ * Copyright (C) 2005-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttsbit.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttsbit.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2023 by\n+ * Copyright (C) 2019-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/woff2tags.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2023 by\n+ * Copyright (C) 2019-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/woff2tags.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2024 by\n@@ -492,1 +492,1 @@\n-    ft_jmp_buf  jump_buffer;\n+    FT_BBox     cbox;\n@@ -513,0 +513,2 @@\n+    ft_jmp_buf  jump_buffer;\n+\n@@ -1000,32 +1002,3 @@\n-   * Benchmarking shows that using DDA to flatten the quadratic Bézier arcs\n-   * is slightly faster in the following cases:\n-   *\n-   *   - When the host CPU is 64-bit.\n-   *   - When SSE2 SIMD registers and instructions are available (even on\n-   *     x86).\n-   *\n-   * For other cases, using binary splits is actually slightly faster.\n-   *\/\n-#if ( defined( __SSE2__ )                          ||   \\\n-      defined( __x86_64__ )                        ||   \\\n-      defined( _M_AMD64 )                          ||   \\\n-      ( defined( _M_IX86_FP ) && _M_IX86_FP >= 2 ) ) && \\\n-    !defined( __VMS )\n-#  define FT_SSE2 1\n-#else\n-#  define FT_SSE2 0\n-#endif\n-\n-#if FT_SSE2                || \\\n-    defined( __aarch64__ ) || \\\n-    defined( _M_ARM64 )\n-#  define BEZIER_USE_DDA  1\n-#else\n-#  define BEZIER_USE_DDA  0\n-#endif\n-\n-  \/*\n-   * For now, the code that depends on `BEZIER_USE_DDA` requires `FT_Int64`\n-   * to be defined.  If `FT_INT64` is not defined, meaning there is no\n-   * 64-bit type available, disable it to avoid compilation errors.  See for\n-   * example https:\/\/gitlab.freedesktop.org\/freetype\/freetype\/-\/issues\/1071.\n+   * For now, the code that uses DDA to render conic curves requires\n+   * `FT_Int64` to be defined.  See for example\n+   *    https:\/\/gitlab.freedesktop.org\/freetype\/freetype\/-\/issues\/1071.\n@@ -1033,6 +1006,0 @@\n-#if !defined( FT_INT64 )\n-#  undef BEZIER_USE_DDA\n-#  define BEZIER_USE_DDA  0\n-#endif\n-\n-#if BEZIER_USE_DDA\n@@ -1040,3 +1007,1 @@\n-#if FT_SSE2\n-#  include <emmintrin.h>\n-#endif\n+#ifdef FT_INT64\n@@ -1098,1 +1063,1 @@\n-    \/* We can calculate the number of necessary bisections because  *\/\n+    \/* We can calculate the number of necessary segments because    *\/\n@@ -1101,1 +1066,1 @@\n-    shift = 0;\n+    shift = 16;\n@@ -1104,2 +1069,2 @@\n-      dx   >>= 2;\n-      shift += 1;\n+      dx >>= 2;\n+      shift--;\n@@ -1108,0 +1073,1 @@\n+    count = 0x10000U >> shift;\n@@ -1153,58 +1119,2 @@\n-#if FT_SSE2\n-    \/* Experience shows that for small shift values, *\/\n-    \/* SSE2 is actually slower.                      *\/\n-    if ( shift > 2 )\n-    {\n-      union\n-      {\n-        struct { FT_Int64  ax, ay, bx, by; }  i;\n-        struct { __m128i  a, b; }  vec;\n-\n-      } u;\n-\n-      union\n-      {\n-        struct { FT_Int32  px_lo, px_hi, py_lo, py_hi; }  i;\n-        __m128i  vec;\n-\n-      } v;\n-\n-      __m128i  a, b;\n-      __m128i  r, q, q2;\n-      __m128i  p;\n-\n-\n-      u.i.ax = ax;\n-      u.i.ay = ay;\n-      u.i.bx = bx;\n-      u.i.by = by;\n-\n-      a = _mm_load_si128( &u.vec.a );\n-      b = _mm_load_si128( &u.vec.b );\n-\n-      r  = _mm_slli_epi64( a, 33 - 2 * shift );\n-      q  = _mm_slli_epi64( b, 33 - shift );\n-      q2 = _mm_slli_epi64( a, 32 - 2 * shift );\n-\n-      q = _mm_add_epi64( q2, q );\n-\n-      v.i.px_lo = 0;\n-      v.i.px_hi = p0.x;\n-      v.i.py_lo = 0;\n-      v.i.py_hi = p0.y;\n-\n-      p = _mm_load_si128( &v.vec );\n-\n-      for ( count = 1U << shift; count > 0; count-- )\n-      {\n-        p = _mm_add_epi64( p, q );\n-        q = _mm_add_epi64( q, r );\n-\n-        _mm_store_si128( &v.vec, p );\n-\n-        gray_render_line( RAS_VAR_ v.i.px_hi, v.i.py_hi );\n-      }\n-\n-      return;\n-    }\n-#endif  \/* FT_SSE2 *\/\n+    rx = LEFT_SHIFT( ax, shift + shift );\n+    ry = LEFT_SHIFT( ay, shift + shift );\n@@ -1212,2 +1122,2 @@\n-    rx = LEFT_SHIFT( ax, 33 - 2 * shift );\n-    ry = LEFT_SHIFT( ay, 33 - 2 * shift );\n+    qx = LEFT_SHIFT( bx, shift + 17 ) + rx;\n+    qy = LEFT_SHIFT( by, shift + 17 ) + ry;\n@@ -1215,2 +1125,2 @@\n-    qx = LEFT_SHIFT( bx, 33 - shift ) + LEFT_SHIFT( ax, 32 - 2 * shift );\n-    qy = LEFT_SHIFT( by, 33 - shift ) + LEFT_SHIFT( ay, 32 - 2 * shift );\n+    rx *= 2;\n+    ry *= 2;\n@@ -1221,1 +1131,1 @@\n-    for ( count = 1U << shift; count > 0; count-- )\n+    do\n@@ -1230,1 +1140,1 @@\n-    }\n+    } while ( --count );\n@@ -1233,1 +1143,1 @@\n-#else  \/* !BEZIER_USE_DDA *\/\n+#else  \/* !FT_INT64 *\/\n@@ -1327,1 +1237,1 @@\n-#endif  \/* !BEZIER_USE_DDA *\/\n+#endif  \/* !FT_INT64 *\/\n@@ -1489,133 +1399,0 @@\n-  static void\n-  gray_sweep( RAS_ARG )\n-  {\n-    int  fill = ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL ) ? 0x100\n-                                                                 : INT_MIN;\n-    int  coverage;\n-    int  y;\n-\n-\n-    for ( y = ras.min_ey; y < ras.max_ey; y++ )\n-    {\n-      PCell   cell  = ras.ycells[y - ras.min_ey];\n-      TCoord  x     = ras.min_ex;\n-      TArea   cover = 0;\n-\n-      unsigned char*  line = ras.target.origin - ras.target.pitch * y;\n-\n-\n-      for ( ; cell != ras.cell_null; cell = cell->next )\n-      {\n-        TArea  area;\n-\n-\n-        if ( cover != 0 && cell->x > x )\n-        {\n-          FT_FILL_RULE( coverage, cover, fill );\n-          FT_GRAY_SET( line + x, coverage, cell->x - x );\n-        }\n-\n-        cover += (TArea)cell->cover * ( ONE_PIXEL * 2 );\n-        area   = cover - cell->area;\n-\n-        if ( area != 0 && cell->x >= ras.min_ex )\n-        {\n-          FT_FILL_RULE( coverage, area, fill );\n-          line[cell->x] = (unsigned char)coverage;\n-        }\n-\n-        x = cell->x + 1;\n-      }\n-\n-      if ( cover != 0 )  \/* only if cropped *\/\n-      {\n-        FT_FILL_RULE( coverage, cover, fill );\n-        FT_GRAY_SET( line + x, coverage, ras.max_ex - x );\n-      }\n-    }\n-  }\n-\n-\n-  static void\n-  gray_sweep_direct( RAS_ARG )\n-  {\n-    int  fill = ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL ) ? 0x100\n-                                                                 : INT_MIN;\n-    int  coverage;\n-    int  y;\n-\n-    FT_Span  span[FT_MAX_GRAY_SPANS];\n-    int      n = 0;\n-\n-\n-    for ( y = ras.min_ey; y < ras.max_ey; y++ )\n-    {\n-      PCell   cell  = ras.ycells[y - ras.min_ey];\n-      TCoord  x     = ras.min_ex;\n-      TArea   cover = 0;\n-\n-\n-      for ( ; cell != ras.cell_null; cell = cell->next )\n-      {\n-        TArea  area;\n-\n-\n-        if ( cover != 0 && cell->x > x )\n-        {\n-          FT_FILL_RULE( coverage, cover, fill );\n-\n-          span[n].coverage = (unsigned char)coverage;\n-          span[n].x        = (short)x;\n-          span[n].len      = (unsigned short)( cell->x - x );\n-\n-          if ( ++n == FT_MAX_GRAY_SPANS )\n-          {\n-            \/* flush the span buffer and reset the count *\/\n-            ras.render_span( y, n, span, ras.render_span_data );\n-            n = 0;\n-          }\n-        }\n-\n-        cover += (TArea)cell->cover * ( ONE_PIXEL * 2 );\n-        area   = cover - cell->area;\n-\n-        if ( area != 0 && cell->x >= ras.min_ex )\n-        {\n-          FT_FILL_RULE( coverage, area, fill );\n-\n-          span[n].coverage = (unsigned char)coverage;\n-          span[n].x        = (short)cell->x;\n-          span[n].len      = 1;\n-\n-          if ( ++n == FT_MAX_GRAY_SPANS )\n-          {\n-            \/* flush the span buffer and reset the count *\/\n-            ras.render_span( y, n, span, ras.render_span_data );\n-            n = 0;\n-          }\n-        }\n-\n-        x = cell->x + 1;\n-      }\n-\n-      if ( cover != 0 )  \/* only if cropped *\/\n-      {\n-        FT_FILL_RULE( coverage, cover, fill );\n-\n-        span[n].coverage = (unsigned char)coverage;\n-        span[n].x        = (short)x;\n-        span[n].len      = (unsigned short)( ras.max_ex - x );\n-\n-        ++n;\n-      }\n-\n-      if ( n )\n-      {\n-        \/* flush the span buffer and reset the count *\/\n-        ras.render_span( y, n, span, ras.render_span_data );\n-        n = 0;\n-      }\n-    }\n-  }\n-\n-\n@@ -1937,1 +1714,1 @@\n-      FT_TRACE7(( \"band [%d..%d]: %td cell%s remaining\/\\n\",\n+      FT_TRACE7(( \"band [%d..%d]: %td cell%s remaining\\n\",\n@@ -1955,0 +1732,133 @@\n+  static void\n+  gray_sweep( RAS_ARG )\n+  {\n+    int  fill = ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL ) ? 0x100\n+                                                                 : INT_MIN;\n+    int  coverage;\n+    int  y;\n+\n+\n+    for ( y = ras.min_ey; y < ras.max_ey; y++ )\n+    {\n+      PCell   cell  = ras.ycells[y - ras.min_ey];\n+      TCoord  x     = ras.min_ex;\n+      TArea   cover = 0;\n+\n+      unsigned char*  line = ras.target.origin - ras.target.pitch * y;\n+\n+\n+      for ( ; cell != ras.cell_null; cell = cell->next )\n+      {\n+        TArea  area;\n+\n+\n+        if ( cover != 0 && cell->x > x )\n+        {\n+          FT_FILL_RULE( coverage, cover, fill );\n+          FT_GRAY_SET( line + x, coverage, cell->x - x );\n+        }\n+\n+        cover += (TArea)cell->cover * ( ONE_PIXEL * 2 );\n+        area   = cover - cell->area;\n+\n+        if ( area != 0 && cell->x >= ras.min_ex )\n+        {\n+          FT_FILL_RULE( coverage, area, fill );\n+          line[cell->x] = (unsigned char)coverage;\n+        }\n+\n+        x = cell->x + 1;\n+      }\n+\n+      if ( cover != 0 )  \/* only if cropped *\/\n+      {\n+        FT_FILL_RULE( coverage, cover, fill );\n+        FT_GRAY_SET( line + x, coverage, ras.max_ex - x );\n+      }\n+    }\n+  }\n+\n+\n+  static void\n+  gray_sweep_direct( RAS_ARG )\n+  {\n+    int  fill = ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL ) ? 0x100\n+                                                                 : INT_MIN;\n+    int  coverage;\n+    int  y;\n+\n+    FT_Span  span[FT_MAX_GRAY_SPANS];\n+    int      n = 0;\n+\n+\n+    for ( y = ras.min_ey; y < ras.max_ey; y++ )\n+    {\n+      PCell   cell  = ras.ycells[y - ras.min_ey];\n+      TCoord  x     = ras.min_ex;\n+      TArea   cover = 0;\n+\n+\n+      for ( ; cell != ras.cell_null; cell = cell->next )\n+      {\n+        TArea  area;\n+\n+\n+        if ( cover != 0 && cell->x > x )\n+        {\n+          FT_FILL_RULE( coverage, cover, fill );\n+\n+          span[n].coverage = (unsigned char)coverage;\n+          span[n].x        = (short)x;\n+          span[n].len      = (unsigned short)( cell->x - x );\n+\n+          if ( ++n == FT_MAX_GRAY_SPANS )\n+          {\n+            \/* flush the span buffer and reset the count *\/\n+            ras.render_span( y, n, span, ras.render_span_data );\n+            n = 0;\n+          }\n+        }\n+\n+        cover += (TArea)cell->cover * ( ONE_PIXEL * 2 );\n+        area   = cover - cell->area;\n+\n+        if ( area != 0 && cell->x >= ras.min_ex )\n+        {\n+          FT_FILL_RULE( coverage, area, fill );\n+\n+          span[n].coverage = (unsigned char)coverage;\n+          span[n].x        = (short)cell->x;\n+          span[n].len      = 1;\n+\n+          if ( ++n == FT_MAX_GRAY_SPANS )\n+          {\n+            \/* flush the span buffer and reset the count *\/\n+            ras.render_span( y, n, span, ras.render_span_data );\n+            n = 0;\n+          }\n+        }\n+\n+        x = cell->x + 1;\n+      }\n+\n+      if ( cover != 0 )  \/* only if cropped *\/\n+      {\n+        FT_FILL_RULE( coverage, cover, fill );\n+\n+        span[n].coverage = (unsigned char)coverage;\n+        span[n].x        = (short)x;\n+        span[n].len      = (unsigned short)( ras.max_ex - x );\n+\n+        ++n;\n+      }\n+\n+      if ( n )\n+      {\n+        \/* flush the span buffer and reset the count *\/\n+        ras.render_span( y, n, span, ras.render_span_data );\n+        n = 0;\n+      }\n+    }\n+  }\n+\n+\n@@ -1958,3 +1868,0 @@\n-    const TCoord  yMin = ras.min_ey;\n-    const TCoord  yMax = ras.max_ey;\n-\n@@ -1962,1 +1869,1 @@\n-    size_t   height = (size_t)( yMax - yMin );\n+    size_t   height = (size_t)( ras.cbox.yMax - ras.cbox.yMin );\n@@ -1988,1 +1895,1 @@\n-    for ( y = yMin; y < yMax; )\n+    for ( y = ras.cbox.yMin; y < ras.cbox.yMax; )\n@@ -1992,1 +1899,3 @@\n-      ras.max_ey = FT_MIN( y, yMax );\n+      ras.max_ey = FT_MIN( y, ras.cbox.yMax );\n+\n+      ras.count_ey = ras.max_ey - ras.min_ey;\n@@ -1995,2 +1904,2 @@\n-      band[1] = ras.min_ey;\n-      band[0] = ras.max_ey;\n+      band[1] = ras.cbox.xMin;\n+      band[0] = ras.cbox.xMax;\n@@ -2000,2 +1909,1 @@\n-        TCoord  width = band[0] - band[1];\n-        TCoord  w;\n+        TCoord  i;\n@@ -2005,2 +1913,6 @@\n-        for ( w = 0; w < width; ++w )\n-          ras.ycells[w] = ras.cell_null;\n+        ras.min_ex = band[1];\n+        ras.max_ex = band[0];\n+\n+        \/* memory management: zero out and skip ycells *\/\n+        for ( i = 0; i < ras.count_ey; ++i )\n+          ras.ycells[i] = ras.cell_null;\n@@ -2008,3 +1920,2 @@\n-        \/* memory management: skip ycells *\/\n-        n = ( (size_t)width * sizeof ( PCell ) + sizeof ( TCell ) - 1 ) \/\n-              sizeof ( TCell );\n+        n = ( (size_t)ras.count_ey * sizeof ( PCell ) + sizeof ( TCell ) - 1 )\n+              \/ sizeof ( TCell );\n@@ -2014,3 +1925,0 @@\n-        ras.min_ey    = band[1];\n-        ras.max_ey    = band[0];\n-        ras.count_ey  = width;\n@@ -2034,1 +1942,1 @@\n-        width >>= 1;\n+        i = ( band[0] - band[1] ) >> 1;\n@@ -2037,1 +1945,1 @@\n-        if ( width == 0 )\n+        if ( i == 0 )\n@@ -2045,1 +1953,1 @@\n-        band[0] += width;\n+        band[0] += i;\n@@ -2076,1 +1984,1 @@\n-    if ( outline->n_points == 0 || outline->n_contours <= 0 )\n+    if ( outline->n_points == 0 || outline->n_contours == 0 )\n@@ -2096,4 +2004,1 @@\n-      ras.min_ex = params->clip_box.xMin;\n-      ras.min_ey = params->clip_box.yMin;\n-      ras.max_ex = params->clip_box.xMax;\n-      ras.max_ey = params->clip_box.yMax;\n+      ras.cbox = params->clip_box;\n@@ -2125,4 +2030,4 @@\n-      ras.min_ex = 0;\n-      ras.min_ey = 0;\n-      ras.max_ex = (FT_Pos)target_map->width;\n-      ras.max_ey = (FT_Pos)target_map->rows;\n+      ras.cbox.xMin = 0;\n+      ras.cbox.yMin = 0;\n+      ras.cbox.xMax = (FT_Pos)target_map->width;\n+      ras.cbox.yMax = (FT_Pos)target_map->rows;\n@@ -2132,1 +2037,1 @@\n-    if ( ras.max_ex <= ras.min_ex || ras.max_ey <= ras.min_ey )\n+    if ( ras.cbox.xMin >= ras.cbox.xMax || ras.cbox.yMin >= ras.cbox.yMax )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftgrays.c","additions":183,"deletions":278,"binary":false,"changes":461,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftgrays.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftsmerrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftsmooth.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftsmooth.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -220,1 +220,14 @@\n-      kerning->x = sfnt->get_kerning( ttface, left_glyph, right_glyph );\n+    {\n+      \/* Use 'kern' table if available since that can be faster; otherwise *\/\n+      \/* use GPOS kerning pairs if available.                              *\/\n+      if ( ttface->kern_avail_bits != 0 )\n+        kerning->x = sfnt->get_kerning( ttface,\n+                                        left_glyph,\n+                                        right_glyph );\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+      else if ( ttface->gpos_kerning_available )\n+        kerning->x = sfnt->get_gpos_kerning( ttface,\n+                                             left_glyph,\n+                                             right_glyph );\n+#endif\n+    }\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttdriver.c","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttdriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/tterrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -356,1 +356,2 @@\n-    FT_Short        *cont, *cont_limit, last;\n+    FT_UShort       *cont, *cont_limit;\n+    FT_Int          last;\n@@ -375,1 +376,1 @@\n-      *cont = FT_NEXT_SHORT( p );\n+      *cont = FT_NEXT_USHORT( p );\n@@ -421,1 +422,1 @@\n-        if ( FT_QNEW_ARRAY( exec->glyphIns, n_ins ) )\n+        if ( FT_DUP( exec->glyphIns, p, n_ins ) )\n@@ -424,2 +425,0 @@\n-        FT_MEM_COPY( exec->glyphIns, p, (FT_Long)n_ins );\n-\n@@ -435,1 +434,1 @@\n-    flag       = (FT_Byte*)outline->tags;\n+    flag       = outline->tags;\n@@ -468,1 +467,1 @@\n-    flag      = (FT_Byte*)outline->tags;\n+    flag      = outline->tags;\n@@ -502,1 +501,1 @@\n-    flag      = (FT_Byte*)outline->tags;\n+    flag      = outline->tags;\n@@ -535,2 +534,2 @@\n-    outline->n_points   = (FT_Short)n_points;\n-    outline->n_contours = (FT_Short)n_contours;\n+    outline->n_points   = (FT_UShort)n_points;\n+    outline->n_contours = (FT_UShort)n_contours;\n@@ -757,4 +756,2 @@\n-    zone->n_points    = (FT_UShort)load->outline.n_points + 4 -\n-                          (FT_UShort)start_point;\n-    zone->n_contours  = load->outline.n_contours -\n-                          (FT_Short)start_contour;\n+    zone->n_points    = load->outline.n_points + 4 - (FT_UShort)start_point;\n+    zone->n_contours  = load->outline.n_contours - (FT_UShort)start_contour;\n@@ -764,2 +761,2 @@\n-    zone->tags        = (FT_Byte*)load->outline.tags + start_point;\n-    zone->contours    = (FT_UShort*)load->outline.contours + start_contour;\n+    zone->tags        = load->outline.tags + start_point;\n+    zone->contours    = load->outline.contours + start_contour;\n@@ -1049,1 +1046,1 @@\n-                         (short)num_base_points;\n+                         (FT_UShort)num_base_points;\n@@ -1062,1 +1059,1 @@\n-      FT_UInt     num_points = (FT_UInt)gloader->base.outline.n_points;\n+      FT_UInt     num_points = gloader->base.outline.n_points;\n@@ -1724,2 +1721,2 @@\n-      start_point   = (FT_UInt)gloader->base.outline.n_points;\n-      start_contour = (FT_UInt)gloader->base.outline.n_contours;\n+      start_point   = gloader->base.outline.n_points;\n+      start_contour = gloader->base.outline.n_contours;\n@@ -1744,1 +1741,1 @@\n-        short        i, limit;\n+        FT_UShort    i, limit;\n@@ -1751,1 +1748,1 @@\n-        limit = (short)gloader->current.num_subglyphs;\n+        limit = (FT_UShort)gloader->current.num_subglyphs;\n@@ -1877,1 +1874,1 @@\n-          num_base_points = (FT_UInt)gloader->base.outline.n_points;\n+          num_base_points = gloader->base.outline.n_points;\n@@ -1901,1 +1898,1 @@\n-          num_points = (FT_UInt)gloader->base.outline.n_points;\n+          num_points = gloader->base.outline.n_points;\n@@ -2316,1 +2313,1 @@\n-       * 2) FT_RENDER_MODE_MONO (i.e, monochome rendering) is requested.\n+       * 2) FT_RENDER_MODE_MONO (i.e, monochrome rendering) is requested.\n@@ -2722,1 +2719,1 @@\n-    FT_TRACE1(( \"  subglyphs = %u, contours = %hd, points = %hd,\"\n+    FT_TRACE1(( \"  subglyphs = %u, contours = %hu, points = %hu,\"\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgload.c","additions":24,"deletions":27,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2024 by\n@@ -132,3 +132,0 @@\n-   *   size ::\n-   *     The size of the table holding the data.\n-   *\n@@ -147,1 +144,0 @@\n-                           FT_ULong   size,\n@@ -152,1 +148,1 @@\n-    FT_UInt    runcnt;\n+    FT_UInt    runcnt, cnt;\n@@ -155,0 +151,1 @@\n+    FT_Byte*   p;\n@@ -172,3 +169,1 @@\n-    if ( n > size )\n-    {\n-      FT_TRACE1(( \"ft_var_readpackedpoints: number of points too large\\n\" ));\n+    if ( FT_QNEW_ARRAY( points, n ) )\n@@ -176,9 +171,0 @@\n-    }\n-\n-    \/* in the nested loops below we increase `i' twice; *\/\n-    \/* it is faster to simply allocate one more slot    *\/\n-    \/* than to add another test within the loop         *\/\n-    if ( FT_QNEW_ARRAY( points, n + 1 ) )\n-      return NULL;\n-\n-    *point_cnt = n;\n@@ -186,0 +172,1 @@\n+    p     = stream->cursor;\n@@ -190,1 +177,11 @@\n-      runcnt = FT_GET_BYTE();\n+      if ( p >= stream->limit )\n+        goto Fail;\n+\n+      runcnt = FT_NEXT_BYTE( p );\n+      cnt    = runcnt & GX_PT_POINT_RUN_COUNT_MASK;\n+\n+      \/* first point not included in run count *\/\n+      cnt++;\n+      if ( cnt > n - i )\n+        cnt = n - i;\n+\n@@ -193,3 +190,2 @@\n-        runcnt     &= GX_PT_POINT_RUN_COUNT_MASK;\n-        first      += FT_GET_USHORT();\n-        points[i++] = first;\n+        if ( 2 * cnt > (FT_UInt)( stream->limit - p ) )\n+          goto Fail;\n@@ -197,2 +193,1 @@\n-        \/* first point not included in run count *\/\n-        for ( j = 0; j < runcnt; j++ )\n+        for ( j = 0; j < cnt; j++ )\n@@ -200,1 +195,1 @@\n-          first      += FT_GET_USHORT();\n+          first      += FT_NEXT_USHORT( p );\n@@ -202,2 +197,0 @@\n-          if ( i >= n )\n-            break;\n@@ -208,2 +201,2 @@\n-        first      += FT_GET_BYTE();\n-        points[i++] = first;\n+        if ( cnt > (FT_UInt)( stream->limit - p ) )\n+          goto Fail;\n@@ -211,1 +204,1 @@\n-        for ( j = 0; j < runcnt; j++ )\n+        for ( j = 0; j < cnt; j++ )\n@@ -213,1 +206,1 @@\n-          first      += FT_GET_BYTE();\n+          first      += FT_NEXT_BYTE( p );\n@@ -215,2 +208,0 @@\n-          if ( i >= n )\n-            break;\n@@ -221,0 +212,4 @@\n+    stream->cursor = p;\n+\n+    *point_cnt = n;\n+\n@@ -222,0 +217,6 @@\n+\n+  Fail:\n+    FT_TRACE1(( \"ft_var_readpackedpoints: invalid table\\n\" ));\n+\n+    FT_FREE( points );\n+    return NULL;\n@@ -243,3 +244,0 @@\n-   *   size ::\n-   *     The size of the table holding the data.\n-   *\n@@ -261,1 +259,0 @@\n-                           FT_ULong   size,\n@@ -267,1 +264,1 @@\n-    FT_UInt    bytes_used;\n+    FT_Byte*   p;\n@@ -275,4 +272,3 @@\n-    i          = 0;\n-    bytes_used = 0;\n-\n-    while ( i < delta_cnt && bytes_used < size )\n+    p = stream->cursor;\n+    i = 0;\n+    while ( i < delta_cnt )\n@@ -280,1 +276,4 @@\n-      runcnt = FT_GET_BYTE();\n+      if ( p >= stream->limit )\n+        goto Fail;\n+\n+      runcnt = FT_NEXT_BYTE( p );\n@@ -283,1 +282,4 @@\n-      bytes_used++;\n+      \/* first point not included in run count *\/\n+      cnt++;\n+      if ( cnt > delta_cnt - i )\n+        cnt = delta_cnt - i;\n@@ -287,2 +289,1 @@\n-        \/* `cnt` + 1 zeroes get added *\/\n-        for ( j = 0; j <= cnt && i < delta_cnt; j++ )\n+        for ( j = 0; j < cnt; j++ )\n@@ -293,6 +294,1 @@\n-        \/* `cnt` + 1 shorts from the stack *\/\n-        bytes_used += 2 * ( cnt + 1 );\n-        if ( bytes_used > size )\n-        {\n-          FT_TRACE1(( \"ft_var_readpackeddeltas:\"\n-                      \" number of short deltas too large\\n\" ));\n+        if ( 2 * cnt > (FT_UInt)( stream->limit - p ) )\n@@ -300,1 +296,0 @@\n-        }\n@@ -302,2 +297,2 @@\n-        for ( j = 0; j <= cnt && i < delta_cnt; j++ )\n-          deltas[i++] = FT_intToFixed( FT_GET_SHORT() );\n+        for ( j = 0; j < cnt; j++ )\n+          deltas[i++] = FT_intToFixed( FT_NEXT_SHORT( p ) );\n@@ -307,6 +302,1 @@\n-        \/* `cnt` + 1 signed bytes from the stack *\/\n-        bytes_used += cnt + 1;\n-        if ( bytes_used > size )\n-        {\n-          FT_TRACE1(( \"ft_var_readpackeddeltas:\"\n-                      \" number of byte deltas too large\\n\" ));\n+        if ( cnt > (FT_UInt)( stream->limit - p ) )\n@@ -314,1 +304,0 @@\n-        }\n@@ -316,9 +305,2 @@\n-        for ( j = 0; j <= cnt && i < delta_cnt; j++ )\n-          deltas[i++] = FT_intToFixed( FT_GET_CHAR() );\n-      }\n-\n-      if ( j <= cnt )\n-      {\n-        FT_TRACE1(( \"ft_var_readpackeddeltas:\"\n-                    \" number of deltas too large\\n\" ));\n-        goto Fail;\n+        for ( j = 0; j < cnt; j++ )\n+          deltas[i++] = FT_intToFixed( FT_NEXT_CHAR( p ) );\n@@ -328,5 +310,1 @@\n-    if ( i < delta_cnt )\n-    {\n-      FT_TRACE1(( \"ft_var_readpackeddeltas: not enough deltas\\n\" ));\n-      goto Fail;\n-    }\n+    stream->cursor = p;\n@@ -337,0 +315,2 @@\n+    FT_TRACE1(( \"ft_var_readpackeddeltas: invalid table\\n\" ));\n+\n@@ -599,1 +579,1 @@\n-        FT_Short  start, peak, end;\n+        FT_Int  start, peak, end;\n@@ -607,0 +587,4 @@\n+        \/* immediately tag invalid ranges with special peak = 0 *\/\n+        if ( ( start < 0 && end > 0 ) || start > peak || peak > end )\n+          peak = 0;\n+\n@@ -1027,0 +1011,3 @@\n+    if ( varData->regionIdxCount == 0 )\n+      return 0; \/* Avoid \"applying zero offset to null pointer\". *\/\n+\n@@ -1077,5 +1064,1 @@\n-        \/* compute the scalar contribution of this axis; *\/\n-        \/* ignore invalid ranges                         *\/\n-        if ( axis->startCoord > axis->peakCoord ||\n-             axis->peakCoord > axis->endCoord   )\n-          continue;\n+        FT_Fixed  ncv = ttface->blend->normalizedcoords[j];\n@@ -1083,4 +1066,0 @@\n-        else if ( axis->startCoord < 0 &&\n-                  axis->endCoord > 0   &&\n-                  axis->peakCoord != 0 )\n-          continue;\n@@ -1088,5 +1067,4 @@\n-        \/* peak of 0 means ignore this axis *\/\n-        else if ( axis->peakCoord == 0 )\n-          continue;\n-\n-        else if ( ttface->blend->normalizedcoords[j] == axis->peakCoord )\n+        \/* compute the scalar contribution of this axis *\/\n+        \/* with peak of 0 used for invalid axes         *\/\n+        if ( axis->peakCoord == ncv ||\n+             axis->peakCoord == 0   )\n@@ -1096,2 +1074,2 @@\n-        else if ( ttface->blend->normalizedcoords[j] <= axis->startCoord ||\n-                  ttface->blend->normalizedcoords[j] >= axis->endCoord   )\n+        else if ( ncv <= axis->startCoord ||\n+                  ncv >= axis->endCoord   )\n@@ -1104,10 +1082,8 @@\n-        else if ( ttface->blend->normalizedcoords[j] < axis->peakCoord )\n-          scalar =\n-            FT_MulDiv( scalar,\n-                       ttface->blend->normalizedcoords[j] - axis->startCoord,\n-                       axis->peakCoord - axis->startCoord );\n-        else\n-          scalar =\n-            FT_MulDiv( scalar,\n-                       axis->endCoord - ttface->blend->normalizedcoords[j],\n-                       axis->endCoord - axis->peakCoord );\n+        else if ( ncv < axis->peakCoord )\n+          scalar = FT_MulDiv( scalar,\n+                              ncv - axis->startCoord,\n+                              axis->peakCoord - axis->startCoord );\n+        else   \/* ncv > axis->peakCoord *\/\n+          scalar = FT_MulDiv( scalar,\n+                              axis->endCoord - ncv,\n+                              axis->endCoord - axis->peakCoord );\n@@ -1923,2 +1899,4 @@\n-      FT_TRACE6(( \"    axis %d coordinate %.5f:\\n\",\n-                  i, (double)blend->normalizedcoords[i] \/ 65536 ));\n+      FT_Fixed  ncv = blend->normalizedcoords[i];\n+\n+\n+      FT_TRACE6(( \"    axis %d coordinate %.5f:\\n\", i, (double)ncv \/ 65536 ));\n@@ -1931,1 +1909,1 @@\n-      if ( tuple_coords[i] == 0 )\n+      if ( tuple_coords[i] == ncv )\n@@ -1933,1 +1911,3 @@\n-        FT_TRACE6(( \"      tuple coordinate is zero, ignore\\n\" ));\n+        FT_TRACE6(( \"      tuple coordinate %.5f fits perfectly\\n\",\n+                    (double)tuple_coords[i] \/ 65536 ));\n+        \/* `apply' does not change *\/\n@@ -1937,8 +1917,1 @@\n-      if ( blend->normalizedcoords[i] == 0 )\n-      {\n-        FT_TRACE6(( \"      axis coordinate is zero, stop\\n\" ));\n-        apply = 0;\n-        break;\n-      }\n-\n-      if ( blend->normalizedcoords[i] == tuple_coords[i] )\n+      if ( tuple_coords[i] == 0 )\n@@ -1946,3 +1919,1 @@\n-        FT_TRACE6(( \"      tuple coordinate %.5f fits perfectly\\n\",\n-                    (double)tuple_coords[i] \/ 65536 ));\n-        \/* `apply' does not change *\/\n+        FT_TRACE6(( \"      tuple coordinate is zero, ignore\\n\" ));\n@@ -1956,2 +1927,8 @@\n-        if ( blend->normalizedcoords[i] < FT_MIN( 0, tuple_coords[i] ) ||\n-             blend->normalizedcoords[i] > FT_MAX( 0, tuple_coords[i] ) )\n+        if ( ( tuple_coords[i] > ncv && ncv > 0 ) ||\n+             ( tuple_coords[i] < ncv && ncv < 0 ) )\n+        {\n+          FT_TRACE6(( \"      tuple coordinate %.5f fits\\n\",\n+                      (double)tuple_coords[i] \/ 65536 ));\n+          apply = FT_MulDiv( apply, ncv, tuple_coords[i] );\n+        }\n+        else\n@@ -1964,6 +1941,0 @@\n-\n-        FT_TRACE6(( \"      tuple coordinate %.5f fits\\n\",\n-                    (double)tuple_coords[i] \/ 65536 ));\n-        apply = FT_MulDiv( apply,\n-                           blend->normalizedcoords[i],\n-                           tuple_coords[i] );\n@@ -1975,2 +1946,2 @@\n-        if ( blend->normalizedcoords[i] <= im_start_coords[i] ||\n-             blend->normalizedcoords[i] >= im_end_coords[i]   )\n+        if ( ncv <= im_start_coords[i] ||\n+             ncv >= im_end_coords[i]   )\n@@ -1989,1 +1960,1 @@\n-        if ( blend->normalizedcoords[i] < tuple_coords[i] )\n+        if ( ncv < tuple_coords[i] )\n@@ -1991,1 +1962,1 @@\n-                             blend->normalizedcoords[i] - im_start_coords[i],\n+                             ncv - im_start_coords[i],\n@@ -1993,1 +1964,1 @@\n-        else\n+        else \/* ncv > tuple_coords[i] *\/\n@@ -1995,1 +1966,1 @@\n-                             im_end_coords[i] - blend->normalizedcoords[i],\n+                             im_end_coords[i] - ncv,\n@@ -2144,1 +2115,2 @@\n-      v += delta << 2;\n+          \/* Convert delta in F2DOT14 to 16.16 before adding. *\/\n+          v += MUL_INT( delta, 4 );\n@@ -2146,3 +2118,3 @@\n-      \/* Clamp value range. *\/\n-      v = v >=  0x10000L ?  0x10000 : v;\n-      v = v <= -0x10000L ? -0x10000 : v;\n+          \/* Clamp value to range [-1, 1]. *\/\n+          v = v >=  0x10000L ?  0x10000 : v;\n+          v = v <= -0x10000L ? -0x10000 : v;\n@@ -2724,1 +2696,1 @@\n-      if ( FT_ALLOC( mmvar, ttface->blend->mmvar_len ) )\n+      if ( FT_DUP( mmvar, ttface->blend->mmvar, ttface->blend->mmvar_len ) )\n@@ -2726,1 +2698,0 @@\n-      FT_MEM_COPY( mmvar, ttface->blend->mmvar, ttface->blend->mmvar_len );\n@@ -3536,3 +3507,4 @@\n-    FT_Fixed*  tuple_coords    = NULL;\n-    FT_Fixed*  im_start_coords = NULL;\n-    FT_Fixed*  im_end_coords   = NULL;\n+    FT_Fixed*  peak_coords = NULL;\n+    FT_Fixed*  tuple_coords;\n+    FT_Fixed*  im_start_coords;\n+    FT_Fixed*  im_end_coords;\n@@ -3559,2 +3531,2 @@\n-      error = FT_Err_Ok;\n-      goto Exit;\n+\n+      return FT_Err_Ok;\n@@ -3567,2 +3539,2 @@\n-      error = FT_Err_Ok;\n-      goto Exit;\n+\n+      return FT_Err_Ok;\n@@ -3576,2 +3548,1 @@\n-      error = FT_Err_Ok;\n-      goto Exit;\n+      return FT_Err_Ok;\n@@ -3581,4 +3552,1 @@\n-    {\n-      error = FT_Err_Ok;\n-      goto Exit;\n-    }\n+      return FT_Err_Ok;\n@@ -3597,5 +3565,0 @@\n-    if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||\n-         FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||\n-         FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )\n-      goto FExit;\n-\n@@ -3624,3 +3587,2 @@\n-      sharedpoints = ft_var_readpackedpoints( stream,\n-                                              table_len,\n-                                              &spoint_count );\n+      sharedpoints = ft_var_readpackedpoints( stream, &spoint_count );\n+\n@@ -3637,2 +3599,6 @@\n-    if ( FT_NEW_ARRAY( cvt_deltas, face->cvt_size ) )\n-      goto FExit;\n+    if ( FT_QNEW_ARRAY( peak_coords, 3 * blend->num_axis ) ||\n+         FT_NEW_ARRAY( cvt_deltas, face->cvt_size )        )\n+      goto Exit;\n+\n+    im_start_coords = peak_coords + blend->num_axis;\n+    im_end_coords = im_start_coords + blend->num_axis;\n@@ -3655,1 +3621,2 @@\n-          tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n+          peak_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n+        tuple_coords = peak_coords;\n@@ -3657,1 +3624,4 @@\n-      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )\n+      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) < blend->tuplecount )\n+        tuple_coords = blend->tuplecoords +\n+            ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) * blend->num_axis;\n+      else\n@@ -3663,18 +3633,1 @@\n-        goto FExit;\n-      }\n-      else\n-      {\n-        if ( !blend->tuplecoords )\n-        {\n-          FT_TRACE2(( \"tt_face_vary_cvt:\"\n-                      \" no valid tuple coordinates available\\n\" ));\n-\n-          error = FT_THROW( Invalid_Table );\n-          goto FExit;\n-        }\n-\n-        FT_MEM_COPY(\n-          tuple_coords,\n-          blend->tuplecoords +\n-            ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) * blend->num_axis,\n-          blend->num_axis * sizeof ( FT_Fixed ) );\n+        goto Exit;\n@@ -3709,3 +3662,1 @@\n-        localpoints = ft_var_readpackedpoints( stream,\n-                                               table_len,\n-                                               &point_count );\n+        localpoints = ft_var_readpackedpoints( stream, &point_count );\n@@ -3722,1 +3673,0 @@\n-                                        table_len,\n@@ -3823,2 +3773,5 @@\n-  FExit:\n-    FT_FRAME_EXIT();\n+    \/* Iterate over all `FT_Size` objects and set `cvt_ready` to -1 *\/\n+    \/* to trigger rescaling of all CVT values.                      *\/\n+    FT_List_Iterate( &root->sizes_list,\n+                     tt_cvt_ready_iterator,\n+                     NULL );\n@@ -3829,3 +3782,0 @@\n-    FT_FREE( tuple_coords );\n-    FT_FREE( im_start_coords );\n-    FT_FREE( im_end_coords );\n@@ -3833,0 +3783,1 @@\n+    FT_FREE( peak_coords );\n@@ -3834,5 +3785,2 @@\n-    \/* iterate over all FT_Size objects and set `cvt_ready' to -1 *\/\n-    \/* to trigger rescaling of all CVT values                     *\/\n-    FT_List_Iterate( &root->sizes_list,\n-                     tt_cvt_ready_iterator,\n-                     NULL );\n+  FExit:\n+    FT_FRAME_EXIT();\n@@ -4102,3 +4050,4 @@\n-    FT_Fixed*  tuple_coords    = NULL;\n-    FT_Fixed*  im_start_coords = NULL;\n-    FT_Fixed*  im_end_coords   = NULL;\n+    FT_Fixed*  peak_coords = NULL;\n+    FT_Fixed*  tuple_coords;\n+    FT_Fixed*  im_start_coords;\n+    FT_Fixed*  im_end_coords;\n@@ -4139,5 +4088,0 @@\n-    if ( FT_NEW_ARRAY( points_org, n_points ) ||\n-         FT_NEW_ARRAY( points_out, n_points ) ||\n-         FT_NEW_ARRAY( has_delta, n_points )  )\n-      goto Fail1;\n-\n@@ -4149,1 +4093,1 @@\n-      goto Fail1;\n+      return error;\n@@ -4155,5 +4099,0 @@\n-    if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||\n-         FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||\n-         FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )\n-      goto Fail2;\n-\n@@ -4171,1 +4110,1 @@\n-      goto Fail2;\n+      goto FExit;\n@@ -4182,3 +4121,2 @@\n-      sharedpoints = ft_var_readpackedpoints( stream,\n-                                              blend->gvar_size,\n-                                              &spoint_count );\n+      sharedpoints = ft_var_readpackedpoints( stream, &spoint_count );\n+\n@@ -4195,3 +4133,10 @@\n-    if ( FT_NEW_ARRAY( point_deltas_x, n_points ) ||\n-         FT_NEW_ARRAY( point_deltas_y, n_points ) )\n-      goto Fail3;\n+    if ( FT_QNEW_ARRAY( peak_coords, 3 * blend->num_axis ) ||\n+         FT_NEW_ARRAY( point_deltas_x, 2 * n_points )      ||\n+         FT_QNEW_ARRAY( points_org, n_points )             ||\n+         FT_QNEW_ARRAY( points_out, n_points )             ||\n+         FT_QNEW_ARRAY( has_delta, n_points )              )\n+      goto Exit;\n+\n+    im_start_coords = peak_coords + blend->num_axis;\n+    im_end_coords   = im_start_coords + blend->num_axis;\n+    point_deltas_y  = point_deltas_x + n_points;\n@@ -4220,1 +4165,2 @@\n-          tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n+          peak_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n+        tuple_coords = peak_coords;\n@@ -4222,1 +4168,4 @@\n-      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )\n+      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) < blend->tuplecount )\n+        tuple_coords = blend->tuplecoords +\n+            ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) * blend->num_axis;\n+      else\n@@ -4228,1 +4177,1 @@\n-        goto Fail3;\n+        goto Exit;\n@@ -4230,6 +4179,0 @@\n-      else\n-        FT_MEM_COPY(\n-          tuple_coords,\n-          blend->tuplecoords +\n-            ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) * blend->num_axis,\n-          blend->num_axis * sizeof ( FT_Fixed ) );\n@@ -4263,3 +4206,1 @@\n-        localpoints = ft_var_readpackedpoints( stream,\n-                                               blend->gvar_size,\n-                                               &point_count );\n+        localpoints = ft_var_readpackedpoints( stream, &point_count );\n@@ -4275,1 +4216,0 @@\n-                                          blend->gvar_size,\n@@ -4279,1 +4219,0 @@\n-                                          blend->gvar_size,\n@@ -4463,5 +4402,1 @@\n-  Fail3:\n-    FT_FREE( point_deltas_x );\n-    FT_FREE( point_deltas_y );\n-\n-  Fail2:\n+  Exit:\n@@ -4470,7 +4405,0 @@\n-    FT_FREE( tuple_coords );\n-    FT_FREE( im_start_coords );\n-    FT_FREE( im_end_coords );\n-\n-    FT_FRAME_EXIT();\n-\n-  Fail1:\n@@ -4480,0 +4408,5 @@\n+    FT_FREE( peak_coords );\n+    FT_FREE( point_deltas_x );\n+\n+  FExit:\n+    FT_FRAME_EXIT();\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgxvar.c","additions":175,"deletions":242,"binary":false,"changes":417,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgxvar.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -5273,1 +5273,1 @@\n-    FT_Short         contour, bounds;\n+    FT_UShort        contour, bounds;\n@@ -5277,1 +5277,1 @@\n-    contour = (FT_Short)args[0];\n+    contour = (FT_UShort)args[0];\n@@ -5293,2 +5293,1 @@\n-      start = (FT_UShort)( exc->zp2.contours[contour - 1] + 1 -\n-                           exc->zp2.first_point );\n+      start = exc->zp2.contours[contour - 1] + 1 - exc->zp2.first_point;\n@@ -5300,2 +5299,1 @@\n-      limit = (FT_UShort)( exc->zp2.contours[contour] -\n-                           exc->zp2.first_point + 1 );\n+      limit = exc->zp2.contours[contour] + 1 - exc->zp2.first_point;\n@@ -5344,1 +5342,1 @@\n-      limit = (FT_UShort)exc->zp2.n_points;\n+      limit = exc->zp2.n_points;\n@@ -5346,1 +5344,1 @@\n-      limit = (FT_UShort)( exc->zp2.contours[exc->zp2.n_contours - 1] + 1 );\n+      limit = exc->zp2.contours[exc->zp2.n_contours - 1] + 1;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttinterp.c","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttinterp.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -118,1 +118,1 @@\n-                    FT_Short      maxContours,\n+                    FT_UShort     maxContours,\n@@ -155,9 +155,12 @@\n-    unsigned int  i;\n-\n-\n-    if ( ft_strlen( name ) < 8 || name[6] != '+' )\n-      return name;\n-\n-    for ( i = 0; i < 6; i++ )\n-      if ( !ft_isupper( name[i] ) )\n-        return name;\n+    if ( ft_isupper( name[0] ) &&\n+         ft_isupper( name[1] ) &&\n+         ft_isupper( name[2] ) &&\n+         ft_isupper( name[3] ) &&\n+         ft_isupper( name[4] ) &&\n+         ft_isupper( name[5] ) &&\n+              '+' == name[6]   &&\n+                     name[7]   )\n+    {\n+      FT_TRACE7(( \"name without randomization tag: %s\\n\", name + 7 ));\n+      return name + 7;\n+    }\n@@ -165,2 +168,1 @@\n-    FT_TRACE7(( \"name without randomization tag: %s\\n\", name + 7 ));\n-    return name + 7;\n+    return name;\n@@ -257,1 +259,2 @@\n-    FT_UInt    i;\n+    FT_Byte*   p;\n+    FT_Int     shift;\n@@ -263,0 +266,2 @@\n+    p = (FT_Byte*)stream->cursor;\n+\n@@ -264,1 +269,1 @@\n-      checksum += (FT_UInt32)FT_GET_ULONG();\n+      checksum += FT_NEXT_ULONG( p );\n@@ -266,2 +271,2 @@\n-    for ( i = 3; length > 0; length--, i-- )\n-      checksum += (FT_UInt32)FT_GET_BYTE() << ( i * 8 );\n+    for ( shift = 24; length > 0; length--, shift -=8 )\n+      checksum += (FT_UInt32)FT_NEXT_BYTE( p ) << shift;\n@@ -785,2 +790,1 @@\n-      if ( FT_HAS_MULTIPLE_MASTERS( ttface ) &&\n-           instance_index > 0                )\n+      if ( FT_HAS_MULTIPLE_MASTERS( ttface ) )\n@@ -993,3 +997,0 @@\n-    \/* unscaled CVT values are already stored in 26.6 format *\/\n-    FT_Fixed  scale = size->ttmetrics.scale >> 6;\n-\n@@ -1002,1 +1003,4 @@\n-      size->cvt[i] = FT_MulFix( face->cvt[i], scale );\n+      \/* Unscaled CVT values are already stored in 26.6 format.            *\/\n+      \/* Note that this scaling operation is very sensitive to rounding;   *\/\n+      \/* the integer division by 64 must be applied to the first argument. *\/\n+      size->cvt[i] = FT_MulFix( face->cvt[i] \/ 64, size->ttmetrics.scale );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttobjs.c","additions":27,"deletions":23,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -108,1 +108,1 @@\n-                    FT_Short      maxContours,\n+                    FT_UShort     maxContours,\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttobjs.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttpload.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttpload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1afm.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1afm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -315,1 +315,0 @@\n-        {\n@@ -317,2 +316,0 @@\n-          ((FT_Char *)value)[retval - 1] = (FT_Char)'\\0';\n-        }\n@@ -347,1 +344,0 @@\n-        {\n@@ -349,3 +345,1 @@\n-                     retval - 1 );\n-          ((FT_Char *)value)[retval - 1] = (FT_Char)'\\0';\n-        }\n+                     retval );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1driver.c","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1driver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1errors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1gload.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1gload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n@@ -754,0 +754,1 @@\n+        FT_FREE( dmap->blend_points );\n@@ -1046,1 +1047,2 @@\n-      if ( FT_QNEW_ARRAY( map->design_points, num_points * 2 ) )\n+      if ( FT_QNEW_ARRAY( map->design_points, num_points ) ||\n+           FT_QNEW_ARRAY( map->blend_points,  num_points ) )\n@@ -1048,1 +1050,0 @@\n-      map->blend_points = map->design_points + num_points;\n@@ -1879,1 +1880,1 @@\n-        if ( FT_QALLOC( temp, size ) )\n+        if ( FT_DUP( temp, base, size ) )\n@@ -1881,1 +1882,0 @@\n-        FT_MEM_COPY( temp, base, size );\n@@ -2093,1 +2093,1 @@\n-          if ( FT_QALLOC( temp, size ) )\n+          if ( FT_DUP( temp, base, size ) )\n@@ -2095,1 +2095,0 @@\n-          FT_MEM_COPY( temp, base, size );\n@@ -2287,1 +2286,1 @@\n-    { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }\n+    T1_FIELD_ZERO\n@@ -2395,1 +2394,1 @@\n-          for (;;)\n+          while ( keyword->len )\n@@ -2397,1 +2396,1 @@\n-            FT_Byte*  name;\n+            FT_Byte*  name = (FT_Byte*)keyword->ident;\n@@ -2400,7 +2399,2 @@\n-            name = (FT_Byte*)keyword->ident;\n-            if ( !name )\n-              break;\n-\n-            if ( cur[0] == name[0]                      &&\n-                 len == ft_strlen( (const char *)name ) &&\n-                 ft_memcmp( cur, name, len ) == 0       )\n+            if ( keyword->len == len              &&\n+                 ft_memcmp( cur, name, len ) == 0 )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1load.c","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1load.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1objs.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1objs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1parse.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1parse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2024 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1tokens.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+shopt -s nullglob\n+for f in *.c *.h *.cc *.hh;\n+do\n+# replace tabs with spaces\n+expand ${f} > ${f}.tmp;\n+mv ${f}.tmp $f;\n+\n+# fix line endings to LF\n+sed -e 's\/\\r$\/\/g' ${f} > ${f}.tmp;\n+mv ${f}.tmp $f;\n+\n+# remove trailing spaces\n+sed -e 's\/[ ]* $\/\/g' ${f} > ${f}.tmp;\n+mv ${f}.tmp $f;\n+done\n\\ No newline at end of file\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/ws.sh","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"}]}