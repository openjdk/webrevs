{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -281,4 +281,48 @@\n-     * @apiNote The path should generally, but is not required to, end with '\/'.\n-     * If the path does not end with '\/', eg such as with {@code \"\/foo\"} then\n-     * this would match requests with a path of {@code \"\/foobar\"} or\n-     * {@code \"\/foo\/bar\"}.\n+     * @apiNote\n+     * The path should generally, but is not required to, end with {@code \/}.\n+     * If the path does not end with {@code \/}, e.g., such as with {@code \/foo},\n+     * then this would match requests with a path of {@code \/foobar} or\n+     * {@code \/foo\/bar}.\n+     *\n+     * @implNote\n+     * The JDK built-in implementation performs <em>strict<\/em> path prefix\n+     * matching such that matching file names must have an exact match, not\n+     * partial. Consider following examples:\n+     *\n+     * <table>\n+     * <thead>\n+     *   <tr>\n+     *   <th rowspan=\"2\">Context path<\/th>\n+     *   <th colspan=\"4\">Request path<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>\/foo<\/th>\n+     *     <th>\/foo\/<\/th>\n+     *     <th>\/foo\/bar<\/th>\n+     *     <th>\/foobar<\/th>\n+     * <\/tr>\n+     * <\/thead>\n+     * <tbody>\n+     * <tr>\n+     *   <td>\/<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     * <\/tr>\n+     * <tr>\n+     *   <td>\/foo<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>N<\/td>\n+     * <\/tr>\n+     * <tr>\n+     *   <td>\/foo\/<\/td>\n+     *   <td>N<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>N<\/td>\n+     * <\/tr>\n+     * <\/tbody>\n+     * <\/table>\n@@ -311,4 +355,48 @@\n-     * @apiNote The path should generally, but is not required to, end with '\/'.\n-     * If the path does not end with '\/', eg such as with {@code \"\/foo\"} then\n-     * this would match requests with a path of {@code \"\/foobar\"} or\n-     * {@code \"\/foo\/bar\"}.\n+     * @apiNote\n+     * The path should generally, but is not required to, end with {@code \/}.\n+     * If the path does not end with {@code \/}, e.g., such as with {@code \/foo},\n+     * then this would match requests with a path of {@code \/foobar} or\n+     * {@code \/foo\/bar}.\n+     *\n+     * @implNote\n+     * The JDK built-in implementation performs <em>strict<\/em> path prefix\n+     * matching such that matching file names must have an exact match, not\n+     * partial. Consider following examples:\n+     *\n+     * <table>\n+     * <thead>\n+     *   <tr>\n+     *   <th rowspan=\"2\">Context path<\/th>\n+     *   <th colspan=\"4\">Request path<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>\/foo<\/th>\n+     *     <th>\/foo\/<\/th>\n+     *     <th>\/foo\/bar<\/th>\n+     *     <th>\/foobar<\/th>\n+     * <\/tr>\n+     * <\/thead>\n+     * <tbody>\n+     * <tr>\n+     *   <td>\/<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     * <\/tr>\n+     * <tr>\n+     *   <td>\/foo<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>N<\/td>\n+     * <\/tr>\n+     * <tr>\n+     *   <td>\/foo\/<\/td>\n+     *   <td>N<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>Y<\/td>\n+     *   <td>N<\/td>\n+     * <\/tr>\n+     * <\/tbody>\n+     * <\/table>\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpServer.java","additions":97,"deletions":9,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.function.BiPredicate;\n@@ -35,0 +36,4 @@\n+        assert ctx != null;\n+        \/\/ `findContext(String protocol, String path, ContextPathMatcher matcher)`\n+        \/\/ expects the protocol to be lower-cased using ROOT locale, hence:\n+        assert ctx.getProtocol().equals(ctx.getProtocol().toLowerCase(Locale.ROOT));\n@@ -43,1 +48,1 @@\n-        return findContext(ctx.getProtocol(), ctx.getPath(), true) != null;\n+        return findContext(ctx.getProtocol(), ctx.getPath(), ContextPathMatcher.EXACT) != null;\n@@ -50,2 +55,5 @@\n-   \/* initially contexts are located only by protocol:path.\n-    * Context with longest prefix matches (currently case-sensitive)\n+   \/**\n+    * {@return the context with the longest case-sensitive prefix match}\n+    *\n+    * @param protocol the request protocol\n+    * @param path the request path\n@@ -53,2 +61,2 @@\n-    synchronized HttpContextImpl findContext(String protocol, String path) {\n-        return findContext(protocol, path, false);\n+    HttpContextImpl findContext(String protocol, String path) {\n+        return findContext(protocol, path, ContextPathMatcher.PREFIX);\n@@ -57,1 +65,1 @@\n-    synchronized HttpContextImpl findContext(String protocol, String path, boolean exact) {\n+    private synchronized HttpContextImpl findContext(String protocol, String path, ContextPathMatcher matcher) {\n@@ -66,3 +74,1 @@\n-            if (exact && !cpath.equals(path)) {\n-                continue;\n-            } else if (!exact && !path.startsWith(cpath)) {\n+            if (!matcher.test(cpath, path)) {\n@@ -79,0 +85,89 @@\n+    private enum ContextPathMatcher implements BiPredicate<String, String> {\n+\n+        \/**\n+         * Tests if both the request path and the context path are identical.\n+         *\/\n+        EXACT(String::equals),\n+\n+        \/**\n+         * Tests path prefix matches such that file names must have an exact\n+         * match. Consider the following examples:\n+         * <table>\n+         * <thead>\n+         *   <tr>\n+         *   <th rowspan=\"2\">Context path<\/th>\n+         *   <th colspan=\"4\">Request path<\/th>\n+         * <\/tr>\n+         * <tr>\n+         *     <th>\/foo<\/th>\n+         *     <th>\/foo\/<\/th>\n+         *     <th>\/foo\/bar<\/th>\n+         *     <th>\/foobar<\/th>\n+         * <\/tr>\n+         * <\/thead>\n+         * <tbody>\n+         * <tr>\n+         *   <td>\/<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         * <\/tr>\n+         * <tr>\n+         *   <td>\/foo<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>N<\/td>\n+         * <\/tr>\n+         * <tr>\n+         *   <td>\/foo\/<\/td>\n+         *   <td>N<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>N<\/td>\n+         * <\/tr>\n+         * <\/tbody>\n+         * <\/table>\n+         *\/\n+        PREFIX((contextPath, requestPath) -> {\n+\n+            \/\/ Fast-path for `\/`\n+            if (\"\/\".equals(contextPath)) {\n+                return true;\n+            }\n+\n+            \/\/ Does the request path prefix match?\n+            if (requestPath.startsWith(contextPath)) {\n+\n+                \/\/ Is it an exact match?\n+                int contextPathLength = contextPath.length();\n+                if (requestPath.length() == contextPathLength) {\n+                    return true;\n+                }\n+\n+                \/\/ Is it a path-prefix match?\n+                if (contextPath.charAt(contextPathLength - 1) == '\/'\n+                        || requestPath.charAt(contextPathLength) == '\/') {\n+                    return true;\n+                }\n+\n+            }\n+\n+            return false;\n+\n+        });\n+\n+        private final BiPredicate<String, String> predicate;\n+\n+        ContextPathMatcher(BiPredicate<String, String> predicate) {\n+            this.predicate = predicate;\n+        }\n+\n+        @Override\n+        public boolean test(String contextPath, String requestPath) {\n+            return predicate.test(contextPath, requestPath);\n+        }\n+\n+    }\n+\n@@ -82,1 +177,1 @@\n-        HttpContextImpl ctx = findContext(protocol, path, true);\n+        HttpContextImpl ctx = findContext(protocol, path, ContextPathMatcher.EXACT);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ContextList.java","additions":106,"deletions":11,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.Map;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+\n+import org.junit.jupiter.api.AfterAll;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8272758\n+ * @summary Verifies that context paths are correctly mapped to request paths\n+ * @build EchoHandler\n+ * @run junit ${test.main.class}\n+ *\/\n+\n+class ContextPathMappingTest {\n+\n+    private static final HttpClient CLIENT =\n+            HttpClient.newBuilder().proxy(NO_PROXY).build();\n+\n+    @AfterAll\n+    static void stopClient() {\n+        CLIENT.shutdownNow();\n+    }\n+\n+    @Test\n+    void testContextPathAtRoot() throws Exception {\n+        try (var infra = new Infra(\"\/\")) {\n+            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\", \"\/foobar\");\n+        }\n+    }\n+\n+    @Test\n+    void testContextPathAtSubDir() throws Exception {\n+        try (var infra = new Infra(\"\/foo\")) {\n+            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\");\n+            infra.expect(404, \"\/foobar\");\n+        }\n+    }\n+\n+    @Test\n+    void testContextPathAtSubDirWithTrailingSlash() throws Exception {\n+        try (var infra = new Infra(\"\/foo\/\")) {\n+            infra.expect(200, \"\/foo\/\", \"\/foo\/bar\");\n+            infra.expect(404, \"\/foo\", \"\/foobar\");\n+        }\n+    }\n+\n+    private static final class Infra implements AutoCloseable {\n+\n+        private static final InetSocketAddress LO_SA_0 =\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+        private static final HttpHandler HANDLER = new EchoHandler();\n+\n+        private final HttpServer server;\n+\n+        private final String contextPath;\n+\n+        private Infra(String contextPath) throws IOException {\n+            this.server = HttpServer.create(LO_SA_0, 10);\n+            server.createContext(contextPath, HANDLER);\n+            server.start();\n+            this.contextPath = contextPath;\n+        }\n+\n+        private void expect(int statusCode, String... requestPaths) throws Exception {\n+            for (String requestPath : requestPaths) {\n+                var requestURI = URI.create(\"http:\/\/%s:%s%s\".formatted(\n+                        server.getAddress().getHostString(),\n+                        server.getAddress().getPort(),\n+                        requestPath));\n+                var request = HttpRequest.newBuilder(requestURI).build();\n+                var response = CLIENT.send(request, HttpResponse.BodyHandlers.discarding());\n+                assertEquals(\n+                        statusCode, response.statusCode(),\n+                        \"unexpected status code \" + Map.of(\n+                                \"contextPath\", contextPath,\n+                                \"requestPath\", requestPath));\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            server.stop(0);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ContextPathMappingTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-                server.getAddress().getPort(), PATH + \"x\",\n+                server.getAddress().getPort(), PATH + \"\/x\",\n@@ -213,1 +213,1 @@\n-        URI proxiedURI = new URI(\"http:\/\/some.host.that.does.not.exist:4242\" + PATH + \"x\");\n+        URI proxiedURI = new URI(\"http:\/\/some.host.that.does.not.exist:4242\" + PATH + \"\/x\");\n","filename":"test\/jdk\/java\/net\/httpclient\/PlainProxyConnectionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}