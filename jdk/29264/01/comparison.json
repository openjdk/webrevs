{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n- * <table class=\"striped\"><caption style=\"display:none\">description<\/caption>\n+ * <table class=\"striped\" style=\"text-align:left\"><caption style=\"display:none\">description<\/caption>\n@@ -281,4 +281,14 @@\n-     * @apiNote The path should generally, but is not required to, end with '\/'.\n-     * If the path does not end with '\/', eg such as with {@code \"\/foo\"} then\n-     * this would match requests with a path of {@code \"\/foobar\"} or\n-     * {@code \"\/foo\/bar\"}.\n+     * @apiNote\n+     * The path should generally, but is not required to, end with {@code \/}.\n+     * If the path does not end with {@code \/}, e.g., such as with {@code \/foo},\n+     * then some implementations may use <em>string prefix matching<\/em> where\n+     * this context path matches request paths {@code \/foo},\n+     * {@code \/foo\/bar}, or {@code \/foobar}. Others may use <em>path prefix\n+     * matching<\/em> where {@code \/foo} matches only request paths\n+     * {@code \/foo} and {@code \/foo\/bar}, but not {@code \/foobar}.\n+     *\n+     * @implNote\n+     * By default, the JDK built-in implementation uses path prefix matching.\n+     * String prefix matching can be enabled using the\n+     * {@link jdk.httpserver\/##sun.net.httpserver.pathMatcher sun.net.httpserver.pathMatcher}\n+     * system property.\n@@ -292,0 +302,2 @@\n+     *\n+     * @see jdk.httpserver\/##sun.net.httpserver.pathMatcher sun.net.httpserver.pathMatcher\n@@ -311,4 +323,14 @@\n-     * @apiNote The path should generally, but is not required to, end with '\/'.\n-     * If the path does not end with '\/', eg such as with {@code \"\/foo\"} then\n-     * this would match requests with a path of {@code \"\/foobar\"} or\n-     * {@code \"\/foo\/bar\"}.\n+     * @apiNote\n+     * The path should generally, but is not required to, end with {@code \/}.\n+     * If the path does not end with {@code \/}, e.g., such as with {@code \/foo},\n+     * then some implementations may use <em>string prefix matching<\/em> where\n+     * this context path matches request paths {@code \/foo},\n+     * {@code \/foo\/bar}, or {@code \/foobar}. Others may use <em>path prefix\n+     * matching<\/em> where {@code \/foo} matches request paths\n+     * {@code \/foo} and {@code \/foo\/bar}, but not {@code \/foobar}.\n+     *\n+     * @implNote\n+     * By default, the JDK built-in implementation uses path prefix matching.\n+     * String prefix matching can be enabled using the\n+     * {@link jdk.httpserver\/##sun.net.httpserver.pathMatcher sun.net.httpserver.pathMatcher}\n+     * system property.\n@@ -321,0 +343,2 @@\n+     *\n+     * @see jdk.httpserver\/##sun.net.httpserver.pathMatcher sun.net.httpserver.pathMatcher\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpServer.java","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -104,1 +104,26 @@\n- * <\/li><\/ul>\n+ * <\/li>\n+ * <li>\n+ * <p><b>{@systemProperty sun.net.httpserver.pathMatcher}<\/b> (default:\n+ * {@code pathPrefix})<br\/>\n+ *\n+ * The path matching scheme used to route requests to context handlers.\n+ * Following list of values are allowed by this property.<\/p>\n+ *\n+ * <blockquote>\n+ * <dl>\n+ * <dt>{@code pathPrefix} (default)<\/dt>\n+ * <dd>The request path must begin with the context path and all matching path\n+ * segments must be identical. For instance, the context path {@code \/foo}\n+ * would match request paths {@code \/foo}, {@code \/foo\/}, and {@code \/foo\/bar},\n+ * but not {@code \/foobar}.<\/dd>\n+ * <dt>{@code stringPrefix}<\/dt>\n+ * <dd>Request path string must begin with the context path string. For\n+ * instance, the context path {@code \/foo} would match request paths\n+ * {@code \/foo}, {@code \/foo\/}, {@code \/foo\/bar}, and {@code \/foobar}.\n+ * <\/dd>\n+ * <\/dl>\n+ * <\/blockquote>\n+ *\n+ * <p>In case of a blank or invalid value, the default will be used.<\/p>\n+ * <\/li>\n+ * <\/ul>\n","filename":"src\/jdk.httpserver\/share\/classes\/module-info.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.function.BiPredicate;\n@@ -32,0 +33,2 @@\n+    private static final System.Logger LOGGER = System.getLogger(ContextList.class.getName());\n+\n@@ -35,0 +38,4 @@\n+        assert ctx != null;\n+        \/\/ `findContext(String protocol, String path, ContextPathMatcher matcher)`\n+        \/\/ expects the protocol to be lower-cased using ROOT locale, hence:\n+        assert ctx.getProtocol().equals(ctx.getProtocol().toLowerCase(Locale.ROOT));\n@@ -43,1 +50,1 @@\n-        return findContext(ctx.getProtocol(), ctx.getPath(), true) != null;\n+        return findContext(ctx.getProtocol(), ctx.getPath(), ContextPathMatcher.EXACT) != null;\n@@ -50,2 +57,5 @@\n-   \/* initially contexts are located only by protocol:path.\n-    * Context with longest prefix matches (currently case-sensitive)\n+   \/**\n+    * {@return the context with the longest case-sensitive prefix match}\n+    *\n+    * @param protocol the request protocol\n+    * @param path the request path\n@@ -53,2 +63,3 @@\n-    synchronized HttpContextImpl findContext(String protocol, String path) {\n-        return findContext(protocol, path, false);\n+    HttpContextImpl findContext(String protocol, String path) {\n+        var matcher = ContextPathMatcher.ofConfiguredPrefixPathMatcher();\n+        return findContext(protocol, path, matcher);\n@@ -57,1 +68,1 @@\n-    synchronized HttpContextImpl findContext(String protocol, String path, boolean exact) {\n+    private synchronized HttpContextImpl findContext(String protocol, String path, ContextPathMatcher matcher) {\n@@ -66,3 +77,1 @@\n-            if (exact && !cpath.equals(path)) {\n-                continue;\n-            } else if (!exact && !path.startsWith(cpath)) {\n+            if (!matcher.test(cpath, path)) {\n@@ -79,0 +88,155 @@\n+    private enum ContextPathMatcher implements BiPredicate<String, String> {\n+\n+        \/**\n+         * Tests if both the request path and the context path are identical.\n+         *\/\n+        EXACT(String::equals),\n+\n+        \/**\n+         * Tests <em>string prefix matches<\/em> where the request path string\n+         * starts with the context path string.\n+         *\n+         * <h3>Examples<\/h3>\n+         *\n+         * <table>\n+         * <thead>\n+         * <tr>\n+         *   <th rowspan=\"2\">Context path<\/th>\n+         *   <th colspan=\"4\">Request path<\/th>\n+         * <\/tr>\n+         * <tr>\n+         *     <th>\/foo<\/th>\n+         *     <th>\/foo\/<\/th>\n+         *     <th>\/foo\/bar<\/th>\n+         *     <th>\/foobar<\/th>\n+         * <\/tr>\n+         * <\/thead>\n+         * <tbody>\n+         * <tr>\n+         *   <td>\/<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         * <\/tr>\n+         * <tr>\n+         *   <td>\/foo<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         * <\/tr>\n+         * <tr>\n+         *   <td>\/foo\/<\/td>\n+         *   <td>N<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>N<\/td>\n+         * <\/tr>\n+         * <\/tbody>\n+         * <\/table>\n+         *\/\n+        STRING_PREFIX((contextPath, requestPath) -> requestPath.startsWith(contextPath)),\n+\n+        \/**\n+         * Tests <em>path prefix matches<\/em> where path segments must have an\n+         * exact match.\n+         *\n+         * <h3>Examples<\/h3>\n+         *\n+         * <table>\n+         * <thead>\n+         * <tr>\n+         *   <th rowspan=\"2\">Context path<\/th>\n+         *   <th colspan=\"4\">Request path<\/th>\n+         * <\/tr>\n+         * <tr>\n+         *     <th>\/foo<\/th>\n+         *     <th>\/foo\/<\/th>\n+         *     <th>\/foo\/bar<\/th>\n+         *     <th>\/foobar<\/th>\n+         * <\/tr>\n+         * <\/thead>\n+         * <tbody>\n+         * <tr>\n+         *   <td>\/<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         * <\/tr>\n+         * <tr>\n+         *   <td>\/foo<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>N<\/td>\n+         * <\/tr>\n+         * <tr>\n+         *   <td>\/foo\/<\/td>\n+         *   <td>N<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>N<\/td>\n+         * <\/tr>\n+         * <\/tbody>\n+         * <\/table>\n+         *\/\n+        PATH_PREFIX((contextPath, requestPath) -> {\n+\n+            \/\/ Fast-path for `\/`\n+            if (\"\/\".equals(contextPath)) {\n+                return true;\n+            }\n+\n+            \/\/ Does the request path prefix match?\n+            if (requestPath.startsWith(contextPath)) {\n+\n+                \/\/ Is it an exact match?\n+                int contextPathLength = contextPath.length();\n+                if (requestPath.length() == contextPathLength) {\n+                    return true;\n+                }\n+\n+                \/\/ Is it a path-prefix match?\n+                if (contextPath.charAt(contextPathLength - 1) == '\/'\n+                        || requestPath.charAt(contextPathLength) == '\/') {\n+                    return true;\n+                }\n+\n+            }\n+\n+            return false;\n+\n+        });\n+\n+        private final BiPredicate<String, String> predicate;\n+\n+        ContextPathMatcher(BiPredicate<String, String> predicate) {\n+            this.predicate = predicate;\n+        }\n+\n+        @Override\n+        public boolean test(String contextPath, String requestPath) {\n+            return predicate.test(contextPath, requestPath);\n+        }\n+\n+        private static ContextPathMatcher ofConfiguredPrefixPathMatcher() {\n+            var propertyName = \"sun.net.httpserver.pathMatcher\";\n+            var propertyValueDefault = \"pathPrefix\";\n+            var propertyValue = System.getProperty(propertyName, propertyValueDefault);\n+            return switch (propertyValue) {\n+                case \"pathPrefix\" -> ContextPathMatcher.PATH_PREFIX;\n+                case \"stringPrefix\" -> ContextPathMatcher.STRING_PREFIX;\n+                default -> {\n+                    LOGGER.log(\n+                            System.Logger.Level.WARNING,\n+                            \"System property \\\"{}\\\" contains an invalid value: \\\"{}\\\". Falling back to the default: \\\"{}\\\"\",\n+                            propertyName, propertyValue, propertyValueDefault);\n+                    yield ContextPathMatcher.PATH_PREFIX;\n+                }\n+            };\n+        }\n+\n+    }\n+\n@@ -82,1 +246,1 @@\n-        HttpContextImpl ctx = findContext(protocol, path, true);\n+        HttpContextImpl ctx = findContext(protocol, path, ContextPathMatcher.EXACT);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ContextList.java","additions":175,"deletions":11,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.Map;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+\n+import org.junit.jupiter.api.AfterAll;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+\/*\n+ * @test id=default\n+ * @bug 8272758\n+ * @summary Verifies path prefix matching using defaults\n+ * @build EchoHandler\n+ * @run junit ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=withProperty\n+ * @bug 8272758\n+ * @summary Verifies path prefix matching by providing a system property\n+ * @build EchoHandler\n+ * @run junit\/othervm\n+ *      -Dsun.net.httpserver.pathMatcher=pathPrefix\n+ *      ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=withInvalidProperty\n+ * @bug 8272758\n+ * @summary Verifies path prefix matching by providing a system property\n+ *          containing an invalid value, and observing it fall back to the\n+ *          default\n+ * @build EchoHandler\n+ * @run junit\/othervm\n+ *      -Dsun.net.httpserver.pathMatcher=noSuchMatcher\n+ *      ${test.main.class}\n+ *\/\n+\n+public class ContextPathMatcherPathPrefixTest {\n+\n+    private static final HttpClient CLIENT =\n+            HttpClient.newBuilder().proxy(NO_PROXY).build();\n+\n+    @AfterAll\n+    static void stopClient() {\n+        CLIENT.shutdownNow();\n+    }\n+\n+    @Test\n+    void testContextPathAtRoot() throws Exception {\n+        try (var infra = new Infra(\"\/\")) {\n+            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\", \"\/foobar\");\n+        }\n+    }\n+\n+    @Test\n+    void testContextPathAtSubDir() throws Exception {\n+        try (var infra = new Infra(\"\/foo\")) {\n+            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\");\n+            infra.expect(404, \"\/foobar\");\n+        }\n+    }\n+\n+    @Test\n+    void testContextPathAtSubDirWithTrailingSlash() throws Exception {\n+        try (var infra = new Infra(\"\/foo\/\")) {\n+            infra.expect(200, \"\/foo\/\", \"\/foo\/bar\");\n+            infra.expect(404, \"\/foo\", \"\/foobar\");\n+        }\n+    }\n+\n+    public static final class Infra implements AutoCloseable {\n+\n+        private static final InetSocketAddress LO_SA_0 =\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+        private static final HttpHandler HANDLER = new EchoHandler();\n+\n+        private final HttpServer server;\n+\n+        private final String contextPath;\n+\n+        public Infra(String contextPath) throws IOException {\n+            this.server = HttpServer.create(LO_SA_0, 10);\n+            server.createContext(contextPath, HANDLER);\n+            server.start();\n+            this.contextPath = contextPath;\n+        }\n+\n+        public void expect(int statusCode, String... requestPaths) throws Exception {\n+            for (String requestPath : requestPaths) {\n+                var requestURI = URI.create(\"http:\/\/%s:%s%s\".formatted(\n+                        server.getAddress().getHostString(),\n+                        server.getAddress().getPort(),\n+                        requestPath));\n+                var request = HttpRequest.newBuilder(requestURI).build();\n+                var response = CLIENT.send(request, HttpResponse.BodyHandlers.discarding());\n+                assertEquals(\n+                        statusCode, response.statusCode(),\n+                        \"unexpected status code \" + Map.of(\n+                                \"contextPath\", contextPath,\n+                                \"requestPath\", requestPath));\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            server.stop(0);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ContextPathMatcherPathPrefixTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.net.http.HttpClient;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+\n+\/*\n+ * @test\n+ * @bug 8272758\n+ * @summary Verifies string prefix matching configured using a system property\n+ * @build ContextPathMatcherPathPrefixTest\n+ *        EchoHandler\n+ * @run junit\/othervm\n+ *      -Dsun.net.httpserver.pathMatcher=stringPrefix\n+ *      ${test.main.class}\n+ *\/\n+\n+class ContextPathMatcherStringPrefixTest {\n+\n+    private static final HttpClient CLIENT =\n+            HttpClient.newBuilder().proxy(NO_PROXY).build();\n+\n+    @AfterAll\n+    static void stopClient() {\n+        CLIENT.shutdownNow();\n+    }\n+\n+    @Test\n+    void testContextPathAtRoot() throws Exception {\n+        try (var infra = new ContextPathMatcherPathPrefixTest.Infra(\"\/\")) {\n+            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\", \"\/foobar\");\n+        }\n+    }\n+\n+    @Test\n+    void testContextPathAtSubDir() throws Exception {\n+        try (var infra = new ContextPathMatcherPathPrefixTest.Infra(\"\/foo\")) {\n+            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\", \"\/foobar\");\n+        }\n+    }\n+\n+    @Test\n+    void testContextPathAtSubDirWithTrailingSlash() throws Exception {\n+        try (var infra = new ContextPathMatcherPathPrefixTest.Infra(\"\/foo\/\")) {\n+            infra.expect(200, \"\/foo\/\", \"\/foo\/bar\");\n+            infra.expect(404, \"\/foo\", \"\/foobar\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ContextPathMatcherStringPrefixTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-                server.getAddress().getPort(), PATH + \"x\",\n+                server.getAddress().getPort(), PATH + \"\/x\",\n@@ -213,1 +213,1 @@\n-        URI proxiedURI = new URI(\"http:\/\/some.host.that.does.not.exist:4242\" + PATH + \"x\");\n+        URI proxiedURI = new URI(\"http:\/\/some.host.that.does.not.exist:4242\" + PATH + \"\/x\");\n","filename":"test\/jdk\/java\/net\/httpclient\/PlainProxyConnectionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}