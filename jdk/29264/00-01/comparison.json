{"files":[{"patch":"@@ -78,1 +78,1 @@\n- * <table class=\"striped\"><caption style=\"display:none\">description<\/caption>\n+ * <table class=\"striped\" style=\"text-align:left\"><caption style=\"display:none\">description<\/caption>\n@@ -284,2 +284,5 @@\n-     * then this would match requests with a path of {@code \/foobar} or\n-     * {@code \/foo\/bar}.\n+     * then some implementations may use <em>string prefix matching<\/em> where\n+     * this context path matches request paths {@code \/foo},\n+     * {@code \/foo\/bar}, or {@code \/foobar}. Others may use <em>path prefix\n+     * matching<\/em> where {@code \/foo} matches only request paths\n+     * {@code \/foo} and {@code \/foo\/bar}, but not {@code \/foobar}.\n@@ -288,41 +291,4 @@\n-     * The JDK built-in implementation performs <em>strict<\/em> path prefix\n-     * matching such that matching file names must have an exact match, not\n-     * partial. Consider following examples:\n-     *\n-     * <table>\n-     * <thead>\n-     *   <tr>\n-     *   <th rowspan=\"2\">Context path<\/th>\n-     *   <th colspan=\"4\">Request path<\/th>\n-     * <\/tr>\n-     * <tr>\n-     *     <th>\/foo<\/th>\n-     *     <th>\/foo\/<\/th>\n-     *     <th>\/foo\/bar<\/th>\n-     *     <th>\/foobar<\/th>\n-     * <\/tr>\n-     * <\/thead>\n-     * <tbody>\n-     * <tr>\n-     *   <td>\/<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     * <\/tr>\n-     * <tr>\n-     *   <td>\/foo<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>N<\/td>\n-     * <\/tr>\n-     * <tr>\n-     *   <td>\/foo\/<\/td>\n-     *   <td>N<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>N<\/td>\n-     * <\/tr>\n-     * <\/tbody>\n-     * <\/table>\n+     * By default, the JDK built-in implementation uses path prefix matching.\n+     * String prefix matching can be enabled using the\n+     * {@link jdk.httpserver\/##sun.net.httpserver.pathMatcher sun.net.httpserver.pathMatcher}\n+     * system property.\n@@ -336,0 +302,2 @@\n+     *\n+     * @see jdk.httpserver\/##sun.net.httpserver.pathMatcher sun.net.httpserver.pathMatcher\n@@ -358,2 +326,5 @@\n-     * then this would match requests with a path of {@code \/foobar} or\n-     * {@code \/foo\/bar}.\n+     * then some implementations may use <em>string prefix matching<\/em> where\n+     * this context path matches request paths {@code \/foo},\n+     * {@code \/foo\/bar}, or {@code \/foobar}. Others may use <em>path prefix\n+     * matching<\/em> where {@code \/foo} matches request paths\n+     * {@code \/foo} and {@code \/foo\/bar}, but not {@code \/foobar}.\n@@ -362,41 +333,4 @@\n-     * The JDK built-in implementation performs <em>strict<\/em> path prefix\n-     * matching such that matching file names must have an exact match, not\n-     * partial. Consider following examples:\n-     *\n-     * <table>\n-     * <thead>\n-     *   <tr>\n-     *   <th rowspan=\"2\">Context path<\/th>\n-     *   <th colspan=\"4\">Request path<\/th>\n-     * <\/tr>\n-     * <tr>\n-     *     <th>\/foo<\/th>\n-     *     <th>\/foo\/<\/th>\n-     *     <th>\/foo\/bar<\/th>\n-     *     <th>\/foobar<\/th>\n-     * <\/tr>\n-     * <\/thead>\n-     * <tbody>\n-     * <tr>\n-     *   <td>\/<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     * <\/tr>\n-     * <tr>\n-     *   <td>\/foo<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>N<\/td>\n-     * <\/tr>\n-     * <tr>\n-     *   <td>\/foo\/<\/td>\n-     *   <td>N<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>Y<\/td>\n-     *   <td>N<\/td>\n-     * <\/tr>\n-     * <\/tbody>\n-     * <\/table>\n+     * By default, the JDK built-in implementation uses path prefix matching.\n+     * String prefix matching can be enabled using the\n+     * {@link jdk.httpserver\/##sun.net.httpserver.pathMatcher sun.net.httpserver.pathMatcher}\n+     * system property.\n@@ -409,0 +343,2 @@\n+     *\n+     * @see jdk.httpserver\/##sun.net.httpserver.pathMatcher sun.net.httpserver.pathMatcher\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpServer.java","additions":23,"deletions":87,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -104,1 +104,26 @@\n- * <\/li><\/ul>\n+ * <\/li>\n+ * <li>\n+ * <p><b>{@systemProperty sun.net.httpserver.pathMatcher}<\/b> (default:\n+ * {@code pathPrefix})<br\/>\n+ *\n+ * The path matching scheme used to route requests to context handlers.\n+ * Following list of values are allowed by this property.<\/p>\n+ *\n+ * <blockquote>\n+ * <dl>\n+ * <dt>{@code pathPrefix} (default)<\/dt>\n+ * <dd>The request path must begin with the context path and all matching path\n+ * segments must be identical. For instance, the context path {@code \/foo}\n+ * would match request paths {@code \/foo}, {@code \/foo\/}, and {@code \/foo\/bar},\n+ * but not {@code \/foobar}.<\/dd>\n+ * <dt>{@code stringPrefix}<\/dt>\n+ * <dd>Request path string must begin with the context path string. For\n+ * instance, the context path {@code \/foo} would match request paths\n+ * {@code \/foo}, {@code \/foo\/}, {@code \/foo\/bar}, and {@code \/foobar}.\n+ * <\/dd>\n+ * <\/dl>\n+ * <\/blockquote>\n+ *\n+ * <p>In case of a blank or invalid value, the default will be used.<\/p>\n+ * <\/li>\n+ * <\/ul>\n","filename":"src\/jdk.httpserver\/share\/classes\/module-info.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+    private static final System.Logger LOGGER = System.getLogger(ContextList.class.getName());\n+\n@@ -62,1 +64,2 @@\n-        return findContext(protocol, path, ContextPathMatcher.PREFIX);\n+        var matcher = ContextPathMatcher.ofConfiguredPrefixPathMatcher();\n+        return findContext(protocol, path, matcher);\n@@ -93,2 +96,5 @@\n-         * Tests path prefix matches such that file names must have an exact\n-         * match. Consider the following examples:\n+         * Tests <em>string prefix matches<\/em> where the request path string\n+         * starts with the context path string.\n+         *\n+         * <h3>Examples<\/h3>\n+         *\n@@ -97,1 +103,47 @@\n-         *   <tr>\n+         * <tr>\n+         *   <th rowspan=\"2\">Context path<\/th>\n+         *   <th colspan=\"4\">Request path<\/th>\n+         * <\/tr>\n+         * <tr>\n+         *     <th>\/foo<\/th>\n+         *     <th>\/foo\/<\/th>\n+         *     <th>\/foo\/bar<\/th>\n+         *     <th>\/foobar<\/th>\n+         * <\/tr>\n+         * <\/thead>\n+         * <tbody>\n+         * <tr>\n+         *   <td>\/<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         * <\/tr>\n+         * <tr>\n+         *   <td>\/foo<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         * <\/tr>\n+         * <tr>\n+         *   <td>\/foo\/<\/td>\n+         *   <td>N<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>Y<\/td>\n+         *   <td>N<\/td>\n+         * <\/tr>\n+         * <\/tbody>\n+         * <\/table>\n+         *\/\n+        STRING_PREFIX((contextPath, requestPath) -> requestPath.startsWith(contextPath)),\n+\n+        \/**\n+         * Tests <em>path prefix matches<\/em> where path segments must have an\n+         * exact match.\n+         *\n+         * <h3>Examples<\/h3>\n+         *\n+         * <table>\n+         * <thead>\n+         * <tr>\n@@ -133,1 +185,1 @@\n-        PREFIX((contextPath, requestPath) -> {\n+        PATH_PREFIX((contextPath, requestPath) -> {\n@@ -172,0 +224,17 @@\n+        private static ContextPathMatcher ofConfiguredPrefixPathMatcher() {\n+            var propertyName = \"sun.net.httpserver.pathMatcher\";\n+            var propertyValueDefault = \"pathPrefix\";\n+            var propertyValue = System.getProperty(propertyName, propertyValueDefault);\n+            return switch (propertyValue) {\n+                case \"pathPrefix\" -> ContextPathMatcher.PATH_PREFIX;\n+                case \"stringPrefix\" -> ContextPathMatcher.STRING_PREFIX;\n+                default -> {\n+                    LOGGER.log(\n+                            System.Logger.Level.WARNING,\n+                            \"System property \\\"{}\\\" contains an invalid value: \\\"{}\\\". Falling back to the default: \\\"{}\\\"\",\n+                            propertyName, propertyValue, propertyValueDefault);\n+                    yield ContextPathMatcher.PATH_PREFIX;\n+                }\n+            };\n+        }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ContextList.java","additions":74,"deletions":5,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-import java.io.IOException;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.URI;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpResponse;\n-import java.util.Map;\n-\n-import static java.net.http.HttpClient.Builder.NO_PROXY;\n-\n-import org.junit.jupiter.api.AfterAll;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-import org.junit.jupiter.api.Test;\n-\n-\/*\n- * @test\n- * @bug 8272758\n- * @summary Verifies that context paths are correctly mapped to request paths\n- * @build EchoHandler\n- * @run junit ${test.main.class}\n- *\/\n-\n-class ContextPathMappingTest {\n-\n-    private static final HttpClient CLIENT =\n-            HttpClient.newBuilder().proxy(NO_PROXY).build();\n-\n-    @AfterAll\n-    static void stopClient() {\n-        CLIENT.shutdownNow();\n-    }\n-\n-    @Test\n-    void testContextPathAtRoot() throws Exception {\n-        try (var infra = new Infra(\"\/\")) {\n-            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\", \"\/foobar\");\n-        }\n-    }\n-\n-    @Test\n-    void testContextPathAtSubDir() throws Exception {\n-        try (var infra = new Infra(\"\/foo\")) {\n-            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\");\n-            infra.expect(404, \"\/foobar\");\n-        }\n-    }\n-\n-    @Test\n-    void testContextPathAtSubDirWithTrailingSlash() throws Exception {\n-        try (var infra = new Infra(\"\/foo\/\")) {\n-            infra.expect(200, \"\/foo\/\", \"\/foo\/bar\");\n-            infra.expect(404, \"\/foo\", \"\/foobar\");\n-        }\n-    }\n-\n-    private static final class Infra implements AutoCloseable {\n-\n-        private static final InetSocketAddress LO_SA_0 =\n-                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        private static final HttpHandler HANDLER = new EchoHandler();\n-\n-        private final HttpServer server;\n-\n-        private final String contextPath;\n-\n-        private Infra(String contextPath) throws IOException {\n-            this.server = HttpServer.create(LO_SA_0, 10);\n-            server.createContext(contextPath, HANDLER);\n-            server.start();\n-            this.contextPath = contextPath;\n-        }\n-\n-        private void expect(int statusCode, String... requestPaths) throws Exception {\n-            for (String requestPath : requestPaths) {\n-                var requestURI = URI.create(\"http:\/\/%s:%s%s\".formatted(\n-                        server.getAddress().getHostString(),\n-                        server.getAddress().getPort(),\n-                        requestPath));\n-                var request = HttpRequest.newBuilder(requestURI).build();\n-                var response = CLIENT.send(request, HttpResponse.BodyHandlers.discarding());\n-                assertEquals(\n-                        statusCode, response.statusCode(),\n-                        \"unexpected status code \" + Map.of(\n-                                \"contextPath\", contextPath,\n-                                \"requestPath\", requestPath));\n-            }\n-        }\n-\n-        @Override\n-        public void close() {\n-            server.stop(0);\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ContextPathMappingTest.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.Map;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+\n+import org.junit.jupiter.api.AfterAll;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+\/*\n+ * @test id=default\n+ * @bug 8272758\n+ * @summary Verifies path prefix matching using defaults\n+ * @build EchoHandler\n+ * @run junit ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=withProperty\n+ * @bug 8272758\n+ * @summary Verifies path prefix matching by providing a system property\n+ * @build EchoHandler\n+ * @run junit\/othervm\n+ *      -Dsun.net.httpserver.pathMatcher=pathPrefix\n+ *      ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=withInvalidProperty\n+ * @bug 8272758\n+ * @summary Verifies path prefix matching by providing a system property\n+ *          containing an invalid value, and observing it fall back to the\n+ *          default\n+ * @build EchoHandler\n+ * @run junit\/othervm\n+ *      -Dsun.net.httpserver.pathMatcher=noSuchMatcher\n+ *      ${test.main.class}\n+ *\/\n+\n+public class ContextPathMatcherPathPrefixTest {\n+\n+    private static final HttpClient CLIENT =\n+            HttpClient.newBuilder().proxy(NO_PROXY).build();\n+\n+    @AfterAll\n+    static void stopClient() {\n+        CLIENT.shutdownNow();\n+    }\n+\n+    @Test\n+    void testContextPathAtRoot() throws Exception {\n+        try (var infra = new Infra(\"\/\")) {\n+            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\", \"\/foobar\");\n+        }\n+    }\n+\n+    @Test\n+    void testContextPathAtSubDir() throws Exception {\n+        try (var infra = new Infra(\"\/foo\")) {\n+            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\");\n+            infra.expect(404, \"\/foobar\");\n+        }\n+    }\n+\n+    @Test\n+    void testContextPathAtSubDirWithTrailingSlash() throws Exception {\n+        try (var infra = new Infra(\"\/foo\/\")) {\n+            infra.expect(200, \"\/foo\/\", \"\/foo\/bar\");\n+            infra.expect(404, \"\/foo\", \"\/foobar\");\n+        }\n+    }\n+\n+    public static final class Infra implements AutoCloseable {\n+\n+        private static final InetSocketAddress LO_SA_0 =\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+        private static final HttpHandler HANDLER = new EchoHandler();\n+\n+        private final HttpServer server;\n+\n+        private final String contextPath;\n+\n+        public Infra(String contextPath) throws IOException {\n+            this.server = HttpServer.create(LO_SA_0, 10);\n+            server.createContext(contextPath, HANDLER);\n+            server.start();\n+            this.contextPath = contextPath;\n+        }\n+\n+        public void expect(int statusCode, String... requestPaths) throws Exception {\n+            for (String requestPath : requestPaths) {\n+                var requestURI = URI.create(\"http:\/\/%s:%s%s\".formatted(\n+                        server.getAddress().getHostString(),\n+                        server.getAddress().getPort(),\n+                        requestPath));\n+                var request = HttpRequest.newBuilder(requestURI).build();\n+                var response = CLIENT.send(request, HttpResponse.BodyHandlers.discarding());\n+                assertEquals(\n+                        statusCode, response.statusCode(),\n+                        \"unexpected status code \" + Map.of(\n+                                \"contextPath\", contextPath,\n+                                \"requestPath\", requestPath));\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            server.stop(0);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ContextPathMatcherPathPrefixTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.net.http.HttpClient;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+\n+\/*\n+ * @test\n+ * @bug 8272758\n+ * @summary Verifies string prefix matching configured using a system property\n+ * @build ContextPathMatcherPathPrefixTest\n+ *        EchoHandler\n+ * @run junit\/othervm\n+ *      -Dsun.net.httpserver.pathMatcher=stringPrefix\n+ *      ${test.main.class}\n+ *\/\n+\n+class ContextPathMatcherStringPrefixTest {\n+\n+    private static final HttpClient CLIENT =\n+            HttpClient.newBuilder().proxy(NO_PROXY).build();\n+\n+    @AfterAll\n+    static void stopClient() {\n+        CLIENT.shutdownNow();\n+    }\n+\n+    @Test\n+    void testContextPathAtRoot() throws Exception {\n+        try (var infra = new ContextPathMatcherPathPrefixTest.Infra(\"\/\")) {\n+            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\", \"\/foobar\");\n+        }\n+    }\n+\n+    @Test\n+    void testContextPathAtSubDir() throws Exception {\n+        try (var infra = new ContextPathMatcherPathPrefixTest.Infra(\"\/foo\")) {\n+            infra.expect(200, \"\/foo\", \"\/foo\/\", \"\/foo\/bar\", \"\/foobar\");\n+        }\n+    }\n+\n+    @Test\n+    void testContextPathAtSubDirWithTrailingSlash() throws Exception {\n+        try (var infra = new ContextPathMatcherPathPrefixTest.Infra(\"\/foo\/\")) {\n+            infra.expect(200, \"\/foo\/\", \"\/foo\/bar\");\n+            infra.expect(404, \"\/foo\", \"\/foobar\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ContextPathMatcherStringPrefixTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}