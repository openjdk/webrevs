{"files":[{"patch":"@@ -79,0 +79,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+  static constexpr size_t footer_size = sizeof(uint16_t);\n@@ -135,13 +136,3 @@\n-\n-  inline static size_t malloc_overhead() { return sizeof(MallocHeader) + sizeof(uint16_t); }\n-  static void asan_poison_header_footer(void* addr) {\n-    MallocHeader* header = (MallocHeader*)addr - 1;\n-    ASAN_POISON_MEMORY_REGION(header->footer_address(), sizeof(uint16_t));\n-    ASAN_POISON_MEMORY_REGION(header, sizeof(MallocHeader));\n-  }\n-  static void asan_unpoison_header_footer(void* addr) {\n-    MallocHeader* header = (MallocHeader*)addr - 1;\n-    ASAN_UNPOISON_MEMORY_REGION(header, sizeof(MallocHeader));\n-    ASAN_UNPOISON_MEMORY_REGION(header->footer_address(), sizeof(uint16_t));\n-  }\n-\n+  inline static size_t malloc_overhead() { return sizeof(MallocHeader) + footer_size; }\n+  inline static MallocHeader* kill_block(void* memblock);\n+  inline static void revive_block(void* memblock);\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -49,3 +49,0 @@\n-  assert(_canary == _header_canary_dead_mark, \"must be dead\");\n-  assert(get_footer() == _footer_canary_dead_mark, \"must be dead\");\n-  NOT_LP64(assert(_alt_canary == _header_alt_canary_dead_mark, \"must be dead\"));\n@@ -168,0 +165,16 @@\n+MallocHeader* MallocHeader::kill_block(void* memblock) {\n+  MallocHeader* header = (MallocHeader*)memblock - 1;\n+  ASAN_UNPOISON_MEMORY_REGION(header, sizeof(MallocHeader));\n+  ASAN_UNPOISON_MEMORY_REGION(header->footer_address(), footer_size);\n+  resolve_checked(memblock);\n+  header->mark_block_as_dead();\n+  return header;\n+}\n+\n+void MallocHeader::revive_block(void* memblock) {\n+  MallocHeader* header = (MallocHeader*)memblock - 1;\n+  header->revive();\n+  ASAN_POISON_MEMORY_REGION(header->footer_address(), footer_size);\n+  ASAN_POISON_MEMORY_REGION(header, sizeof(MallocHeader));\n+}\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.inline.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-  MallocHeader::asan_poison_header_footer(memblock);\n+  MallocHeader::revive_block(memblock);\n@@ -210,2 +210,1 @@\n-  MallocHeader::asan_unpoison_header_footer(memblock);\n-  MallocHeader* header = MallocHeader::resolve_checked(memblock);\n+  MallocHeader* header = MallocHeader::kill_block(memblock);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -314,9 +314,0 @@\n-\n-  static inline MallocHeader* malloc_header(void *memblock) {\n-    assert(memblock != nullptr, \"null pointer\");\n-    return (MallocHeader*)memblock -1;\n-  }\n-  static inline const MallocHeader* malloc_header(const void *memblock) {\n-    assert(memblock != nullptr, \"null pointer\");\n-    return (const MallocHeader*)memblock -1;\n-  }\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -709,7 +709,2 @@\n-    MallocHeader::asan_unpoison_header_footer(memblock);\n-    const size_t old_size = MallocTracker::malloc_header(memblock)->size();\n-\n-    \/\/ Observe MallocLimit\n-    if ((size > old_size) && MemTracker::check_exceeds_limit(size - old_size, mem_tag)) {\n-      return nullptr;\n-    }\n+    MallocHeader* header = MallocHeader::kill_block(memblock);\n+    const size_t old_size = header->size();\n@@ -719,1 +714,0 @@\n-    MallocHeader* header = MallocHeader::resolve_checked(memblock);\n@@ -722,3 +716,14 @@\n-    const MallocHeader::FreeInfo free_info = header->free_info();\n-\n-    header->mark_block_as_dead();\n+    bool within_malloc_limit = !((size > old_size) && MemTracker::check_exceeds_limit(size - old_size, mem_tag));\n+    bool success = within_malloc_limit;\n+    \/\/ Observe MallocLimit\n+    if (success) {\n+      \/\/ If realloc succeeds, the header is freed. Get FreeInfo before that.\n+      MallocHeader::FreeInfo free_info = header->free_info();\n+      void* const new_outer_ptr = permit_forbidden_function::realloc(header, new_outer_size);\n+      success = new_outer_ptr != nullptr;\n+      if (success) {\n+        \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to deaccount the old block.\n+        MemTracker::deaccount(free_info);\n+        \/\/ After a successful realloc(3), we account the resized block with its new size\n+        \/\/ to NMT.\n+        void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack);\n@@ -726,2 +731,6 @@\n-    \/\/ the real realloc\n-    void* const new_outer_ptr = permit_forbidden_function::realloc(header, new_outer_size);\n+#ifdef ASSERT\n+        if (ZapCHeap && old_size < size) {\n+          \/\/ We also zap the newly extended region.\n+          ::memset((char*)new_inner_ptr + old_size, uninitBlockPad, size - old_size);\n+        }\n+#endif\n@@ -729,1 +738,4 @@\n-    if (new_outer_ptr == nullptr) {\n+        rc = new_inner_ptr;\n+      }\n+    }\n+    if (!success) {\n@@ -732,2 +744,1 @@\n-      header->revive();\n-      MallocHeader::asan_poison_header_footer(memblock);\n+      MallocHeader::revive_block(memblock);\n@@ -736,17 +747,0 @@\n-    \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to deaccount the old block.\n-    MemTracker::deaccount(free_info);\n-\n-    \/\/ After a successful realloc(3), we account the resized block with its new size\n-    \/\/ to NMT.\n-    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack);\n-\n-#ifdef ASSERT\n-    assert(old_size == free_info.size, \"Sanity\");\n-    if (ZapCHeap && old_size < size) {\n-      \/\/ We also zap the newly extended region.\n-      ::memset((char*)new_inner_ptr + old_size, uninitBlockPad, size - old_size);\n-    }\n-#endif\n-\n-    rc = new_inner_ptr;\n-\n@@ -754,1 +748,0 @@\n-\n@@ -760,1 +753,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":27,"deletions":35,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -201,2 +201,2 @@\n-  uint16_t* canary_ptr = (uint16_t*)((char*)p - sizeof(uint16_t));\n-  *canary_ptr = 1;\n+  \/\/ sizeof(MallocHeader) == 16, pick anywheree in [p - 16, p)\n+  *(uint16_t*)((char*)p - 5) = 1;\n@@ -208,3 +208,2 @@\n-  uint16_t* canary_ptr = (uint16_t*)((char*)p - sizeof(uint16_t));\n-  uint16_t read_canary = 0;\n-  read_canary = *canary_ptr;\n+  \/\/ sizeof(MallocHeader) == 16, pick anywheree in [p - 16, p)\n+  uint16_t read_canary = *(uint16_t*)((char*)p - 5);\n@@ -216,1 +215,0 @@\n-  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n@@ -224,1 +222,0 @@\n-  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n@@ -233,2 +230,2 @@\n-  uint16_t* canary_ptr = (uint16_t*)((char*)p - sizeof(uint16_t));\n-  *canary_ptr = 1;\n+  \/\/ sizeof(MallocHeader) == 16, pick anywheree in [p - 16, p)\n+  *(uint16_t*)((char*)p - 5) = 1;\n@@ -241,3 +238,2 @@\n-  uint16_t* canary_ptr = (uint16_t*)((char*)p - sizeof(uint16_t));\n-  uint16_t read_canary = 0;\n-  read_canary = *canary_ptr;\n+  \/\/ sizeof(MallocHeader) == 16, pick anywheree in [p - 16, p)\n+  uint16_t read_canary = *(uint16_t*)((char*)p - 5);\n@@ -250,1 +246,0 @@\n-  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n@@ -259,1 +254,0 @@\n-  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-#endif \/\/ !INCLUDE_ASAN\n@@ -157,3 +156,2 @@\n-  MallocHeader* hdr = MallocTracker::malloc_header(p);\n-  hdr->mark_block_as_dead();\n-  hdr->revive();\n+  MallocHeader* hdr = MallocHeader::kill_block(p);\n+  MallocHeader::revive_block(p);\n@@ -162,0 +160,2 @@\n+#endif \/\/ !INCLUDE_ASAN\n+\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_cornercases.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+ * @comment Under ASAN build, memory corruption is reported by ASAN runtime and not JVM.\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTPrintMallocSiteOfCorruptedMemory.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}