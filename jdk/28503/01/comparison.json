{"files":[{"patch":"@@ -79,0 +79,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"sanitizers\/address.hpp\"\n@@ -34,0 +35,5 @@\n+#if INCLUDE_ASAN\n+#undef NMT_BLOCK_INTEGRITY_CHECKS\n+#else\n+#define NMT_BLOCK_INTEGRITY_CHECKS\n+#endif\n@@ -121,0 +127,1 @@\n+  static constexpr size_t footer_size = sizeof(uint16_t);\n@@ -129,2 +136,3 @@\n-\n-  inline static size_t malloc_overhead() { return sizeof(MallocHeader) + sizeof(uint16_t); }\n+  inline static size_t malloc_overhead() { return sizeof(MallocHeader) + footer_size; }\n+  inline static MallocHeader* kill_block(void* memblock);\n+  inline static void revive_block(void* memblock);\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,3 +49,0 @@\n-  assert(_canary == _header_canary_dead_mark, \"must be dead\");\n-  assert(get_footer() == _footer_canary_dead_mark, \"must be dead\");\n-  NOT_LP64(assert(_alt_canary == _header_alt_canary_dead_mark, \"must be dead\"));\n@@ -99,5 +96,0 @@\n-  char msg[256];\n-  address corruption = nullptr;\n-  if (!is_valid_malloced_pointer(memblock, msg, sizeof(msg))) {\n-    fatal(\"Not a valid malloc pointer: \" PTR_FORMAT \": %s\", p2i(memblock), msg);\n-  }\n@@ -105,4 +97,11 @@\n-  if (!header_pointer->check_block_integrity(msg, sizeof(msg), &corruption)) {\n-    header_pointer->print_block_on_error(tty, corruption != nullptr ? corruption : (address)header_pointer, (address)header_pointer);\n-    fatal(\"NMT has detected a memory corruption bug. Block at \" PTR_FORMAT \": %s\", p2i(memblock), msg);\n-  }\n+  #ifdef NMT_BLOCK_INTEGRITY_CHECKS\n+    char msg[256];\n+    address corruption = nullptr;\n+    if (!is_valid_malloced_pointer(memblock, msg, sizeof(msg))) {\n+      fatal(\"Not a valid malloc pointer: \" PTR_FORMAT \": %s\", p2i(memblock), msg);\n+    }\n+    if (!header_pointer->check_block_integrity(msg, sizeof(msg), &corruption)) {\n+      header_pointer->print_block_on_error(tty, corruption != nullptr ? corruption : (address)header_pointer, (address)header_pointer);\n+      fatal(\"NMT has detected a memory corruption bug. Block at \" PTR_FORMAT \": %s\", p2i(memblock), msg);\n+    }\n+  #endif\n@@ -166,0 +165,16 @@\n+MallocHeader* MallocHeader::kill_block(void* memblock) {\n+  MallocHeader* header = (MallocHeader*)memblock - 1;\n+  ASAN_UNPOISON_MEMORY_REGION(header, sizeof(MallocHeader));\n+  ASAN_UNPOISON_MEMORY_REGION(header->footer_address(), footer_size);\n+  resolve_checked(memblock);\n+  header->mark_block_as_dead();\n+  return header;\n+}\n+\n+void MallocHeader::revive_block(void* memblock) {\n+  MallocHeader* header = (MallocHeader*)memblock - 1;\n+  header->revive();\n+  ASAN_POISON_MEMORY_REGION(header->footer_address(), footer_size);\n+  ASAN_POISON_MEMORY_REGION(header, sizeof(MallocHeader));\n+}\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.inline.hpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-\n+  MallocHeader::revive_block(memblock);\n@@ -210,1 +210,1 @@\n-  MallocHeader* header = MallocHeader::resolve_checked(memblock);\n+  MallocHeader* header = MallocHeader::kill_block(memblock);\n@@ -221,1 +221,0 @@\n-\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -314,9 +314,0 @@\n-\n-  static inline MallocHeader* malloc_header(void *memblock) {\n-    assert(memblock != nullptr, \"null pointer\");\n-    return (MallocHeader*)memblock -1;\n-  }\n-  static inline const MallocHeader* malloc_header(const void *memblock) {\n-    assert(memblock != nullptr, \"null pointer\");\n-    return (const MallocHeader*)memblock -1;\n-  }\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -709,7 +709,2 @@\n-\n-    const size_t old_size = MallocTracker::malloc_header(memblock)->size();\n-\n-    \/\/ Observe MallocLimit\n-    if ((size > old_size) && MemTracker::check_exceeds_limit(size - old_size, mem_tag)) {\n-      return nullptr;\n-    }\n+    MallocHeader* header = MallocHeader::kill_block(memblock);\n+    const size_t old_size = header->size();\n@@ -719,1 +714,0 @@\n-    MallocHeader* header = MallocHeader::resolve_checked(memblock);\n@@ -722,3 +716,14 @@\n-    const MallocHeader::FreeInfo free_info = header->free_info();\n-\n-    header->mark_block_as_dead();\n+    bool within_malloc_limit = !((size > old_size) && MemTracker::check_exceeds_limit(size - old_size, mem_tag));\n+    bool success = within_malloc_limit;\n+    \/\/ Observe MallocLimit\n+    if (success) {\n+      \/\/ If realloc succeeds, the header is freed. Get FreeInfo before that.\n+      MallocHeader::FreeInfo free_info = header->free_info();\n+      void* const new_outer_ptr = permit_forbidden_function::realloc(header, new_outer_size);\n+      success = new_outer_ptr != nullptr;\n+      if (success) {\n+        \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to deaccount the old block.\n+        MemTracker::deaccount(free_info);\n+        \/\/ After a successful realloc(3), we account the resized block with its new size\n+        \/\/ to NMT.\n+        void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack);\n@@ -726,2 +731,6 @@\n-    \/\/ the real realloc\n-    void* const new_outer_ptr = permit_forbidden_function::realloc(header, new_outer_size);\n+#ifdef ASSERT\n+        if (ZapCHeap && old_size < size) {\n+          \/\/ We also zap the newly extended region.\n+          ::memset((char*)new_inner_ptr + old_size, uninitBlockPad, size - old_size);\n+        }\n+#endif\n@@ -729,1 +738,4 @@\n-    if (new_outer_ptr == nullptr) {\n+        rc = new_inner_ptr;\n+      }\n+    }\n+    if (!success) {\n@@ -732,1 +744,1 @@\n-      header->revive();\n+      MallocHeader::revive_block(memblock);\n@@ -735,17 +747,0 @@\n-    \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to deaccount the old block.\n-    MemTracker::deaccount(free_info);\n-\n-    \/\/ After a successful realloc(3), we account the resized block with its new size\n-    \/\/ to NMT.\n-    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack);\n-\n-#ifdef ASSERT\n-    assert(old_size == free_info.size, \"Sanity\");\n-    if (ZapCHeap && old_size < size) {\n-      \/\/ We also zap the newly extended region.\n-      ::memset((char*)new_inner_ptr + old_size, uninitBlockPad, size - old_size);\n-    }\n-#endif\n-\n-    rc = new_inner_ptr;\n-\n@@ -753,1 +748,0 @@\n-\n@@ -759,1 +753,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":27,"deletions":34,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-#if !INCLUDE_ASAN\n-\n@@ -55,0 +53,2 @@\n+#if !INCLUDE_ASAN\n+\n@@ -193,0 +193,74 @@\n+#else \/\/ ASAN is enabled\n+\n+#define DEFINE_ASAN_TEST(test_function)  \\\n+  DEFINE_TEST(test_function, \".*AddressSanitizer.*\")\n+\n+static void test_write_header() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  \/\/ sizeof(MallocHeader) == 16, pick anywheree in [p - 16, p)\n+  *(uint16_t*)((char*)p - 5) = 1;\n+}\n+\n+static void test_read_header() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  \/\/ sizeof(MallocHeader) == 16, pick anywheree in [p - 16, p)\n+  uint16_t read_canary = *(uint16_t*)((char*)p - 5);\n+}\n+\n+static void test_write_footer() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  uint16_t* footer_ptr = (uint16_t*)(p + SIZE);\n+  *footer_ptr = 1;\n+}\n+\n+static void test_read_footer() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  uint16_t* footer_ptr = (uint16_t*)(p + SIZE);\n+  uint16_t read_footer = *footer_ptr;\n+}\n+\n+static void test_write_header_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  \/\/ sizeof(MallocHeader) == 16, pick anywheree in [p - 16, p)\n+  *(uint16_t*)((char*)p - 5) = 1;\n+}\n+\n+static void test_read_header_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  \/\/ sizeof(MallocHeader) == 16, pick anywheree in [p - 16, p)\n+  uint16_t read_canary = *(uint16_t*)((char*)p - 5);\n+}\n+\n+static void test_write_footer_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  uint16_t* footer_ptr = (uint16_t*)(p + 2 * SIZE);\n+  *footer_ptr = 1;\n+}\n+\n+static void test_read_footer_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  uint16_t* footer_ptr = (uint16_t*)(p + 2 * SIZE);\n+  uint16_t read_footer = *footer_ptr;\n+}\n+\n+DEFINE_ASAN_TEST(test_write_header);\n+DEFINE_ASAN_TEST(test_read_header);\n+DEFINE_ASAN_TEST(test_write_footer);\n+DEFINE_ASAN_TEST(test_read_footer);\n+DEFINE_ASAN_TEST(test_write_header_after_realloc);\n+DEFINE_ASAN_TEST(test_read_header_after_realloc);\n+DEFINE_ASAN_TEST(test_write_footer_after_realloc);\n+DEFINE_ASAN_TEST(test_read_footer_after_realloc);\n+\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-#endif \/\/ !INCLUDE_ASAN\n@@ -157,3 +156,2 @@\n-  MallocHeader* hdr = MallocTracker::malloc_header(p);\n-  hdr->mark_block_as_dead();\n-  hdr->revive();\n+  MallocHeader* hdr = MallocHeader::kill_block(p);\n+  MallocHeader::revive_block(p);\n@@ -162,0 +160,2 @@\n+#endif \/\/ !INCLUDE_ASAN\n+\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_cornercases.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+ * @comment Under ASAN build, memory corruption is reported by ASAN runtime and not JVM.\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTPrintMallocSiteOfCorruptedMemory.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}