{"files":[{"patch":"@@ -350,1 +350,1 @@\n-        final String urlNoFragString = URLUtil.urlNoFragString(url);\n+        final String urlKey = URLUtil.urlNoFragString(url);\n@@ -352,2 +352,4 @@\n-        \/\/ Open available URLs until we reach the requested one\n-        while ((loader = lmap.get(urlNoFragString)) == null && getLoader(loaders.size()) != null) {}\n+        synchronized (this) {\n+            \/\/ Open available URLs until we reach the requested one\n+            while ((loader = lmap.get(urlKey)) == null && getLoader(loaders.size()) != null) {}\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n@@ -37,1 +35,0 @@\n-import java.net.URLClassLoader;\n@@ -354,3 +351,1 @@\n-    private static class UnregisteredClassLoader extends URLClassLoader {\n-        \/** Class<?> URLClassLoader::defineClass(String name, Resource res) *\/\n-        private static final Method DEFINE_CLASS;\n+    private static class UnregisteredClassLoader extends ClassLoader {\n@@ -358,9 +353,1 @@\n-            try {\n-                DEFINE_CLASS = URLClassLoader.class.getDeclaredMethod(\n-                    \"defineClass\", String.class, Resource.class\n-                );\n-            } catch (NoSuchMethodException e) {\n-                throw new InternalError(e);\n-            }\n-            assert DEFINE_CLASS.getReturnType() == Class.class;\n-            DEFINE_CLASS.setAccessible(true);\n+            registerAsParallelCapable();\n@@ -371,4 +358,0 @@\n-         * <p>\n-         * URLClassLoader also has this but we use it in a different way: we\n-         * request resources from specific sources rather than from the first\n-         * source in the list that has a resource with the requested name.\n@@ -378,10 +361,0 @@\n-        \/**\n-         * Used only by native code. Construct an UnregisteredClassLoader for loading\n-         * unregistered classes.\n-         *\/\n-        private UnregisteredClassLoader() {\n-            \/\/ Parent is not set to null: we will delegate to system class loader to load registered\n-            \/\/ supers and interfaces of unregistered classes\n-            super(new URL[0]);\n-        }\n-\n@@ -407,2 +380,0 @@\n-            \/\/ Almost like URLClassLoader.findClass(...), the main difference is that we request\n-            \/\/ .class file from the specific source\n@@ -415,0 +386,1 @@\n+                final var buf = res.getByteBuffer();\n@@ -420,19 +392,11 @@\n-                return (Class<?>) DEFINE_CLASS.invoke(this, name, res);\n-            } catch (IllegalAccessException e) {\n-                throw new AssertionError(\"defineClass not accessible\", e); \/\/ Should not happen\n-            } catch (InvocationTargetException ite) {\n-                final Throwable cause = ite.getCause();\n-                switch (cause) {\n-                    \/\/ Special handling as in URLClassLoader.findClass(...)\n-                    case IOException e -> throw new ClassNotFoundException(name, e);\n-                    case ClassFormatError e -> {\n-                        if (res.getDataError() != null) {\n-                            e.addSuppressed(res.getDataError());\n-                        }\n-                        throw e;\n-                    }\n-                    \/\/ Other\n-                    case Error e -> throw e;\n-                    case RuntimeException e -> throw e;\n-                    case null -> throw new ClassNotFoundException(name, ite);\n-                    default -> throw new ClassNotFoundException(name, cause);\n+                if (buf != null) {\n+                    return defineClass(name, buf, null);\n+                } else {\n+                    final byte[] bytes = res.getBytes();\n+                    return defineClass(name, bytes, 0, bytes.length);\n+                }\n+            } catch (IOException e) {\n+                throw new ClassNotFoundException(name, e);\n+            } catch (ClassFormatError e) {\n+                if (res.getDataError() != null) {\n+                    e.addSuppressed(res.getDataError());\n@@ -440,0 +404,1 @@\n+                throw e;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":15,"deletions":50,"binary":false,"changes":65,"status":"modified"}]}