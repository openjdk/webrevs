{"files":[{"patch":"@@ -142,9 +142,0 @@\n-\/\/ getCause does not always return cause field so using this is more accurate.\n-static oop get_exception_cause(Handle exception, TRAPS) {\n-  JavaValue cause(T_OBJECT);\n-  JavaCalls::call_virtual(&cause, exception, exception->klass(),\n-                          vmSymbols::getCause_name(), vmSymbols::void_throwable_signature(),\n-                          CHECK_AND_CLEAR_NULL); \/\/ Ignore possible new exceptions\n-  return cause.get_oop();\n-}\n-\n@@ -168,14 +159,5 @@\n-    Handle ex(THREAD, PENDING_EXCEPTION);\n-    CLEAR_PENDING_EXCEPTION;\n-    {\n-      ResourceMark rm(THREAD);\n-      const oop msg = java_lang_Throwable::message(ex());\n-      log_warning(cds)(\"%s: %s\", ex->klass()->external_name(),\n-                       msg != nullptr ? java_lang_String::as_utf8_string(msg) : \"\");\n-    }\n-    for (oop cause = get_exception_cause(ex, THREAD); cause != nullptr;\n-         ex.replace(cause), cause = get_exception_cause(ex, THREAD)) {\n-      ResourceMark rm(THREAD);\n-      const oop msg = java_lang_Throwable::message(cause);\n-      log_warning(cds)(\"\\tCaused by: %s: %s\", cause->klass()->external_name(),\n-                       msg != nullptr ? java_lang_String::as_utf8_string(msg) : \"\");\n+    ResourceMark rm(THREAD);\n+    char* ex_msg = (char*)\"\";\n+    oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n+    if (message != nullptr) {\n+      ex_msg = java_lang_String::as_utf8_string(message);\n@@ -183,1 +165,1 @@\n-\n+    log_warning(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n@@ -186,0 +168,1 @@\n+    CLEAR_PENDING_EXCEPTION;\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -340,20 +340,0 @@\n-    \/**\n-     * Finds the Resource with the specified name on the specified URL. Returns\n-     * null if no Resource could be found, including the case when the URL is\n-     * not in the search path.\n-     *\n-     * @param name the name of the Resource\n-     * @param url  the URL to look in\n-     * @return the Resource, or null if not found\n-     *\/\n-    public Resource getResource(String name, URL url) {\n-        final String urlKey = URLUtil.urlNoFragString(url);\n-        Loader loader;\n-        synchronized (this) {\n-            \/\/ Open available URLs until we reach the requested one\n-            while ((loader = lmap.get(urlKey)) == null && getLoader(loaders.size()) != null) {}\n-        }\n-        \/\/ loader == null if either the URL is not in the path or it cannot be opened\n-        return loader != null ? loader.getResource(name) : null;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.net.URL;\n+import java.nio.file.Files;\n@@ -38,0 +38,1 @@\n+import java.util.HashMap;\n@@ -41,0 +42,1 @@\n+import java.util.jar.JarFile;\n@@ -44,2 +46,0 @@\n-import jdk.internal.loader.Resource;\n-import jdk.internal.loader.URLClassPath;\n@@ -356,4 +356,63 @@\n-        \/**\n-         * Collection of all sources used so far.\n-         *\/\n-        private final URLClassPath ucp = new URLClassPath(new URL[0]);\n+        static interface Source {\n+            public byte[] readClassFile(String className) throws IOException;\n+        }\n+\n+        static class JarSource implements Source {\n+            private final JarFile jar;\n+\n+            JarSource(File file) throws IOException {\n+                jar = new JarFile(file);\n+            }\n+\n+            @Override\n+            public byte[] readClassFile(String className) throws IOException {\n+                final var entryName = className.replace('.', '\/').concat(\".class\");\n+                final var entry = jar.getEntry(entryName);\n+                if (entry == null) {\n+                    throw new IOException(\"No such entry: \" + entryName + \" in \" + jar.getName());\n+                }\n+                try (final var in = jar.getInputStream(entry)) {\n+                    return in.readAllBytes();\n+                }\n+            }\n+        }\n+\n+        static class DirSource implements Source {\n+            private final String basePath;\n+\n+            DirSource(File dir) {\n+                assert dir.isDirectory();\n+                basePath = dir.toString();\n+            }\n+\n+            @Override\n+            public byte[] readClassFile(String className) throws IOException {\n+                final var subPath = className.replace('.', File.separatorChar).concat(\".class\");\n+                final var fullPath = Path.of(basePath, subPath);\n+                return Files.readAllBytes(fullPath);\n+            }\n+        }\n+\n+        private final HashMap<String, Source> sources = new HashMap<>();\n+\n+        private Source resolveSource(String path) throws IOException {\n+            Source source = sources.get(path);\n+            if (source != null) {\n+                return source;\n+            }\n+\n+            final var file = new File(path);\n+            if (!file.exists()) {\n+                throw new IOException(\"No such file: \" + path);\n+            }\n+            if (file.isFile()) {\n+                source = new JarSource(file);\n+            } else if (file.isDirectory()) {\n+                source = new DirSource(file);\n+            } else {\n+                throw new IOException(\"Not a normal file: \" + path);\n+            }\n+            sources.put(path, source);\n+\n+            return source;\n+        }\n@@ -371,35 +430,9 @@\n-        private Class<?> load(String name, String source) throws ClassNotFoundException {\n-            final URL sourceUrl;\n-            try {\n-                sourceUrl = Path.of(source).toRealPath().toUri().toURL(); \/\/ toRealPath also checks existance\n-            } catch (IOException e) {\n-                throw new IllegalArgumentException(\"Invalid class source: \" + source, e);\n-            }\n-            ucp.addURL(sourceUrl);\n-\n-            final String path = name.replace('.', '\/').concat(\".class\");\n-            final Resource res = ucp.getResource(path, sourceUrl);\n-            if (res == null) {\n-                throw new ClassNotFoundException(name + \": cannot get \" + path + \" from \" + source);\n-            }\n-            try {\n-                final var buf = res.getByteBuffer();\n-                \/\/ While executing this VM may invoke loadClass() to load supers and interfaces of\n-                \/\/ this unregistered class. This should only happen for registered supers and\n-                \/\/ interfaces because all unregistered ones should have already been loaded by this\n-                \/\/ class loader. Thus it is safe to delegate their loading to system class loader\n-                \/\/ (our parent) - this is what the default implementation of loadClass() will do.\n-                if (buf != null) {\n-                    return defineClass(name, buf, null);\n-                } else {\n-                    final byte[] bytes = res.getBytes();\n-                    return defineClass(name, bytes, 0, bytes.length);\n-                }\n-            } catch (IOException e) {\n-                throw new ClassNotFoundException(name, e);\n-            } catch (ClassFormatError e) {\n-                if (res.getDataError() != null) {\n-                    e.addSuppressed(res.getDataError());\n-                }\n-                throw e;\n-            }\n+        private Class<?> load(String name, String source) throws IOException {\n+            final Source resolvedSource = resolveSource(source);\n+            final byte[] bytes = resolvedSource.readClassFile(name);\n+            \/\/ While executing this VM may invoke loadClass() to load supers and interfaces of\n+            \/\/ this unregistered class. This should only happen for registered supers and\n+            \/\/ interfaces because all unregistered ones should have already been loaded by this\n+            \/\/ class loader. Thus it is safe to delegate their loading to system class loader\n+            \/\/ (our parent) - this is what the default implementation of loadClass() will do.\n+            return defineClass(name, bytes, 0, bytes.length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":75,"deletions":42,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -114,2 +114,1 @@\n-            \"java.lang.IllegalArgumentException: Invalid class source: no_such_file.jar\",\n-            \"Caused by: java.nio.file.NoSuchFileException\");\n+            \"java.io.IOException: No such file: no_such_file.jar\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatE.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}