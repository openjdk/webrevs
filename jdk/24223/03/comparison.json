{"files":[{"patch":"@@ -397,1 +397,1 @@\n-objArrayOop ClassListParser::get_specified_interfaces(TRAPS) {\n+GrowableArray<InstanceKlass *> ClassListParser::get_specified_interfaces() {\n@@ -399,8 +399,3 @@\n-  if (n == 0) {\n-    return nullptr;\n-  } else {\n-    objArrayOop array = oopFactory::new_objArray(vmClasses::Class_klass(), n, CHECK_NULL);\n-    for (int i = 0; i < n; i++) {\n-      array->obj_at_put(i, lookup_class_by_id(_interfaces->at(i))->java_mirror());\n-    }\n-    return array;\n+  GrowableArray<InstanceKlass *> specified_interfaces(n);\n+  for (int i = 0; i < n; i++) {\n+    specified_interfaces.append(lookup_class_by_id(_interfaces->at(i)));\n@@ -408,0 +403,1 @@\n+  return specified_interfaces;\n@@ -535,1 +531,0 @@\n-  char * source_path = os::strdup_check_oom(ClassLoader::uri_to_path(_source));\n@@ -537,5 +532,5 @@\n-  Handle super_class(THREAD, specified_super->java_mirror());\n-  objArrayOop r = get_specified_interfaces(CHECK_NULL);\n-  objArrayHandle interfaces(THREAD, r);\n-  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path,\n-                                                     super_class, interfaces, CHECK_NULL);\n+  GrowableArray<InstanceKlass*> specified_interfaces = get_specified_interfaces();\n+\n+  const char* source_path = ClassLoader::uri_to_path(_source);\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path, CHECK_NULL);\n+\n@@ -553,0 +548,9 @@\n+  for (int i = 0; i < _interfaces->length(); i++) {\n+    InstanceKlass* specified_interface = specified_interfaces.at(i);\n+    if (!k->local_interfaces()->contains(specified_interface)) {\n+      print_specified_interfaces();\n+      print_actual_interfaces(k);\n+      error(\"Specified interface %s (id %d) is not directly implemented\",\n+            specified_interface->external_name(), _interfaces->at(i));\n+      }\n+  }\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-  objArrayOop get_specified_interfaces(TRAPS);\n+  GrowableArray<InstanceKlass*> get_specified_interfaces();\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,4 +27,0 @@\n-#include \"classfile\/classFileStream.hpp\"\n-#include \"classfile\/classLoader.inline.hpp\"\n-#include \"classfile\/classLoaderExt.hpp\"\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -34,2 +30,0 @@\n-#include \"memory\/oopFactory.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n@@ -37,0 +31,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -38,0 +33,1 @@\n+#include \"runtime\/handles.hpp\"\n@@ -43,0 +39,1 @@\n+static OopHandle _unregistered_class_loader;\n@@ -50,0 +47,6 @@\n+\n+    precond(_unregistered_class_loader.is_empty());\n+    HandleMark hm(THREAD);\n+    const Handle cl = JavaCalls::construct_new_instance(UnregisteredClassLoader_klass(),\n+                                                        vmSymbols::void_method_signature(), CHECK);\n+    _unregistered_class_loader = OopHandle(Universe::vm_global(), cl());\n@@ -56,2 +59,1 @@\n-InstanceKlass* UnregisteredClasses::load_class(Symbol* name, const char* path,\n-                                               Handle super_class, objArrayHandle interfaces, TRAPS) {\n+InstanceKlass* UnregisteredClasses::load_class(Symbol* name, const char* path, TRAPS) {\n@@ -65,28 +67,2 @@\n-  \/\/ Call CDS$UnregisteredClassLoader::load(String name, Class<?> superClass, Class<?>[] interfaces)\n-  Symbol* methodName = SymbolTable::new_symbol(\"load\");\n-  Symbol* methodSignature = SymbolTable::new_symbol(\"(Ljava\/lang\/String;Ljava\/lang\/Class;[Ljava\/lang\/Class;)Ljava\/lang\/Class;\");\n-  Symbol* path_symbol = SymbolTable::new_symbol(path);\n-  Handle classloader = get_classloader(path_symbol, CHECK_NULL);\n-  Handle ext_class_name = java_lang_String::externalize_classname(name, CHECK_NULL);\n-\n-  JavaValue result(T_OBJECT);\n-  JavaCallArguments args(3);\n-  args.set_receiver(classloader);\n-  args.push_oop(ext_class_name);\n-  args.push_oop(super_class);\n-  args.push_oop(interfaces);\n-  JavaCalls::call_virtual(&result,\n-                          UnregisteredClassLoader_klass(),\n-                          methodName,\n-                          methodSignature,\n-                          &args,\n-                          CHECK_NULL);\n-  assert(result.get_type() == T_OBJECT, \"just checking\");\n-  oop obj = result.get_oop();\n-  return InstanceKlass::cast(java_lang_Class::as_Klass(obj));\n-}\n-\n-class UnregisteredClasses::ClassLoaderTable : public ResourceHashtable<\n-  Symbol*, OopHandle,\n-  137, \/\/ prime number\n-  AnyObj::C_HEAP> {};\n+  assert(!_unregistered_class_loader.is_empty(), \"not initialized\");\n+  Handle classloader(THREAD, _unregistered_class_loader.resolve());\n@@ -94,1 +70,6 @@\n-static UnregisteredClasses::ClassLoaderTable* _classloader_table = nullptr;\n+  oop obj;\n+  { \/\/ Call CDS$UnregisteredClassLoader::load(String name, String source)\n+    Symbol* methodName = SymbolTable::new_symbol(\"load\");\n+    Symbol* methodSignature = SymbolTable::new_symbol(\"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/Class;\");\n+    Handle ext_class_name = java_lang_String::externalize_classname(name, CHECK_NULL);\n+    Handle path_string = java_lang_String::create_from_str(path, CHECK_NULL);\n@@ -96,23 +77,11 @@\n-Handle UnregisteredClasses::create_classloader(Symbol* path, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  JavaValue result(T_OBJECT);\n-  Handle path_string = java_lang_String::create_from_str(path->as_C_string(), CHECK_NH);\n-  Handle classloader = JavaCalls::construct_new_instance(\n-                           UnregisteredClassLoader_klass(),\n-                           vmSymbols::string_void_signature(),\n-                           path_string, CHECK_NH);\n-  return classloader;\n-}\n-\n-Handle UnregisteredClasses::get_classloader(Symbol* path, TRAPS) {\n-  if (_classloader_table == nullptr) {\n-    _classloader_table = new (mtClass)ClassLoaderTable();\n-  }\n-  OopHandle* classloader_ptr = _classloader_table->get(path);\n-  if (classloader_ptr != nullptr) {\n-    return Handle(THREAD, (*classloader_ptr).resolve());\n-  } else {\n-    Handle classloader = create_classloader(path, CHECK_NH);\n-    _classloader_table->put(path, OopHandle(Universe::vm_global(), classloader()));\n-    path->increment_refcount();\n-    return classloader;\n+    JavaValue result(T_OBJECT);\n+    JavaCalls::call_virtual(&result,\n+                            classloader,\n+                            UnregisteredClassLoader_klass(),\n+                            methodName,\n+                            methodSignature,\n+                            ext_class_name,\n+                            path_string,\n+                            CHECK_NULL);\n+    assert(result.get_type() == T_OBJECT, \"just checking\");\n+    obj = result.get_oop();\n@@ -120,0 +89,2 @@\n+\n+  return InstanceKlass::cast(java_lang_Class::as_Klass(obj));\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":31,"deletions":60,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -36,3 +36,1 @@\n-  static InstanceKlass* load_class(Symbol* h_name, const char* path,\n-                                   Handle super_class, objArrayHandle interfaces,\n-                                   TRAPS);\n+  static InstanceKlass* load_class(Symbol* name, const char* path, TRAPS);\n@@ -44,2 +42,0 @@\n-  class ClassLoaderTable;\n-\n@@ -49,3 +45,0 @@\n-\n-  static Handle create_classloader(Symbol* path, TRAPS);\n-  static Handle get_classloader(Symbol* path, TRAPS);\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,3 +34,1 @@\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.file.InvalidPathException;\n+import java.nio.file.Files;\n@@ -40,0 +38,1 @@\n+import java.util.HashMap;\n@@ -43,0 +42,1 @@\n+import java.util.jar.JarFile;\n@@ -351,4 +351,4 @@\n-    private static class UnregisteredClassLoader extends URLClassLoader {\n-        private String currentClassName;\n-        private Class<?> currentSuperClass;\n-        private Class<?>[] currentInterfaces;\n+    private static class UnregisteredClassLoader extends ClassLoader {\n+        static {\n+            registerAsParallelCapable();\n+        }\n@@ -356,12 +356,2 @@\n-        \/**\n-         * Used only by native code. Construct an UnregisteredClassLoader for loading\n-         * unregistered classes from the specified file. If the file doesn't exist,\n-         * the exception will be caughted by native code which will print a warning message and continue.\n-         *\n-         * @param fileName path of the the JAR file to load unregistered classes from.\n-         *\/\n-        private UnregisteredClassLoader(String fileName) throws InvalidPathException, IOException {\n-            super(toURLArray(fileName), \/*parent*\/null);\n-            currentClassName = null;\n-            currentSuperClass = null;\n-            currentInterfaces = null;\n+        static interface Source {\n+            public byte[] readClassFile(String className) throws IOException;\n@@ -370,3 +360,17 @@\n-        private static URL[] toURLArray(String fileName) throws InvalidPathException, IOException {\n-            if (!((new File(fileName)).exists())) {\n-                throw new IOException(\"No such file: \" + fileName);\n+        static class JarSource implements Source {\n+            private final JarFile jar;\n+\n+            JarSource(File file) throws IOException {\n+                jar = new JarFile(file);\n+            }\n+\n+            @Override\n+            public byte[] readClassFile(String className) throws IOException {\n+                final var entryName = className.replace('.', '\/').concat(\".class\");\n+                final var entry = jar.getEntry(entryName);\n+                if (entry == null) {\n+                    throw new IOException(\"No such entry: \" + entryName + \" in \" + jar.getName());\n+                }\n+                try (final var in = jar.getInputStream(entry)) {\n+                    return in.readAllBytes();\n+                }\n@@ -374,6 +378,0 @@\n-            return new URL[] {\n-                \/\/ Use an intermediate File object to construct a URI\/URL without\n-                \/\/ authority component as URLClassPath can't handle URLs with a UNC\n-                \/\/ server name in the authority component.\n-                Path.of(fileName).toRealPath().toFile().toURI().toURL()\n-            };\n@@ -382,0 +380,2 @@\n+        static class DirSource implements Source {\n+            private final String basePath;\n@@ -383,30 +383,10 @@\n-        \/**\n-         * Load the class of the given <code>\/name<code> from the JAR file that was given to\n-         * the constructor of the current UnregisteredClassLoader instance. This class must be\n-         * a direct subclass of <code>superClass<\/code>. This class must be declared to implement\n-         * the specified <code>interfaces<\/code>.\n-         * <p>\n-         * This method must be called in a single threaded context. It will never be recursed (thus\n-         * the asserts)\n-         *\n-         * @param name the name of the class to be loaded.\n-         * @param superClass must not be null. The named class must have a super class.\n-         * @param interfaces could be null if the named class does not implement any interfaces.\n-         *\/\n-        private Class<?> load(String name, Class<?> superClass, Class<?>[] interfaces)\n-            throws ClassNotFoundException\n-        {\n-            assert currentClassName == null;\n-            assert currentSuperClass == null;\n-            assert currentInterfaces == null;\n-\n-            try {\n-                currentClassName = name;\n-                currentSuperClass = superClass;\n-                currentInterfaces = interfaces;\n-\n-                return findClass(name);\n-            } finally {\n-                currentClassName = null;\n-                currentSuperClass = null;\n-                currentInterfaces = null;\n+            DirSource(File dir) {\n+                assert dir.isDirectory();\n+                basePath = dir.toString();\n+            }\n+\n+            @Override\n+            public byte[] readClassFile(String className) throws IOException {\n+                final var subPath = className.replace('.', File.separatorChar).concat(\".class\");\n+                final var fullPath = Path.of(basePath, subPath);\n+                return Files.readAllBytes(fullPath);\n@@ -416,21 +396,6 @@\n-        \/**\n-         * This method must be called from inside the <code>load()<\/code> method. The <code>\/name<code>\n-         * can be only:\n-         * <ul>\n-         * <li> the <code>name<\/code> parameter for <code>load()<\/code>\n-         * <li> the name of the <code>superClass<\/code> parameter for <code>load()<\/code>\n-         * <li> the name of one of the interfaces in <code>interfaces<\/code> parameter for <code>load()<\/code>\n-         * <ul>\n-         *\n-         * For all other cases, a <code>ClassNotFoundException<\/code> will be thrown.\n-         *\/\n-        protected Class<?> findClass(final String name)\n-            throws ClassNotFoundException\n-        {\n-            Objects.requireNonNull(currentClassName);\n-            Objects.requireNonNull(currentSuperClass);\n-\n-            if (name.equals(currentClassName)) {\n-                \/\/ Note: the following call will call back to <code>this.findClass(name)<\/code> to\n-                \/\/ resolve the super types of the named class.\n-                return super.findClass(name);\n+        private final HashMap<String, Source> sources = new HashMap<>();\n+\n+        private Source resolveSource(String path) throws IOException {\n+            Source source = sources.get(path);\n+            if (source != null) {\n+                return source;\n@@ -438,2 +403,4 @@\n-            if (name.equals(currentSuperClass.getName())) {\n-                return currentSuperClass;\n+\n+            final var file = new File(path);\n+            if (!file.exists()) {\n+                throw new IOException(\"No such file: \" + path);\n@@ -441,6 +408,6 @@\n-            if (currentInterfaces != null) {\n-                for (Class<?> c : currentInterfaces) {\n-                    if (name.equals(c.getName())) {\n-                        return c;\n-                    }\n-                }\n+            if (file.isFile()) {\n+                source = new JarSource(file);\n+            } else if (file.isDirectory()) {\n+                source = new DirSource(file);\n+            } else {\n+                throw new IOException(\"Not a normal file: \" + path);\n@@ -448,0 +415,25 @@\n+            sources.put(path, source);\n+\n+            return source;\n+        }\n+\n+        \/**\n+         * Load the class of the given <code>name<\/code> from the given <code>source<\/code>.\n+         * <p>\n+         * All unregistered super classes and interfaces of the named class must already be loaded\n+         * by this class loader instance.\n+         *\n+         * @param name the name of the class to be loaded.\n+         * @param source path to a directory or a JAR file from which the named class should be\n+         *               loaded.\n+         *\/\n+        private Class<?> load(String name, String source) throws IOException {\n+            final Source resolvedSource = resolveSource(source);\n+            final byte[] bytes = resolvedSource.readClassFile(name);\n+            \/\/ While executing this VM may invoke loadClass() to load supers and interfaces of\n+            \/\/ this unregistered class. This should only happen for registered supers and\n+            \/\/ interfaces because all unregistered ones should have already been loaded by this\n+            \/\/ class loader. Thus it is safe to delegate their loading to system class loader\n+            \/\/ (our parent) - this is what the default implementation of loadClass() will do.\n+            return defineClass(name, bytes, 0, bytes.length);\n+        }\n@@ -449,0 +441,4 @@\n+        @Override\n+        protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            \/\/ Unregistered classes should be found in load(...), registered classes should be\n+            \/\/ handeled by parent loaders\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":83,"deletions":87,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @summary Tests that if a class is listed as unregistered it will be archived\n+ * as such even if it is on classpath (i.e. it will not be loaded by the app\n+ * loader).\n+ *\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/CustomLoadee.java\n+ * @run main ClassFromClasspath\n+ *\/\n+public class ClassFromClasspath {\n+    public static void main(String[] args) throws Exception {\n+        Files.copy(Path.of(System.getProperty(\"test.classes\"), \"CustomLoadee.class\"), Path.of(\"CustomLoadee.class\"));\n+        final String classlist[] = new String[] {\n+            \"java\/lang\/Object id: 0\",\n+            \"CustomLoadee id: 1 super: 0 source: .\",\n+        };\n+        \/\/ Note: if you get a HotSpot crash here in a debug build it is probably because of an\n+        \/\/ assertion in HotSpot CDS code that performs the same check as this test\n+        final OutputAnalyzer out = TestCommon.testDump(null, classlist, \"-Xlog:cds+class=debug\");\n+        out.shouldContain(\"unreg CustomLoadee\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassFromClasspath.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8315130\n+ * @summary Tests archiving a hierarchy of package-private classes loaded from\n+ * different sources.\n+ *\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/DifferentSourcesApp.java test-classes\/CustomLoadee5.java test-classes\/CustomLoadee5Child.java\n+ * @run main DifferentSourcesTest\n+ *\/\n+public class DifferentSourcesTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Setup:\n+        \/\/ - CustomLoadee5 is package-private\n+        \/\/ - CustomLoadee5Child extends CustomLoadee5\n+        \/\/\n+        \/\/ This setup requires CustomLoadee5 and CustomLoadee5Child to be in the\n+        \/\/ same run-time package. Since their package name is the same (empty)\n+        \/\/ this boils down to \"be loaded by the same class loader\".\n+        \/\/\n+        \/\/ DifferentSourcesApp adheres to this requirement.\n+        \/\/\n+        \/\/ This test checks that CDS adheres to this requirement too when\n+        \/\/ creating a static app archive, even if CustomLoadee5 and\n+        \/\/ CustomLoadee5Child are in different sources.\n+\n+        OutputAnalyzer output;\n+\n+        \/\/ The main check: the archive is created without IllegalAccessError\n+        JarBuilder.build(\"base\", \"CustomLoadee5\");\n+        JarBuilder.build(\"sub\", \"CustomLoadee5Child\");\n+        final String classlist[] = new String[] {\n+            \"java\/lang\/Object id: 0\",\n+            \"CustomLoadee5 id: 1 super: 0 source: base.jar\",\n+            \"CustomLoadee5Child id: 2 super: 1 source: sub.jar\",\n+        };\n+        output = TestCommon.testDump(null, classlist);\n+        output.shouldNotContain(\"java.lang.IllegalAccessError: class CustomLoadee5Child cannot access its superclass CustomLoadee5\");\n+        output.shouldNotContain(\"Cannot find CustomLoadee5Child\");\n+\n+        \/\/ Sanity check: the archive is used as expected\n+        output = TestCommon.execCommon(\"-Xlog:class+load\", \"DifferentSourcesApp\");\n+        TestCommon.checkExec(\n+            output,\n+            \"CustomLoadee5 source: shared objects file\",\n+            \"CustomLoadee5Child source: shared objects file\"\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/DifferentSourcesTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class CustomLoadee5 {\n+    public String toString() {\n+        return \"this is CustomLoadee5\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/CustomLoadee5.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class CustomLoadee5Child extends CustomLoadee5 {\n+    public String toString() {\n+        return \"this is CustomLoadee5Child\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/CustomLoadee5Child.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.FileSystems;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+\n+\/**\n+ * See ..\/DifferentSourcesTest.java for details.\n+ *\/\n+public class DifferentSourcesApp {\n+  public static void main(String args[]) throws Exception {\n+    Path base = FileSystems.getDefault().getPath(\"base.jar\");\n+    Path sub = FileSystems.getDefault().getPath(\"sub.jar\");\n+    URL[] urls = new URL[] { base.toUri().toURL(), sub.toUri().toURL() };\n+    URLClassLoader cl = new URLClassLoader(urls, \/* parent = *\/ null);\n+    Class<?> cls = cl.loadClass(\"CustomLoadee5Child\");\n+    System.out.println(cls.getName());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/DifferentSourcesApp.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"}]}