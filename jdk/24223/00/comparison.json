{"files":[{"patch":"@@ -142,0 +142,9 @@\n+\/\/ getCause does not always return cause field so using this is more accurate.\n+static oop get_exception_cause(Handle exception, TRAPS) {\n+  JavaValue cause(T_OBJECT);\n+  JavaCalls::call_virtual(&cause, exception, exception->klass(),\n+                          vmSymbols::getCause_name(), vmSymbols::void_throwable_signature(),\n+                          CHECK_AND_CLEAR_NULL); \/\/ Ignore possible new exceptions\n+  return cause.get_oop();\n+}\n+\n@@ -159,5 +168,7 @@\n-    ResourceMark rm(THREAD);\n-    char* ex_msg = (char*)\"\";\n-    oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n-    if (message != nullptr) {\n-      ex_msg = java_lang_String::as_utf8_string(message);\n+    Handle ex(THREAD, PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    {\n+      ResourceMark rm(THREAD);\n+      const oop msg = java_lang_Throwable::message(ex());\n+      log_warning(cds)(\"%s: %s\", ex->klass()->external_name(),\n+                       msg != nullptr ? java_lang_String::as_utf8_string(msg) : \"\");\n@@ -165,1 +176,8 @@\n-    log_warning(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n+    for (oop cause = get_exception_cause(ex, THREAD); cause != nullptr;\n+         ex.replace(cause), cause = get_exception_cause(ex, THREAD)) {\n+      ResourceMark rm(THREAD);\n+      const oop msg = java_lang_Throwable::message(cause);\n+      log_warning(cds)(\"\\tCaused by: %s: %s\", cause->klass()->external_name(),\n+                       msg != nullptr ? java_lang_String::as_utf8_string(msg) : \"\");\n+    }\n+\n@@ -168,1 +186,0 @@\n-    CLEAR_PENDING_EXCEPTION;\n@@ -397,1 +414,1 @@\n-objArrayOop ClassListParser::get_specified_interfaces(TRAPS) {\n+GrowableArray<InstanceKlass *> ClassListParser::get_specified_interfaces() {\n@@ -399,8 +416,3 @@\n-  if (n == 0) {\n-    return nullptr;\n-  } else {\n-    objArrayOop array = oopFactory::new_objArray(vmClasses::Class_klass(), n, CHECK_NULL);\n-    for (int i = 0; i < n; i++) {\n-      array->obj_at_put(i, lookup_class_by_id(_interfaces->at(i))->java_mirror());\n-    }\n-    return array;\n+  GrowableArray<InstanceKlass *> specified_interfaces(n);\n+  for (int i = 0; i < n; i++) {\n+    specified_interfaces.append(lookup_class_by_id(_interfaces->at(i)));\n@@ -408,0 +420,1 @@\n+  return specified_interfaces;\n@@ -535,1 +548,0 @@\n-  char * source_path = os::strdup_check_oom(ClassLoader::uri_to_path(_source));\n@@ -537,5 +549,5 @@\n-  Handle super_class(THREAD, specified_super->java_mirror());\n-  objArrayOop r = get_specified_interfaces(CHECK_NULL);\n-  objArrayHandle interfaces(THREAD, r);\n-  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path,\n-                                                     super_class, interfaces, CHECK_NULL);\n+  GrowableArray<InstanceKlass*> specified_interfaces = get_specified_interfaces();\n+\n+  const char* source_path = ClassLoader::uri_to_path(_source);\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path, CHECK_NULL);\n+\n@@ -553,0 +565,9 @@\n+  for (int i = 0; i < _interfaces->length(); i++) {\n+    InstanceKlass* specified_interface = specified_interfaces.at(i);\n+    if (!k->local_interfaces()->contains(specified_interface)) {\n+      print_specified_interfaces();\n+      print_actual_interfaces(k);\n+      error(\"Specified interface %s (id %d) is not directly implemented\",\n+            specified_interface->external_name(), _interfaces->at(i));\n+      }\n+  }\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":43,"deletions":22,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-  objArrayOop get_specified_interfaces(TRAPS);\n+  GrowableArray<InstanceKlass*> get_specified_interfaces();\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,4 +27,0 @@\n-#include \"classfile\/classFileStream.hpp\"\n-#include \"classfile\/classLoader.inline.hpp\"\n-#include \"classfile\/classLoaderExt.hpp\"\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -34,2 +30,0 @@\n-#include \"memory\/oopFactory.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n@@ -37,0 +31,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -38,0 +33,1 @@\n+#include \"runtime\/handles.hpp\"\n@@ -43,0 +39,1 @@\n+static OopHandle _unregistered_class_loader;\n@@ -50,0 +47,6 @@\n+\n+    precond(_unregistered_class_loader.is_empty());\n+    HandleMark hm(THREAD);\n+    const Handle cl = JavaCalls::construct_new_instance(UnregisteredClassLoader_klass(),\n+                                                        vmSymbols::void_method_signature(), CHECK);\n+    _unregistered_class_loader = OopHandle(Universe::vm_global(), cl());\n@@ -56,2 +59,1 @@\n-InstanceKlass* UnregisteredClasses::load_class(Symbol* name, const char* path,\n-                                               Handle super_class, objArrayHandle interfaces, TRAPS) {\n+InstanceKlass* UnregisteredClasses::load_class(Symbol* name, const char* path, TRAPS) {\n@@ -65,28 +67,2 @@\n-  \/\/ Call CDS$UnregisteredClassLoader::load(String name, Class<?> superClass, Class<?>[] interfaces)\n-  Symbol* methodName = SymbolTable::new_symbol(\"load\");\n-  Symbol* methodSignature = SymbolTable::new_symbol(\"(Ljava\/lang\/String;Ljava\/lang\/Class;[Ljava\/lang\/Class;)Ljava\/lang\/Class;\");\n-  Symbol* path_symbol = SymbolTable::new_symbol(path);\n-  Handle classloader = get_classloader(path_symbol, CHECK_NULL);\n-  Handle ext_class_name = java_lang_String::externalize_classname(name, CHECK_NULL);\n-\n-  JavaValue result(T_OBJECT);\n-  JavaCallArguments args(3);\n-  args.set_receiver(classloader);\n-  args.push_oop(ext_class_name);\n-  args.push_oop(super_class);\n-  args.push_oop(interfaces);\n-  JavaCalls::call_virtual(&result,\n-                          UnregisteredClassLoader_klass(),\n-                          methodName,\n-                          methodSignature,\n-                          &args,\n-                          CHECK_NULL);\n-  assert(result.get_type() == T_OBJECT, \"just checking\");\n-  oop obj = result.get_oop();\n-  return InstanceKlass::cast(java_lang_Class::as_Klass(obj));\n-}\n-\n-class UnregisteredClasses::ClassLoaderTable : public ResourceHashtable<\n-  Symbol*, OopHandle,\n-  137, \/\/ prime number\n-  AnyObj::C_HEAP> {};\n+  assert(!_unregistered_class_loader.is_empty(), \"not initialized\");\n+  Handle classloader(THREAD, _unregistered_class_loader.resolve());\n@@ -94,1 +70,6 @@\n-static UnregisteredClasses::ClassLoaderTable* _classloader_table = nullptr;\n+  oop obj;\n+  { \/\/ Call CDS$UnregisteredClassLoader::load(String name, String source)\n+    Symbol* methodName = SymbolTable::new_symbol(\"load\");\n+    Symbol* methodSignature = SymbolTable::new_symbol(\"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/Class;\");\n+    Handle ext_class_name = java_lang_String::externalize_classname(name, CHECK_NULL);\n+    Handle path_string = java_lang_String::create_from_str(path, CHECK_NULL);\n@@ -96,23 +77,11 @@\n-Handle UnregisteredClasses::create_classloader(Symbol* path, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  JavaValue result(T_OBJECT);\n-  Handle path_string = java_lang_String::create_from_str(path->as_C_string(), CHECK_NH);\n-  Handle classloader = JavaCalls::construct_new_instance(\n-                           UnregisteredClassLoader_klass(),\n-                           vmSymbols::string_void_signature(),\n-                           path_string, CHECK_NH);\n-  return classloader;\n-}\n-\n-Handle UnregisteredClasses::get_classloader(Symbol* path, TRAPS) {\n-  if (_classloader_table == nullptr) {\n-    _classloader_table = new (mtClass)ClassLoaderTable();\n-  }\n-  OopHandle* classloader_ptr = _classloader_table->get(path);\n-  if (classloader_ptr != nullptr) {\n-    return Handle(THREAD, (*classloader_ptr).resolve());\n-  } else {\n-    Handle classloader = create_classloader(path, CHECK_NH);\n-    _classloader_table->put(path, OopHandle(Universe::vm_global(), classloader()));\n-    path->increment_refcount();\n-    return classloader;\n+    JavaValue result(T_OBJECT);\n+    JavaCalls::call_virtual(&result,\n+                            classloader,\n+                            UnregisteredClassLoader_klass(),\n+                            methodName,\n+                            methodSignature,\n+                            ext_class_name,\n+                            path_string,\n+                            CHECK_NULL);\n+    assert(result.get_type() == T_OBJECT, \"just checking\");\n+    obj = result.get_oop();\n@@ -120,0 +89,2 @@\n+\n+  return InstanceKlass::cast(java_lang_Class::as_Klass(obj));\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":31,"deletions":60,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -36,3 +36,1 @@\n-  static InstanceKlass* load_class(Symbol* h_name, const char* path,\n-                                   Handle super_class, objArrayHandle interfaces,\n-                                   TRAPS);\n+  static InstanceKlass* load_class(Symbol* name, const char* path, TRAPS);\n@@ -44,2 +42,0 @@\n-  class ClassLoaderTable;\n-\n@@ -49,3 +45,0 @@\n-\n-  static Handle create_classloader(Symbol* path, TRAPS);\n-  static Handle get_classloader(Symbol* path, TRAPS);\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -340,0 +340,18 @@\n+    \/**\n+     * Finds the Resource with the specified name on the specified URL. Returns\n+     * null if no Resource could be found, including the case when the URL is\n+     * not in the search path.\n+     *\n+     * @param name the name of the Resource\n+     * @param url  the URL to look in\n+     * @return the Resource, or null if not found\n+     *\/\n+    public Resource getResource(String name, URL url) {\n+        final String urlNoFragString = URLUtil.urlNoFragString(url);\n+        Loader loader;\n+        \/\/ Open available URLs until we reach the requested one\n+        while ((loader = lmap.get(urlNoFragString)) == null && getLoader(loaders.size()) != null) {}\n+        \/\/ loader == null if either the URL is not in the path or it cannot be opened\n+        return loader != null ? loader.getResource(name) : null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -36,1 +38,0 @@\n-import java.nio.file.InvalidPathException;\n@@ -46,0 +47,2 @@\n+import jdk.internal.loader.Resource;\n+import jdk.internal.loader.URLClassPath;\n@@ -352,21 +355,9 @@\n-        private String currentClassName;\n-        private Class<?> currentSuperClass;\n-        private Class<?>[] currentInterfaces;\n-\n-        \/**\n-         * Used only by native code. Construct an UnregisteredClassLoader for loading\n-         * unregistered classes from the specified file. If the file doesn't exist,\n-         * the exception will be caughted by native code which will print a warning message and continue.\n-         *\n-         * @param fileName path of the the JAR file to load unregistered classes from.\n-         *\/\n-        private UnregisteredClassLoader(String fileName) throws InvalidPathException, IOException {\n-            super(toURLArray(fileName), \/*parent*\/null);\n-            currentClassName = null;\n-            currentSuperClass = null;\n-            currentInterfaces = null;\n-        }\n-\n-        private static URL[] toURLArray(String fileName) throws InvalidPathException, IOException {\n-            if (!((new File(fileName)).exists())) {\n-                throw new IOException(\"No such file: \" + fileName);\n+        \/** Class<?> URLClassLoader::defineClass(String name, Resource res) *\/\n+        private static final Method DEFINE_CLASS;\n+        static {\n+            try {\n+                DEFINE_CLASS = URLClassLoader.class.getDeclaredMethod(\n+                    \"defineClass\", String.class, Resource.class\n+                );\n+            } catch (NoSuchMethodException e) {\n+                throw new InternalError(e);\n@@ -374,6 +365,2 @@\n-            return new URL[] {\n-                \/\/ Use an intermediate File object to construct a URI\/URL without\n-                \/\/ authority component as URLClassPath can't handle URLs with a UNC\n-                \/\/ server name in the authority component.\n-                Path.of(fileName).toRealPath().toFile().toURI().toURL()\n-            };\n+            assert DEFINE_CLASS.getReturnType() == Class.class;\n+            DEFINE_CLASS.setAccessible(true);\n@@ -382,1 +369,0 @@\n-\n@@ -384,4 +370,1 @@\n-         * Load the class of the given <code>\/name<code> from the JAR file that was given to\n-         * the constructor of the current UnregisteredClassLoader instance. This class must be\n-         * a direct subclass of <code>superClass<\/code>. This class must be declared to implement\n-         * the specified <code>interfaces<\/code>.\n+         * Collection of all sources used so far.\n@@ -389,6 +372,3 @@\n-         * This method must be called in a single threaded context. It will never be recursed (thus\n-         * the asserts)\n-         *\n-         * @param name the name of the class to be loaded.\n-         * @param superClass must not be null. The named class must have a super class.\n-         * @param interfaces could be null if the named class does not implement any interfaces.\n+         * URLClassLoader also has this but we use it in a different way: we\n+         * request resources from specific sources rather than from the first\n+         * source in the list that has a resource with the requested name.\n@@ -396,6 +376,1 @@\n-        private Class<?> load(String name, Class<?> superClass, Class<?>[] interfaces)\n-            throws ClassNotFoundException\n-        {\n-            assert currentClassName == null;\n-            assert currentSuperClass == null;\n-            assert currentInterfaces == null;\n+        private final URLClassPath ucp = new URLClassPath(new URL[0]);\n@@ -403,11 +378,8 @@\n-            try {\n-                currentClassName = name;\n-                currentSuperClass = superClass;\n-                currentInterfaces = interfaces;\n-\n-                return findClass(name);\n-            } finally {\n-                currentClassName = null;\n-                currentSuperClass = null;\n-                currentInterfaces = null;\n-            }\n+        \/**\n+         * Used only by native code. Construct an UnregisteredClassLoader for loading\n+         * unregistered classes.\n+         *\/\n+        private UnregisteredClassLoader() {\n+            \/\/ Parent is not set to null: we will delegate to system class loader to load registered\n+            \/\/ supers and interfaces of unregistered classes\n+            super(new URL[0]);\n@@ -417,7 +389,4 @@\n-         * This method must be called from inside the <code>load()<\/code> method. The <code>\/name<code>\n-         * can be only:\n-         * <ul>\n-         * <li> the <code>name<\/code> parameter for <code>load()<\/code>\n-         * <li> the name of the <code>superClass<\/code> parameter for <code>load()<\/code>\n-         * <li> the name of one of the interfaces in <code>interfaces<\/code> parameter for <code>load()<\/code>\n-         * <ul>\n+         * Load the class of the given <code>name<\/code> from the given <code>source<\/code>.\n+         * <p>\n+         * All unregistered super classes and interfaces of the named class must already be loaded\n+         * by this class loader instance.\n@@ -425,1 +394,3 @@\n-         * For all other cases, a <code>ClassNotFoundException<\/code> will be thrown.\n+         * @param name the name of the class to be loaded.\n+         * @param source path to a directory or a JAR file from which the named class should be\n+         *               loaded.\n@@ -427,10 +398,6 @@\n-        protected Class<?> findClass(final String name)\n-            throws ClassNotFoundException\n-        {\n-            Objects.requireNonNull(currentClassName);\n-            Objects.requireNonNull(currentSuperClass);\n-\n-            if (name.equals(currentClassName)) {\n-                \/\/ Note: the following call will call back to <code>this.findClass(name)<\/code> to\n-                \/\/ resolve the super types of the named class.\n-                return super.findClass(name);\n+        private Class<?> load(String name, String source) throws ClassNotFoundException {\n+            final URL sourceUrl;\n+            try {\n+                sourceUrl = Path.of(source).toRealPath().toUri().toURL(); \/\/ toRealPath also checks existance\n+            } catch (IOException e) {\n+                throw new IllegalArgumentException(\"Invalid class source: \" + source, e);\n@@ -438,2 +405,8 @@\n-            if (name.equals(currentSuperClass.getName())) {\n-                return currentSuperClass;\n+            ucp.addURL(sourceUrl);\n+\n+            \/\/ Almost like URLClassLoader.findClass(...), the main difference is that we request\n+            \/\/ .class file from the specific source\n+            final String path = name.replace('.', '\/').concat(\".class\");\n+            final Resource res = ucp.getResource(path, sourceUrl);\n+            if (res == null) {\n+                throw new ClassNotFoundException(name + \": cannot get \" + path + \" from \" + source);\n@@ -441,4 +414,19 @@\n-            if (currentInterfaces != null) {\n-                for (Class<?> c : currentInterfaces) {\n-                    if (name.equals(c.getName())) {\n-                        return c;\n+            try {\n+                \/\/ While executing this VM may invoke loadClass() to load supers and interfaces of\n+                \/\/ this unregistered class. This should only happen for registered supers and\n+                \/\/ interfaces because all unregistered ones should have already been loaded by this\n+                \/\/ class loader. Thus it is safe to delegate their loading to system class loader\n+                \/\/ (our parent) - this is what the default implementation of loadClass() will do.\n+                return (Class<?>) DEFINE_CLASS.invoke(this, name, res);\n+            } catch (IllegalAccessException e) {\n+                throw new AssertionError(\"defineClass not accessible\", e); \/\/ Should not happen\n+            } catch (InvocationTargetException ite) {\n+                final Throwable cause = ite.getCause();\n+                switch (cause) {\n+                    \/\/ Special handling as in URLClassLoader.findClass(...)\n+                    case IOException e -> throw new ClassNotFoundException(name, e);\n+                    case ClassFormatError e -> {\n+                        if (res.getDataError() != null) {\n+                            e.addSuppressed(res.getDataError());\n+                        }\n+                        throw e;\n@@ -446,0 +434,5 @@\n+                    \/\/ Other\n+                    case Error e -> throw e;\n+                    case RuntimeException e -> throw e;\n+                    case null -> throw new ClassNotFoundException(name, ite);\n+                    default -> throw new ClassNotFoundException(name, cause);\n@@ -448,0 +441,1 @@\n+        }\n@@ -449,0 +443,4 @@\n+        @Override\n+        protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            \/\/ Unregistered classes should be found in load(...), registered classes should be\n+            \/\/ handeled by parent loaders\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":78,"deletions":80,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-            \"java.io.IOException: No such file: no_such_file.jar\");\n+            \"java.lang.IllegalArgumentException: Invalid class source: no_such_file.jar\",\n+            \"Caused by: java.nio.file.NoSuchFileException\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatE.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8315130\n+ * @summary Tests archiving a hierarchy of package-private classes loaded from\n+ * different sources.\n+ *\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/DifferentSourcesApp.java test-classes\/CustomLoadee5.java test-classes\/CustomLoadee5Child.java\n+ * @run main DifferentSourcesTest\n+ *\/\n+public class DifferentSourcesTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Setup:\n+        \/\/ - CustomLoadee5 is package-private\n+        \/\/ - CustomLoadee5Child extends CustomLoadee5\n+        \/\/\n+        \/\/ This setup requires CustomLoadee5 and CustomLoadee5Child to be in the\n+        \/\/ same run-time package. Since their package name is the same (empty)\n+        \/\/ this boils down to \"be loaded by the same class loader\".\n+        \/\/\n+        \/\/ DifferentSourcesApp adheres to this requirement.\n+        \/\/\n+        \/\/ This test checks that CDS adheres to this requirement too when\n+        \/\/ creating a static app archive, even if CustomLoadee5 and\n+        \/\/ CustomLoadee5Child are in different sources.\n+\n+        OutputAnalyzer output;\n+\n+        \/\/ The main check: the archive is created without IllegalAccessError\n+        JarBuilder.build(\"base\", \"CustomLoadee5\");\n+        JarBuilder.build(\"sub\", \"CustomLoadee5Child\");\n+        final String classlist[] = new String[] {\n+            \"java\/lang\/Object id: 0\",\n+            \"CustomLoadee5 id: 1 super: 0 source: base.jar\",\n+            \"CustomLoadee5Child id: 2 super: 1 source: sub.jar\",\n+        };\n+        output = TestCommon.testDump(null, classlist);\n+        output.shouldNotContain(\"java.lang.IllegalAccessError: class CustomLoadee5Child cannot access its superclass CustomLoadee5\");\n+        output.shouldNotContain(\"Cannot find CustomLoadee5Child\");\n+\n+        \/\/ Sanity check: the archive is used as expected\n+        output = TestCommon.execCommon(\"-Xlog:class+load\", \"DifferentSourcesApp\");\n+        TestCommon.checkExec(\n+            output,\n+            \"CustomLoadee5 source: shared objects file\",\n+            \"CustomLoadee5Child source: shared objects file\"\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/DifferentSourcesTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class CustomLoadee5 {\n+    public String toString() {\n+        return \"this is CustomLoadee5\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/CustomLoadee5.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class CustomLoadee5Child extends CustomLoadee5 {\n+    public String toString() {\n+        return \"this is CustomLoadee5Child\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/CustomLoadee5Child.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.FileSystems;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+\n+\/**\n+ * See ..\/DifferentSourcesTest.java for details.\n+ *\/\n+public class DifferentSourcesApp {\n+  public static void main(String args[]) throws Exception {\n+    Path base = FileSystems.getDefault().getPath(\"base.jar\");\n+    Path sub = FileSystems.getDefault().getPath(\"sub.jar\");\n+    URL[] urls = new URL[] { base.toUri().toURL(), sub.toUri().toURL() };\n+    URLClassLoader cl = new URLClassLoader(urls, \/* parent = *\/ null);\n+    Class<?> cls = cl.loadClass(\"CustomLoadee5Child\");\n+    System.out.println(cls.getName());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/DifferentSourcesApp.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"}]}