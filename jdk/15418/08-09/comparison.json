{"files":[{"patch":"@@ -145,0 +145,5 @@\n+int MutableNUMASpace::lgrp_space_index(int lgrp_id) const {\n+  return lgrp_spaces()->find_if([&](LGRPSpace* space) {\n+    return space->lgrp_id() == checked_cast<uint>(lgrp_id);\n+  });\n+}\n@@ -163,4 +168,1 @@\n-  int i = lgrp_spaces()->find_if([&](LGRPSpace* space) {\n-    return space->lgrp_id() == (uint)lgrp_id;\n-  });\n-\n+  int i = lgrp_space_index(lgrp_id);\n@@ -185,3 +187,1 @@\n-  int i = lgrp_spaces()->find_if([&](LGRPSpace* space) {\n-    return space->lgrp_id() == (uint)lgrp_id;\n-  });\n+  int i = lgrp_space_index(lgrp_id);\n@@ -207,3 +207,1 @@\n-  int i = lgrp_spaces()->find_if([&](LGRPSpace* space) {\n-    return space->lgrp_id() == (uint)lgrp_id;\n-  });\n+  int i = lgrp_space_index(lgrp_id);\n@@ -592,3 +590,1 @@\n-  int i = lgrp_spaces()->find_if([&](LGRPSpace* space) {\n-    return space->lgrp_id() == (uint)lgrp_id;\n-  });\n+  int i = lgrp_space_index(lgrp_id);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -99,4 +99,0 @@\n-    static bool equals(uint* lgrp_id_value, LGRPSpace* const& p) {\n-      return *lgrp_id_value == p->lgrp_id();\n-    }\n-\n@@ -167,0 +163,2 @@\n+  int lgrp_space_index(int lgrp_id) const;\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,7 +122,0 @@\n-bool GrowableCache::equals(GrowableElement* e1, GrowableElement* const& e2) {\n-  assert(e1 != nullptr, \"e1 != nullptr\");\n-  assert(e2 != nullptr, \"e2 != nullptr\");\n-\n-  return e1->equals(e2);\n-}\n-\n@@ -165,2 +158,2 @@\n-int GrowableCache::find(GrowableElement* e) {\n-  return _elements->find_if([&](GrowableElement* other_e) { return e->equals(other_e); });\n+int GrowableCache::find(const GrowableElement* e) const {\n+  return _elements->find_if([&](const GrowableElement* other_e) { return e->equals(other_e); });\n@@ -218,1 +211,1 @@\n-bool JvmtiBreakpoint::equals(JvmtiBreakpoint& bp) {\n+bool JvmtiBreakpoint::equals(const JvmtiBreakpoint& bp) const {\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -69,3 +69,3 @@\n-  virtual address getCacheValue()                =0;\n-  virtual bool equals(const GrowableElement* e)  =0;\n-  virtual GrowableElement *clone()               =0;\n+  virtual address getCacheValue()                     =0;\n+  virtual bool equals(const GrowableElement* e) const =0;\n+  virtual GrowableElement* clone()                    =0;\n@@ -107,1 +107,1 @@\n-  int find(GrowableElement* e);\n+  int find(const GrowableElement* e) const;\n@@ -168,1 +168,1 @@\n-  bool equals(JvmtiBreakpoint& bp);\n+  bool equals(const JvmtiBreakpoint& bp) const;\n@@ -180,1 +180,1 @@\n-  bool equals(const GrowableElement* e) { return equals((JvmtiBreakpoint&) *e); }\n+  bool equals(const GrowableElement* e) const { return equals((const JvmtiBreakpoint&) *e); }\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -188,0 +188,4 @@\n+bool PerfData::name_equals(const char* name) const {\n+  return strcmp(name, this->name()) == 0;\n+}\n+\n@@ -505,6 +509,2 @@\n-  auto name_predicate = [&](PerfData* pd) {\n-    if (pd == nullptr)\n-      return false;\n-    return strcmp((const char*)name, pd->name()) == 0;\n-  };\n-  int i = _set->find_if(name_predicate);\n+\n+  int i = _set->find_if([&](PerfData* pd) { return pd->name_equals(name); });\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -322,1 +322,2 @@\n-    const char* name() { return _name; }\n+    const char* name() const  { return _name; }\n+    bool name_equals(const char* name) const;\n@@ -578,0 +579,4 @@\n+\n+    \/\/ method to search for a instrumentation object by name\n+    static bool by_name(const char* name, PerfData* pd);\n+\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -74,5 +74,0 @@\n-\n-bool match_oop_entry(oop *op, const UnhandledOopEntry& e) {\n-  return (const_cast<UnhandledOopEntry&>(e).oop_ptr() == op);\n-}\n-\n@@ -86,4 +81,3 @@\n-  auto predicate = [&](const UnhandledOopEntry& e) {\n-    return (const_cast<UnhandledOopEntry&>(e).oop_ptr() == op);\n-  };\n-  int i = _oop_list->find_from_end_if(predicate);\n+  int i = _oop_list->find_from_end_if([&](const UnhandledOopEntry& e) {\n+    return e.match_oop_entry(op);\n+  });\n@@ -110,4 +104,4 @@\n-  auto predicate = [&](const UnhandledOopEntry& e) {\n-    return (const_cast<UnhandledOopEntry&>(e).oop_ptr() == op);\n-  };\n-  int i = _oop_list->find_from_end_if(predicate);\n+\n+  int i = _oop_list->find_from_end_if([&](const UnhandledOopEntry& e) {\n+    return e.match_oop_entry(op);\n+  });\n","filename":"src\/hotspot\/share\/runtime\/unhandledOops.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -56,0 +56,5 @@\n+\n+  bool match_oop_entry(oop* op) const {\n+    return _oop_ptr == op;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/unhandledOops.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -147,0 +147,4 @@\n+bool DCmdInfo::name_equals(const char* name) const {\n+  return strcmp(name, this->name()) == 0;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+  bool name_equals(const char* cmd_name) const;\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2007,5 +2007,3 @@\n-    auto name_predicate = [&](DCmdInfo* info) {\n-        if (info == nullptr) return false;\n-        return strcmp((const char*)cmd_name, info->name()) == 0;\n-    };\n-    int pos = info_list->find_if(name_predicate);\n+    int pos = info_list->find_if([&](DCmdInfo* info) {\n+      return info->name_equals(cmd_name);\n+    });\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -212,2 +212,7 @@\n-  template<typename F>\n-  int find_if(F f) const {\n+  \/\/ Find first element that matches the given predicate.\n+  \/\/\n+  \/\/ Predicate: bool predicate(const E& elem)\n+  \/\/\n+  \/\/ Returns the index of the element or -1 if no element matches the predicate\n+  template<typename Predicate>\n+  int find_if(Predicate predicate) const {\n@@ -215,3 +220,2 @@\n-      if (f(_data[i])) return i;\n-    }\n-    return -1;\n+      if (predicate(_data[i])) return i;\n+    }    return -1;\n@@ -220,2 +224,7 @@\n-  template<typename F>\n-  int find_from_end_if(F f) const {\n+  \/\/ Find last element that matches the given predicate.\n+  \/\/\n+  \/\/ Predicate: bool predicate(const E& elem)\n+  \/\/\n+  \/\/ Returns the index of the element or -1 if no element matches the predicate\n+  template<typename Predicate>\n+  int find_from_end_if(Predicate predicate) const {\n@@ -224,1 +233,1 @@\n-      if (f(_data[i])) return i;\n+      if (predicate(_data[i])) return i;\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -604,0 +604,63 @@\n+\n+\n+TEST(GrowableArrayCHeap, find_if) {\n+  struct Element {\n+    int value;\n+  };\n+  GrowableArrayCHeap<Element, mtTest> array;\n+  array.push({1});\n+  array.push({2});\n+  array.push({3});\n+\n+  {\n+    int index = array.find_if([&](const Element& elem) {\n+      return elem.value == 1;\n+    });\n+    ASSERT_EQ(index, 0);\n+  }\n+\n+  {\n+    int index = array.find_if([&](const Element& elem) {\n+      return elem.value > 1;\n+    });\n+    ASSERT_EQ(index, 1);\n+  }\n+\n+  {\n+    int index = array.find_if([&](const Element& elem) {\n+      return elem.value == 4;\n+    });\n+    ASSERT_EQ(index, -1);\n+  }\n+}\n+\n+TEST(GrowableArrayCHeap, find_from_end_if) {\n+  struct Element {\n+    int value;\n+  };\n+  GrowableArrayCHeap<Element, mtTest> array;\n+  array.push({1});\n+  array.push({2});\n+  array.push({3});\n+\n+  {\n+    int index = array.find_from_end_if([&](const Element& elem) {\n+      return elem.value == 1;\n+    });\n+    ASSERT_EQ(index, 0);\n+  }\n+\n+  {\n+    int index = array.find_from_end_if([&](const Element& elem) {\n+      return elem.value > 1;\n+    });\n+    ASSERT_EQ(index, 2);\n+  }\n+\n+  {\n+    int index = array.find_from_end_if([&](const Element& elem) {\n+      return elem.value == 4;\n+    });\n+    ASSERT_EQ(index, -1);\n+  }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/utilities\/test_growableArray.cpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"}]}