{"files":[{"patch":"@@ -2310,4 +2310,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1006,4 +1006,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2153,4 +2153,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1969,4 +1969,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1480,4 +1480,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3132,0 +3132,7 @@\n+void Assembler::kxnorbl(KRegister dst, KRegister src1, KRegister src2) {\n+  assert(VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(AVX_256bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x46, (0xC0 | encode));\n+}\n+\n@@ -3139,0 +3146,7 @@\n+void Assembler::kxnorql(KRegister dst, KRegister src1, KRegister src2) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(AVX_256bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x46, (0xC0 | encode));\n+}\n+\n@@ -3277,7 +3291,0 @@\n-void Assembler::kxnorbl(KRegister dst, KRegister src1, KRegister src2) {\n-  assert(VM_Version::supports_avx512dq(), \"\");\n-  InstructionAttr attributes(AVX_256bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16(0x46, (0xC0 | encode));\n-}\n-\n@@ -11638,3 +11645,3 @@\n-void Assembler::evbroadcasti32x4(XMMRegister dst, Address src, int vector_len) {\n-  assert(vector_len != Assembler::AVX_128bit, \"\");\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::vbroadcasti128(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx2(), \"\");\n+  assert(vector_len == AVX_256bit || vector_len == AVX_512bit, \"\");\n@@ -11644,1 +11651,0 @@\n-  attributes.set_rex_vex_w_reverted();\n@@ -11652,0 +11658,7 @@\n+void Assembler::evbroadcasti32x4(XMMRegister dst, Address src, int vector_len) {\n+  assert(vector_len != Assembler::AVX_128bit, \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  vbroadcasti128(dst, src, vector_len);\n+}\n+\n@@ -11675,0 +11688,14 @@\n+void Assembler::evbroadcasti64x4(XMMRegister dst, Address src, int vector_len) {\n+  assert(vector_len == Assembler::AVX_512bit, \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T4, \/* input_size_in_bits *\/ EVEX_64bit);\n+  \/\/ swap src<->dst for encoding\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x5B);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -11723,1 +11750,1 @@\n-  assert(vector_len == AVX_256bit, \"\");\n+  assert(vector_len == AVX_256bit || vector_len == AVX_512bit, \"\");\n@@ -11734,0 +11761,13 @@\n+void Assembler::evbroadcastf64x4(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit, \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T4, \/* input_size_in_bits *\/ EVEX_64bit);\n+  \/\/ swap src<->dst for encoding\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x1B);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":52,"deletions":12,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1679,0 +1679,1 @@\n+  void kxnorbl(KRegister dst, KRegister src1, KRegister src2);\n@@ -1680,0 +1681,1 @@\n+  void kxnorql(KRegister dst, KRegister src1, KRegister src2);\n@@ -1711,1 +1713,0 @@\n-  void kxnorbl(KRegister dst, KRegister src1, KRegister src2);\n@@ -3027,0 +3028,1 @@\n+  void vbroadcasti128(XMMRegister dst, Address src, int vector_len);\n@@ -3031,0 +3033,1 @@\n+  void evbroadcasti64x4(XMMRegister dst, Address src, int vector_len);\n@@ -3038,0 +3041,1 @@\n+  void evbroadcastf64x4(XMMRegister dst, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1736,2 +1736,3 @@\n-void C2_MacroAssembler::load_vector(XMMRegister dst, Address src, int vlen_in_bytes) {\n-  switch (vlen_in_bytes) {\n+void C2_MacroAssembler::load_vector(BasicType bt, XMMRegister dst, Address src, int vlen_in_bytes) {\n+  if (is_integral_type(bt)) {\n+    switch (vlen_in_bytes) {\n@@ -1744,0 +1745,10 @@\n+    }\n+  } else {\n+    switch (vlen_in_bytes) {\n+    case 4:  movflt(dst, src); break;\n+    case 8:  movdbl(dst, src); break;\n+    case 16: movups(dst, src); break;\n+    case 32: vmovups(dst, src, Assembler::AVX_256bit); break;\n+    case 64: vmovups(dst, src, Assembler::AVX_512bit); break;\n+    default: ShouldNotReachHere();\n+    }\n@@ -1747,1 +1758,1 @@\n-void C2_MacroAssembler::load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch) {\n+void C2_MacroAssembler::load_vector(BasicType bt, XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch) {\n@@ -1751,1 +1762,1 @@\n-    load_vector(dst, as_Address(src), vlen_in_bytes);\n+    load_vector(bt, dst, as_Address(src), vlen_in_bytes);\n@@ -1754,1 +1765,1 @@\n-    load_vector(dst, Address(rscratch, 0), vlen_in_bytes);\n+    load_vector(bt, dst, Address(rscratch, 0), vlen_in_bytes);\n@@ -1758,1 +1769,1 @@\n-void C2_MacroAssembler::load_constant_vector(BasicType bt, XMMRegister dst, InternalAddress src, int vlen) {\n+void C2_MacroAssembler::load_constant_vector(BasicType bt, XMMRegister dst, InternalAddress src, int width, int vlen) {\n@@ -1760,13 +1771,11 @@\n-  if (VM_Version::supports_avx()) {\n-    if (bt == T_LONG) {\n-      if (VM_Version::supports_avx2()) {\n-        vpbroadcastq(dst, src, vlen_enc);\n-      } else {\n-        vmovddup(dst, src, vlen_enc);\n-      }\n-    } else if (bt == T_DOUBLE) {\n-      if (vlen_enc != Assembler::AVX_128bit) {\n-        vbroadcastsd(dst, src, vlen_enc, noreg);\n-      } else {\n-        vmovddup(dst, src, vlen_enc);\n-      }\n+  if (width == vlen) {\n+    load_vector(bt, dst, as_Address(src), vlen);\n+    return;\n+  }\n+  if (is_integral_type(bt) && VM_Version::supports_avx2()) {\n+    if (width == 4) {\n+      vpbroadcastd(dst, as_Address(src), vlen_enc);\n+    } else if (width == 8) {\n+      vpbroadcastq(dst, as_Address(src), vlen_enc);\n+    } else if (width == 16) {\n+      vbroadcasti128(dst, as_Address(src), vlen_enc);\n@@ -1774,2 +1783,9 @@\n-      if (VM_Version::supports_avx2() && is_integral_type(bt)) {\n-        vpbroadcastd(dst, src, vlen_enc);\n+      assert(width == 32, \"\");\n+      evbroadcasti64x4(dst, as_Address(src), vlen_enc);\n+    }\n+  } else if (VM_Version::supports_avx()) {\n+    if (width == 4) {\n+      vbroadcastss(dst, as_Address(src), vlen_enc);\n+    } else if (width == 8) {\n+      if (vlen_enc == AVX_128bit) {\n+        vmovddup(dst, as_Address(src), vlen_enc);\n@@ -1777,1 +1793,1 @@\n-        vbroadcastss(dst, src, vlen_enc);\n+        vbroadcastsd(dst, as_Address(src), vlen_enc);\n@@ -1779,0 +1795,5 @@\n+    } else if (width == 16) {\n+      vbroadcastf128(dst, as_Address(src), vlen_enc);\n+    } else {\n+      assert(width == 32, \"\");\n+      evbroadcastf64x4(dst, as_Address(src), vlen_enc);\n@@ -1780,2 +1801,0 @@\n-  } else if (VM_Version::supports_sse3()) {\n-    movddup(dst, src);\n@@ -1783,4 +1802,2 @@\n-    movq(dst, src);\n-    if (vlen == 16) {\n-      punpcklqdq(dst, dst);\n-    }\n+    assert(width == 8, \"\");\n+    movddup(dst, as_Address(src));\n@@ -1797,1 +1814,1 @@\n-  load_vector(dst, addr, vlen_in_bytes);\n+  load_vector(T_BYTE, dst, addr, vlen_in_bytes);\n@@ -3487,1 +3504,1 @@\n-  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+  load_vector(eltype, dst, src, arrays_hashcode_elsize(eltype) * 8);\n@@ -3491,1 +3508,1 @@\n-  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+  load_vector(eltype, dst, src, arrays_hashcode_elsize(eltype) * 8);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":48,"deletions":31,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -130,2 +130,2 @@\n-  void load_vector(XMMRegister dst, Address        src, int vlen_in_bytes);\n-  void load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch = noreg);\n+  void load_vector(BasicType bt, XMMRegister dst, Address        src, int vlen_in_bytes);\n+  void load_vector(BasicType bt, XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch = noreg);\n@@ -136,1 +136,1 @@\n-  void load_constant_vector(BasicType bt, XMMRegister dst, InternalAddress src, int vlen);\n+  void load_constant_vector(BasicType bt, XMMRegister dst, InternalAddress src, int width, int vlen);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1272,0 +1272,38 @@\n+class VectorHelper {\n+public:\n+  static bool conv_is_zero(const Node* n) {\n+    const TypeVect* v = n->bottom_type()->is_vect();\n+    for (uint i = 0; i < v->length(); i++) {\n+      const Type* e = v->element_type(i);\n+      if (e != TypeInt::ZERO && e != TypeLong::ZERO && e != TypeF::ZERO && e != TypeD::ZERO) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  static bool conv_is_allset(const Node* n) {\n+    const TypeVect* v = n->bottom_type()->is_vect();\n+    for (uint i = 0; i < v->length(); i++) {\n+      const Type* e = v->element_type(i);\n+      if (e != TypeInt::MINUS_1 && e != TypeLong::MINUS_1) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  static bool conm_is_allset(const Node* n) {\n+    const TypeVectMask* v = n->bottom_type()->isa_vectmask();\n+    if (v == nullptr) {\n+      return false;\n+    }\n+    for (uint i = 0; i < v->length(); i++) {\n+      if (v->element_type(i) != TypeInt::ONE) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+};\n+\n@@ -2234,4 +2272,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n@@ -2720,12 +2754,37 @@\n-template <class T>\n-static inline GrowableArray<jvalue>* vreplicate_imm(BasicType bt, T con, int len) {\n-  GrowableArray<jvalue>* val = new GrowableArray<jvalue>(len);\n-  jvalue ele;\n-  switch (bt) {\n-    case T_BYTE:   ele.b = con; break;\n-    case T_SHORT:  ele.s = con; break;\n-    case T_INT:    ele.i = con; break;\n-    case T_LONG:   ele.j = con; break;\n-    case T_FLOAT:  ele.f = con; break;\n-    case T_DOUBLE: ele.d = con; break;\n-    default: ShouldNotReachHere();\n+static void materialize_vector_con(jbyte* data, const TypeVect* vt) {\n+  for (uint i = 0; i < vt->length(); i++) {\n+    size_t offset = i * type2aelembytes(vt->element_basic_type());\n+    const Type* et = vt->element_type(i);\n+    switch (vt->element_basic_type()) {\n+    case T_BYTE: {\n+      data[i] = et->is_int()->get_con();\n+      break;\n+    }\n+    case T_SHORT: {\n+      jshort e = et->is_int()->get_con();\n+      memcpy(&data[offset], &e, sizeof(jshort));\n+      break;\n+    }\n+    case T_INT: {\n+      jint e = et->is_int()->get_con();\n+      memcpy(&data[offset], &e, sizeof(jint));\n+      break;\n+    }\n+    case T_LONG: {\n+      jlong e = et->is_long()->get_con();\n+      memcpy(&data[offset], &e, sizeof(jlong));\n+      break;\n+    }\n+    case T_FLOAT: {\n+      jfloat e = et->getf();\n+      memcpy(&data[offset], &e, sizeof(jfloat));\n+      break;\n+    }\n+    case T_DOUBLE: {\n+      jdouble e = et->getd();\n+      memcpy(&data[offset], &e, sizeof(jdouble));\n+      break;\n+    }\n+    default:\n+      assert(false, \"%s\", type2name(vt->element_basic_type()));\n+    }\n@@ -2733,2 +2792,10 @@\n-  for (int i = 0; i < len; i++) {\n-    val->append(ele);\n+}\n+\n+static uint vector_con_width(const jbyte* data, uint size) {\n+  uint width;\n+  if (VM_Version::supports_avx()) {\n+    width = 4; \/\/ vbroadcastss can be used\n+  } else if (VM_Version::supports_sse3()) {\n+    width = 8; \/\/ movddup can be used\n+  } else {\n+    width = 16; \/\/ No broadcast instruction, must load the constant\n@@ -2736,1 +2803,38 @@\n-  return val;\n+\n+  width = MIN2(width, size);\n+  for (; width < size; width *= 2) {\n+    bool satisfied = true; \/\/ whether this ConV is a broadcast of the current width\n+    for (uint i = 0; i < size - width; i++) {\n+      if (data[i] != data[i + width]) {\n+        satisfied = false;\n+        break;\n+      }\n+    }\n+    if (satisfied) {\n+      break;\n+    }\n+  }\n+  assert(width >= 4, \"vectors should not be less than 4 bytes\");\n+  return width;\n+}\n+\n+static GrowableArray<jbyte>* vector_con_data(const MachTypeNode* n) {\n+  constexpr size_t max_vector_size = 64;\n+  const TypeVect* vt = n->bottom_type()->is_vect();\n+  assert(vt->length_in_bytes() <= max_vector_size, \"increase max_vector_size: %u\", vt->length_in_bytes());\n+  jbyte data[max_vector_size];\n+  materialize_vector_con(data, vt);\n+  uint width = vector_con_width(data, vt->length_in_bytes());\n+  GrowableArray<jbyte>* res = new GrowableArray<jbyte>(width, width, 0);\n+  memcpy(res->adr_at(0), data, width);\n+  return res;\n+}\n+\n+static inline jlong mask_con_data(const MachTypeNode* n) {\n+  jlong res = 0;\n+  const TypeVectMask* v = n->bottom_type()->is_vectmask();\n+  for (int i = v->length() - 1; i >= 0; i--) {\n+    res <<= 1;\n+    res |= v->element_type(i)->is_int()->get_con();\n+  }\n+  return res;\n@@ -2813,0 +2917,35 @@\n+operand immV() %{\n+  match(ConV);\n+\n+  op_cost(10);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immV_0() %{\n+  predicate(VectorHelper::conv_is_zero(n));\n+  match(ConV);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immV_M1() %{\n+  predicate(VectorHelper::conv_is_allset(n));\n+  match(ConV);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immM_M1() %{\n+  predicate(VectorHelper::conm_is_allset(n));\n+  match(ConV);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -2950,0 +3089,78 @@\n+instruct loadConV(vec dst, immV src) %{\n+  match(Set dst src);\n+  format %{ \"loadvector  $dst, [$constantaddress]\" %}\n+  ins_cost(125);\n+  ins_encode %{\n+    constexpr size_t max_vector_size = 64;\n+    InternalAddress addr = $constantaddress(vector_con_data(this));\n+    const TypeVect* vt = this->bottom_type()->is_vect();\n+    uint vlen = vt->length_in_bytes();\n+    assert(vlen <= max_vector_size, \"increase max_vector_size: %u\", vlen);\n+    jbyte data[max_vector_size];\n+    materialize_vector_con(data, vt);\n+    __ load_constant_vector(vt->element_basic_type(), $dst$$XMMRegister, addr, vector_con_width(data, vlen), vlen);\n+  %}\n+  ins_pipe(fpu_reg_mem);\n+%}\n+\n+instruct loadConV_zero(vec dst, immV_0 src) %{\n+  match(Set dst src);\n+  format %{ \"vzero   $dst\" %}\n+  ins_cost(50);\n+  ins_encode %{\n+    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vldq()) {\n+      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vector_length_encoding(this));\n+    } else if (is_integral_type(Matcher::vector_element_basic_type(this))) {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n+    } else {\n+      __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n+  %}\n+  ins_pipe(fpu_reg_reg_reg);\n+%}\n+\n+instruct loadConV_allset(vec dst, immV_M1 src) %{\n+  match(Set dst src);\n+  format %{ \"vallones    $dst\" %}\n+  ins_cost(100);\n+  ins_encode %{\n+    __ vallones($dst$$XMMRegister, vector_length_encoding(this));\n+  %}\n+  ins_pipe(fpu_reg_reg_reg);\n+%}\n+\n+instruct loadConM(kReg dst, immV src) %{\n+  match(Set dst src);\n+  format %{ \"loadmask    $dst, [$constantaddress]\" %}\n+  ins_cost(125);\n+  ins_encode %{\n+    InternalAddress addr = $constantaddress(mask_con_data(this));\n+    __ kmov($dst$$KRegister, __ as_Address(addr));\n+  %}\n+  ins_pipe(fpu_reg_mem);\n+%}\n+\n+instruct loadConM_0(kReg dst, immV_0 src) %{\n+  match(Set dst src);\n+  format %{ \"kzero   $dst\" %}\n+  ins_cost(50);\n+  ins_encode %{\n+    __ kxorwl($dst$$KRegister, $dst$$KRegister, $dst$$KRegister);\n+  %}\n+  ins_pipe(fpu_reg_reg_reg);\n+%}\n+\n+instruct loadConM_M1(kReg dst, immM_M1 src) %{\n+  match(Set dst src);\n+  format %{ \"kallones    $dst\" %}\n+  ins_cost(100);\n+  ins_encode %{\n+    if (VM_Version::supports_avx512bw()) {\n+      __ kxnorql($dst$$KRegister, k0, k0);\n+    } else {\n+      __ kxnorwl($dst$$KRegister, k0, k0);\n+    }\n+  %}\n+  ins_pipe(fpu_reg_reg_reg);\n+%}\n+\n@@ -4018,1 +4235,2 @@\n-    __ load_vector($dst$$XMMRegister, $mem$$Address, Matcher::vector_length_in_bytes(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ load_vector(bt, $dst$$XMMRegister, $mem$$Address, Matcher::vector_length_in_bytes(this));\n@@ -4496,43 +4714,0 @@\n-instruct ReplI_imm(vec dst, immI con) %{\n-  predicate(Matcher::is_non_long_integral_vector(n));\n-  match(Set dst (Replicate con));\n-  format %{ \"replicateI $dst,$con\" %}\n-  ins_encode %{\n-    InternalAddress addr = $constantaddress(Matcher::vector_element_basic_type(this),\n-        vreplicate_imm(Matcher::vector_element_basic_type(this), $con$$constant,\n-            (VM_Version::supports_sse3() ? (VM_Version::supports_avx() ? 4 : 8) : 8) \/\n-                type2aelembytes(Matcher::vector_element_basic_type(this))));\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int vlen = Matcher::vector_length_in_bytes(this);\n-    __ load_constant_vector(bt, $dst$$XMMRegister, addr, vlen);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ Replicate scalar zero to be vector\n-instruct ReplI_zero(vec dst, immI_0 zero) %{\n-  predicate(Matcher::is_non_long_integral_vector(n));\n-  match(Set dst (Replicate zero));\n-  format %{ \"replicateI $dst,$zero\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vl()) {\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    } else {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    }\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-instruct ReplI_M1(vec dst, immI_M1 con) %{\n-  predicate(UseSSE >= 2 && Matcher::is_non_long_integral_vector(n));\n-  match(Set dst (Replicate con));\n-  format %{ \"vallones $dst\" %}\n-  ins_encode %{\n-    int vector_len = vector_length_encoding(this);\n-    __ vallones($dst$$XMMRegister, vector_len);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -4636,39 +4811,0 @@\n-\/\/ Replicate long (8 byte) scalar immediate to be vector by loading from const table.\n-instruct ReplL_imm(vec dst, immL con) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n-  match(Set dst (Replicate con));\n-  format %{ \"replicateL $dst,$con\" %}\n-  ins_encode %{\n-    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, $con$$constant, 1));\n-    int vlen = Matcher::vector_length_in_bytes(this);\n-    __ load_constant_vector(T_LONG, $dst$$XMMRegister, addr, vlen);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct ReplL_zero(vec dst, immL0 zero) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n-  match(Set dst (Replicate zero));\n-  format %{ \"replicateL $dst,$zero\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vl()) {\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    } else {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    }\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-instruct ReplL_M1(vec dst, immL_M1 con) %{\n-  predicate(UseSSE >= 2 && Matcher::vector_element_basic_type(n) == T_LONG);\n-  match(Set dst (Replicate con));\n-  format %{ \"vallones $dst\" %}\n-  ins_encode %{\n-    int vector_len = vector_length_encoding(this);\n-    __ vallones($dst$$XMMRegister, vector_len);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -4718,29 +4854,0 @@\n-\/\/ Replicate float scalar immediate to be vector by loading from const table.\n-instruct ReplF_imm(vec dst, immF con) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n-  match(Set dst (Replicate con));\n-  format %{ \"replicateF $dst,$con\" %}\n-  ins_encode %{\n-    InternalAddress addr = $constantaddress(T_FLOAT, vreplicate_imm(T_FLOAT, $con$$constant,\n-        VM_Version::supports_sse3() ? (VM_Version::supports_avx() ? 1 : 2) : 2));\n-    int vlen = Matcher::vector_length_in_bytes(this);\n-    __ load_constant_vector(T_FLOAT, $dst$$XMMRegister, addr, vlen);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct ReplF_zero(vec dst, immF0 zero) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n-  match(Set dst (Replicate zero));\n-  format %{ \"replicateF $dst,$zero\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vldq()) {\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    } else {\n-      __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n-    }\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n@@ -4795,28 +4902,0 @@\n-\/\/ Replicate double (8 byte) scalar immediate to be vector by loading from const table.\n-instruct ReplD_imm(vec dst, immD con) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n-  match(Set dst (Replicate con));\n-  format %{ \"replicateD $dst,$con\" %}\n-  ins_encode %{\n-    InternalAddress addr = $constantaddress(T_DOUBLE, vreplicate_imm(T_DOUBLE, $con$$constant, 1));\n-    int vlen = Matcher::vector_length_in_bytes(this);\n-    __ load_constant_vector(T_DOUBLE, $dst$$XMMRegister, addr, vlen);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct ReplD_zero(vec dst, immD0 zero) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n-  match(Set dst (Replicate zero));\n-  format %{ \"replicateD $dst,$zero\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vldq()) {\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    } else {\n-      __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n-    }\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n@@ -9611,1 +9690,1 @@\n-    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, 0x8040201008040201L, 1));\n+    InternalAddress addr = $constantaddress(jlong(0x8040201008040201));\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":239,"deletions":160,"binary":false,"changes":399,"status":"modified"},{"patch":"@@ -1058,0 +1058,1 @@\n+  case 'V':    return \"\";\n@@ -1095,1 +1096,1 @@\n-        !strcmp(ident, \"Bool\")) {\n+        !strcmp(ident, \"ConV\") || !strcmp(ident, \"Bool\")) {\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+  if (strcmp(name,\"ConV\")==0) return Form::idealV;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2662,1 +2662,2 @@\n-  case Form::idealN: fprintf(fp,\"  if (_c%d) _c%d->dump_on(st);\\n\", const_index, const_index); break;\n+  case Form::idealN:\n+  case Form::idealV: fprintf(fp,\"  if (_c%d) _c%d->dump_on(st);\\n\", const_index, const_index); break;\n@@ -4335,0 +4336,1 @@\n+    \"ConV\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3795,0 +3795,2 @@\n+    } else if ( (strcmp(optype,\"ConV\") == 0) ) {\n+      fprintf(fp, \"_leaf->bottom_type()->is_vect()\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,0 +240,6 @@\n+    else if (!strcmp(type, \"ConV\")) {\n+      if (i > 0) {\n+        fprintf(fp, \", \");\n+      }\n+      fprintf(fp, \"  const TypeVect* _c%d;\\n\", i);\n+    }\n@@ -280,0 +286,4 @@\n+      else if (!strcmp(comp->base_type(globals), \"ConV\")) {\n+        fprintf(fp,\"  const TypeVect*  _c%d;\\n\", i);\n+        i++;\n+      }\n@@ -319,0 +329,1 @@\n+    case Form::idealV :      { fprintf(fp,\"const TypeVect* c%d\", i); break;}\n@@ -362,0 +373,5 @@\n+      else if (!strcmp(comp->base_type(globals), \"ConV\")) {\n+        if (i > 0) fprintf(fp,\", \");\n+        fprintf(fp,\"const TypeVect* c%d\", i);\n+        i++;\n+      }\n@@ -435,0 +451,4 @@\n+  else if (!strcmp(ideal_type, \"ConV\")) {\n+    fprintf(fp,\"    _c%d->dump_on(st);\\n\", i);\n+    ++i;\n+  }\n@@ -1259,1 +1279,1 @@\n-      if( type != nullptr ) {\n+      if (type != nullptr) {\n@@ -1261,3 +1281,2 @@\n-        \/\/ Check if we are an ideal pointer type\n-        if( data_type == Form::idealP || data_type == Form::idealN || data_type == Form::idealNKlass ) {\n-          \/\/ Return the ideal type we already have: <TypePtr *>\n+        if (data_type == Form::idealP || data_type == Form::idealN || data_type == Form::idealNKlass || data_type == Form::idealV) {\n+          \/\/ Just return the type if available\n@@ -1895,0 +1914,1 @@\n+      case Form::idealV:\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-  address array_constant(BasicType bt, GrowableArray<jvalue>* c, int alignment) {\n+  address array_constant(GrowableArray<jbyte>* c, int alignment) {\n@@ -485,3 +485,1 @@\n-    int len = c->length();\n-    int size = type2aelembytes(bt) * len;\n-    address ptr = start_a_const(size, alignment);\n+    address ptr = start_a_const(c->length(), alignment);\n@@ -489,14 +487,2 @@\n-      for (int i = 0; i < len; i++) {\n-        jvalue e = c->at(i);\n-        switch(bt) {\n-          case T_BOOLEAN: emit_int8(e.z);   break;\n-          case T_BYTE:    emit_int8(e.b);   break;\n-          case T_CHAR:    emit_int16(e.c);  break;\n-          case T_SHORT:   emit_int16(e.s);  break;\n-          case T_INT:     emit_int32(e.i);  break;\n-          case T_LONG:    emit_int64(e.j);  break;\n-          case T_FLOAT:   emit_float(e.f);  break;\n-          case T_DOUBLE:  emit_double(e.d); break;\n-          default:\n-            ShouldNotReachHere();\n-        }\n+      for (int i = 0; i < c->length(); i++) {\n+        emit_int8(c->at(i));\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+macro(ConV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,5 @@\n-ConNode *ConNode::make(const Type *t) {\n+ConNode* ConNode::make(const Type *t) {\n+  if (t->isa_vect()) {\n+    return new ConVNode(t->is_vect());\n+  }\n+\n@@ -68,0 +72,6 @@\n+\n+ConVNode::ConVNode(const TypeVect* vt) : ConNode(vt) {\n+  assert(Matcher::match_rule_supported(Op_ConV), \"unsupported\");\n+  Compile* C = Compile::current();\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), vt->length_in_bytes()));\n+}\n","filename":"src\/hotspot\/share\/opto\/connode.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,7 @@\n+\/\/ Vector constants\n+class ConVNode : public ConNode {\n+public:\n+  ConVNode(const TypeVect* t);\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/connode.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,15 +44,1 @@\n-      jvalue ele1 = get_array()->at(i);\n-      jvalue ele2 = other.get_array()->at(i);\n-      bool is_eq;\n-      switch (type()) {\n-        case T_BOOLEAN: is_eq = ele1.z == ele2.z; break;\n-        case T_BYTE:    is_eq = ele1.b == ele2.b; break;\n-        case T_CHAR:    is_eq = ele1.c == ele2.c; break;\n-        case T_SHORT:   is_eq = ele1.s == ele2.s; break;\n-        case T_INT:     is_eq = ele1.i == ele2.i; break;\n-        case T_LONG:    is_eq = ele1.j == ele2.j; break;\n-        case T_FLOAT:   is_eq = jint_cast(ele1.f)  == jint_cast(ele2.f);  break;\n-        case T_DOUBLE:  is_eq = jlong_cast(ele1.d) == jlong_cast(ele2.d); break;\n-        default: ShouldNotReachHere(); is_eq = false;\n-      }\n-      if (!is_eq) {\n+      if (get_array()->at(i) != other.get_array()->at(i)) {\n@@ -78,0 +64,9 @@\n+int ConstantTable::alignment() const {\n+  int res = 1;\n+  for (int i = 0; i < _constants.length(); i++) {\n+    const Constant& c = _constants.at(i);\n+    res = MAX2(res, c.alignment());\n+  }\n+  return res;\n+}\n+\n@@ -79,4 +74,24 @@\n-  \/\/ sort descending\n-  if (a->freq() > b->freq())  return -1;\n-  if (a->freq() < b->freq())  return  1;\n-  return 0;\n+  \/\/ put the ones with large alignments first\n+  if (a->alignment() > 8 && b->alignment() > 8) {\n+    \/\/ sort them by alignment\n+    if (a->alignment() > b->alignment()) {\n+      return -1;\n+    } else if (a->alignment() < b->alignment()) {\n+      return 1;\n+    } else {\n+      return 0;\n+    }\n+  } else if (a->alignment() > 8) {\n+    return -1;\n+  } else if (b->alignment() > 8) {\n+    return 1;\n+  } else {\n+    \/\/ sort descending\n+    if (a->freq() > b->freq()) {\n+      return -1;\n+    } else if (a->freq() < b->freq()) {\n+      return 1;\n+    } else {\n+      return 0;\n+    }\n+  }\n@@ -87,1 +102,1 @@\n-    return type2aelembytes(con->type()) * con->get_array()->length();\n+    return con->get_array()->length();\n@@ -152,1 +167,1 @@\n-      constant_addr = masm->array_constant(con.type(), con.get_array(), con.alignment());\n+      constant_addr = masm->array_constant(con.get_array(), con.alignment());\n@@ -254,3 +269,2 @@\n-ConstantTable::Constant ConstantTable::add(MachConstantNode* n, BasicType bt,\n-                                           GrowableArray<jvalue>* array, int alignment) {\n-  Constant con(bt, array, alignment);\n+ConstantTable::Constant ConstantTable::add(MachConstantNode* n, GrowableArray<jbyte>* array, int alignment) {\n+  Constant con(array, alignment);\n@@ -261,3 +275,2 @@\n-ConstantTable::Constant ConstantTable::add(MachConstantNode* n, BasicType bt,\n-                                           GrowableArray<jvalue>* array) {\n-  return add(n, bt, array, array->length() * type2aelembytes(bt));\n+ConstantTable::Constant ConstantTable::add(MachConstantNode* n, GrowableArray<jbyte>* array) {\n+  return add(n, array, array->length());\n","filename":"src\/hotspot\/share\/opto\/constantTable.cpp","additions":41,"deletions":28,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-      GrowableArray<jvalue>* _array;\n+      GrowableArray<jbyte>* _array;\n@@ -75,2 +75,2 @@\n-    Constant(BasicType type, GrowableArray<jvalue>* array, int alignment, bool can_be_reused = true) :\n-      _type(type),\n+    Constant(GrowableArray<jbyte>* array, int alignment, bool can_be_reused = true) :\n+      _type(T_BYTE),\n@@ -83,1 +83,0 @@\n-      assert(is_java_primitive(type), \"not applicable for %s\", type2name(type));\n@@ -85,2 +84,2 @@\n-      _v._array = new GrowableArray<jvalue>(array->length());\n-      for (jvalue ele : *array) {\n+      _v._array = new GrowableArray<jbyte>(array->length());\n+      for (jbyte ele : *array) {\n@@ -105,1 +104,1 @@\n-    GrowableArray<jvalue>* get_array() const { return _v._array; }\n+    GrowableArray<jbyte>* get_array() const { return _v._array; }\n@@ -137,0 +136,1 @@\n+  int alignment() const;\n@@ -153,2 +153,2 @@\n-  Constant add(MachConstantNode* n, BasicType bt, GrowableArray<jvalue>* array);\n-  Constant add(MachConstantNode* n, BasicType bt, GrowableArray<jvalue>* array, int alignment);\n+  Constant add(MachConstantNode* n, GrowableArray<jbyte>* array);\n+  Constant add(MachConstantNode* n, GrowableArray<jbyte>* array, int alignment);\n","filename":"src\/hotspot\/share\/opto\/constantTable.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4551,1 +4551,0 @@\n-    const Type* bt_t      = Type::get_const_basic_type(bt);\n@@ -4631,1 +4630,1 @@\n-    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt_t);\n+    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,1 +345,0 @@\n-  static const TypeVectMask* predicate_reg_type(const Type* elemTy, int length);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1335,1 +1335,1 @@\n-    const_req = constant_table().size() + add_size;\n+    const_req = constant_table().alignment() + constant_table().size() + add_size;\n@@ -1375,0 +1375,1 @@\n+  cb->set_const_section_alignment(constant_table().alignment());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -718,1 +718,1 @@\n-  if (t->singleton() && !k->is_Con()) {\n+  if (t->singleton() && !k->is_Con() && (!t->isa_vect() || Matcher::match_rule_supported(Op_ConV))) {\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -231,2 +231,2 @@\n-      const Type* element_type = _vloop_analyzer.types().velt_type(p0);\n-      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type->isa_long()) {\n+      BasicType element_type = _vloop_analyzer.types().velt_basic_type(p0);\n+      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type == T_LONG) {\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -682,3 +682,0 @@\n-  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(TypeInt::BOOL, MaxVectorSize))->hashcons();\n-  mreg2type[Op_RegVectMask] = TypeVect::VECTMASK;\n-\n@@ -706,0 +703,7 @@\n+  const Type** elem_types = static_cast<const Type**>(Compile::current()->type_arena()->AmallocWords(sizeof(Type*) * MaxVectorSize));\n+  for (uint i = 0; i < uint(MaxVectorSize); i++) {\n+    elem_types[i] = TypeInt::BOOL;\n+  }\n+  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(T_BYTE, MaxVectorSize, elem_types))->hashcons();\n+  mreg2type[Op_RegVectMask] = TypeVect::VECTMASK;\n+\n@@ -2494,5 +2498,1 @@\n-const TypeVect* TypeVect::make(const Type *elem, uint length, bool is_mask) {\n-  if (is_mask) {\n-    return makemask(elem, length);\n-  }\n-  BasicType elem_bt = elem->array_element_basic_type();\n+const TypeVect* TypeVect::make(BasicType elem_bt, uint length, const Type** elem_types) {\n@@ -2503,4 +2503,2 @@\n-  case Op_VecA:\n-    return (TypeVect*)(new TypeVectA(elem, length))->hashcons();\n-  case Op_VecS:\n-    return (TypeVect*)(new TypeVectS(elem, length))->hashcons();\n+  case Op_VecA: return (TypeVect*)(new TypeVectA(elem_bt, length, elem_types))->hashcons();\n+  case Op_VecS: return (TypeVect*)(new TypeVectS(elem_bt, length, elem_types))->hashcons();\n@@ -2509,20 +2507,4 @@\n-  case Op_RegD:\n-    return (TypeVect*)(new TypeVectD(elem, length))->hashcons();\n-  case Op_VecX:\n-    return (TypeVect*)(new TypeVectX(elem, length))->hashcons();\n-  case Op_VecY:\n-    return (TypeVect*)(new TypeVectY(elem, length))->hashcons();\n-  case Op_VecZ:\n-    return (TypeVect*)(new TypeVectZ(elem, length))->hashcons();\n-  }\n- ShouldNotReachHere();\n-  return nullptr;\n-}\n-\n-const TypeVect *TypeVect::makemask(const Type* elem, uint length) {\n-  BasicType elem_bt = elem->array_element_basic_type();\n-  if (Matcher::has_predicated_vectors() &&\n-      Matcher::match_rule_supported_vector_masked(Op_VectorLoadMask, length, elem_bt)) {\n-    return TypeVectMask::make(elem, length);\n-  } else {\n-    return make(elem, length);\n+  case Op_RegD: return (TypeVect*)(new TypeVectD(elem_bt, length, elem_types))->hashcons();\n+  case Op_VecX: return (TypeVect*)(new TypeVectX(elem_bt, length, elem_types))->hashcons();\n+  case Op_VecY: return (TypeVect*)(new TypeVectY(elem_bt, length, elem_types))->hashcons();\n+  case Op_VecZ: return (TypeVect*)(new TypeVectZ(elem_bt, length, elem_types))->hashcons();\n@@ -2530,0 +2512,2 @@\n+  ShouldNotReachHere();\n+  return nullptr;\n@@ -2534,1 +2518,1 @@\n-const Type *TypeVect::xmeet( const Type *t ) const {\n+const Type* TypeVect::xmeet(const Type* t) const {\n@@ -2536,28 +2520,2 @@\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is Vector\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case VectorMask: {\n-    const TypeVectMask* v = t->is_vectmask();\n-    assert(  base() == v->base(), \"\");\n-    assert(length() == v->length(), \"\");\n-    assert(element_basic_type() == v->element_basic_type(), \"\");\n-    return TypeVect::makemask(_elem->xmeet(v->_elem), _length);\n-  }\n-  case VectorA:\n-  case VectorS:\n-  case VectorD:\n-  case VectorX:\n-  case VectorY:\n-  case VectorZ: {                \/\/ Meeting 2 vectors?\n-    const TypeVect* v = t->is_vect();\n-    assert(  base() == v->base(), \"\");\n-    assert(length() == v->length(), \"\");\n-    assert(element_basic_type() == v->element_basic_type(), \"\");\n-    return TypeVect::make(_elem->xmeet(v->_elem), _length);\n+  if (this == t) {\n+    return this;\n@@ -2565,2 +2523,10 @@\n-  case Top:\n-    break;\n+\n+  const TypeVect* v = t->isa_vect();\n+  if (v == nullptr) {\n+    if (t->base() == Bottom) {\n+      return t;\n+    } else if (t->base() == Top) {\n+      return this;\n+    } else {\n+      typerr(t);\n+    }\n@@ -2568,1 +2534,7 @@\n-  return this;\n+\n+  assert(base() == v->base(), \"\");\n+  assert(length() == v->length(), \"\");\n+  assert(element_basic_type() == v->element_basic_type(), \"\");\n+  return TypeVect::make(element_basic_type(), length(), [&](uint idx) {\n+    return element_type(idx)->meet(v->element_type(idx));\n+  });\n@@ -2573,2 +2545,6 @@\n-const Type *TypeVect::xdual() const {\n-  return new TypeVect(base(), _elem->dual(), _length);\n+const Type* TypeVect::xdual() const {\n+  const Type** elem_types = static_cast<const Type**>(Compile::current()->type_arena()->AmallocWords(sizeof(Type*) * length()));\n+  for (uint i = 0; i < length(); i++) {\n+    elem_types[i] = element_type(i)->dual();\n+  }\n+  return new TypeVect(base(), element_basic_type(), length(), elem_types);\n@@ -2580,2 +2556,11 @@\n-  const TypeVect *v = t->is_vect();\n-  return (_elem == v->_elem) && (_length == v->_length);\n+  const TypeVect* v = t->is_vect();\n+  if (!is_compatible(v)) {\n+    return false;\n+  }\n+\n+  for (uint i = 0; i < length(); i++) {\n+    if (element_type(i) != v->element_type(i)) {\n+      return false;\n+    }\n+  }\n+  return true;\n@@ -2586,2 +2571,6 @@\n-uint TypeVect::hash(void) const {\n-  return (uint)(uintptr_t)_elem + (uint)(uintptr_t)_length;\n+uint TypeVect::hash() const {\n+  uint res = element_basic_type() + length();\n+  for (uint i = 0; i < length(); i++) {\n+    res += element_type(i)->hash();\n+  }\n+  return res;\n@@ -2594,4 +2583,7 @@\n-bool TypeVect::singleton(void) const {\n-\/\/ There is no Con node for vectors yet.\n-\/\/  return _elem->singleton();\n-  return false;\n+bool TypeVect::singleton() const {\n+  for (uint i = 0; i < length(); i++) {\n+    if (!element_type(i)->singleton()) {\n+      return false;\n+    }\n+  }\n+  return true;\n@@ -2601,1 +2593,18 @@\n-  return _elem->empty();\n+  for (uint i = 0; i < length(); i++) {\n+    if (element_type(i)->empty()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool TypeVect::supports_predicate_vector(BasicType elem_bt, uint length) {\n+  return Matcher::has_predicated_vectors() && Matcher::match_rule_supported_vector_masked(Op_VectorLoadMask, length, elem_bt);\n+}\n+\n+const Type* TypeVectMask::xdual() const {\n+  const Type** elem_types = static_cast<const Type**>(Compile::current()->type_arena()->AmallocWords(sizeof(Type*) * length()));\n+  for (uint i = 0; i < length(); i++) {\n+    elem_types[i] = element_type(i)->dual();\n+  }\n+  return new TypeVectMask(element_basic_type(), length(), elem_types);\n@@ -2606,1 +2615,1 @@\n-void TypeVect::dump2(Dict &d, uint depth, outputStream *st) const {\n+void TypeVect::dump2(Dict& d, uint depth, outputStream* st) const {\n@@ -2609,1 +2618,1 @@\n-    st->print(\"vectora[\"); break;\n+    st->print(\"vectora\"); break;\n@@ -2611,1 +2620,1 @@\n-    st->print(\"vectors[\"); break;\n+    st->print(\"vectors\"); break;\n@@ -2613,1 +2622,1 @@\n-    st->print(\"vectord[\"); break;\n+    st->print(\"vectord\"); break;\n@@ -2615,1 +2624,1 @@\n-    st->print(\"vectorx[\"); break;\n+    st->print(\"vectorx\"); break;\n@@ -2617,1 +2626,1 @@\n-    st->print(\"vectory[\"); break;\n+    st->print(\"vectory\"); break;\n@@ -2619,3 +2628,1 @@\n-    st->print(\"vectorz[\"); break;\n-  case VectorMask:\n-    st->print(\"vectormask[\"); break;\n+    st->print(\"vectorz\"); break;\n@@ -2625,17 +2632,7 @@\n-  st->print(\"%d]:{\", _length);\n-  _elem->dump2(d, depth, st);\n-  st->print(\"}\");\n-}\n-#endif\n-\n-bool TypeVectMask::eq(const Type *t) const {\n-  const TypeVectMask *v = t->is_vectmask();\n-  return (element_type() == v->element_type()) && (length() == v->length());\n-}\n-\n-const Type *TypeVectMask::xdual() const {\n-  return new TypeVectMask(element_type()->dual(), length());\n-}\n-\n-const TypeVectMask *TypeVectMask::make(const BasicType elem_bt, uint length) {\n-  return make(get_const_basic_type(elem_bt), length);\n+  st->print(\"<%c,%u>[\", type2char(element_basic_type()), length());\n+  element_type(0)->dump2(d, depth, st);\n+  for (uint i = 1; i < length(); i++) {\n+    st->print(\", \");\n+    element_type(i)->dump2(d, depth, st);\n+  }\n+  st->print(\"]\");\n@@ -2644,3 +2641,11 @@\n-const TypeVectMask *TypeVectMask::make(const Type* elem, uint length) {\n-  const TypeVectMask* mtype = Matcher::predicate_reg_type(elem, length);\n-  return (TypeVectMask*) const_cast<TypeVectMask*>(mtype)->hashcons();\n+void TypeVectMask::dump2(Dict& d, uint depth, outputStream* st) const {\n+  st->print(\"vectormask:\");\n+  for (uint i = 0; i < length(); i++) {\n+    if (element_type(i) == TypeInt::ONE) {\n+      st->print(\"1\");\n+    } else if (element_type(i) == TypeInt::ZERO) {\n+      st->print(\"0\");\n+    } else {\n+      st->print(\"*\");\n+    }\n+  }\n@@ -2648,0 +2653,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":110,"deletions":104,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -787,2 +787,3 @@\n-  const Type*   _elem;  \/\/ Vector's element type\n-  const uint  _length;  \/\/ Elements in vector (power of 2)\n+  const BasicType _elem_bt; \/\/ Vector's element type\n+  const uint _length;       \/\/ Elements in vector (power of 2)\n+  const Type* const * const _elem_types;\n@@ -791,2 +792,2 @@\n-  TypeVect(TYPES t, const Type* elem, uint length) : Type(t),\n-    _elem(elem), _length(length) {}\n+  TypeVect(TYPES t, BasicType elem_bt, uint length, const Type** elem_types) : Type(t),\n+    _elem_bt(elem_bt), _length(length), _elem_types(elem_types) {}\n@@ -795,5 +796,6 @@\n-  const Type* element_type() const { return _elem; }\n-  BasicType element_basic_type() const { return _elem->array_element_basic_type(); }\n-  uint length() const { return _length; }\n-  uint length_in_bytes() const {\n-   return _length * type2aelembytes(element_basic_type());\n+  BasicType element_basic_type() const { return _elem_bt; }\n+  uint length()                  const { return _length; }\n+  uint length_in_bytes()         const { return length() * type2aelembytes(element_basic_type()); }\n+  const Type* element_type(uint idx) const {\n+    assert(idx < _length, \"index %u out of bounds for length %u\", idx, _length);\n+    return _elem_types[idx];\n@@ -802,1 +804,5 @@\n-  virtual bool eq(const Type *t) const;\n+  bool is_compatible(const TypeVect* v) const {\n+    return base() == v->base() && element_basic_type() == v->element_basic_type() && length() == v->length();\n+  }\n+\n+  virtual bool eq(const Type* t) const;\n@@ -807,3 +813,9 @@\n-  static const TypeVect *make(const BasicType elem_bt, uint length, bool is_mask = false) {\n-    \/\/ Use bottom primitive type.\n-    return make(get_const_basic_type(elem_bt), length, is_mask);\n+  static const TypeVect* make(BasicType elem_bt, uint length, bool is_mask = false) {\n+    if (is_mask) {\n+      return makemask(elem_bt, length);\n+    } else {\n+      const Type* elem_bottom_type = get_const_basic_type(elem_bt);\n+      return make(elem_bt, length, [elem_bottom_type](uint idx) {\n+        return elem_bottom_type;\n+      });\n+    }\n@@ -811,2 +823,0 @@\n-  \/\/ Used directly by Replicate nodes to construct singleton vector.\n-  static const TypeVect *make(const Type* elem, uint length, bool is_mask = false);\n@@ -814,3 +824,10 @@\n-  static const TypeVect *makemask(const BasicType elem_bt, uint length) {\n-    \/\/ Use bottom primitive type.\n-    return makemask(get_const_basic_type(elem_bt), length);\n+  template <class TypeSupplier>\n+  static const TypeVect* make(BasicType elem_bt, uint length, TypeSupplier ts) {\n+    const Type* elem_bottom_type = get_const_basic_type(elem_bt);\n+    const Type** elem_types = static_cast<const Type**>(Compile::current()->type_arena()->AmallocWords(sizeof(Type*) * length));\n+    for (uint i = 0; i < length; i++) {\n+      const Type* elem_type = ts(i);\n+      assert(elem_type == elem_bottom_type || elem_type->higher_equal(elem_bottom_type), \"invalid element\");\n+      elem_types[i] = elem_type;\n+    }\n+    return make(elem_bt, length, elem_types);\n@@ -818,1 +835,0 @@\n-  static const TypeVect *makemask(const Type* elem, uint length);\n@@ -820,0 +836,5 @@\n+  static const TypeVect* makemask(BasicType elem_bt, uint length) {\n+    return makemask(elem_bt, length, [](uint idx) {\n+      return TypeInt::BOOL;\n+    });\n+  }\n@@ -821,2 +842,2 @@\n-  virtual const Type *xmeet( const Type *t) const;\n-  virtual const Type *xdual() const;     \/\/ Compute dual right now.\n+  template <class TypeSupplier>\n+  static const TypeVect* makemask(BasicType elem_bt, uint length, TypeSupplier ts);\n@@ -824,7 +845,10 @@\n-  static const TypeVect *VECTA;\n-  static const TypeVect *VECTS;\n-  static const TypeVect *VECTD;\n-  static const TypeVect *VECTX;\n-  static const TypeVect *VECTY;\n-  static const TypeVect *VECTZ;\n-  static const TypeVect *VECTMASK;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n+\n+  static const TypeVect* VECTA;\n+  static const TypeVect* VECTS;\n+  static const TypeVect* VECTD;\n+  static const TypeVect* VECTX;\n+  static const TypeVect* VECTY;\n+  static const TypeVect* VECTZ;\n+  static const TypeVect* VECTMASK;\n@@ -833,1 +857,1 @@\n-  virtual void dump2(Dict &d, uint, outputStream *st) const; \/\/ Specialized per-Type dumping\n+  virtual void dump2(Dict& d, uint, outputStream* st) const; \/\/ Specialized per-Type dumping\n@@ -835,0 +859,4 @@\n+\n+private:\n+  static const TypeVect* make(BasicType elem_bt, uint length, const Type** elem_types);\n+  static bool supports_predicate_vector(BasicType elem_bt, uint length);\n@@ -839,1 +867,1 @@\n-  TypeVectA(const Type* elem, uint length) : TypeVect(VectorA, elem, length) {}\n+  TypeVectA(BasicType elem_bt, uint length, const Type** elem_types) : TypeVect(VectorA, elem_bt, length, elem_types) {}\n@@ -844,1 +872,1 @@\n-  TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}\n+  TypeVectS(BasicType elem_bt, uint length, const Type** elem_types) : TypeVect(VectorS, elem_bt, length, elem_types) {}\n@@ -849,1 +877,1 @@\n-  TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}\n+  TypeVectD(BasicType elem_bt, uint length, const Type** elem_types) : TypeVect(VectorD, elem_bt, length, elem_types) {}\n@@ -854,1 +882,1 @@\n-  TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}\n+  TypeVectX(BasicType elem_bt, uint length, const Type** elem_types) : TypeVect(VectorX, elem_bt, length, elem_types) {}\n@@ -859,1 +887,1 @@\n-  TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}\n+  TypeVectY(BasicType elem_bt, uint length, const Type** elem_types) : TypeVect(VectorY, elem_bt, length, elem_types) {}\n@@ -864,1 +892,1 @@\n-  TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}\n+  TypeVectZ(BasicType elem_bt, uint length, const Type** elem_types) : TypeVect(VectorZ, elem_bt, length, elem_types) {}\n@@ -870,5 +898,22 @@\n-  TypeVectMask(const Type* elem, uint length) : TypeVect(VectorMask, elem, length) {}\n-  virtual bool eq(const Type *t) const;\n-  virtual const Type *xdual() const;\n-  static const TypeVectMask* make(const BasicType elem_bt, uint length);\n-  static const TypeVectMask* make(const Type* elem, uint length);\n+  TypeVectMask(BasicType elem_bt, uint length, const Type** elem_types) : TypeVect(VectorMask, elem_bt, length, elem_types) {}\n+  virtual const Type* xdual() const;\n+  static const TypeVectMask* make(BasicType elem_bt, uint length) {\n+    return make(elem_bt, length, [](uint idx) {\n+      return TypeInt::BOOL;\n+    });\n+  }\n+\n+  template <class TypeSupplier>\n+  static const TypeVectMask* make(BasicType elem_bt, uint length, TypeSupplier ts) {\n+    const Type** elem_types = static_cast<const Type**>(Compile::current()->type_arena()->AmallocWords(sizeof(Type*) * length));\n+    for (uint i = 0; i < length; i++) {\n+      const Type* elem_type = ts(i);\n+      assert(elem_type == TypeInt::BOOL || elem_type->higher_equal(TypeInt::BOOL), \"invalid element\");\n+      elem_types[i] = elem_type;\n+    }\n+    return static_cast<const TypeVectMask*>((new TypeVectMask(elem_bt, length, elem_types))->hashcons());\n+  }\n+\n+#ifndef PRODUCT\n+  virtual void dump2(Dict& d, uint, outputStream* st) const; \/\/ Specialized per-Type dumping\n+#endif\n@@ -877,0 +922,39 @@\n+template <class TypeSupplier>\n+const TypeVect* TypeVect::makemask(BasicType elem_bt, uint length, TypeSupplier ts)  {\n+  if (supports_predicate_vector(elem_bt, length)) {\n+    return TypeVectMask::make(elem_bt, length, ts);\n+  }\n+\n+  BasicType bit_bt = elem_bt;\n+  if (bit_bt == T_FLOAT) {\n+    bit_bt = T_INT;\n+  } else if (bit_bt == T_DOUBLE) {\n+    bit_bt = T_LONG;\n+  }\n+\n+  if (bit_bt == T_LONG) {\n+    const TypeLong* elem_bottom_type = TypeLong::make(-1, 0, WidenMin);\n+    return make(bit_bt, length, [&](uint idx) {\n+      const Type* elem_type = ts(idx);\n+      if (elem_type == TypeInt::ZERO) {\n+        return TypeLong::ZERO;\n+      } else if (elem_type == TypeInt::ONE) {\n+        return TypeLong::MINUS_1;\n+      } else {\n+        return elem_bottom_type;\n+      }\n+    });\n+  } else {\n+    return make(bit_bt, length, [&](uint idx) {\n+      const Type* elem_type = ts(idx);\n+      if (elem_type == TypeInt::ZERO) {\n+        return TypeInt::ZERO;\n+      } else if (elem_type == TypeInt::ONE) {\n+        return TypeInt::MINUS_1;\n+      } else {\n+        return TypeInt::CC_LE;\n+      }\n+    });\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":124,"deletions":40,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -442,0 +442,1 @@\n+  kit.insert_mem_bar(Op_MemBarStoreStore);\n@@ -453,0 +454,8 @@\n+    const TypeVect* cvt = vec_unbox->try_constant_fold(&gvn);\n+    if (cvt != nullptr) {\n+      gvn.hash_delete(vec_unbox);\n+      vec_unbox->disconnect_inputs(C);\n+      C->gvn_replace_by(vec_unbox, gvn.makecon(cvt));\n+      C->remove_macro_node(vec_unbox);\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -527,1 +527,0 @@\n-  const Type* type_bt = Type::get_const_basic_type(elem_bt);\n@@ -530,1 +529,1 @@\n-  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, type_bt));\n+  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, elem_bt));\n@@ -535,2 +534,2 @@\n-  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, type_bt));\n-  const TypeVect* vmask_type = TypeVect::makemask(type_bt, num_elem);\n+  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, elem_bt));\n+  const TypeVect* vmask_type = TypeVect::makemask(elem_bt, num_elem);\n@@ -603,3 +602,1 @@\n-  const Type * type_bt = Type::get_const_basic_type(elem_bt);\n-  const TypeVect * vt  = TypeVect::make(type_bt, num_elem);\n-\n+  const TypeVect * vt  = TypeVect::make(elem_bt, num_elem);\n@@ -612,1 +609,1 @@\n-    Node* bcast_step     = gvn().transform(VectorNode::scalar2vector(step, num_elem, type_bt));\n+    Node* bcast_step = gvn().transform(VectorNode::scalar2vector(step, num_elem, elem_bt));\n@@ -621,1 +618,1 @@\n-    Node* bcast_start    = gvn().transform(VectorNode::scalar2vector(start, num_elem, type_bt));\n+    Node* bcast_start    = gvn().transform(VectorNode::scalar2vector(start, num_elem, elem_bt));\n@@ -626,1 +623,1 @@\n-  Node * bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, type_bt));\n+  Node * bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, elem_bt));\n@@ -853,1 +850,1 @@\n-    broadcast = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt), is_mask);\n+    broadcast = VectorNode::scalar2vector(elem, num_elem, elem_bt, is_mask);\n@@ -1297,1 +1294,1 @@\n-      zero = gvn().transform(VectorNode::scalar2vector(zero, mem_num_elem, Type::get_const_basic_type(mem_elem_bt)));\n+      zero = gvn().transform(VectorNode::scalar2vector(zero, mem_num_elem, mem_elem_bt));\n@@ -1623,1 +1620,1 @@\n-    Node* reduce_identity = gvn().transform(VectorNode::scalar2vector(init, num_elem, Type::get_const_basic_type(elem_bt)));\n+    Node* reduce_identity = gvn().transform(VectorNode::scalar2vector(init, num_elem, elem_bt));\n@@ -2004,1 +2001,1 @@\n-      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, Type::get_const_basic_type(elem_bt)));\n+      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, elem_bt));\n@@ -2179,1 +2176,0 @@\n-      const Type * type_bt = Type::get_const_basic_type(elem_bt);\n@@ -2181,1 +2177,1 @@\n-      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, type_bt));\n+      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, elem_bt));\n@@ -2839,1 +2835,1 @@\n-    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, Type::get_const_basic_type(elem_bt)));\n+    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, elem_bt));\n@@ -2952,1 +2948,1 @@\n-    indexLimit = gvn().transform(VectorNode::scalar2vector(indexLimit, num_elem, Type::get_const_basic_type(elem_bt)));\n+    indexLimit = gvn().transform(VectorNode::scalar2vector(indexLimit, num_elem, elem_bt));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -802,4 +803,3 @@\n-VectorNode* VectorNode::scalar2vector(Node* s, uint vlen, const Type* opd_t, bool is_mask) {\n-  BasicType bt = opd_t->array_element_basic_type();\n-  if (is_mask && Matcher::match_rule_supported_vector(Op_MaskAll, vlen, bt)) {\n-    const TypeVect* vt = TypeVect::make(opd_t, vlen, true);\n+VectorNode* VectorNode::scalar2vector(Node* s, uint vlen, BasicType elem_bt, bool is_mask) {\n+  if (is_mask && Matcher::match_rule_supported_vector(Op_MaskAll, vlen, elem_bt)) {\n+    const TypeVect* vt = TypeVect::make(elem_bt, vlen, true);\n@@ -809,2 +809,1 @@\n-  const TypeVect* vt = opd_t->singleton() ? TypeVect::make(opd_t, vlen)\n-                                          : TypeVect::make(bt, vlen);\n+  const TypeVect* vt = TypeVect::make(elem_bt, vlen);\n@@ -1629,2 +1628,0 @@\n-    const Type* elem_ty = Type::get_const_basic_type(bt);\n-\n@@ -1642,2 +1639,2 @@\n-    Node* vector_mask = phase->transform(VectorNode::scalar2vector(shift_mask_node, vlen, elem_ty));\n-    Node* vector_one = phase->transform(VectorNode::scalar2vector(const_one_node, vlen, elem_ty));\n+    Node* vector_mask = phase->transform(VectorNode::scalar2vector(shift_mask_node, vlen, bt));\n+    Node* vector_one = phase->transform(VectorNode::scalar2vector(const_one_node, vlen, bt));\n@@ -1762,0 +1759,71 @@\n+const TypeVect* VectorUnboxNode::try_constant_fold(PhaseGVN* phase) const {\n+  if (!Matcher::match_rule_supported(Op_ConV)) {\n+    return nullptr;\n+  }\n+  const TypeVect* vt = bottom_type()->is_vect();\n+  const TypeInstPtr* vbox_type = phase->type(obj())->isa_instptr();\n+  if (vbox_type == nullptr || !vbox_type->singleton()) {\n+    return nullptr;\n+  }\n+\n+  ciInstance* vbox = vbox_type->const_oop()->as_instance();\n+  OrderAccess::acquire();\n+  ciInstanceKlass* vbox_klass = vbox->klass()->as_instance_klass();\n+  ciField* payload_field = vbox_klass->get_field_by_name(ciSymbols::payload_name(), ciSymbols::object_signature(), false);\n+  ciArray* payload = vbox->field_value(payload_field).as_object()->as_array();\n+\n+  if (vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass())) {\n+    return nullptr;\n+  } else if (vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass())) {\n+    assert(payload->element_basic_type() == T_BOOLEAN, \"unexpected payload type: %s\", type2name(payload->element_basic_type()));\n+    if (vt->isa_vectmask()) {\n+      return TypeVectMask::make(vt->element_basic_type(), vt->length(), [&](uint idx) {\n+        return payload->element_value(idx).as_boolean() ? TypeInt::ONE : TypeInt::ZERO;\n+      });\n+    } else {\n+      assert(is_integral_type(vt->element_basic_type()), \"must be\");\n+      if (vt->element_basic_type() == T_LONG) {\n+        return TypeVect::make(vt->element_basic_type(), vt->length(), [&](uint idx) {\n+          return payload->element_value(idx).as_boolean() ? TypeLong::MINUS_1 : TypeLong::ZERO;\n+        });\n+      } else {\n+        return TypeVect::make(vt->element_basic_type(), vt->length(), [&](uint idx) {\n+          return payload->element_value(idx).as_boolean() ? TypeInt::MINUS_1 : TypeInt::ZERO;\n+        });\n+      }\n+    }\n+  }\n+\n+  assert(payload->element_basic_type() == vt->element_basic_type(), \"mismatched vector types %s vs %s\",\n+         type2name(payload->element_basic_type()), type2name(vt->element_basic_type()));\n+  switch (vt->element_basic_type()) {\n+  case T_BYTE:\n+    return TypeVect::make(T_BYTE, vt->length(), [&](uint idx) {\n+      return TypeInt::make(payload->element_value(idx).as_byte());\n+    });\n+  case T_SHORT:\n+    return TypeVect::make(T_SHORT, vt->length(), [&](uint idx) {\n+      return TypeInt::make(payload->element_value(idx).as_short());\n+    });\n+  case T_INT:\n+    return TypeVect::make(T_INT, vt->length(), [&](uint idx) {\n+      return TypeInt::make(payload->element_value(idx).as_int());\n+    });\n+  case T_LONG:\n+    return TypeVect::make(T_LONG, vt->length(), [&](uint idx) {\n+      return TypeLong::make(payload->element_value(idx).as_long());\n+    });\n+  case T_FLOAT:\n+    return TypeVect::make(T_FLOAT, vt->length(), [&](uint idx) {\n+      return TypeF::make(payload->element_value(idx).as_float());\n+    });\n+  case T_DOUBLE:\n+    return TypeVect::make(T_DOUBLE, vt->length(), [&](uint idx) {\n+      return TypeD::make(payload->element_value(idx).as_double());\n+    });\n+  default:\n+    assert(false, \"%s\", type2name(vt->element_basic_type()));\n+    return nullptr;\n+  }\n+}\n+\n@@ -1885,1 +1953,1 @@\n-      const_minus_one = phase->transform(VectorNode::scalar2vector(const_minus_one, vlen, Type::get_const_basic_type(bt)));\n+      const_minus_one = phase->transform(VectorNode::scalar2vector(const_minus_one, vlen, bt));\n@@ -1890,1 +1958,1 @@\n-      const_one = phase->transform(VectorNode::scalar2vector(const_one, vlen, Type::get_const_basic_type(bt)));\n+      const_one = phase->transform(VectorNode::scalar2vector(const_one, vlen, bt));\n@@ -1907,1 +1975,1 @@\n-  const_zero = phase->transform(VectorNode::scalar2vector(const_zero, vlen, Type::get_const_basic_type(bt)));\n+  const_zero = phase->transform(VectorNode::scalar2vector(const_zero, vlen, bt));\n@@ -2072,2 +2140,1 @@\n-    return VectorNode::scalar2vector(zero, length(), Type::get_const_basic_type(bt),\n-                                     bottom_type()->isa_vectmask() != nullptr);\n+    return VectorNode::scalar2vector(zero, length(), bt, bottom_type()->isa_vectmask() != nullptr);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":82,"deletions":15,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  static VectorNode* scalar2vector(Node* s, uint vlen, const Type* opd_t, bool is_mask = false);\n+  static VectorNode* scalar2vector(Node* s, uint vlen, BasicType elem_bt, bool is_mask = false);\n@@ -1666,3 +1666,1 @@\n-     assert((!dst_vt->isa_vectmask() && !src_vt->isa_vectmask()) ||\n-            (type2aelembytes(src_vt->element_basic_type()) >= type2aelembytes(dst_vt->element_basic_type())),\n-            \"unsupported mask widening reinterpretation\");\n+     assert((!dst_vt->isa_vectmask() && !src_vt->isa_vectmask()) || dst_vt->length() >= src_vt->length(), \"unsupported mask reinterpretation\");\n@@ -1877,0 +1875,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1878,1 +1877,0 @@\n-  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1880,0 +1878,1 @@\n+  const TypeVect* try_constant_fold(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -425,2 +425,1 @@\n-  tty->print(\"vlen=%d element_type=\", _vlen);\n-  _element_type->dump();\n+  tty->print(\"vlen=%d element_type=%s\", _vlen, type2name(_element_type));;\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-  const Type* _element_type;\n+  BasicType _element_type;\n@@ -359,1 +359,1 @@\n-  VTransformReplicateNode(VTransform& vtransform, int vlen, const Type* element_type) :\n+  VTransformReplicateNode(VTransform& vtransform, int vlen, BasicType element_type) :\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,1 @@\n+  OrderAccess::release();\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,7 +122,7 @@\n-    private static final String TYPE_BYTE   = \"byte\";\n-    private static final String TYPE_CHAR   = \"char\";\n-    private static final String TYPE_SHORT  = \"short\";\n-    private static final String TYPE_INT    = \"int\";\n-    private static final String TYPE_LONG   = \"long\";\n-    private static final String TYPE_FLOAT  = \"float\";\n-    private static final String TYPE_DOUBLE = \"double\";\n+    private static final String TYPE_BYTE   = \"B\";\n+    private static final String TYPE_CHAR   = \"C\";\n+    private static final String TYPE_SHORT  = \"S\";\n+    private static final String TYPE_INT    = \"I\";\n+    private static final String TYPE_LONG   = \"J\";\n+    private static final String TYPE_FLOAT  = \"F\";\n+    private static final String TYPE_DOUBLE = \"D\";\n@@ -495,0 +495,5 @@\n+    public static final String CON_V = PREFIX + \"CON_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CON_V, \"ConV\");\n+    }\n+\n@@ -2306,1 +2311,1 @@\n-        String regex = START + irNodeRegex + MID  + IS_REPLACED + END;\n+        String regex = START + irNodeRegex + MID + IS_REPLACED + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,1 @@\n-        return nodeRegex.replaceAll(IRNode.IS_REPLACED,\n-                                    \"vector[A-Za-z]\\\\\\\\[\" + sizeRegex + \"\\\\\\\\]:\\\\\\\\{\" + type + \"\\\\\\\\}\");\n+        return nodeRegex.replaceAll(IRNode.IS_REPLACED, \"vector[A-Za-z]<\" + type + \",\" + sizeRegex + \">\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/RawIRNode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+\/**\n+ * @test\n+ * @bug 8341102\n+ * @library \/test\/lib \/\n+ * @summary Constant fold constant vectors into ConV nodes\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.TestConVNode\n+ *\/\n+public class TestConVNode {\n+    private static final ByteVector VB;\n+    private static final ShortVector VS;\n+    private static final IntVector VI;\n+    private static final LongVector VL;\n+    private static final FloatVector VF;\n+    private static final DoubleVector VD;\n+\n+    private static final byte[] AB;\n+    private static final short[] AS;\n+    private static final int[] AI;\n+    private static final long[] AL;\n+    private static final float[] AF;\n+    private static final double[] AD;\n+\n+    private static final IntVector V1;\n+    private static final IntVector V2;\n+    private static final IntVector V4;\n+    private static final IntVector V8;\n+\n+    private static final int[] A1;\n+    private static final int[] A2;\n+    private static final int[] A4;\n+    private static final int[] A8;\n+\n+    static {\n+        Random r = Utils.getRandomInstance();\n+        AB = new byte[ByteVector.SPECIES_PREFERRED.length()];\n+        for (int i = 0; i < AB.length; i++) {\n+            AB[i] = (byte) r.nextInt();\n+        }\n+        VB = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, AB, 0);\n+        AS = new short[ShortVector.SPECIES_PREFERRED.length()];\n+        for (int i = 0; i < AS.length; i++) {\n+            AS[i] = (short) r.nextInt();\n+        }\n+        VS = ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, AS, 0);\n+        AI = new int[IntVector.SPECIES_PREFERRED.length()];\n+        for (int i = 0; i < AI.length; i++) {\n+            AI[i] = r.nextInt();\n+        }\n+        VI = IntVector.fromArray(IntVector.SPECIES_PREFERRED, AI, 0);\n+        AL = new long[LongVector.SPECIES_PREFERRED.length()];\n+        for (int i = 0; i < AL.length; i++) {\n+            AL[i] = r.nextLong();\n+        }\n+        VL = LongVector.fromArray(LongVector.SPECIES_PREFERRED, AL, 0);\n+        AF = new float[FloatVector.SPECIES_PREFERRED.length()];\n+        for (int i = 0; i < AF.length; i++) {\n+            AF[i] = r.nextFloat();\n+        }\n+        VF = FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, AF, 0);\n+        AD = new double[DoubleVector.SPECIES_PREFERRED.length()];\n+        for (int i = 0; i < AD.length; i++) {\n+            AD[i] = r.nextDouble();\n+        }\n+        VD = DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, AD, 0);\n+\n+        A1 = new int[IntVector.SPECIES_PREFERRED.length()];\n+        A2 = new int[IntVector.SPECIES_PREFERRED.length()];\n+        A4 = new int[IntVector.SPECIES_PREFERRED.length()];\n+        A8 = new int[IntVector.SPECIES_PREFERRED.length()];\n+        A1[0] = r.nextInt();\n+        for (int i = 1; i < A1.length; i++) {\n+            A1[i] = A1[0];\n+        }\n+        for (int i = 0; i < A2.length; i++) {\n+            if (i < 2) {\n+                A2[i] = r.nextInt();\n+            } else {\n+                A2[i] = A2[i - 2];\n+            }\n+        }\n+        for (int i = 0; i < A4.length; i++) {\n+            if (i < 4) {\n+                A4[i] = r.nextInt();\n+            } else {\n+                A4[i] = A4[i - 4];\n+            }\n+        }\n+        for (int i = 0; i < A8.length; i++) {\n+            if (i < 8) {\n+                A8[i] = r.nextInt();\n+            } else {\n+                A8[i] = A8[i - 8];\n+            }\n+        }\n+        V1 = IntVector.fromArray(IntVector.SPECIES_PREFERRED, A1, 0);\n+        V2 = IntVector.fromArray(IntVector.SPECIES_PREFERRED, A2, 0);\n+        V4 = IntVector.fromArray(IntVector.SPECIES_PREFERRED, A4, 0);\n+        V8 = IntVector.fromArray(IntVector.SPECIES_PREFERRED, A8, 0);\n+    }\n+\n+    @Run(test = {\"testByteVector\", \"testShortVector\", \"testIntVector\",\n+            \"testLongVector\", \"testFloatVector\", \"testDoubleVector\",\n+            \"testReplicate1IntVector\", \"testReplicate2IntVector\",\n+            \"testReplicate4IntVector\", \"testReplicate8IntVector\"})\n+    public void run() {\n+        byte[] rb = new byte[VB.length()];\n+        testByteVector(rb);\n+        Asserts.assertTrue(Arrays.equals(AB, rb));\n+        short[] rs = new short[VS.length()];\n+        testShortVector(rs);\n+        Asserts.assertTrue(Arrays.equals(AS, rs));\n+        int[] ri = new int[VI.length()];\n+        testIntVector(ri);\n+        Asserts.assertTrue(Arrays.equals(AI, ri));\n+        long[] rl = new long[VL.length()];\n+        testLongVector(rl);\n+        Asserts.assertTrue(Arrays.equals(AL, rl));\n+        float[] rf = new float[VF.length()];\n+        testFloatVector(rf);\n+        Asserts.assertEquals(AF.length, rf.length);\n+        for (int i = 0; i < rf.length; i++) {\n+            Asserts.assertEquals(Float.floatToRawIntBits(AF[i]), Float.floatToRawIntBits(rf[i]));\n+        }\n+        double[] rd = new double[VD.length()];\n+        testDoubleVector(rd);\n+        Asserts.assertEquals(AD.length, rd.length);\n+        for (int i = 0; i < rd.length; i++) {\n+            Asserts.assertEquals(Double.doubleToRawLongBits(AD[i]), Double.doubleToRawLongBits(rd[i]));\n+        }\n+        int[] r1 = new int[V1.length()];\n+        testReplicate1IntVector(r1);\n+        Asserts.assertTrue(Arrays.equals(A1, r1));\n+        int[] r2 = new int[V2.length()];\n+        testReplicate2IntVector(r2);\n+        Asserts.assertTrue(Arrays.equals(A2, r2));\n+        int[] r4 = new int[V4.length()];\n+        testReplicate4IntVector(r4);\n+        Asserts.assertTrue(Arrays.equals(A4, r4));\n+        int[] r8 = new int[V8.length()];\n+        testReplicate8IntVector(r8);\n+        Asserts.assertTrue(Arrays.equals(A8, r8));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_V, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    public void testByteVector(byte[] r) {\n+        VB.intoArray(r, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_V, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    public void testShortVector(short[] r) {\n+        VS.intoArray(r, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_V, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    public void testIntVector(int[] r) {\n+        VI.intoArray(r, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_V, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    public void testLongVector(long[] r) {\n+        VL.intoArray(r, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_V, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    public void testFloatVector(float[] r) {\n+        VF.intoArray(r, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_V, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    public void testDoubleVector(double[] r) {\n+        VD.intoArray(r, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_V, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    public void testReplicate1IntVector(int[] r) {\n+        V1.intoArray(r, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_V, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    public void testReplicate2IntVector(int[] r) {\n+        V2.intoArray(r, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_V, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    public void testReplicate4IntVector(int[] r) {\n+        V4.intoArray(r, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_V, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    public void testReplicate8IntVector(int[] r) {\n+        V8.intoArray(r, 0);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestConVNode.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -960,10 +960,0 @@\n-    @Test\n-    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_L, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n-    public static void testStoreLoadLongVectorDifferentSpeciesVector() {\n-        long[] res = new long[L_SPECIES.length()];\n-        longVector.intoArray(res, 0);\n-        LongVector res2 = LongVector.fromArray(LongVector.SPECIES_64, res, 0);\n-        Asserts.assertFalse(L_SPECIES.length() != 1 && res2.equals(longVector));\n-    }\n-\n-\n@@ -1026,10 +1016,0 @@\n-    @Test\n-    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_I, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n-    public static void testStoreLoadIntVectorDifferentSpeciesVector() {\n-        int[] res = new int[I_SPECIES.length()];\n-        intVector.intoArray(res, 0);\n-        IntVector res2 = IntVector.fromArray(IntVector.SPECIES_64, res, 0);\n-        Asserts.assertNotEquals(res2, intVector);\n-    }\n-\n-\n@@ -1092,10 +1072,0 @@\n-    @Test\n-    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_D, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n-    public static void testStoreLoadDoubleVectorDifferentSpeciesVector() {\n-        double[] res = new double[D_SPECIES.length()];\n-        doubleVector.intoArray(res, 0);\n-        DoubleVector res2 = DoubleVector.fromArray(DoubleVector.SPECIES_64, res, 0);\n-        Asserts.assertFalse(D_SPECIES.length() != 1 && res2.equals(doubleVector));\n-    }\n-\n-\n@@ -1158,10 +1128,0 @@\n-    @Test\n-    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_F, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n-    public static void testStoreLoadFloatVectorDifferentSpeciesVector() {\n-        float[] res = new float[F_SPECIES.length()];\n-        floatVector.intoArray(res, 0);\n-        FloatVector res2 = FloatVector.fromArray(FloatVector.SPECIES_64, res, 0);\n-        Asserts.assertNotEquals(res2, floatVector);\n-    }\n-\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherMaskFoldingTest.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"}]}