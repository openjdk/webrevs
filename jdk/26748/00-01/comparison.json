{"files":[{"patch":"@@ -1277,0 +1277,7 @@\n+  void load_store_volatile(Register data, BasicType type, Register addr,\n+                           bool is_load) {\n+     load_store_exclusive(dummy_reg, data, dummy_reg, addr,\n+                          (Assembler::operand_size)exact_log2(type2aelembytes(type)),\n+                          is_load ? 0b110: 0b100, 1);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -916,8 +916,0 @@\n-  if (is_floating_point_type(type)) {\n-    \/\/ Use LDAR instead of DMB+LD+DMB, except for floats\/doubles (no LDAR equivalent).\n-    if (!CompilerConfig::is_c1_only_no_jvmci()) {\n-      __ membar(__ AnyAny);\n-    }\n-    mem2reg(src, dest, type, patch_code, info, false);\n-    return;\n-  }\n@@ -941,0 +933,7 @@\n+\n+  Register dest_reg = rscratch2;\n+  if (!is_floating_point_type(type)) {\n+    dest_reg = (dest->is_single_cpu()\n+                ? dest->as_register() : dest->as_register_lo());\n+  }\n+  __ load_store_volatile(dest_reg, type, rscratch1, \/*is_load*\/true);\n@@ -942,6 +941,3 @@\n-    case T_BOOLEAN:\n-      __ ldarb(dest->as_register(), rscratch1);\n-      break;\n-    case T_BYTE: \/\/ LDAR is unsigned so need to sign-extend for byte\n-      __ ldarb(dest->as_register(), rscratch1);\n-      __ sxtb(dest->as_register(), dest->as_register());\n+    \/\/ LDAR is unsigned so need to sign-extend for byte and short\n+    case T_BYTE:\n+      __ sxtb(dest_reg, dest_reg);\n@@ -949,12 +945,2 @@\n-    case T_CHAR:\n-      __ ldarh(dest->as_register(), rscratch1);\n-      break;\n-    case T_SHORT: \/\/ LDAR is unsigned so need to sign-extend for short\n-      __ ldarh(dest->as_register(), rscratch1);\n-      __ sxth(dest->as_register(), dest->as_register());\n-      break;\n-    case T_INT:\n-      __ ldarw(dest->as_register(), rscratch1);\n-      break;\n-    case T_ADDRESS:\n-      __ ldar(dest->as_register(), rscratch1);\n+    case T_SHORT:\n+      __ sxth(dest_reg, dest_reg);\n@@ -962,2 +948,3 @@\n-    case T_LONG:\n-      __ ldar(dest->as_register_lo(), rscratch1);\n+    \/\/ need to move from GPR to FPR after LDAR with FMOV for floating types\n+    case T_FLOAT:\n+      __ fmovs(dest->as_float_reg(), dest_reg);\n@@ -965,7 +952,2 @@\n-    case T_ARRAY:\n-    case T_OBJECT:\n-      if (UseCompressedOops) {\n-        __ ldarw(dest->as_register(), rscratch1);\n-      } else {\n-        __ ldar(dest->as_register(), rscratch1);\n-      }\n+    case T_DOUBLE:\n+      __ fmovd(dest->as_double_reg(), dest_reg);\n@@ -973,5 +955,0 @@\n-    case T_METADATA:\n-      \/\/ We get here to store a method pointer to the stack to pass to\n-      \/\/ a dtrace runtime call. This can't work on 64 bit with\n-      \/\/ compressed klass ptrs: T_METADATA can be a compressed klass\n-      \/\/ ptr or a 64 bit method pointer.\n@@ -979,1 +956,1 @@\n-      ShouldNotReachHere();\n+      break;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":18,"deletions":41,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1418,1 +1418,1 @@\n-  return AlwaysAtomicAccesses || is_floating_point_type(address->type());\n+  return AlwaysAtomicAccesses;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-    \/\/  Hence trailing DMB is no longer needed.\n+    \/\/ Hence trailing DMB is no longer needed.\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}