{"files":[{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1277,0 +1278,7 @@\n+  void load_store_volatile(Register data, BasicType type, Register addr,\n+                           bool is_load) {\n+     load_store_exclusive(dummy_reg, data, dummy_reg, addr,\n+                          (Assembler::operand_size)exact_log2(type2aelembytes(type)),\n+                          is_load ? 0b110: 0b100, 1);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -907,0 +908,5 @@\n+void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type,\n+                            LIR_PatchCode patch_code, CodeEmitInfo* info,\n+                            bool wide) {\n+  mem2reg(src, dest, type, patch_code, info, wide, false);\n+}\n@@ -908,1 +914,3 @@\n-void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide) {\n+void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type,\n+                            LIR_PatchCode patch_code, CodeEmitInfo* info,\n+                            bool wide, bool is_volatile) {\n@@ -924,1 +932,18 @@\n-  int null_check_here = code_offset();\n+\n+  if (is_volatile) {\n+    load_volatile(from_addr, dest, type);\n+  } else {\n+    load_relaxed(from_addr, dest, type, wide);\n+  }\n+\n+  if (is_reference_type(type)) {\n+    if (UseCompressedOops && !wide) {\n+      __ decode_heap_oop(dest->as_register());\n+    }\n+\n+    __ verify_oop(dest->as_register());\n+  }\n+}\n+\n+void LIR_Assembler::load_relaxed(LIR_Address *from_addr, LIR_Opr dest,\n+                                 BasicType type, bool wide) {\n@@ -982,0 +1007,1 @@\n+}\n@@ -983,4 +1009,3 @@\n-  if (is_reference_type(type)) {\n-    if (UseCompressedOops && !wide) {\n-      __ decode_heap_oop(dest->as_register());\n-    }\n+void LIR_Assembler::load_volatile(LIR_Address *from_addr, LIR_Opr dest,\n+                                  BasicType type) {\n+  __ lea(rscratch1, as_Address(from_addr));\n@@ -988,1 +1013,4 @@\n-    __ verify_oop(dest->as_register());\n+  Register dest_reg = rscratch2;\n+  if (!is_floating_point_type(type)) {\n+    dest_reg = (dest->is_single_cpu()\n+                ? dest->as_register() : dest->as_register_lo());\n@@ -990,1 +1018,0 @@\n-}\n@@ -992,0 +1019,22 @@\n+  \/\/ Uses LDAR to ensure memory ordering.\n+  __ load_store_volatile(dest_reg, type, rscratch1, \/*is_load*\/true);\n+\n+  switch (type) {\n+    \/\/ LDAR is unsigned so need to sign-extend for byte and short\n+    case T_BYTE:\n+      __ sxtb(dest_reg, dest_reg);\n+      break;\n+    case T_SHORT:\n+      __ sxth(dest_reg, dest_reg);\n+      break;\n+    \/\/ need to move from GPR to FPR after LDAR with FMOV for floating types\n+    case T_FLOAT:\n+      __ fmovs(dest->as_float_reg(), dest_reg);\n+      break;\n+    case T_DOUBLE:\n+      __ fmovd(dest->as_double_reg(), dest_reg);\n+      break;\n+    default:\n+      break;\n+  }\n+}\n@@ -2831,1 +2880,3 @@\n-  if (dest->is_address() || src->is_address()) {\n+  if (src->is_address()) {\n+    mem2reg(src, dest, type, lir_patch_none, info, \/*wide*\/false, \/*is_volatile*\/true);\n+  } else if (dest->is_address()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":60,"deletions":9,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -61,0 +61,6 @@\n+  void mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type,\n+               LIR_PatchCode patch_code,\n+               CodeEmitInfo* info, bool wide, bool is_volatile);\n+  void load_relaxed(LIR_Address *from_addr, LIR_Opr dest, BasicType type, bool wide);\n+  void load_volatile(LIR_Address *from_addr, LIR_Opr dest, BasicType type);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1403,1 +1404,1 @@\n-void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n+bool LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n@@ -1405,9 +1406,0 @@\n-  \/\/ 8179954: We need to make sure that the code generated for\n-  \/\/ volatile accesses forms a sequentially-consistent set of\n-  \/\/ operations when combined with STLR and LDAR.  Without a leading\n-  \/\/ membar it's possible for a simple Dekker test to fail if loads\n-  \/\/ use LD;DMB but stores use STLR.  This can happen if C2 compiles\n-  \/\/ the stores in one method and C1 compiles the loads in another.\n-  if (!CompilerConfig::is_c1_only_no_jvmci()) {\n-    __ membar();\n-  }\n@@ -1415,0 +1407,1 @@\n+  return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1321,1 +1321,1 @@\n-void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n+bool LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n@@ -1335,1 +1335,2 @@\n-    return;\n+  } else {\n+    __ load(address, result, info, lir_patch_none);\n@@ -1337,1 +1338,1 @@\n-  __ load(address, result, info, lir_patch_none);\n+  return true;\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1138,1 +1138,1 @@\n-void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n+bool LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n@@ -1146,0 +1146,1 @@\n+  return true;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1173,1 +1173,1 @@\n-void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n+bool LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n@@ -1176,0 +1176,1 @@\n+  return true;\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1046,1 +1046,1 @@\n-void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n+bool LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n@@ -1049,0 +1049,1 @@\n+  return true;\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1423,1 +1423,1 @@\n-void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n+bool LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n@@ -1439,0 +1439,1 @@\n+  return true;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-  \/\/ it always known as well.\n+  \/\/ is always known as well.\n@@ -335,1 +335,3 @@\n-  void volatile_field_load(LIR_Address* address, LIR_Opr result, CodeEmitInfo* info);\n+\n+  \/\/ returns false if it provides trailing membar semantics. Else returns true.\n+  bool volatile_field_load(LIR_Address* address, LIR_Opr result, CodeEmitInfo* info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -186,0 +187,1 @@\n+  bool needs_trailing_dmb = is_volatile;\n@@ -195,1 +197,4 @@\n-    gen->volatile_field_load(access.resolved_addr()->as_address_ptr(), result, access.access_emit_info());\n+    \/\/ volatile_field_load returns false if it itself provides trailing membar semantics.\n+    \/\/ Hence trailing DMB is no longer needed.\n+    needs_trailing_dmb &= gen->volatile_field_load(access.resolved_addr()->as_address_ptr(),\n+                                                   result, access.access_emit_info());\n@@ -200,1 +205,1 @@\n-  if (is_volatile) {\n+  if (needs_trailing_dmb) {\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}