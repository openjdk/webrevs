{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -32,0 +33,1 @@\n+import java.nio.channels.FileChannel;\n@@ -34,2 +36,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n@@ -723,0 +723,36 @@\n+        \/**\n+         * {@return a request body publisher whose body is the {@code length}\n+         * content bytes read from the provided file {@code channel} starting\n+         * from the specified {@code offset}}\n+         * <p>\n+         * The {@linkplain FileChannel file channel} will be read using\n+         * {@link FileChannel#read(ByteBuffer, long) FileChannel.read(ByteBuffer buffer, long position)},\n+         * which does not modify the channel's position. Thus, the same file\n+         * channel may be shared between several publishers passed to\n+         * concurrent requests.\n+         * <p>\n+         * The file channel will not be closed upon completion. The caller is\n+         * expected to manage the life cycle of the channel, and close it\n+         * appropriately when not needed anymore.\n+         *\n+         * @param channel a file channel\n+         * @param offset the offset of the first byte\n+         * @param length the number of bytes to read from the file channel\n+         *\n+         * @throws IndexOutOfBoundsException if the specified byte range is\n+         * found to be {@linkplain Objects#checkFromIndexSize(long, long, long)\n+         * out of bounds} compared with the size of the file referred by the\n+         * channel\n+         *\n+         * @throws IOException if the size of the file referred by the provided\n+         * channel cannot be read while verifying the specified byte range\n+         *\n+         * @throws NullPointerException if {@code channel} is null\n+         *\n+         * @since 26\n+         *\/\n+        public static BodyPublisher ofFileChannel(FileChannel channel, long offset, long length) throws IOException {\n+            Objects.requireNonNull(channel, \"channel\");\n+            return new RequestPublishers.FileChannelPublisher(channel, offset, length);\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpRequest.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.channels.FileChannel;\n@@ -421,0 +422,75 @@\n+    public static final class FileChannelPublisher implements BodyPublisher {\n+\n+        private final FileChannel channel;\n+\n+        private final long position;\n+\n+        private final long limit;\n+\n+        public FileChannelPublisher(FileChannel channel, long offset, long length) throws IOException {\n+            this.channel = Objects.requireNonNull(channel, \"channel\");\n+            long fileSize = channel.size();\n+            Objects.checkFromIndexSize(offset, length, fileSize);\n+            this.position = offset;\n+            this.limit = offset + length;\n+        }\n+\n+        @Override\n+        public long contentLength() {\n+            return limit - position;\n+        }\n+\n+        @Override\n+        public void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n+            Iterable<ByteBuffer> iterable = () -> new FileChannelIterator(channel, position, limit);\n+            new PullPublisher<>(iterable).subscribe(subscriber);\n+        }\n+\n+    }\n+\n+    private static final class FileChannelIterator implements Iterator<ByteBuffer> {\n+\n+        private final FileChannel channel;\n+\n+        private final long limit;\n+\n+        private long position;\n+\n+        private boolean terminated;\n+\n+        private FileChannelIterator(FileChannel channel, long position, long limit) {\n+            this.channel = channel;\n+            this.position = position;\n+            this.limit = limit;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return position < limit && !terminated;\n+        }\n+\n+        @Override\n+        public ByteBuffer next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            long remaining = limit - position;\n+            ByteBuffer buffer = Utils.getBufferWithAtMost(remaining);\n+            try {\n+                int readLength = channel.read(buffer, position);\n+                \/\/ Short-circuit if `read()` has failed, e.g., due to file content being changed in the meantime\n+                if (readLength < 0) {\n+                    \/\/ Throw to signal that the request needs to be cancelled\n+                    throw new IOException(\"Unexpected EOF (position=%s)\".formatted(position));\n+                } else {\n+                    position += readLength;\n+                }\n+            } catch (IOException ioe) {\n+                terminated = true;\n+                throw new UncheckedIOException(ioe);\n+            }\n+            return buffer.flip();\n+        }\n+\n+    }\n+\n@@ -433,1 +509,1 @@\n-        public final long contentLength() {\n+        public long contentLength() {\n@@ -438,1 +514,1 @@\n-        public final void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n+        public void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RequestPublishers.java","additions":78,"deletions":2,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -370,0 +370,4 @@\n+\n+    \/**\n+     * {@return a new {@link ByteBuffer} instance of {@link #BUFSIZE} capacity}\n+     *\/\n@@ -374,0 +378,18 @@\n+    \/**\n+     * {@return a new {@link ByteBuffer} instance whose capacity is set to the\n+     * smaller of the specified {@code maxCapacity} and the default\n+     * ({@value BUFSIZE})}\n+     *\n+     * @param maxCapacity a buffer capacity, in bytes\n+     * @throws IllegalArgumentException if {@code maxCapacity < 0}\n+     *\/\n+    public static ByteBuffer getBufferWithAtMost(long maxCapacity) {\n+        if (maxCapacity < 0) {\n+            throw new IllegalArgumentException(\n+                    \/\/ Match the message produced by `ByteBuffer::createCapacityException`\n+                    \"capacity < 0: (%s < 0)\".formatted(maxCapacity));\n+        }\n+        int effectiveCapacity = (int) Math.min(maxCapacity, BUFSIZE);\n+        return ByteBuffer.allocate(effectiveCapacity);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,708 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verifies `HttpRequest.BodyPublishers::ofFileChannel`\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit FileChannelPublisherTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpResponse.BodyHandlers.discarding;\n+import static java.net.http.HttpResponse.BodyHandlers.ofInputStream;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FileChannelPublisherTest {\n+\n+    private static final String CLASS_NAME = FileChannelPublisherTest.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n+\n+    private static final int DEFAULT_BUFFER_SIZE = Utils.getBuffer().capacity();\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    private static final HttpClient CLIENT = HttpClient.newBuilder().sslContext(SSL_CONTEXT).proxy(NO_PROXY).build();\n+\n+    private static final ExecutorService EXECUTOR = Executors.newCachedThreadPool();\n+\n+    private static final ServerRequestPair\n+            HTTP1 = ServerRequestPair.of(Version.HTTP_1_1, false),\n+            HTTPS1 = ServerRequestPair.of(Version.HTTP_1_1, true),\n+            HTTP2 = ServerRequestPair.of(Version.HTTP_2, false),\n+            HTTPS2 = ServerRequestPair.of(Version.HTTP_2, true);\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    private record ServerRequestPair(\n+            String serverName,\n+            HttpTestServer server,\n+            BlockingQueue<byte[]> serverReadRequestBodyBytes,\n+            HttpRequest.Builder requestBuilder,\n+            boolean secure) {\n+\n+        private static CountDownLatch SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+\n+        private static CountDownLatch SERVER_READ_PERMISSION = null;\n+\n+        private static ServerRequestPair of(Version version, boolean secure) {\n+\n+            \/\/ Create the server\n+            SSLContext sslContext = secure ? SSL_CONTEXT : null;\n+            HttpTestServer server = createServer(version, sslContext);\n+            String serverName = secure ? version.toString().replaceFirst(\"_\", \"S_\") : version.toString();\n+\n+            \/\/ Add the handler\n+            String handlerPath = \"\/%s\/\".formatted(CLASS_NAME);\n+            BlockingQueue<byte[]> serverReadRequestBodyBytes =\n+                    addRequestBodyConsumingServerHandler(serverName, server, handlerPath);\n+\n+            \/\/ Create the request builder\n+            String requestUriScheme = secure ? \"https\" : \"http\";\n+            \/\/ `x` suffix in the URI is not a typo, but ensures that *only* the parent handler path is matched\n+            URI requestUri = URI.create(\"%s:\/\/%s%sx\".formatted(requestUriScheme, server.serverAuthority(), handlerPath));\n+            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(requestUri).version(version);\n+\n+            \/\/ Create the pair\n+            ServerRequestPair pair = new ServerRequestPair(serverName, server, serverReadRequestBodyBytes, requestBuilder, secure);\n+            pair.server.start();\n+            LOGGER.log(\"Server[%s] is started at `%s`\", pair, server.serverAuthority());\n+\n+            return pair;\n+\n+        }\n+\n+        private static HttpTestServer createServer(Version version, SSLContext sslContext) {\n+            try {\n+                \/\/ The default HTTP\/1.1 test server processes requests sequentially.\n+                \/\/ This causes a deadlock for concurrent tests such as `testSlicedUpload()`.\n+                \/\/ Hence, explicitly providing a multithreaded executor for HTTP\/1.1.\n+                ExecutorService executor = Version.HTTP_1_1.equals(version) ? EXECUTOR : null;\n+                return HttpTestServer.create(version, sslContext, executor);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static BlockingQueue<byte[]> addRequestBodyConsumingServerHandler(\n+                String serverName, HttpTestServer server, String handlerPath) {\n+            BlockingQueue<byte[]> readRequestBodyBytes = new LinkedBlockingQueue<>();\n+            HttpTestHandler handler = exchange -> {\n+                \/\/ `HttpTestExchange::toString` changes on failure, pin it\n+                String exchangeName = exchange.toString();\n+                try (exchange) {\n+\n+                    \/\/ Discard `HEAD` requests used for initial connection admission\n+                    if (\"HEAD\".equals(exchange.getRequestMethod())) {\n+                        exchange.sendResponseHeaders(200, -1L);\n+                        return;\n+                    }\n+\n+                    signalServerRequestReceived(serverName, exchangeName);\n+                    awaitServerReadPermission(serverName, exchangeName);\n+\n+                    LOGGER.log(\"Server[%s] is reading the request body (exchange=%s)\", serverName, exchangeName);\n+                    byte[] requestBodyBytes = exchange.getRequestBody().readAllBytes();\n+                    LOGGER.log(\"Server[%s] has read %s bytes (exchange=%s)\", serverName, requestBodyBytes.length, exchangeName);\n+                    readRequestBodyBytes.add(requestBodyBytes);\n+\n+                    LOGGER.log(\"Server[%s] is writing the response (exchange=%s)\", serverName, exchangeName);\n+                    exchange.sendResponseHeaders(200, requestBodyBytes.length);\n+                    exchange.getResponseBody().write(requestBodyBytes);\n+\n+                } catch (Throwable exception) {\n+                    LOGGER.log(\n+                            \"Server[%s] failed to process the request (exchange=%s)\".formatted(serverName, exception),\n+                            exception);\n+                    readRequestBodyBytes.add(new byte[0]);\n+                } finally {\n+                    LOGGER.log(\"Server[%s] completed processing the request (exchange=%s)\", serverName, exchangeName);\n+                }\n+            };\n+            server.addHandler(handler, handlerPath);\n+            return readRequestBodyBytes;\n+        }\n+\n+        private static void signalServerRequestReceived(String serverName, String exchangeName) {\n+            if (SERVER_REQUEST_RECEIVED_SIGNAL != null) {\n+                LOGGER.log(\"Server[%s] is signaling that the request is received (exchange=%s)\", serverName, exchangeName);\n+                SERVER_REQUEST_RECEIVED_SIGNAL.countDown();\n+            }\n+        }\n+\n+        private static void awaitServerReadPermission(String serverName, String exchangeName) {\n+            if (SERVER_READ_PERMISSION != null) {\n+                LOGGER.log(\"Server[%s] is waiting for the read permission (exchange=%s)\", serverName, exchangeName);\n+                try {\n+                    SERVER_READ_PERMISSION.await();\n+                } catch (InterruptedException ie) {\n+                    Thread.currentThread().interrupt();     \/\/ Restore the `interrupted` flag\n+                    throw new RuntimeException(ie);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return serverName;\n+        }\n+\n+    }\n+\n+    @AfterAll\n+    static void shutDown() {\n+        LOGGER.log(\"Closing the client\");\n+        CLIENT.close();\n+        LOGGER.log(\"Closing servers\");\n+        closeServers();\n+        LOGGER.log(\"Closing the executor\");\n+        EXECUTOR.shutdownNow();\n+    }\n+\n+    private static void closeServers() {\n+        Exception[] exceptionRef = {null};\n+        Stream\n+                .of(HTTP1, HTTPS1, HTTP2, HTTPS2)\n+                .map(pair -> (Runnable) pair.server::stop)\n+                .forEach(terminator -> {\n+                    try {\n+                        terminator.run();\n+                    } catch (Exception exception) {\n+                        if (exceptionRef[0] == null) {\n+                            exceptionRef[0] = exception;\n+                        } else {\n+                            exceptionRef[0].addSuppressed(exception);\n+                        }\n+                    }\n+                });\n+        if (exceptionRef[0] != null) {\n+            throw new RuntimeException(\"failed closing one or more server resources\", exceptionRef[0]);\n+        }\n+    }\n+\n+    \/**\n+     * Resets {@link ServerRequestPair#serverReadRequestBodyBytes()} to avoid leftover state from a test leaking to the next.\n+     *\/\n+    @BeforeEach\n+    void resetServerHandlerResults() {\n+        Stream\n+                .of(HTTP1, HTTPS1, HTTP2, HTTPS2)\n+                .forEach(pair -> pair.serverReadRequestBodyBytes.clear());\n+    }\n+\n+    static ServerRequestPair[] serverRequestPairs() {\n+        return new ServerRequestPair[]{\n+                HTTP1,\n+                HTTPS1,\n+                HTTP2,\n+                HTTPS2\n+        };\n+    }\n+\n+    @Test\n+    void testNullFileChannel() {\n+        assertThrows(NullPointerException.class, () -> BodyPublishers.ofFileChannel(null, 0, 1));\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+            \"6,-1,1\",   \/\/ offset < 0\n+            \"6,7,1\",    \/\/ offset > fileSize\n+            \"6,0,-1\",   \/\/ length < 0\n+            \"6,0,7\",    \/\/ length > fileSize\n+            \"6,2,5\"     \/\/ (offset + length) > fileSize\n+    })\n+    void testIllegalOffsetOrLength(\n+            int fileLength,\n+            int fileChannelOffset,\n+            int fileChannelLength,\n+            @TempDir Path tempDir) throws Exception {\n+        withFileChannel(tempDir.resolve(\"data.txt\"), fileLength, (_, fileChannel) ->\n+                assertThrows(\n+                        IndexOutOfBoundsException.class,\n+                        () -> BodyPublishers.ofFileChannel(fileChannel, fileChannelOffset, fileChannelLength)));\n+    }\n+\n+    \/**\n+     * Stresses corner cases in {@linkplain\n+     * BodyPublishers#ofFileChannel(FileChannel, long, long) the file channel\n+     * publisher}, which uses a {@linkplain #DEFAULT_BUFFER_SIZE fixed size}\n+     * buffer to read files, by providing sub-ranges and files that are\n+     * <em>smaller<\/em> than the buffer size.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testContentLessThanBufferSize(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Use a file of length smaller than the default buffer size\n+        int fileLength = 6;\n+        assertTrue(fileLength < DEFAULT_BUFFER_SIZE);\n+\n+        \/\/ Publish the `[0, fileLength)` sub-range\n+        testSuccessfulContentDelivery(\n+                \"Complete content\",\n+                pair, tempDir, fileLength, 0, fileLength);\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range to stress the inclusion of EOF\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = fileLength - 1;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength - 1)` sub-range to stress the exclusion of EOF\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = fileLength - 2;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Stresses corner cases in {@linkplain\n+     * BodyPublishers#ofFileChannel(FileChannel, long, long) the file channel\n+     * publisher}, which uses a {@linkplain #DEFAULT_BUFFER_SIZE fixed size}\n+     * buffer to read files, by providing sub-ranges and files that are\n+     * <em>bigger<\/em> than the buffer size.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testContentMoreThanBufferSize(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Use a file of length that is\n+        \/\/ 1. greater than the default buffer size\n+        \/\/ 2. *not* a multitude of the buffer size\n+        int fileLength = 1 + 3 * DEFAULT_BUFFER_SIZE;\n+\n+        \/\/ Publish the `[0, fileLength)` sub-range\n+        testSuccessfulContentDelivery(\n+                \"Complete content\",\n+                pair, tempDir, fileLength, 0, fileLength);\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is included\n+        \/\/ - the total length is a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF. Occupies exactly 3 buffers. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is included\n+        \/\/ - the total length is *not* a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE - 1;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF. Occupies 3 buffers, the last is custom sized. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is *not* included\n+        \/\/ - the total length is a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 2 * DEFAULT_BUFFER_SIZE;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF. Occupies exactly 2 buffers. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is *not* included\n+        \/\/ - the total length is *not* a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE - 2;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF. Occupies 3 buffers, the last is custom sized. \"+ debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+    }\n+\n+    private static String debuggingContext(int fileLength, int fileChannelOffset, int fileChannelLength) {\n+        Map<String, Object> context = new LinkedHashMap<>();    \/\/ Using `LHM` to preserve the insertion order\n+        context.put(\"DEFAULT_BUFFER_SIZE\", DEFAULT_BUFFER_SIZE);\n+        context.put(\"fileLength\", fileLength);\n+        context.put(\"fileChannelOffset\", fileChannelOffset);\n+        context.put(\"fileChannelLength\", fileChannelLength);\n+        boolean customSizedBuffer = fileChannelLength % DEFAULT_BUFFER_SIZE == 0;\n+        context.put(\"customSizedBuffer\", customSizedBuffer);\n+        return context.toString();\n+    }\n+\n+    private void testSuccessfulContentDelivery(\n+            String caseDescription,\n+            ServerRequestPair pair,\n+            Path tempDir,\n+            int fileLength,\n+            int fileChannelOffset,\n+            int fileChannelLength) throws Exception {\n+\n+        \/\/ Case names come handy even when no debug logging is enabled.\n+        \/\/ Hence, intentionally avoiding `Logger`.\n+        System.err.printf(\"Case: %s%n\", caseDescription);\n+\n+        \/\/ Create the file to upload\n+        String fileName = \"data-%d-%d-%d.txt\".formatted(fileLength, fileChannelOffset, fileChannelLength);\n+        Path filePath = tempDir.resolve(fileName);\n+        withFileChannel(filePath, fileLength, (fileBytes, fileChannel) -> {\n+\n+            \/\/ Upload the file\n+            HttpRequest request = pair\n+                    .requestBuilder\n+                    .POST(BodyPublishers.ofFileChannel(fileChannel, fileChannelOffset, fileChannelLength))\n+                    .build();\n+            CLIENT.send(request, discarding());\n+\n+            \/\/ Verify the received request body\n+            byte[] expectedRequestBodyBytes = new byte[fileChannelLength];\n+            System.arraycopy(fileBytes, fileChannelOffset, expectedRequestBodyBytes, 0, fileChannelLength);\n+            byte[] actualRequestBodyBytes = pair.serverReadRequestBodyBytes.take();\n+            assertArrayEquals(expectedRequestBodyBytes, actualRequestBodyBytes);\n+\n+        });\n+\n+    }\n+\n+    \/**\n+     * <em>Big enough<\/em> file length to observe the effects of publisher state corruption while uploading.\n+     * <p>\n+     * Certain tests follow below steps:\n+     * <\/p>\n+     * <ol>\n+     * <li>Issue the request<\/li>\n+     * <li>Wait for the server's signal that the request (not the body!) is received<\/li>\n+     * <li>Corrupt the publisher's state; modify the file, close the file channel, etc.<\/li>\n+     * <li>Signal the server to proceed with reading<\/li>\n+     * <\/ol>\n+     * <p>\n+     * With small files, even before we permit the server to read (step 4), file gets already uploaded.\n+     * This voids the effect of state corruption (step 3).\n+     * To circumvent this, use this <em>big enough<\/em> file size.\n+     * <\/p>\n+     *\n+     * @see #testChannelCloseDuringPublisherRead(ServerRequestPair, Path)\n+     * @see #testFileModificationDuringPublisherRead(ServerRequestPair, Path)\n+     *\/\n+    private static final int BIG_FILE_LENGTH = 8 * 1024 * 1024;  \/\/ 8 MiB\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testChannelCloseDuringPublisherRead(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+        establishInitialConnection(pair);\n+        ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = new CountDownLatch(1);\n+        ServerRequestPair.SERVER_READ_PERMISSION = new CountDownLatch(1);\n+        try {\n+\n+            int fileLength = BIG_FILE_LENGTH;\n+            AtomicReference<Future<HttpResponse<Void>>> responseFutureRef = new AtomicReference<>();\n+            withFileChannel(tempDir.resolve(\"data.txt\"), fileLength, ((_, fileChannel) -> {\n+\n+                \/\/ Issue the request\n+                LOGGER.log(\"Issuing the request\");\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, 0, fileLength))\n+                        .build();\n+                responseFutureRef.set(CLIENT.sendAsync(request, discarding()));\n+\n+                \/\/ Wait for server to receive the request\n+                LOGGER.log(\"Waiting for the request to be received\");\n+                ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL.await();\n+\n+            }));\n+\n+            LOGGER.log(\"File channel is closed\");\n+\n+            \/\/ Let the server proceed\n+            LOGGER.log(\"Permitting the server to proceed\");\n+            ServerRequestPair.SERVER_READ_PERMISSION.countDown();\n+\n+            \/\/ Verifying the client failure\n+            LOGGER.log(\"Verifying the client failure\");\n+            Exception requestFailure0 = assertThrows(ExecutionException.class, () -> responseFutureRef.get().get());\n+            Exception requestFailure1 = assertInstanceOf(UncheckedIOException.class, requestFailure0.getCause());\n+            assertInstanceOf(ClosedChannelException.class, requestFailure1.getCause());\n+\n+            verifyServerIncompleteRead(pair, fileLength);\n+\n+        } finally {\n+            ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+            ServerRequestPair.SERVER_READ_PERMISSION = null;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testFileModificationDuringPublisherRead(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+        establishInitialConnection(pair);\n+        ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = new CountDownLatch(1);\n+        ServerRequestPair.SERVER_READ_PERMISSION = new CountDownLatch(1);\n+        try {\n+\n+            int fileLength = BIG_FILE_LENGTH;\n+            Path filePath = tempDir.resolve(\"data.txt\");\n+            withFileChannel(filePath, fileLength, ((_, fileChannel) -> {\n+\n+                \/\/ Issue the request\n+                LOGGER.log(\"Issuing the request\");\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, 0, fileLength))\n+                        .build();\n+                Future<HttpResponse<Void>> responseFuture = CLIENT.sendAsync(request, discarding());\n+\n+                \/\/ Wait for server to receive the request\n+                LOGGER.log(\"Waiting for the request to be received\");\n+                ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL.await();\n+\n+                \/\/ Modify the file\n+                LOGGER.log(\"Modifying the file\");\n+                Files.write(filePath, generateFileBytes(1));\n+\n+                \/\/ Let the server proceed\n+                LOGGER.log(\"Permitting the server to proceed\");\n+                ServerRequestPair.SERVER_READ_PERMISSION.countDown();\n+\n+                \/\/ Verifying the client failure\n+                LOGGER.log(\"Verifying the client failure\");\n+                Exception requestFailure0 = assertThrows(ExecutionException.class, responseFuture::get);\n+                Exception requestFailure1 = assertInstanceOf(UncheckedIOException.class, requestFailure0.getCause());\n+                Exception requestFailure2 = assertInstanceOf(IOException.class, requestFailure1.getCause());\n+                String requestFailure2Message = requestFailure2.getMessage();\n+                assertTrue(\n+                        requestFailure2Message.contains(\"Unexpected EOF\"),\n+                        \"unexpected message: \" + requestFailure2Message);\n+\n+                verifyServerIncompleteRead(pair, fileLength);\n+\n+            }));\n+\n+        } finally {\n+            ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+            ServerRequestPair.SERVER_READ_PERMISSION = null;\n+        }\n+    }\n+\n+    private static void verifyServerIncompleteRead(ServerRequestPair pair, int fileLength) throws InterruptedException {\n+        LOGGER.log(\"Verifying the server's incomplete read\");\n+        byte[] readRequestBodyBytes = pair.serverReadRequestBodyBytes.take();\n+        assertTrue(\n+                readRequestBodyBytes.length < fileLength,\n+                \"was expecting `readRequestBodyBytes < fileLength` (%s < %s)\".formatted(\n+                        readRequestBodyBytes.length, fileLength));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSlicedUpload(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Populate the file\n+        int sliceCount = 4;\n+        int sliceLength = 14_281; \/\/ Intentionally using a prime number to increase the chances of hitting corner cases\n+        int fileLength = sliceCount * sliceLength;\n+        byte[] fileBytes = generateFileBytes(fileLength);\n+        Path filePath = tempDir.resolve(\"data.txt\");\n+        Files.write(filePath, fileBytes, StandardOpenOption.CREATE);\n+\n+        List<InputStream> responseBodyStreams = new ArrayList<>(sliceCount);\n+        try (FileChannel fileChannel = FileChannel.open(filePath)) {\n+\n+            \/\/ Upload the complete file in mutually exclusive slices\n+            List<Future<HttpResponse<InputStream>>> responseFutures = new ArrayList<>(sliceCount);\n+            for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+                LOGGER.log(\"Issuing request %d\/%d\", (sliceIndex + 1), sliceCount);\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, sliceIndex * sliceLength, sliceLength))\n+                        .build();\n+                responseFutures.add(CLIENT.sendAsync(\n+                        request,\n+                        \/\/ Intentionally using an `InputStream` response\n+                        \/\/ handler to defer consuming the response body\n+                        \/\/ until after the file channel is closed:\n+                        ofInputStream()));\n+            }\n+\n+            \/\/ Collect response body `InputStream`s from all requests\n+            for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+                LOGGER.log(\"Collecting response body `InputStream` for request %d\/%d\", (sliceIndex + 1), sliceCount);\n+                HttpResponse<InputStream> response = responseFutures.get(sliceIndex).get();\n+                assertEquals(200, response.statusCode());\n+                responseBodyStreams.add(response.body());\n+            }\n+\n+        }\n+\n+        LOGGER.log(\"File channel is closed\");\n+\n+        \/\/ Verify response bodies\n+        for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+            LOGGER.log(\"Consuming response body %d\/%d\", (sliceIndex + 1), sliceCount);\n+            byte[] expectedResponseBodyBytes = new byte[sliceLength];\n+            System.arraycopy(fileBytes, sliceIndex * sliceLength, expectedResponseBodyBytes, 0, sliceLength);\n+            try (InputStream responseBodyStream = responseBodyStreams.get(sliceIndex)) {\n+                byte[] responseBodyBytes = responseBodyStream.readAllBytes();\n+                assertArrayEquals(expectedResponseBodyBytes, responseBodyBytes);\n+            }\n+        }\n+\n+    }\n+\n+    \/**\n+     * Performs the initial {@code HEAD} request to the specified server. This\n+     * effectively admits a connection to the client's pool, where all protocol\n+     * upgrades, handshakes, etc. are already performed.\n+     * <p>\n+     * HTTP\/2 test server consumes the complete request payload in the very\n+     * first upgrade frame. That is, if a client sends 100 MiB of data, all\n+     * of it will be consumed first before the configured handler is\n+     * invoked. Though certain tests expect the data to be consumed\n+     * piecemeal. To accommodate this, we ensure client has an upgraded\n+     * connection in the pool.\n+     * <\/p>\n+     *\/\n+    private static void establishInitialConnection(ServerRequestPair pair) {\n+        LOGGER.log(\"Server[%s] is getting queried for the initial connection pool admission\", pair);\n+        try {\n+            CLIENT.send(pair.requestBuilder.HEAD().build(), discarding());\n+        } catch (Exception exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    private static void withFileChannel(Path filePath, int fileLength, FileChannelConsumer fileChannelConsumer) throws Exception {\n+        byte[] fileBytes = generateFileBytes(fileLength);\n+        Files.write(filePath, fileBytes, StandardOpenOption.CREATE);\n+        try (FileChannel fileChannel = FileChannel.open(filePath)) {\n+            fileChannelConsumer.consume(fileBytes, fileChannel);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface FileChannelConsumer {\n+\n+        void consume(byte[] fileBytes, FileChannel fileChannel) throws Exception;\n+\n+    }\n+\n+    private static byte[] generateFileBytes(int length) {\n+        byte[] bytes = new byte[length];\n+        for (int i = 0; i < length; i++) {\n+            bytes[i] = (byte) i;\n+        }\n+        return bytes;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/FileChannelPublisherTest.java","additions":708,"deletions":0,"binary":false,"changes":708,"status":"added"}]}