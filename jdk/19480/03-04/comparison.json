{"files":[{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4162583 7054918 8130181\n+ * @bug 4162583 7054918 8130181 8028127\n@@ -29,1 +29,0 @@\n- * @run main\/othervm SynchronizedAccess\n@@ -60,1 +59,1 @@\n-        Asserts.assertEquals(providersCountBefore + 1, providersCountAfter);\n+        Asserts.assertEquals(providersCountBefore, providersCountAfter);\n@@ -63,1 +62,1 @@\n-    public static class AccessorThread extends Thread {\n+    static class AccessorThread extends Thread {\n@@ -77,0 +76,6 @@\n+                for (int i = 0; i < provs.length; i++) {\n+                    \/\/ Might install (>=0) or not (-1) if already installed\n+                    Security.addProvider(provs[i]);\n+                    Thread.yield();\n+                }\n+\n@@ -78,3 +83,0 @@\n-                    for (int i = 0; i < provs.length; i++) {\n-                        Security.addProvider(provs[i]);\n-                    }\n@@ -82,5 +84,1 @@\n-                    \/\/ Skip the first provider to ensure one is always available for getInstance.\n-                    \/\/ This prevents issues if other threads remove providers in parallel.\n-                    for (int i = 1; i < provs.length; i++) {\n-                        Security.removeProvider(\"name\" + i);\n-                    }\n+                    Thread.yield();\n@@ -88,1 +86,7 @@\n-                    throw new RuntimeException(\"Expected algorithm sigalg not found\", nsae);\n+                    \/\/ All providers may have been deregistered.  Ok.\n+                }\n+\n+                for (int i = 0; i < provs.length; i++) {\n+                    \/\/ Might or might not remove (silent return)\n+                    Security.removeProvider(\"name\" + i);\n+                    Thread.yield();\n","filename":"test\/jdk\/java\/security\/Security\/SynchronizedAccess.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"}]}