{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @library ..\/testlibrary\n+ * @library \/test\/lib ..\/testlibrary\n@@ -29,0 +29,1 @@\n+ * @run main\/othervm SynchronizedAccess\n@@ -33,0 +34,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -45,0 +48,1 @@\n+        var providersCountBefore = Security.getProviders().length;\n@@ -46,3 +50,4 @@\n-        for (int i=0; i < acc.length; i++)\n-            acc[i] = new AccessorThread(\"thread\"+i);\n-        for (int i=0; i < acc.length; i++)\n+        for (int i = 0; i < acc.length; i++) {\n+            acc[i] = new AccessorThread(\"thread\" + i);\n+        }\n+        for (int i = 0; i < acc.length; i++) {\n@@ -50,1 +55,2 @@\n-        for (int i=0; i < acc.length; i++)\n+        }\n+        for (int i = 0; i < acc.length; i++) {\n@@ -52,0 +58,3 @@\n+        }\n+        var providersCountAfter = Security.getProviders().length;\n+        Asserts.assertEquals(providersCountBefore + 1, providersCountAfter);\n@@ -53,1 +62,0 @@\n-}\n@@ -55,1 +63,1 @@\n-class AccessorThread extends Thread {\n+    public static class AccessorThread extends Thread {\n@@ -57,3 +65,3 @@\n-    public AccessorThread(String str) {\n-        super(str);\n-    }\n+        public AccessorThread(String str) {\n+            super(str);\n+        }\n@@ -61,4 +69,5 @@\n-    public void run() {\n-        Provider[] provs = new Provider[10];\n-        for (int i=0; i < provs.length; i++)\n-            provs[i] = new MyProvider(\"name\"+i, \"1\", \"test\");\n+        public void run() {\n+            Provider[] provs = new Provider[10];\n+            for (int i = 0; i < provs.length; i++) {\n+                provs[i] = new MyProvider(\"name\" + i, \"1\", \"test\");\n+            }\n@@ -66,9 +75,14 @@\n-        int rounds = 20;\n-        while (rounds-- > 0) {\n-            try {\n-                for (int i=0; i<provs.length; i++) {\n-                    Security.addProvider(provs[i]);\n-                }\n-                Signature sig = Signature.getInstance(\"sigalg\");\n-                for (int i=0; i<provs.length; i++) {\n-                    Security.removeProvider(\"name\"+i);\n+            int rounds = 20;\n+            while (rounds-- > 0) {\n+                try {\n+                    for (int i = 0; i < provs.length; i++) {\n+                        Security.addProvider(provs[i]);\n+                    }\n+                    Signature.getInstance(\"sigalg\");\n+                    \/\/ Skip the first provider to ensure one is always available for getInstance.\n+                    \/\/ This prevents issues if other threads remove providers in parallel.\n+                    for (int i = 1; i < provs.length; i++) {\n+                        Security.removeProvider(\"name\" + i);\n+                    }\n+                } catch (NoSuchAlgorithmException nsae) {\n+                    throw new RuntimeException(\"Expected algorithm sigalg not found\", nsae);\n@@ -76,2 +90,7 @@\n-                provs = Security.getProviders();\n-            } catch (NoSuchAlgorithmException nsae) {\n+            } \/\/ while\n+        }\n+\n+        public static final class MyProvider extends Provider {\n+            public MyProvider(String name, String version, String info) {\n+                super(name, version, info);\n+                put(\"Signature.sigalg\", SigImpl.class.getName());\n@@ -79,0 +98,3 @@\n+        }\n+\n+        public static final class SigImpl extends Signature {\n@@ -80,3 +102,6 @@\n-            try {\n-                Thread.sleep(5);\n-            } catch (InterruptedException ie) {\n+            public SigImpl() {\n+                super(null);\n+            }\n+\n+            @Override\n+            protected void engineInitVerify(PublicKey publicKey) {\n@@ -84,3 +109,0 @@\n-        } \/\/ while\n-    }\n-}\n@@ -88,4 +110,33 @@\n-class MyProvider extends Provider {\n-    public MyProvider(String name, String version, String info) {\n-        super(name, version, info);\n-        put(\"Signature.sigalg\", \"sigimpl\");\n+            @Override\n+            protected void engineInitSign(PrivateKey privateKey) {\n+            }\n+\n+            @Override\n+            protected void engineUpdate(byte b) {\n+            }\n+\n+            @Override\n+            protected void engineUpdate(byte[] b, int off, int len) {\n+            }\n+\n+            @Override\n+            protected byte[] engineSign() {\n+                return new byte[0];\n+            }\n+\n+            @Override\n+            protected boolean engineVerify(byte[] sigBytes) {\n+                return false;\n+            }\n+\n+            @Override\n+            protected void engineSetParameter(String param, Object value)\n+                    throws InvalidParameterException {\n+            }\n+\n+            @Override\n+            protected Object engineGetParameter(String param)\n+                    throws InvalidParameterException {\n+                return null;\n+            }\n+        }\n@@ -93,1 +144,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/Security\/SynchronizedAccess.java","additions":88,"deletions":37,"binary":false,"changes":125,"status":"modified"}]}