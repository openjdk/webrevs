{"files":[{"patch":"@@ -2770,3 +2770,5 @@\n-     * Rearranges the lane elements of two vectors, selecting lanes\n-     * under the control of a specific index vector (the current vector)\n-     * holding indexes in valid index range of two vectors i.e. {@code [0, VLENGTH*2)}.\n+     * Using values stored in the lanes of this vector,\n+     * assemble values stored in the second vector {@code v1}\n+     * and third vector {@code v2}. The second and third vectors thus\n+     * serve as a table, whose elements are selected by indexes\n+     * in this vector.\n@@ -2775,1 +2777,16 @@\n-     * elements of the two input vectors {@code v1} and a second vector {@code v2}).\n+     * elements of the argument vectors, under the control of\n+     * this vector.\n+     *\n+     * For each lane {@code N} of this vector, and for each lane\n+     * value {@code I=wrapIndex(this.lane(N)} in this vector,\n+     * the output lane {@code N} obtains the value from\n+     * the second vector at lane {@code I} if {@code I < VLENGTH}.\n+     * Otherwise, the output lane {@code N} obtains the value from\n+     * the third vector at lane {@code I - VLENGTH}.\n+     *\n+     * Here, {@code VLENGTH} is the result of {@code this.length()},\n+     * and {@code wrapIndex} computes the result of\n+     * {@code Math.floorMod(E, 2 * VLENGTH)},\n+     * where {@code E} is the index to be wrapped.\n+     * As long as {@code VLENGTH} is a power of two, then the result\n+     * is also equal to {@code E & (2 * VLENGTH - 1)}.\n@@ -2777,5 +2794,11 @@\n-     * For each lane {@code N} of the index vector (the current vector), and\n-     * for each lane source index {@code I=this.laneSource(N)} in the index vector,\n-     * the output lane {@code N} obtains the value from the first vector at lane {@code I}\n-     * if {@code I>=0 && I < VLENGTH}. Otherwise, index vector lane is used to index\n-     * the <em>second<\/em> vector, at index {@code I-VLENGTH}.\n+     * In this way, the result contains only values stored in the\n+     * argument vectors {@code v1} and {@code v2}, but presented in\n+     * an order which depends on the index values in {@code this}.\n+     *\n+     * The result is the same as the expression\n+     * {@snippet lang=java :\n+     * v1.rearrange(\n+     * this.lanewise(VectorOperators.AND, 2 * VLENGTH - 1).toShuffle(),\n+     * v2)\n+     * }\n+     * when {@code VLENGTH} is a power of two.\n@@ -2785,4 +2808,2 @@\n-     * @return the rearrangement of lane elements of first and\n-     *         the second input vector\n-     * @throws IndexOutOfBoundsException if any invalid\n-     *         source indexes are found in {@code this}\n+     * @return the rearrangement of lane elements of {@code v1} and {@code v2}\n+     * @see #rearrange(VectorShuffle, Vector)\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":34,"deletions":13,"binary":false,"changes":47,"status":"modified"}]}