{"files":[{"patch":"@@ -4467,16 +4467,0 @@\n-void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x76, (0xC0 | encode));\n-}\n-\n-void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_avx512_vbmi(), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x7D, (0xC0 | encode));\n-}\n-\n@@ -14737,0 +14721,56 @@\n+\n+void Assembler::evpermi2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x75, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x75, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2d(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x76, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x76, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x77, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x77, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x7D, (0xC0 | encode));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":56,"deletions":16,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1874,0 +1874,4 @@\n+  void evpmultishiftqb(XMMRegister dst, XMMRegister ctl, XMMRegister src, int vector_len);\n+  void evpermi2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpermi2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpermi2d(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1875,0 +1879,2 @@\n+  void evpermi2ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpermi2pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1876,1 +1882,0 @@\n-  void evpmultishiftqb(XMMRegister dst, XMMRegister ctl, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6445,0 +6445,27 @@\n+\n+void C2_MacroAssembler::select_from_two_vectors_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                     XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      evpermi2b(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_SHORT:\n+      evpermi2w(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_INT:\n+      evpermi2d(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_LONG:\n+      evpermi2q(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_FLOAT:\n+      evpermi2ps(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_DOUBLE:\n+      evpermi2pd(dst, src1, src2, vlen_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -508,0 +508,2 @@\n+  void select_from_two_vectors_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1938,0 +1938,14 @@\n+    case Op_SelectFromTwoVector:\n+       if (size_in_bits < 128 || (size_in_bits < 512 && !VM_Version::supports_avx512vl())) {\n+         return false;\n+       }\n+       if (bt == T_SHORT && !VM_Version::supports_avx512bw()) {\n+         return false;\n+       }\n+       if (bt == T_BYTE && !VM_Version::supports_avx512_vbmi()) {\n+         return false;\n+       }\n+       if ((bt == T_INT || bt == T_FLOAT || bt == T_DOUBLE) && !VM_Version::supports_evex()) {\n+         return false;\n+       }\n+       break;\n@@ -10471,0 +10485,14 @@\n+\n+\n+instruct vector_selectfrom_twovectors_reg_evex(vec index, vec src1, vec src2)\n+%{\n+  match(Set index (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP index);\n+  format %{ \"select_from_two_vector $index, $src1, $src2 \\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ select_from_two_vectors_evex(bt, $index$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -4355,1 +4355,1 @@\n-    \"VectorTest\", \"VectorLoadMask\", \"VectorStoreMask\", \"VectorBlend\", \"VectorInsert\",\n+    \"SelectFromTwoVector\", \"VectorTest\", \"VectorLoadMask\", \"VectorStoreMask\", \"VectorBlend\", \"VectorInsert\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -979,0 +979,11 @@\n+  do_intrinsic(_VectorSelectFromTwoVectorOp, jdk_internal_vm_vector_VectorSupport, vector_select_from_op_name, vector_select_from_op_sig, F_S) \\\n+   do_signature(vector_select_from_op_sig, \"(Ljava\/lang\/Class;\"                                                                                \\\n+                                            \"Ljava\/lang\/Class;\"                                                                                \\\n+                                            \"I\"                                                                                                \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$SelectFromTwoVector;)\"                                      \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                   \\\n+   do_name(vector_select_from_op_name,     \"selectFromTwoVectorOp\")                                                                            \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -815,0 +815,1 @@\n+  case vmIntrinsics::_VectorSelectFromTwoVectorOp:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -485,0 +485,1 @@\n+macro(SelectFromTwoVector)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -748,0 +748,2 @@\n+  case vmIntrinsics::_VectorSelectFromTwoVectorOp:\n+    return inline_vector_select_from_two_vectors();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+  bool inline_vector_select_from_two_vectors();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2403,0 +2403,1 @@\n+    case Op_SelectFromTwoVector:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2148,0 +2148,2 @@\n+  const TypeInt* cnt_type = cnt->bottom_type()->isa_int();\n+\n@@ -2150,1 +2152,0 @@\n-  const TypeInt* cnt_type = cnt->bottom_type()->isa_int();\n@@ -2634,0 +2635,114 @@\n+\n+\/\/  public static\n+\/\/  <V extends Vector<E>,\n+\/\/   E>\n+\/\/  V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,\n+\/\/                          V v1, V v2, V v3,\n+\/\/                          SelectFromTwoVector<V> defaultImpl)\n+bool LibraryCallKit::inline_vector_select_from_two_vectors() {\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt* vlen = gvn().type(argument(2))->isa_int();\n+\n+  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass->const_oop() == nullptr ||!vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()]);\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(vector_klass)) {\n+    log_if_needed(\"  ** klass argument not initialized\");\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  if (!is_power_of_2(num_elem)) {\n+    log_if_needed(\"  ** vlen is not power of two=%d\", num_elem);\n+    return false;\n+  }\n+\n+  BasicType elem_bt = elem_type->basic_type();\n+  BasicType index_elem_bt = elem_bt;\n+  if (elem_bt == T_FLOAT) {\n+    index_elem_bt = T_INT;\n+  } else if (elem_bt == T_DOUBLE) {\n+    index_elem_bt = T_LONG;\n+  }\n+\n+  if (!arch_supports_vector(Op_SelectFromTwoVector, num_elem, elem_bt, VecMaskNotUsed)) {\n+    int cast_vopc = VectorCastNode::opcode(-1, elem_bt, true);\n+    if (!arch_supports_vector(Op_VectorMaskCmp, num_elem, T_BYTE, VecMaskNotUsed)            ||\n+        !arch_supports_vector(Op_AndV, num_elem, T_BYTE, VecMaskNotUsed)                     ||\n+        !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)             ||\n+        !arch_supports_vector(Op_VectorRearrange, num_elem, elem_bt, VecMaskNotUsed)         ||\n+        !arch_supports_vector(cast_vopc, num_elem, T_BYTE, VecMaskNotUsed)                   ||\n+        !arch_supports_vector(Op_VectorLoadShuffle, num_elem, index_elem_bt, VecMaskNotUsed) ||\n+        !arch_supports_vector(Op_Replicate, num_elem, T_BYTE, VecMaskNotUsed)) {\n+      log_if_needed(\"  ** not supported: opc=%d vlen=%d etype=%s ismask=useload\",\n+                    Op_SelectFromTwoVector, num_elem, type2name(elem_bt));\n+      return false; \/\/ not supported\n+    }\n+  }\n+\n+  int cast_vopc = VectorCastNode::opcode(-1, elem_bt, true);\n+  if (is_floating_point_type(elem_bt)) {\n+    index_elem_bt = elem_bt == T_FLOAT ? T_INT : T_LONG;\n+    if (!arch_supports_vector(Op_AndV, num_elem, index_elem_bt, VecMaskNotUsed)              ||\n+        !arch_supports_vector(cast_vopc, num_elem, index_elem_bt, VecMaskNotUsed)            ||\n+        !arch_supports_vector(Op_Replicate, num_elem, index_elem_bt, VecMaskNotUsed)) {\n+      log_if_needed(\"  ** index wrapping not supported: vlen=%d etype=%s\" ,\n+                     num_elem, type2name(elem_bt));\n+      return false; \/\/ not supported\n+    }\n+  }\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  Node* opd1 = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  if (opd1 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v1=%s\",\n+                  NodeClassNames[argument(3)->Opcode()]);\n+    return false;\n+  }\n+  Node* opd2 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  if (opd2 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v2=%s\",\n+                  NodeClassNames[argument(4)->Opcode()]);\n+    return false;\n+  }\n+  Node* opd3 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  if (opd3 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v3=%s\",\n+                  NodeClassNames[argument(5)->Opcode()]);\n+    return false;\n+  }\n+\n+  if (index_elem_bt != elem_bt) {\n+    opd1 = gvn().transform(VectorCastNode::make(cast_vopc, opd1, index_elem_bt, num_elem));\n+  }\n+\n+  int indexRangeMask = 2 * num_elem - 1;\n+  Node* wrap_mask = gvn().makecon(TypeInteger::make(indexRangeMask, indexRangeMask, Type::WidenMin, index_elem_bt != T_LONG ? T_INT : index_elem_bt));\n+  Node* wrap_mask_vec = gvn().transform(VectorNode::scalar2vector(wrap_mask, num_elem, Type::get_const_basic_type(index_elem_bt), false));\n+  opd1 = gvn().transform(VectorNode::make(Op_AndV, opd1, wrap_mask_vec, opd1->bottom_type()->is_vect()));\n+\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  Node* operation = gvn().transform(VectorNode::make(Op_SelectFromTwoVector, opd1, opd2, opd3, vt));\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  Node* vbox = box_vector(operation, vbox_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":116,"deletions":1,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -784,0 +784,1 @@\n+  case Op_SelectFromTwoVector: return new SelectFromTwoVectorNode(n1, n2, n3, vt);\n@@ -2086,0 +2087,63 @@\n+Node* SelectFromTwoVectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  int num_elem = vect_type()->length();\n+  BasicType elem_bt = vect_type()->element_basic_type();\n+\n+  \/\/ Keep the node if it is supported, else lower it to other nodes.\n+  if (Matcher::match_rule_supported_vector(Op_SelectFromTwoVector, num_elem, elem_bt)) {\n+    return nullptr;\n+  }\n+\n+  Node* index_vec = in(1);\n+  Node* src1 = in(2);\n+  Node* src2 = in(3);\n+\n+  \/\/ Lower the IR to constituents operations.\n+  \/\/   SelectFromTwoVectorNode =\n+  \/\/     (VectorBlend\n+  \/\/         (VectorRearrange SRC1 (WRAPED_INDEX AND (VLEN-1))\n+  \/\/         (VectorRearrange SRC2 (WRAPED_INDEX AND (VLEN-1))\n+  \/\/         MASK)\n+  \/\/ Where\n+  \/\/   incoming WRAPED_INDEX is within two vector index range [0, VLEN*2) and\n+  \/\/   MASK = WRAPED_INDEX < VLEN\n+  \/\/\n+  \/\/ IR lowering prevents intrinsification failure and associated argument\n+  \/\/ boxing penalties.\n+  \/\/\n+\n+  const TypeVect* index_vect_type = index_vec->bottom_type()->is_vect();\n+  BasicType index_elem_bt = index_vect_type->element_basic_type();\n+\n+  \/\/ Downcast index vector to a type agnostic shuffle representation, shuffle indices\n+  \/\/ are held in a byte vector which are later transformed to target specific permutation\n+  \/\/ index format by subsequent VectorLoadShuffle.\n+  int cast_vopc = VectorCastNode::opcode(0, index_elem_bt, true);\n+  Node* index_byte_vec = phase->transform(VectorCastNode::make(cast_vopc, index_vec, T_BYTE, num_elem));\n+\n+  Node* lane_cnt_m1 = phase->makecon(TypeInt::make(num_elem - 1));\n+  Node* bcast_lane_cnt_m1_vec = phase->transform(VectorNode::scalar2vector(lane_cnt_m1, num_elem, Type::get_const_basic_type(T_BYTE), false));\n+\n+  \/\/ Compute the blend mask for merging two indipendently permututed vectors\n+  \/\/ using shuff index in two vector index range [0, VLEN * 2).\n+  BoolTest::mask pred = BoolTest::le;\n+  ConINode* pred_node = phase->makecon(TypeInt::make(pred))->as_ConI();\n+  const TypeVect* vmask_type = TypeVect::makemask(T_BYTE, num_elem);\n+  Node* mask = phase->transform(new VectorMaskCmpNode(pred, index_byte_vec, bcast_lane_cnt_m1_vec, pred_node, vmask_type));\n+\n+  \/\/ Rearrange expects the indexes to lie within single vector index range [0, VLEN).\n+  index_byte_vec = phase->transform(VectorNode::make(Op_AndV, index_byte_vec, bcast_lane_cnt_m1_vec, index_byte_vec->bottom_type()->is_vect()));\n+\n+  \/\/ Load indexes from byte vector and appropriatly transform them to target specific\n+  \/\/ permutation index format.\n+  index_vec = phase->transform(new VectorLoadShuffleNode(index_byte_vec, index_vect_type));\n+\n+  vmask_type = TypeVect::makemask(elem_bt, num_elem);\n+  mask = phase->transform(new VectorMaskCastNode(mask, vmask_type));\n+\n+  Node* p1 = phase->transform(new VectorRearrangeNode(src1, index_vec));\n+  Node* p2 = phase->transform(new VectorRearrangeNode(src2, index_vec));\n+\n+  return new VectorBlendNode(p2, p1, mask);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1615,0 +1615,16 @@\n+\n+\/\/ Select elements from two source vectors based on the wrapped indexes held in\n+\/\/ the first vector.\n+class SelectFromTwoVectorNode : public VectorNode {\n+public:\n+  SelectFromTwoVectorNode(Node* indexes, Node* src1, Node* src2, const TypeVect* vt)\n+  : VectorNode(indexes, src1, src2, vt) {\n+      assert(is_integral_type(indexes->bottom_type()->is_vect()->element_basic_type()),\n+             \"indexes must be an integral vector\");\n+  }\n+\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual int Opcode() const;\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -384,0 +384,18 @@\n+    \/* ============================================================================ *\/\n+\n+    public interface SelectFromTwoVector<V extends Vector<?>> {\n+        V apply(V v1, V v2, V v3);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     E>\n+    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,\n+                            V v1, V v2, V v3,\n+                            SelectFromTwoVector<V> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v1, v2, v3);\n+    }\n+\n+    \/* ============================================================================ *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte128Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte128Vector)\n+            super.selectFromTemplate((Byte128Vector) v1, (Byte128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte256Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte256Vector)\n+            super.selectFromTemplate((Byte256Vector) v1, (Byte256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte512Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte512Vector)\n+            super.selectFromTemplate((Byte512Vector) v1, (Byte512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte64Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte64Vector)\n+            super.selectFromTemplate((Byte64Vector) v1, (Byte64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (ByteMaxVector)\n+            super.selectFromTemplate((ByteMaxVector) v1, (ByteMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static ByteVector selectFromTwoVectorHelper(Vector<Byte> indexes, Vector<Byte> src1, Vector<Byte> src2) {\n+        int vlen = indexes.length();\n+        byte[] res = new byte[vlen];\n+        byte[] vecPayload1 = ((ByteVector)indexes).vec();\n+        byte[] vecPayload2 = ((ByteVector)src1).vec();\n+        byte[] vecPayload3 = ((ByteVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((ByteVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2571,0 +2584,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector selectFrom(Vector<Byte> v1, Vector<Byte> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final ByteVector selectFromTemplate(ByteVector v1, ByteVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double128Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double128Vector)\n+            super.selectFromTemplate((Double128Vector) v1, (Double128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double256Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double256Vector)\n+            super.selectFromTemplate((Double256Vector) v1, (Double256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double512Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double512Vector)\n+            super.selectFromTemplate((Double512Vector) v1, (Double512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double64Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double64Vector)\n+            super.selectFromTemplate((Double64Vector) v1, (Double64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (DoubleMaxVector)\n+            super.selectFromTemplate((DoubleMaxVector) v1, (DoubleMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -528,0 +528,13 @@\n+    static DoubleVector selectFromTwoVectorHelper(Vector<Double> indexes, Vector<Double> src1, Vector<Double> src2) {\n+        int vlen = indexes.length();\n+        double[] res = new double[vlen];\n+        double[] vecPayload1 = ((DoubleVector)indexes).vec();\n+        double[] vecPayload2 = ((DoubleVector)src1).vec();\n+        double[] vecPayload3 = ((DoubleVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((DoubleVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2413,0 +2426,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector selectFrom(Vector<Double> v1, Vector<Double> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final DoubleVector selectFromTemplate(DoubleVector v1, DoubleVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), double.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float128Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float128Vector)\n+            super.selectFromTemplate((Float128Vector) v1, (Float128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float256Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float256Vector)\n+            super.selectFromTemplate((Float256Vector) v1, (Float256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float512Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float512Vector)\n+            super.selectFromTemplate((Float512Vector) v1, (Float512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float64Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float64Vector)\n+            super.selectFromTemplate((Float64Vector) v1, (Float64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (FloatMaxVector)\n+            super.selectFromTemplate((FloatMaxVector) v1, (FloatMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -528,0 +528,13 @@\n+    static FloatVector selectFromTwoVectorHelper(Vector<Float> indexes, Vector<Float> src1, Vector<Float> src2) {\n+        int vlen = indexes.length();\n+        float[] res = new float[vlen];\n+        float[] vecPayload1 = ((FloatVector)indexes).vec();\n+        float[] vecPayload2 = ((FloatVector)src1).vec();\n+        float[] vecPayload3 = ((FloatVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((FloatVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2425,0 +2438,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector selectFrom(Vector<Float> v1, Vector<Float> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final FloatVector selectFromTemplate(FloatVector v1, FloatVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), float.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int128Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int128Vector)\n+            super.selectFromTemplate((Int128Vector) v1, (Int128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int256Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int256Vector)\n+            super.selectFromTemplate((Int256Vector) v1, (Int256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int512Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int512Vector)\n+            super.selectFromTemplate((Int512Vector) v1, (Int512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int64Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int64Vector)\n+            super.selectFromTemplate((Int64Vector) v1, (Int64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public IntMaxVector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (IntMaxVector)\n+            super.selectFromTemplate((IntMaxVector) v1, (IntMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static IntVector selectFromTwoVectorHelper(Vector<Integer> indexes, Vector<Integer> src1, Vector<Integer> src2) {\n+        int vlen = indexes.length();\n+        int[] res = new int[vlen];\n+        int[] vecPayload1 = ((IntVector)indexes).vec();\n+        int[] vecPayload2 = ((IntVector)src1).vec();\n+        int[] vecPayload3 = ((IntVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((IntVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2556,0 +2569,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector selectFrom(Vector<Integer> v1, Vector<Integer> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final IntVector selectFromTemplate(IntVector v1, IntVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), int.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long128Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long128Vector)\n+            super.selectFromTemplate((Long128Vector) v1, (Long128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long256Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long256Vector)\n+            super.selectFromTemplate((Long256Vector) v1, (Long256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long512Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long512Vector)\n+            super.selectFromTemplate((Long512Vector) v1, (Long512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long64Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long64Vector)\n+            super.selectFromTemplate((Long64Vector) v1, (Long64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public LongMaxVector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (LongMaxVector)\n+            super.selectFromTemplate((LongMaxVector) v1, (LongMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static LongVector selectFromTwoVectorHelper(Vector<Long> indexes, Vector<Long> src1, Vector<Long> src2) {\n+        int vlen = indexes.length();\n+        long[] res = new long[vlen];\n+        long[] vecPayload1 = ((LongVector)indexes).vec();\n+        long[] vecPayload2 = ((LongVector)src1).vec();\n+        long[] vecPayload3 = ((LongVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((LongVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2422,0 +2435,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector selectFrom(Vector<Long> v1, Vector<Long> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final LongVector selectFromTemplate(LongVector v1, LongVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), long.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short128Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short128Vector)\n+            super.selectFromTemplate((Short128Vector) v1, (Short128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short256Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short256Vector)\n+            super.selectFromTemplate((Short256Vector) v1, (Short256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short512Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short512Vector)\n+            super.selectFromTemplate((Short512Vector) v1, (Short512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short64Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short64Vector)\n+            super.selectFromTemplate((Short64Vector) v1, (Short64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (ShortMaxVector)\n+            super.selectFromTemplate((ShortMaxVector) v1, (ShortMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static ShortVector selectFromTwoVectorHelper(Vector<Short> indexes, Vector<Short> src1, Vector<Short> src2) {\n+        int vlen = indexes.length();\n+        short[] res = new short[vlen];\n+        short[] vecPayload1 = ((ShortVector)indexes).vec();\n+        short[] vecPayload2 = ((ShortVector)src1).vec();\n+        short[] vecPayload3 = ((ShortVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((ShortVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2572,0 +2585,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector selectFrom(Vector<Short> v1, Vector<Short> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final ShortVector selectFromTemplate(ShortVector v1, ShortVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2769,0 +2769,55 @@\n+    \/**\n+     * Using values stored in the lanes of this vector,\n+     * assemble values stored in the second vector {@code v1}\n+     * and third vector {@code v2}. The second and third vectors thus\n+     * serve as a table, whose elements are selected by indexes\n+     * in this vector.\n+     *\n+     * This is a cross-lane operation that rearranges the lane\n+     * elements of the argument vectors, under the control of\n+     * this vector.\n+     *\n+     * For each lane {@code N} of this vector, and for each lane\n+     * value {@code I=wrapIndex(this.lane(N)} in this vector,\n+     * the output lane {@code N} obtains the value from\n+     * the second vector at lane {@code I} if {@code I < VLENGTH}.\n+     * Otherwise, the output lane {@code N} obtains the value from\n+     * the third vector at lane {@code I - VLENGTH}.\n+     *\n+     * Here, {@code VLENGTH} is the result of {@code this.length()},\n+     * and for integral values {@code wrapIndex} computes the result of\n+     * {@code Math.floorMod(E, 2 * VLENGTH)}, where {@code E} is the index\n+     * to be wrapped. As long as {@code VLENGTH} is a power of two, then the\n+     * result is also equal to {@code E & (2 * VLENGTH - 1)}.\n+     *\n+     * For floating point values {@code wrapIndex} computes\n+     * {@code Math.floorMod(convert(E), 2 * VLENGTH)}, where {@code convert}\n+     * converts the floating point value to an integral value with the same\n+     * number of representational bits - as in converting a double value to\n+     * a long value ({@code (long)doubleVal}), or a float value to an int value\n+     * ({@code (int)floatVal}).\n+     *\n+     * In this way, the result contains only values stored in the\n+     * argument vectors {@code v1} and {@code v2}, but presented in\n+     * an order which depends on the index values in {@code this}.\n+     *\n+     * The result for integral values is the same as the expression\n+     * {@snippet lang=java :\n+     * v1.rearrange(\n+     * this.lanewise(VectorOperators.AND, 2 * VLENGTH - 1).toShuffle(),\n+     * v2)\n+     * }\n+     * when {@code VLENGTH} is a power of two.\n+     * The lane-wise {@code AND} operation results in a vector whose\n+     * elements are in the range {@code [0, 2 * VLENGTH - 1])}. The shuffle\n+     * conversion results in a partially wrapped shuffle whose indexes are\n+     * in the range {@code [-VLENGTH, VLENGTH - 1])}, where exceptional\n+     * indexes are used to select elements in the third vector.\n+     *\n+     * @param v1 the first input vector\n+     * @param v2 the second input vector\n+     * @return the rearrangement of lane elements of {@code v1} and {@code v2}\n+     * @see #rearrange(VectorShuffle,Vector)\n+     *\/\n+    public abstract Vector<E> selectFrom(Vector<E> v1, Vector<E> v2);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -566,0 +566,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -553,0 +553,13 @@\n+    static $abstractvectortype$ selectFromTwoVectorHelper(Vector<$Boxtype$> indexes, Vector<$Boxtype$> src1, Vector<$Boxtype$> src2) {\n+        int vlen = indexes.length();\n+        $type$[] res = new $type$[vlen];\n+        $type$[] vecPayload1 = (($abstractvectortype$)indexes).vec();\n+        $type$[] vecPayload2 = (($abstractvectortype$)src1).vec();\n+        $type$[] vecPayload3 = (($abstractvectortype$)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return (($abstractvectortype$)src1).vectorFactory(res);\n+    }\n+\n@@ -2948,0 +2961,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    $abstractvectortype$ selectFrom(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final $abstractvectortype$ selectFromTemplate($abstractvectortype$ v1, $abstractvectortype$ v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), $type$.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -515,0 +515,7 @@\n+    @Override\n+    @ForceInline\n+    public $vectortype$ selectFrom(Vector<$Boxtype$> v1,\n+                                   Vector<$Boxtype$> v2) {\n+        return ($vectortype$)\n+            super.selectFromTemplate(($vectortype$) v1, ($vectortype$) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -991,0 +1010,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1018,0 +1049,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5778,0 +5815,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -991,0 +1010,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1018,0 +1049,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5778,0 +5815,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -991,0 +1010,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1018,0 +1049,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5778,0 +5815,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -991,0 +1010,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1018,0 +1049,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5778,0 +5815,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -321,0 +321,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -996,0 +1015,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1023,0 +1054,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5783,0 +5820,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1135,0 +1154,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1162,0 +1193,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4835,0 +4872,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble128VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1135,0 +1154,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1162,0 +1193,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4835,0 +4872,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble256VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1135,0 +1154,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1162,0 +1193,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4835,0 +4872,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble512VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1135,0 +1154,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1162,0 +1193,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4835,0 +4872,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble64VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -338,0 +338,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1140,0 +1159,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1167,0 +1198,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4840,0 +4877,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDoubleMaxVectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1146,0 +1165,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1173,0 +1204,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4814,0 +4851,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat128VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1146,0 +1165,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1173,0 +1204,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4814,0 +4851,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat256VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1146,0 +1165,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1173,0 +1204,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4814,0 +4851,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat512VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1146,0 +1165,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1173,0 +1204,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4814,0 +4851,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat64VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -338,0 +338,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1151,0 +1170,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1178,0 +1209,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4817,0 +4854,18 @@\n+    }\n+\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloatMaxVectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5811,0 +5848,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5811,0 +5848,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5811,0 +5848,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5811,0 +5848,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -321,0 +321,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -986,0 +1005,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1013,0 +1044,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5816,0 +5853,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -273,0 +273,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -971,0 +990,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -998,0 +1029,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5697,0 +5734,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -273,0 +273,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -971,0 +990,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -998,0 +1029,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5697,0 +5734,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -273,0 +273,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -971,0 +990,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -998,0 +1029,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5697,0 +5734,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -273,0 +273,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -971,0 +990,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -998,0 +1029,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5697,0 +5734,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -278,0 +278,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -976,0 +995,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1003,0 +1034,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5702,0 +5739,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5758,0 +5795,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5758,0 +5795,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5758,0 +5795,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5758,0 +5795,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -321,0 +321,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -986,0 +1005,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1013,0 +1044,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5761,0 +5798,18 @@\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -300,0 +300,18 @@\n+    @Test(dataProvider = \"$type$SelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVector$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] idx = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ idxv = $abstractvectortype$.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -399,0 +399,19 @@\n+    static void assertSelectFromTwoVectorEquals($type$[] r, $type$[] order, $type$[] a, $type$[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index =(((int)order[idx]) & (2 * vector_len -1));\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1238,0 +1257,12 @@\n+    static final List<IntFunction<$type$[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"$type$[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_GENERATOR_SELECT_FROM_TRIPLES =\n+        $TYPE$_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1265,0 +1296,6 @@\n+    @DataProvider\n+    public Object[][] $type$SelectFromTwoVectorOpProvider() {\n+        return $TYPE$_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SelectFromBenchmark {\n+    @Param({\"1024\",\"2048\"})\n+    int size;\n+\n+    byte[] byteindex;\n+    byte[] bytesrc1;\n+    byte[] bytesrc2;\n+    byte[] byteres;\n+\n+    short[] shortindex;\n+    short[] shortsrc1;\n+    short[] shortsrc2;\n+    short[] shortres;\n+\n+    int[] intindex;\n+    int[] intsrc1;\n+    int[] intsrc2;\n+    int[] intres;\n+\n+    long[] longindex;\n+    long[] longsrc1;\n+    long[] longsrc2;\n+    long[] longres;\n+\n+    float[] floatindex;\n+    float[] floatsrc1;\n+    float[] floatsrc2;\n+    float[] floatres;\n+\n+    double[] doubleindex;\n+    double[] doublesrc1;\n+    double[] doublesrc2;\n+    double[] doubleres;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        byteindex = new byte[size];\n+        bytesrc1 = new byte[size];\n+        bytesrc2 = new byte[size];\n+        byteres = new byte[size];\n+\n+        shortindex = new short[size];\n+        shortsrc1 = new short[size];\n+        shortsrc2 = new short[size];\n+        shortres = new short[size];\n+\n+        intindex = new int[size];\n+        intsrc1 = new int[size];\n+        intsrc2 = new int[size];\n+        intres = new int[size];\n+\n+        longindex = new long[size];\n+        longsrc1 = new long[size];\n+        longsrc2 = new long[size];\n+        longres = new long[size];\n+\n+        floatindex = new float[size];\n+        floatsrc1 = new float[size];\n+        floatsrc2 = new float[size];\n+        floatres = new float[size];\n+\n+        doubleindex = new double[size];\n+        doublesrc1 = new double[size];\n+        doublesrc2 = new double[size];\n+        doubleres = new double[size];\n+\n+        Arrays.fill(bytesrc1, (byte)1);\n+        Arrays.fill(bytesrc2, (byte)2);\n+\n+        Arrays.fill(shortsrc1, (short)1);\n+        Arrays.fill(shortsrc2, (short)2);\n+\n+        Arrays.fill(intsrc1, 1);\n+        Arrays.fill(intsrc2, 2);\n+\n+        Arrays.fill(longsrc1, 1);\n+        Arrays.fill(longsrc2, 2);\n+\n+        Arrays.fill(floatsrc1, 1.0f);\n+        Arrays.fill(floatsrc2, 2.0f);\n+\n+        Arrays.fill(doublesrc1, 1.0);\n+        Arrays.fill(doublesrc2, 2.0);\n+\n+        for (int i = 0; i < size; i++) {\n+            byteindex[i] = (byte)((ByteVector.SPECIES_PREFERRED.length() - 1) & i);\n+            shortindex[i] = (short)((ShortVector.SPECIES_PREFERRED.length() - 1) & i);\n+            intindex[i] = (int)((IntVector.SPECIES_PREFERRED.length() - 1) & i);\n+            longindex[i] = (long)((LongVector.SPECIES_PREFERRED.length() - 1) & i);\n+            floatindex[i] = (float)((FloatVector.SPECIES_PREFERRED.length() - 1) & i);\n+            doubleindex[i] = (double)((DoubleVector.SPECIES_PREFERRED.length() - 1) & i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromByteVector() {\n+        for (int j = 0; j < size; j += ByteVector.SPECIES_PREFERRED.length()) {\n+            ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, byteindex, j)\n+                .selectFrom(ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc1, j),\n+                            ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc2, j))\n+                .intoArray(byteres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromByteVector() {\n+        for (int j = 0; j < size; j += ByteVector.SPECIES_PREFERRED.length()) {\n+            ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc1, j)\n+                .rearrange(ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, byteindex, j).toShuffle(),\n+                           ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc2, j))\n+                .intoArray(byteres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromShortVector() {\n+        for (int j = 0; j < size; j += ShortVector.SPECIES_PREFERRED.length()) {\n+            ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortindex, j)\n+                .selectFrom(ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc1, j),\n+                            ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc2, j))\n+                .intoArray(shortres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromShortVector() {\n+        for (int j = 0; j < size; j += ShortVector.SPECIES_PREFERRED.length()) {\n+            ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc1, j)\n+                .rearrange(ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortindex, j).toShuffle(),\n+                           ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc2, j))\n+                .intoArray(shortres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromIntVector() {\n+        for (int j = 0; j < size; j += IntVector.SPECIES_PREFERRED.length()) {\n+            IntVector.fromArray(IntVector.SPECIES_PREFERRED, intindex, j)\n+                .selectFrom(IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc1, j),\n+                            IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc2, j))\n+                .intoArray(intres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromIntVector() {\n+        for (int j = 0; j < size; j += IntVector.SPECIES_PREFERRED.length()) {\n+            IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc1, j)\n+                .rearrange(IntVector.fromArray(IntVector.SPECIES_PREFERRED, intindex, j).toShuffle(),\n+                           IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc2, j))\n+                .intoArray(intres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromLongVector() {\n+        for (int j = 0; j < size; j += LongVector.SPECIES_PREFERRED.length()) {\n+            LongVector.fromArray(LongVector.SPECIES_PREFERRED, longindex, j)\n+                .selectFrom(LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc1, j),\n+                            LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc2, j))\n+                .intoArray(longres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromLongVector() {\n+        for (int j = 0; j < size; j += LongVector.SPECIES_PREFERRED.length()) {\n+            LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc1, j)\n+                .rearrange(LongVector.fromArray(LongVector.SPECIES_PREFERRED, longindex, j).toShuffle(),\n+                           LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc2, j))\n+                .intoArray(longres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromFloatVector() {\n+        for (int j = 0; j < size; j += FloatVector.SPECIES_PREFERRED.length()) {\n+            FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatindex, j)\n+                .selectFrom(FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc1, j),\n+                            FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc2, j))\n+                .intoArray(floatres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromFloatVector() {\n+        for (int j = 0; j < size; j += FloatVector.SPECIES_PREFERRED.length()) {\n+            FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc1, j)\n+                .rearrange(FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatindex, j).toShuffle(),\n+                           FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc2, j))\n+                .intoArray(floatres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromDoubleVector() {\n+        for (int j = 0; j < size; j += DoubleVector.SPECIES_PREFERRED.length()) {\n+            DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doubleindex, j)\n+                .selectFrom(DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc1, j),\n+                            DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc2, j))\n+                .intoArray(doubleres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromDoubleVector() {\n+        for (int j = 0; j < size; j += DoubleVector.SPECIES_PREFERRED.length()) {\n+            DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc1, j)\n+                .rearrange(DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doubleindex, j).toShuffle(),\n+                           DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc2, j))\n+                .intoArray(doubleres, j);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/SelectFromBenchmark.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"}]}