{"files":[{"patch":"@@ -180,0 +180,4 @@\n+  static bool vector_indexes_needs_massaging(BasicType ety, int vlen) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -173,0 +173,4 @@\n+  static bool vector_indexes_needs_massaging(BasicType ety, int vlen) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,0 +182,4 @@\n+  static bool vector_indexes_needs_massaging(BasicType ety, int vlen) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -179,0 +179,4 @@\n+  static bool vector_indexes_needs_massaging(BasicType ety, int vlen) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,0 +171,4 @@\n+  static bool vector_indexes_needs_massaging(BasicType ety, int vlen) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4467,16 +4467,0 @@\n-void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x76, (0xC0 | encode));\n-}\n-\n-void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_avx512_vbmi(), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x7D, (0xC0 | encode));\n-}\n-\n@@ -14737,0 +14721,56 @@\n+\n+void Assembler::evpermi2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x75, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x75, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2d(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x76, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x76, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x77, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x77, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x7D, (0xC0 | encode));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":56,"deletions":16,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1874,0 +1874,4 @@\n+  void evpmultishiftqb(XMMRegister dst, XMMRegister ctl, XMMRegister src, int vector_len);\n+  void evpermi2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpermi2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpermi2d(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1875,0 +1879,2 @@\n+  void evpermi2ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpermi2pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1876,1 +1882,0 @@\n-  void evpmultishiftqb(XMMRegister dst, XMMRegister ctl, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6445,0 +6445,29 @@\n+\n+void C2_MacroAssembler::select_from_two_vector_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                    XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      evpermi2b(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_SHORT:\n+      evpermi2w(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_INT:\n+      evpermi2d(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_LONG:\n+      evpermi2q(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_FLOAT:\n+      vcvttps2dq(dst, dst, vlen_enc);\n+      evpermi2ps(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_DOUBLE:\n+      evcvttpd2qq(dst, dst, vlen_enc);\n+      evpermi2pd(dst, src1, src2, vlen_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -508,0 +508,2 @@\n+  void select_from_two_vector_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -215,0 +215,12 @@\n+  static bool vector_indexes_needs_massaging(BasicType ety, int vlen) {\n+     switch(ety) {\n+       default:\n+         return false;\n+       case T_SHORT:\n+         return !VM_Version::supports_avx512bw();\n+       case T_LONG:\n+       case T_DOUBLE:\n+         return !VM_Version::supports_avx512vl();\n+     }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1938,0 +1938,17 @@\n+    case Op_SelectFromTwoVector:\n+       if (size_in_bits < 128 || (size_in_bits < 512 && !VM_Version::supports_avx512vl())) {\n+         return false;\n+       }\n+       if (bt == T_SHORT && !VM_Version::supports_avx512bw()) {\n+         return false;\n+       }\n+       if (bt == T_BYTE && !VM_Version::supports_avx512_vbmi()) {\n+         return false;\n+       }\n+       if ((bt == T_INT || bt == T_FLOAT) && !VM_Version::supports_evex()) {\n+         return false;\n+       }\n+       if (bt == T_DOUBLE && !VM_Version::supports_avx512dq()) {\n+         return false;\n+       }\n+       break;\n@@ -10471,0 +10488,14 @@\n+\n+\n+instruct selectFromTwoVec_evex(vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (SelectFromTwoVector (Binary dst src1) src2));\n+  effect(TEMP dst);\n+  format %{ \"select_from_two_vector $dst, $src1, $src2 \\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ select_from_two_vector_evex(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -4355,1 +4355,1 @@\n-    \"VectorTest\", \"VectorLoadMask\", \"VectorStoreMask\", \"VectorBlend\", \"VectorInsert\",\n+    \"SelectFromTwoVector\", \"VectorTest\", \"VectorLoadMask\", \"VectorStoreMask\", \"VectorBlend\", \"VectorInsert\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -979,0 +979,11 @@\n+  do_intrinsic(_VectorSelectFromTwoVectorOp, jdk_internal_vm_vector_VectorSupport, vector_select_from_op_name, vector_select_from_op_sig, F_S) \\\n+   do_signature(vector_select_from_op_sig, \"(Ljava\/lang\/Class;\"                                                                                \\\n+                                            \"Ljava\/lang\/Class;\"                                                                                \\\n+                                            \"I\"                                                                                                \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$SelectFromTwoVector;)\"                                      \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                   \\\n+   do_name(vector_select_from_op_name,     \"selectFromTwoVectorOp\")                                                                            \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -815,0 +815,1 @@\n+  case vmIntrinsics::_VectorSelectFromTwoVectorOp:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -485,0 +485,1 @@\n+macro(SelectFromTwoVector)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -748,0 +748,2 @@\n+  case vmIntrinsics::_VectorSelectFromTwoVectorOp:\n+    return inline_vector_select_from_two_vectors();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+  bool inline_vector_select_from_two_vectors();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2403,0 +2403,1 @@\n+    case Op_SelectFromTwoVector:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2634,0 +2634,84 @@\n+\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  E>\n+\/\/ V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,\n+\/\/                         V v1, V v2, V v3,\n+\/\/                         SelectFromTwoVector<V> defaultImpl)\n+bool LibraryCallKit::inline_vector_select_from_two_vectors() {\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+\n+  if (vector_klass == nullptr || elem_klass == nullptr ||  vlen == nullptr ||\n+      vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr ||\n+      !vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()]);\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(vector_klass)) {\n+    log_if_needed(\"  ** klass argument not initialized\");\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = elem_type->basic_type();\n+\n+  if (!arch_supports_vector(Op_SelectFromTwoVector, num_elem, elem_bt, VecMaskNotUsed)) {\n+    int opc = VectorSupport::vop2ideal(VectorSupport::VECTOR_OP_SUB, elem_bt);\n+    int sopc = VectorNode::opcode(opc, elem_bt);\n+    if (!arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskNotUsed)   ||\n+        !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)     ||\n+        !arch_supports_vector(Op_VectorRearrange, num_elem, elem_bt, VecMaskNotUsed) ||\n+        (!is_integral_type(elem_bt) &&\n+          ((elem_bt == T_FLOAT && !arch_supports_vector(Op_VectorCastF2X, num_elem, T_INT, VecMaskNotUsed))     ||\n+           (elem_bt == T_DOUBLE && !arch_supports_vector(Op_VectorCastD2X, num_elem, T_LONG, VecMaskNotUsed)))) ||\n+        !arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed)) {\n+      log_if_needed(\"  ** not supported: opc=%d vlen=%d etype=%s ismask=useload\",\n+                    Op_SelectFromTwoVector, num_elem, type2name(elem_bt));\n+      return false; \/\/ not supported\n+    }\n+  }\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  Node* opd1 = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  if (opd1 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v1=%s\",\n+                  NodeClassNames[argument(3)->Opcode()]);\n+    return false;\n+  }\n+  Node* opd2 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  if (opd2 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v1=%s\",\n+                  NodeClassNames[argument(4)->Opcode()]);\n+    return false;\n+  }\n+  Node* opd3 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  if (opd3 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v1=%s\",\n+                  NodeClassNames[argument(5)->Opcode()]);\n+    return false;\n+  }\n+\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  Node* operation = gvn().transform(VectorNode::make(Op_SelectFromTwoVector, opd1, opd2, opd3, vt));\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  Node* vbox = box_vector(operation, vbox_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -784,0 +784,1 @@\n+  case Op_SelectFromTwoVector: return new SelectFromTwoVectorNode(n1, n2, n3, vt);\n@@ -2086,0 +2087,108 @@\n+Node* SelectFromTwoVectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  int num_elem = vect_type()->length();\n+  BasicType elem_bt = vect_type()->element_basic_type();\n+  if (Matcher::match_rule_supported_vector(Op_SelectFromTwoVector, num_elem, elem_bt)) {\n+    return nullptr;\n+  }\n+  Node* index_vec = in(1);\n+  Node* src1  = in(2);\n+  Node* src2  = in(3);\n+\n+  \/\/ Lower the IR to constituents operations.\n+  \/\/   SelectFromTwoVectorNode =\n+  \/\/     (VectorBlend\n+  \/\/         (VectorRearrange SRC1, INDEX)\n+  \/\/         (VectorRearrange SRC2, NORM_INDEX)\n+  \/\/         MASK)\n+  \/\/ This shall prevent an intrinsification failure and associated argument\n+  \/\/ boxing penalties.\n+\n+  auto lane_count_type = [&]() {\n+    switch(elem_bt) {\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_INT:\n+      case T_FLOAT:\n+        return static_cast<const Type*>(TypeInt::make(num_elem));\n+      case T_DOUBLE:\n+      case T_LONG:\n+        return static_cast<const Type*>(TypeLong::make(num_elem));\n+      default:\n+        fatal(\"Unsupported vectortype (%s)\", type2name(elem_bt));\n+        return static_cast<const Type*>(nullptr);\n+    }\n+  };\n+\n+  auto make_integral_index_vec = [&](Node* index_vec) {\n+    switch(elem_bt) {\n+      case T_FLOAT:\n+        return phase->transform(new VectorCastF2XNode(index_vec, TypeVect::make(T_INT, num_elem)));\n+      break;\n+      case T_DOUBLE:\n+        return phase->transform(new VectorCastD2XNode(index_vec, TypeVect::make(T_LONG, num_elem)));\n+      break;\n+      default:\n+        return index_vec;\n+    }\n+  };\n+\n+  auto get_integal_type = [&](BasicType elem_bt) {\n+    switch(elem_bt) {\n+      case T_FLOAT:  return T_INT;\n+      case T_DOUBLE: return T_LONG;\n+      default: return elem_bt;\n+    }\n+  };\n+\n+  BasicType integral_elem_bt = get_integal_type(elem_bt);\n+  int opc = VectorSupport::vop2ideal(VectorSupport::VECTOR_OP_SUB, integral_elem_bt);\n+  int sopc = VectorNode::opcode(opc, integral_elem_bt);\n+\n+  BoolTest::mask pred = BoolTest::lt;\n+  ConINode* pred_node = (ConINode*)phase->makecon(TypeInt::make(pred));\n+  Node* lane_cnt = phase->makecon(lane_count_type());\n+  Node* bcast_lane_cnt_vec = phase->transform(VectorNode::scalar2vector(lane_cnt, num_elem, Type::get_const_basic_type(integral_elem_bt), false));\n+  Node* integral_index_vec = make_integral_index_vec(index_vec);\n+\n+  \/\/ Comparison over integral vectors weeds out emitting additional\n+  \/\/ instructions for checking special floating point values.\n+  const TypeVect* vmask_type = TypeVect::makemask(integral_elem_bt, num_elem);\n+  Node* mask = phase->transform(new VectorMaskCmpNode(pred, integral_index_vec, bcast_lane_cnt_vec, pred_node, vmask_type));\n+\n+  vmask_type = TypeVect::makemask(elem_bt, num_elem);\n+  mask = phase->transform(new VectorMaskCastNode(mask, vmask_type));\n+\n+  Node* p1 = phase->transform(new VectorRearrangeNode(src1, integral_index_vec));\n+  Node* normalized_index_vec = phase->transform(VectorNode::make(sopc, integral_index_vec, bcast_lane_cnt_vec, vect_type()));\n+  Node* p2 = phase->transform(new VectorRearrangeNode(src2, normalized_index_vec));\n+\n+  return new VectorBlendNode(p2, p1, mask);\n+}\n+\n+Node* VectorRearrangeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  BasicType elem_bt = vect_type()->element_basic_type();\n+  int num_elem = vect_type()->length();\n+  if (in(2)->Opcode() != Op_VectorUnbox &&\n+      in(2)->Opcode() != Op_VectorLoadShuffle &&\n+      Matcher::match_rule_supported_vector(Op_VectorRearrange, num_elem, elem_bt) &&\n+      Matcher::vector_indexes_needs_massaging(elem_bt, num_elem)) {\n+    auto get_integal_type = [&](BasicType elem_bt) {\n+      switch(elem_bt) {\n+        case T_FLOAT:  return T_INT;\n+        case T_DOUBLE: return T_LONG;\n+        default: return elem_bt;\n+      }\n+    };\n+    \/\/ Targets emulating unsupported permutation for certain vector types\n+    \/\/ may need to message the indexes to match the users intent.\n+    \/\/ Lowering index vector to a bytevector followed by an explicit loadshuffle\n+    \/\/ will bring the indexes in the consumable format.\n+    int cast_opc = VectorCastNode::opcode(-1, elem_bt, true);\n+    Node* pack_shuf = phase->transform(VectorCastNode::make(cast_opc, in(2), T_BYTE, num_elem));\n+    const TypeVect* newvt = TypeVect::make(get_integal_type(elem_bt), num_elem);\n+    Node* unpack_shuf = phase->transform(new VectorLoadShuffleNode(pack_shuf, newvt));\n+    return new VectorRearrangeNode(in(1), unpack_shuf);\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -1272,0 +1272,1 @@\n+\n@@ -1610,0 +1611,1 @@\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1615,0 +1617,11 @@\n+\n+class SelectFromTwoVectorNode : public VectorNode {\n+public:\n+  SelectFromTwoVectorNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt)\n+  : VectorNode(in1, in2, in3, vt) {}\n+\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual int Opcode() const;\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -384,0 +384,18 @@\n+    \/* ============================================================================ *\/\n+\n+    public interface SelectFromTwoVector<V extends Vector<?>> {\n+        V apply(V v1, V v2, V v3);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     E>\n+    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,\n+                             V v1, V v2, V v3,\n+                             SelectFromTwoVector<V> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v1, v2, v3);\n+    }\n+\n+    \/* ============================================================================ *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte128Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte128Vector)\n+            super.selectFromTemplate((Byte128Vector) v1, (Byte128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte256Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte256Vector)\n+            super.selectFromTemplate((Byte256Vector) v1, (Byte256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte512Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte512Vector)\n+            super.selectFromTemplate((Byte512Vector) v1, (Byte512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte64Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte64Vector)\n+            super.selectFromTemplate((Byte64Vector) v1, (Byte64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (ByteMaxVector)\n+            super.selectFromTemplate((ByteMaxVector) v1, (ByteMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static ByteVector selectFromHelper(Vector<Byte> v1, Vector<Byte> v2, Vector<Byte> v3) {\n+        int vlen = v1.length();\n+        byte[] res = new byte[vlen];\n+        byte[] vpayload1 = ((ByteVector)v1).vec();\n+        byte[] vpayload2 = ((ByteVector)v2).vec();\n+        byte[] vpayload3 = ((ByteVector)v3).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int index = ((int)vpayload1[i]);\n+            res[i] = index >= vlen ? vpayload3[index & (vlen - 1)] : vpayload2[index];\n+        }\n+        return ((ByteVector)v1).vectorFactory(res);\n+    }\n+\n@@ -2571,0 +2584,18 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector selectFrom(Vector<Byte> v1, Vector<Byte> v2);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final ByteVector selectFromTemplate(ByteVector v1, ByteVector v2) {\n+        int twovectorlen = length() * 2;\n+        ByteVector wrapped_indexes = this.lanewise(VectorOperators.AND, twovectorlen - 1);\n+        return (ByteVector)VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, length(), wrapped_indexes, v1, v2,\n+            (vec1, vec2, vec3) -> selectFromHelper(vec1, vec2, vec3)\n+        );\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double128Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double128Vector)\n+            super.selectFromTemplate((Double128Vector) v1, (Double128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double256Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double256Vector)\n+            super.selectFromTemplate((Double256Vector) v1, (Double256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double512Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double512Vector)\n+            super.selectFromTemplate((Double512Vector) v1, (Double512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double64Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double64Vector)\n+            super.selectFromTemplate((Double64Vector) v1, (Double64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (DoubleMaxVector)\n+            super.selectFromTemplate((DoubleMaxVector) v1, (DoubleMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -528,0 +528,13 @@\n+    static DoubleVector selectFromHelper(Vector<Double> v1, Vector<Double> v2, Vector<Double> v3) {\n+        int vlen = v1.length();\n+        double[] res = new double[vlen];\n+        double[] vpayload1 = ((DoubleVector)v1).vec();\n+        double[] vpayload2 = ((DoubleVector)v2).vec();\n+        double[] vpayload3 = ((DoubleVector)v3).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int index = ((int)vpayload1[i]);\n+            res[i] = index >= vlen ? vpayload3[index & (vlen - 1)] : vpayload2[index];\n+        }\n+        return ((DoubleVector)v1).vectorFactory(res);\n+    }\n+\n@@ -2413,0 +2426,22 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector selectFrom(Vector<Double> v1, Vector<Double> v2);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final DoubleVector selectFromTemplate(DoubleVector v1, DoubleVector v2) {\n+        int twovectorlen = length() * 2;\n+        DoubleVector wrapped_indexes = this.convert(VectorOperators.D2I, 0)\n+                                               .lanewise(VectorOperators.AND, twovectorlen - 1)\n+                                               .reinterpretAsInts()\n+                                               .convert(VectorOperators.I2D, 0)\n+                                               .reinterpretAsDoubles();\n+        return (DoubleVector)VectorSupport.selectFromTwoVectorOp(getClass(), double.class, length(), wrapped_indexes, v1, v2,\n+            (vec1, vec2, vec3) -> selectFromHelper(vec1, vec2, vec3)\n+        );\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float128Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float128Vector)\n+            super.selectFromTemplate((Float128Vector) v1, (Float128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float256Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float256Vector)\n+            super.selectFromTemplate((Float256Vector) v1, (Float256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float512Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float512Vector)\n+            super.selectFromTemplate((Float512Vector) v1, (Float512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float64Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float64Vector)\n+            super.selectFromTemplate((Float64Vector) v1, (Float64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (FloatMaxVector)\n+            super.selectFromTemplate((FloatMaxVector) v1, (FloatMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -528,0 +528,13 @@\n+    static FloatVector selectFromHelper(Vector<Float> v1, Vector<Float> v2, Vector<Float> v3) {\n+        int vlen = v1.length();\n+        float[] res = new float[vlen];\n+        float[] vpayload1 = ((FloatVector)v1).vec();\n+        float[] vpayload2 = ((FloatVector)v2).vec();\n+        float[] vpayload3 = ((FloatVector)v3).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int index = ((int)vpayload1[i]);\n+            res[i] = index >= vlen ? vpayload3[index & (vlen - 1)] : vpayload2[index];\n+        }\n+        return ((FloatVector)v1).vectorFactory(res);\n+    }\n+\n@@ -2425,0 +2438,22 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector selectFrom(Vector<Float> v1, Vector<Float> v2);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final FloatVector selectFromTemplate(FloatVector v1, FloatVector v2) {\n+        int twovectorlen = length() * 2;\n+        FloatVector wrapped_indexes = this.convert(VectorOperators.F2I, 0)\n+                                               .lanewise(VectorOperators.AND, twovectorlen - 1)\n+                                               .reinterpretAsInts()\n+                                               .convert(VectorOperators.I2F, 0)\n+                                               .reinterpretAsFloats();\n+        return (FloatVector)VectorSupport.selectFromTwoVectorOp(getClass(), float.class, length(), wrapped_indexes, v1, v2,\n+            (vec1, vec2, vec3) -> selectFromHelper(vec1, vec2, vec3)\n+        );\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int128Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int128Vector)\n+            super.selectFromTemplate((Int128Vector) v1, (Int128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int256Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int256Vector)\n+            super.selectFromTemplate((Int256Vector) v1, (Int256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int512Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int512Vector)\n+            super.selectFromTemplate((Int512Vector) v1, (Int512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int64Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int64Vector)\n+            super.selectFromTemplate((Int64Vector) v1, (Int64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public IntMaxVector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (IntMaxVector)\n+            super.selectFromTemplate((IntMaxVector) v1, (IntMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static IntVector selectFromHelper(Vector<Integer> v1, Vector<Integer> v2, Vector<Integer> v3) {\n+        int vlen = v1.length();\n+        int[] res = new int[vlen];\n+        int[] vpayload1 = ((IntVector)v1).vec();\n+        int[] vpayload2 = ((IntVector)v2).vec();\n+        int[] vpayload3 = ((IntVector)v3).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int index = ((int)vpayload1[i]);\n+            res[i] = index >= vlen ? vpayload3[index & (vlen - 1)] : vpayload2[index];\n+        }\n+        return ((IntVector)v1).vectorFactory(res);\n+    }\n+\n@@ -2556,0 +2569,18 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector selectFrom(Vector<Integer> v1, Vector<Integer> v2);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final IntVector selectFromTemplate(IntVector v1, IntVector v2) {\n+        int twovectorlen = length() * 2;\n+        IntVector wrapped_indexes = this.lanewise(VectorOperators.AND, twovectorlen - 1);\n+        return (IntVector)VectorSupport.selectFromTwoVectorOp(getClass(), int.class, length(), wrapped_indexes, v1, v2,\n+            (vec1, vec2, vec3) -> selectFromHelper(vec1, vec2, vec3)\n+        );\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long128Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long128Vector)\n+            super.selectFromTemplate((Long128Vector) v1, (Long128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long256Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long256Vector)\n+            super.selectFromTemplate((Long256Vector) v1, (Long256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long512Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long512Vector)\n+            super.selectFromTemplate((Long512Vector) v1, (Long512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long64Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long64Vector)\n+            super.selectFromTemplate((Long64Vector) v1, (Long64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public LongMaxVector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (LongMaxVector)\n+            super.selectFromTemplate((LongMaxVector) v1, (LongMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static LongVector selectFromHelper(Vector<Long> v1, Vector<Long> v2, Vector<Long> v3) {\n+        int vlen = v1.length();\n+        long[] res = new long[vlen];\n+        long[] vpayload1 = ((LongVector)v1).vec();\n+        long[] vpayload2 = ((LongVector)v2).vec();\n+        long[] vpayload3 = ((LongVector)v3).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int index = ((int)vpayload1[i]);\n+            res[i] = index >= vlen ? vpayload3[index & (vlen - 1)] : vpayload2[index];\n+        }\n+        return ((LongVector)v1).vectorFactory(res);\n+    }\n+\n@@ -2422,0 +2435,18 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector selectFrom(Vector<Long> v1, Vector<Long> v2);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final LongVector selectFromTemplate(LongVector v1, LongVector v2) {\n+        int twovectorlen = length() * 2;\n+        LongVector wrapped_indexes = this.lanewise(VectorOperators.AND, twovectorlen - 1);\n+        return (LongVector)VectorSupport.selectFromTwoVectorOp(getClass(), long.class, length(), wrapped_indexes, v1, v2,\n+            (vec1, vec2, vec3) -> selectFromHelper(vec1, vec2, vec3)\n+        );\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short128Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short128Vector)\n+            super.selectFromTemplate((Short128Vector) v1, (Short128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short256Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short256Vector)\n+            super.selectFromTemplate((Short256Vector) v1, (Short256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short512Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short512Vector)\n+            super.selectFromTemplate((Short512Vector) v1, (Short512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short64Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short64Vector)\n+            super.selectFromTemplate((Short64Vector) v1, (Short64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (ShortMaxVector)\n+            super.selectFromTemplate((ShortMaxVector) v1, (ShortMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static ShortVector selectFromHelper(Vector<Short> v1, Vector<Short> v2, Vector<Short> v3) {\n+        int vlen = v1.length();\n+        short[] res = new short[vlen];\n+        short[] vpayload1 = ((ShortVector)v1).vec();\n+        short[] vpayload2 = ((ShortVector)v2).vec();\n+        short[] vpayload3 = ((ShortVector)v3).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int index = ((int)vpayload1[i]);\n+            res[i] = index >= vlen ? vpayload3[index & (vlen - 1)] : vpayload2[index];\n+        }\n+        return ((ShortVector)v1).vectorFactory(res);\n+    }\n+\n@@ -2572,0 +2585,18 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector selectFrom(Vector<Short> v1, Vector<Short> v2);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final ShortVector selectFromTemplate(ShortVector v1, ShortVector v2) {\n+        int twovectorlen = length() * 2;\n+        ShortVector wrapped_indexes = this.lanewise(VectorOperators.AND, twovectorlen - 1);\n+        return (ShortVector)VectorSupport.selectFromTwoVectorOp(getClass(), short.class, length(), wrapped_indexes, v1, v2,\n+            (vec1, vec2, vec3) -> selectFromHelper(vec1, vec2, vec3)\n+        );\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2769,0 +2769,23 @@\n+    \/**\n+     * Rearranges the lane elements of two vectors, selecting lanes\n+     * under the control of a specific index vector (the current vector)\n+     * holding indexes in valid index range of two vectors i.e. {@code [0, VLENGTH*2)}.\n+     *\n+     * This is a cross-lane operation that rearranges the lane\n+     * elements of the two input vectors {@code v1} and a second vector {@code v2}).\n+     *\n+     * For each lane {@code N} of the index vector (the current vector), and\n+     * for each lane source index {@code I=this.laneSource(N)} in the index vector,\n+     * the output lane {@code N} obtains the value from the first vector at lane {@code I}\n+     * if {@code I>=0 && I < VLENGTH}. Otherwise, index vector lane is used to index\n+     * the <em>second<\/em> vector, at index {@code I-VLENGTH}.\n+     *\n+     * @param v1 the first input vector\n+     * @param v2 the second input vector\n+     * @return the rearrangement of lane elements of first and\n+     *         the second input vector\n+     * @throws IndexOutOfBoundsException if any invalid\n+     *         source indexes are found in {@code this}\n+     *\/\n+    public abstract Vector<E> selectFrom(Vector<E> v1, Vector<E> v2);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -566,0 +566,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -553,0 +553,13 @@\n+    static $abstractvectortype$ selectFromHelper(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2, Vector<$Boxtype$> v3) {\n+        int vlen = v1.length();\n+        $type$[] res = new $type$[vlen];\n+        $type$[] vpayload1 = (($abstractvectortype$)v1).vec();\n+        $type$[] vpayload2 = (($abstractvectortype$)v2).vec();\n+        $type$[] vpayload3 = (($abstractvectortype$)v3).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int index = ((int)vpayload1[i]);\n+            res[i] = index >= vlen ? vpayload3[index & (vlen - 1)] : vpayload2[index];\n+        }\n+        return (($abstractvectortype$)v1).vectorFactory(res);\n+    }\n+\n@@ -2948,0 +2961,34 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    $abstractvectortype$ selectFrom(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final $abstractvectortype$ selectFromTemplate($abstractvectortype$ v1, $abstractvectortype$ v2) {\n+        int twovectorlen = length() * 2;\n+#if[FP]\n+#if[intOrFloat]\n+        $abstractvectortype$ wrapped_indexes = this.convert(VectorOperators.F2I, 0)\n+                                               .lanewise(VectorOperators.AND, twovectorlen - 1)\n+                                               .reinterpretAsInts()\n+                                               .convert(VectorOperators.I2F, 0)\n+                                               .reinterpretAsFloats();\n+#else[intOrFloat]\n+        $abstractvectortype$ wrapped_indexes = this.convert(VectorOperators.D2I, 0)\n+                                               .lanewise(VectorOperators.AND, twovectorlen - 1)\n+                                               .reinterpretAsInts()\n+                                               .convert(VectorOperators.I2D, 0)\n+                                               .reinterpretAsDoubles();\n+#end[intOrFloat]\n+#else[FP]\n+        $abstractvectortype$ wrapped_indexes = this.lanewise(VectorOperators.AND, twovectorlen - 1);\n+#end[FP]\n+        return ($Type$Vector)VectorSupport.selectFromTwoVectorOp(getClass(), $type$.class, length(), wrapped_indexes, v1, v2,\n+            (vec1, vec2, vec3) -> selectFromHelper(vec1, vec2, vec3)\n+        );\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -515,0 +515,7 @@\n+    @Override\n+    @ForceInline\n+    public $vectortype$ selectFrom(Vector<$Boxtype$> v1,\n+                                   Vector<$Boxtype$> v2) {\n+        return ($vectortype$)\n+            super.selectFromTemplate(($vectortype$) v1, ($vectortype$) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -991,0 +1010,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1018,0 +1049,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5778,0 +5815,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -991,0 +1010,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1018,0 +1049,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5778,0 +5815,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -991,0 +1010,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1018,0 +1049,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5778,0 +5815,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -991,0 +1010,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1018,0 +1049,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5778,0 +5815,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -321,0 +321,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -996,0 +1015,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1023,0 +1054,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5783,0 +5820,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1135,0 +1154,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1162,0 +1193,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4835,0 +4872,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble128VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1135,0 +1154,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1162,0 +1193,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4835,0 +4872,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble256VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1135,0 +1154,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1162,0 +1193,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4835,0 +4872,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble512VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1135,0 +1154,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1162,0 +1193,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4835,0 +4872,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble64VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -338,0 +338,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1140,0 +1159,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1167,0 +1198,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4840,0 +4877,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDoubleMaxVectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1146,0 +1165,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1173,0 +1204,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4814,0 +4851,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat128VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1146,0 +1165,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1173,0 +1204,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4814,0 +4851,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat256VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1146,0 +1165,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1173,0 +1204,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4814,0 +4851,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat512VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -333,0 +333,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1146,0 +1165,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1173,0 +1204,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4814,0 +4851,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat64VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -338,0 +338,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1151,0 +1170,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1178,0 +1209,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4817,0 +4854,18 @@\n+    }\n+\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloatMaxVectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5811,0 +5848,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5811,0 +5848,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5811,0 +5848,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5811,0 +5848,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -321,0 +321,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -986,0 +1005,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1013,0 +1044,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5816,0 +5853,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -273,0 +273,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -971,0 +990,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -998,0 +1029,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5697,0 +5734,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -273,0 +273,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -971,0 +990,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -998,0 +1029,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5697,0 +5734,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -273,0 +273,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -971,0 +990,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -998,0 +1029,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5697,0 +5734,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -273,0 +273,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -971,0 +990,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -998,0 +1029,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5697,0 +5734,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -278,0 +278,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -976,0 +995,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1003,0 +1034,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5702,0 +5739,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5758,0 +5795,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5758,0 +5795,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5758,0 +5795,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -316,0 +316,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -981,0 +1000,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1008,0 +1039,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5758,0 +5795,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -321,0 +321,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -986,0 +1005,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1013,0 +1044,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5761,0 +5798,18 @@\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -300,0 +300,18 @@\n+    @Test(dataProvider = \"$type$SelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVector$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] idx = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ idxv = $abstractvectortype$.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -399,0 +399,19 @@\n+    static void assertSelectFromTwoVectorEquals($type$[] r, $type$[] order, $type$[] a, $type$[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    int idx = i + j;\n+                    boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+                    int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            boolean is_exceptional_idx = (int)order[idx] >= vector_len;\n+            int oidx = is_exceptional_idx ? ((int)order[idx] - vector_len) : (int)order[idx];\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + (int)order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1238,0 +1257,12 @@\n+    static final List<IntFunction<$type$[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"$type$[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(RAND.nextInt(SPECIES.length() * 2)));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_GENERATOR_SELECT_FROM_TRIPLES =\n+        $TYPE$_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1265,0 +1296,6 @@\n+    @DataProvider\n+    public Object[][] $type$SelectFromTwoVectorOpProvider() {\n+        return $TYPE$_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SelectFromBenchmark {\n+    @Param({\"1024\",\"2048\"})\n+    int size;\n+\n+    byte[] byteindex;\n+    byte[] bytesrc1;\n+    byte[] bytesrc2;\n+    byte[] byteres;\n+\n+    short[] shortindex;\n+    short[] shortsrc1;\n+    short[] shortsrc2;\n+    short[] shortres;\n+\n+    int[] intindex;\n+    int[] intsrc1;\n+    int[] intsrc2;\n+    int[] intres;\n+\n+    long[] longindex;\n+    long[] longsrc1;\n+    long[] longsrc2;\n+    long[] longres;\n+\n+    float[] floatindex;\n+    float[] floatsrc1;\n+    float[] floatsrc2;\n+    float[] floatres;\n+\n+    double[] doubleindex;\n+    double[] doublesrc1;\n+    double[] doublesrc2;\n+    double[] doubleres;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        byteindex = new byte[size];\n+        bytesrc1 = new byte[size];\n+        bytesrc2 = new byte[size];\n+        byteres = new byte[size];\n+\n+        shortindex = new short[size];\n+        shortsrc1 = new short[size];\n+        shortsrc2 = new short[size];\n+        shortres = new short[size];\n+\n+        intindex = new int[size];\n+        intsrc1 = new int[size];\n+        intsrc2 = new int[size];\n+        intres = new int[size];\n+\n+        longindex = new long[size];\n+        longsrc1 = new long[size];\n+        longsrc2 = new long[size];\n+        longres = new long[size];\n+\n+        floatindex = new float[size];\n+        floatsrc1 = new float[size];\n+        floatsrc2 = new float[size];\n+        floatres = new float[size];\n+\n+        doubleindex = new double[size];\n+        doublesrc1 = new double[size];\n+        doublesrc2 = new double[size];\n+        doubleres = new double[size];\n+\n+        Arrays.fill(bytesrc1, (byte)1);\n+        Arrays.fill(bytesrc2, (byte)2);\n+\n+        Arrays.fill(shortsrc1, (short)1);\n+        Arrays.fill(shortsrc2, (short)2);\n+\n+        Arrays.fill(intsrc1, 1);\n+        Arrays.fill(intsrc2, 2);\n+\n+        Arrays.fill(longsrc1, 1);\n+        Arrays.fill(longsrc2, 2);\n+\n+        Arrays.fill(floatsrc1, 1.0f);\n+        Arrays.fill(floatsrc2, 2.0f);\n+\n+        Arrays.fill(doublesrc1, 1.0);\n+        Arrays.fill(doublesrc2, 2.0);\n+\n+        for (int i = 0; i < size; i++) {\n+            byteindex[i] = (byte)((ByteVector.SPECIES_PREFERRED.length() - 1) & i);\n+            shortindex[i] = (short)((ShortVector.SPECIES_PREFERRED.length() - 1) & i);\n+            intindex[i] = (int)((IntVector.SPECIES_PREFERRED.length() - 1) & i);\n+            longindex[i] = (long)((LongVector.SPECIES_PREFERRED.length() - 1) & i);\n+            floatindex[i] = (float)((FloatVector.SPECIES_PREFERRED.length() - 1) & i);\n+            doubleindex[i] = (double)((DoubleVector.SPECIES_PREFERRED.length() - 1) & i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromByteVector() {\n+        for (int j = 0; j < size; j += ByteVector.SPECIES_PREFERRED.length()) {\n+            ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, byteindex, j)\n+                .selectFrom(ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc1, j),\n+                            ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc2, j))\n+                .intoArray(byteres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromByteVector() {\n+        for (int j = 0; j < size; j += ByteVector.SPECIES_PREFERRED.length()) {\n+            ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc1, j)\n+                .rearrange(ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, byteindex, j).toShuffle(),\n+                           ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc2, j))\n+                .intoArray(byteres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromShortVector() {\n+        for (int j = 0; j < size; j += ShortVector.SPECIES_PREFERRED.length()) {\n+            ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortindex, j)\n+                .selectFrom(ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc1, j),\n+                            ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc2, j))\n+                .intoArray(shortres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromShortVector() {\n+        for (int j = 0; j < size; j += ShortVector.SPECIES_PREFERRED.length()) {\n+            ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc1, j)\n+                .rearrange(ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortindex, j).toShuffle(),\n+                           ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc2, j))\n+                .intoArray(shortres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromIntVector() {\n+        for (int j = 0; j < size; j += IntVector.SPECIES_PREFERRED.length()) {\n+            IntVector.fromArray(IntVector.SPECIES_PREFERRED, intindex, j)\n+                .selectFrom(IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc1, j),\n+                            IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc2, j))\n+                .intoArray(intres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromIntVector() {\n+        for (int j = 0; j < size; j += IntVector.SPECIES_PREFERRED.length()) {\n+            IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc1, j)\n+                .rearrange(IntVector.fromArray(IntVector.SPECIES_PREFERRED, intindex, j).toShuffle(),\n+                           IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc2, j))\n+                .intoArray(intres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromLongVector() {\n+        for (int j = 0; j < size; j += LongVector.SPECIES_PREFERRED.length()) {\n+            LongVector.fromArray(LongVector.SPECIES_PREFERRED, longindex, j)\n+                .selectFrom(LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc1, j),\n+                            LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc2, j))\n+                .intoArray(longres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromLongVector() {\n+        for (int j = 0; j < size; j += LongVector.SPECIES_PREFERRED.length()) {\n+            LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc1, j)\n+                .rearrange(LongVector.fromArray(LongVector.SPECIES_PREFERRED, longindex, j).toShuffle(),\n+                           LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc2, j))\n+                .intoArray(longres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromFloatVector() {\n+        for (int j = 0; j < size; j += FloatVector.SPECIES_PREFERRED.length()) {\n+            FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatindex, j)\n+                .selectFrom(FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc1, j),\n+                            FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc2, j))\n+                .intoArray(floatres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromFloatVector() {\n+        for (int j = 0; j < size; j += FloatVector.SPECIES_PREFERRED.length()) {\n+            FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc1, j)\n+                .rearrange(FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatindex, j).toShuffle(),\n+                           FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc2, j))\n+                .intoArray(floatres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromDoubleVector() {\n+        for (int j = 0; j < size; j += DoubleVector.SPECIES_PREFERRED.length()) {\n+            DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doubleindex, j)\n+                .selectFrom(DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc1, j),\n+                            DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc2, j))\n+                .intoArray(doubleres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromDoubleVector() {\n+        for (int j = 0; j < size; j += DoubleVector.SPECIES_PREFERRED.length()) {\n+            DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc1, j)\n+                .rearrange(DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doubleindex, j).toShuffle(),\n+                           DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc2, j))\n+                .intoArray(doubleres, j);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/SelectFromBenchmark.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"}]}