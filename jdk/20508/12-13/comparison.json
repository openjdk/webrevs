{"files":[{"patch":"@@ -10490,1 +10490,0 @@\n-  effect(TEMP index);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2636,0 +2636,53 @@\n+static Node* LowerSelectFromTwoVectorOperation(PhaseGVN& phase, Node* index_vec, Node* src1, Node* src2, const TypeVect* vt) {\n+  int num_elem = vt->length();\n+  BasicType elem_bt = vt->element_basic_type();\n+\n+  \/\/ Lower select from operations to its constituents operations.\n+  \/\/   SelectFromTwoVectorNode =\n+  \/\/     (VectorBlend\n+  \/\/         (VectorRearrange SRC1 (WRAPED_INDEX AND (VLEN-1))\n+  \/\/         (VectorRearrange SRC2 (WRAPED_INDEX AND (VLEN-1))\n+  \/\/         MASK)\n+  \/\/ Where\n+  \/\/   incoming WRAPED_INDEX is within two vector index range [0, VLEN*2) and\n+  \/\/   MASK = WRAPED_INDEX < VLEN\n+  \/\/\n+  \/\/ IR lowering prevents intrinsification failure and associated argument\n+  \/\/ boxing penalties.\n+  \/\/\n+\n+  const TypeVect* index_vect_type = index_vec->bottom_type()->is_vect();\n+  BasicType index_elem_bt = index_vect_type->element_basic_type();\n+\n+  \/\/ Downcast index vector to a type agnostic shuffle representation, shuffle indices\n+  \/\/ are held in a byte vector which are later transformed to target specific permutation\n+  \/\/ index format by subsequent VectorLoadShuffle.\n+  int cast_vopc = VectorCastNode::opcode(0, index_elem_bt, true);\n+  Node* index_byte_vec = phase.transform(VectorCastNode::make(cast_vopc, index_vec, T_BYTE, num_elem));\n+\n+  Node* lane_cnt_m1 = phase.makecon(TypeInt::make(num_elem - 1));\n+  Node* bcast_lane_cnt_m1_vec = phase.transform(VectorNode::scalar2vector(lane_cnt_m1, num_elem, Type::get_const_basic_type(T_BYTE), false));\n+\n+  \/\/ Compute the blend mask for merging two independently permitted vectors\n+  \/\/ using shuffle index in two vector index range [0, VLEN * 2).\n+  BoolTest::mask pred = BoolTest::le;\n+  ConINode* pred_node = phase.makecon(TypeInt::make(pred))->as_ConI();\n+  const TypeVect* vmask_type = TypeVect::makemask(T_BYTE, num_elem);\n+  Node* mask = phase.transform(new VectorMaskCmpNode(pred, index_byte_vec, bcast_lane_cnt_m1_vec, pred_node, vmask_type));\n+\n+  \/\/ Rearrange expects the indexes to lie within single vector index range [0, VLEN).\n+  index_byte_vec = phase.transform(VectorNode::make(Op_AndV, index_byte_vec, bcast_lane_cnt_m1_vec, index_byte_vec->bottom_type()->is_vect()));\n+\n+  \/\/ Load indexes from byte vector and appropriately transform them to target specific\n+  \/\/ permutation index format.\n+  index_vec = phase.transform(new VectorLoadShuffleNode(index_byte_vec, index_vect_type));\n+\n+  vmask_type = TypeVect::makemask(elem_bt, num_elem);\n+  mask = phase.transform(new VectorMaskCastNode(mask, vmask_type));\n+\n+  Node* p1 = phase.transform(new VectorRearrangeNode(src1, index_vec));\n+  Node* p2 = phase.transform(new VectorRearrangeNode(src2, index_vec));\n+\n+  return new VectorBlendNode(p2, p1, mask);\n+}\n+\n@@ -2681,0 +2734,1 @@\n+  bool lowerSelectFromOp = false;\n@@ -2685,0 +2739,1 @@\n+        !arch_supports_vector(Op_VectorMaskCast, num_elem, elem_bt, VecMaskNotUsed)          ||\n@@ -2694,0 +2749,1 @@\n+    lowerSelectFromOp = true;\n@@ -2698,1 +2754,0 @@\n-    index_elem_bt = elem_bt == T_FLOAT ? T_INT : T_LONG;\n@@ -2740,1 +2795,5 @@\n-  Node* operation = gvn().transform(VectorNode::make(Op_SelectFromTwoVector, opd1, opd2, opd3, vt));\n+\n+  Node* operation = lowerSelectFromOp ?\n+                      LowerSelectFromTwoVectorOperation(gvn(), opd1, opd2, opd3, vt) :\n+                      VectorNode::make(Op_SelectFromTwoVector, opd1, opd2, opd3, vt);\n+  operation = gvn().transform(operation);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":61,"deletions":2,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2087,62 +2087,0 @@\n-Node* SelectFromTwoVectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  int num_elem = vect_type()->length();\n-  BasicType elem_bt = vect_type()->element_basic_type();\n-\n-  \/\/ Keep the node if it is supported, else lower it to other nodes.\n-  if (Matcher::match_rule_supported_vector(Op_SelectFromTwoVector, num_elem, elem_bt)) {\n-    return nullptr;\n-  }\n-\n-  Node* index_vec = in(1);\n-  Node* src1 = in(2);\n-  Node* src2 = in(3);\n-\n-  \/\/ Lower the IR to constituents operations.\n-  \/\/   SelectFromTwoVectorNode =\n-  \/\/     (VectorBlend\n-  \/\/         (VectorRearrange SRC1 (WRAPED_INDEX AND (VLEN-1))\n-  \/\/         (VectorRearrange SRC2 (WRAPED_INDEX AND (VLEN-1))\n-  \/\/         MASK)\n-  \/\/ Where\n-  \/\/   incoming WRAPED_INDEX is within two vector index range [0, VLEN*2) and\n-  \/\/   MASK = WRAPED_INDEX < VLEN\n-  \/\/\n-  \/\/ IR lowering prevents intrinsification failure and associated argument\n-  \/\/ boxing penalties.\n-  \/\/\n-\n-  const TypeVect* index_vect_type = index_vec->bottom_type()->is_vect();\n-  BasicType index_elem_bt = index_vect_type->element_basic_type();\n-\n-  \/\/ Downcast index vector to a type agnostic shuffle representation, shuffle indices\n-  \/\/ are held in a byte vector which are later transformed to target specific permutation\n-  \/\/ index format by subsequent VectorLoadShuffle.\n-  int cast_vopc = VectorCastNode::opcode(0, index_elem_bt, true);\n-  Node* index_byte_vec = phase->transform(VectorCastNode::make(cast_vopc, index_vec, T_BYTE, num_elem));\n-\n-  Node* lane_cnt_m1 = phase->makecon(TypeInt::make(num_elem - 1));\n-  Node* bcast_lane_cnt_m1_vec = phase->transform(VectorNode::scalar2vector(lane_cnt_m1, num_elem, Type::get_const_basic_type(T_BYTE), false));\n-\n-  \/\/ Compute the blend mask for merging two indipendently permututed vectors\n-  \/\/ using shuff index in two vector index range [0, VLEN * 2).\n-  BoolTest::mask pred = BoolTest::le;\n-  ConINode* pred_node = phase->makecon(TypeInt::make(pred))->as_ConI();\n-  const TypeVect* vmask_type = TypeVect::makemask(T_BYTE, num_elem);\n-  Node* mask = phase->transform(new VectorMaskCmpNode(pred, index_byte_vec, bcast_lane_cnt_m1_vec, pred_node, vmask_type));\n-\n-  \/\/ Rearrange expects the indexes to lie within single vector index range [0, VLEN).\n-  index_byte_vec = phase->transform(VectorNode::make(Op_AndV, index_byte_vec, bcast_lane_cnt_m1_vec, index_byte_vec->bottom_type()->is_vect()));\n-\n-  \/\/ Load indexes from byte vector and appropriatly transform them to target specific\n-  \/\/ permutation index format.\n-  index_vec = phase->transform(new VectorLoadShuffleNode(index_byte_vec, index_vect_type));\n-\n-  vmask_type = TypeVect::makemask(elem_bt, num_elem);\n-  mask = phase->transform(new VectorMaskCastNode(mask, vmask_type));\n-\n-  Node* p1 = phase->transform(new VectorRearrangeNode(src1, index_vec));\n-  Node* p2 = phase->transform(new VectorRearrangeNode(src2, index_vec));\n-\n-  return new VectorBlendNode(p2, p1, mask);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1626,1 +1626,0 @@\n-  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}