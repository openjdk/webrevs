{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import java.util.ArrayDeque;\n@@ -101,2 +100,9 @@\n-    \/* The original search path of URLs. *\/\n-    private final ArrayList<URL> path;\n+    \/* Search path of URLs passed to the constructor or by calls to addURL\n+     * Access is guarded by a monitor on 'searchPath' itself\n+     *\/\n+    private final ArrayList<URL> searchPath;\n+\n+    \/* Index of the next URL in the search path to process\n+     * Access is guarded by a monitor on 'searchPath'\n+     *\/\n+    private int nextURL = 0;\n@@ -104,2 +110,4 @@\n-    \/* The deque of unopened URLs *\/\n-    private final ArrayDeque<URL> unopenedUrls;\n+    \/* Queue of URLs found during expansion of JAR 'Class-Path' attributes\n+     * Access is guarded by a monitor on 'searchPath'\n+     *\/\n+    private final ArrayList<URL> expandedPath = new ArrayList<>();\n@@ -131,8 +139,2 @@\n-        ArrayList<URL> path = new ArrayList<>(urls.length);\n-        ArrayDeque<URL> unopenedUrls = new ArrayDeque<>(urls.length);\n-        for (URL url : urls) {\n-            path.add(url);\n-            unopenedUrls.add(url);\n-        }\n-        this.path = path;\n-        this.unopenedUrls = unopenedUrls;\n+        \/\/ Reject null URLs\n+        this.searchPath = new ArrayList<>(List.of(urls));\n@@ -177,10 +179,1 @@\n-\n-        \/\/ can't use ArrayDeque#addAll or new ArrayDeque(Collection);\n-        \/\/ it's too early in the bootstrap to trigger use of lambdas\n-        int size = path.size();\n-        ArrayDeque<URL> unopenedUrls = new ArrayDeque<>(size);\n-        for (int i = 0; i < size; i++)\n-            unopenedUrls.add(path.get(i));\n-\n-        this.unopenedUrls = unopenedUrls;\n-        this.path = path;\n+        this.searchPath = path;\n@@ -218,4 +211,3 @@\n-        synchronized (unopenedUrls) {\n-            if (! path.contains(url)) {\n-                unopenedUrls.addLast(url);\n-                path.add(url);\n+        synchronized (searchPath) {\n+            if (! searchPath.contains(url)) {\n+                searchPath.add(url);\n@@ -252,2 +244,2 @@\n-        synchronized (unopenedUrls) {\n-            return path.toArray(new URL[0]);\n+        synchronized (searchPath) {\n+            return searchPath.toArray(new URL[0]);\n@@ -382,0 +374,17 @@\n+    \/*\n+     * Returns the next URL to process or null if finished\n+     *\/\n+    private URL nextURL() {\n+        synchronized (searchPath) {\n+            \/\/ Check paths discovered during 'Class-Path' expansion first\n+            if (!expandedPath.isEmpty()) {\n+                return expandedPath.removeLast();\n+            }\n+            \/\/ Check the regular search path\n+            if (nextURL < searchPath.size()) {\n+                return searchPath.get(nextURL++);\n+            }\n+            \/\/ All paths exhausted\n+            return null;\n+        }\n+    }\n@@ -392,1 +401,1 @@\n-        \/\/ or unopenedUrls is exhausted.\n+        \/\/ or all paths are exhausted.\n@@ -394,5 +403,3 @@\n-            final URL url;\n-            synchronized (unopenedUrls) {\n-                url = unopenedUrls.pollFirst();\n-                if (url == null)\n-                    return null;\n+            final URL url = nextURL();\n+            if (url == null) {\n+                return null;\n@@ -400,0 +407,1 @@\n+\n@@ -425,1 +433,1 @@\n-                push(loaderClassPathURLs);\n+                addExpandedPaths(loaderClassPathURLs);\n@@ -478,1 +486,1 @@\n-     * Pushes the specified URLs onto the head of unopened URLs.\n+     * Adds the specified URLs to the queue of 'Class-Path' expanded URLs\n@@ -480,5 +488,4 @@\n-    private void push(URL[] urls) {\n-        synchronized (unopenedUrls) {\n-            for (int i = urls.length - 1; i >= 0; --i) {\n-                unopenedUrls.addFirst(urls[i]);\n-            }\n+    private void addExpandedPaths(URL[] urls) {\n+        synchronized (searchPath) {\n+            \/\/ Adding in reversed order since expandedPath is consumed tail-first\n+            expandedPath.addAll(Arrays.asList(urls).reversed());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":50,"deletions":43,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8375580\n+ * @summary Verify that URLClassPath discovers JAR Class-Path URLs in DFS order\n+ * @run junit JarClassPathDfsOrder\n+ *\/\n+public class JarClassPathDfsOrder {\n+\n+    \/\/ Name of the JAR resource use for lookups\n+    private static final String ENTRY_NAME = \"JarClassPathOrdering.txt\";\n+\n+    \/**\n+     * Verify that URLClassPath discovers JAR files in DFS order when only\n+     * root JARs are on the 'original' class path and the other JARs are\n+     * found via multiple levels of Class-Path Manifest attributes.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @Test\n+    public void shouldLoadJARsInDFSOrder() throws IOException {\n+\n+        \/\/ Set up a 'Class-Path' JAR tree of depth 3\n+        JarTree specs = new JarTree();\n+        specs.addJars(3);\n+\n+        \/\/ List of \"root\" JAR file URLs to use for URLClassLoader\n+        List<URL> searchPath = new ArrayList<>();\n+\n+        \/\/ Order of JAR files we expect URLClassPath to find\n+        List<String> dfsJarNames = new ArrayList<>();\n+\n+        for (JarSpec spec : specs.dfs) {\n+            Path jar = createJar(spec);\n+            dfsJarNames.add(jar.getFileName().toString());\n+            \/\/ Only root JARs in the search path, others are discovered transitively via \"Class-Path\"\n+            if (spec.isRoot()) {\n+                searchPath.add(jar.toUri().toURL());\n+            }\n+        }\n+\n+        \/\/ Load ENTRY_NAME to identify all JARs found by URLClassPath\n+        try (URLClassLoader loader = new URLClassLoader(searchPath.toArray(new URL[0]))) {\n+            Enumeration<URL> resources = loader.getResources(ENTRY_NAME);\n+            \/\/ Collect all JAR file names in the order discovered by URLClassPath\n+            List<String> actualJarNames = Collections.list(resources)\n+                    .stream()\n+                    .map(this::extractJarName)\n+                    .collect(Collectors.toList());\n+            \/\/ JARs should be found in DFS order\n+            assertEquals(dfsJarNames, actualJarNames, \"JAR files not found in expected DFS order\");\n+        }\n+    }\n+\n+    \/\/ Extract file name of JAR file from a JAR URL\n+    private String extractJarName(URL url) {\n+        String jarPath = url.getPath().substring(0, url.getPath().indexOf(\"!\/\"));\n+        String jarName = jarPath.substring(jarPath.lastIndexOf('\/') + 1);\n+        return jarName;\n+    }\n+\n+    \/\/ Create a JAR file according to the spec, possibly including a Class-Path attribute\n+    private Path createJar(JarSpec spec) throws IOException {\n+        Path file = Path.of(spec.name +\".jar\");\n+        Manifest man = new Manifest();\n+        Attributes attrs = man.getMainAttributes();\n+        attrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+\n+        \/\/ Set Class-Path attribute\n+        if (!spec.children.isEmpty()) {\n+            String path = String.join(\" \", spec.children\n+                    .stream()\n+                    .map(js -> js.name +\".jar\")\n+                    .collect(Collectors.toList()));\n+            attrs.put(Attributes.Name.CLASS_PATH, path);\n+        }\n+\n+        try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(file), man)) {\n+            \/\/ All JARs include the same entry\n+            out.putNextEntry(new JarEntry(ENTRY_NAME));\n+        }\n+\n+        return file;\n+    }\n+\n+\n+    \/\/ Helper class to represent a tree of JARs related by \"Class-Path\"\n+    static class JarTree {\n+        static final List<String> NAMES = List.of(\"a\", \"b\", \"c\");\n+        List<JarSpec> dfs = new ArrayList<>();\n+\n+        private void addJar(String prefix, String name, JarSpec parent, int depth, int maxDepth) {\n+            if (depth > maxDepth) {\n+                return;\n+            }\n+            JarSpec spec = new JarSpec(prefix + name, parent);\n+            dfs.add(spec);\n+\n+            if (parent != null) {\n+                parent.children.add(spec);\n+            }\n+\n+            for (String childName : NAMES) {\n+                addJar(prefix + name, childName, spec, depth + 1, maxDepth);\n+            }\n+        }\n+\n+        \/* Make a tree of JARs related by the 'Class-Path' Manifest attribute:\n+         * a.jar\n+         *  aa.jar\n+         *    aaa.jar\n+         *    aab.jar\n+         * [...]\n+         *    ccc.jar\n+         *\/\n+        public void addJars(int maxDepth) {\n+            for (String name : NAMES) {\n+                addJar(\"\", name, null, 1, maxDepth);\n+            }\n+        }\n+    }\n+\n+    \/\/ Helper class to represent a JAR file to be found by URLClassPath\n+    static class JarSpec {\n+        final String name;\n+        final JarSpec parent;\n+        final List<JarSpec> children = new ArrayList<>();\n+\n+        JarSpec(String name, JarSpec parent) {\n+            this.name = name;\n+            this.parent = parent;\n+        }\n+        boolean isRoot() {\n+            return parent == null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/JarClassPathDfsOrder.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"}]}