{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-    static BoundMethodHandle bindSingle(MethodType type, LambdaForm form, Object x) {\n+    static BoundMethodHandle bindSingleL(MethodType type, LambdaForm form, Object x) {\n@@ -69,0 +69,32 @@\n+    static BoundMethodHandle bindSingleI(MethodType type, LambdaForm form, int x) {\n+        try {\n+            return (BoundMethodHandle) SimpleMethodHandle.BMH_SPECIES.extendWith(I_TYPE).factory().invokeBasic(type, form, x);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+    }\n+\n+    static BoundMethodHandle bindSingleJ(MethodType type, LambdaForm form, long x) {\n+        try {\n+            return (BoundMethodHandle) SimpleMethodHandle.BMH_SPECIES.extendWith(J_TYPE).factory().invokeBasic(type, form, x);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+    }\n+\n+    static BoundMethodHandle bindSingleF(MethodType type, LambdaForm form, float x) {\n+        try {\n+            return (BoundMethodHandle) SimpleMethodHandle.BMH_SPECIES.extendWith(F_TYPE).factory().invokeBasic(type, form, x);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+    }\n+\n+    static BoundMethodHandle bindSingleD(MethodType type, LambdaForm form, double x) {\n+        try {\n+            return (BoundMethodHandle) SimpleMethodHandle.BMH_SPECIES.extendWith(D_TYPE).factory().invokeBasic(type, form, x);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -381,7 +381,1 @@\n-            LambdaForm zero = LambdaForm.zeroForm(type);\n-            String name = zero.kind.defaultLambdaName\n-                   + \"_\" + zero.returnType().basicTypeChar();\n-            if (dedupSet.add(name)) {\n-                names.add(name);\n-                forms.add(zero);\n-            }\n+            String name;\n@@ -396,0 +390,10 @@\n+\n+            if (type != V_TYPE) {\n+                LambdaForm constant = LambdaForm.constantForm(type);\n+                name = constant.kind.defaultLambdaName\n+                        + \"_\" + constant.returnType().basicTypeChar();\n+                if (dedupSet.add(name)) {\n+                    names.add(name);\n+                    forms.add(constant);\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -460,2 +460,2 @@\n-            case ZERO:                      \/\/ fall-through\n-            case IDENTITY: {\n+            case IDENTITY:                  \/\/ fall-through\n+            case CONSTANT: {\n@@ -634,4 +634,0 @@\n-                                case ZERO:\n-                                    assert(name.arguments.length == 0);\n-                                    cob.loadConstant((ConstantDesc)name.type.basicTypeWrapper().zero());\n-                                    continue;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,1 @@\n-        MethodHandle invoker = BoundMethodHandle.bindSingle(invokerType, lform, mtype);\n+        MethodHandle invoker = BoundMethodHandle.bindSingleL(invokerType, lform, mtype);\n@@ -162,1 +162,1 @@\n-        MethodHandle invoker = BoundMethodHandle.bindSingle(invokerType, lform, ad);\n+        MethodHandle invoker = BoundMethodHandle.bindSingleL(invokerType, lform, ad);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -248,1 +248,0 @@\n-        ZERO(\"zero\"),\n@@ -250,0 +249,1 @@\n+        CONSTANT(\"constant\"),\n@@ -375,1 +375,1 @@\n-        \/\/ Make a blank lambda form, which returns a constant zero or null.\n+        \/\/ Make a dummy blank lambda form.\n@@ -378,9 +378,1 @@\n-        int arity = mt.parameterCount();\n-        int result = (mt.returnType() == void.class || mt.returnType() == Void.class) ? VOID_RESULT : arity;\n-        Name[] names = buildEmptyNames(arity, mt, result == VOID_RESULT);\n-        boolean canInterpret = normalizeNames(arity, names);\n-        LambdaForm form = new LambdaForm(arity, result, DEFAULT_FORCE_INLINE, DEFAULT_CUSTOMIZED, names, Kind.ZERO);\n-        assert(form.nameRefsAreLegal() && form.isEmpty() && isValidSignature(form.basicTypeSignature()));\n-        if (!canInterpret) {\n-            form.compileToBytecode();\n-        }\n+        LambdaForm form = new LambdaForm(0, 0, DEFAULT_FORCE_INLINE, DEFAULT_CUSTOMIZED, new Name[0], Kind.GENERIC);\n@@ -390,10 +382,0 @@\n-    private static Name[] buildEmptyNames(int arity, MethodType mt, boolean isVoid) {\n-        Name[] names = arguments(isVoid ? 0 : 1, mt);\n-        if (!isVoid) {\n-            Name zero = new Name(constantZero(basicType(mt.returnType())));\n-            names[arity] = zero.withIndex(arity);\n-        }\n-        assert(namesOK(arity, names));\n-        return names;\n-    }\n-\n@@ -1014,9 +996,0 @@\n-    private boolean isEmpty() {\n-        if (result < 0)\n-            return (names.length == arity);\n-        else if (result == arity && names.length == arity + 1)\n-            return names[arity].isConstantZero();\n-        else\n-            return false;\n-    }\n-\n@@ -1254,4 +1227,0 @@\n-        public boolean isConstantZero() {\n-            return this.equals(constantZero(returnType()));\n-        }\n-\n@@ -1456,3 +1425,0 @@\n-        boolean isConstantZero() {\n-            return !isParam() && arguments.length == 0 && function.isConstantZero();\n-        }\n@@ -1665,1 +1631,1 @@\n-        createFormsFor(type);\n+        createIdentityForm(type);\n@@ -1669,10 +1635,0 @@\n-    static LambdaForm zeroForm(BasicType type) {\n-        int ord = type.ordinal();\n-        LambdaForm form = LF_zero[ord];\n-        if (form != null) {\n-            return form;\n-        }\n-        createFormsFor(type);\n-        return LF_zero[ord];\n-    }\n-\n@@ -1685,1 +1641,1 @@\n-        createFormsFor(type);\n+        createIdentityForm(type);\n@@ -1689,8 +1645,14 @@\n-    static NamedFunction constantZero(BasicType type) {\n-        int ord = type.ordinal();\n-        NamedFunction function = NF_zero[ord];\n-        if (function != null) {\n-            return function;\n-        }\n-        createFormsFor(type);\n-        return NF_zero[ord];\n+    static LambdaForm constantForm(BasicType type) {\n+        assert type != null && type != V_TYPE : type;\n+        var cached = LF_constant[type.ordinal()];\n+        if (cached != null)\n+            return cached;\n+        return createConstantForm(type);\n+    }\n+\n+    private static LambdaForm createConstantForm(BasicType type) {\n+        UNSAFE.ensureClassInitialized(BoundMethodHandle.class); \/\/ defend access to SimpleMethodHandle\n+        var species = SimpleMethodHandle.BMH_SPECIES.extendWith(type);\n+        var carrier = argument(0, L_TYPE).withConstraint(species); \/\/ BMH bound with data\n+        Name[] constNames = new Name[] { carrier, new Name(species.getterFunction(0), carrier) };\n+        return LF_constant[type.ordinal()] = create(1, constNames, Kind.CONSTANT);\n@@ -1700,1 +1662,0 @@\n-    private static final @Stable LambdaForm[] LF_zero = new LambdaForm[TYPE_LIMIT];\n@@ -1702,1 +1663,1 @@\n-    private static final @Stable NamedFunction[] NF_zero = new NamedFunction[TYPE_LIMIT];\n+    private static final @Stable LambdaForm[] LF_constant = new LambdaForm[ARG_TYPE_LIMIT]; \/\/ no void\n@@ -1704,2 +1665,2 @@\n-    private static final Object createFormsLock = new Object();\n-    private static void createFormsFor(BasicType type) {\n+    private static final Object createIdentityFormLock = new Object();\n+    private static void createIdentityForm(BasicType type) {\n@@ -1708,1 +1669,1 @@\n-        synchronized (createFormsLock) {\n+        synchronized (createIdentityFormLock) {\n@@ -1717,2 +1678,1 @@\n-            MethodType zeType = MethodType.methodType(btClass);\n-            MethodType idType = (isVoid) ? zeType : MethodType.methodType(btClass, btClass);\n+            MethodType idType = (isVoid) ? MethodType.methodType(btClass) : MethodType.methodType(btClass, btClass);\n@@ -1722,1 +1682,0 @@\n-            \/\/ Zero is built from a call to an identity function with a constant zero input.\n@@ -1724,1 +1683,0 @@\n-            MemberName zeMem = null;\n@@ -1727,4 +1685,0 @@\n-                if (!isVoid) {\n-                    zeMem = new MemberName(LambdaForm.class, \"zero_\"+btChar, zeType, REF_invokeStatic);\n-                    zeMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, zeMem, null, LM_TRUSTED, NoSuchMethodException.class);\n-                }\n@@ -1736,2 +1690,0 @@\n-            LambdaForm zeForm;\n-            NamedFunction zeFun;\n@@ -1746,3 +1698,0 @@\n-\n-                zeForm = idForm;\n-                zeFun = idFun;\n@@ -1753,1 +1702,1 @@\n-                idFun = new NamedFunction(idMem, MethodHandleImpl.makeIntrinsic(SimpleMethodHandle.make(idMem.getInvocationType(), idForm),\n+                idFun = new NamedFunction(idMem, MethodHandleImpl.makeIntrinsic(idMem.getInvocationType(), idForm,\n@@ -1755,7 +1704,0 @@\n-\n-                Object zeValue = Wrapper.forBasicType(btChar).zero();\n-                Name[] zeNames = new Name[] { argument(0, L_TYPE), new Name(idFun, zeValue) };\n-                zeForm = LambdaForm.create(1, zeNames, 1, Kind.ZERO);\n-                zeForm.compileToBytecode();\n-                zeFun = new NamedFunction(zeMem, MethodHandleImpl.makeIntrinsic(SimpleMethodHandle.make(zeMem.getInvocationType(), zeForm),\n-                        MethodHandleImpl.Intrinsic.ZERO));\n@@ -1764,2 +1706,0 @@\n-            LF_zero[ord] = zeForm;\n-            NF_zero[ord] = zeFun;\n@@ -1770,2 +1710,0 @@\n-            assert(zeFun.isConstantZero());\n-            assert(new Name(zeFun).isConstantZero());\n@@ -1782,6 +1720,0 @@\n-    private static int zero_I() { return 0; }\n-    private static long zero_J() { return 0; }\n-    private static float zero_F() { return 0; }\n-    private static double zero_D() { return 0; }\n-    private static Object zero_L() { return null; }\n-\n@@ -1817,1 +1749,1 @@\n-    \/* Placeholder class for zero and identity forms generated ahead of time *\/\n+    \/* Placeholder class for identity and constant forms generated ahead of time *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":27,"deletions":95,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -972,1 +972,1 @@\n-                callFilter = new Name(constantZero(newType));\n+                callFilter = new Name(LambdaForm.identity(newType), newType.btWrapper.zero());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1346,1 +1346,0 @@\n-        ZERO,\n@@ -2236,0 +2235,23 @@\n+    \/\/ type is validated, value is not\n+    static MethodHandle makeConstantReturning(Class<?> type, Object value) {\n+        var callType = MethodType.methodType(type);\n+        var basicType = BasicType.basicType(type);\n+        var form = constantForm(basicType);\n+\n+        if (type.isPrimitive()) {\n+            assert type != void.class;\n+            var wrapper = Wrapper.forPrimitiveType(type);\n+            var v = wrapper.convert(value, type); \/\/ throws CCE\n+            return switch (wrapper) {\n+                case INT    -> BoundMethodHandle.bindSingleI(callType, form, (int) v);\n+                case LONG   -> BoundMethodHandle.bindSingleJ(callType, form, (long) v);\n+                case FLOAT  -> BoundMethodHandle.bindSingleF(callType, form, (float) v);\n+                case DOUBLE -> BoundMethodHandle.bindSingleD(callType, form, (double) v);\n+                default -> BoundMethodHandle.bindSingleI(callType, form, ValueConversions.widenSubword(v));\n+            };\n+        }\n+\n+        var v = type.cast(value); \/\/ throws CCE\n+        return BoundMethodHandle.bindSingleL(callType, form, v);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -67,3 +68,1 @@\n-import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n-import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;\n-import static java.lang.invoke.MethodHandleStatics.newInternalError;\n+import static java.lang.invoke.MethodHandleStatics.*;\n@@ -4830,13 +4829,3 @@\n-        if (type.isPrimitive()) {\n-            if (type == void.class)\n-                throw newIllegalArgumentException(\"void type\");\n-            Wrapper w = Wrapper.forPrimitiveType(type);\n-            value = w.convert(value, type);\n-            if (w.zero().equals(value))\n-                return zero(w, type);\n-            return insertArguments(identity(type), 0, value);\n-        } else {\n-            if (value == null)\n-                return zero(Wrapper.OBJECT, type);\n-            return identity(type).bindTo(value);\n-        }\n+        if (Objects.requireNonNull(type) == void.class)\n+            throw newIllegalArgumentException(\"void type\");\n+        return MethodHandleImpl.makeConstantReturning(type, value);\n@@ -4884,1 +4873,2 @@\n-        return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);\n+        return type.isPrimitive() ? primitiveZero(Wrapper.forPrimitiveType(type))\n+                : MethodHandleImpl.makeConstantReturning(type, null);\n@@ -4903,1 +4893,1 @@\n-     * @see MethodHandles#zero\n+     * @see MethodHandles#primitiveZero\n@@ -4914,1 +4904,1 @@\n-        MethodType mtype = methodType(ptype, ptype);\n+        MethodType mtype = methodType(ptype, ptype); \/\/ throws IAE for void\n@@ -4919,5 +4909,6 @@\n-    private static MethodHandle zero(Wrapper btw, Class<?> rtype) {\n-        int pos = btw.ordinal();\n-        MethodHandle zero = ZERO_MHS[pos];\n-        if (zero == null) {\n-            zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));\n+    private static MethodHandle primitiveZero(Wrapper w) {\n+        assert w != Wrapper.OBJECT : w;\n+        int pos = w.ordinal();\n+        MethodHandle mh = PRIMITIVE_ZERO_MHS[pos];\n+        if (mh == null) {\n+            mh = setCachedMethodHandle(PRIMITIVE_ZERO_MHS, pos, makePrimitiveZero(w));\n@@ -4925,4 +4916,2 @@\n-        if (zero.type().returnType() == rtype)\n-            return zero;\n-        assert(btw == Wrapper.OBJECT);\n-        return makeZero(rtype);\n+        assert (mh.type().returnType() == w.primitiveType()) : mh;\n+        return mh;\n@@ -4930,5 +4919,8 @@\n-    private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];\n-    private static MethodHandle makeZero(Class<?> rtype) {\n-        MethodType mtype = methodType(rtype);\n-        LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));\n-        return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);\n+\n+    private static MethodHandle makePrimitiveZero(Wrapper w) {\n+        if (w == Wrapper.VOID) {\n+            var lf = LambdaForm.identityForm(V_TYPE); \/\/ ensures BMH & SimpleMH are initialized\n+            return SimpleMethodHandle.make(MethodType.methodType(void.class), lf);\n+        } else {\n+            return MethodHandleImpl.makeConstantReturning(w.primitiveType(), w.zero());\n+        }\n@@ -4937,0 +4929,2 @@\n+    private static final @Stable MethodHandle[] PRIMITIVE_ZERO_MHS = new MethodHandle[Wrapper.COUNT];\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":27,"deletions":33,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+ * Access to SimpleMethodHandle should ensure BoundMethodHandle is initialized\n+ * first.\n@@ -71,1 +73,1 @@\n-        return BoundMethodHandle.bindSingle(mt, lf, narg); \/\/ Use known fast path.\n+        return BoundMethodHandle.bindSingleL(mt, lf, narg); \/\/ Use known fast path.\n@@ -73,0 +75,1 @@\n+\n@@ -76,5 +79,1 @@\n-        try {\n-            return (BoundMethodHandle) BMH_SPECIES.extendWith(I_TYPE).factory().invokeBasic(mt, lf, narg);\n-        } catch (Throwable ex) {\n-            throw uncaughtException(ex);\n-        }\n+        return BoundMethodHandle.bindSingleI(mt, lf, narg);\n@@ -82,0 +81,1 @@\n+\n@@ -85,5 +85,1 @@\n-        try {\n-            return (BoundMethodHandle) BMH_SPECIES.extendWith(J_TYPE).factory().invokeBasic(mt, lf, narg);\n-        } catch (Throwable ex) {\n-            throw uncaughtException(ex);\n-        }\n+        return BoundMethodHandle.bindSingleJ(mt, lf, narg);\n@@ -91,0 +87,1 @@\n+\n@@ -94,5 +91,1 @@\n-        try {\n-            return (BoundMethodHandle) BMH_SPECIES.extendWith(F_TYPE).factory().invokeBasic(mt, lf, narg);\n-        } catch (Throwable ex) {\n-            throw uncaughtException(ex);\n-        }\n+        return BoundMethodHandle.bindSingleF(mt, lf, narg);\n@@ -100,0 +93,1 @@\n+\n@@ -103,5 +97,1 @@\n-        try {\n-            return (BoundMethodHandle) BMH_SPECIES.extendWith(D_TYPE).factory().invokeBasic(mt, lf, narg);\n-        } catch (Throwable ex) {\n-            throw uncaughtException(ex);\n-        }\n+        return BoundMethodHandle.bindSingleD(mt, lf, narg);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/SimpleMethodHandle.java","additions":12,"deletions":22,"binary":false,"changes":34,"status":"modified"}]}