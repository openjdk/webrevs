{"files":[{"patch":"@@ -1142,1 +1142,3 @@\n-            NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-        } catch  (GeneralSecurityException gse) {\n+        } catch (GeneralSecurityException gse) {\n@@ -307,1 +307,1 @@\n-        public byte[] produce(ConnectionContext context) {\n+        public byte[] produce(ConnectionContext context) throws IOException {\n@@ -369,1 +369,1 @@\n-                            \"session timeout\");\n+                            \"session timeout is too long\");\n@@ -375,6 +375,11 @@\n-            SecretKey resumptionMasterSecret =\n-                hc.handshakeSession.getResumptionMasterSecret();\n-            if (resumptionMasterSecret == null) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\"No session ticket produced: \" +\n-                        \"no resumption secret\");\n+            \/\/ Send NewSessionTickets to the client based\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                int i = 0;\n+                NewSessionTicketMessage nstm;\n+                while (i < SSLConfiguration.serverNewSessionTicketCount) {\n+                    nstm = generateNST(hc, sessionCache);\n+                    if (nstm == null) {\n+                        break;\n+                    }\n+                    nstm.write(hc.handshakeOutput);\n+                    i++;\n@@ -383,1 +388,1 @@\n-                return null;\n+                hc.handshakeOutput.flush();\n@@ -385,1 +390,0 @@\n-\n@@ -387,9 +391,15 @@\n-             * This thread addresses a Windows only networking issue found with\n-             * SSLSocketBruteForceClose. A client that quickly closes after\n-             * TLS Finished completed would cause the server read-side to\n-             * get a SocketException: \"An established connection was aborted\n-             * by the software in your host machine\", which relates to WinSock\n-             * error WSAECONNABORTED.  This situation was observed with\n-             * multiple NST messages when the client and server threads on the\n-             * same machine.  This is very unlikely to be seen where client\n-             * and server are on different machines.\n+             * With large NST counts, a client that quickly closes after\n+             * TLS Finished completes can cause SocketExceptions such as:\n+             * Windows servers read-side throwing SocketException:\n+             *   \"An established connection was aborted by the software in\n+             *    your host machine\", which relates to error WSAECONNABORTED.\n+             * A SocketException caused by a \"broken pipe\" has been observed on\n+             * other systems.\n+             * These are very unlikely situations when client and server are on\n+             * different machines.\n+             *\n+             * RFC 8446 does not put requirements when an NST needs to be\n+             * sent, but it should be sent very soon after TLS Finished for\n+             * clients that will quickly resume to create more sessions.\n+             * TLS 1.3 is different from TLS 1.2, there is more data the client\n+             * should be aware of\n@@ -397,25 +407,0 @@\n-            Thread nstThread = Thread.ofVirtual().name(\"NST\").start(() -> {\n-                \/\/ Output the handshake message.\n-                try {\n-                    int i = 0;\n-                    while (i < SSLConfiguration.serverNewSessionTicketCount) {\n-                        SessionId newId = new SessionId(true,\n-                            hc.sslContext.getSecureRandom());\n-                        NewSessionTicketMessage nstm = generateNST(hc,\n-                            sessionTimeoutSeconds, newId, sessionCache);\n-                        if (nstm != null) {\n-                            \/\/ should never be null\n-                            nstm.write(hc.handshakeOutput);\n-                        }\n-                        i++;\n-                    }\n-                    hc.handshakeOutput.flush();\n-                } catch (IOException e) {\n-                    \/\/ Low exception likelihood this is data requires not\n-                    \/\/ reply an IO errors will be handled by other messages.\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.fine(\"NST thread exception:\");\n-                        e.printStackTrace();\n-                    }\n-                }\n-            });\n@@ -433,9 +418,0 @@\n-            \/\/ Rejoin NST thread\n-            try {\n-                nstThread.join(1000);\n-            } catch (InterruptedException e) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\"NST thread interrupted: \");\n-                    e.printStackTrace();\n-                }\n-            }\n@@ -450,1 +426,0 @@\n-            int sessionTimeoutSeconds, SessionId newId,\n@@ -452,0 +427,1 @@\n+\n@@ -453,0 +429,2 @@\n+            SessionId newId = new SessionId(true,\n+                hc.sslContext.getSecureRandom());\n@@ -455,5 +433,1 @@\n-            byte[] nonceArr = hc.handshakeSession.incrTicketNonceCounter().\n-                toByteArray();\n-            SecretKey psk = derivePreSharedKey(\n-                hc.negotiatedCipherSuite.hashAlg,\n-                hc.handshakeSession.getResumptionMasterSecret(), nonceArr);\n+            byte[] nonce = hc.handshakeSession.incrTicketNonceCounter();\n@@ -463,1 +437,3 @@\n-            sessionCopy.setPreSharedKey(psk);\n+            sessionCopy.setPreSharedKey(derivePreSharedKey(\n+                hc.negotiatedCipherSuite.hashAlg,\n+                hc.handshakeSession.getResumptionMasterSecret(), nonce));\n@@ -470,1 +446,1 @@\n-                        sessionTimeoutSeconds,\n+                        sessionCache.getSessionTimeout(),\n@@ -472,1 +448,1 @@\n-                        nonceArr,\n+                        nonce,\n@@ -489,3 +465,4 @@\n-                nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,\n-                        hc.sslContext.getSecureRandom(), nonceArr,\n-                        newId.getId());\n+                nstm = new T13NewSessionTicketMessage(hc,\n+                    sessionCache.getSessionTimeout(),\n+                    hc.sslContext.getSecureRandom(), nonce,\n+                    newId.getId());\n@@ -494,1 +471,1 @@\n-                            \"post-handshake message\", nstm);\n+                        \"post-handshake message\", nstm);\n@@ -506,0 +483,4 @@\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"No NewSessionTicket created\");\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":48,"deletions":67,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    \/\/ Number of NewSessionTickets (NST) that will be sent by the server.\n+    \/\/ Number of NewSessionTickets that will be sent by the server.\n@@ -126,2 +126,2 @@\n-    \/\/ Default for NST\n-    static final int SERVER_NST_DEFAULT = 3;\n+    \/\/ Default for NewSessionTickets\n+    static final int SERVER_NST_DEFAULT = 1;\n@@ -200,0 +200,6 @@\n+        \/*\n+         * jdk.tls.server.newSessionTicketCount system property\n+         * Sets the number of NewSessionTickets sent to a TLS 1.3 resumption\n+         * client.  The value must be between 0 and 10.  Default is defined by\n+         * SERVER_NST_DEFAULT.\n+         *\/\n@@ -202,1 +208,1 @@\n-        if (nstServerCount == null || nstServerCount < 1 ||\n+        if (nstServerCount == null || nstServerCount < 0 ||\n@@ -209,1 +215,1 @@\n-                        \"the property was not between 1 and 10\");\n+                        \"the property was not between 0 and 10\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -419,5 +419,6 @@\n-        if ((conContext.handshakeContext == null) &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            conContext.handshakeContext == null &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    private static final int DEFAULT_MAX_QUEUE_SIZE = 10;\n@@ -99,1 +100,2 @@\n-            sessionHostPortCache = Cache.newSoftMemoryQueue(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryQueue(cacheLimit, timeout,\n+                DEFAULT_MAX_QUEUE_SIZE);\n@@ -281,10 +283,2 @@\n-    void put(SSLSessionImpl s, boolean flag) {\n-        sessionCache.put(s.getSessionId(), s);\n-\n-        \/\/ If no hostname\/port info is available, don't add this one.\n-        if ((s.getPeerHost() != null) && (s.getPeerPort() != -1)) {\n-            sessionHostPortCache.put(\n-                getKey(s.getPeerHost(), s.getPeerPort()), s, flag);\n-        }\n-\n-        s.setContext(this);\n+    void put(SSLSessionImpl s) {\n+        put(s, false);\n@@ -293,1 +287,7 @@\n-    void put(SSLSessionImpl s) {\n+    \/**\n+     * Put an entry in the cache\n+     * @param s SSLSessionImpl entry to be stored\n+     * @param canQueue True if multiple entries may exist under one\n+     *                 session entry.\n+     *\/\n+    void put(SSLSessionImpl s, boolean canQueue) {\n@@ -299,1 +299,1 @@\n-                getKey(s.getPeerHost(), s.getPeerPort()), s);\n+                getKey(s.getPeerHost(), s.getPeerPort()), s, canQueue);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-final public class SSLSessionImpl extends ExtendedSSLSession {\n+final class SSLSessionImpl extends ExtendedSSLSession {\n@@ -134,1 +134,5 @@\n-    private BigInteger ticketNonceCounter = BigInteger.ONE;\n+    private byte ticketNonceCounter = 1;\n+\n+    \/\/ This boolean is true when a new set of NewSessionTickets are needed after\n+    \/\/ the initial ones sent after the handshake.\n+    boolean updateNST = false;\n@@ -722,9 +726,2 @@\n-    BigInteger incrTicketNonceCounter() {\n-        sessionLock.lock();\n-        try {\n-            BigInteger result = ticketNonceCounter;\n-            ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);\n-            return result;\n-        } finally {\n-            sessionLock.unlock();\n-        }\n+    byte[] incrTicketNonceCounter() {\n+        return new byte[] {ticketNonceCounter++};\n@@ -734,1 +731,1 @@\n-        return (ticketNonceCounter.compareTo(BigInteger.ZERO) > 0);\n+        return (ticketNonceCounter > 0);\n@@ -1246,1 +1243,0 @@\n-    boolean updateNST;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1324,1 +1324,0 @@\n-                conContext.conSession.updateNST = false;\n@@ -1559,6 +1558,7 @@\n-        if (!conContext.sslConfig.isClientMode &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                conContext.handshakeContext == null &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            !conContext.sslConfig.isClientMode &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            conContext.handshakeContext == null &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n@@ -1568,0 +1568,1 @@\n+            conContext.conSession.updateNST = false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -140,1 +139,1 @@\n-        return new MemoryCache<>(CacheType.SOFT, size);\n+        return new MemoryCache<>(true, size);\n@@ -149,1 +148,1 @@\n-        return new MemoryCache<>(CacheType.SOFT, size, timeout);\n+        return new MemoryCache<>(true, size, timeout);\n@@ -152,2 +151,3 @@\n-    public static <K,V> Cache<K,V> newSoftMemoryQueue(int size, int timeout) {\n-        return new MemoryCache<>(CacheType.CACHE, size, timeout);\n+    public static <K,V> Cache<K,V> newSoftMemoryQueue(int size, int timeout,\n+        int maxQueueSize) {\n+        return new MemoryCache<>(true, size, timeout, maxQueueSize);\n@@ -161,1 +161,1 @@\n-        return new MemoryCache<>(CacheType.HARD, size);\n+        return new MemoryCache<>(false, size);\n@@ -178,1 +178,1 @@\n-        return new MemoryCache<>(CacheType.HARD, size, timeout);\n+        return new MemoryCache<>(false, size, timeout);\n@@ -265,6 +265,0 @@\n-\/**\n- * There are three types of cache.  SoftCacheEntry, HardCacheEntry, and\n- * QueueCacheEntry.  This enum is used to identify the cache's configuration.\n- *\/\n-enum CacheType { SOFT, HARD, CACHE }\n-\n@@ -278,0 +272,1 @@\n+    final private int maxQueueSize;\n@@ -280,1 +275,0 @@\n-    private final CacheType cacheType;\n@@ -286,2 +280,2 @@\n-    public MemoryCache(CacheType type, int maxSize) {\n-        this(type, maxSize, 0);\n+    public MemoryCache(boolean soft, int maxSize) {\n+        this(soft, maxSize, 0, 0);\n@@ -290,1 +284,5 @@\n-    public MemoryCache(CacheType type, int maxSize, int lifetime) {\n+    public MemoryCache(boolean soft, int maxSize, int lifetime) {\n+        this(soft, maxSize, lifetime, 0);\n+    }\n+\n+    public MemoryCache(boolean soft, int maxSize, int lifetime, int qSize) {\n@@ -292,0 +290,1 @@\n+        this.maxQueueSize = qSize;\n@@ -293,4 +292,1 @@\n-        cacheType = type;\n-        if (cacheType == CacheType.HARD) {\n-            this.queue = null;\n-        } else {\n+        if (soft) {\n@@ -298,0 +294,2 @@\n+        } else {\n+            this.queue = null;\n@@ -299,2 +297,3 @@\n-\n-        cacheMap = new ConcurrentHashMap<>();\n+        \/\/ LinkedHashMap is needed for its access order.  0.75f load factor is\n+        \/\/ default.\n+        cacheMap = new LinkedHashMap<>(1, 0.75f, true);\n@@ -310,1 +309,0 @@\n-\n@@ -318,1 +316,1 @@\n-            CacheEntry<K, V> entry = (CacheEntry<K, V>) queue.poll();\n+            CacheEntry<K,V> entry = (CacheEntry<K,V>)queue.poll();\n@@ -327,2 +325,1 @@\n-\n-            CacheEntry<K, V> currentEntry = cacheMap.remove(key);\n+            CacheEntry<K,V> currentEntry = cacheMap.remove(key);\n@@ -335,1 +332,0 @@\n-\n@@ -340,1 +336,0 @@\n-\n@@ -353,1 +348,0 @@\n-\n@@ -395,1 +389,3 @@\n-            while (queue.poll() != null);\n+            while (queue.poll() != null) {\n+                \/\/ empty\n+            }\n@@ -407,1 +403,1 @@\n-     * If useQueue is true, V will be added using a QueueCacheEntry which\n+     * If canQueue is true, V will be added using a QueueCacheEntry which\n@@ -409,0 +405,2 @@\n+     * The caller must keep a consistent canQueue value, mixing them can\n+     * result in a queue being replaced with a single entry.\n@@ -424,1 +422,0 @@\n-\n@@ -426,3 +423,5 @@\n-        if (cacheType != CacheType.CACHE) {\n-            \/\/ No matter canQueue's value, enter the value directly\n-            cacheMap.put(key, newEntry);\n+        if (maxQueueSize == 0) {\n+            CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n+            if (oldEntry != null) {\n+                oldEntry.invalidate();\n+            }\n@@ -435,0 +434,2 @@\n+                    \/\/ If `canQueue` create a queue and put in entry.  If\n+                    \/\/ canQueue == false, replace or put this CacheEntry only.\n@@ -437,1 +438,1 @@\n-                            expirationTime, queue);\n+                            expirationTime, maxQueueSize, queue);\n@@ -452,1 +453,0 @@\n-\n@@ -475,1 +475,1 @@\n-            cacheMap.remove(key);\n+            removeImpl(key);\n@@ -481,1 +481,0 @@\n-\n@@ -486,1 +485,1 @@\n-                cacheMap.remove(key);\n+                removeImpl(key);\n@@ -490,1 +489,0 @@\n-\n@@ -496,0 +494,5 @@\n+        removeImpl(key);\n+    }\n+\n+    \/\/ removeImpl is thread-safe entry removal from the cacheMap.\n+    private synchronized void removeImpl(Object key) {\n@@ -501,2 +504,1 @@\n-\n-    public V pull(Object key) {\n+    public synchronized V pull(Object key) {\n@@ -683,1 +685,1 @@\n-        private static final int MAXQUEUESIZE = 10;\n+        private final int MAXQUEUESIZE;\n@@ -690,1 +692,1 @@\n-        QueueCacheEntry(K key, V value, long expirationTime,\n+        QueueCacheEntry(K key, V value, long expirationTime, int maxSize,\n@@ -695,0 +697,1 @@\n+            this.MAXQUEUESIZE = maxSize;\n@@ -707,1 +710,0 @@\n-\n@@ -714,1 +716,2 @@\n-                    return entry.getValue();\n+                    \/\/ SoftReference get() returns the same as entry.getValue()\n+                    return get();\n@@ -736,1 +739,1 @@\n-            \/\/ the get() will remove expired tickets\n+            \/\/ The getValue() calls will remove expired tickets.\n@@ -738,4 +741,2 @@\n-            \/\/ Limit the number of queue entries, removing the oldest.  As this\n-            \/\/ is a one for one entry swap, locking isn't necessary and plus or\n-            \/\/ minus a few entries is not critical.\n-            if (queue.size() > MAXQUEUESIZE) {\n+            \/\/ Limit the number of queue entries, removing the oldest.\n+            if (queue.size() >= MAXQUEUESIZE) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":54,"deletions":53,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+ * @summary Verifies multiple session tickets are PSKs are used by JSSE\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=1\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=3\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=10\n@@ -34,1 +38,0 @@\n- * @summary Verifies multiple session tickets are PSKs are used by JSSE\n@@ -37,1 +40,0 @@\n-\n@@ -43,0 +45,1 @@\n+import java.util.Arrays;\n@@ -59,1 +62,6 @@\n-            String params = args[0] + \" \" + args[1] + \" \" + args[2];\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> {\n+                sb.append(a);\n+                sb.append(\" \");\n+            });\n+            String params = sb.toString();\n@@ -79,4 +87,7 @@\n-                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").asLines().stream().filter(s -> s.contains(\"MultiNST PSK\")).toList();\n-                List<String> serverPSK = list.stream().filter(s -> s.contains(\"MultiNST PSK (Server)\")).toList();\n-                List<String> clientPSK = list.stream().filter(s -> s.contains(\"MultiNST PSK (Client)\")).toList();\n-                \/\/System.err.println(\"found server: \" + serverPSK.size() + \" \" + serverPSK);\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n@@ -86,1 +97,0 @@\n-                \/\/System.err.println(\"found client: \" + clientPSK.size() + \" \" + clientPSK);\n@@ -154,0 +164,1 @@\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"}]}