{"files":[{"patch":"@@ -1142,1 +1142,3 @@\n-            NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.math.BigInteger;\n@@ -33,0 +32,1 @@\n+import java.util.Arrays;\n@@ -121,5 +121,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -224,5 +219,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -304,1 +294,1 @@\n-        } catch  (GeneralSecurityException gse) {\n+        } catch (GeneralSecurityException gse) {\n@@ -335,2 +325,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -354,2 +343,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -366,2 +354,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -378,6 +365,2 @@\n-            SessionId newId = new SessionId(true,\n-                hc.sslContext.getSecureRandom());\n-\n-            SecretKey resumptionMasterSecret =\n-                hc.handshakeSession.getResumptionMasterSecret();\n-            if (resumptionMasterSecret == null) {\n+            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n+            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n@@ -385,3 +368,2 @@\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"no resumption secret\");\n+                    SSLLogger.fine(\"No session ticket produced: \" +\n+                            \"session timeout is too long\");\n@@ -393,13 +375,11 @@\n-            \/\/ construct the PSK and handshake message\n-            BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();\n-            byte[] nonceArr = nonce.toByteArray();\n-            SecretKey psk = derivePreSharedKey(\n-                    hc.negotiatedCipherSuite.hashAlg,\n-                    resumptionMasterSecret, nonceArr);\n-\n-            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n-            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"session timeout\");\n+            \/\/ Send NewSessionTickets to the client based\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                int i = 0;\n+                NewSessionTicketMessage nstm;\n+                while (i < SSLConfiguration.serverNewSessionTicketCount) {\n+                    nstm = generateNST(hc, sessionCache);\n+                    if (nstm == null) {\n+                        break;\n+                    }\n+                    nstm.write(hc.handshakeOutput);\n+                    i++;\n@@ -408,1 +388,1 @@\n-                return null;\n+                hc.handshakeOutput.flush();\n@@ -410,0 +390,17 @@\n+            \/*\n+             * With large NST counts, a client that quickly closes after\n+             * TLS Finished completes can cause SocketExceptions such as:\n+             * Windows servers read-side throwing SocketException:\n+             *   \"An established connection was aborted by the software in\n+             *    your host machine\", which relates to error WSAECONNABORTED.\n+             * A SocketException caused by a \"broken pipe\" has been observed on\n+             * other systems.\n+             * These are very unlikely situations when client and server are on\n+             * different machines.\n+             *\n+             * RFC 8446 does not put requirements when an NST needs to be\n+             * sent, but it should be sent very soon after TLS Finished for\n+             * clients that will quickly resume to create more sessions.\n+             * TLS 1.3 is different from TLS 1.2, there is more data the client\n+             * should be aware of\n+             *\/\n@@ -411,1 +408,26 @@\n-            NewSessionTicketMessage nstm = null;\n+            \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n+            \/\/\n+            \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n+            \/\/ of this post-handshake message will indicate the FINISHED\n+            \/\/ handshake status.  It is not needed to have a follow-on\n+            \/\/ SSLEngine.wrap() any longer.\n+            if (hc.conContext.needHandshakeFinishedStatus) {\n+                hc.conContext.needHandshakeFinishedStatus = false;\n+            }\n+\n+            \/\/ clean the post handshake context\n+            hc.conContext.finishPostHandshake();\n+\n+            \/\/ The message has been delivered.\n+            return null;\n+        }\n+\n+        private NewSessionTicketMessage generateNST(HandshakeContext hc,\n+            SSLSessionContextImpl sessionCache) throws IOException {\n+\n+            NewSessionTicketMessage nstm;\n+            SessionId newId = new SessionId(true,\n+                hc.sslContext.getSecureRandom());\n+\n+            \/\/ construct the PSK and handshake message\n+            byte[] nonce = hc.handshakeSession.incrTicketNonceCounter();\n@@ -414,2 +436,4 @@\n-                    new SSLSessionImpl(hc.handshakeSession, newId);\n-            sessionCopy.setPreSharedKey(psk);\n+                new SSLSessionImpl(hc.handshakeSession, newId);\n+            sessionCopy.setPreSharedKey(derivePreSharedKey(\n+                hc.negotiatedCipherSuite.hashAlg,\n+                hc.handshakeSession.getResumptionMasterSecret(), nonce));\n@@ -422,1 +446,1 @@\n-                        sessionTimeoutSeconds,\n+                        sessionCache.getSessionTimeout(),\n@@ -424,1 +448,1 @@\n-                        nonceArr,\n+                        nonce,\n@@ -431,2 +455,1 @@\n-                        SSLLogger.fine(\n-                            \"Produced NewSessionTicket stateless \" +\n+                        SSLLogger.fine(\"Produced NewSessionTicket stateless \" +\n@@ -436,0 +459,1 @@\n+                return nstm;\n@@ -441,3 +465,4 @@\n-                nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,\n-                        hc.sslContext.getSecureRandom(), nonceArr,\n-                        newId.getId());\n+                nstm = new T13NewSessionTicketMessage(hc,\n+                    sessionCache.getSessionTimeout(),\n+                    hc.sslContext.getSecureRandom(), nonce,\n+                    newId.getId());\n@@ -445,3 +470,2 @@\n-                    SSLLogger.fine(\n-                            \"Produced NewSessionTicket post-handshake message\",\n-                            nstm);\n+                    SSLLogger.fine(\"Produced NewSessionTicket \" +\n+                        \"post-handshake message\", nstm);\n@@ -456,0 +480,1 @@\n+                return nstm;\n@@ -458,15 +483,2 @@\n-            \/\/ Output the handshake message.\n-            if (nstm != null) {\n-                \/\/ should never be null\n-                nstm.write(hc.handshakeOutput);\n-                hc.handshakeOutput.flush();\n-\n-                \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n-                \/\/\n-                \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n-                \/\/ of this post-handshake message will indicate the FINISHED\n-                \/\/ handshake status.  It is not needed to have a follow-on\n-                \/\/ SSLEngine.wrap() any longer.\n-                if (hc.conContext.needHandshakeFinishedStatus) {\n-                    hc.conContext.needHandshakeFinishedStatus = false;\n-                }\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"No NewSessionTicket created\");\n@@ -475,4 +487,0 @@\n-            \/\/ clean the post handshake context\n-            hc.conContext.finishPostHandshake();\n-\n-            \/\/ The message has been delivered.\n@@ -483,1 +491,1 @@\n-    \/**\n+        \/**\n@@ -581,1 +589,0 @@\n-                sessionCache.remove(hc.handshakeSession.getSessionId());\n@@ -622,1 +629,6 @@\n-            sessionCache.put(sessionCopy);\n+            sessionCache.put(sessionCopy, sessionCopy.isPSK());\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"MultiNST PSK (Server): \" +\n+                    Utilities.toHexString(Arrays.copyOf(nstm.ticket, 16)));\n+            }\n@@ -677,2 +689,1 @@\n-                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" +\n-                        nstm.toString());\n+                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" + nstm);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":90,"deletions":79,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -707,0 +707,2 @@\n+                SSLLogger.fine(\n+                    \"MultiNST PSK (Client): \" + Utilities.toHexString(Arrays.copyOf(chc.pskIdentity, 16)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,5 @@\n+    \/\/ Number of NewSessionTickets that will be sent by the server.\n+    static final int serverNewSessionTicketCount;\n+    \/\/ Default for NewSessionTickets\n+    static final int SERVER_NST_DEFAULT = 1;\n+\n@@ -185,1 +190,1 @@\n-                \"jdk.tls.client.maxInboundCertificateChainLength\");\n+            \"jdk.tls.client.maxInboundCertificateChainLength\");\n@@ -194,0 +199,26 @@\n+\n+        \/*\n+         * jdk.tls.server.newSessionTicketCount system property\n+         * Sets the number of NewSessionTickets sent to a TLS 1.3 resumption\n+         * client.  The value must be between 0 and 10.  Default is defined by\n+         * SERVER_NST_DEFAULT.\n+         *\/\n+        Integer nstServerCount = GetIntegerAction.privilegedGetProperty(\n+            \"jdk.tls.server.newSessionTicketCount\");\n+        if (nstServerCount == null || nstServerCount < 0 ||\n+            nstServerCount > 10) {\n+            serverNewSessionTicketCount = SERVER_NST_DEFAULT;\n+            if (nstServerCount != null && SSLLogger.isOn &&\n+                SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount defaults to 3 as \" +\n+                        \"the property was not between 0 and 10\");\n+            }\n+        } else {\n+            serverNewSessionTicketCount = nstServerCount;\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount set to \" +\n+                        serverNewSessionTicketCount);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -419,5 +419,6 @@\n-        if ((conContext.handshakeContext == null) &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            conContext.handshakeContext == null &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    private static final int DEFAULT_MAX_QUEUE_SIZE = 10;\n@@ -90,2 +91,0 @@\n-        sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n-        sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -93,0 +92,2 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -95,1 +96,1 @@\n-            \/\/ but doesn't necessarily has to be a true random number.\n+            \/\/ but doesn't necessarily have to be a true random number.\n@@ -98,0 +99,3 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryQueue(cacheLimit, timeout,\n+                DEFAULT_MAX_QUEUE_SIZE);\n@@ -280,0 +284,10 @@\n+        put(s, false);\n+    }\n+\n+    \/**\n+     * Put an entry in the cache\n+     * @param s SSLSessionImpl entry to be stored\n+     * @param canQueue True if multiple entries may exist under one\n+     *                 session entry.\n+     *\/\n+    void put(SSLSessionImpl s, boolean canQueue) {\n@@ -285,1 +299,1 @@\n-                getKey(s.getPeerHost(), s.getPeerPort()), s);\n+                getKey(s.getPeerHost(), s.getPeerPort()), s, canQueue);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.util.Enumeration;\n@@ -135,1 +134,5 @@\n-    private BigInteger ticketNonceCounter = BigInteger.ONE;\n+    private byte ticketNonceCounter = 1;\n+\n+    \/\/ This boolean is true when a new set of NewSessionTickets are needed after\n+    \/\/ the initial ones sent after the handshake.\n+    boolean updateNST = false;\n@@ -495,1 +498,1 @@\n-                buf.get(b, 0 , i);\n+                buf.get(b, 0, i);\n@@ -504,2 +507,7 @@\n-                this.pskIdentity = new byte[buf.get()];\n-                buf.get(pskIdentity);\n+                i = buf.get();\n+                if (i > 0) {\n+                    this.pskIdentity = new byte[buf.get()];\n+                    buf.get(pskIdentity);\n+                } else {\n+                    this.pskIdentity = null;\n+                }\n@@ -718,4 +726,2 @@\n-    BigInteger incrTicketNonceCounter() {\n-        BigInteger result = ticketNonceCounter;\n-        ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);\n-        return result;\n+    byte[] incrTicketNonceCounter() {\n+        return new byte[] {ticketNonceCounter++};\n@@ -725,1 +731,1 @@\n-        return (ticketNonceCounter.compareTo(BigInteger.ZERO) > 0);\n+        return (ticketNonceCounter > 0);\n@@ -784,0 +790,4 @@\n+    public boolean isPSK() {\n+        return (pskIdentity != null && pskIdentity.length > 0);\n+    }\n+\n@@ -1233,1 +1243,0 @@\n-    boolean updateNST;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1324,1 +1324,0 @@\n-                conContext.conSession.updateNST = false;\n@@ -1559,6 +1558,7 @@\n-        if (!conContext.sslConfig.isClientMode &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                conContext.handshakeContext == null &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            !conContext.sslConfig.isClientMode &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            conContext.handshakeContext == null &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n@@ -1568,0 +1568,1 @@\n+            conContext.conSession.updateNST = false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n@@ -29,1 +31,1 @@\n-import java.lang.ref.*;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -93,0 +95,9 @@\n+    \/**\n+     * Add V to the cache with the option to use a QueueCacheEntry if the\n+     * cache is configured for it.  If the cache is not configured for a queue,\n+     * V will silently add the entry directly.\n+     *\/\n+    public void put(K key, V value, boolean canQueue) {\n+        put(key, value);\n+    }\n+\n@@ -140,0 +151,5 @@\n+    public static <K,V> Cache<K,V> newSoftMemoryQueue(int size, int timeout,\n+        int maxQueueSize) {\n+        return new MemoryCache<>(true, size, timeout, maxQueueSize);\n+    }\n+\n@@ -251,3 +267,1 @@\n-    private static final float LOAD_FACTOR = 0.75f;\n-\n-    \/\/ XXXX\n+    \/\/ Debugging\n@@ -258,0 +272,1 @@\n+    final private int maxQueueSize;\n@@ -266,1 +281,1 @@\n-        this(soft, maxSize, 0);\n+        this(soft, maxSize, 0, 0);\n@@ -270,0 +285,4 @@\n+        this(soft, maxSize, lifetime, 0);\n+    }\n+\n+    public MemoryCache(boolean soft, int maxSize, int lifetime, int qSize) {\n@@ -271,0 +290,1 @@\n+        this.maxQueueSize = qSize;\n@@ -272,1 +292,1 @@\n-        if (soft)\n+        if (soft) {\n@@ -274,1 +294,1 @@\n-        else\n+        } else {\n@@ -276,2 +296,4 @@\n-\n-        cacheMap = new LinkedHashMap<>(1, LOAD_FACTOR, true);\n+        }\n+        \/\/ LinkedHashMap is needed for its access order.  0.75f load factor is\n+        \/\/ default.\n+        cacheMap = new LinkedHashMap<>(1, 0.75f, true);\n@@ -308,0 +330,4 @@\n+                continue;\n+            }\n+            if (currentEntry instanceof QueueCacheEntry<K,V> qe) {\n+                qe.clear();\n@@ -370,1 +396,20 @@\n-    public synchronized void put(K key, V value) {\n+    public void put(K key, V value) {\n+        put(key, value, false);\n+    }\n+\n+    \/**\n+     * This puts an entry into the cacheMap.\n+     *\n+     * If canQueue is true, V will be added using a QueueCacheEntry which\n+     * is added to cacheMap.  If false, V is added to the cacheMap directly.\n+     * The caller must keep a consistent canQueue value, mixing them can\n+     * result in a queue being replaced with a single entry.\n+     *\n+     * This method is synchronized to avoid multiple QueueCacheEntry\n+     * overwriting the same key.\n+     *\n+     * @param key key to the cacheMap\n+     * @param value value to be stored\n+     * @param canQueue can the value be put into a QueueCacheEntry\n+     *\/\n+    public synchronized void put(K key, V value, boolean canQueue) {\n@@ -372,2 +417,2 @@\n-        long expirationTime = (lifetime == 0) ? 0 :\n-                                        System.currentTimeMillis() + lifetime;\n+        long expirationTime =\n+            (lifetime == 0) ? 0 : System.currentTimeMillis() + lifetime;\n@@ -378,4 +423,29 @@\n-        CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n-        if (oldEntry != null) {\n-            oldEntry.invalidate();\n-            return;\n+        if (maxQueueSize == 0) {\n+            CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n+            if (oldEntry != null) {\n+                oldEntry.invalidate();\n+            }\n+        } else {\n+            CacheEntry<K, V> entry = cacheMap.get(key);\n+            switch (entry) {\n+                case QueueCacheEntry<K, V> qe -> qe.putValue(newEntry);\n+                case null,\n+                    default -> {\n+                    \/\/ If `canQueue` create a queue and put in entry.  If\n+                    \/\/ canQueue == false, replace or put this CacheEntry only.\n+                    if (canQueue) {\n+                        var q = new QueueCacheEntry<>(key, value,\n+                            expirationTime, maxQueueSize, queue);\n+                        q.putValue(newEntry);\n+                        cacheMap.put(key, q);\n+                    } else {\n+                        cacheMap.put(key, newEntry);\n+                    }\n+                }\n+            }\n+\n+            if (DEBUG) {\n+                System.out.println(\"Cache entry added: key=\" +\n+                    key.toString() + \", class=\" +\n+                    (entry != null ? entry.getClass().getName() : null));\n+            }\n@@ -398,1 +468,1 @@\n-    public synchronized V get(Object key) {\n+    public V get(Object key) {\n@@ -404,2 +474,2 @@\n-        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n-        if (!entry.isValid(time)) {\n+        if (lifetime > 0 && !entry.isValid(System.currentTimeMillis())) {\n+            removeImpl(key);\n@@ -409,1 +479,0 @@\n-            cacheMap.remove(key);\n@@ -412,0 +481,8 @@\n+        \/\/ If the value is a queue, return a queue entry.\n+        if (entry instanceof QueueCacheEntry<K,V> qe) {\n+            V result = qe.getValue(lifetime);\n+            if (qe.isEmpty()) {\n+                removeImpl(key);\n+            }\n+            return result;\n+        }\n@@ -415,1 +492,1 @@\n-    public synchronized void remove(Object key) {\n+    public void remove(Object key) {\n@@ -417,0 +494,5 @@\n+        removeImpl(key);\n+    }\n+\n+    \/\/ removeImpl is thread-safe entry removal from the cacheMap.\n+    private synchronized void removeImpl(Object key) {\n@@ -422,1 +504,0 @@\n-\n@@ -553,3 +634,2 @@\n-    private static class SoftCacheEntry<K,V>\n-            extends SoftReference<V>\n-            implements CacheEntry<K,V> {\n+    private static class SoftCacheEntry<K,V> extends SoftReference<V>\n+        implements CacheEntry<K,V> {\n@@ -594,1 +674,106 @@\n-}\n+    \/**\n+     * This CacheEntry<K,V> type allows multiple V entries to be stored in\n+     * one key in the cacheMap.\n+     *\n+     * This implementation is need for TLS clients that receive multiple\n+     * PSKs or NewSessionTickets for server resumption.\n+     *\/\n+    private static class QueueCacheEntry<K,V> extends SoftReference<V>\n+        implements CacheEntry<K,V> {\n+\n+        \/\/ Limit the number of queue entries.\n+        private final int MAXQUEUESIZE;\n+\n+        final boolean DEBUG = false;\n+        private K key;\n+        private long expirationTime;\n+        final Queue<CacheEntry<K,V>> queue = new ConcurrentLinkedQueue<>();\n+\n+        QueueCacheEntry(K key, V value, long expirationTime, int maxSize,\n+            ReferenceQueue<V> queue) {\n+            super(value, queue);\n+            this.key = key;\n+            this.expirationTime = expirationTime;\n+            this.MAXQUEUESIZE = maxSize;\n+        }\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return getValue(0);\n+        }\n+\n+        public V getValue(long lifetime) {\n+            long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n+            do {\n+                var entry = queue.poll();\n+                if (entry == null) {\n+                    return null;\n+                }\n+                if (entry.isValid(time)) {\n+                    \/\/ SoftReference get() returns the same as entry.getValue()\n+                    return get();\n+                }\n+                entry.invalidate();\n+            } while (!queue.isEmpty());\n+\n+            return null;\n+        }\n+\n+        public long getExpirationTime() {\n+            return expirationTime;\n+        }\n+\n+        public void setExpirationTime(long time) {\n+            expirationTime = time;\n+        }\n+\n+        public void putValue(CacheEntry<K,V> entry) {\n+            if (DEBUG) {\n+                System.out.println(\"Added to queue (size=\" + queue.size() +\n+                    \"): \" + entry.getKey().toString() + \",  \" + entry);\n+            }\n+            \/\/ Update the cache entry's expiration time to the latest entry.\n+            \/\/ The getValue() calls will remove expired tickets.\n+            expirationTime = entry.getExpirationTime();\n+            \/\/ Limit the number of queue entries, removing the oldest.\n+            if (queue.size() >= MAXQUEUESIZE) {\n+                queue.remove();\n+            }\n+            queue.add(entry);\n+        }\n+\n+        public boolean isValid(long currentTime) {\n+            boolean valid = (currentTime <= expirationTime) && (get() != null);\n+            if (!valid) {\n+                invalidate();\n+            }\n+            return valid;\n+        }\n+\n+        public boolean isValid() {\n+            return isValid(System.currentTimeMillis());\n+        }\n+\n+        public void invalidate() {\n+            clear();\n+            key = null;\n+            expirationTime = -1;\n+        }\n+\n+        public void clear() {\n+            queue.forEach(CacheEntry::invalidate);\n+            queue.clear();\n+        }\n+\n+        public boolean isEmpty() {\n+            return queue.isEmpty();\n+        }\n+\n+        public Queue<CacheEntry<K,V>> getQueue() {\n+            return queue;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":212,"deletions":27,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    static String pathToStores = \"..\/etc\";\n+    static String pathToStores = \"javax\/net\/ssl\/etc\";\n@@ -60,0 +60,3 @@\n+    final static String TESTROOT =\n+        System.getProperty(\"test.root\", \"..\/..\/..\/..\");\n+\n@@ -67,6 +70,4 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+\n+        String keyFilename = TESTROOT +  \"\/\" + pathToStores + \"\/\" + keyStoreFile;\n+        String trustFilename = TESTROOT + \"\/\" + pathToStores + \"\/\" +\n+            trustStoreFile;\n@@ -100,1 +101,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") + \"\/\" + pathToStores +\n@@ -116,1 +117,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") + \"\/\" + pathToStores +\n@@ -326,0 +327,4 @@\n+            this(km, tm, true);\n+        }\n+\n+        Client(boolean km, boolean tm, boolean connect) {\n@@ -329,1 +334,3 @@\n-            connect();\n+            if (connect) {\n+                this.sock = connect();\n+            }\n@@ -332,1 +339,0 @@\n-        \/\/ Connect to server.  Maybe runnable in the future\n@@ -337,0 +343,14 @@\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return getNewSocket();\n+        }\n+\n+        public SSLSession getSession() {\n+            return sock.getSession();\n+        }\n+\n+        \/\/ Connect to server.  Maybe runnable in the future\n+        private SSLSocket getNewSocket() {\n+            try {\n+\n@@ -350,0 +370,4 @@\n+        public SSLSession getNewSession() {\n+            return getNewSocket().getSession();\n+        }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":35,"deletions":11,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple session tickets are PSKs are used by JSSE\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=1\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=3\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=10\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs and PSKs are sent by a JSSE server.\n+ * Then JSSE client is able to store them all and resume the connection.  It\n+ * requires specific text in the TLS debugging to verify the success.\n+ *\/\n+\n+public class MultiNSTClient {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> {\n+                sb.append(a);\n+                sb.append(\" \");\n+            });\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                );\n+\n+            boolean TLS13 = args[0].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTClient\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            System.out.println(\"I'm here\");\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                for (int i = 0; i < 2; i++) {\n+                    String svr = serverPSK.getFirst();\n+                    String cli = clientPSK.getFirst();\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"No MultiNST PSK found.\");\n+                pass = false;\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client client1 = new TLSBase.Client();\n+\n+        SSLSession initialSession = client1.getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+        SSLSession resumption;\n+        resumption = client1.getNewSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  Second getNewSession from original client\");\n+        resumption = client1.getNewSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  new client\");\n+        TLSBase.Client client2 = new TLSBase.Client();\n+        SSLSession newSession = client2.getSession();\n+\n+        System.out.println(\"id = \" + hex.formatHex(newSession.getId()));\n+        System.out.println(\"session = \" + newSession);\n+        if (initialSession.toString().equalsIgnoreCase(newSession.toString())) {\n+            throw new Exception(\"new session is the same as the initial.\");\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        client1.close();\n+        client2.close();\n+        server.close(client1);\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"}]}