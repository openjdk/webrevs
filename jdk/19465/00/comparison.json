{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.math.BigInteger;\n@@ -33,0 +32,1 @@\n+import java.util.Arrays;\n@@ -121,5 +121,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -224,5 +219,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -317,1 +307,1 @@\n-        public byte[] produce(ConnectionContext context) throws IOException {\n+        public byte[] produce(ConnectionContext context) {\n@@ -335,2 +325,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -354,2 +343,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -366,2 +354,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -378,2 +365,9 @@\n-            SessionId newId = new SessionId(true,\n-                hc.sslContext.getSecureRandom());\n+            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n+            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"No session ticket produced: \" +\n+                            \"session timeout\");\n+                }\n+\n+                return null;\n+            }\n@@ -385,3 +379,2 @@\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"no resumption secret\");\n+                    SSLLogger.fine(\"No session ticket produced: \" +\n+                        \"no resumption secret\");\n@@ -393,6 +386,36 @@\n-            \/\/ construct the PSK and handshake message\n-            BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();\n-            byte[] nonceArr = nonce.toByteArray();\n-            SecretKey psk = derivePreSharedKey(\n-                    hc.negotiatedCipherSuite.hashAlg,\n-                    resumptionMasterSecret, nonceArr);\n+            \/*\n+             * This thread addresses a Windows only networking issue found with\n+             * SSLSocketBruteForceClose. A client that quickly closes after\n+             * TLS Finished completed would cause the server read-side to\n+             * get a SocketException: \"An established connection was aborted\n+             * by the software in your host machine\", which relates to WinSock\n+             * error WSAECONNABORTED.  This situation was observed with\n+             * multiple NST messages when the client and server threads on the\n+             * same machine.  This is very unlikely to be seen where client\n+             * and server are on different machines.\n+             *\/\n+            Thread nstThread = Thread.ofVirtual().name(\"NST\").start(() -> {\n+                \/\/ Output the handshake message.\n+                try {\n+                    int i = 0;\n+                    while (i < SSLConfiguration.serverNewSessionTicketCount) {\n+                        SessionId newId = new SessionId(true,\n+                            hc.sslContext.getSecureRandom());\n+                        NewSessionTicketMessage nstm = generateNST(hc,\n+                            sessionTimeoutSeconds, newId, sessionCache);\n+                        if (nstm != null) {\n+                            \/\/ should never be null\n+                            nstm.write(hc.handshakeOutput);\n+                        }\n+                        i++;\n+                    }\n+                    hc.handshakeOutput.flush();\n+                } catch (IOException e) {\n+                    \/\/ Low exception likelihood this is data requires not\n+                    \/\/ reply an IO errors will be handled by other messages.\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        SSLLogger.fine(\"NST thread exception:\");\n+                        e.printStackTrace();\n+                    }\n+                }\n+            });\n@@ -400,2 +423,14 @@\n-            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n-            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n+            \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n+            \/\/\n+            \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n+            \/\/ of this post-handshake message will indicate the FINISHED\n+            \/\/ handshake status.  It is not needed to have a follow-on\n+            \/\/ SSLEngine.wrap() any longer.\n+            if (hc.conContext.needHandshakeFinishedStatus) {\n+                hc.conContext.needHandshakeFinishedStatus = false;\n+            }\n+\n+            \/\/ Rejoin NST thread\n+            try {\n+                nstThread.join(1000);\n+            } catch (InterruptedException e) {\n@@ -403,3 +438,2 @@\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"session timeout\");\n+                    SSLLogger.fine(\"NST thread interrupted: \");\n+                    e.printStackTrace();\n@@ -407,2 +441,0 @@\n-\n-                return null;\n@@ -410,0 +442,2 @@\n+            \/\/ clean the post handshake context\n+            hc.conContext.finishPostHandshake();\n@@ -411,1 +445,15 @@\n-            NewSessionTicketMessage nstm = null;\n+            \/\/ The message has been delivered.\n+            return null;\n+        }\n+\n+        private NewSessionTicketMessage generateNST(HandshakeContext hc,\n+            int sessionTimeoutSeconds, SessionId newId,\n+            SSLSessionContextImpl sessionCache) throws IOException {\n+            NewSessionTicketMessage nstm;\n+\n+            \/\/ construct the PSK and handshake message\n+            byte[] nonceArr = hc.handshakeSession.incrTicketNonceCounter().\n+                toByteArray();\n+            SecretKey psk = derivePreSharedKey(\n+                hc.negotiatedCipherSuite.hashAlg,\n+                hc.handshakeSession.getResumptionMasterSecret(), nonceArr);\n@@ -414,1 +462,1 @@\n-                    new SSLSessionImpl(hc.handshakeSession, newId);\n+                new SSLSessionImpl(hc.handshakeSession, newId);\n@@ -431,2 +479,1 @@\n-                        SSLLogger.fine(\n-                            \"Produced NewSessionTicket stateless \" +\n+                        SSLLogger.fine(\"Produced NewSessionTicket stateless \" +\n@@ -436,0 +483,1 @@\n+                return nstm;\n@@ -445,3 +493,2 @@\n-                    SSLLogger.fine(\n-                            \"Produced NewSessionTicket post-handshake message\",\n-                            nstm);\n+                    SSLLogger.fine(\"Produced NewSessionTicket \" +\n+                            \"post-handshake message\", nstm);\n@@ -456,0 +503,1 @@\n+                return nstm;\n@@ -458,21 +506,0 @@\n-            \/\/ Output the handshake message.\n-            if (nstm != null) {\n-                \/\/ should never be null\n-                nstm.write(hc.handshakeOutput);\n-                hc.handshakeOutput.flush();\n-\n-                \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n-                \/\/\n-                \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n-                \/\/ of this post-handshake message will indicate the FINISHED\n-                \/\/ handshake status.  It is not needed to have a follow-on\n-                \/\/ SSLEngine.wrap() any longer.\n-                if (hc.conContext.needHandshakeFinishedStatus) {\n-                    hc.conContext.needHandshakeFinishedStatus = false;\n-                }\n-            }\n-\n-            \/\/ clean the post handshake context\n-            hc.conContext.finishPostHandshake();\n-\n-            \/\/ The message has been delivered.\n@@ -483,1 +510,1 @@\n-    \/**\n+        \/**\n@@ -581,1 +608,0 @@\n-                sessionCache.remove(hc.handshakeSession.getSessionId());\n@@ -622,1 +648,6 @@\n-            sessionCache.put(sessionCopy);\n+            sessionCache.put(sessionCopy, sessionCopy.isPSK());\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"MultiNST PSK (Server): \" +\n+                    Utilities.toHexString(Arrays.copyOf(nstm.ticket, 16)));\n+            }\n@@ -677,2 +708,1 @@\n-                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" +\n-                        nstm.toString());\n+                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" + nstm);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":100,"deletions":70,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -707,0 +707,2 @@\n+                SSLLogger.fine(\n+                    \"MultiNST PSK (Client): \" + Utilities.toHexString(Arrays.copyOf(chc.pskIdentity, 16)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,5 @@\n+    \/\/ Number of NewSessionTickets (NST) that will be sent by the server.\n+    static final int serverNewSessionTicketCount;\n+    \/\/ Default for NST\n+    static final int SERVER_NST_DEFAULT = 3;\n+\n@@ -185,1 +190,1 @@\n-                \"jdk.tls.client.maxInboundCertificateChainLength\");\n+            \"jdk.tls.client.maxInboundCertificateChainLength\");\n@@ -194,0 +199,20 @@\n+\n+        Integer nstServerCount = GetIntegerAction.privilegedGetProperty(\n+            \"jdk.tls.server.newSessionTicketCount\");\n+        if (nstServerCount == null || nstServerCount < 1 ||\n+            nstServerCount > 10) {\n+            serverNewSessionTicketCount = SERVER_NST_DEFAULT;\n+            if (nstServerCount != null && SSLLogger.isOn &&\n+                SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount defaults to 3 as \" +\n+                        \"the property was not between 1 and 10\");\n+            }\n+        } else {\n+            serverNewSessionTicketCount = nstServerCount;\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount set to \" +\n+                        serverNewSessionTicketCount);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,0 @@\n-        sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n-        sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -93,0 +91,2 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -95,1 +95,1 @@\n-            \/\/ but doesn't necessarily has to be a true random number.\n+            \/\/ but doesn't necessarily have to be a true random number.\n@@ -98,0 +98,2 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryQueue(cacheLimit, timeout);\n@@ -279,0 +281,12 @@\n+    void put(SSLSessionImpl s, boolean flag) {\n+        sessionCache.put(s.getSessionId(), s);\n+\n+        \/\/ If no hostname\/port info is available, don't add this one.\n+        if ((s.getPeerHost() != null) && (s.getPeerPort() != -1)) {\n+            sessionHostPortCache.put(\n+                getKey(s.getPeerHost(), s.getPeerPort()), s, flag);\n+        }\n+\n+        s.setContext(this);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.util.Enumeration;\n@@ -76,1 +75,1 @@\n-final class SSLSessionImpl extends ExtendedSSLSession {\n+final public class SSLSessionImpl extends ExtendedSSLSession {\n@@ -495,1 +494,1 @@\n-                buf.get(b, 0 , i);\n+                buf.get(b, 0, i);\n@@ -504,2 +503,7 @@\n-                this.pskIdentity = new byte[buf.get()];\n-                buf.get(pskIdentity);\n+                i = buf.get();\n+                if (i > 0) {\n+                    this.pskIdentity = new byte[buf.get()];\n+                    buf.get(pskIdentity);\n+                } else {\n+                    this.pskIdentity = null;\n+                }\n@@ -719,3 +723,8 @@\n-        BigInteger result = ticketNonceCounter;\n-        ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);\n-        return result;\n+        sessionLock.lock();\n+        try {\n+            BigInteger result = ticketNonceCounter;\n+            ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);\n+            return result;\n+        } finally {\n+            sessionLock.unlock();\n+        }\n@@ -784,0 +793,4 @@\n+    public boolean isPSK() {\n+        return (pskIdentity != null && pskIdentity.length > 0);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n@@ -29,1 +31,2 @@\n-import java.lang.ref.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -93,0 +96,9 @@\n+    \/**\n+     * Add V to the cache with the option to use a QueueCacheEntry if the\n+     * cache is configured for it.  If the cache is not configured for a queue,\n+     * V will silently add the entry directly.\n+     *\/\n+    public void put(K key, V value, boolean canQueue) {\n+        put(key, value);\n+    }\n+\n@@ -128,1 +140,1 @@\n-        return new MemoryCache<>(true, size);\n+        return new MemoryCache<>(CacheType.SOFT, size);\n@@ -137,1 +149,5 @@\n-        return new MemoryCache<>(true, size, timeout);\n+        return new MemoryCache<>(CacheType.SOFT, size, timeout);\n+    }\n+\n+    public static <K,V> Cache<K,V> newSoftMemoryQueue(int size, int timeout) {\n+        return new MemoryCache<>(CacheType.CACHE, size, timeout);\n@@ -145,1 +161,1 @@\n-        return new MemoryCache<>(false, size);\n+        return new MemoryCache<>(CacheType.HARD, size);\n@@ -162,1 +178,1 @@\n-        return new MemoryCache<>(false, size, timeout);\n+        return new MemoryCache<>(CacheType.HARD, size, timeout);\n@@ -249,1 +265,5 @@\n-class MemoryCache<K,V> extends Cache<K,V> {\n+\/**\n+ * There are three types of cache.  SoftCacheEntry, HardCacheEntry, and\n+ * QueueCacheEntry.  This enum is used to identify the cache's configuration.\n+ *\/\n+enum CacheType { SOFT, HARD, CACHE }\n@@ -251,1 +271,1 @@\n-    private static final float LOAD_FACTOR = 0.75f;\n+class MemoryCache<K,V> extends Cache<K,V> {\n@@ -253,1 +273,1 @@\n-    \/\/ XXXX\n+    \/\/ Debugging\n@@ -260,0 +280,1 @@\n+    private final CacheType cacheType;\n@@ -265,2 +286,2 @@\n-    public MemoryCache(boolean soft, int maxSize) {\n-        this(soft, maxSize, 0);\n+    public MemoryCache(CacheType type, int maxSize) {\n+        this(type, maxSize, 0);\n@@ -269,1 +290,1 @@\n-    public MemoryCache(boolean soft, int maxSize, int lifetime) {\n+    public MemoryCache(CacheType type, int maxSize, int lifetime) {\n@@ -272,3 +293,2 @@\n-        if (soft)\n-            this.queue = new ReferenceQueue<>();\n-        else\n+        cacheType = type;\n+        if (cacheType == CacheType.HARD) {\n@@ -276,0 +296,3 @@\n+        } else {\n+            this.queue = new ReferenceQueue<>();\n+        }\n@@ -277,1 +300,1 @@\n-        cacheMap = new LinkedHashMap<>(1, LOAD_FACTOR, true);\n+        cacheMap = new ConcurrentHashMap<>();\n@@ -287,0 +310,1 @@\n+\n@@ -294,1 +318,1 @@\n-            CacheEntry<K,V> entry = (CacheEntry<K,V>)queue.poll();\n+            CacheEntry<K, V> entry = (CacheEntry<K, V>) queue.poll();\n@@ -303,1 +327,2 @@\n-            CacheEntry<K,V> currentEntry = cacheMap.remove(key);\n+\n+            CacheEntry<K, V> currentEntry = cacheMap.remove(key);\n@@ -308,0 +333,5 @@\n+                continue;\n+            }\n+\n+            if (currentEntry instanceof QueueCacheEntry<K,V> qe) {\n+                qe.clear();\n@@ -310,0 +340,1 @@\n+\n@@ -322,0 +353,1 @@\n+\n@@ -363,3 +395,1 @@\n-            while (queue.poll() != null) {\n-                \/\/ empty\n-            }\n+            while (queue.poll() != null);\n@@ -370,1 +400,18 @@\n-    public synchronized void put(K key, V value) {\n+    public void put(K key, V value) {\n+        put(key, value, false);\n+    }\n+\n+    \/**\n+     * This puts an entry into the cacheMap.\n+     *\n+     * If useQueue is true, V will be added using a QueueCacheEntry which\n+     * is added to cacheMap.  If false, V is added to the cacheMap directly.\n+     *\n+     * This method is synchronized to avoid multiple QueueCacheEntry\n+     * overwriting the same key.\n+     *\n+     * @param key key to the cacheMap\n+     * @param value value to be stored\n+     * @param canQueue can the value be put into a QueueCacheEntry\n+     *\/\n+    public synchronized void put(K key, V value, boolean canQueue) {\n@@ -372,2 +419,2 @@\n-        long expirationTime = (lifetime == 0) ? 0 :\n-                                        System.currentTimeMillis() + lifetime;\n+        long expirationTime =\n+            (lifetime == 0) ? 0 : System.currentTimeMillis() + lifetime;\n@@ -377,0 +424,1 @@\n+\n@@ -378,4 +426,25 @@\n-        CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n-        if (oldEntry != null) {\n-            oldEntry.invalidate();\n-            return;\n+        if (cacheType != CacheType.CACHE) {\n+            \/\/ No matter canQueue's value, enter the value directly\n+            cacheMap.put(key, newEntry);\n+        } else {\n+            CacheEntry<K, V> entry = cacheMap.get(key);\n+            switch (entry) {\n+                case QueueCacheEntry<K, V> qe -> qe.putValue(newEntry);\n+                case null,\n+                    default -> {\n+                    if (canQueue) {\n+                        var q = new QueueCacheEntry<>(key, value,\n+                            expirationTime, queue);\n+                        q.putValue(newEntry);\n+                        cacheMap.put(key, q);\n+                    } else {\n+                        cacheMap.put(key, newEntry);\n+                    }\n+                }\n+            }\n+\n+            if (DEBUG) {\n+                System.out.println(\"Cache entry added: key=\" +\n+                    key.toString() + \", class=\" +\n+                    (entry != null ? entry.getClass().getName() : null));\n+            }\n@@ -383,0 +452,1 @@\n+\n@@ -398,1 +468,1 @@\n-    public synchronized V get(Object key) {\n+    public V get(Object key) {\n@@ -404,2 +474,2 @@\n-        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n-        if (!entry.isValid(time)) {\n+        if (lifetime > 0 && !entry.isValid(System.currentTimeMillis())) {\n+            cacheMap.remove(key);\n@@ -409,1 +479,0 @@\n-            cacheMap.remove(key);\n@@ -412,0 +481,10 @@\n+\n+        \/\/ If the value is a queue, return a queue entry.\n+        if (entry instanceof QueueCacheEntry<K,V> qe) {\n+            V result = qe.getValue(lifetime);\n+            if (qe.isEmpty()) {\n+                cacheMap.remove(key);\n+            }\n+            return result;\n+        }\n+\n@@ -415,1 +494,1 @@\n-    public synchronized void remove(Object key) {\n+    public void remove(Object key) {\n@@ -423,1 +502,1 @@\n-    public synchronized V pull(Object key) {\n+    public V pull(Object key) {\n@@ -553,3 +632,2 @@\n-    private static class SoftCacheEntry<K,V>\n-            extends SoftReference<V>\n-            implements CacheEntry<K,V> {\n+    private static class SoftCacheEntry<K,V> extends SoftReference<V>\n+        implements CacheEntry<K,V> {\n@@ -594,1 +672,107 @@\n-}\n+    \/**\n+     * This CacheEntry<K,V> type allows multiple V entries to be stored in\n+     * one key in the cacheMap.\n+     *\n+     * This implementation is need for TLS clients that receive multiple\n+     * PSKs or NewSessionTickets for server resumption.\n+     *\/\n+    private static class QueueCacheEntry<K,V> extends SoftReference<V>\n+        implements CacheEntry<K,V> {\n+\n+        \/\/ Limit the number of queue entries.\n+        private static final int MAXQUEUESIZE = 10;\n+\n+        final boolean DEBUG = false;\n+        private K key;\n+        private long expirationTime;\n+        final Queue<CacheEntry<K,V>> queue = new ConcurrentLinkedQueue<>();\n+\n+        QueueCacheEntry(K key, V value, long expirationTime,\n+            ReferenceQueue<V> queue) {\n+            super(value, queue);\n+            this.key = key;\n+            this.expirationTime = expirationTime;\n+        }\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return getValue(0);\n+        }\n+\n+        public V getValue(long lifetime) {\n+            long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n+\n+            do {\n+                var entry = queue.poll();\n+                if (entry == null) {\n+                    return null;\n+                }\n+                if (entry.isValid(time)) {\n+                    return entry.getValue();\n+                }\n+                entry.invalidate();\n+            } while (!queue.isEmpty());\n+\n+            return null;\n+        }\n+\n+        public long getExpirationTime() {\n+            return expirationTime;\n+        }\n+\n+        public void setExpirationTime(long time) {\n+            expirationTime = time;\n+        }\n+\n+        public void putValue(CacheEntry<K,V> entry) {\n+            if (DEBUG) {\n+                System.out.println(\"Added to queue (size=\" + queue.size() +\n+                    \"): \" + entry.getKey().toString() + \",  \" + entry);\n+            }\n+            \/\/ Update the cache entry's expiration time to the latest entry.\n+            \/\/ the get() will remove expired tickets\n+            expirationTime = entry.getExpirationTime();\n+            \/\/ Limit the number of queue entries, removing the oldest.  As this\n+            \/\/ is a one for one entry swap, locking isn't necessary and plus or\n+            \/\/ minus a few entries is not critical.\n+            if (queue.size() > MAXQUEUESIZE) {\n+                queue.remove();\n+            }\n+            queue.add(entry);\n+        }\n+\n+        public boolean isValid(long currentTime) {\n+            boolean valid = (currentTime <= expirationTime) && (get() != null);\n+            if (!valid) {\n+                invalidate();\n+            }\n+            return valid;\n+        }\n+\n+        public boolean isValid() {\n+            return isValid(System.currentTimeMillis());\n+        }\n+\n+        public void invalidate() {\n+            clear();\n+            key = null;\n+            expirationTime = -1;\n+        }\n+\n+        public void clear() {\n+            queue.forEach(CacheEntry::invalidate);\n+            queue.clear();\n+        }\n+\n+        public boolean isEmpty() {\n+            return queue.isEmpty();\n+        }\n+\n+        public Queue<CacheEntry<K,V>> getQueue() {\n+            return queue;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":222,"deletions":38,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    static String pathToStores = \"..\/etc\";\n+    static String pathToStores = \"javax\/net\/ssl\/etc\";\n@@ -60,0 +60,3 @@\n+    final static String TESTROOT =\n+        System.getProperty(\"test.root\", \"..\/..\/..\/..\");\n+\n@@ -67,6 +70,4 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+\n+        String keyFilename = TESTROOT +  \"\/\" + pathToStores + \"\/\" + keyStoreFile;\n+        String trustFilename = TESTROOT + \"\/\" + pathToStores + \"\/\" +\n+            trustStoreFile;\n@@ -100,1 +101,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") + \"\/\" + pathToStores +\n@@ -116,1 +117,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") + \"\/\" + pathToStores +\n@@ -326,0 +327,4 @@\n+            this(km, tm, true);\n+        }\n+\n+        Client(boolean km, boolean tm, boolean connect) {\n@@ -329,1 +334,3 @@\n-            connect();\n+            if (connect) {\n+                this.sock = connect();\n+            }\n@@ -332,1 +339,0 @@\n-        \/\/ Connect to server.  Maybe runnable in the future\n@@ -337,0 +343,14 @@\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return getNewSocket();\n+        }\n+\n+        public SSLSession getSession() {\n+            return sock.getSession();\n+        }\n+\n+        \/\/ Connect to server.  Maybe runnable in the future\n+        private SSLSocket getNewSocket() {\n+            try {\n+\n@@ -350,0 +370,4 @@\n+        public SSLSession getNewSession() {\n+            return getNewSocket().getSession();\n+        }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":35,"deletions":11,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @summary Verifies multiple session tickets are PSKs are used by JSSE\n+ *\/\n+\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs and PSKs are sent by a JSSE server.\n+ * Then JSSE client is able to store them all and resume the connection.  It\n+ * requires specific text in the TLS debugging to verify the success.\n+ *\/\n+\n+public class MultiNSTClient {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            String params = args[0] + \" \" + args[1] + \" \" + args[2];\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                );\n+\n+            boolean TLS13 = args[0].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTClient\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            System.out.println(\"I'm here\");\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").asLines().stream().filter(s -> s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s -> s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s -> s.contains(\"MultiNST PSK (Client)\")).toList();\n+                \/\/System.err.println(\"found server: \" + serverPSK.size() + \" \" + serverPSK);\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                \/\/System.err.println(\"found client: \" + clientPSK.size() + \" \" + clientPSK);\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                for (int i = 0; i < 2; i++) {\n+                    String svr = serverPSK.getFirst();\n+                    String cli = clientPSK.getFirst();\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"No MultiNST PSK found.\");\n+                pass = false;\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client client1 = new TLSBase.Client();\n+\n+        SSLSession initialSession = client1.getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+        SSLSession resumption;\n+        resumption = client1.getNewSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  Second getNewSession from original client\");\n+        resumption = client1.getNewSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  new client\");\n+        TLSBase.Client client2 = new TLSBase.Client();\n+        SSLSession newSession = client2.getSession();\n+\n+        System.out.println(\"id = \" + hex.formatHex(newSession.getId()));\n+        System.out.println(\"session = \" + newSession);\n+        if (initialSession.toString().equalsIgnoreCase(newSession.toString())) {\n+            throw new Exception(\"new session is the same as the initial.\");\n+        }\n+        System.out.println(\"------  Closing connections\");\n+        client1.close();\n+        client2.close();\n+        server.close(client1);\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"}]}