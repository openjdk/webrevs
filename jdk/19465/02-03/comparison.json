{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -278,3 +277,0 @@\n-    \/\/ Locking is to protect QueueCacheEntry's from being removed from the\n-    \/\/ cacheMap while another thread is adding new queue entries.\n-    private ReentrantLock lock;\n@@ -306,3 +302,0 @@\n-        if (qSize > 0) {\n-            lock = new ReentrantLock();\n-        }\n@@ -339,4 +332,0 @@\n-                continue;\n-            }\n-            if (currentEntry instanceof QueueCacheEntry<K,V> qe) {\n-                qe.clear();\n@@ -373,4 +362,0 @@\n-                \/\/ If the top level entry expires, the whole queue is expired.\n-                if (entry instanceof QueueCacheEntry<K,V> qe) {\n-                    qe.clear();\n-                }\n@@ -382,5 +367,1 @@\n-                    qe.getQueue().forEach(e -> {\n-                        if (e.isValid(time)) {\n-                            qe.getQueue().remove(e);\n-                        }\n-                    });\n+                    qe.getQueue().removeIf(e -> e.isValid(time));\n@@ -444,1 +425,1 @@\n-        if (maxQueueSize == 0) {\n+        if (maxQueueSize == 0 || !canQueue) {\n@@ -453,1 +434,0 @@\n-                    lock.lock();\n@@ -455,1 +435,0 @@\n-                    lock.unlock();\n@@ -463,11 +442,3 @@\n-                case null,\n-                    default -> {\n-                    \/\/ If `canQueue` create a queue and put in entry.  If\n-                    \/\/ canQueue == false, replace or put this CacheEntry only.\n-                    if (canQueue) {\n-                        cacheMap.put(key, new QueueCacheEntry<>(key, newEntry,\n-                            expirationTime, maxQueueSize));\n-                    } else {\n-                        cacheMap.put(key, newEntry);\n-                    }\n-                }\n+                case null, default ->\n+                    cacheMap.put(key, new QueueCacheEntry<>(key, newEntry,\n+                        expirationTime, maxQueueSize));\n@@ -497,1 +468,1 @@\n-    public V get(Object key) {\n+    synchronized public V get(Object key) {\n@@ -503,14 +474,5 @@\n-        if (maxQueueSize > 0) {\n-            lock.lock();\n-        }\n-        try {\n-            if (lifetime > 0 && !entry.isValid(System.currentTimeMillis())) {\n-                removeImpl(key);\n-                if (DEBUG) {\n-                    System.out.println(\"Ignoring expired entry: \");\n-                }\n-                return null;\n-            }\n-        } finally {\n-            if (maxQueueSize > 0) {\n-                lock.unlock();\n+\n+        if (lifetime > 0 && !entry.isValid(System.currentTimeMillis())) {\n+            removeImpl(key);\n+            if (DEBUG) {\n+                System.out.println(\"Ignoring expired entry: \");\n@@ -518,0 +480,1 @@\n+            return null;\n@@ -523,1 +486,0 @@\n-            lock.lock();\n@@ -527,1 +489,0 @@\n-            lock.unlock();\n@@ -538,1 +499,0 @@\n-    \/\/ removeImpl is thread-safe entry removal from the cacheMap.\n@@ -763,4 +723,0 @@\n-                    \/\/ Use SoftReference get()\n-                    if (entry instanceof SoftCacheEntry<K,V> sce) {\n-                        return sce.get();\n-                    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":12,"deletions":56,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @summary Verifies multiple session tickets are PSKs are used by JSSE\n+ * @summary Verifies multiple PSKs are used by JSSE\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @summary Verifies multiple session tickets are PSKs are used by TLSv1.3\n+ * @summary Verifies multiple PSKs are used by TLSv1.3\n@@ -194,7 +194,3 @@\n-        try {\n-            for (Thread t : slist) {\n-                t.join(1000);\n-                System.err.println(\"released: \" + t.getName());\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"any exception?\");\n+        for (Thread t : slist) {\n+            t.join(1000);\n+            System.err.println(\"released: \" + t.getName());\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"}]}