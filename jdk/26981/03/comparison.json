{"files":[{"patch":"@@ -121,1 +121,1 @@\n-bool ZMappedCache::EntryCompare::cmp(const IntrusiveRBNode* a, const IntrusiveRBNode* b) {\n+bool ZMappedCache::EntryCompare::less_than(const IntrusiveRBNode* a, const IntrusiveRBNode* b) {\n@@ -128,1 +128,1 @@\n-int ZMappedCache::EntryCompare::cmp(zoffset key, const IntrusiveRBNode* node) {\n+RBTreeOrdering ZMappedCache::EntryCompare::cmp(zoffset key, const IntrusiveRBNode* node) {\n@@ -131,2 +131,2 @@\n-  if (key < vmem.start()) { return -1; }\n-  if (key > vmem.end()) { return 1; }\n+  if (key < vmem.start()) { return RBTreeOrdering::LT; }\n+  if (key > vmem.end()) { return RBTreeOrdering::GT; }\n@@ -134,1 +134,1 @@\n-  return 0; \/\/ Containing\n+  return RBTreeOrdering::EQ; \/\/ Containing\n@@ -171,1 +171,1 @@\n-  if (_left_most == nullptr || EntryCompare::cmp(node, _left_most)) {\n+  if (_left_most == nullptr || EntryCompare::less_than(node, _left_most)) {\n@@ -176,1 +176,1 @@\n-  if (_right_most == nullptr || EntryCompare::cmp(_right_most, node)) {\n+  if (_right_most == nullptr || EntryCompare::less_than(_right_most, node)) {\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-    static int cmp(zoffset a, const IntrusiveRBNode* b);\n-    static bool cmp(const IntrusiveRBNode*  a, const IntrusiveRBNode* b);\n+    static RBTreeOrdering cmp(zoffset a, const IntrusiveRBNode* b);\n+    static bool less_than(const IntrusiveRBNode*  a, const IntrusiveRBNode* b);\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,5 +53,4 @@\n-    static int cmp(position a, position b) {\n-      if (a < b) return -1;\n-      if (a == b) return 0;\n-      if (a > b) return 1;\n-      ShouldNotReachHere();\n+    static RBTreeOrdering cmp(position a, position b) {\n+      if (a < b) return RBTreeOrdering::LT;\n+      if (a > b) return RBTreeOrdering::GT;\n+      return RBTreeOrdering::EQ;\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,2 +70,4 @@\n-    static int cmp(int a, int b) {\n-      return a - b;\n+    static RBTreeOrdering cmp(int a, int b) {\n+      if (a < b) return RBTreeOrdering::LT;\n+      if (a > b) return RBTreeOrdering::GT;\n+      return RBTreeOrdering::EQ;\n","filename":"src\/hotspot\/share\/opto\/printinlining.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,11 +38,7 @@\n-\/\/     - an int < 0 when a < b\n-\/\/     - an int == 0 when a == b\n-\/\/     - an int > 0 when a > b\n-\/\/ Additional static functions used for extra validation can optionally be provided:\n-\/\/   `cmp(K a, K b)` which returns:\n-\/\/       - an int < 0 when a < b\n-\/\/       - an int == 0 when a == b\n-\/\/       - an int > 0 when a > b\n-\/\/   `cmp(const IntrusiveRBNode* a, const IntrusiveRBNode* b)` which returns:\n-\/\/       - true if a < b\n-\/\/       - false otherwise\n+\/\/     - RBTreeOrdering::LT when a < b\n+\/\/     - RBTreeOrdering::EQ when a == b\n+\/\/     - RBTreeOrdering::GT when a > b\n+\/\/ A second static function `less_than(const IntrusiveRBNode* a, const IntrusiveRBNode* b)`\n+\/\/ used for extra validation can optionally be provided. This should return:\n+\/\/     - true if a < b\n+\/\/     - false otherwise\n@@ -57,4 +53,4 @@\n-\/\/     - an int < 0 when a < b\n-\/\/     - an int == 0 when a == b\n-\/\/     - an int > 0 when a > b\n-\/\/ A second static function `cmp(const RBNode<K, V>* a, const RBNode<K, V>* b)`\n+\/\/     - RBTreeOrdering::LT when a < b\n+\/\/     - RBTreeOrdering::EQ when a == b\n+\/\/     - RBTreeOrdering::GT when a > b\n+\/\/ A second static function `less_than(const RBNode<K, V>* a, const RBNode<K, V>* b)`\n@@ -69,0 +65,2 @@\n+enum class RBTreeOrdering : int { LT, EQ, GT };\n+\n@@ -130,1 +128,1 @@\n-  template <typename NodeType, typename NodeVerifier>\n+  template <typename NodeType, typename NODE_VERIFIER, typename USER_VERIFIER>\n@@ -133,1 +131,2 @@\n-              size_t& tree_depth, bool expect_visited, NodeVerifier verifier) const;\n+              size_t& tree_depth, bool expect_visited, NODE_VERIFIER verifier,\n+              const USER_VERIFIER& extra_verifier) const;\n@@ -207,1 +206,1 @@\n-  static constexpr bool HasKeyComparator = has_cmp_type<CMP, int, K, K>::value;\n+  static constexpr bool HasKeyComparator = has_cmp_type<CMP, RBTreeOrdering, K, K>::value;\n@@ -210,1 +209,6 @@\n-  static constexpr bool HasNodeComparator = has_cmp_type<CMP, int, K, const NodeType*>::value;\n+  static constexpr bool HasNodeComparator = has_cmp_type<CMP, RBTreeOrdering, K, const NodeType*>::value;\n+\n+  template <typename CMP, typename RET, typename ARG1, typename ARG2, typename = void>\n+  struct has_less_than_type : std::false_type {};\n+  template <typename CMP, typename RET, typename ARG1, typename ARG2>\n+  struct has_less_than_type<CMP, RET, ARG1, ARG2, decltype(static_cast<RET(*)(ARG1, ARG2)>(CMP::less), void())> : std::true_type {};\n@@ -213,1 +217,1 @@\n-  static constexpr bool HasNodeVerifier = has_cmp_type<CMP, bool, const NodeType*, const NodeType*>::value;\n+  static constexpr bool HasNodeVerifier = has_less_than_type<CMP, bool, const NodeType*, const NodeType*>::value;\n@@ -216,1 +220,1 @@\n-  int cmp(const K& a, const NodeType* b) const {\n+  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n@@ -221,1 +225,1 @@\n-  int cmp(const K& a, const NodeType* b) const {\n+  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n@@ -226,1 +230,1 @@\n-  bool cmp(const NodeType* a, const NodeType* b) const {\n+  bool less_than(const NodeType* a, const NodeType* b) const {\n@@ -231,2 +235,2 @@\n-  bool cmp(const NodeType* a, const NodeType* b) const {\n-    return COMPARATOR::cmp(a, b);\n+  bool less_than(const NodeType* a, const NodeType* b) const {\n+    return COMPARATOR::less_than(a, b);\n@@ -241,1 +245,1 @@\n-    assert(COMPARATOR::cmp(a, b) <= 0, \"key a must be less or equal to key b\");\n+    assert(COMPARATOR::cmp(a, b) != RBTreeOrdering::GT, \"key a must be less or equal to key b\");\n@@ -260,2 +264,14 @@\n-  template <typename NodeVerifier>\n-  void verify_self(NodeVerifier verifier) const;\n+  struct empty_verifier {\n+    bool operator()(const NodeType* n) const {\n+      return true;\n+    }\n+  };\n+\n+  template <typename NODE_VERIFIER, typename USER_VERIFIER>\n+  void verify_self(NODE_VERIFIER verifier, const USER_VERIFIER& extra_verifier) const;\n+\n+  struct default_printer {\n+    void operator()(outputStream* st, const NodeType* n, int depth) const {\n+      n->print_on(st, depth);\n+    }\n+  };\n@@ -263,1 +279,2 @@\n-  void print_node_on(outputStream* st, int depth, const NodeType* n) const;\n+  template <typename PRINTER>\n+  void print_node_on(outputStream* st, int depth, const NodeType* n, const PRINTER& node_printer) const;\n@@ -426,3 +443,6 @@\n-  template <typename CMP = COMPARATOR, ENABLE_IF(HasNodeVerifier<CMP>)>\n-  void verify_self() const {\n-    verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::cmp(a, b);});\n+  \/\/ Accepts an optional callable `bool extra_verifier(const Node* n)`.\n+  \/\/ This should return true if the node is valid.\n+  \/\/ If provided, each node is also verified through this callable.\n+  template <typename USER_VERIFIER = empty_verifier, typename CMP = COMPARATOR, ENABLE_IF(HasNodeVerifier<CMP>)>\n+  void verify_self(const USER_VERIFIER& extra_verifier = USER_VERIFIER()) const {\n+    verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::less_than(a, b);}, extra_verifier);\n@@ -431,3 +451,4 @@\n-  template <typename CMP = COMPARATOR, ENABLE_IF(HasKeyComparator<CMP> && !HasNodeVerifier<CMP>)>\n-  void verify_self() const {\n-    verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::cmp(a->key(), b->key()) < 0; });\n+  template <typename USER_VERIFIER = empty_verifier, typename CMP = COMPARATOR,\n+            ENABLE_IF(HasKeyComparator<CMP> && !HasNodeVerifier<CMP>)>\n+  void verify_self(const USER_VERIFIER& extra_verifier = USER_VERIFIER()) const {\n+    verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::cmp(a->key(), b->key()) == RBTreeOrdering::LT; }, extra_verifier);\n@@ -436,3 +457,4 @@\n-  template <typename CMP = COMPARATOR, ENABLE_IF(HasNodeComparator<CMP> && !HasKeyComparator<CMP> && !HasNodeVerifier<CMP>)>\n-  void verify_self() const {\n-    verify_self([](const NodeType*, const NodeType*){ return true;});\n+  template <typename USER_VERIFIER = empty_verifier, typename CMP = COMPARATOR,\n+            ENABLE_IF(HasNodeComparator<CMP> && !HasKeyComparator<CMP> && !HasNodeVerifier<CMP>)>\n+  void verify_self(const USER_VERIFIER& extra_verifier = USER_VERIFIER()) const {\n+    verify_self([](const NodeType*, const NodeType*){ return true;}, extra_verifier);\n@@ -441,1 +463,4 @@\n-  void print_on(outputStream* st) const;\n+  \/\/ Accepts an optional printing callable `void node_printer(outputStream* st, const Node* n, int depth)`.\n+  \/\/ If provided, each node is printed through this callable rather than the default `print_on`.\n+  template <typename PRINTER = default_printer>\n+  void print_on(outputStream* st, const PRINTER& node_printer = PRINTER()) const;\n@@ -455,0 +480,8 @@\n+  RBTree(const RBTree& other) : BaseType(), _allocator() {\n+    assert(std::is_copy_constructible<V>(), \"Value type must be copy-constructible\");\n+    other.visit_in_order([&](auto node) {\n+      this->upsert(node->key(), node->val());\n+      return true;\n+    });\n+  }\n+  RBTree& operator=(const RBTree& other) = delete;\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":72,"deletions":39,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-template <typename NodeType, typename NodeVerifier>\n+template <typename NodeType, typename NODE_VERIFIER, typename USER_VERIFIER>\n@@ -129,1 +129,2 @@\n-    size_t& tree_depth, bool expect_visited, NodeVerifier verifier) const {\n+    size_t& tree_depth, bool expect_visited, NODE_VERIFIER verifier, const USER_VERIFIER& extra_verifier) const {\n+  assert(extra_verifier(static_cast<const NodeType*>(this)), \"user provided verifier failed\");\n@@ -146,1 +147,1 @@\n-                  longest_leaf_path_left, tree_depth_left, expect_visited, verifier);\n+                  longest_leaf_path_left, tree_depth_left, expect_visited, verifier, extra_verifier);\n@@ -162,1 +163,1 @@\n-                   longest_leaf_path_right, tree_depth_right, expect_visited, verifier);\n+                   longest_leaf_path_right, tree_depth_right, expect_visited, verifier, extra_verifier);\n@@ -193,1 +194,1 @@\n-    const int hint_cmp = cmp(key, hint_node);\n+    const RBTreeOrdering hint_cmp = cmp(key, hint_node);\n@@ -195,1 +196,1 @@\n-      const int parent_cmp = cmp(key, (NodeType*)hint_node->parent());\n+      const RBTreeOrdering parent_cmp = cmp(key, (NodeType*)hint_node->parent());\n@@ -198,2 +199,2 @@\n-      if ((parent_cmp <= 0 && hint_cmp < 0) ||\n-          (parent_cmp >= 0 && hint_cmp > 0)) {\n+      if ((parent_cmp != RBTreeOrdering::GT && hint_cmp == RBTreeOrdering::LT) ||\n+          (parent_cmp != RBTreeOrdering::LT    && hint_cmp == RBTreeOrdering::GT)) {\n@@ -215,1 +216,1 @@\n-    const int key_cmp_k = cmp(key, curr);\n+    const RBTreeOrdering key_cmp_k = cmp(key, curr);\n@@ -217,1 +218,1 @@\n-    if (key_cmp_k == 0) {\n+    if (key_cmp_k == RBTreeOrdering::EQ) {\n@@ -222,1 +223,1 @@\n-    if (key_cmp_k < 0) {\n+    if (key_cmp_k == RBTreeOrdering::LT) {\n@@ -554,1 +555,1 @@\n-    assert(cmp(static_cast<const NodeType*>(new_node), static_cast<const NodeType*>(new_node->parent())), \"new node not < parent\");\n+    assert(less_than(static_cast<const NodeType*>(new_node), static_cast<const NodeType*>(new_node->parent())), \"new node not < parent\");\n@@ -556,1 +557,1 @@\n-    assert(cmp(static_cast<const NodeType*>(new_node->parent()), static_cast<const NodeType*>(new_node)), \"new node not > parent\");\n+    assert(less_than(static_cast<const NodeType*>(new_node->parent()), static_cast<const NodeType*>(new_node)), \"new node not > parent\");\n@@ -562,1 +563,1 @@\n-    assert(cmp(static_cast<const NodeType*>(new_node->_left), static_cast<const NodeType*>(new_node)), \"left child not < new node\");\n+    assert(less_than(static_cast<const NodeType*>(new_node->_left), static_cast<const NodeType*>(new_node)), \"left child not < new node\");\n@@ -566,1 +567,1 @@\n-    assert(cmp(static_cast<const NodeType*>(new_node), static_cast<const NodeType*>(new_node->_right)), \"right child not > new node\");\n+    assert(less_than(static_cast<const NodeType*>(new_node), static_cast<const NodeType*>(new_node->_right)), \"right child not > new node\");\n@@ -664,2 +665,2 @@\n-template <typename NodeVerifier>\n-inline void AbstractRBTree<K, NodeType, COMPARATOR>::verify_self(NodeVerifier verifier) const {\n+template <typename NODE_VERIFIER, typename USER_VERIFIER>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::verify_self(NODE_VERIFIER verifier, const USER_VERIFIER& extra_verifier) const {\n@@ -682,1 +683,1 @@\n-                tree_depth, expected_visited, verifier);\n+                tree_depth, expected_visited, verifier, extra_verifier);\n@@ -734,2 +735,3 @@\n-void AbstractRBTree<K, NodeType, COMPARATOR>::print_node_on(outputStream* st, int depth, const NodeType* n) const {\n-  n->print_on(st, depth);\n+template <typename PRINTER>\n+void AbstractRBTree<K, NodeType, COMPARATOR>::print_node_on(outputStream* st, int depth, const NodeType* n, const PRINTER& node_printer) const {\n+  node_printer(st, n, depth);\n@@ -737,3 +739,0 @@\n-  if (n->_right != nullptr) {\n-    print_node_on(st, depth, (NodeType*)n->_right);\n-  }\n@@ -741,1 +740,4 @@\n-    print_node_on(st, depth, (NodeType*)n->_left);\n+    print_node_on(st, depth, (NodeType*)n->_left, node_printer);\n+  }\n+  if (n->_right != nullptr) {\n+    print_node_on(st, depth, (NodeType*)n->_right, node_printer);\n@@ -746,1 +748,2 @@\n-void AbstractRBTree<K, NodeType, COMPARATOR>::print_on(outputStream* st) const {\n+template <typename PRINTER>\n+void AbstractRBTree<K, NodeType, COMPARATOR>::print_on(outputStream* st, const PRINTER& node_printer) const {\n@@ -748,1 +751,1 @@\n-    print_node_on(st, 0, (NodeType*)_root);\n+    print_node_on(st, 0, (NodeType*)_root, node_printer);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":29,"deletions":26,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -39,2 +39,4 @@\n-    static int cmp(int a, int b) {\n-      return a - b;\n+    static RBTreeOrdering cmp(int a, int b) {\n+      if (a < b) return RBTreeOrdering::LT;\n+      if (a > b) return RBTreeOrdering::GT;\n+      return RBTreeOrdering::EQ;\n@@ -43,1 +45,1 @@\n-    static bool cmp(const RBTreeIntNode* a, const RBTreeIntNode* b) {\n+    static bool less_than(const RBTreeIntNode* a, const RBTreeIntNode* b) {\n@@ -49,2 +51,4 @@\n-    static int cmp(int a, int b) {\n-      return b - a;\n+    static RBTreeOrdering cmp(int a, int b) {\n+      if (a < b) return RBTreeOrdering::GT;\n+      if (a > b) return RBTreeOrdering::LT;\n+      return RBTreeOrdering::EQ;\n@@ -55,4 +59,4 @@\n-    static int cmp(float a, float b) {\n-      if (a < b) return -1;\n-      if (a == b) return 0;\n-      return 1;\n+    static RBTreeOrdering cmp(float a, float b) {\n+      if (a < b) return RBTreeOrdering::LT;\n+      if (a > b) return RBTreeOrdering::GT;\n+      return RBTreeOrdering::EQ;\n@@ -97,6 +101,5 @@\n-    static int cmp(int a, const IntrusiveTreeNode* b) {\n-      return a - IntrusiveHolder::cast_to_self(b)->key;\n-    }\n-\n-    static int cmp(int a, int b) {\n-      return a - b;\n+    static RBTreeOrdering cmp(int a, const IntrusiveTreeNode* b_node) {\n+      int b = IntrusiveHolder::cast_to_self(b_node)->key;\n+      if (a < b) return RBTreeOrdering::LT;\n+      if (a > b) return RBTreeOrdering::GT;\n+      return RBTreeOrdering::EQ;\n@@ -106,1 +109,1 @@\n-    static bool cmp(const IntrusiveTreeNode* a, const IntrusiveTreeNode* b) {\n+    static bool less_than(const IntrusiveTreeNode* a, const IntrusiveTreeNode* b) {\n@@ -840,0 +843,44 @@\n+  static bool custom_validator(const IntrusiveRBNode* n) {\n+    IntrusiveHolder* holder = IntrusiveHolder::cast_to_self(n);\n+    assert(holder->key == holder->data, \"must be\");\n+\n+    return true;\n+  }\n+\n+  void test_custom_verify_intrusive() {\n+    IntrusiveTreeInt intrusive_tree;\n+    int num_nodes = 100;\n+\n+    \/\/ Insert values\n+    for (int n = 0; n < num_nodes; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NULL(cursor.node());\n+\n+      \/\/ Custom allocation here is just malloc\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n, n);\n+\n+      intrusive_tree.insert_at_cursor(place->get_node(), cursor);\n+      IntrusiveCursor cursor2 = intrusive_tree.cursor(n);\n+\n+      EXPECT_NOT_NULL(cursor2.node());\n+    }\n+\n+    intrusive_tree.verify_self(RBTreeTest::custom_validator);\n+\n+    int node_count = 0;\n+    intrusive_tree.verify_self([&](const IntrusiveRBNode* n) {\n+      node_count++;\n+\n+      IntrusiveHolder* holder = IntrusiveHolder::cast_to_self(n);\n+      assert(holder->key >= 0, \"must be\");\n+      assert(holder->data >= 0, \"must be\");\n+      assert(holder->key < num_nodes, \"must be\");\n+      assert(holder->data < num_nodes, \"must be\");\n+\n+      return true;\n+    });\n+\n+    EXPECT_EQ(node_count, num_nodes);\n+  }\n+\n@@ -948,1 +995,1 @@\n-  static int cmp(const void* a, const void* b) {\n+  static RBTreeOrdering cmp(const void* a, const void* b) {\n@@ -951,1 +998,4 @@\n-    return ai == bi ? 0 : (ai > bi ? 1 : -1);\n+\n+    if (ai < bi) return RBTreeOrdering::LT;\n+    if (ai > bi) return RBTreeOrdering::GT;\n+    return RBTreeOrdering::EQ;\n@@ -985,1 +1035,5 @@\n-  static int cmp(int a, int b) { return a == b ? 0 : (a > b ? 1 : -1); }\n+  static RBTreeOrdering cmp(int a, int b) {\n+    if (a < b) return RBTreeOrdering::LT;\n+    if (a > b) return RBTreeOrdering::GT;\n+    return RBTreeOrdering::EQ;\n+  }\n@@ -1008,0 +1062,28 @@\n+TEST_VM(RBTreeTestNonFixture, TestPrintCustomPrinter) {\n+  typedef RBTree<int, unsigned, IntCmp, RBTreeCHeapAllocator<mtTest> > TreeType;\n+  typedef RBNode<int, unsigned> NodeType;\n+\n+  TreeType tree;\n+  const int i1 = -13591;\n+  const int i2 = 0;\n+  const int i3 = 82924;\n+  tree.upsert(i1, 1U);\n+  tree.upsert(i2, 2U);\n+  tree.upsert(i3, 3U);\n+\n+  stringStream ss;\n+  int print_count = 0;\n+  tree.print_on(&ss, [&](outputStream* st, const NodeType* n, int depth) {\n+    st->print_cr(\"[%d] (%d): %d\", depth, n->val(), n->key());\n+    print_count++;\n+  });\n+\n+const char* const expected =\n+    \"[0] (2): 0\\n\"\n+    \"[1] (1): -13591\\n\"\n+    \"[1] (3): 82924\\n\";\n+\n+  ASSERT_EQ(print_count, 3);\n+  ASSERT_STREQ(ss.base(), expected);\n+}\n+\n@@ -1012,0 +1094,4 @@\n+TEST_VM_F(RBTreeTest, IntrusiveCustomVerifyTest) {\n+  this->test_custom_verify_intrusive();\n+}\n+\n@@ -1024,0 +1110,16 @@\n+\n+TEST_VM_ASSERT_MSG(RBTreeTestNonFixture, CustomVerifyAssert, \".*failed on key = 7\") {\n+  typedef RBTreeCHeap<int, int, IntCmp, mtTest> TreeType;\n+  typedef RBNode<int, int> NodeType;\n+\n+  TreeType tree;\n+  for (int i = 0; i < 10; i++) {\n+    tree.upsert(i, i);\n+  }\n+\n+  tree.verify_self([&](const NodeType* n) {\n+    assert(n->key() != 7, \"failed on key = %d\", n->key());\n+    return true;\n+  });\n+}\n+\n@@ -1042,0 +1144,19 @@\n+TEST_VM_F(RBTreeTest, CustomVerify) {\n+  constexpr int num_nodes = 1000;\n+  RBTreeInt tree;\n+  for (int i = 0; i < num_nodes; i++) {\n+    tree.upsert(i, i);\n+  }\n+\n+  int node_count = 0;\n+  tree.verify_self([&](const RBTreeIntNode* n) {\n+    node_count++;\n+\n+    assert(n->key() >= 0, \"must be\");\n+    assert(n->key() < num_nodes, \"must be\");\n+    return true;\n+  });\n+\n+  EXPECT_EQ(node_count, num_nodes);\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":140,"deletions":19,"binary":false,"changes":159,"status":"modified"}]}