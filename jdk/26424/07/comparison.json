{"files":[{"patch":"@@ -1862,0 +1862,2 @@\n+  bool would_sink_below_pre_loop_exit(IdealLoopTree* n_loop, Node* ctrl);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1713,9 +1713,11 @@\n-        if (n->depends_only_on_test()) {\n-          Node* pinned_clone = n->pin_array_access_node();\n-          if (pinned_clone != nullptr) {\n-            \/\/ Pin array access nodes: if this is an array load, it's going to be dependent on a condition that's not a\n-            \/\/ range check for that access. If that condition is replaced by an identical dominating one, then an\n-            \/\/ unpinned load would risk floating above its range check.\n-            register_new_node(pinned_clone, n_ctrl);\n-            maybe_pinned_n = pinned_clone;\n-            _igvn.replace_node(n, pinned_clone);\n+        if (!would_sink_below_pre_loop_exit(loop_ctrl, outside_ctrl)) {\n+          if (n->depends_only_on_test()) {\n+            Node* pinned_clone = n->pin_array_access_node();\n+            if (pinned_clone != nullptr) {\n+              \/\/ Pin array access nodes: if this is an array load, it's going to be dependent on a condition that's not a\n+              \/\/ range check for that access. If that condition is replaced by an identical dominating one, then an\n+              \/\/ unpinned load would risk floating above its range check.\n+              register_new_node(pinned_clone, n_ctrl);\n+              maybe_pinned_n = pinned_clone;\n+              _igvn.replace_node(n, pinned_clone);\n+            }\n@@ -1723,0 +1725,1 @@\n+          _igvn.replace_input_of(maybe_pinned_n, 0, outside_ctrl);\n@@ -1724,1 +1727,0 @@\n-        _igvn.replace_input_of(maybe_pinned_n, 0, outside_ctrl);\n@@ -1932,0 +1934,15 @@\n+\/\/ Sinking a node from a pre loop to its main loop pins the node between the pre and main loops. If that node is input\n+\/\/ to a check that's eliminated by range check elimination, it becomes input to an expression that feeds into the exit\n+\/\/ test of the pre loop above the point in the graph where it's pinned. This results in a broken graph. One way to avoid\n+\/\/ it would be to not eliminate the check in the main loop. Instead, we prevent sinking of the node here so better code\n+\/\/ is generated for the main loop.\n+bool PhaseIdealLoop::would_sink_below_pre_loop_exit(IdealLoopTree* n_loop, Node* ctrl) {\n+  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop()) {\n+    CountedLoopNode* pre_loop = n_loop->_head->as_CountedLoop();\n+    if (is_dominator(pre_loop->loopexit(), ctrl)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1943,8 +1960,2 @@\n-  \/\/ Sinking a node from a pre loop to its main loop pins the node between the pre and main loops. If that node is input\n-  \/\/ to a check that's eliminated by range check elimination, it becomes input to an expression that feeds into the exit\n-  \/\/ test of the pre loop above the point in the graph where it's pinned.\n-  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop()) {\n-    CountedLoopNode* pre_loop = n_loop->_head->as_CountedLoop();\n-    if (is_dominator(pre_loop->loopexit(), ctrl)) {\n-      return false;\n-    }\n+  if (would_sink_below_pre_loop_exit(n_loop, ctrl)) {\n+    return false;\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8361702\n+ * @summary C2: assert(is_dominator(compute_early_ctrl(limit, limit_ctrl), pre_end)) failed: node pinned on loop exit test?\n+  *\n+ * @run main\/othervm -XX:CompileCommand=compileonly,*TestSunkRangeFromPreLoopRCE2*::* -Xbatch TestSunkRangeFromPreLoopRCE2\n+ * @run main TestSunkRangeFromPreLoopRCE2\n+ *\/\n+\n+public class TestSunkRangeFromPreLoopRCE2 {\n+    static int iFld;\n+    static long lArr[] = new long[400];\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 1000; i++) {\n+            test();\n+        }\n+    }\n+\n+    static void test() {\n+        int iArr[] = new int[400];\n+        for (int i = 8; i < 128; i++) {\n+            for (int j = 209; j > 9; j--) {\n+                switch ((j % 5) + 58) {\n+                    case 58:\n+                        iArr[i] = 194;\n+                        break;\n+                    case 59:\n+                        iFld = 3;\n+                    case 62:\n+                    default:\n+                        iArr[1] = i;\n+                }\n+                for (int k = 2; k > 1; --k) {\n+                    lArr[k] -= iFld;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestSunkRangeFromPreLoopRCE2.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8361702\n+ * @summary C2: assert(is_dominator(compute_early_ctrl(limit, limit_ctrl), pre_end)) failed: node pinned on loop exit test?\n+ * @requires vm.flavor == \"server\"\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:LoopUnrollLimit=100 -XX:-UseLoopPredicate -XX:-UseProfiledLoopPredicate TestSunkRangeFromPreLoopRCE3\n+ * @run main TestSunkRangeFromPreLoopRCE3\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class TestSunkRangeFromPreLoopRCE3 {\n+\n+    static final int nbIterations = 100;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(0);\n+            test1(0);\n+        }\n+    }\n+\n+    private static float test1(int k) {\n+        float v = 0;\n+        int j = 0;\n+        int[] lengths = new int[2];\n+        test1Helper(lengths);\n+        int constantFoldedTo4AfterCCP = 2;\n+        for (; constantFoldedTo4AfterCCP < 4; constantFoldedTo4AfterCCP *= 2);\n+\n+        int constantFoldedTo0AfterCCPAnd1RoundLoopOpts;\n+        for (constantFoldedTo0AfterCCPAnd1RoundLoopOpts = 0; constantFoldedTo0AfterCCPAnd1RoundLoopOpts < 40; constantFoldedTo0AfterCCPAnd1RoundLoopOpts += constantFoldedTo4AfterCCP) {\n+        }\n+        constantFoldedTo0AfterCCPAnd1RoundLoopOpts -= 40;\n+        for (int i = 0; i < nbIterations; i++) {\n+            int arrayLength2 = Integer.max(Integer.min(lengths[j * k], 1000), 0);\n+            float[] array = new float[arrayLength2];\n+            v += array[(constantFoldedTo0AfterCCPAnd1RoundLoopOpts + 1) * i];\n+\n+            int arrayLength = Integer.max(Integer.min(lengths[k], 1000), 0);\n+\n+            v += arrayLength & constantFoldedTo0AfterCCPAnd1RoundLoopOpts;\n+\n+            j = 1;\n+        }\n+        return v;\n+    }\n+\n+    private static void test1Helper(int[] lengths) {\n+        lengths[0] = nbIterations+1;\n+        lengths[1] = nbIterations+1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestSunkRangeFromPreLoopRCE3.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"}]}