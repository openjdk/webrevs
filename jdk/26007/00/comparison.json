{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -191,1 +192,5 @@\n-    assert(ik->is_initialized(), \"must be\");\n+    if (RegeneratedClasses::is_regenerated_object(ik)) {\n+      precond(RegeneratedClasses::get_original_object(ik)->is_initialized());\n+    } else {\n+      precond(ik->is_initialized());\n+    }\n@@ -246,0 +251,5 @@\n+    InstanceKlass* nest_host = ik->nest_host_or_null();\n+    if (nest_host != nullptr) {\n+      add_cached_instance_class(nest_host);\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -106,0 +107,4 @@\n+  if (RegeneratedClasses::is_regenerated_object(ik)) {\n+    ik = RegeneratedClasses::get_original_object(ik);\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -578,0 +578,3 @@\n+      if (RegeneratedClasses::has_been_regenerated(klass)) {\n+        klass = RegeneratedClasses::get_regenerated_object(klass);\n+      }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -546,0 +547,4 @@\n+      Klass* k = java_lang_Class::as_Klass(source_referent);\n+      if (RegeneratedClasses::has_been_regenerated(k)) {\n+        source_referent = RegeneratedClasses::get_regenerated_object(k)->java_mirror();\n+      }\n@@ -757,0 +762,5 @@\n+\n+    if (RegeneratedClasses::has_been_regenerated(native_ptr)) {\n+      native_ptr = RegeneratedClasses::get_regenerated_object(native_ptr);\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -820,3 +820,0 @@\n-  } else if (CDSConfig::is_dumping_method_handles()) {\n-    \/\/ Work around JDK-8310831, as some methods in lambda form holder classes may not get generated.\n-    return false;\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -340,0 +341,3 @@\n+          if (RegeneratedClasses::has_been_regenerated(m)) {\n+            m = RegeneratedClasses::get_regenerated_object(m);\n+          }\n@@ -509,3 +513,9 @@\n-  oop orig_mirror = ik->java_mirror();\n-  oop m = scratch_java_mirror(ik);\n-  assert(ik->is_initialized(), \"must be\");\n+  oop orig_mirror;\n+  if (RegeneratedClasses::is_regenerated_object(ik)) {\n+    InstanceKlass* orig_ik = RegeneratedClasses::get_original_object(ik);\n+    precond(orig_ik->is_initialized());\n+    orig_mirror = orig_ik->java_mirror();\n+  } else {\n+    precond(ik->is_initialized());\n+    orig_mirror = ik->java_mirror();\n+  }\n@@ -513,0 +523,1 @@\n+  oop m = scratch_java_mirror(ik);\n@@ -1523,0 +1534,7 @@\n+  if (java_lang_Class::is_instance(orig_obj)) {\n+    Klass* k = java_lang_Class::as_Klass(orig_obj);\n+    if (RegeneratedClasses::has_been_regenerated(k)) {\n+      orig_obj = RegeneratedClasses::get_regenerated_object(k)->java_mirror();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+    log_info(aot, lambda)(\"regenerate_class excluding klass %s %s\", class_name, klass->name()->as_C_string());\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-static RegeneratedObjTable* _renegerated_objs = nullptr; \/\/ InstanceKlass* and Method*\n+static RegeneratedObjTable* _regenerated_objs = nullptr; \/\/ InstanceKlass* and Method*  orig_obj  -> regen_obj\n+static RegeneratedObjTable* _original_objs = nullptr;    \/\/ InstanceKlass* and Method*  regen_obj -> orig_obj\n@@ -49,2 +50,5 @@\n-  if (_renegerated_objs == nullptr) {\n-    _renegerated_objs = new (mtClass)RegeneratedObjTable();\n+  if (_regenerated_objs == nullptr) {\n+    _regenerated_objs = new (mtClass)RegeneratedObjTable();\n+  }\n+  if (_original_objs == nullptr) {\n+    _original_objs = new (mtClass)RegeneratedObjTable();\n@@ -53,1 +57,2 @@\n-  _renegerated_objs->put((address)orig_klass, (address)regen_klass);\n+  _regenerated_objs->put((address)orig_klass, (address)regen_klass);\n+  _original_objs->put((address)regen_klass, (address)orig_klass);\n@@ -63,1 +68,2 @@\n-      _renegerated_objs->put((address)orig_m, (address)regen_m);\n+      _regenerated_objs->put((address)orig_m, (address)regen_m);\n+      _original_objs->put((address)regen_m, (address)orig_m);\n@@ -69,1 +75,16 @@\n-  if (_renegerated_objs == nullptr) {\n+  if (_regenerated_objs == nullptr) {\n+    return false;\n+  } else {\n+    return _regenerated_objs->get(orig_obj) != nullptr;\n+  }\n+}\n+\n+address RegeneratedClasses::get_regenerated_object(address orig_obj) {\n+  assert(_regenerated_objs != nullptr, \"must be\");\n+  address* p =_regenerated_objs->get(orig_obj);\n+  assert(p != nullptr, \"must be\");\n+  return *p;\n+}\n+\n+bool RegeneratedClasses::is_regenerated_object(address regen_obj) {\n+  if (_original_objs == nullptr) {\n@@ -72,1 +93,1 @@\n-    return _renegerated_objs->get(orig_obj) != nullptr;\n+    return _original_objs->get(regen_obj) != nullptr;\n@@ -76,0 +97,7 @@\n+address RegeneratedClasses::get_original_object(address regen_obj) {\n+  assert(_original_objs != nullptr, \"must be\");\n+  address* p =_original_objs->get(regen_obj);\n+  assert(p != nullptr, \"must be\");\n+  return *p;\n+}\n+\n@@ -78,1 +106,1 @@\n-  if (_renegerated_objs != nullptr) {\n+  if (_regenerated_objs != nullptr) {\n@@ -82,1 +110,1 @@\n-    _renegerated_objs->iterate_all(doit);\n+    _regenerated_objs->iterate_all(doit);\n@@ -95,2 +123,2 @@\n-  if (_renegerated_objs != nullptr) {\n-    delete _renegerated_objs;\n+  if (_regenerated_objs != nullptr) {\n+    delete _regenerated_objs;\n","filename":"src\/hotspot\/share\/cds\/regeneratedClasses.cpp","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+  static address get_regenerated_object(address orig_obj); \/\/ orig_obj -> regen_obj\n@@ -47,0 +48,18 @@\n+\n+  \/\/ Handy functions to avoid type casts\n+  template <class T> static bool has_been_regenerated(T orig_obj) {\n+    return has_been_regenerated((address)orig_obj);\n+  }\n+  template <class T> static T get_regenerated_object(T orig_obj) {\n+    return (T)get_regenerated_object((address)orig_obj);\n+  }\n+\n+  static bool is_regenerated_object(address regen_obj);\n+  static address get_original_object(address regen_obj);  \/\/ regen_obj -> orig_obj\n+\n+  template <class T> static bool is_regenerated_object(T regen_obj) {\n+    return is_regenerated_object((address)regen_obj);\n+  }\n+  template <class T> static T get_original_object(T regen_obj) {\n+    return (T)get_original_object((address)regen_obj);\n+  }\n","filename":"src\/hotspot\/share\/cds\/regeneratedClasses.hpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -351,0 +351,7 @@\n+  InstanceKlass* nest_host = k->nest_host_or_null();\n+  if (nest_host != nullptr && nest_host != k && check_for_exclusion(nest_host, nullptr)) {\n+    ResourceMark rm;\n+    aot_log_warning(aot)(\"Skipping %s: nest_host class %s is excluded\", k->name()->as_C_string(), nest_host->name()->as_C_string());\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -447,0 +447,3 @@\n+  InstanceKlass* nest_host_or_null() {\n+    return _nest_host;\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                      .shouldContain(\"ChildOldInf$InnerChild source: shared objects file (top)\")\n+                      .shouldMatch(\".class.load. ChildOldInf[$]InnerChild source:.*oldclassapp.jar\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/NestHostOldInf.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}