{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,4 +40,82 @@\n-ObjectMonitorTable::ConcurrentTable* ObjectMonitorTable::_table = nullptr;\n-volatile size_t ObjectMonitorTable::_items_count = 0;\n-size_t ObjectMonitorTable::_table_size = 0;\n-volatile bool ObjectMonitorTable::_resize = false;\n+using ConcurrentTable = ConcurrentHashTable<ObjectMonitorTableConfig, mtObjectMonitor>;\n+\n+static ConcurrentTable* _table = nullptr;\n+static volatile size_t _items_count = 0;\n+static size_t _table_size = 0;\n+static volatile bool _resize = false;\n+\n+class ObjectMonitorTableConfig : public AllStatic {\n+ public:\n+  using Value = ObjectMonitor*;\n+  static uintx get_hash(Value const& value, bool* is_dead) {\n+    return (uintx)value->hash();\n+  }\n+  static void* allocate_node(void* context, size_t size, Value const& value) {\n+    ObjectMonitorTable::inc_items_count();\n+    return AllocateHeap(size, mtObjectMonitor);\n+  };\n+  static void free_node(void* context, void* memory, Value const& value) {\n+    ObjectMonitorTable::dec_items_count();\n+    FreeHeap(memory);\n+  }\n+};\n+\n+class Lookup : public StackObj {\n+  oop _obj;\n+\n+ public:\n+  explicit Lookup(oop obj) : _obj(obj) {}\n+\n+  uintx get_hash() const {\n+    uintx hash = _obj->mark().hash();\n+    assert(hash != 0, \"should have a hash\");\n+    return hash;\n+  }\n+\n+  bool equals(ObjectMonitor** value) {\n+    assert(*value != nullptr, \"must be\");\n+    return (*value)->object_refers_to(_obj);\n+  }\n+\n+  bool is_dead(ObjectMonitor** value) {\n+    assert(*value != nullptr, \"must be\");\n+    return false;\n+  }\n+};\n+\n+class LookupMonitor : public StackObj {\n+  ObjectMonitor* _monitor;\n+\n+ public:\n+  explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n+\n+  uintx get_hash() const {\n+    return _monitor->hash();\n+  }\n+\n+  bool equals(ObjectMonitor** value) {\n+    return (*value) == _monitor;\n+  }\n+\n+  bool is_dead(ObjectMonitor** value) {\n+    assert(*value != nullptr, \"must be\");\n+    return (*value)->object_is_dead();\n+  }\n+};\n+\n+void ObjectMonitorTable::inc_items_count() {\n+  AtomicAccess::inc(&_items_count, memory_order_relaxed);\n+}\n+\n+void ObjectMonitorTable::dec_items_count() {\n+  AtomicAccess::dec(&_items_count, memory_order_relaxed);\n+}\n+\n+double ObjectMonitorTable::get_load_factor() {\n+  size_t count = AtomicAccess::load(&_items_count);\n+  return (double)count \/ (double)_table_size;\n+}\n+\n+size_t ObjectMonitorTable::table_size(Thread* current) {\n+  return ((size_t)1) << _table->get_size_log2(current);\n+}\n@@ -58,0 +136,19 @@\n+\/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n+size_t ObjectMonitorTable::min_log_size() {\n+  return 10;\n+}\n+\n+template<typename V>\n+size_t ObjectMonitorTable::clamp_log_size(V log_size) {\n+  return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n+}\n+\n+size_t ObjectMonitorTable::initial_log_size() {\n+  const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n+  return clamp_log_size(estimate);\n+}\n+\n+size_t ObjectMonitorTable::grow_hint() {\n+  return ConcurrentTable::DEFAULT_GROW_HINT;\n+}\n+\n@@ -61,1 +158,1 @@\n-  _table_size = table_size();\n+  _table_size = table_size(Thread::current());\n@@ -106,1 +203,1 @@\n-template<typename Task, typename... Args>\n+template <typename Task, typename... Args>\n","filename":"src\/hotspot\/share\/runtime\/objectMonitorTable.cpp","additions":104,"deletions":7,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,6 +25,0 @@\n-#include \"memory\/allStatic.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/objectMonitor.hpp\"\n-#include \"utilities\/concurrentHashTable.inline.hpp\"\n-\n@@ -34,72 +28,3 @@\n-class ObjectMonitorTable : AllStatic {\n-  struct Config {\n-    using Value = ObjectMonitor*;\n-    static uintx get_hash(Value const& value, bool* is_dead) {\n-      return (uintx)value->hash();\n-    }\n-    static void* allocate_node(void* context, size_t size, Value const& value) {\n-      ObjectMonitorTable::inc_items_count();\n-      return AllocateHeap(size, mtObjectMonitor);\n-    };\n-    static void free_node(void* context, void* memory, Value const& value) {\n-      ObjectMonitorTable::dec_items_count();\n-      FreeHeap(memory);\n-    }\n-  };\n-  using ConcurrentTable = ConcurrentHashTable<Config, mtObjectMonitor>;\n-\n-  static ConcurrentTable* _table;\n-  static volatile size_t _items_count;\n-  static size_t _table_size;\n-  static volatile bool _resize;\n-\n-  class Lookup : public StackObj {\n-    oop _obj;\n-\n-   public:\n-    explicit Lookup(oop obj) : _obj(obj) {}\n-\n-    uintx get_hash() const {\n-      uintx hash = _obj->mark().hash();\n-      assert(hash != 0, \"should have a hash\");\n-      return hash;\n-    }\n-\n-    bool equals(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return (*value)->object_refers_to(_obj);\n-    }\n-\n-    bool is_dead(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return false;\n-    }\n-  };\n-\n-  class LookupMonitor : public StackObj {\n-    ObjectMonitor* _monitor;\n-\n-   public:\n-    explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n-\n-    uintx get_hash() const {\n-      return _monitor->hash();\n-    }\n-\n-    bool equals(ObjectMonitor** value) {\n-      return (*value) == _monitor;\n-    }\n-\n-    bool is_dead(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return (*value)->object_is_dead();\n-    }\n-  };\n-\n-  static void inc_items_count() {\n-    AtomicAccess::inc(&_items_count, memory_order_relaxed);\n-  }\n-\n-  static void dec_items_count() {\n-    AtomicAccess::dec(&_items_count, memory_order_relaxed);\n-  }\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -107,4 +32,5 @@\n-  static double get_load_factor() {\n-    size_t count = AtomicAccess::load(&_items_count);\n-    return (double)count \/ (double)_table_size;\n-  }\n+class JavaThread;\n+class ObjectMonitor;\n+class ObjectMonitorTableConfig;\n+class outputStream;\n+class Thread;\n@@ -112,3 +38,2 @@\n-  static size_t table_size(Thread* current = Thread::current()) {\n-    return ((size_t)1) << _table->get_size_log2(current);\n-  }\n+class ObjectMonitorTable : AllStatic {\n+  friend class ObjectMonitorTableConfig;\n@@ -116,0 +41,5 @@\n+ private:\n+  static void inc_items_count();\n+  static void dec_items_count();\n+  static double get_load_factor();\n+  static size_t table_size(Thread* current);\n@@ -117,0 +47,1 @@\n+  static size_t min_log_size();\n@@ -118,16 +49,4 @@\n-  \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n-  static size_t min_log_size() { return 10; }\n-\n-  template<typename V>\n-  static size_t clamp_log_size(V log_size) {\n-    return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n-  }\n-\n-  static size_t initial_log_size() {\n-    const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n-    return clamp_log_size(estimate);\n-  }\n-\n-  static size_t grow_hint () {\n-    return ConcurrentTable::DEFAULT_GROW_HINT;\n-  }\n+  template <typename V>\n+  static size_t clamp_log_size(V log_size);\n+  static size_t initial_log_size();\n+  static size_t grow_hint();\n@@ -147,1 +66,1 @@\n-  template<typename Task, typename... Args>\n+  template <typename Task, typename... Args>\n","filename":"src\/hotspot\/share\/runtime\/objectMonitorTable.hpp","additions":22,"deletions":103,"binary":false,"changes":125,"status":"modified"}]}