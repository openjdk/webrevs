{"files":[{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/objectMonitorTable.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ -----------------------------------------------------------------------------\n+\/\/ ConcurrentHashTable storing links from objects to ObjectMonitors\n+\n+ObjectMonitorTable::ConcurrentTable* ObjectMonitorTable::_table = nullptr;\n+volatile size_t ObjectMonitorTable::_items_count = 0;\n+size_t ObjectMonitorTable::_table_size = 0;\n+volatile bool ObjectMonitorTable::_resize = false;\n+\n+size_t ObjectMonitorTable::max_log_size() {\n+  \/\/ TODO[OMTable]: Evaluate the max size.\n+  \/\/ TODO[OMTable]: Need to fix init order to use Universe::heap()->max_capacity();\n+  \/\/                Using MaxHeapSize directly this early may be wrong, and there\n+  \/\/                are definitely rounding errors (alignment).\n+  const size_t max_capacity = MaxHeapSize;\n+  const size_t min_object_size = CollectedHeap::min_dummy_object_size() * HeapWordSize;\n+  const size_t max_objects = max_capacity \/ MAX2(MinObjAlignmentInBytes, checked_cast<int>(min_object_size));\n+  const size_t log_max_objects = log2i_graceful(max_objects);\n+\n+  return MAX2(MIN2<size_t>(SIZE_BIG_LOG2, log_max_objects), min_log_size());\n+}\n+\n+void ObjectMonitorTable::create() {\n+  _table = new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint());\n+  _items_count = 0;\n+  _table_size = table_size();\n+  _resize = false;\n+}\n+\n+void ObjectMonitorTable::verify_monitor_get_result(oop obj, ObjectMonitor* monitor) {\n+#ifdef ASSERT\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    bool has_monitor = obj->mark().has_monitor();\n+    assert(has_monitor == (monitor != nullptr),\n+           \"Inconsistency between markWord and ObjectMonitorTable has_monitor: %s monitor: \" PTR_FORMAT,\n+           BOOL_TO_STR(has_monitor), p2i(monitor));\n+  }\n+#endif\n+}\n+\n+ObjectMonitor* ObjectMonitorTable::monitor_get(Thread* current, oop obj) {\n+  ObjectMonitor* result = nullptr;\n+  Lookup lookup_f(obj);\n+  auto found_f = [&](ObjectMonitor** found) {\n+    assert((*found)->object_peek() == obj, \"must be\");\n+    result = *found;\n+  };\n+  _table->get(current, lookup_f, found_f);\n+  verify_monitor_get_result(obj, result);\n+  return result;\n+}\n+\n+void ObjectMonitorTable::try_notify_grow() {\n+  if (!_table->is_max_size_reached() && !AtomicAccess::load(&_resize)) {\n+    AtomicAccess::store(&_resize, true);\n+    if (Service_lock->try_lock()) {\n+      Service_lock->notify();\n+      Service_lock->unlock();\n+    }\n+  }\n+}\n+\n+bool ObjectMonitorTable::should_grow() {\n+  return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n+}\n+\n+bool ObjectMonitorTable::should_resize() {\n+  return should_grow() || should_shrink() || AtomicAccess::load(&_resize);\n+}\n+\n+template<typename Task, typename... Args>\n+bool ObjectMonitorTable::run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n+  if (task.prepare(current)) {\n+    log_trace(monitortable)(\"Started to %s\", task_name);\n+    TraceTime timer(task_name, TRACETIME_LOG(Debug, monitortable, perf));\n+    while (task.do_task(current, args...)) {\n+      task.pause(current);\n+      {\n+        ThreadBlockInVM tbivm(current);\n+      }\n+      task.cont(current);\n+    }\n+    task.done(current);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool ObjectMonitorTable::grow(JavaThread* current) {\n+  ConcurrentTable::GrowTask grow_task(_table);\n+  if (run_task(current, grow_task, \"Grow\")) {\n+    _table_size = table_size(current);\n+    log_info(monitortable)(\"Grown to size: %zu\", _table_size);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool ObjectMonitorTable::clean(JavaThread* current) {\n+  ConcurrentTable::BulkDeleteTask clean_task(_table);\n+  auto is_dead = [&](ObjectMonitor** monitor) {\n+    return (*monitor)->object_is_dead();\n+  };\n+  auto do_nothing = [&](ObjectMonitor** monitor) {};\n+  NativeHeapTrimmer::SuspendMark sm(\"ObjectMonitorTable\");\n+  return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n+}\n+\n+bool ObjectMonitorTable::resize(JavaThread* current) {\n+  LogTarget(Info, monitortable) lt;\n+  bool success = false;\n+\n+  if (should_grow()) {\n+    lt.print(\"Start growing with load factor %f\", get_load_factor());\n+    success = grow(current);\n+  } else {\n+    if (!_table->is_max_size_reached() && AtomicAccess::load(&_resize)) {\n+      lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n+    }\n+    lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n+    success = clean(current);\n+  }\n+\n+  AtomicAccess::store(&_resize, false);\n+\n+  return success;\n+}\n+\n+ObjectMonitor* ObjectMonitorTable::monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n+  \/\/ Enter the monitor into the concurrent hashtable.\n+  ObjectMonitor* result = monitor;\n+  Lookup lookup_f(obj);\n+  auto found_f = [&](ObjectMonitor** found) {\n+    assert((*found)->object_peek() == obj, \"must be\");\n+    result = *found;\n+  };\n+  bool grow;\n+  _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n+  verify_monitor_get_result(obj, result);\n+  if (grow) {\n+    try_notify_grow();\n+  }\n+  return result;\n+}\n+\n+bool ObjectMonitorTable::remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n+  LookupMonitor lookup_f(monitor);\n+  return _table->remove(current, lookup_f);\n+}\n+\n+bool ObjectMonitorTable::contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+  LookupMonitor lookup_f(monitor);\n+  bool result = false;\n+  auto found_f = [&](ObjectMonitor** found) {\n+    result = true;\n+  };\n+  _table->get(current, lookup_f, found_f);\n+  return result;\n+}\n+\n+void ObjectMonitorTable::print_on(outputStream* st) {\n+  auto printer = [&] (ObjectMonitor** entry) {\n+    ObjectMonitor* om = *entry;\n+    oop obj = om->object_peek();\n+    st->print(\"monitor=\" PTR_FORMAT \", \", p2i(om));\n+    st->print(\"object=\" PTR_FORMAT, p2i(obj));\n+    assert(obj->mark().hash() == om->hash(), \"hash must match\");\n+    st->cr();\n+    return true;\n+  };\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    _table->do_safepoint_scan(printer);\n+  } else {\n+    _table->do_scan(Thread::current(), printer);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/objectMonitorTable.cpp","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+\n+#ifndef SHARE_RUNTIME_OBJECTMONITORTABLE_HPP\n+#define SHARE_RUNTIME_OBJECTMONITORTABLE_HPP\n+\n+class ObjectMonitorTable : AllStatic {\n+  struct Config {\n+    using Value = ObjectMonitor*;\n+    static uintx get_hash(Value const& value, bool* is_dead) {\n+      return (uintx)value->hash();\n+    }\n+    static void* allocate_node(void* context, size_t size, Value const& value) {\n+      ObjectMonitorTable::inc_items_count();\n+      return AllocateHeap(size, mtObjectMonitor);\n+    };\n+    static void free_node(void* context, void* memory, Value const& value) {\n+      ObjectMonitorTable::dec_items_count();\n+      FreeHeap(memory);\n+    }\n+  };\n+  using ConcurrentTable = ConcurrentHashTable<Config, mtObjectMonitor>;\n+\n+  static ConcurrentTable* _table;\n+  static volatile size_t _items_count;\n+  static size_t _table_size;\n+  static volatile bool _resize;\n+\n+  class Lookup : public StackObj {\n+    oop _obj;\n+\n+   public:\n+    explicit Lookup(oop obj) : _obj(obj) {}\n+\n+    uintx get_hash() const {\n+      uintx hash = _obj->mark().hash();\n+      assert(hash != 0, \"should have a hash\");\n+      return hash;\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_refers_to(_obj);\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return false;\n+    }\n+  };\n+\n+  class LookupMonitor : public StackObj {\n+    ObjectMonitor* _monitor;\n+\n+   public:\n+    explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n+\n+    uintx get_hash() const {\n+      return _monitor->hash();\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      return (*value) == _monitor;\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_is_dead();\n+    }\n+  };\n+\n+  static void inc_items_count() {\n+    AtomicAccess::inc(&_items_count, memory_order_relaxed);\n+  }\n+\n+  static void dec_items_count() {\n+    AtomicAccess::dec(&_items_count, memory_order_relaxed);\n+  }\n+\n+  static double get_load_factor() {\n+    size_t count = AtomicAccess::load(&_items_count);\n+    return (double)count \/ (double)_table_size;\n+  }\n+\n+  static size_t table_size(Thread* current = Thread::current()) {\n+    return ((size_t)1) << _table->get_size_log2(current);\n+  }\n+\n+  static size_t max_log_size();\n+\n+  \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n+  static size_t min_log_size() { return 10; }\n+\n+  template<typename V>\n+  static size_t clamp_log_size(V log_size) {\n+    return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n+  }\n+\n+  static size_t initial_log_size() {\n+    const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n+    return clamp_log_size(estimate);\n+  }\n+\n+  static size_t grow_hint () {\n+    return ConcurrentTable::DEFAULT_GROW_HINT;\n+  }\n+\n+ public:\n+  static void create();\n+  static void verify_monitor_get_result(oop obj, ObjectMonitor* monitor);\n+  static ObjectMonitor* monitor_get(Thread* current, oop obj);\n+  static void try_notify_grow();\n+  static bool should_shrink() { return false; } \/\/ Not implemented\n+\n+  static constexpr double GROW_LOAD_FACTOR = 0.75;\n+\n+  static bool should_grow();\n+  static bool should_resize();\n+\n+  template<typename Task, typename... Args>\n+  static bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args);\n+  static bool grow(JavaThread* current);\n+  static bool clean(JavaThread* current);\n+  static bool resize(JavaThread* current);\n+  static ObjectMonitor* monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj);\n+  static bool remove_monitor_entry(Thread* current, ObjectMonitor* monitor);\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor);\n+  static void print_on(outputStream* st);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_OBJECTMONITORTABLE_HPP\n","filename":"src\/hotspot\/share\/runtime\/objectMonitorTable.hpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/objectMonitorTable.hpp\"\n@@ -1473,285 +1474,0 @@\n-\/\/ -----------------------------------------------------------------------------\n-\/\/ ConcurrentHashTable storing links from objects to ObjectMonitors\n-class ObjectMonitorTable : AllStatic {\n-  struct Config {\n-    using Value = ObjectMonitor*;\n-    static uintx get_hash(Value const& value, bool* is_dead) {\n-      return (uintx)value->hash();\n-    }\n-    static void* allocate_node(void* context, size_t size, Value const& value) {\n-      ObjectMonitorTable::inc_items_count();\n-      return AllocateHeap(size, mtObjectMonitor);\n-    };\n-    static void free_node(void* context, void* memory, Value const& value) {\n-      ObjectMonitorTable::dec_items_count();\n-      FreeHeap(memory);\n-    }\n-  };\n-  using ConcurrentTable = ConcurrentHashTable<Config, mtObjectMonitor>;\n-\n-  static ConcurrentTable* _table;\n-  static volatile size_t _items_count;\n-  static size_t _table_size;\n-  static volatile bool _resize;\n-\n-  class Lookup : public StackObj {\n-    oop _obj;\n-\n-   public:\n-    explicit Lookup(oop obj) : _obj(obj) {}\n-\n-    uintx get_hash() const {\n-      uintx hash = _obj->mark().hash();\n-      assert(hash != 0, \"should have a hash\");\n-      return hash;\n-    }\n-\n-    bool equals(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return (*value)->object_refers_to(_obj);\n-    }\n-\n-    bool is_dead(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return false;\n-    }\n-  };\n-\n-  class LookupMonitor : public StackObj {\n-    ObjectMonitor* _monitor;\n-\n-   public:\n-    explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n-\n-    uintx get_hash() const {\n-      return _monitor->hash();\n-    }\n-\n-    bool equals(ObjectMonitor** value) {\n-      return (*value) == _monitor;\n-    }\n-\n-    bool is_dead(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return (*value)->object_is_dead();\n-    }\n-  };\n-\n-  static void inc_items_count() {\n-    AtomicAccess::inc(&_items_count, memory_order_relaxed);\n-  }\n-\n-  static void dec_items_count() {\n-    AtomicAccess::dec(&_items_count, memory_order_relaxed);\n-  }\n-\n-  static double get_load_factor() {\n-    size_t count = AtomicAccess::load(&_items_count);\n-    return (double)count \/ (double)_table_size;\n-  }\n-\n-  static size_t table_size(Thread* current = Thread::current()) {\n-    return ((size_t)1) << _table->get_size_log2(current);\n-  }\n-\n-  static size_t max_log_size() {\n-    \/\/ TODO[OMTable]: Evaluate the max size.\n-    \/\/ TODO[OMTable]: Need to fix init order to use Universe::heap()->max_capacity();\n-    \/\/                Using MaxHeapSize directly this early may be wrong, and there\n-    \/\/                are definitely rounding errors (alignment).\n-    const size_t max_capacity = MaxHeapSize;\n-    const size_t min_object_size = CollectedHeap::min_dummy_object_size() * HeapWordSize;\n-    const size_t max_objects = max_capacity \/ MAX2(MinObjAlignmentInBytes, checked_cast<int>(min_object_size));\n-    const size_t log_max_objects = log2i_graceful(max_objects);\n-\n-    return MAX2(MIN2<size_t>(SIZE_BIG_LOG2, log_max_objects), min_log_size());\n-  }\n-\n-  static size_t min_log_size() {\n-    \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n-    return 10;\n-  }\n-\n-  template<typename V>\n-  static size_t clamp_log_size(V log_size) {\n-    return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n-  }\n-\n-  static size_t initial_log_size() {\n-    const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n-    return clamp_log_size(estimate);\n-  }\n-\n-  static size_t grow_hint () {\n-    return ConcurrentTable::DEFAULT_GROW_HINT;\n-  }\n-\n- public:\n-  static void create() {\n-    _table = new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint());\n-    _items_count = 0;\n-    _table_size = table_size();\n-    _resize = false;\n-  }\n-\n-  static void verify_monitor_get_result(oop obj, ObjectMonitor* monitor) {\n-#ifdef ASSERT\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      bool has_monitor = obj->mark().has_monitor();\n-      assert(has_monitor == (monitor != nullptr),\n-          \"Inconsistency between markWord and ObjectMonitorTable has_monitor: %s monitor: \" PTR_FORMAT,\n-          BOOL_TO_STR(has_monitor), p2i(monitor));\n-    }\n-#endif\n-  }\n-\n-  static ObjectMonitor* monitor_get(Thread* current, oop obj) {\n-    ObjectMonitor* result = nullptr;\n-    Lookup lookup_f(obj);\n-    auto found_f = [&](ObjectMonitor** found) {\n-      assert((*found)->object_peek() == obj, \"must be\");\n-      result = *found;\n-    };\n-    _table->get(current, lookup_f, found_f);\n-    verify_monitor_get_result(obj, result);\n-    return result;\n-  }\n-\n-  static void try_notify_grow() {\n-    if (!_table->is_max_size_reached() && !AtomicAccess::load(&_resize)) {\n-      AtomicAccess::store(&_resize, true);\n-      if (Service_lock->try_lock()) {\n-        Service_lock->notify();\n-        Service_lock->unlock();\n-      }\n-    }\n-  }\n-\n-  static bool should_shrink() {\n-    \/\/ Not implemented;\n-    return false;\n-  }\n-\n-  static constexpr double GROW_LOAD_FACTOR = 0.75;\n-\n-  static bool should_grow() {\n-    return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n-  }\n-\n-  static bool should_resize() {\n-    return should_grow() || should_shrink() || AtomicAccess::load(&_resize);\n-  }\n-\n-  template<typename Task, typename... Args>\n-  static bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n-    if (task.prepare(current)) {\n-      log_trace(monitortable)(\"Started to %s\", task_name);\n-      TraceTime timer(task_name, TRACETIME_LOG(Debug, monitortable, perf));\n-      while (task.do_task(current, args...)) {\n-        task.pause(current);\n-        {\n-          ThreadBlockInVM tbivm(current);\n-        }\n-        task.cont(current);\n-      }\n-      task.done(current);\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  static bool grow(JavaThread* current) {\n-    ConcurrentTable::GrowTask grow_task(_table);\n-    if (run_task(current, grow_task, \"Grow\")) {\n-      _table_size = table_size(current);\n-      log_info(monitortable)(\"Grown to size: %zu\", _table_size);\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  static bool clean(JavaThread* current) {\n-    ConcurrentTable::BulkDeleteTask clean_task(_table);\n-    auto is_dead = [&](ObjectMonitor** monitor) {\n-      return (*monitor)->object_is_dead();\n-    };\n-    auto do_nothing = [&](ObjectMonitor** monitor) {};\n-    NativeHeapTrimmer::SuspendMark sm(\"ObjectMonitorTable\");\n-    return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n-  }\n-\n-  static bool resize(JavaThread* current) {\n-    LogTarget(Info, monitortable) lt;\n-    bool success = false;\n-\n-    if (should_grow()) {\n-      lt.print(\"Start growing with load factor %f\", get_load_factor());\n-      success = grow(current);\n-    } else {\n-      if (!_table->is_max_size_reached() && AtomicAccess::load(&_resize)) {\n-        lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n-      }\n-      lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n-      success = clean(current);\n-    }\n-\n-    AtomicAccess::store(&_resize, false);\n-\n-    return success;\n-  }\n-\n-  static ObjectMonitor* monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n-    \/\/ Enter the monitor into the concurrent hashtable.\n-    ObjectMonitor* result = monitor;\n-    Lookup lookup_f(obj);\n-    auto found_f = [&](ObjectMonitor** found) {\n-      assert((*found)->object_peek() == obj, \"must be\");\n-      result = *found;\n-    };\n-    bool grow;\n-    _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n-    verify_monitor_get_result(obj, result);\n-    if (grow) {\n-      try_notify_grow();\n-    }\n-    return result;\n-  }\n-\n-  static bool remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n-    LookupMonitor lookup_f(monitor);\n-    return _table->remove(current, lookup_f);\n-  }\n-\n-  static bool contains_monitor(Thread* current, ObjectMonitor* monitor) {\n-    LookupMonitor lookup_f(monitor);\n-    bool result = false;\n-    auto found_f = [&](ObjectMonitor** found) {\n-      result = true;\n-    };\n-    _table->get(current, lookup_f, found_f);\n-    return result;\n-  }\n-\n-  static void print_on(outputStream* st) {\n-    auto printer = [&] (ObjectMonitor** entry) {\n-       ObjectMonitor* om = *entry;\n-       oop obj = om->object_peek();\n-       st->print(\"monitor=\" PTR_FORMAT \", \", p2i(om));\n-       st->print(\"object=\" PTR_FORMAT, p2i(obj));\n-       assert(obj->mark().hash() == om->hash(), \"hash must match\");\n-       st->cr();\n-       return true;\n-    };\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      _table->do_safepoint_scan(printer);\n-    } else {\n-      _table->do_scan(Thread::current(), printer);\n-    }\n-  }\n-};\n-\n-ObjectMonitorTable::ConcurrentTable* ObjectMonitorTable::_table = nullptr;\n-volatile size_t ObjectMonitorTable::_items_count = 0;\n-size_t ObjectMonitorTable::_table_size = 0;\n-volatile bool ObjectMonitorTable::_resize = false;\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":285,"binary":false,"changes":286,"status":"modified"}]}