{"files":[{"patch":"@@ -83,0 +83,1 @@\n+      init_req_with_scalar(p0,   vtn, MemNode::Control);\n@@ -88,0 +89,1 @@\n+      init_req_with_scalar(p0,   vtn, MemNode::Control);\n@@ -96,19 +98,18 @@\n-    } else {\n-      assert(vtn->isa_ElementWiseVector() != nullptr, \"all other vtnodes are handled above\");\n-      if (VectorNode::is_scalar_rotate(p0) &&\n-          p0->in(2)->is_Con() &&\n-          Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n-        init_req_with_vector(pack, vtn, 1);\n-        init_req_with_scalar(p0,   vtn, 2); \/\/ constant rotation\n-      } else if (VectorNode::is_roundopD(p0)) {\n-        init_req_with_vector(pack, vtn, 1);\n-        init_req_with_scalar(p0,   vtn, 2); \/\/ constant rounding mode\n-      } else if (p0->is_CMove()) {\n-        \/\/ Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n-        set_all_req_with_vectors(pack, vtn);\n-        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(1)->isa_BoolVector();\n-        if (vtn_mask_cmp->test()._is_negated) {\n-          vtn->swap_req(2, 3); \/\/ swap if test was negated.\n-        }\n-      } else {\n-        set_all_req_with_vectors(pack, vtn);\n+    } else if (VectorNode::is_scalar_rotate(p0) &&\n+               p0->in(2)->is_Con() &&\n+               Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n+      init_req_with_vector(pack, vtn, 1);\n+      init_req_with_scalar(p0,   vtn, 2); \/\/ constant rotation\n+    } else if (VectorNode::is_roundopD(p0)) {\n+      init_req_with_vector(pack, vtn, 1);\n+      init_req_with_scalar(p0,   vtn, 2); \/\/ constant rounding mode\n+    } else if (p0->is_CMove()) {\n+      \/\/ Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n+      init_all_req_with_vectors(pack, vtn);\n+      \/\/ Inputs must be permuted from (mask, blend1, blend2) -> (blend1, blend2, mask)\n+      vtn->swap_req(1, 2);\n+      vtn->swap_req(2, 3);\n+      \/\/ If the test was negated: (blend1, blend2, mask) -> (blend2, blend1, mask)\n+      VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(3)->isa_BoolVector();\n+      if (vtn_mask_cmp->test()._is_negated) {\n+        vtn->swap_req(1, 2); \/\/ swap if test was negated.\n@@ -116,0 +117,2 @@\n+    } else {\n+      init_all_req_with_vectors(pack, vtn);\n@@ -142,1 +145,1 @@\n-      set_all_req_with_scalars(n, vtn);\n+      init_all_req_with_scalars(n, vtn);\n@@ -149,1 +152,0 @@\n-  uint pack_size = pack->size();\n@@ -151,2 +153,4 @@\n-  int opc = p0->Opcode();\n-  VTransformVectorNode* vtn = nullptr;\n+  const VTransformVectorNodeProperties properties = VTransformVectorNodeProperties::make_from_pack(pack, _vloop_analyzer);\n+  const int sopc     = properties.scalar_opcode();\n+  const uint vlen    = properties.vector_length();\n+  const BasicType bt = properties.element_basic_type();\n@@ -154,0 +158,1 @@\n+  VTransformVectorNode* vtn = nullptr;\n@@ -156,2 +161,2 @@\n-    const VPointer vector_p(scalar_p.make_with_size(scalar_p.size() * pack_size));\n-    vtn = new (_vtransform.arena()) VTransformLoadVectorNode(_vtransform, pack_size, vector_p);\n+    const VPointer vector_p(scalar_p.make_with_size(scalar_p.size() * vlen));\n+    vtn = new (_vtransform.arena()) VTransformLoadVectorNode(_vtransform, properties, vector_p, p0->adr_type());\n@@ -160,2 +165,4 @@\n-    const VPointer vector_p(scalar_p.make_with_size(scalar_p.size() * pack_size));\n-    vtn = new (_vtransform.arena()) VTransformStoreVectorNode(_vtransform, pack_size, vector_p);\n+    const VPointer vector_p(scalar_p.make_with_size(scalar_p.size() * vlen));\n+    vtn = new (_vtransform.arena()) VTransformStoreVectorNode(_vtransform, properties, vector_p, p0->adr_type());\n+  } else if (p0->is_Cmp()) {\n+    vtn = new (_vtransform.arena()) VTransformCmpVectorNode(_vtransform, properties);\n@@ -164,1 +171,3 @@\n-    vtn = new (_vtransform.arena()) VTransformBoolVectorNode(_vtransform, pack_size, kind);\n+    vtn = new (_vtransform.arena()) VTransformBoolVectorNode(_vtransform, properties, kind);\n+  } else if (p0->is_CMove()) {\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), properties, Op_VectorBlend);\n@@ -166,1 +175,1 @@\n-    vtn = new (_vtransform.arena()) VTransformReductionVectorNode(_vtransform, pack_size);\n+    vtn = new (_vtransform.arena()) VTransformReductionVectorNode(_vtransform, properties);\n@@ -172,1 +181,16 @@\n-    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, 3, pack_size);\n+    int vopc = VectorNode::opcode(sopc, bt);\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, 3, properties, vopc);\n+  } else if (VectorNode::is_convert_opcode(sopc)) {\n+    assert(p0->req() == 2, \"convert should have 2 operands\");\n+    BasicType def_bt = _vloop_analyzer.types().velt_basic_type(p0->in(1));\n+    int vopc = VectorCastNode::opcode(sopc, def_bt);\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), properties, vopc);\n+  } else if (VectorNode::is_reinterpret_opcode(sopc)) {\n+    assert(p0->req() == 2, \"reinterpret should have 2 operands\");\n+    BasicType src_bt = _vloop_analyzer.types().velt_basic_type(p0->in(1));\n+    vtn = new (_vtransform.arena()) VTransformReinterpretVectorNode(_vtransform, properties, src_bt);\n+  } else if (VectorNode::can_use_RShiftI_instead_of_URShiftI(p0, bt)) {\n+    int vopc = VectorNode::opcode(Op_RShiftI, bt);\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), properties, vopc);\n+  } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(sopc)) {\n+    vtn = new (_vtransform.arena()) VTransformElementWiseLongOpWithCastToIntVectorNode(_vtransform, properties);\n@@ -175,10 +199,8 @@\n-           p0->is_CMove() ||\n-           VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc) ||\n-           VectorNode::is_convert_opcode(opc) ||\n-           VectorNode::is_reinterpret_opcode(opc) ||\n-           VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc) ||\n-           opc == Op_FmaD  ||\n-           opc == Op_FmaF  ||\n-           opc == Op_FmaHF ||\n-           opc == Op_SignumF ||\n-           opc == Op_SignumD,\n+           VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(sopc) ||\n+           VectorNode::is_reinterpret_opcode(sopc) ||\n+           VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(sopc) ||\n+           sopc == Op_FmaD  ||\n+           sopc == Op_FmaF  ||\n+           sopc == Op_FmaHF ||\n+           sopc == Op_SignumF ||\n+           sopc == Op_SignumD,\n@@ -186,1 +208,3 @@\n-    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), pack_size);\n+    assert(!VectorNode::is_roundopD(p0) || p0->in(2)->is_Con(), \"rounding mode must be constant\");\n+    int vopc = VectorNode::opcode(sopc, bt);\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), properties, vopc);\n@@ -294,1 +318,1 @@\n-void SuperWordVTransformBuilder::set_all_req_with_scalars(Node* n, VTransformNode* vtn) {\n+void SuperWordVTransformBuilder::init_all_req_with_scalars(Node* n, VTransformNode* vtn) {\n@@ -303,1 +327,1 @@\n-void SuperWordVTransformBuilder::set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn) {\n+void SuperWordVTransformBuilder::init_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn) {\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":67,"deletions":43,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-  void set_all_req_with_scalars(Node* n, VTransformNode* vtn);\n-  void set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn);\n+  void init_all_req_with_scalars(Node* n, VTransformNode* vtn);\n+  void init_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn);\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-  if (_trace._verbose) {\n+  if (_trace._info) {\n@@ -161,1 +161,1 @@\n-      VTransformVectorNode* vtn = vtnodes.at(i)->isa_Vector();\n+      VTransformMemVectorNode* vtn = vtnodes.at(i)->isa_MemVector();\n@@ -163,3 +163,1 @@\n-      MemNode* p0 = vtn->nodes().at(0)->isa_Mem();\n-      if (p0 == nullptr) { continue; }\n-      const VPointer& vp = vpointer(p0);\n+      const VPointer& vp = vtn->vpointer();\n@@ -723,1 +721,1 @@\n-  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  \/\/ This was just wrapped. Now we simply unwrap without touching the inputs.\n@@ -728,1 +726,1 @@\n-  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  \/\/ This was just wrapped. Now we simply unwrap without touching the inputs.\n@@ -733,1 +731,1 @@\n-  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  \/\/ This was just wrapped. Now we simply unwrap without touching the inputs.\n@@ -738,1 +736,1 @@\n-  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  \/\/ This was just wrapped. Now we simply unwrap without touching the inputs.\n@@ -743,1 +741,1 @@\n-  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  \/\/ This was just wrapped. Now we simply unwrap without touching the inputs.\n@@ -750,2 +748,2 @@\n-  register_new_node_from_vectorization(apply_state, vn, val);\n-  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+  register_new_node_from_vectorization(apply_state, vn);\n+  return VTransformApplyResult::make_vector(vn);\n@@ -757,1 +755,1 @@\n-  register_new_node_from_vectorization(apply_state, n, val);\n+  register_new_node_from_vectorization(apply_state, n);\n@@ -769,1 +767,1 @@\n-  register_new_node_from_vectorization(apply_state, shift_count_masked, shift_count_in);\n+  register_new_node_from_vectorization(apply_state, shift_count_masked);\n@@ -772,2 +770,2 @@\n-  register_new_node_from_vectorization(apply_state, vn, shift_count_in);\n-  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+  register_new_node_from_vectorization(apply_state, vn);\n+  return VTransformApplyResult::make_vector(vn);\n@@ -784,2 +782,2 @@\n-  register_new_node_from_vectorization(apply_state, vn, val);\n-  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+  register_new_node_from_vectorization(apply_state, vn);\n+  return VTransformApplyResult::make_vector(vn);\n@@ -789,10 +787,1 @@\n-  Node* first = nodes().at(0);\n-  uint  vlen = nodes().length();\n-  int   opc  = first->Opcode();\n-  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n-\n-  if (first->is_Cmp()) {\n-    \/\/ Cmp + Bool -> VectorMaskCmp\n-    \/\/ Handled by Bool \/ VTransformBoolVectorNode, so we do not generate any nodes here.\n-    return VTransformApplyResult::make_empty();\n-  }\n+  const TypeVect* vt = TypeVect::make(element_basic_type(), vector_length());\n@@ -801,1 +790,0 @@\n-  VectorNode* vn = nullptr;\n@@ -806,25 +794,3 @@\n-  if (first->is_CMove()) {\n-    assert(req() == 4, \"three inputs expected: mask, blend1, blend2\");\n-    vn = new VectorBlendNode(\/* blend1 *\/ in2, \/* blend2 *\/ in3, \/* mask *\/ in1);\n-  } else if (VectorNode::is_convert_opcode(opc)) {\n-    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n-    int vopc = VectorCastNode::opcode(opc, in1->bottom_type()->is_vect()->element_basic_type());\n-    vn = VectorCastNode::make(vopc, in1, bt, vlen);\n-  } else if (VectorNode::is_reinterpret_opcode(opc)) {\n-    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n-    const TypeVect* vt = TypeVect::make(bt, vlen);\n-    vn = new VectorReinterpretNode(in1, in1->bottom_type()->is_vect(), vt);\n-  } else if (VectorNode::can_use_RShiftI_instead_of_URShiftI(first, bt)) {\n-    opc = Op_RShiftI;\n-    vn = VectorNode::make(opc, in1, in2, vlen, bt);\n-  } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc)) {\n-    \/\/ The scalar operation was a long -> int operation.\n-    \/\/ However, the vector operation is long -> long.\n-    VectorNode* long_vn = VectorNode::make(opc, in1, nullptr, vlen, T_LONG);\n-    register_new_node_from_vectorization(apply_state, long_vn, first);\n-    \/\/ Cast long -> int, to mimic the scalar long -> int operation.\n-    vn = VectorCastNode::make(Op_VectorCastL2X, long_vn, T_INT, vlen);\n-  } else if (req() == 3 ||\n-             VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc)) {\n-    assert(!VectorNode::is_roundopD(first) || in2->is_Con(), \"rounding mode must be constant\");\n-    vn = VectorNode::make(opc, in1, in2, vlen, bt); \/\/ unary and binary\n+  VectorNode* vn = nullptr;\n+  if (req() <= 3) {\n+    vn = VectorNode::make(_vector_opcode, in1, in2, vt); \/\/ unary and binary\n@@ -832,8 +798,1 @@\n-    assert(req() == 4, \"three inputs expected\");\n-    assert(opc == Op_FmaD  ||\n-           opc == Op_FmaF  ||\n-           opc == Op_FmaHF ||\n-           opc == Op_SignumF ||\n-           opc == Op_SignumD,\n-           \"element wise operation must be from this list\");\n-    vn = VectorNode::make(opc, in1, in2, in3, vlen, bt); \/\/ ternary\n+    vn = VectorNode::make(_vector_opcode, in1, in2, in3, vt); \/\/ ternary\n@@ -843,1 +802,28 @@\n-  return VTransformApplyResult::make_vector(vn, vlen, vn->length_in_bytes());\n+  return VTransformApplyResult::make_vector(vn);\n+}\n+\n+VTransformApplyResult VTransformElementWiseLongOpWithCastToIntVectorNode::apply(VTransformApplyState& apply_state) const {\n+  uint vlen = vector_length();\n+  int sopc  = scalar_opcode();\n+  Node* in1 = apply_state.transformed_node(in_req(1));\n+\n+  \/\/ The scalar operation was a long -> int operation.\n+  \/\/ However, the vector operation is long -> long.\n+  VectorNode* long_vn = VectorNode::make(sopc, in1, nullptr, vlen, T_LONG);\n+  register_new_node_from_vectorization(apply_state, long_vn);\n+  \/\/ Cast long -> int, to mimic the scalar long -> int operation.\n+  VectorNode* vn = VectorCastNode::make(Op_VectorCastL2X, long_vn, T_INT, vlen);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n+  return VTransformApplyResult::make_vector(vn);\n+}\n+\n+VTransformApplyResult VTransformReinterpretVectorNode::apply(VTransformApplyState& apply_state) const {\n+  const TypeVect* dst_vt = TypeVect::make(element_basic_type(), vector_length());\n+  const TypeVect* src_vt = TypeVect::make(_src_bt,              vector_length());\n+  assert(VectorNode::is_reinterpret_opcode(scalar_opcode()), \"scalar opcode must be reinterpret\");\n+\n+  Node* in1 = apply_state.transformed_node(in_req(1));\n+  VectorNode* vn = new VectorReinterpretNode(in1, src_vt, dst_vt);\n+\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n+  return VTransformApplyResult::make_vector(vn);\n@@ -847,3 +833,2 @@\n-  BoolNode* first = nodes().at(0)->as_Bool();\n-  uint  vlen = nodes().length();\n-  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n+  const TypeVect* vt = TypeVect::make(element_basic_type(), vector_length());\n+  assert(scalar_opcode() == Op_Bool, \"\");\n@@ -852,3 +837,2 @@\n-  VTransformElementWiseVectorNode* vtn_cmp = in_req(1)->isa_ElementWiseVector();\n-  assert(vtn_cmp != nullptr && vtn_cmp->nodes().at(0)->is_Cmp(),\n-         \"bool vtn expects cmp vtn as input\");\n+  VTransformCmpVectorNode* vtn_cmp = in_req(1)->isa_CmpVector();\n+  assert(vtn_cmp != nullptr, \"bool vtn expects cmp vtn as input\");\n@@ -862,1 +846,0 @@\n-  const TypeVect* vt = TypeVect::make(bt, vlen);\n@@ -865,1 +848,1 @@\n-  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n+  return VTransformApplyResult::make_vector(vn);\n@@ -869,5 +852,0 @@\n-  Node* first = nodes().at(0);\n-  uint  vlen = nodes().length();\n-  int   opc  = first->Opcode();\n-  BasicType bt = first->bottom_type()->basic_type();\n-\n@@ -877,1 +855,1 @@\n-  ReductionNode* vn = ReductionNode::make(opc, nullptr, init, vec, bt);\n+  ReductionNode* vn = ReductionNode::make(scalar_opcode(), nullptr, init, vec, element_basic_type());\n@@ -879,1 +857,1 @@\n-  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n+  return VTransformApplyResult::make_vector(vn, vn->vect_type());\n@@ -883,0 +861,4 @@\n+  int sopc     = scalar_opcode();\n+  uint vlen    = vector_length();\n+  BasicType bt = element_basic_type();\n+\n@@ -884,2 +866,2 @@\n-  uint  vlen = nodes().length();\n-  Node* ctrl = first->in(MemNode::Control);\n+  Node* ctrl = apply_state.transformed_node(in_req(MemNode::Control));\n+  \/\/ first has the correct memory state, determined by VTransformGraph::apply_memops_reordering_with_schedule\n@@ -887,4 +869,1 @@\n-  Node* adr  = first->in(MemNode::Address);\n-  int   opc  = first->Opcode();\n-  const TypePtr* adr_type = first->adr_type();\n-  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n+  Node* adr  = apply_state.transformed_node(in_req(MemNode::Address));\n@@ -905,1 +884,1 @@\n-  LoadVectorNode* vn = LoadVectorNode::make(opc, ctrl, mem, adr, adr_type, vlen, bt,\n+  LoadVectorNode* vn = LoadVectorNode::make(sopc, ctrl, mem, adr, _adr_type, vlen, bt,\n@@ -909,1 +888,1 @@\n-  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n+  return VTransformApplyResult::make_vector(vn, vn->vect_type());\n@@ -913,0 +892,3 @@\n+  int sopc  = scalar_opcode();\n+  uint vlen = vector_length();\n+\n@@ -914,2 +896,2 @@\n-  uint  vlen = nodes().length();\n-  Node* ctrl = first->in(MemNode::Control);\n+  Node* ctrl = apply_state.transformed_node(in_req(MemNode::Control));\n+  \/\/ first has the correct memory state, determined by VTransformGraph::apply_memops_reordering_with_schedule\n@@ -917,3 +899,1 @@\n-  Node* adr  = first->in(MemNode::Address);\n-  int   opc  = first->Opcode();\n-  const TypePtr* adr_type = first->adr_type();\n+  Node* adr  = apply_state.transformed_node(in_req(MemNode::Address));\n@@ -922,1 +902,1 @@\n-  StoreVectorNode* vn = StoreVectorNode::make(opc, ctrl, mem, adr, adr_type, value, vlen);\n+  StoreVectorNode* vn = StoreVectorNode::make(sopc, ctrl, mem, adr, _adr_type, value, vlen);\n@@ -925,1 +905,1 @@\n-  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n+  return VTransformApplyResult::make_vector(vn, vn->vect_type());\n@@ -930,3 +910,1 @@\n-  Node* first = nodes().at(0);\n-\n-  register_new_node_from_vectorization(apply_state, vn, first);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -940,1 +918,1 @@\n-void VTransformNode::register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn, Node* old_node) const {\n+void VTransformNode::register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn) const {\n@@ -942,1 +920,3 @@\n-  phase->register_new_node_with_ctrl_of(vn, old_node);\n+  \/\/ Using the cl is sometimes not the most accurate, but still correct. We do not have to be\n+  \/\/ perfectly accurate, because we will set major_progress anyway.\n+  phase->register_new_node(vn, apply_state.vloop().cl());\n@@ -1053,9 +1033,6 @@\n-  tty->print(\"%d-pack[\", _nodes.length());\n-  for (int i = 0; i < _nodes.length(); i++) {\n-    Node* n = _nodes.at(i);\n-    if (i > 0) {\n-      tty->print(\", \");\n-    }\n-    tty->print(\"%d %s\", n->_idx, n->Name());\n-  }\n-  tty->print(\"]\");\n+  tty->print(\"Properties[orig=[%d %s] sopc=%s vlen=%d element_bt=%s]\",\n+             approximate_origin()->_idx,\n+             approximate_origin()->Name(),\n+             NodeClassNames[scalar_opcode()],\n+             vector_length(),\n+             type2name(element_basic_type()));\n@@ -1067,0 +1044,17 @@\n+\n+void VTransformElementWiseVectorNode::print_spec() const {\n+  VTransformVectorNode::print_spec();\n+  tty->print(\" vopc=%s\", NodeClassNames[_vector_opcode]);\n+}\n+\n+void VTransformReinterpretVectorNode::print_spec() const {\n+  VTransformVectorNode::print_spec();\n+  tty->print(\" src_bt=%s\", type2name(_src_bt));\n+}\n+\n+void VTransformBoolVectorNode::print_spec() const {\n+  VTransformVectorNode::print_spec();\n+  const BoolTest bt(_test._mask);\n+  tty->print(\" test=\");\n+  bt.dump_on(tty);\n+}\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":101,"deletions":107,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -70,0 +71,1 @@\n+class VTransformCmpVectorNode;\n@@ -93,3 +95,6 @@\n-  static VTransformApplyResult make_vector(Node* n, uint vector_length, uint vector_width) {\n-    assert(vector_length > 0 && vector_width > 0, \"must have nonzero size\");\n-    return VTransformApplyResult(n, vector_length, vector_width);\n+  static VTransformApplyResult make_vector(VectorNode* vn) {\n+    return VTransformApplyResult(vn, vn->length(), vn->length_in_bytes());\n+  }\n+\n+  static VTransformApplyResult make_vector(Node* n, const TypeVect* vt) {\n+    return VTransformApplyResult(n, vt->length(), vt->length_in_bytes());\n@@ -434,0 +439,1 @@\n+  virtual VTransformCmpVectorNode* isa_CmpVector() { return nullptr; }\n@@ -448,1 +454,1 @@\n-  void register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn, Node* old_node) const;\n+  void register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn) const;\n@@ -593,1 +599,33 @@\n-\/\/ Base class for all vector vtnodes.\n+\/\/ Bundle the information needed for vector nodes.\n+class VTransformVectorNodeProperties : public StackObj {\n+private:\n+  Node* _approximate_origin; \/\/ for proper propagation of node notes\n+  const int _scalar_opcode;\n+  const uint _vector_length;\n+  const BasicType _element_basic_type;\n+\n+  VTransformVectorNodeProperties(Node* approximate_origin,\n+                                 int scalar_opcode,\n+                                 uint vector_length,\n+                                 BasicType element_basic_type) :\n+    _approximate_origin(approximate_origin),\n+    _scalar_opcode(scalar_opcode),\n+    _vector_length(vector_length),\n+    _element_basic_type(element_basic_type) {}\n+\n+public:\n+  static VTransformVectorNodeProperties make_from_pack(const Node_List* pack, const VLoopAnalyzer& vloop_analyzer) {\n+    Node* first = pack->at(0);\n+    int opc = first->Opcode();\n+    int vlen = pack->size();\n+    BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+    return VTransformVectorNodeProperties(first, opc, vlen, bt);\n+  }\n+\n+  Node* approximate_origin()     const { return _approximate_origin; }\n+  int scalar_opcode()            const { return _scalar_opcode; }\n+  uint vector_length()           const { return _vector_length; }\n+  BasicType element_basic_type() const { return _element_basic_type; }\n+};\n+\n+\/\/ Abstract base class for all vector vtnodes.\n@@ -596,0 +634,2 @@\n+  const VTransformVectorNodeProperties _properties;\n+protected:\n@@ -598,2 +638,7 @@\n-  VTransformVectorNode(VTransform& vtransform, const uint req, const uint number_of_nodes) :\n-    VTransformNode(vtransform, req), _nodes(vtransform.arena(), number_of_nodes, number_of_nodes, nullptr) {}\n+  VTransformVectorNode(VTransform& vtransform, const uint req, const VTransformVectorNodeProperties properties) :\n+    VTransformNode(vtransform, req),\n+    _properties(properties),\n+    _nodes(vtransform.arena(),\n+           properties.vector_length(),\n+           properties.vector_length(),\n+           nullptr) {}\n@@ -607,1 +652,0 @@\n-  const GrowableArray<Node*>& nodes() const { return _nodes; }\n@@ -611,0 +655,6 @@\n+\n+protected:\n+  Node* approximate_origin()     const { return _properties.approximate_origin(); }\n+  int scalar_opcode()            const { return _properties.scalar_opcode(); }\n+  uint vector_length()           const { return _properties.vector_length(); }\n+  BasicType element_basic_type() const { return _properties.element_basic_type(); }\n@@ -615,0 +665,2 @@\n+private:\n+  const int _vector_opcode;\n@@ -616,2 +668,2 @@\n-  VTransformElementWiseVectorNode(VTransform& vtransform, uint req, uint number_of_nodes) :\n-    VTransformVectorNode(vtransform, req, number_of_nodes) {}\n+  VTransformElementWiseVectorNode(VTransform& vtransform, uint req, const VTransformVectorNodeProperties properties, const int vector_opcode) :\n+    VTransformVectorNode(vtransform, req, properties), _vector_opcode(vector_opcode) {}\n@@ -621,0 +673,23 @@\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ The scalar operation was a long -> int operation.\n+\/\/ However, the vector operation is long -> long.\n+\/\/ Hence, we vectorize it as: long --long_op--> long --cast--> int\n+class VTransformElementWiseLongOpWithCastToIntVectorNode : public VTransformVectorNode {\n+public:\n+  VTransformElementWiseLongOpWithCastToIntVectorNode(VTransform& vtransform, const VTransformVectorNodeProperties properties) :\n+    VTransformVectorNode(vtransform, 2, properties) {}\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ElementWiseLongOpWithCastToIntVector\"; };)\n+};\n+\n+class VTransformReinterpretVectorNode : public VTransformVectorNode {\n+private:\n+  const BasicType _src_bt;\n+public:\n+  VTransformReinterpretVectorNode(VTransform& vtransform, const VTransformVectorNodeProperties properties, const BasicType src_bt) :\n+    VTransformVectorNode(vtransform, 2, properties), _src_bt(src_bt) {}\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ReinterpretVector\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n@@ -631,1 +706,12 @@\n-class VTransformBoolVectorNode : public VTransformElementWiseVectorNode {\n+\/\/ Cmp + Bool -> VectorMaskCmp\n+\/\/ The Bool node takes care of \"apply\".\n+class VTransformCmpVectorNode : public VTransformVectorNode {\n+public:\n+  VTransformCmpVectorNode(VTransform& vtransform, const VTransformVectorNodeProperties properties) :\n+    VTransformVectorNode(vtransform, 3, properties) {}\n+  virtual VTransformCmpVectorNode* isa_CmpVector() override { return this; }\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override { return VTransformApplyResult::make_empty(); }\n+  NOT_PRODUCT(virtual const char* name() const override { return \"CmpVector\"; };)\n+};\n+\n+class VTransformBoolVectorNode : public VTransformVectorNode {\n@@ -635,2 +721,2 @@\n-  VTransformBoolVectorNode(VTransform& vtransform, uint number_of_nodes, VTransformBoolTest test) :\n-    VTransformElementWiseVectorNode(vtransform, 2, number_of_nodes), _test(test) {}\n+  VTransformBoolVectorNode(VTransform& vtransform, const VTransformVectorNodeProperties properties, VTransformBoolTest test) :\n+    VTransformVectorNode(vtransform, 2, properties), _test(test) {}\n@@ -641,0 +727,1 @@\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n@@ -646,2 +733,2 @@\n-  VTransformReductionVectorNode(VTransform& vtransform, uint number_of_nodes) :\n-    VTransformVectorNode(vtransform, 3, number_of_nodes) {}\n+  VTransformReductionVectorNode(VTransform& vtransform, const VTransformVectorNodeProperties properties) :\n+    VTransformVectorNode(vtransform, 3, properties) {}\n@@ -656,0 +743,2 @@\n+protected:\n+  const TypePtr* _adr_type;\n@@ -658,3 +747,4 @@\n-  VTransformMemVectorNode(VTransform& vtransform, const uint req, uint number_of_nodes, const VPointer& vpointer) :\n-    VTransformVectorNode(vtransform, req, number_of_nodes),\n-    _vpointer(vpointer) {}\n+  VTransformMemVectorNode(VTransform& vtransform, const uint req, const VTransformVectorNodeProperties properties, const VPointer& vpointer, const TypePtr* adr_type) :\n+    VTransformVectorNode(vtransform, req, properties),\n+    _vpointer(vpointer),\n+    _adr_type(adr_type) {}\n@@ -662,0 +752,1 @@\n+  const GrowableArray<Node*>& nodes() const { return _nodes; }\n@@ -670,2 +761,2 @@\n-  VTransformLoadVectorNode(VTransform& vtransform, uint number_of_nodes, const VPointer& vpointer) :\n-    VTransformMemVectorNode(vtransform, 3, number_of_nodes, vpointer) {}\n+  VTransformLoadVectorNode(VTransform& vtransform, const VTransformVectorNodeProperties properties, const VPointer& vpointer, const TypePtr* adr_type) :\n+    VTransformMemVectorNode(vtransform, 3, properties, vpointer, adr_type) {}\n@@ -682,2 +773,2 @@\n-  VTransformStoreVectorNode(VTransform& vtransform, uint number_of_nodes, const VPointer& vpointer) :\n-    VTransformMemVectorNode(vtransform, 4, number_of_nodes, vpointer) {}\n+  VTransformStoreVectorNode(VTransform& vtransform, const VTransformVectorNodeProperties properties, const VPointer& vpointer, const TypePtr* adr_type) :\n+    VTransformMemVectorNode(vtransform, 4, properties, vpointer, adr_type) {}\n@@ -706,2 +797,2 @@\n-    VTransformVectorNode* vector = vtn->isa_Vector();\n-    if (vector != nullptr && vector->nodes().at(0)->is_Mem()) {\n+    VTransformMemVectorNode* vector = vtn->isa_MemVector();\n+    if (vector != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":115,"deletions":24,"binary":false,"changes":139,"status":"modified"}]}