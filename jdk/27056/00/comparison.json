{"files":[{"patch":"@@ -83,0 +83,1 @@\n+      init_req_with_scalar(p0,   vtn, MemNode::Control);\n@@ -88,0 +89,1 @@\n+      init_req_with_scalar(p0,   vtn, MemNode::Control);\n@@ -96,19 +98,18 @@\n-    } else {\n-      assert(vtn->isa_ElementWiseVector() != nullptr, \"all other vtnodes are handled above\");\n-      if (VectorNode::is_scalar_rotate(p0) &&\n-          p0->in(2)->is_Con() &&\n-          Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n-        init_req_with_vector(pack, vtn, 1);\n-        init_req_with_scalar(p0,   vtn, 2); \/\/ constant rotation\n-      } else if (VectorNode::is_roundopD(p0)) {\n-        init_req_with_vector(pack, vtn, 1);\n-        init_req_with_scalar(p0,   vtn, 2); \/\/ constant rounding mode\n-      } else if (p0->is_CMove()) {\n-        \/\/ Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n-        set_all_req_with_vectors(pack, vtn);\n-        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(1)->isa_BoolVector();\n-        if (vtn_mask_cmp->test()._is_negated) {\n-          vtn->swap_req(2, 3); \/\/ swap if test was negated.\n-        }\n-      } else {\n-        set_all_req_with_vectors(pack, vtn);\n+    } else if (VectorNode::is_scalar_rotate(p0) &&\n+               p0->in(2)->is_Con() &&\n+               Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n+      init_req_with_vector(pack, vtn, 1);\n+      init_req_with_scalar(p0,   vtn, 2); \/\/ constant rotation\n+    } else if (VectorNode::is_roundopD(p0)) {\n+      init_req_with_vector(pack, vtn, 1);\n+      init_req_with_scalar(p0,   vtn, 2); \/\/ constant rounding mode\n+    } else if (p0->is_CMove()) {\n+      \/\/ Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n+      init_all_req_with_vectors(pack, vtn);\n+      \/\/ Inputs must be permuted from (mask, blend1, blend2) -> (blend1, blend2, mask)\n+      vtn->swap_req(1, 2);\n+      vtn->swap_req(2, 3);\n+      \/\/ If the test was negated: (blend1, blend2, mask) -> (blend2, blend1, mask)\n+      VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(3)->isa_BoolVector();\n+      if (vtn_mask_cmp->test()._is_negated) {\n+        vtn->swap_req(1, 2); \/\/ swap if test was negated.\n@@ -116,0 +117,2 @@\n+    } else {\n+      init_all_req_with_vectors(pack, vtn);\n@@ -142,1 +145,1 @@\n-      set_all_req_with_scalars(n, vtn);\n+      init_all_req_with_scalars(n, vtn);\n@@ -149,1 +152,0 @@\n-  uint pack_size = pack->size();\n@@ -151,2 +153,4 @@\n-  int opc = p0->Opcode();\n-  VTransformVectorNode* vtn = nullptr;\n+  const VTransformVectorNodePrototype prototype = VTransformVectorNodePrototype::make_from_pack(pack, _vloop_analyzer);\n+  const int  sopc = prototype.scalar_opcode();\n+  const uint vlen = prototype.vector_length();\n+  const BasicType bt = prototype.element_basic_type();\n@@ -154,0 +158,1 @@\n+  VTransformVectorNode* vtn = nullptr;\n@@ -156,2 +161,2 @@\n-    const VPointer vector_p(scalar_p.make_with_size(scalar_p.size() * pack_size));\n-    vtn = new (_vtransform.arena()) VTransformLoadVectorNode(_vtransform, pack_size, vector_p);\n+    const VPointer vector_p(scalar_p.make_with_size(scalar_p.size() * vlen));\n+    vtn = new (_vtransform.arena()) VTransformLoadVectorNode(_vtransform, prototype, vector_p, p0->adr_type());\n@@ -160,2 +165,4 @@\n-    const VPointer vector_p(scalar_p.make_with_size(scalar_p.size() * pack_size));\n-    vtn = new (_vtransform.arena()) VTransformStoreVectorNode(_vtransform, pack_size, vector_p);\n+    const VPointer vector_p(scalar_p.make_with_size(scalar_p.size() * vlen));\n+    vtn = new (_vtransform.arena()) VTransformStoreVectorNode(_vtransform, prototype, vector_p, p0->adr_type());\n+  } else if (p0->is_Cmp()) {\n+    vtn = new (_vtransform.arena()) VTransformCmpVectorNode(_vtransform, prototype);\n@@ -164,1 +171,3 @@\n-    vtn = new (_vtransform.arena()) VTransformBoolVectorNode(_vtransform, pack_size, kind);\n+    vtn = new (_vtransform.arena()) VTransformBoolVectorNode(_vtransform, prototype, kind);\n+  } else if (p0->is_CMove()) {\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), prototype, Op_VectorBlend);\n@@ -166,1 +175,1 @@\n-    vtn = new (_vtransform.arena()) VTransformReductionVectorNode(_vtransform, pack_size);\n+    vtn = new (_vtransform.arena()) VTransformReductionVectorNode(_vtransform, prototype);\n@@ -172,1 +181,16 @@\n-    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, 3, pack_size);\n+    int vopc = VectorNode::opcode(sopc, bt);\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, 3, prototype, vopc);\n+  } else if (VectorNode::is_convert_opcode(sopc)) {\n+    assert(p0->req() == 2, \"convert should have 2 operands\");\n+    BasicType def_bt = _vloop_analyzer.types().velt_basic_type(p0->in(1));\n+    int vopc = VectorCastNode::opcode(sopc, def_bt);\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), prototype, vopc);\n+  } else if (VectorNode::is_reinterpret_opcode(sopc)) {\n+    assert(p0->req() == 2, \"reinterpret should have 2 operands\");\n+    BasicType src_bt = _vloop_analyzer.types().velt_basic_type(p0->in(1));\n+    vtn = new (_vtransform.arena()) VTransformReinterpretVectorNode(_vtransform, prototype, src_bt);\n+  } else if (VectorNode::can_use_RShiftI_instead_of_URShiftI(p0, bt)) {\n+    int vopc = VectorNode::opcode(Op_RShiftI, bt);\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), prototype, vopc);\n+  } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(sopc)) {\n+    vtn = new (_vtransform.arena()) VTransformElementWiseLongOpWithCastToIntVectorNode(_vtransform, prototype);\n@@ -175,10 +199,8 @@\n-           p0->is_CMove() ||\n-           VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc) ||\n-           VectorNode::is_convert_opcode(opc) ||\n-           VectorNode::is_reinterpret_opcode(opc) ||\n-           VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc) ||\n-           opc == Op_FmaD  ||\n-           opc == Op_FmaF  ||\n-           opc == Op_FmaHF ||\n-           opc == Op_SignumF ||\n-           opc == Op_SignumD,\n+           VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(sopc) ||\n+           VectorNode::is_reinterpret_opcode(sopc) ||\n+           VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(sopc) ||\n+           sopc == Op_FmaD  ||\n+           sopc == Op_FmaF  ||\n+           sopc == Op_FmaHF ||\n+           sopc == Op_SignumF ||\n+           sopc == Op_SignumD,\n@@ -186,1 +208,3 @@\n-    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), pack_size);\n+    assert(!VectorNode::is_roundopD(p0) || p0->in(2)->is_Con(), \"rounding mode must be constant\");\n+    int vopc = VectorNode::opcode(sopc, bt);\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), prototype, vopc);\n@@ -294,1 +318,1 @@\n-void SuperWordVTransformBuilder::set_all_req_with_scalars(Node* n, VTransformNode* vtn) {\n+void SuperWordVTransformBuilder::init_all_req_with_scalars(Node* n, VTransformNode* vtn) {\n@@ -303,1 +327,1 @@\n-void SuperWordVTransformBuilder::set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn) {\n+void SuperWordVTransformBuilder::init_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn) {\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":67,"deletions":43,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-  void set_all_req_with_scalars(Node* n, VTransformNode* vtn);\n-  void set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn);\n+  void init_all_req_with_scalars(Node* n, VTransformNode* vtn);\n+  void init_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn);\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-  if (_trace._verbose) {\n+  if (_trace._info) {\n@@ -161,1 +161,1 @@\n-      VTransformVectorNode* vtn = vtnodes.at(i)->isa_Vector();\n+      VTransformMemVectorNode* vtn = vtnodes.at(i)->isa_MemVector();\n@@ -163,3 +163,1 @@\n-      MemNode* p0 = vtn->nodes().at(0)->isa_Mem();\n-      if (p0 == nullptr) { continue; }\n-      const VPointer& vp = vpointer(p0);\n+      const VPointer& vp = vtn->vpointer();\n@@ -750,1 +748,1 @@\n-  register_new_node_from_vectorization(apply_state, vn, val);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -757,1 +755,1 @@\n-  register_new_node_from_vectorization(apply_state, n, val);\n+  register_new_node_from_vectorization(apply_state, n);\n@@ -769,1 +767,1 @@\n-  register_new_node_from_vectorization(apply_state, shift_count_masked, shift_count_in);\n+  register_new_node_from_vectorization(apply_state, shift_count_masked);\n@@ -772,1 +770,1 @@\n-  register_new_node_from_vectorization(apply_state, vn, shift_count_in);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -784,1 +782,1 @@\n-  register_new_node_from_vectorization(apply_state, vn, val);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -789,10 +787,4 @@\n-  Node* first = nodes().at(0);\n-  uint  vlen = nodes().length();\n-  int   opc  = first->Opcode();\n-  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n-\n-  if (first->is_Cmp()) {\n-    \/\/ Cmp + Bool -> VectorMaskCmp\n-    \/\/ Handled by Bool \/ VTransformBoolVectorNode, so we do not generate any nodes here.\n-    return VTransformApplyResult::make_empty();\n-  }\n+  uint    vlen = vector_length();\n+  int     vopc = _vector_opcode;\n+  BasicType bt = element_basic_type();\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n@@ -801,1 +793,0 @@\n-  VectorNode* vn = nullptr;\n@@ -806,25 +797,3 @@\n-  if (first->is_CMove()) {\n-    assert(req() == 4, \"three inputs expected: mask, blend1, blend2\");\n-    vn = new VectorBlendNode(\/* blend1 *\/ in2, \/* blend2 *\/ in3, \/* mask *\/ in1);\n-  } else if (VectorNode::is_convert_opcode(opc)) {\n-    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n-    int vopc = VectorCastNode::opcode(opc, in1->bottom_type()->is_vect()->element_basic_type());\n-    vn = VectorCastNode::make(vopc, in1, bt, vlen);\n-  } else if (VectorNode::is_reinterpret_opcode(opc)) {\n-    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n-    const TypeVect* vt = TypeVect::make(bt, vlen);\n-    vn = new VectorReinterpretNode(in1, in1->bottom_type()->is_vect(), vt);\n-  } else if (VectorNode::can_use_RShiftI_instead_of_URShiftI(first, bt)) {\n-    opc = Op_RShiftI;\n-    vn = VectorNode::make(opc, in1, in2, vlen, bt);\n-  } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc)) {\n-    \/\/ The scalar operation was a long -> int operation.\n-    \/\/ However, the vector operation is long -> long.\n-    VectorNode* long_vn = VectorNode::make(opc, in1, nullptr, vlen, T_LONG);\n-    register_new_node_from_vectorization(apply_state, long_vn, first);\n-    \/\/ Cast long -> int, to mimic the scalar long -> int operation.\n-    vn = VectorCastNode::make(Op_VectorCastL2X, long_vn, T_INT, vlen);\n-  } else if (req() == 3 ||\n-             VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc)) {\n-    assert(!VectorNode::is_roundopD(first) || in2->is_Con(), \"rounding mode must be constant\");\n-    vn = VectorNode::make(opc, in1, in2, vlen, bt); \/\/ unary and binary\n+  VectorNode* vn = nullptr;\n+  if (req() <= 3) {\n+    vn = VectorNode::make(vopc, in1, in2, vt); \/\/ unary and binary\n@@ -832,8 +801,1 @@\n-    assert(req() == 4, \"three inputs expected\");\n-    assert(opc == Op_FmaD  ||\n-           opc == Op_FmaF  ||\n-           opc == Op_FmaHF ||\n-           opc == Op_SignumF ||\n-           opc == Op_SignumD,\n-           \"element wise operation must be from this list\");\n-    vn = VectorNode::make(opc, in1, in2, in3, vlen, bt); \/\/ ternary\n+    vn = VectorNode::make(vopc, in1, in2, in3, vt); \/\/ ternary\n@@ -846,0 +808,30 @@\n+VTransformApplyResult VTransformElementWiseLongOpWithCastToIntVectorNode::apply(VTransformApplyState& apply_state) const {\n+  uint vlen = vector_length();\n+  int  sopc = scalar_opcode();\n+  Node* in1 = apply_state.transformed_node(in_req(1));\n+\n+  \/\/ The scalar operation was a long -> int operation.\n+  \/\/ However, the vector operation is long -> long.\n+  VectorNode* long_vn = VectorNode::make(sopc, in1, nullptr, vlen, T_LONG);\n+  register_new_node_from_vectorization(apply_state, long_vn);\n+  \/\/ Cast long -> int, to mimic the scalar long -> int operation.\n+  VectorNode* vn = VectorCastNode::make(Op_VectorCastL2X, long_vn, T_INT, vlen);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformReinterpretVectorNode::apply(VTransformApplyState& apply_state) const {\n+  uint    vlen = vector_length();\n+  int     sopc = scalar_opcode();\n+  BasicType bt = element_basic_type();\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n+  assert(VectorNode::is_reinterpret_opcode(sopc), \"scalar opcode must be reinterpret\");\n+\n+  Node* in1 = apply_state.transformed_node(in_req(1));\n+  const TypeVect* src_vt = TypeVect::make(_src_bt, vlen);\n+  VectorNode* vn = new VectorReinterpretNode(in1, src_vt, vt);\n+\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->length_in_bytes());\n+}\n+\n@@ -847,3 +839,3 @@\n-  BoolNode* first = nodes().at(0)->as_Bool();\n-  uint  vlen = nodes().length();\n-  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n+  uint    vlen = vector_length();\n+  BasicType bt = element_basic_type();\n+  assert(scalar_opcode() == Op_Bool, \"\");\n@@ -852,3 +844,2 @@\n-  VTransformElementWiseVectorNode* vtn_cmp = in_req(1)->isa_ElementWiseVector();\n-  assert(vtn_cmp != nullptr && vtn_cmp->nodes().at(0)->is_Cmp(),\n-         \"bool vtn expects cmp vtn as input\");\n+  VTransformCmpVectorNode* vtn_cmp = in_req(1)->isa_CmpVector();\n+  assert(vtn_cmp != nullptr, \"bool vtn expects cmp vtn as input\");\n@@ -869,4 +860,3 @@\n-  Node* first = nodes().at(0);\n-  uint  vlen = nodes().length();\n-  int   opc  = first->Opcode();\n-  BasicType bt = first->bottom_type()->basic_type();\n+  int     sopc = scalar_opcode();\n+  uint    vlen = vector_length();\n+  BasicType bt = element_basic_type();\n@@ -877,1 +867,1 @@\n-  ReductionNode* vn = ReductionNode::make(opc, nullptr, init, vec, bt);\n+  ReductionNode* vn = ReductionNode::make(sopc, nullptr, init, vec, bt);\n@@ -883,0 +873,3 @@\n+  int     sopc = scalar_opcode();\n+  uint    vlen = vector_length();\n+  BasicType bt = element_basic_type();\n@@ -884,2 +877,2 @@\n-  uint  vlen = nodes().length();\n-  Node* ctrl = first->in(MemNode::Control);\n+  Node* ctrl = apply_state.transformed_node(in_req(MemNode::Control));\n+  \/\/ first has the correct memory state, determined by VTransformGraph::apply_memops_reordering_with_schedule\n@@ -887,4 +880,1 @@\n-  Node* adr  = first->in(MemNode::Address);\n-  int   opc  = first->Opcode();\n-  const TypePtr* adr_type = first->adr_type();\n-  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n+  Node* adr  = apply_state.transformed_node(in_req(MemNode::Address));\n@@ -905,1 +895,1 @@\n-  LoadVectorNode* vn = LoadVectorNode::make(opc, ctrl, mem, adr, adr_type, vlen, bt,\n+  LoadVectorNode* vn = LoadVectorNode::make(sopc, ctrl, mem, adr, _adr_type, vlen, bt,\n@@ -913,0 +903,2 @@\n+  int     sopc = scalar_opcode();\n+  uint    vlen = vector_length();\n@@ -914,2 +906,2 @@\n-  uint  vlen = nodes().length();\n-  Node* ctrl = first->in(MemNode::Control);\n+  Node* ctrl = apply_state.transformed_node(in_req(MemNode::Control));\n+  \/\/ first has the correct memory state, determined by VTransformGraph::apply_memops_reordering_with_schedule\n@@ -917,3 +909,1 @@\n-  Node* adr  = first->in(MemNode::Address);\n-  int   opc  = first->Opcode();\n-  const TypePtr* adr_type = first->adr_type();\n+  Node* adr  = apply_state.transformed_node(in_req(MemNode::Address));\n@@ -922,1 +912,1 @@\n-  StoreVectorNode* vn = StoreVectorNode::make(opc, ctrl, mem, adr, adr_type, value, vlen);\n+  StoreVectorNode* vn = StoreVectorNode::make(sopc, ctrl, mem, adr, _adr_type, value, vlen);\n@@ -930,3 +920,1 @@\n-  Node* first = nodes().at(0);\n-\n-  register_new_node_from_vectorization(apply_state, vn, first);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -940,1 +928,1 @@\n-void VTransformNode::register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn, Node* old_node) const {\n+void VTransformNode::register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn) const {\n@@ -942,1 +930,2 @@\n-  phase->register_new_node_with_ctrl_of(vn, old_node);\n+  \/\/ The control is not always correct, but we set major_progress anyway.\n+  phase->register_new_node(vn, apply_state.vloop().cl());\n@@ -1053,9 +1042,6 @@\n-  tty->print(\"%d-pack[\", _nodes.length());\n-  for (int i = 0; i < _nodes.length(); i++) {\n-    Node* n = _nodes.at(i);\n-    if (i > 0) {\n-      tty->print(\", \");\n-    }\n-    tty->print(\"%d %s\", n->_idx, n->Name());\n-  }\n-  tty->print(\"]\");\n+  tty->print(\"Prototype[orig=[%d %s] sopc=%s vlen=%d element_bt=%s]\",\n+             approximate_origin()->_idx,\n+             approximate_origin()->Name(),\n+             NodeClassNames[scalar_opcode()],\n+             vector_length(),\n+             type2name(element_basic_type()));\n@@ -1067,0 +1053,17 @@\n+\n+void VTransformElementWiseVectorNode::print_spec() const {\n+  VTransformVectorNode::print_spec();\n+  tty->print(\" vopc=%s\", NodeClassNames[_vector_opcode]);\n+}\n+\n+void VTransformReinterpretVectorNode::print_spec() const {\n+  VTransformVectorNode::print_spec();\n+  tty->print(\" src_bt=%s\", type2name(_src_bt));\n+}\n+\n+void VTransformBoolVectorNode::print_spec() const {\n+  VTransformVectorNode::print_spec();\n+  const BoolTest bt(_test._mask);\n+  tty->print(\" test=\");\n+  bt.dump_on(tty);\n+}\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":95,"deletions":92,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+class VTransformCmpVectorNode;\n@@ -434,0 +435,1 @@\n+  virtual VTransformCmpVectorNode* isa_CmpVector() { return nullptr; }\n@@ -448,1 +450,1 @@\n-  void register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn, Node* old_node) const;\n+  void register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn) const;\n@@ -593,1 +595,33 @@\n-\/\/ Base class for all vector vtnodes.\n+\/\/ Bundle the information needed for vector nodes.\n+class VTransformVectorNodePrototype : public StackObj {\n+private:\n+  Node* _approximate_origin; \/\/ for proper propagation of node notes\n+  const int _scalar_opcode;\n+  const uint _vector_length;\n+  const BasicType _element_basic_type;\n+\n+  VTransformVectorNodePrototype(Node* approximate_origin,\n+                                int scalar_opcode,\n+                                uint vector_length,\n+                                BasicType element_basic_type) :\n+    _approximate_origin(approximate_origin),\n+    _scalar_opcode(scalar_opcode),\n+    _vector_length(vector_length),\n+    _element_basic_type(element_basic_type) {}\n+\n+public:\n+  static VTransformVectorNodePrototype make_from_pack(const Node_List* pack, const VLoopAnalyzer& vloop_analyzer) {\n+    Node* first = pack->at(0);\n+    int opc = first->Opcode();\n+    int vlen = pack->size();\n+    BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+    return VTransformVectorNodePrototype(first, opc, vlen, bt);\n+  }\n+\n+  Node* approximate_origin()     const { return _approximate_origin; }\n+  int scalar_opcode()            const { return _scalar_opcode; }\n+  uint vector_length()           const { return _vector_length; }\n+  BasicType element_basic_type() const { return _element_basic_type; }\n+};\n+\n+\/\/ Abstract base class for all vector vtnodes.\n@@ -596,0 +630,2 @@\n+  const VTransformVectorNodePrototype _prototype;\n+protected:\n@@ -598,2 +634,7 @@\n-  VTransformVectorNode(VTransform& vtransform, const uint req, const uint number_of_nodes) :\n-    VTransformNode(vtransform, req), _nodes(vtransform.arena(), number_of_nodes, number_of_nodes, nullptr) {}\n+  VTransformVectorNode(VTransform& vtransform, const uint req, const VTransformVectorNodePrototype prototype) :\n+    VTransformNode(vtransform, req),\n+    _prototype(prototype),\n+    _nodes(vtransform.arena(),\n+           prototype.vector_length(),\n+           prototype.vector_length(),\n+           nullptr) {}\n@@ -607,1 +648,0 @@\n-  const GrowableArray<Node*>& nodes() const { return _nodes; }\n@@ -611,0 +651,6 @@\n+\n+protected:\n+  Node* approximate_origin()     const { return _prototype.approximate_origin(); }\n+  int scalar_opcode()            const { return _prototype.scalar_opcode(); }\n+  uint vector_length()           const { return _prototype.vector_length(); }\n+  BasicType element_basic_type() const { return _prototype.element_basic_type(); }\n@@ -615,0 +661,2 @@\n+private:\n+  const int _vector_opcode;\n@@ -616,2 +664,2 @@\n-  VTransformElementWiseVectorNode(VTransform& vtransform, uint req, uint number_of_nodes) :\n-    VTransformVectorNode(vtransform, req, number_of_nodes) {}\n+  VTransformElementWiseVectorNode(VTransform& vtransform, uint req, const VTransformVectorNodePrototype prototype, const int vector_opcode) :\n+    VTransformVectorNode(vtransform, req, prototype), _vector_opcode(vector_opcode) {}\n@@ -621,0 +669,23 @@\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ The scalar operation was a long -> int operation.\n+\/\/ However, the vector operation is long -> long.\n+\/\/ Hence, we vectorize it as: long --long_op--> long --cast--> int\n+class VTransformElementWiseLongOpWithCastToIntVectorNode : public VTransformVectorNode {\n+public:\n+  VTransformElementWiseLongOpWithCastToIntVectorNode(VTransform& vtransform, const VTransformVectorNodePrototype prototype) :\n+    VTransformVectorNode(vtransform, 2, prototype) {}\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ElementWiseLongOpWithCastToIntVector\"; };)\n+};\n+\n+class VTransformReinterpretVectorNode : public VTransformVectorNode {\n+private:\n+  const BasicType _src_bt;\n+public:\n+  VTransformReinterpretVectorNode(VTransform& vtransform, const VTransformVectorNodePrototype prototype, const BasicType src_bt) :\n+    VTransformVectorNode(vtransform, 2, prototype), _src_bt(src_bt) {}\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ReinterpretVector\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n@@ -631,1 +702,12 @@\n-class VTransformBoolVectorNode : public VTransformElementWiseVectorNode {\n+\/\/ Cmp + Bool -> VectorMaskCmp\n+\/\/ The Bool node takes care of \"apply\".\n+class VTransformCmpVectorNode : public VTransformVectorNode {\n+public:\n+  VTransformCmpVectorNode(VTransform& vtransform, const VTransformVectorNodePrototype prototype) :\n+    VTransformVectorNode(vtransform, 3, prototype) {}\n+  virtual VTransformCmpVectorNode* isa_CmpVector() override { return this; }\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override { return VTransformApplyResult::make_empty(); }\n+  NOT_PRODUCT(virtual const char* name() const override { return \"CmpVector\"; };)\n+};\n+\n+class VTransformBoolVectorNode : public VTransformVectorNode {\n@@ -635,2 +717,2 @@\n-  VTransformBoolVectorNode(VTransform& vtransform, uint number_of_nodes, VTransformBoolTest test) :\n-    VTransformElementWiseVectorNode(vtransform, 2, number_of_nodes), _test(test) {}\n+  VTransformBoolVectorNode(VTransform& vtransform, const VTransformVectorNodePrototype prototype, VTransformBoolTest test) :\n+    VTransformVectorNode(vtransform, 2, prototype), _test(test) {}\n@@ -641,0 +723,1 @@\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n@@ -646,2 +729,2 @@\n-  VTransformReductionVectorNode(VTransform& vtransform, uint number_of_nodes) :\n-    VTransformVectorNode(vtransform, 3, number_of_nodes) {}\n+  VTransformReductionVectorNode(VTransform& vtransform, const VTransformVectorNodePrototype prototype) :\n+    VTransformVectorNode(vtransform, 3, prototype) {}\n@@ -656,0 +739,2 @@\n+protected:\n+  const TypePtr* _adr_type;\n@@ -658,3 +743,4 @@\n-  VTransformMemVectorNode(VTransform& vtransform, const uint req, uint number_of_nodes, const VPointer& vpointer) :\n-    VTransformVectorNode(vtransform, req, number_of_nodes),\n-    _vpointer(vpointer) {}\n+  VTransformMemVectorNode(VTransform& vtransform, const uint req, const VTransformVectorNodePrototype prototype, const VPointer& vpointer, const TypePtr* adr_type) :\n+    VTransformVectorNode(vtransform, req, prototype),\n+    _vpointer(vpointer),\n+    _adr_type(adr_type) {}\n@@ -662,0 +748,1 @@\n+  const GrowableArray<Node*>& nodes() const { return _nodes; }\n@@ -670,2 +757,2 @@\n-  VTransformLoadVectorNode(VTransform& vtransform, uint number_of_nodes, const VPointer& vpointer) :\n-    VTransformMemVectorNode(vtransform, 3, number_of_nodes, vpointer) {}\n+  VTransformLoadVectorNode(VTransform& vtransform, const VTransformVectorNodePrototype prototype, const VPointer& vpointer, const TypePtr* adr_type) :\n+    VTransformMemVectorNode(vtransform, 3, prototype, vpointer, adr_type) {}\n@@ -682,2 +769,2 @@\n-  VTransformStoreVectorNode(VTransform& vtransform, uint number_of_nodes, const VPointer& vpointer) :\n-    VTransformMemVectorNode(vtransform, 4, number_of_nodes, vpointer) {}\n+  VTransformStoreVectorNode(VTransform& vtransform, const VTransformVectorNodePrototype prototype, const VPointer& vpointer, const TypePtr* adr_type) :\n+    VTransformMemVectorNode(vtransform, 4, prototype, vpointer, adr_type) {}\n@@ -706,2 +793,2 @@\n-    VTransformVectorNode* vector = vtn->isa_Vector();\n-    if (vector != nullptr && vector->nodes().at(0)->is_Mem()) {\n+    VTransformMemVectorNode* vector = vtn->isa_MemVector();\n+    if (vector != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":108,"deletions":21,"binary":false,"changes":129,"status":"modified"}]}