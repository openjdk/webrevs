{"files":[{"patch":"@@ -689,0 +689,6 @@\n+`installer.exe`\n+\n+:   Executable wrapper for MSI installer\n+\n+    Default resource is *msiwrapper.exe*\n+\n","filename":"src\/jdk.jpackage\/share\/man\/jpackage.md","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.OverridableResource.createResource;\n+\n@@ -132,3 +134,5 @@\n-        try (InputStream is = OverridableResource.readDefault(EXE_WRAPPER_NAME)) {\n-            Files.copy(is, exePath);\n-        }\n+\n+        createResource(EXE_WRAPPER_NAME, params)\n+                .setCategory(I18N.getString(\"resource.installer-exe\"))\n+                .setPublicName(\"installer.exe\")\n+                .saveToFile(exePath);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+resource.installer-exe=installer executable\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.awt.image.BufferedImage;\n@@ -28,2 +27,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n@@ -32,3 +29,0 @@\n-import java.util.Optional;\n-import javax.imageio.ImageIO;\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n@@ -71,1 +65,1 @@\n-            WinIconVerifier.instance.verifyLauncherIcon(cmd, launcherName,\n+            WinExecutableIconVerifier.verifyLauncherIcon(cmd, launcherName,\n@@ -86,187 +80,0 @@\n-    private static class WinIconVerifier {\n-\n-        void verifyLauncherIcon(JPackageCommand cmd, String launcherName,\n-                Path expectedIcon, boolean expectedDefault) {\n-            TKit.withTempDirectory(\"icons\", tmpDir -> {\n-                Path launcher = cmd.appLauncherPath(launcherName);\n-                Path iconWorkDir = tmpDir.resolve(launcher.getFileName());\n-                Path iconContainer = iconWorkDir.resolve(\"container.exe\");\n-                Files.createDirectories(iconContainer.getParent());\n-                Files.copy(getDefaultAppLauncher(expectedIcon == null\n-                        && !expectedDefault), iconContainer);\n-                if (expectedIcon != null) {\n-                    Executor.tryRunMultipleTimes(() -> {\n-                        setIcon(expectedIcon, iconContainer);\n-                    }, 3, 5);\n-                }\n-\n-                Path extractedExpectedIcon = extractIconFromExecutable(\n-                        iconWorkDir, iconContainer, \"expected\");\n-                Path extractedActualIcon = extractIconFromExecutable(iconWorkDir,\n-                        launcher, \"actual\");\n-\n-                TKit.trace(String.format(\n-                        \"Check icon file [%s] of %s launcher is a copy of source icon file [%s]\",\n-                        extractedActualIcon,\n-                        Optional.ofNullable(launcherName).orElse(\"main\"),\n-                        extractedExpectedIcon));\n-\n-                if (Files.mismatch(extractedExpectedIcon, extractedActualIcon)\n-                        != -1) {\n-                    \/\/ On Windows11 .NET API extracting icons from executables\n-                    \/\/ produce slightly different output for the same icon.\n-                    \/\/ To workaround it, compare pixels of images and if the\n-                    \/\/ number of off pixels is below a threshold, assume\n-                    \/\/ equality.\n-                    BufferedImage expectedImg = ImageIO.read(\n-                            extractedExpectedIcon.toFile());\n-                    BufferedImage actualImg = ImageIO.read(\n-                            extractedActualIcon.toFile());\n-\n-                    int w = expectedImg.getWidth();\n-                    int h = expectedImg.getHeight();\n-\n-                    TKit.assertEquals(w, actualImg.getWidth(),\n-                            \"Check expected and actual icons have the same width\");\n-                    TKit.assertEquals(h, actualImg.getHeight(),\n-                            \"Check expected and actual icons have the same height\");\n-\n-                    int diffPixelCount = 0;\n-\n-                    for (int i = 0; i != w; ++i) {\n-                        for (int j = 0; j != h; ++j) {\n-                            int expectedRGB = expectedImg.getRGB(i, j);\n-                            int actualRGB = actualImg.getRGB(i, j);\n-\n-                            if (expectedRGB != actualRGB) {\n-                                TKit.trace(String.format(\n-                                        \"Images mismatch at [%d, %d] pixel\", i,\n-                                        j));\n-                                diffPixelCount++;\n-                            }\n-                        }\n-                    }\n-\n-                    double threshold = 0.1;\n-                    TKit.assertTrue(((double) diffPixelCount) \/ (w * h)\n-                            < threshold,\n-                            String.format(\n-                                    \"Check the number of mismatched pixels [%d] of [%d] is < [%f] threshold\",\n-                                    diffPixelCount, (w * h), threshold));\n-                }\n-            });\n-        }\n-\n-        private WinIconVerifier() {\n-            try {\n-                executableRebranderClass = Class.forName(\n-                        \"jdk.jpackage.internal.ExecutableRebrander\");\n-\n-                lockResource = executableRebranderClass.getDeclaredMethod(\n-                        \"lockResource\", String.class);\n-                \/\/ Note: this reflection call requires\n-                \/\/ --add-opens jdk.jpackage\/jdk.jpackage.internal=ALL-UNNAMED\n-                lockResource.setAccessible(true);\n-\n-                unlockResource = executableRebranderClass.getDeclaredMethod(\n-                        \"unlockResource\", long.class);\n-                unlockResource.setAccessible(true);\n-\n-                iconSwapWrapper = executableRebranderClass.getDeclaredMethod(\n-                        \"iconSwapWrapper\", long.class, String.class);\n-                iconSwapWrapper.setAccessible(true);\n-            } catch (ClassNotFoundException | NoSuchMethodException\n-                    | SecurityException ex) {\n-                throw rethrowUnchecked(ex);\n-            }\n-        }\n-\n-        private Path extractIconFromExecutable(Path outputDir, Path executable,\n-                String label) {\n-            \/\/ Run .NET code to extract icon from the given executable.\n-            \/\/ ExtractAssociatedIcon() will succeed even if the target file\n-            \/\/ is locked (by an antivirus). It will output a default icon\n-            \/\/ in case of error. To prevent this \"fail safe\" behavior we try\n-            \/\/ lock the target file with Open() call. If the attempt\n-            \/\/ fails ExtractAssociatedIcon() is not called and the script exits\n-            \/\/ with the exit code that will be trapped\n-            \/\/ inside of Executor.executeAndRepeatUntilExitCode() method that\n-            \/\/ will keep running the script until it succeeds or the number of\n-            \/\/ allowed attempts is exceeded.\n-\n-            Path extractedIcon = outputDir.resolve(label + \".bmp\");\n-            String script = String.join(\";\",\n-                    String.format(\n-                            \"try { [System.io.File]::Open('%s', 'Open', 'Read', 'None') } catch { exit 100 }\",\n-                            executable.toAbsolutePath().normalize()),\n-                    \"[System.Reflection.Assembly]::LoadWithPartialName('System.Drawing')\",\n-                    String.format(\n-                            \"[System.Drawing.Icon]::ExtractAssociatedIcon('%s').ToBitmap().Save('%s', [System.Drawing.Imaging.ImageFormat]::Bmp)\",\n-                            executable.toAbsolutePath().normalize(),\n-                            extractedIcon.toAbsolutePath().normalize()));\n-\n-            Executor.of(\"powershell\", \"-NoLogo\", \"-NoProfile\", \"-Command\",\n-                    script).executeAndRepeatUntilExitCode(0, 5, 10);\n-\n-            return extractedIcon;\n-        }\n-\n-        private Path getDefaultAppLauncher(boolean noIcon) {\n-            \/\/ Create app image with the sole purpose to get the default app launcher\n-            Path defaultAppOutputDir = TKit.workDir().resolve(String.format(\n-                    \"out-%d\", ProcessHandle.current().pid()));\n-            JPackageCommand cmd = JPackageCommand.helloAppImage().setFakeRuntime().setArgumentValue(\n-                    \"--dest\", defaultAppOutputDir);\n-\n-            String launcherName;\n-            if (noIcon) {\n-                launcherName = \"no-icon\";\n-                new AdditionalLauncher(launcherName).setNoIcon().applyTo(cmd);\n-            } else {\n-                launcherName = null;\n-            }\n-\n-            if (!Files.isExecutable(cmd.appLauncherPath(launcherName))) {\n-                cmd.execute();\n-            }\n-            return cmd.appLauncherPath(launcherName);\n-        }\n-\n-        private void setIcon(Path iconPath, Path launcherPath) {\n-            TKit.trace(String.format(\"Set icon of [%s] launcher to [%s] file\",\n-                    launcherPath, iconPath));\n-            try {\n-                launcherPath.toFile().setWritable(true, true);\n-                try {\n-                    long lock = 0;\n-                    try {\n-                        lock = (Long) lockResource.invoke(null, new Object[]{\n-                            launcherPath.toAbsolutePath().normalize().toString()});\n-                        if (lock == 0) {\n-                            throw new RuntimeException(String.format(\n-                                    \"Failed to lock [%s] executable\",\n-                                    launcherPath));\n-                        }\n-                        iconSwapWrapper.invoke(null, new Object[]{lock,\n-                            iconPath.toAbsolutePath().normalize().toString()});\n-                    } finally {\n-                        if (lock != 0) {\n-                            unlockResource.invoke(null, new Object[]{lock});\n-                        }\n-                    }\n-                } catch (IllegalAccessException | InvocationTargetException ex) {\n-                    throw rethrowUnchecked(ex);\n-                }\n-            } finally {\n-                launcherPath.toFile().setWritable(false, true);\n-            }\n-        }\n-\n-        static final WinIconVerifier instance = new WinIconVerifier();\n-\n-        private final Class<?> executableRebranderClass;\n-        private final Method lockResource;\n-        private final Method unlockResource;\n-        private final Method iconSwapWrapper;\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":1,"deletions":194,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.imageio.ImageIO;\n+\n+public final class WinExecutableIconVerifier {\n+\n+    static void verifyLauncherIcon(JPackageCommand cmd, String launcherName,\n+            Path expectedIcon, boolean expectedDefault) {\n+        Objects.requireNonNull(cmd);\n+        INSTANCE.verifyExecutablesHaveSameIcon(new Input() {\n+            @Override\n+            public Path executableWithExpectedIcon(Path iconWorkDir) throws IOException {\n+                final var iconContainer = iconWorkDir.resolve(\"container.exe\");\n+                Files.createDirectories(iconContainer.getParent());\n+                Files.copy(INSTANCE.getDefaultAppLauncher(expectedIcon == null\n+                        && !expectedDefault), iconContainer);\n+                if (expectedIcon != null) {\n+                    Executor.tryRunMultipleTimes(() -> {\n+                        INSTANCE.setIcon(expectedIcon, iconContainer);\n+                    }, 3, 5);\n+                }\n+                return iconContainer;\n+            }\n+\n+            @Override\n+            public Path executableWithActualIcon(Path iconWorkDir) {\n+                return cmd.appLauncherPath(launcherName);\n+            }\n+\n+            @Override\n+            public void trace(Path extractedActualIcon, Path extractedExpectedIcon) {\n+                TKit.trace(String.format(\n+                        \"Check icon file [%s] of %s launcher is a copy of source icon file [%s]\",\n+                        extractedActualIcon,\n+                        Optional.ofNullable(launcherName).orElse(\"main\"),\n+                        extractedExpectedIcon));\n+            }\n+        });\n+    }\n+\n+    public static void verifyExecutablesHaveSameIcon(Path executableWithExpectedIcon,\n+            Path executableWithActualIcon) {\n+        Objects.requireNonNull(executableWithExpectedIcon);\n+        Objects.requireNonNull(executableWithActualIcon);\n+        INSTANCE.verifyExecutablesHaveSameIcon(new Input() {\n+            @Override\n+            public Path executableWithExpectedIcon(Path iconWorkDir) {\n+                return executableWithExpectedIcon;\n+            }\n+\n+            @Override\n+            public Path executableWithActualIcon(Path iconWorkDir) {\n+                return executableWithActualIcon;\n+            }\n+\n+            @Override\n+            public void trace(Path extractedActualIcon, Path extractedExpectedIcon) {\n+                TKit.trace(String.format(\n+                        \"Check icon file [%s] extracted from [%s] executable is a copy of icon file [%s] extracted from [%s] executable\",\n+                        extractedActualIcon, executableWithActualIcon,\n+                        extractedExpectedIcon, executableWithExpectedIcon));\n+            }\n+        });\n+    }\n+\n+    private interface Input {\n+        Path executableWithExpectedIcon(Path iconWorkDir) throws IOException;\n+        Path executableWithActualIcon(Path iconWorkDir) throws IOException;\n+        void trace(Path extractedActualIcon, Path extractedExpectedIcon);\n+    }\n+\n+    private void verifyExecutablesHaveSameIcon(Input input) {\n+\n+        Objects.requireNonNull(input);\n+\n+        TKit.withTempDirectory(\"icons\", iconWorkDir -> {\n+\n+            final var executableWithExpectedIcon = input.executableWithExpectedIcon(iconWorkDir);\n+            final var executableWithActualIcon = input.executableWithActualIcon(iconWorkDir);\n+\n+            if (Files.isSameFile(executableWithExpectedIcon, executableWithActualIcon)) {\n+                throw new IllegalArgumentException(\"Supply different files for icon comparison\");\n+            }\n+\n+            Path extractedExpectedIcon = extractIconFromExecutable(\n+                    iconWorkDir, executableWithExpectedIcon, \"expected\");\n+            Path extractedActualIcon = extractIconFromExecutable(iconWorkDir,\n+                    executableWithActualIcon, \"actual\");\n+\n+            input.trace(extractedActualIcon, extractedExpectedIcon);\n+\n+            \/\/ If executable doesn't have an icon, icon file will be empty.\n+            \/\/ Both icon files must be empty or not empty.\n+            \/\/ If only one icon file is empty executables have different icons.\n+            final var expectedIconIsEmpty = isFileEmpty(extractedExpectedIcon);\n+            final var actualIconIsEmpty = isFileEmpty(extractedActualIcon);\n+\n+            TKit.assertTrue(expectedIconIsEmpty == actualIconIsEmpty,\n+                    \"Check both icon files are empty or not empty\");\n+\n+            if (!expectedIconIsEmpty && Files.mismatch(extractedExpectedIcon, extractedActualIcon) != -1) {\n+                \/\/ On Windows11 .NET API extracting icons from executables\n+                \/\/ produce slightly different output for the same icon.\n+                \/\/ To workaround it, compare pixels of images and if the\n+                \/\/ number of off pixels is below a threshold, assume\n+                \/\/ equality.\n+                BufferedImage expectedImg = ImageIO.read(\n+                        extractedExpectedIcon.toFile());\n+                BufferedImage actualImg = ImageIO.read(\n+                        extractedActualIcon.toFile());\n+\n+                int w = expectedImg.getWidth();\n+                int h = expectedImg.getHeight();\n+\n+                TKit.assertEquals(w, actualImg.getWidth(),\n+                        \"Check expected and actual icons have the same width\");\n+                TKit.assertEquals(h, actualImg.getHeight(),\n+                        \"Check expected and actual icons have the same height\");\n+\n+                int diffPixelCount = 0;\n+\n+                for (int i = 0; i != w; ++i) {\n+                    for (int j = 0; j != h; ++j) {\n+                        int expectedRGB = expectedImg.getRGB(i, j);\n+                        int actualRGB = actualImg.getRGB(i, j);\n+\n+                        if (expectedRGB != actualRGB) {\n+                            TKit.trace(String.format(\n+                                    \"Images mismatch at [%d, %d] pixel\", i,\n+                                    j));\n+                            diffPixelCount++;\n+                        }\n+                    }\n+                }\n+\n+                double threshold = 0.1;\n+                TKit.assertTrue(((double) diffPixelCount) \/ (w * h)\n+                        < threshold,\n+                        String.format(\n+                                \"Check the number of mismatched pixels [%d] of [%d] is < [%f] threshold\",\n+                                diffPixelCount, (w * h), threshold));\n+            }\n+        });\n+    }\n+\n+    private WinExecutableIconVerifier() {\n+        try {\n+            executableRebranderClass = Class.forName(\n+                    \"jdk.jpackage.internal.ExecutableRebrander\");\n+\n+            lockResource = executableRebranderClass.getDeclaredMethod(\n+                    \"lockResource\", String.class);\n+            \/\/ Note: this reflection call requires\n+            \/\/ --add-opens jdk.jpackage\/jdk.jpackage.internal=ALL-UNNAMED\n+            lockResource.setAccessible(true);\n+\n+            unlockResource = executableRebranderClass.getDeclaredMethod(\n+                    \"unlockResource\", long.class);\n+            unlockResource.setAccessible(true);\n+\n+            iconSwap = executableRebranderClass.getDeclaredMethod(\n+                    \"iconSwap\", long.class, String.class);\n+            iconSwap.setAccessible(true);\n+        } catch (ClassNotFoundException | NoSuchMethodException\n+                | SecurityException ex) {\n+            throw rethrowUnchecked(ex);\n+        }\n+    }\n+\n+    private Path extractIconFromExecutable(Path outputDir, Path executable,\n+            String extractedIconFilename) {\n+\n+        Objects.requireNonNull(outputDir);\n+        Objects.requireNonNull(executable);\n+        Objects.requireNonNull(extractedIconFilename);\n+\n+        Path extractedIcon = outputDir.resolve(extractedIconFilename + \".bmp\");\n+\n+        Executor.of(\"powershell\", \"-NoLogo\", \"-NoProfile\", \"-ExecutionPolicy\", \"Unrestricted\",\n+                \"-File\", EXTRACT_ICON_PS1.toString(),\n+                \"-InputExecutable\", executable.toAbsolutePath().normalize().toString(),\n+                \"-OutputIcon\", extractedIcon.toAbsolutePath().normalize().toString()\n+        ).executeAndRepeatUntilExitCode(0, 5, 10);\n+\n+        return extractedIcon;\n+    }\n+\n+    private Path getDefaultAppLauncher(boolean noIcon) {\n+        \/\/ Create app image with the sole purpose to get the default app launcher\n+        Path defaultAppOutputDir = TKit.workDir().resolve(String.format(\n+                \"out-%d\", ProcessHandle.current().pid()));\n+        JPackageCommand cmd = JPackageCommand.helloAppImage().setFakeRuntime().setArgumentValue(\n+                \"--dest\", defaultAppOutputDir);\n+\n+        String launcherName;\n+        if (noIcon) {\n+            launcherName = \"no-icon\";\n+            new AdditionalLauncher(launcherName).setNoIcon().applyTo(cmd);\n+        } else {\n+            launcherName = null;\n+        }\n+\n+        if (!Files.isExecutable(cmd.appLauncherPath(launcherName))) {\n+            cmd.execute();\n+        }\n+        return cmd.appLauncherPath(launcherName);\n+    }\n+\n+    private void setIcon(Path iconPath, Path executable) {\n+        Objects.requireNonNull(iconPath);\n+        Objects.requireNonNull(executable);\n+\n+        try {\n+            executable.toFile().setWritable(true, true);\n+            try {\n+                long lock = 0;\n+                try {\n+                    lock = (Long) lockResource.invoke(null, new Object[]{\n+                            executable.toAbsolutePath().normalize().toString()});\n+                    if (lock == 0) {\n+                        throw new RuntimeException(String.format(\n+                                \"Failed to lock [%s] executable\",\n+                                executable));\n+                    }\n+                    var exitCode = (Integer) iconSwap.invoke(null, new Object[]{\n+                        lock,\n+                        iconPath.toAbsolutePath().normalize().toString()});\n+                    if (exitCode != 0) {\n+                        throw new RuntimeException(String.format(\n+                                \"Failed to swap icon of [%s] executable\",\n+                                executable));\n+                    }\n+                } finally {\n+                    if (lock != 0) {\n+                        unlockResource.invoke(null, new Object[]{lock});\n+                    }\n+                }\n+            } catch (IllegalAccessException | InvocationTargetException ex) {\n+                throw rethrowUnchecked(ex);\n+            }\n+        } finally {\n+            executable.toFile().setWritable(false, true);\n+        }\n+    }\n+\n+    private static boolean isFileEmpty(Path file) {\n+        return file.toFile().length() == 0;\n+    }\n+\n+    private final Class<?> executableRebranderClass;\n+    private final Method lockResource;\n+    private final Method unlockResource;\n+    private final Method iconSwap;\n+\n+    private static final WinExecutableIconVerifier INSTANCE = new WinExecutableIconVerifier();\n+\n+    private static final Path EXTRACT_ICON_PS1 = TKit.TEST_SRC_ROOT.resolve(Path.of(\"resources\/read-executable-icon.ps1\")).normalize();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WinExecutableIconVerifier.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+param (\n+  # Path to input executable file.\n+  [Parameter(Mandatory=$true)]\n+  [string]$InputExecutable,\n+\n+  # Path to BMP file where to save an icon extracted from the input executable.\n+  [Parameter(Mandatory=$true)]\n+  [string]$OutputIcon\n+)\n+\n+Add-Type -AssemblyName 'System.Drawing'\n+\n+$Shell32MethodDefinitions = @'\n+[DllImport(\"shell32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]\n+public static extern uint ExtractIconEx(string szFileName, int nIconIndex, IntPtr[] phiconLarge, IntPtr[] phiconSmall, uint nIcons);\n+'@\n+$Shell32 = Add-Type -MemberDefinition $Shell32MethodDefinitions -Name 'Shell32' -Namespace 'Win32' -PassThru\n+\n+$IconHandleArray = New-Object IntPtr[] 1 # Allocate IntPtr[1] to recieve HICON\n+$IconCount = $Shell32::ExtractIconEx($InputExecutable, 0, $IconHandleArray, $null, 1);\n+if ($IconCount -eq [uint32]::MaxValue) {\n+  Write-Error \"Failed to read icon.\"\n+  exit 100\n+} elseif ($IconCount -ne 0) {\n+  # Executable has an icon.\n+  $Icon = [System.Drawing.Icon]::FromHandle($IconHandleArray[0]);\n+  $Icon.ToBitmap().Save($OutputIcon, [System.Drawing.Imaging.ImageFormat]::Bmp)\n+} else {\n+  # Execeutable doesn't have an icon. Empty output icon file.\n+  $null = New-Item -Force $OutputIcon -ItemType File\n+}\n","filename":"test\/jdk\/tools\/jpackage\/resources\/read-executable-icon.ps1","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.jpackage.test.WinExecutableIconVerifier.verifyExecutablesHaveSameIcon;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n+\n+\/**\n+ * Test for installer exe from the resource directory.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with installer exe from the resource directory\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror WinInstallerResourceTest.java\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm\/timeout=720 -Xmx512m  jdk.jpackage.test.Main\n+ *  --jpt-run=WinInstallerResourceTest\n+ *\/\n+public class WinInstallerResourceTest {\n+\n+    @Test\n+    public void test() {\n+        createPackageTest(\"dummy\")\n+        .addInitializer(JPackageCommand::setFakeRuntime)\n+        .addInitializer(cmd -> {\n+            \/\/ Create exe installer using the default installer exe resource and a custom icon.\n+            cmd.addArguments(\"--icon\", iconPath(\"icon\"));\n+        })\n+        .addBundleVerifier(cmd -> {\n+            final var exeInstaller = cmd.outputBundle();\n+\n+            createPackageTest(\"InstallerResTest\")\n+            .addInitializer(cmd2 -> {\n+                cmd2.setArgumentValue(\"--runtime-image\", cmd.getArgumentValue(\"--runtime-image\"));\n+            })\n+            .addInitializer(cmd2 -> {\n+                \/\/\n+                \/\/ Create an exe installer using the exe installer created in the first jpackage run.\n+                \/\/\n+\n+                \/\/ The exe installer created in the first jpackage run has a custom icon.\n+                \/\/ Configure the second jpackage run to use the default icon.\n+                \/\/ This will prevent jpackage from editing icon in the exe installer.\n+                \/\/ Copy the exe installer created in the first jpackage run into the\n+                \/\/ resource directory for the second jpackage run.\n+                \/\/ If jpackage will pick an exe installer resource from the resource directory,\n+                \/\/ the output exe installer should have the same icon as\n+                \/\/ the exe installer produced in the first jpackage run.\n+                final var resourceDir = TKit.createTempDirectory(\"resources\");\n+                Files.copy(exeInstaller, resourceDir.resolve(\"installer.exe\"));\n+                cmd2.addArguments(\"--resource-dir\", resourceDir);\n+            })\n+            .addBundleVerifier(cmd2 -> {\n+                verifyExecutablesHaveSameIcon(exeInstaller, cmd2.outputBundle());\n+            }).run(Action.CREATE);\n+        }).run(Action.CREATE);\n+    }\n+\n+    private PackageTest createPackageTest(String name) {\n+        return new PackageTest()\n+                .ignoreBundleOutputDir()\n+                .forTypes(PackageType.WIN_EXE)\n+                .configureHelloApp()\n+                .addInitializer(cmd -> cmd.setArgumentValue(\"--name\", name));\n+    }\n+\n+    private static Path iconPath(String name) {\n+        return TKit.TEST_SRC_ROOT.resolve(Path.of(\"resources\", name\n+                + TKit.ICON_SUFFIX));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinInstallerResourceTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}