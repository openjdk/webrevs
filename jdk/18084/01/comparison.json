{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n@@ -44,0 +47,2 @@\n+    private boolean printDateTime;\n+    private boolean printThreadDetails;\n@@ -46,0 +51,6 @@\n+    private static boolean threadInfoAll;\n+    private static boolean timeStampInfoAll;\n+    private static boolean dateTimeFormatInitialized;\n+\n+    private static final HexFormat HEX_FORMATTER =\n+            HexFormat.of().withUpperCase();\n@@ -64,0 +75,6 @@\n+            } else if (args.contains(\"all\")) {\n+                int beginIndex = args.lastIndexOf(\"all\") + \"all\".length();\n+                int commaIndex = args.indexOf(',', beginIndex);\n+                if (commaIndex == -1) commaIndex = args.length();\n+                threadInfoAll = args.substring(beginIndex, commaIndex).contains(\"+thread\");;\n+                timeStampInfoAll = args.substring(beginIndex, commaIndex).contains(\"+timestamp\");;\n@@ -105,0 +122,5 @@\n+        System.err.println(\"+timestamp can be appended to any of above options to print\");\n+        System.err.println(\"              a timestamp for that debug option\");\n+        System.err.println(\"+thread can be appended to any of above options to print\");\n+        System.err.println(\"              thread information for that debug option\");\n+        System.err.println();\n@@ -156,0 +178,8 @@\n+            d.printThreadDetails = getConfigInfo(option, \"+thread\");\n+            d.printDateTime = getConfigInfo(option, \"+timestamp\");\n+            if (d.printDateTime && !dateTimeFormatInitialized) {\n+                \/\/ trigger loading of Locale service impl now to avoid\n+                \/\/ possible bootstrap recursive class load issue\n+                FormatHolder.DATE_TIME_FORMATTER.format(Instant.now());\n+                dateTimeFormatInitialized = true;\n+            }\n@@ -162,0 +192,31 @@\n+    private static String formatCaller() {\n+        return StackWalker.getInstance().walk(s ->\n+                s.dropWhile(f ->\n+                    f.getClassName().startsWith(\"sun.security.util.Debug\"))\n+                        .map(f -> f.getFileName() + \":\" + f.getLineNumber())\n+                        .findFirst().orElse(\"unknown caller\"));\n+    }\n+\n+    private static boolean getConfigInfo(String option, String extraInfoOption) {\n+        \/\/ args is converted to lower case for the most part via marshal method\n+        int beginIndex;\n+        String subOpt;\n+        \/\/ treat \"all\" as special case,\n+        if (timeStampInfoAll && extraInfoOption.equals(\"+timestamp\")) {\n+            return true;\n+        }\n+        if (threadInfoAll && extraInfoOption.equals(\"+thread\")) {\n+            return true;\n+        }\n+        try {\n+            beginIndex = args.lastIndexOf(option) + option.length();\n+            int commaIndex = args.indexOf(',', beginIndex);\n+            if (commaIndex == -1) commaIndex = args.length();\n+            subOpt = args.substring(beginIndex, commaIndex);\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ no sub option\n+            return false;\n+        }\n+        return subOpt.contains(extraInfoOption);\n+    }\n+\n@@ -192,1 +253,1 @@\n-        System.err.println(prefix + \": \"+message);\n+        System.err.println(prefix + extraInfo() + \": \" + message);\n@@ -201,1 +262,1 @@\n-        System.err.println(prefix + \" [\" + obj.getClass().getSimpleName() +\n+        System.err.println(prefix + extraInfo() + \" [\" + obj.getClass().getSimpleName() +\n@@ -211,1 +272,1 @@\n-        System.err.println(prefix + \":\");\n+        System.err.println(prefix + extraInfo() + \":\");\n@@ -218,1 +279,1 @@\n-    public static void println(String prefix, String message)\n+    public void println(String prefix, String message)\n@@ -220,1 +281,21 @@\n-        System.err.println(prefix + \": \"+message);\n+        System.err.println(prefix + extraInfo() + \": \" + message);\n+    }\n+\n+    \/**\n+     * If thread debug option enabled, include information containing\n+     * hex value of threadId and the current thread name\n+     * If timestamp debug option enabled, include timestamp string\n+     * @return extra info if debug option enabled.\n+     *\/\n+    private String extraInfo() {\n+        String retString = \"\";\n+        if (printThreadDetails) {\n+            retString = \"0x\" + Long.toHexString(\n+                    Thread.currentThread().threadId()).toUpperCase(Locale.ROOT) +\n+                    \"|\" + Thread.currentThread().getName() + \"|\" + formatCaller();\n+        }\n+        if (printDateTime) {\n+            retString += (retString.isEmpty() ? \"\" : \"|\")\n+                    + FormatHolder.DATE_TIME_FORMATTER.format(Instant.now());\n+        }\n+        return retString.isEmpty() ? \"\" : \"[\" + retString + \"]\";\n@@ -340,0 +421,8 @@\n+    \/\/ Holder class to break cyclic dependency seen during build\n+    private static class FormatHolder {\n+        private static final String PATTERN = \"yyyy-MM-dd kk:mm:ss.SSS z\";\n+        private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter\n+                .ofPattern(PATTERN, Locale.ENGLISH)\n+                .withZone(ZoneId.systemDefault());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":95,"deletions":6,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8051959\n+ * @summary Option to print extra information in java.security.debug output\n+ * @library \/test\/lib\n+ * @run junit DebugOptions\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.security.KeyStore;\n+import java.security.Security;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class DebugOptions {\n+\n+    private static Stream<Arguments> patternMatches() {\n+        return Stream.of(\n+                \/\/ no extra info present\n+                Arguments.of(\"properties\",\n+                        \"properties: Initial\",\n+                        \"properties\\\\[\"),\n+                \/\/ thread info only\n+                Arguments.of(\"properties+thread\",\n+                        \"properties\\\\[.*\\\\|main|\\\\.*java.*]:\",\n+                        \"UTC]\"),\n+                \/\/ timestamp info only\n+                Arguments.of(\"properties+timestamp\",\n+                        \"properties\\\\[.*UTC\\\\]\",\n+                        \"\\\\|main\\\\]:\"),\n+                \/\/ both thread and timestamp\n+                Arguments.of(\"properties+timestamp+thread\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*UTC\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ flip the arguments of previous test\n+                Arguments.of(\"properties+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*UTC\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ comma not valid separator, ignore extra info printing request\n+                Arguments.of(\"properties,thread,timestamp\",\n+                        \"properties:\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*UTC\\\\]:\"),\n+                \/\/ no extra info for keystore debug prints\n+                Arguments.of(\"properties+thread+timestamp,keystore\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*UTC\\\\]:\",\n+                        \"keystore\\\\[\"),\n+                \/\/ flip arguments around in last test - same outcome expected\n+                Arguments.of(\"keystore,properties+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*UTC\\\\]:\",\n+                        \"keystore\\\\[\"),\n+                \/\/ turn on thread info for both keystore and properties components\n+                Arguments.of(\"keystore+thread,properties+thread\",\n+                        \"properties\\\\[.*\\\\|main.*\\\\Rkeystore\\\\[.*\\\\|main|.*\\\\]:\",\n+                        \"UTC]\"),\n+                \/\/ same as above with erroneous comma at end of string. same output expected\n+                Arguments.of(\"keystore+thread,properties+thread,\",\n+                        \"properties\\\\[.*\\\\|main.*\\\\Rkeystore\\\\[.*\\\\|main|.*\\\\]:\",\n+                        \"UTC]\"),\n+                \/\/ turn on thread info for properties and timestamp for keystore\n+                Arguments.of(\"keystore+timestamp,properties+thread\",\n+                        \"properties\\\\[.*\\\\|main|.*\\\\Rkeystore\\\\[.*UTC\\\\]:\",\n+                        \"properties\\\\[.*UTC\\\\]:\"),\n+                \/\/ turn on thread info for all components\n+                Arguments.of(\"all+thread\",\n+                        \"properties\\\\[.*\\\\|main.*((.*\\\\R)*)keystore\\\\[.*\\\\|main.*java.*\\\\]:\",\n+                        \"properties\\\\[.*UTC\\\\]:\"),\n+                \/\/ turn on thread info and timestamp for all components\n+                Arguments.of(\"all+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main.*UTC\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*UTC\\\\]:\",\n+                        \"properties:\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"patternMatches\")\n+    public void shouldContain(String params, String expected, String notExpected) throws Exception {\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                \"-Duser.timezone=UTC\",\n+                \"-Djava.security.debug=\" + params,\n+                \"DebugOptions\"\n+        );\n+        outputAnalyzer.shouldHaveExitValue(0)\n+                .shouldMatch(expected)\n+                .shouldNotMatch(notExpected);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ something to trigger \"properties\" debug output\n+        Security.getProperty(\"test\");\n+        \/\/ trigger \"keystore\" debug output\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/Debug\/DebugOptions.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}