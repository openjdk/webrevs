{"files":[{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.util.FormatConcatItem;\n@@ -130,14 +128,0 @@\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static long mix(long lengthCoder, FormatConcatItem value) {\n-        lengthCoder = value.mix(lengthCoder);\n-        return checkOverflow(lengthCoder);\n-    }\n-\n@@ -347,42 +331,0 @@\n-    \/**\n-     * Prepends the stringly representation of FormatConcatItem value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      String value to encode\n-     * @return           updated index (coder value retained)\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static long prepend(long indexCoder, byte[] buf, FormatConcatItem value) {\n-        try {\n-            return value.prepend(indexCoder, buf);\n-        } catch (Error ex) {\n-            throw ex;\n-        } catch (Throwable ex) {\n-            throw new AssertionError(\"FormatConcatItem prepend error\", ex);\n-        }\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static long prepend(long indexCoder, byte[] buf,\n-                        FormatConcatItem value, String prefix) {\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n-    }\n-\n@@ -520,65 +462,0 @@\n-    \/*\n-     * Initialize after phase1.\n-     *\/\n-    private static class LateInit {\n-        static final MethodHandle GETCHAR_LATIN1_MH;\n-\n-        static final MethodHandle GETCHAR_UTF16_MH;\n-\n-        static final MethodHandle PUTCHAR_LATIN1_MH;\n-\n-        static final MethodHandle PUTCHAR_UTF16_MH;\n-\n-        static {\n-            MethodType getCharMT =\n-                MethodType.methodType(char.class,\n-                        byte[].class, int.class);\n-            MethodType putCharMT =\n-                MethodType.methodType(void.class,\n-                        byte[].class, int.class, int.class);\n-            GETCHAR_LATIN1_MH = lookupStatic(\"getCharLatin1\", getCharMT);\n-            GETCHAR_UTF16_MH = lookupStatic(\"getCharUTF16\", getCharMT);\n-            PUTCHAR_LATIN1_MH = lookupStatic(\"putCharLatin1\", putCharMT);\n-            PUTCHAR_UTF16_MH = lookupStatic(\"putCharUTF16\", putCharMT);\n-        }\n-\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static char getCharLatin1(byte[] buffer, int index) {\n-        return (char)buffer[index];\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static char getCharUTF16(byte[] buffer, int index) {\n-        return StringUTF16.getChar(buffer, index);\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static void putCharLatin1(byte[] buffer, int index, int ch) {\n-        buffer[index] = (byte)ch;\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static void putCharUTF16(byte[] buffer, int index, int ch) {\n-        StringUTF16.putChar(buffer, index, ch);\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static MethodHandle selectGetChar(long indexCoder) {\n-        return indexCoder < UTF16 ? LateInit.GETCHAR_LATIN1_MH :\n-                                    LateInit.GETCHAR_UTF16_MH;\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static MethodHandle selectPutChar(long indexCoder) {\n-        return indexCoder < UTF16 ? LateInit.PUTCHAR_LATIN1_MH :\n-                                    LateInit.PUTCHAR_UTF16_MH;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -1,622 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.FormatProcessor;\n-import java.util.function.Function;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.access.JavaTemplateAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * {@link StringTemplate} is the run-time representation of a string template or\n- * text block template in a template expression.\n- * <p>\n- * In the source code of a Java program, a string template or text block template\n- * contains an interleaved succession of <em>fragment literals<\/em> and <em>embedded\n- * expressions<\/em>. The {@link StringTemplate#fragments()} method returns the\n- * fragment literals, and the {@link StringTemplate#values()} method returns the\n- * results of evaluating the embedded expressions. {@link StringTemplate} does not\n- * provide access to the source code of the embedded expressions themselves; it is\n- * not a compile-time representation of a string template or text block template.\n- * <p>\n- * {@link StringTemplate} is primarily used in conjunction with a template processor\n- * to produce a string or other meaningful value. Evaluation of a template expression\n- * first produces an instance of {@link StringTemplate}, representing the right hand side\n- * of the template expression, and then passes the instance to the template processor\n- * given by the template expression.\n- * <p>\n- * For example, the following code contains a template expression that uses the template\n- * processor {@code RAW}, which simply yields the {@link StringTemplate} passed to it:\n- * {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n- * List<String> fragments = st.fragments();\n- * List<Object> values = st.values();\n- * }\n- * {@code fragments} will be equivalent to {@code List.of(\"\", \" + \", \" = \", \"\")},\n- * which includes the empty first and last fragments. {@code values} will be the\n- * equivalent of {@code List.of(10, 20, 30)}.\n- * <p>\n- * The following code contains a template expression with the same template but with a\n- * different template processor, {@code STR}:\n- * {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * String s = STR.\"\\{x} + \\{y} = \\{x + y}\";\n- * }\n- * When the template expression is evaluated, an instance of {@link StringTemplate} is\n- * produced that returns the same lists from {@link StringTemplate#fragments()} and\n- * {@link StringTemplate#values()} as shown above. The {@link StringTemplate#STR} template\n- * processor uses these lists to yield an interpolated string. The value of {@code s} will\n- * be equivalent to {@code \"10 + 20 = 30\"}.\n- * <p>\n- * The {@code interpolate()} method provides a direct way to perform string interpolation\n- * of a {@link StringTemplate}. Template processors can use the following code pattern:\n- * {@snippet :\n- * List<String> fragments = st.fragments();\n- * List<Object> values    = st.values();\n- * ... check or manipulate the fragments and\/or values ...\n- * String result = StringTemplate.interpolate(fragments, values);\n- * }\n- * The {@link StringTemplate#process(Processor)} method, in conjunction with\n- * the {@link StringTemplate#RAW} processor, may be used to defer processing of a\n- * {@link StringTemplate}.\n- * {@snippet :\n- * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n- * ...other steps...\n- * String result = st.process(STR);\n- * }\n- * The factory methods {@link StringTemplate#of(String)} and\n- * {@link StringTemplate#of(List, List)} can be used to construct a {@link StringTemplate}.\n- *\n- * @see Processor\n- * @see java.util.FormatProcessor\n- *\n- * @implNote Implementations of {@link StringTemplate} must minimally implement the\n- * methods {@link StringTemplate#fragments()} and {@link StringTemplate#values()}.\n- * Instances of {@link StringTemplate} are considered immutable. To preserve the\n- * semantics of string templates and text block templates, the list returned by\n- * {@link StringTemplate#fragments()} must be one element larger than the list returned\n- * by {@link StringTemplate#values()}.\n- *\n- * @since 21\n- *\n- * @jls 15.8.6 Process Template Expressions\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-public interface StringTemplate {\n-    \/**\n-     * Returns a list of fragment literals for this {@link StringTemplate}.\n-     * The fragment literals are the character sequences preceding each of the embedded\n-     * expressions in source code, plus the character sequence following the last\n-     * embedded expression. Such character sequences may be zero-length if an embedded\n-     * expression appears at the beginning or end of a template, or if two embedded\n-     * expressions are directly adjacent in a template.\n-     * In the example: {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * List<String> fragments = st.fragments(); \/\/ @highlight substring=\"fragments()\"\n-     * }\n-     * {@code fragments} will be equivalent to\n-     * {@code List.of(\"The student \", \" is in \", \"'s classroom.\")}\n-     *\n-     * @return list of string fragments\n-     *\n-     * @implSpec the list returned is immutable\n-     *\/\n-    List<String> fragments();\n-\n-    \/**\n-     * Returns a list of embedded expression results for this {@link StringTemplate}.\n-     * In the example:\n-     * {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * List<Object> values = st.values(); \/\/ @highlight substring=\"values()\"\n-     * }\n-     * {@code values} will be equivalent to {@code List.of(student, teacher)}\n-     *\n-     * @return list of expression values\n-     *\n-     * @implSpec the list returned is immutable\n-     *\/\n-    List<Object> values();\n-\n-    \/**\n-     * Returns the string interpolation of the fragments and values for this\n-     * {@link StringTemplate}.\n-     * @apiNote For better visibility and when practical, it is recommended to use the\n-     * {@link StringTemplate#STR} processor instead of invoking the\n-     * {@link StringTemplate#interpolate()} method.\n-     * {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * String result = st.interpolate(); \/\/ @highlight substring=\"interpolate()\"\n-     * }\n-     * In the above example, the value of  {@code result} will be\n-     * {@code \"The student Mary is in Johnson's classroom.\"}. This is\n-     * produced by the interleaving concatenation of fragments and values from the supplied\n-     * {@link StringTemplate}. To accommodate concatenation, values are converted to strings\n-     * as if invoking {@link String#valueOf(Object)}.\n-     *\n-     * @return interpolation of this {@link StringTemplate}\n-     *\n-     * @implSpec The default implementation returns the result of invoking\n-     * {@code StringTemplate.interpolate(this.fragments(), this.values())}.\n-     *\/\n-    default String interpolate() {\n-        return StringTemplate.interpolate(fragments(), values());\n-    }\n-\n-    \/**\n-     * Returns the result of applying the specified processor to this {@link StringTemplate}.\n-     * This method can be used as an alternative to string template expressions. For example,\n-     * {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * String result1 = STR.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * String result2 = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\".process(STR); \/\/ @highlight substring=\"process\"\n-     * }\n-     * Produces an equivalent result for both {@code result1} and {@code result2}.\n-     *\n-     * @param processor the {@link Processor} instance to process\n-     *\n-     * @param <R>  Processor's process result type.\n-     * @param <E>  Exception thrown type.\n-     *\n-     * @return constructed object of type {@code R}\n-     *\n-     * @throws E exception thrown by the template processor when validation fails\n-     * @throws NullPointerException if processor is null\n-     *\n-     * @implSpec The default implementation returns the result of invoking\n-     * {@code processor.process(this)}. If the invocation throws an exception that\n-     * exception is forwarded to the caller.\n-     *\/\n-    default <R, E extends Throwable> R\n-    process(Processor<? extends R, ? extends E> processor) throws E {\n-        Objects.requireNonNull(processor, \"processor should not be null\");\n-\n-        return processor.process(this);\n-    }\n-\n-    \/**\n-     * Produces a diagnostic string that describes the fragments and values of the supplied\n-     * {@link StringTemplate}.\n-     *\n-     * @param stringTemplate  the {@link StringTemplate} to represent\n-     *\n-     * @return diagnostic string representing the supplied string template\n-     *\n-     * @throws NullPointerException if stringTemplate is null\n-     *\/\n-    static String toString(StringTemplate stringTemplate) {\n-        Objects.requireNonNull(stringTemplate, \"stringTemplate should not be null\");\n-        return \"StringTemplate{ fragments = [ \\\"\" +\n-                String.join(\"\\\", \\\"\", stringTemplate.fragments()) +\n-                \"\\\" ], values = \" +\n-                stringTemplate.values() +\n-                \" }\";\n-    }\n-\n-    \/**\n-     * Returns a {@link StringTemplate} as if constructed by invoking\n-     * {@code StringTemplate.of(List.of(string), List.of())}. That is, a {@link StringTemplate}\n-     * with one fragment and no values.\n-     *\n-     * @param string  single string fragment\n-     *\n-     * @return StringTemplate composed from string\n-     *\n-     * @throws NullPointerException if string is null\n-     *\/\n-    static StringTemplate of(String string) {\n-        Objects.requireNonNull(string, \"string must not be null\");\n-        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-        return JTA.of(List.of(string), List.of());\n-    }\n-\n-    \/**\n-     * Returns a StringTemplate with the given fragments and values.\n-     *\n-     * @implSpec The {@code fragments} list size must be one more that the\n-     * {@code values} list size.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    list of expression values\n-     *\n-     * @return StringTemplate composed from string\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n-     *\n-     * @implNote Contents of both lists are copied to construct immutable lists.\n-     *\/\n-    static StringTemplate of(List<String> fragments, List<?> values) {\n-        Objects.requireNonNull(fragments, \"fragments must not be null\");\n-        Objects.requireNonNull(values, \"values must not be null\");\n-        if (values.size() + 1 != fragments.size()) {\n-            throw new IllegalArgumentException(\n-                    \"fragments list size is not one more than values list size\");\n-        }\n-        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-        return JTA.of(fragments, values);\n-    }\n-\n-    \/**\n-     * Creates a string that interleaves the elements of values between the\n-     * elements of fragments. To accommodate interpolation, values are converted to strings\n-     * as if invoking {@link String#valueOf(Object)}.\n-     *\n-     * @param fragments  list of String fragments\n-     * @param values     list of expression values\n-     *\n-     * @return String interpolation of fragments and values\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException fragments or values is null or if any of the fragments is null\n-     *\/\n-    static String interpolate(List<String> fragments, List<?> values) {\n-        Objects.requireNonNull(fragments, \"fragments must not be null\");\n-        Objects.requireNonNull(values, \"values must not be null\");\n-        int fragmentsSize = fragments.size();\n-        int valuesSize = values.size();\n-        if (fragmentsSize != valuesSize + 1) {\n-            throw new IllegalArgumentException(\"fragments must have one more element than values\");\n-        }\n-        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-        return JTA.interpolate(fragments, values);\n-    }\n-\n-    \/**\n-     * Combine zero or more {@link StringTemplate StringTemplates} into a single\n-     * {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\");\n-     * assert st.interpolate().equals(STR.\"\\{a}\\{b}\\{c}\");\n-     * }\n-     * Fragment lists from the {@link StringTemplate StringTemplates} are combined end to\n-     * end with the last fragment from each {@link StringTemplate} concatenated with the\n-     * first fragment of the next. To demonstrate, if we were to take two strings and we\n-     * combined them as follows: {@snippet lang = \"java\":\n-     * String s1 = \"abc\";\n-     * String s2 = \"xyz\";\n-     * String sc = s1 + s2;\n-     * assert Objects.equals(sc, \"abcxyz\");\n-     * }\n-     * the last character {@code \"c\"} from the first string is juxtaposed with the first\n-     * character {@code \"x\"} of the second string. The same would be true of combining\n-     * {@link StringTemplate StringTemplates}.\n-     * {@snippet lang =\"java\":\n-     * StringTemplate st1 = RAW.\"a\\{}b\\{}c\";\n-     * StringTemplate st2 = RAW.\"x\\{}y\\{}z\";\n-     * StringTemplate st3 = RAW.\"a\\{}b\\{}cx\\{}y\\{}z\";\n-     * StringTemplate stc = StringTemplate.combine(st1, st2);\n-     *\n-     * assert Objects.equals(st1.fragments(), List.of(\"a\", \"b\", \"c\"));\n-     * assert Objects.equals(st2.fragments(), List.of(\"x\", \"y\", \"z\"));\n-     * assert Objects.equals(st3.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * assert Objects.equals(stc.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * }\n-     * Values lists are simply concatenated to produce a single values list.\n-     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n-     * n is the total of number of values across all the supplied\n-     * {@link StringTemplate StringTemplates}.\n-     *\n-     * @param stringTemplates  zero or more {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if stringTemplates is null or if any of the\n-     * {@code stringTemplates} are null\n-     *\n-     * @implNote If zero {@link StringTemplate} arguments are provided then a\n-     * {@link StringTemplate} with an empty fragment and no values is returned, as if invoking\n-     * <code>StringTemplate.of(\"\")<\/code> . If only one {@link StringTemplate} argument is provided\n-     * then it is returned unchanged.\n-     *\/\n-    static StringTemplate combine(StringTemplate... stringTemplates) {\n-        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-        return JTA.combine(stringTemplates);\n-    }\n-\n-    \/**\n-     * Combine a list of {@link StringTemplate StringTemplates} into a single\n-     * {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(List.of(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\"));\n-     * assert st.interpolate().equals(STR.\"\\{a}\\{b}\\{c}\");\n-     * }\n-     * Fragment lists from the {@link StringTemplate StringTemplates} are combined end to\n-     * end with the last fragment from each {@link StringTemplate} concatenated with the\n-     * first fragment of the next. To demonstrate, if we were to take two strings and we\n-     * combined them as follows: {@snippet lang = \"java\":\n-     * String s1 = \"abc\";\n-     * String s2 = \"xyz\";\n-     * String sc = s1 + s2;\n-     * assert Objects.equals(sc, \"abcxyz\");\n-     * }\n-     * the last character {@code \"c\"} from the first string is juxtaposed with the first\n-     * character {@code \"x\"} of the second string. The same would be true of combining\n-     * {@link StringTemplate StringTemplates}.\n-     * {@snippet lang =\"java\":\n-     * StringTemplate st1 = RAW.\"a\\{}b\\{}c\";\n-     * StringTemplate st2 = RAW.\"x\\{}y\\{}z\";\n-     * StringTemplate st3 = RAW.\"a\\{}b\\{}cx\\{}y\\{}z\";\n-     * StringTemplate stc = StringTemplate.combine(List.of(st1, st2));\n-     *\n-     * assert Objects.equals(st1.fragments(), List.of(\"a\", \"b\", \"c\"));\n-     * assert Objects.equals(st2.fragments(), List.of(\"x\", \"y\", \"z\"));\n-     * assert Objects.equals(st3.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * assert Objects.equals(stc.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * }\n-     * Values lists are simply concatenated to produce a single values list.\n-     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n-     * n is the total of number of values across all the supplied\n-     * {@link StringTemplate StringTemplates}.\n-     *\n-     * @param stringTemplates  list of {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if stringTemplates is null or if any of the\n-     * its elements are null\n-     *\n-     * @implNote If {@code stringTemplates.size() == 0} then a {@link StringTemplate} with\n-     * an empty fragment and no values is returned, as if invoking\n-     * <code>StringTemplate.of(\"\")<\/code> . If {@code stringTemplates.size() == 1}\n-     * then the first element of the list is returned unchanged.\n-     *\/\n-    static StringTemplate combine(List<StringTemplate> stringTemplates) {\n-        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-        return JTA.combine(stringTemplates.toArray(new StringTemplate[0]));\n-    }\n-\n-    \/**\n-     * This {@link Processor} instance is conventionally used for the string interpolation\n-     * of a supplied {@link StringTemplate}.\n-     * <p>\n-     * For better visibility and when practical, it is recommended that users use the\n-     * {@link StringTemplate#STR} processor instead of invoking the\n-     * {@link StringTemplate#interpolate()} method.\n-     * Example: {@snippet :\n-     * int x = 10;\n-     * int y = 20;\n-     * String result = STR.\"\\{x} + \\{y} = \\{x + y}\"; \/\/ @highlight substring=\"STR\"\n-     * }\n-     * In the above example, the value of {@code result} will be {@code \"10 + 20 = 30\"}. This is\n-     * produced by the interleaving concatenation of fragments and values from the supplied\n-     * {@link StringTemplate}. To accommodate concatenation, values are converted to strings\n-     * as if invoking {@link String#valueOf(Object)}.\n-     * @apiNote {@link StringTemplate#STR} is statically imported implicitly into every\n-     * Java compilation unit.\n-     *\/\n-    Processor<String, RuntimeException> STR = StringTemplate::interpolate;\n-\n-    \/**\n-     * This {@link Processor} instance is conventionally used to indicate that the\n-     * processing of the {@link StringTemplate} is to be deferred to a later time. Deferred\n-     * processing can be resumed by invoking the\n-     * {@link StringTemplate#process(Processor)} or\n-     * {@link Processor#process(StringTemplate)} methods.\n-     * {@snippet :\n-     * import static java.lang.StringTemplate.RAW;\n-     * ...\n-     * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-     * ...other steps...\n-     * String result = STR.process(st);\n-     * }\n-     * @implNote Unlike {@link StringTemplate#STR}, {@link StringTemplate#RAW} must be\n-     * statically imported explicitly.\n-     *\/\n-    Processor<StringTemplate, RuntimeException> RAW = st -> st;\n-\n-    \/**\n-     * This interface describes the methods provided by a generalized string template processor. The\n-     * primary method {@link Processor#process(StringTemplate)} is used to validate\n-     * and compose a result using a {@link StringTemplate StringTemplate's} fragments and values lists.\n-     * <p>\n-     * For example:\n-     * {@snippet :\n-     * class MyProcessor implements Processor<String, IllegalArgumentException> {\n-     *     @Override\n-     *     public String process(StringTemplate st) throws IllegalArgumentException {\n-     *          StringBuilder sb = new StringBuilder();\n-     *          Iterator<String> fragmentsIter = st.fragments().iterator();\n-     *\n-     *          for (Object value : st.values()) {\n-     *              sb.append(fragmentsIter.next());\n-     *\n-     *              if (value instanceof Boolean) {\n-     *                  throw new IllegalArgumentException(\"I don't like Booleans\");\n-     *              }\n-     *\n-     *              sb.append(value);\n-     *          }\n-     *\n-     *          sb.append(fragmentsIter.next());\n-     *\n-     *          return sb.toString();\n-     *     }\n-     * }\n-     *\n-     * MyProcessor myProcessor = new MyProcessor();\n-     * try {\n-     *     int x = 10;\n-     *     int y = 20;\n-     *     String result = myProcessor.\"\\{x} + \\{y} = \\{x + y}\";\n-     *     ...\n-     * } catch (IllegalArgumentException ex) {\n-     *     ...\n-     * }\n-     * }\n-     * Implementations of this interface may provide, but are not limited to, validating\n-     * inputs, composing inputs into a result, and transforming an intermediate string\n-     * result to a non-string value before delivering the final result.\n-     * <p>\n-     * The user has the option of validating inputs used in composition. For example an SQL\n-     * processor could prevent injection vulnerabilities by sanitizing inputs or throwing an\n-     * exception of type {@code E} if an SQL statement is a potential vulnerability.\n-     * <p>\n-     * Composing allows user control over how the result is assembled. Most often, a\n-     * user will construct a new string from the string template, with placeholders\n-     * replaced by string representations of value list elements. These string\n-     * representations are created as if invoking {@link String#valueOf}.\n-     * <p>\n-     * Transforming allows the processor to return something other than a string. For\n-     * instance, a JSON processor could return a JSON object, by parsing the string created\n-     * by composition, instead of the composed string.\n-     * <p>\n-     * {@link Processor} is a {@link FunctionalInterface}. This permits\n-     * declaration of a processor using lambda expressions;\n-     * {@snippet :\n-     * Processor<String, RuntimeException> processor = st -> {\n-     *     List<String> fragments = st.fragments();\n-     *     List<Object> values = st.values();\n-     *     \/\/ check or manipulate the fragments and\/or values\n-     *     ...\n-     *     return StringTemplate.interpolate(fragments, values);\n-     * };\n-     * }\n-     * The {@link StringTemplate#interpolate()} method is available for those processors\n-     * that just need to work with the string interpolation;\n-     * {@snippet :\n-     * Processor<String, RuntimeException> processor = StringTemplate::interpolate;\n-     * }\n-     * or simply transform the string interpolation into something other than\n-     * {@link String};\n-     * {@snippet :\n-     * Processor<JSONObject, RuntimeException> jsonProcessor = st -> new JSONObject(st.interpolate());\n-     * }\n-     * @implNote The Java compiler automatically imports {@link StringTemplate#STR}\n-     *\n-     * @param <R>  Processor's process result type\n-     * @param <E>  Exception thrown type\n-     *\n-     * @see StringTemplate\n-     * @see java.util.FormatProcessor\n-     *\n-     * @since 21\n-     *\n-     * @jls 15.8.6 Process Template Expressions\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    @FunctionalInterface\n-    public interface Processor<R, E extends Throwable> {\n-\n-        \/**\n-         * Constructs a result based on the template fragments and values in the\n-         * supplied {@link StringTemplate stringTemplate} object.\n-         * @apiNote Processing of a {@link StringTemplate} may include validation according to the particular facts relating\n-         * to each situation. The {@code E} type parameter indicates the type of checked exception that is thrown by\n-         * {@link #process} if validation fails, ex. {@code java.sql.SQLException}. If no checked exception is expected\n-         * then {@link RuntimeException} may be used. Note that unchecked exceptions, such as {@link RuntimeException},\n-         * {@link NullPointerException} or {@link IllegalArgumentException} may be thrown as part of the normal\n-         * method arguments processing. Details of which exceptions are thrown will be found in the documentation\n-         * of the specific implementation.\n-         *\n-         * @param stringTemplate  a {@link StringTemplate} instance\n-         *\n-         * @return constructed object of type R\n-         *\n-         * @throws E exception thrown by the template processor when validation fails\n-         *\/\n-        R process(StringTemplate stringTemplate) throws E;\n-\n-        \/**\n-         * This factory method can be used to create a {@link Processor} containing a\n-         * {@link Processor#process} method derived from a lambda expression. As an example;\n-         * {@snippet :\n-         * Processor<String, RuntimeException> mySTR = Processor.of(StringTemplate::interpolate);\n-         * int x = 10;\n-         * int y = 20;\n-         * String str = mySTR.\"\\{x} + \\{y} = \\{x + y}\";\n-         * }\n-         * The result type of the constructed {@link Processor} may be derived from\n-         * the lambda expression, thus this method may be used in a var\n-         * statement. For example, {@code mySTR} from above can also be declared using;\n-         * {@snippet :\n-         * var mySTR = Processor.of(StringTemplate::interpolate);\n-         * }\n-         * {@link RuntimeException} is the assumed exception thrown type.\n-         *\n-         * @param process a function that takes a {@link StringTemplate} as an argument\n-         *                and returns the inferred result type\n-         *\n-         * @return a {@link Processor}\n-         *\n-         * @param <T>  Processor's process result type\n-         *\/\n-        static <T> Processor<T, RuntimeException> of(Function<? super StringTemplate, ? extends T> process) {\n-            return process::apply;\n-        }\n-\n-        \/**\n-         * Built-in policies using this additional interface have the flexibility to\n-         * specialize the composition of the templated string by returning a customized\n-         * {@link MethodHandle} from {@link Linkage#linkage linkage}.\n-         * These specializations are typically implemented to improve performance;\n-         * specializing value types or avoiding boxing and vararg arrays.\n-         *\n-         * @implNote This interface is sealed to only allow standard processors.\n-         *\n-         * @sealedGraph\n-         * @since 21\n-         *\/\n-        @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-        public sealed interface Linkage permits FormatProcessor {\n-            \/**\n-             * This method creates a {@link MethodHandle} that when invoked with arguments of\n-             * those specified in {@code type} returns a result that equals that returned by\n-             * the template processor's process method. The difference being that this method\n-             * can preview the template's fragments and value types in advance of usage and\n-             * thereby has the opportunity to produce a specialized implementation.\n-             *\n-             * @param fragments  string template fragments\n-             * @param type       method type, includes the StringTemplate receiver as\n-             * well as the value types\n-             *\n-             * @return {@link MethodHandle} for the processor applied to template\n-             *\n-             * @throws NullPointerException if any of the arguments are null\n-             *\/\n-            MethodHandle linkage(List<String> fragments, MethodType type);\n-        }\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringTemplate.java","additions":0,"deletions":622,"binary":false,"changes":622,"status":"deleted"},{"patch":"@@ -83,1 +83,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -2493,0 +2492,3 @@\n+            public void putCharUTF16(byte[] bytes, int index, int ch) {\n+                StringUTF16.putChar(bytes, index, ch);\n+            }\n@@ -2533,0 +2535,4 @@\n+            public long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value) {\n+                return StringConcatHelper.prepend(indexCoder, buf, value);\n+            }\n+\n@@ -2541,3 +2547,6 @@\n-            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-            public long stringConcatCoder(char value) {\n-                return StringConcatHelper.coder(value);\n+            public long stringConcatMix(long lengthCoder, char value) {\n+                return StringConcatHelper.mix(lengthCoder, value);\n+            }\n+\n+            public int stringSize(long i) {\n+                return Long.stringSize(i);\n@@ -2546,4 +2555,2 @@\n-            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-            public long stringBuilderConcatMix(long lengthCoder,\n-                                               StringBuilder sb) {\n-                return sb.mix(lengthCoder);\n+            public int getCharsLatin1(long i, int index, byte[] buf) {\n+                return StringLatin1.getChars(i, index, buf);\n@@ -2552,4 +2559,2 @@\n-            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-            public long stringBuilderConcatPrepend(long lengthCoder, byte[] buf,\n-                                                   StringBuilder sb) {\n-                return sb.prepend(lengthCoder, buf);\n+            public int getCharsUTF16(long i, int index, byte[] buf) {\n+                return StringUTF16.getChars(i, index, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.util.FormatConcatItem;\n@@ -121,1 +120,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n@@ -715,3 +713,0 @@\n-            if (idx == STRING_CONCAT_ITEM) {\n-                cl = FormatConcatItem.class;\n-            }\n@@ -729,3 +724,0 @@\n-            if (idx == STRING_CONCAT_ITEM) {\n-                cl = FormatConcatItem.class;\n-            }\n@@ -744,2 +736,1 @@\n-            STRING_CONCAT_ITEM = 5,\n-            TYPE_COUNT = 6;\n+            TYPE_COUNT = 5;\n@@ -752,1 +743,0 @@\n-        if (FormatConcatItem.class.isAssignableFrom(cl)) return STRING_CONCAT_ITEM;\n@@ -1050,299 +1040,0 @@\n-    \/**\n-     * Simplified concatenation method to facilitate {@link StringTemplate}\n-     * concatenation. This method returns a single concatenation method that\n-     * interleaves fragments and values. fragment|value|fragment|value|...|value|fragment.\n-     * The number of fragments must be one more that the number of ptypes.\n-     * The total number of slots used by the ptypes must be less than or equal\n-     * to {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n-     *\n-     * @param fragments list of string fragments\n-     * @param ptypes    list of expression types\n-     *\n-     * @return the {@link MethodHandle} for concatenation\n-     *\n-     * @throws StringConcatException If any of the linkage invariants are violated.\n-     * @throws NullPointerException If any of the incoming arguments is null.\n-     * @throws IllegalArgumentException If the number of value slots exceed {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n-     *\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    public static MethodHandle makeConcatWithTemplate(\n-            List<String> fragments,\n-            List<Class<?>> ptypes)\n-            throws StringConcatException\n-    {\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-        Objects.requireNonNull(ptypes, \"ptypes is null\");\n-        ptypes = List.copyOf(ptypes);\n-\n-        if (fragments.size() != ptypes.size() + 1) {\n-            throw new IllegalArgumentException(\"fragments size not equal ptypes size plus one\");\n-        }\n-\n-        if (ptypes.isEmpty()) {\n-            return MethodHandles.constant(String.class, fragments.get(0));\n-        }\n-\n-        Class<?>[] ttypes = new Class<?>[ptypes.size()];\n-        MethodHandle[] filters = new MethodHandle[ptypes.size()];\n-        int slots = 0;\n-\n-        int pos = 0;\n-        for (Class<?> ptype : ptypes) {\n-            slots += ptype == long.class || ptype == double.class ? 2 : 1;\n-\n-            if (MAX_INDY_CONCAT_ARG_SLOTS < slots) {\n-                throw new StringConcatException(\"Too many concat argument slots: \" +\n-                        slots + \", can only accept \" + MAX_INDY_CONCAT_ARG_SLOTS);\n-            }\n-\n-            boolean isSpecialized = ptype.isPrimitive();\n-            boolean isFormatConcatItem = FormatConcatItem.class.isAssignableFrom(ptype);\n-            Class<?> ttype = isSpecialized ? promoteToIntType(ptype) :\n-                             isFormatConcatItem ? FormatConcatItem.class : Object.class;\n-            MethodHandle filter = isFormatConcatItem ? null : stringifierFor(ttype);\n-\n-            if (filter != null) {\n-                filters[pos] = filter;\n-                ttype = String.class;\n-            }\n-\n-            ttypes[pos++] = ttype;\n-        }\n-\n-        MethodHandle mh = MethodHandles.dropArguments(newString(), 2, ttypes);\n-\n-        long initialLengthCoder = INITIAL_CODER;\n-        pos = 0;\n-        for (String fragment : fragments) {\n-            initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, fragment);\n-\n-            if (ttypes.length <= pos) {\n-                break;\n-            }\n-\n-            Class<?> ttype = ttypes[pos];\n-            \/\/ (long,byte[],ttype) -> long\n-            MethodHandle prepender = prepender(fragment, ttype);\n-            \/\/ (byte[],long,ttypes...) -> String (unchanged)\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepender,1, 0, 2 + pos);\n-\n-            pos++;\n-        }\n-\n-        String lastFragment = fragments.getLast();\n-        initialLengthCoder -= lastFragment.length();\n-        MethodHandle newArrayCombinator = lastFragment.isEmpty() ? newArray() :\n-                newArrayWithSuffix(lastFragment);\n-        \/\/ (long,ttypes...) -> String\n-        mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,\n-                1 \/\/ index\n-        );\n-\n-        pos = 0;\n-        for (Class<?> ttype : ttypes) {\n-            \/\/ (long,ttype) -> long\n-            MethodHandle mix = mixer(ttypes[pos]);\n-            boolean lastPType = pos == ttypes.length - 1;\n-\n-            if (lastPType) {\n-                \/\/ (ttype) -> long\n-                mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);\n-                \/\/ (ttypes...) -> String\n-                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                        1 + pos \/\/ selected argument\n-                );\n-            } else {\n-                \/\/ (long,ttypes...) -> String\n-                mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,\n-                        0, \/\/ old-index\n-                        1 + pos \/\/ selected argument\n-                );\n-            }\n-\n-            pos++;\n-        }\n-\n-        mh = MethodHandles.filterArguments(mh, 0, filters);\n-        MethodType mt = MethodType.methodType(String.class, ptypes);\n-        mh = mh.viewAsType(mt, true);\n-\n-        return mh;\n-    }\n-\n-    \/**\n-     * This method breaks up large concatenations into separate\n-     * {@link MethodHandle MethodHandles} based on the number of slots required\n-     * per {@link MethodHandle}. Each {@link MethodHandle} after the first will\n-     * have an extra {@link String} slot for the result from the previous\n-     * {@link MethodHandle}.\n-     * {@link #makeConcatWithTemplate}\n-     * is used to construct the {@link MethodHandle MethodHandles}. The total\n-     * number of slots used by the ptypes is open ended. However, care must\n-     * be given when combining the {@link MethodHandle MethodHandles} so that\n-     * the combine total does not exceed the 255 slot limit.\n-     *\n-     * @param fragments list of string fragments\n-     * @param ptypes    list of expression types\n-     * @param maxSlots  maximum number of slots per {@link MethodHandle}.\n-     *\n-     * @return List of {@link MethodHandle MethodHandles}\n-     *\n-     * @throws IllegalArgumentException If maxSlots is not between 1 and\n-     *                                  MAX_INDY_CONCAT_ARG_SLOTS.\n-     * @throws StringConcatException If any of the linkage invariants are violated.\n-     * @throws NullPointerException If any of the incoming arguments is null.\n-     * @throws IllegalArgumentException If the number of value slots exceed {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n-     *\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    public static List<MethodHandle> makeConcatWithTemplateCluster(\n-            List<String> fragments,\n-            List<Class<?>> ptypes,\n-            int maxSlots)\n-            throws StringConcatException\n-    {\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-        Objects.requireNonNull(ptypes, \"ptypes is null\");\n-\n-        if (fragments.size() != ptypes.size() + 1) {\n-            throw new StringConcatException(\"fragments size not equal ptypes size plus one\");\n-        }\n-\n-        if (maxSlots < 1 || MAX_INDY_CONCAT_ARG_SLOTS < maxSlots) {\n-            throw new IllegalArgumentException(\"maxSlots must be between 1 and \" +\n-                    MAX_INDY_CONCAT_ARG_SLOTS);\n-\n-        }\n-\n-        if (ptypes.isEmpty()) {\n-            return List.of(MethodHandles.constant(String.class, fragments.get(0)));\n-        }\n-\n-        List<MethodHandle> mhs = new ArrayList<>();\n-        List<String> fragmentsSection = new ArrayList<>();\n-        List<Class<?>> ptypeSection = new ArrayList<>();\n-        int slots = 0;\n-\n-        int pos = 0;\n-        for (Class<?> ptype : ptypes) {\n-            boolean lastPType = pos == ptypes.size() - 1;\n-            fragmentsSection.add(fragments.get(pos));\n-            ptypeSection.add(ptype);\n-\n-            slots += ptype == long.class || ptype == double.class ? 2 : 1;\n-\n-            if (maxSlots <= slots || lastPType) {\n-                fragmentsSection.add(lastPType ? fragments.get(pos + 1) : \"\");\n-                MethodHandle mh = makeConcatWithTemplate(fragmentsSection,\n-                        ptypeSection);\n-                mhs.add(mh);\n-                fragmentsSection.clear();\n-                fragmentsSection.add(\"\");\n-                ptypeSection.clear();\n-                ptypeSection.add(String.class);\n-                slots = 1;\n-            }\n-\n-            pos++;\n-        }\n-\n-        return mhs;\n-    }\n-\n-    \/**\n-     * This method creates a {@link MethodHandle} expecting one input, the\n-     * receiver of the supplied getters. This method uses\n-     * {@link #makeConcatWithTemplateCluster}\n-     * to create the intermediate {@link MethodHandle MethodHandles}.\n-     *\n-     * @param fragments list of string fragments\n-     * @param getters   list of getter {@link MethodHandle MethodHandles}\n-     * @param maxSlots  maximum number of slots per {@link MethodHandle} in\n-     *                  cluster.\n-     *\n-     * @return the {@link MethodHandle} for concatenation\n-     *\n-     * @throws IllegalArgumentException If maxSlots is not between 1 and\n-     *                                  MAX_INDY_CONCAT_ARG_SLOTS or if the\n-     *                                  getters don't use the same argument type\n-     * @throws StringConcatException If any of the linkage invariants are violated\n-     * @throws NullPointerException If any of the incoming arguments is null\n-     * @throws IllegalArgumentException If the number of value slots exceed {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n-     *\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    public static MethodHandle makeConcatWithTemplateGetters(\n-            List<String> fragments,\n-            List<MethodHandle> getters,\n-            int maxSlots)\n-            throws StringConcatException\n-    {\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-        Objects.requireNonNull(getters, \"getters is null\");\n-\n-        if (fragments.size() != getters.size() + 1) {\n-            throw new StringConcatException(\"fragments size not equal getters size plus one\");\n-        }\n-\n-        if (maxSlots < 1 || MAX_INDY_CONCAT_ARG_SLOTS < maxSlots) {\n-            throw new IllegalArgumentException(\"maxSlots must be between 1 and \" +\n-                    MAX_INDY_CONCAT_ARG_SLOTS);\n-\n-        }\n-\n-        if (getters.size() == 0) {\n-            throw new StringConcatException(\"no getters supplied\");\n-        }\n-\n-        Class<?> receiverType = null;\n-        List<Class<?>> ptypes = new ArrayList<>();\n-\n-        for (MethodHandle getter : getters) {\n-            MethodType mt = getter.type();\n-            Class<?> returnType = mt.returnType();\n-\n-            if (returnType == void.class || mt.parameterCount() != 1) {\n-                throw new StringConcatException(\"not a getter \" + mt);\n-            }\n-\n-            if (receiverType == null) {\n-                receiverType = mt.parameterType(0);\n-            } else if (receiverType != mt.parameterType(0)) {\n-                throw new StringConcatException(\"not the same receiever type \" +\n-                        mt + \" needs \" + receiverType);\n-            }\n-\n-            ptypes.add(returnType);\n-        }\n-\n-        MethodType resultType = MethodType.methodType(String.class, receiverType);\n-        List<MethodHandle> clusters = makeConcatWithTemplateCluster(fragments, ptypes,\n-                maxSlots);\n-\n-        MethodHandle mh = null;\n-        Iterator<MethodHandle> getterIterator = getters.iterator();\n-\n-        for (MethodHandle cluster : clusters) {\n-            MethodType mt = cluster.type();\n-            MethodHandle[] filters = new MethodHandle[mt.parameterCount()];\n-            int pos = 0;\n-\n-            if (mh != null) {\n-                filters[pos++] = mh;\n-            }\n-\n-            while (pos < filters.length) {\n-                filters[pos++] = getterIterator.next();\n-            }\n-\n-            cluster = MethodHandles.filterArguments(cluster, 0, filters);\n-            mh = MethodHandles.permuteArguments(cluster, resultType,\n-                    new int[filters.length]);\n-        }\n-\n-        return mh;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":1,"deletions":310,"binary":false,"changes":311,"status":"modified"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.util.List;\n-import java.util.Objects;\n-\n-\/**\n- * This class implements specialized {@link StringTemplate StringTemplates} produced by\n- * string template bootstrap method callsites generated by the compiler. Instances of this\n- * class are produced by {@link StringTemplateImplFactory}.\n- * <p>\n- * Values are stored by subclassing {@link Carriers.CarrierObject}. This allows specializations\n- * and sharing of value shapes without creating a new class for each shape.\n- * <p>\n- * {@link StringTemplate} fragments are shared via binding to the\n- * {@link java.lang.invoke.CallSite CallSite's} {@link MethodHandle}.\n- * <p>\n- * The {@link StringTemplateImpl} instance also carries\n- * specialized {@link MethodHandle MethodHandles} for producing the values list and interpolation.\n- * These {@link MethodHandle MethodHandles} are  also shared by binding to the\n- * {@link java.lang.invoke.CallSite CallSite}.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-final class StringTemplateImpl extends Carriers.CarrierObject implements StringTemplate {\n-    \/**\n-     * List of string fragments for the string template. This value of this list is shared by\n-     * all instances created at the {@link java.lang.invoke.CallSite CallSite}.\n-     *\/\n-    private final List<String> fragments;\n-\n-    \/**\n-     * Specialized {@link MethodHandle} used to implement the {@link StringTemplate StringTemplate's}\n-     * {@code values} method. This {@link MethodHandle} is shared by all instances created at the\n-     * {@link java.lang.invoke.CallSite CallSite}.\n-     *\/\n-    private final MethodHandle valuesMH;\n-\n-    \/**\n-     * Specialized {@link MethodHandle} used to implement the {@link StringTemplate StringTemplate's}\n-     * {@code interpolate} method. This {@link MethodHandle} is shared by all instances created at the\n-     * {@link java.lang.invoke.CallSite CallSite}.\n-     *\/\n-    private final MethodHandle interpolateMH;\n-\n-    \/**\n-     * Constructor.\n-     *\n-     * @param primitiveCount  number of primitive slots required (bound at callsite)\n-     * @param objectCount     number of object slots required (bound at callsite)\n-     * @param fragments       list of string fragments (bound in (bound at callsite)\n-     * @param valuesMH        {@link MethodHandle} to produce list of values (bound at callsite)\n-     * @param interpolateMH   {@link MethodHandle} to produce interpolation (bound at callsite)\n-     *\/\n-    StringTemplateImpl(int primitiveCount, int objectCount,\n-                       List<String> fragments, MethodHandle valuesMH, MethodHandle interpolateMH) {\n-        super(primitiveCount, objectCount);\n-        this.fragments = fragments;\n-        this.valuesMH = valuesMH;\n-        this.interpolateMH = interpolateMH;\n-    }\n-\n-    @Override\n-    public List<String> fragments() {\n-        return fragments;\n-    }\n-\n-    @Override\n-    public List<Object> values() {\n-        try {\n-            return (List<Object>)valuesMH.invokeExact(this);\n-        } catch (RuntimeException | Error ex) {\n-            throw ex;\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(\"string template values failure\", ex);\n-        }\n-    }\n-\n-    @Override\n-    public String interpolate() {\n-        try {\n-            return (String)interpolateMH.invokeExact(this);\n-        } catch (RuntimeException | Error ex) {\n-            throw ex;\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(\"string template interpolate failure\", ex);\n-        }\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        return other instanceof StringTemplate st &&\n-                Objects.equals(fragments(), st.fragments()) &&\n-                Objects.equals(values(), st.values());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(fragments(), values());\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return StringTemplate.toString(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/StringTemplateImpl.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.StringConcatException;\n-import java.lang.invoke.StringConcatFactory;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-\/**\n- * This class synthesizes {@link StringTemplate StringTemplates} based on\n- * fragments and bootstrap method type. Usage is primarily from\n- * {@link java.lang.runtime.TemplateRuntime}.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-final class StringTemplateImplFactory {\n-\n-    \/**\n-     * Private constructor.\n-     *\/\n-    StringTemplateImplFactory() {\n-        throw new AssertionError(\"private constructor\");\n-    }\n-\n-    \/*\n-     * {@link StringTemplateImpl} constructor MethodHandle.\n-     *\/\n-    private static final MethodHandle CONSTRUCTOR;\n-\n-\n-    \/*\n-     * Frequently used method types.\n-     *\/\n-    private static final MethodType MT_STRING_STIMPL =\n-            MethodType.methodType(String.class, StringTemplateImpl.class);\n-    private static final MethodType MT_LIST_STIMPL =\n-            MethodType.methodType(List.class, StringTemplateImpl.class);\n-\n-    \/**\n-     * List (for nullable) of MethodHandle;\n-     *\/\n-    private static final MethodHandle TO_LIST;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-            MethodType mt = MethodType.methodType(void.class, int.class, int.class, List.class,\n-                    MethodHandle.class, MethodHandle.class);\n-            CONSTRUCTOR = lookup.findConstructor(StringTemplateImpl.class, mt)\n-                    .asType(mt.changeReturnType(Carriers.CarrierObject.class));\n-\n-            mt = MethodType.methodType(List.class, Object[].class);\n-            TO_LIST = lookup.findStatic(StringTemplateImplFactory.class, \"toList\", mt);\n-        } catch(ReflectiveOperationException ex) {\n-            throw new AssertionError(\"carrier static init fail\", ex);\n-        }\n-    }\n-\n-    \/**\n-     * Create a new {@link StringTemplateImpl} constructor.\n-     *\n-     * @param fragments  string template fragments\n-     * @param type       values types with StringTemplate return\n-     *\n-     * @return {@link MethodHandle} that can construct a {@link StringTemplateImpl} with arguments\n-     * used as values.\n-     *\/\n-    static MethodHandle createStringTemplateImplMH(List<String> fragments, MethodType type) {\n-        Carriers.CarrierElements elements = Carriers.CarrierFactory.of(type);\n-        MethodHandle[] components = elements\n-                .components()\n-                .stream()\n-                .map(c -> c.asType(c.type().changeParameterType(0, StringTemplateImpl.class)))\n-                .toArray(MethodHandle[]::new);\n-        Class<?>[] ptypes = elements\n-                .components()\n-                .stream()\n-                .map(c -> c.type().returnType())\n-                .toArray(Class<?>[]::new);\n-        int[] permute = new int[ptypes.length];\n-\n-        MethodHandle interpolateMH;\n-        MethodType mt;\n-        try {\n-            interpolateMH = StringConcatFactory.makeConcatWithTemplate(fragments, List.of(ptypes));\n-        } catch (StringConcatException ex) {\n-            throw new RuntimeException(\"constructing internal string template\", ex);\n-        }\n-        interpolateMH = MethodHandles.filterArguments(interpolateMH, 0, components);\n-        interpolateMH = MethodHandles.permuteArguments(interpolateMH, MT_STRING_STIMPL, permute);\n-\n-        mt = MethodType.methodType(List.class, ptypes);\n-        MethodHandle valuesMH = TO_LIST.asCollector(Object[].class, components.length).asType(mt);\n-        valuesMH = MethodHandles.filterArguments(valuesMH, 0, components);\n-        valuesMH = MethodHandles.permuteArguments(valuesMH, MT_LIST_STIMPL, permute);\n-\n-        MethodHandle constructor = MethodHandles.insertArguments(CONSTRUCTOR, 0,\n-                elements.primitiveCount(), elements.objectCount(),\n-                fragments, valuesMH, interpolateMH);\n-        constructor = MethodHandles.foldArguments(elements.initializer(), 0, constructor);\n-\n-        mt = MethodType.methodType(StringTemplate.class, ptypes);\n-        constructor = constructor.asType(mt);\n-\n-        return constructor;\n-    }\n-\n-    \/**\n-     * Generic {@link StringTemplate}.\n-     *\n-     * @param fragments  immutable list of string fragments from string template\n-     * @param values     immutable list of expression values\n-     *\/\n-    private record SimpleStringTemplate(List<String> fragments, List<Object> values)\n-            implements StringTemplate {\n-        @Override\n-        public String toString() {\n-            return StringTemplate.toString(this);\n-        }\n-    }\n-\n-    \/**\n-     * Returns a new StringTemplate composed from fragments and values.\n-     *\n-     * @param fragments array of string fragments\n-     * @param values    array of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\/\n-    static StringTemplate newTrustedStringTemplate(String[] fragments, Object[] values) {\n-        return new SimpleStringTemplate(List.of(fragments), toList(values));\n-    }\n-\n-    \/**\n-     * Returns a new StringTemplate composed from fragments and values.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    array of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\/\n-    static StringTemplate newTrustedStringTemplate(List<String> fragments, Object[] values) {\n-        return new SimpleStringTemplate(List.copyOf(fragments), toList(values));\n-    }\n-\n-    \/**\n-     * Returns a new StringTemplate composed from fragments and values.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    list of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\/\n-\n-    static StringTemplate newStringTemplate(List<String> fragments, List<?> values) {\n-        @SuppressWarnings(\"unchecked\")\n-        List<Object> copy = (List<Object>)values.stream().toList();\n-        return new SimpleStringTemplate(List.copyOf(fragments), copy);\n-    }\n-\n-    \/**\n-     * Collect nullable elements from an array into a unmodifiable list.\n-     * Elements are guaranteed to be safe.\n-     *\n-     * @param elements  elements to place in list\n-     *\n-     * @return unmodifiable list.\n-     *\/\n-    private static List<Object> toList(Object[] elements) {\n-        return Arrays.stream(elements).toList();\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/StringTemplateImplFactory.java","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.ConstantCallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.StringTemplate.Processor;\n-import java.lang.StringTemplate.Processor.Linkage;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.access.JavaTemplateAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * Manages string template bootstrap methods. These methods may be used, for example,\n- * by Java compiler implementations to create {@link StringTemplate} instances. For example,\n- * the java compiler will translate the following code;\n- * {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n- * }\n- * to byte code that invokes the {@link java.lang.runtime.TemplateRuntime#newStringTemplate}\n- * bootstrap method to construct a {@link CallSite} that accepts two integers and produces a new\n- * {@link StringTemplate} instance.\n- * {@snippet :\n- * MethodHandles.Lookup lookup = MethodHandles.lookup();\n- * MethodType mt = MethodType.methodType(StringTemplate.class, int.class, int.class);\n- * CallSite cs = TemplateRuntime.newStringTemplate(lookup, \"\", mt, \"\", \" + \", \" = \", \"\");\n- * ...\n- * int x = 10;\n- * int y = 20;\n- * StringTemplate st = (StringTemplate)cs.getTarget().invokeExact(x, y);\n- * }\n- * If the string template requires more than\n- * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS} value slots,\n- * then the java compiler will use the\n- * {@link java.lang.runtime.TemplateRuntime#newLargeStringTemplate} bootstrap method\n- * instead. For example, the java compiler will translate the following code;\n- * {@snippet :\n- * int[] a = new int[1000], b = new int[1000];\n- * ...\n- * StringTemplate st = \"\"\"\n- *      \\{a[0]} - \\{b[0]}\n- *      \\{a[1]} - \\{b[1]}\n- *      ...\n- *      \\{a[999]} - \\{b[999]}\n- *      \"\"\";\n- * }\n- * to byte code that invokes the {@link java.lang.runtime.TemplateRuntime#newLargeStringTemplate}\n- * bootstrap method to construct a {@link CallSite} that accepts an array of integers and produces a new\n- * {@link StringTemplate} instance.\n- * {@snippet :\n- * MethodType mt = MethodType.methodType(StringTemplate.class, String[].class, Object[].class);\n- * CallSite cs = TemplateRuntime.newStringTemplate(lookup, \"\", mt);\n- * ...\n- * int[] a = new int[1000], b = new int[1000];\n- * ...\n- * StringTemplate st = (StringTemplate)cs.getTarget().invokeExact(\n- *         new String[] { \"\", \" - \", \"\\n\", \" - \", \"\\n\", ... \" - \", \"\\n\" },\n- *         new Object[] { a[0], b[0], a[1], b[1], ..., a[999], b[999]}\n- *         );\n- * }\n- *\n- * @since 21\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-public final class TemplateRuntime {\n-    private static final JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-\n-    \/**\n-     * {@link MethodHandle} to {@link TemplateRuntime#defaultProcess}.\n-     *\/\n-    private static final MethodHandle DEFAULT_PROCESS_MH;\n-\n-    \/**\n-     * {@link MethodHandle} to {@link TemplateRuntime#newTrustedStringTemplate}.\n-     *\/\n-    private static final MethodHandle NEW_TRUSTED_STRING_TEMPLATE;\n-\n-    \/**\n-     * Initialize {@link MethodHandle MethodHandles}.\n-     *\/\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-            MethodType mt = MethodType.methodType(Object.class,\n-                    List.class, Processor.class, Object[].class);\n-            DEFAULT_PROCESS_MH =\n-                lookup.findStatic(TemplateRuntime.class, \"defaultProcess\", mt);\n-\n-            mt = MethodType.methodType(StringTemplate.class, String[].class, Object[].class);\n-            NEW_TRUSTED_STRING_TEMPLATE =\n-                lookup.findStatic(StringTemplateImplFactory.class, \"newTrustedStringTemplate\", mt);\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(\"string bootstrap fail\", ex);\n-        }\n-    }\n-\n-    \/**\n-     * Private constructor.\n-     *\/\n-    private TemplateRuntime() {\n-        throw new AssertionError(\"private constructor\");\n-    }\n-\n-    \/**\n-     * String template bootstrap method for creating string templates.\n-     * The static arguments include the fragments list.\n-     * The non-static arguments are the values.\n-     *\n-     * @param lookup          method lookup from call site\n-     * @param name            method name - not used\n-     * @param type            method type\n-     *                        (ptypes...) -> StringTemplate\n-     * @param fragments       fragment array for string template\n-     *\n-     * @return {@link CallSite} to handle create string template\n-     *\n-     * @throws NullPointerException if any of the arguments is null\n-     * @throws Throwable            if linkage fails\n-     *\/\n-    public static CallSite newStringTemplate(MethodHandles.Lookup lookup,\n-                                             String name,\n-                                             MethodType type,\n-                                             String... fragments) throws Throwable {\n-        Objects.requireNonNull(lookup, \"lookup is null\");\n-        Objects.requireNonNull(name, \"name is null\");\n-        Objects.requireNonNull(type, \"type is null\");\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-\n-        MethodHandle mh = StringTemplateImplFactory\n-                .createStringTemplateImplMH(List.of(fragments), type).asType(type);\n-\n-        return new ConstantCallSite(mh);\n-    }\n-\n-    \/**\n-     * String template bootstrap method for creating large string templates,\n-     * i.e., when the number of value slots exceeds\n-     * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS}.\n-     * The non-static arguments are the fragments array and values array.\n-     *\n-     * @param lookup          method lookup from call site\n-     * @param name            method name - not used\n-     * @param type            method type\n-     *                        (String[], Object[]) -> StringTemplate\n-     *\n-     * @return {@link CallSite} to handle create large string template\n-     *\n-     * @throws NullPointerException if any of the arguments is null\n-     * @throws Throwable            if linkage fails\n-     *\/\n-    public static CallSite newLargeStringTemplate(MethodHandles.Lookup lookup,\n-                                                  String name,\n-                                                  MethodType type) throws Throwable {\n-        Objects.requireNonNull(lookup, \"lookup is null\");\n-        Objects.requireNonNull(name, \"name is null\");\n-        Objects.requireNonNull(type, \"type is null\");\n-\n-        return new ConstantCallSite(NEW_TRUSTED_STRING_TEMPLATE.asType(type));\n-    }\n-\n-    \/**\n-     * String template bootstrap method for static final processors.\n-     * The static arguments include the fragments array  and a {@link MethodHandle}\n-     * to retrieve the value of the static final processor.\n-     * The non-static arguments are the values.\n-     *\n-     * @param lookup          method lookup from call site\n-     * @param name            method name - not used\n-     * @param type            method type\n-     *                        (ptypes...) -> Object\n-     * @param processorGetter {@link MethodHandle} to get static final processor\n-     * @param fragments       fragments from string template\n-     *\n-     * @return {@link CallSite} to handle string template processing\n-     *\n-     * @throws NullPointerException if any of the arguments is null\n-     * @throws Throwable            if linkage fails\n-     *\n-     * @implNote this method is likely to be revamped before exiting preview.\n-     *\/\n-    public static CallSite processStringTemplate(MethodHandles.Lookup lookup,\n-                                                 String name,\n-                                                 MethodType type,\n-                                                 MethodHandle processorGetter,\n-                                                 String... fragments) throws Throwable {\n-        Objects.requireNonNull(lookup, \"lookup is null\");\n-        Objects.requireNonNull(name, \"name is null\");\n-        Objects.requireNonNull(type, \"type is null\");\n-        Objects.requireNonNull(processorGetter, \"processorGetter is null\");\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-\n-        Processor<?, ?> processor = (Processor<?, ?>)processorGetter.invoke();\n-        MethodHandle mh = processor instanceof Linkage linkage\n-                ? linkage.linkage(List.of(fragments), type)\n-                : defaultProcessMethodHandle(type, processor, List.of(fragments));\n-\n-        return new ConstantCallSite(mh);\n-    }\n-\n-    \/**\n-     * Creates a simple {@link StringTemplate} and then invokes the processor's process method.\n-     *\n-     * @param fragments fragments from string template\n-     * @param processor {@link Processor} to process\n-     * @param values    array of expression values\n-     *\n-     * @return result of processing the string template\n-     *\n-     * @throws Throwable when {@link Processor#process(StringTemplate)} throws\n-     *\/\n-    private static Object defaultProcess(\n-            List<String> fragments,\n-            Processor<?, ?> processor,\n-            Object[] values\n-    ) throws Throwable {\n-        return processor.process(StringTemplate.of(fragments, Arrays.stream(values).toList()));\n-    }\n-\n-    \/**\n-     * Generate a {@link MethodHandle} which is effectively invokes\n-     * {@code processor.process(new StringTemplate(fragments, values...)}.\n-     *\n-     * @return default process {@link MethodHandle}\n-     *\/\n-    private static MethodHandle defaultProcessMethodHandle(\n-            MethodType type,\n-            Processor<?, ?> processor,\n-            List<String> fragments\n-    ) {\n-        MethodHandle mh = MethodHandles.insertArguments(DEFAULT_PROCESS_MH, 0, fragments, processor);\n-        return mh.asCollector(Object[].class, type.parameterCount()).asType(type);\n-    }\n-}\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateRuntime.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaTemplateAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/**\n- * This class provides runtime support for string templates. The methods within\n- * are intended for internal use only.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-final class TemplateSupport implements JavaTemplateAccess {\n-\n-    \/**\n-     * Private constructor.\n-     *\/\n-    private TemplateSupport() {\n-    }\n-\n-    static {\n-        SharedSecrets.setJavaTemplateAccess(new TemplateSupport());\n-    }\n-\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    \/**\n-     * Returns a StringTemplate composed from fragments and values.\n-     *\n-     * @implSpec The {@code fragments} list size must be one more that the\n-     * {@code values} list size.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    list of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n-     *\n-     * @implNote Contents of both lists are copied to construct immutable lists.\n-     *\/\n-    @Override\n-    public StringTemplate of(List<String> fragments, List<?> values) {\n-        return StringTemplateImplFactory.newStringTemplate(fragments, values);\n-    }\n-\n-    \/**\n-     * Creates a string that interleaves the elements of values between the\n-     * elements of fragments.\n-     *\n-     * @param fragments  list of String fragments\n-     * @param values     list of expression values\n-     *\n-     * @return String interpolation of fragments and values\n-     *\/\n-    @Override\n-    public String interpolate(List<String> fragments, List<?> values) {\n-        int fragmentsSize = fragments.size();\n-        int valuesSize = values.size();\n-        if (fragmentsSize == 1) {\n-            return fragments.get(0);\n-        }\n-        int size = fragmentsSize + valuesSize;\n-        String[] strings = new String[size];\n-        int i = 0, j = 0;\n-        for (; j < valuesSize; j++) {\n-            strings[i++] = fragments.get(j);\n-            strings[i++] = String.valueOf(values.get(j));\n-        }\n-        strings[i] = fragments.get(j);\n-        return JLA.join(\"\", \"\", \"\", strings, size);\n-    }\n-\n-    \/**\n-     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n-     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n-     * }\n-     *\n-     * @param sts  zero or more {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if sts is null or if any element of sts is null\n-     *\/\n-    @Override\n-    public StringTemplate combine(StringTemplate... sts) {\n-        Objects.requireNonNull(sts, \"sts must not be null\");\n-        if (sts.length == 0) {\n-            return StringTemplate.of(\"\");\n-        } else if (sts.length == 1) {\n-            return Objects.requireNonNull(sts[0], \"string templates should not be null\");\n-        }\n-        int size = 0;\n-        for (StringTemplate st : sts) {\n-            Objects.requireNonNull(st, \"string templates should not be null\");\n-            size += st.values().size();\n-        }\n-        String[] combinedFragments = new String[size + 1];\n-        Object[] combinedValues = new Object[size];\n-        combinedFragments[0] = \"\";\n-        int fragmentIndex = 1;\n-        int valueIndex = 0;\n-        for (StringTemplate st : sts) {\n-            Iterator<String> iterator = st.fragments().iterator();\n-            combinedFragments[fragmentIndex - 1] += iterator.next();\n-            while (iterator.hasNext()) {\n-                combinedFragments[fragmentIndex++] = iterator.next();\n-            }\n-            for (Object value : st.values()) {\n-                combinedValues[valueIndex++] = value;\n-            }\n-        }\n-        return StringTemplateImplFactory.newTrustedStringTemplate(combinedFragments, combinedValues);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateSupport.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -1,540 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.util;\n-\n-import java.io.IOException;\n-import java.lang.invoke.*;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.nio.ByteOrder;\n-import java.nio.charset.StandardCharsets;\n-import java.text.DecimalFormatSymbols;\n-import java.util.Formatter.FormatSpecifier;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.util.FormatConcatItem;\n-import jdk.internal.util.DecimalDigits;\n-import jdk.internal.util.HexDigits;\n-import jdk.internal.util.OctalDigits;\n-\n-import static java.lang.invoke.MethodType.methodType;\n-\n-\/**\n- * A specialized objects used by FormatterBuilder that knows how to insert\n- * themselves into a concatenation performed by StringConcatFactory.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-class FormatItem {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    private static final MethodHandle CHAR_MIX =\n-            JLA.stringConcatHelper(\"mix\",\n-                    MethodType.methodType(long.class, long.class,char.class));\n-\n-    private static final MethodHandle STRING_PREPEND =\n-            JLA.stringConcatHelper(\"prepend\",\n-                    MethodType.methodType(long.class, long.class, byte[].class,\n-                            String.class));\n-\n-    private static final MethodHandle SELECT_GETCHAR_MH =\n-            JLA.stringConcatHelper(\"selectGetChar\",\n-                    MethodType.methodType(MethodHandle.class, long.class));\n-\n-    private static final MethodHandle SELECT_PUTCHAR_MH =\n-            JLA.stringConcatHelper(\"selectPutChar\",\n-                    MethodType.methodType(MethodHandle.class, long.class));\n-\n-    private static long charMix(long lengthCoder, char value) {\n-        try {\n-            return (long)CHAR_MIX.invokeExact(lengthCoder, value);\n-        } catch (Error | RuntimeException ex) {\n-            throw ex;\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(ex);\n-        }\n-    }\n-\n-    private static long stringMix(long lengthCoder, String value) {\n-        return JLA.stringConcatMix(lengthCoder, value);\n-    }\n-\n-    private static long stringPrepend(long lengthCoder, byte[] buffer,\n-                                            String value) throws Throwable {\n-        return (long)STRING_PREPEND.invokeExact(lengthCoder, buffer, value);\n-    }\n-\n-    private static MethodHandle selectGetChar(long indexCoder) throws Throwable {\n-        return (MethodHandle)SELECT_GETCHAR_MH.invokeExact(indexCoder);\n-    }\n-\n-    private static MethodHandle selectPutChar(long indexCoder) throws Throwable {\n-        return (MethodHandle)SELECT_PUTCHAR_MH.invokeExact(indexCoder);\n-    }\n-\n-    private static final MethodHandle PUT_CHAR_DIGIT;\n-\n-    static {\n-        try {\n-            Lookup lookup = MethodHandles.lookup();\n-            PUT_CHAR_DIGIT = lookup.findStatic(FormatItem.class, \"putByte\",\n-                    MethodType.methodType(void.class,\n-                            byte[].class, int.class, int.class));\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(\"putByte lookup failed\", ex);\n-        }\n-    }\n-\n-    private static void putByte(byte[] buffer, int index, int ch) {\n-        buffer[index] = (byte)ch;\n-    }\n-\n-    private FormatItem() {\n-        throw new AssertionError(\"private constructor\");\n-    }\n-\n-    \/**\n-     * Decimal value format item.\n-     *\/\n-    static final class FormatItemDecimal implements FormatConcatItem {\n-        private final char groupingSeparator;\n-        private final char zeroDigit;\n-        private final char minusSign;\n-        private final int digitOffset;\n-        private final byte[] digits;\n-        private final int length;\n-        private final boolean isNegative;\n-        private final int width;\n-        private final byte prefixSign;\n-        private final int groupSize;\n-        private final long value;\n-        private final boolean parentheses;\n-\n-        FormatItemDecimal(DecimalFormatSymbols dfs, int width, char sign,\n-                          boolean parentheses, int groupSize, long value) throws Throwable {\n-            this.groupingSeparator = dfs.getGroupingSeparator();\n-            this.zeroDigit = dfs.getZeroDigit();\n-            this.minusSign = dfs.getMinusSign();\n-            this.digitOffset = this.zeroDigit - '0';\n-            int length = DecimalDigits.INSTANCE.size(value);\n-            this.digits = new byte[length];\n-            DecimalDigits.INSTANCE.digits(value, this.digits, length, PUT_CHAR_DIGIT);\n-            this.isNegative = value < 0L;\n-            this.length = this.isNegative ? length - 1 : length;\n-            this.width = width;\n-            this.groupSize = groupSize;\n-            this.value = value;\n-            this.parentheses = parentheses && isNegative;\n-            this.prefixSign = (byte)(isNegative ? (parentheses ? '\\0' : minusSign) : sign);\n-        }\n-\n-        private int signLength() {\n-            return (prefixSign != '\\0' ? 1 : 0) + (parentheses ? 2 : 0);\n-        }\n-\n-        private int groupLength() {\n-            return 0 < groupSize ? (length - 1) \/ groupSize : 0;\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return JLA.stringConcatCoder(zeroDigit) |\n-                    (lengthCoder +\n-                     Integer.max(length + signLength() + groupLength(), width));\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            if (parentheses) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)')');\n-            }\n-\n-            if (0 < groupSize) {\n-                int groupIndex = groupSize;\n-\n-                for (int i = 1; i <= length; i++) {\n-                    if (groupIndex-- == 0) {\n-                        putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                                (int)groupingSeparator);\n-                        groupIndex = groupSize - 1;\n-                    }\n-\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n-                }\n-            } else {\n-                for (int i = 1; i <= length; i++) {\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n-                }\n-            }\n-\n-            for (int i = length + signLength() + groupLength(); i < width; i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n-            }\n-\n-            if (parentheses) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'(');\n-            }\n-            if (prefixSign != '\\0') {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)prefixSign);\n-            }\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-    \/**\n-     * Hexadecimal format item.\n-     *\/\n-    static final class FormatItemHexadecimal implements FormatConcatItem {\n-        private final int width;\n-        private final boolean hasPrefix;\n-        private final long value;\n-        private final int length;\n-\n-        FormatItemHexadecimal(int width, boolean hasPrefix, long value) {\n-            this.width = width;\n-            this.hasPrefix = hasPrefix;\n-            this.value = value;\n-            this.length = HexDigits.INSTANCE.size(value);\n-        }\n-\n-        private int prefixLength() {\n-            return hasPrefix ? 2 : 0;\n-        }\n-\n-        private int zeroesLength() {\n-            return Integer.max(0, width - length - prefixLength());\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return lengthCoder + length + prefixLength() + zeroesLength();\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            HexDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n-            lengthCoder -= length;\n-\n-            for (int i = 0; i < zeroesLength(); i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n-            }\n-\n-            if (hasPrefix) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'x');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n-            }\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-    \/**\n-     * Hexadecimal format item.\n-     *\/\n-    static final class FormatItemOctal implements FormatConcatItem {\n-        private final int width;\n-        private final boolean hasPrefix;\n-        private final long value;\n-        private final int length;\n-\n-        FormatItemOctal(int width, boolean hasPrefix, long value) {\n-            this.width = width;\n-            this.hasPrefix = hasPrefix;\n-            this.value = value;\n-            this.length = OctalDigits.INSTANCE.size(value);\n-        }\n-\n-        private int prefixLength() {\n-            return hasPrefix && value != 0 ? 1 : 0;\n-        }\n-\n-        private int zeroesLength() {\n-            return Integer.max(0, width - length - prefixLength());\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return lengthCoder + length + prefixLength() + zeroesLength();\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            OctalDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n-            lengthCoder -= length;\n-\n-            for (int i = 0; i < zeroesLength(); i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n-            }\n-\n-            if (hasPrefix && value != 0) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n-            }\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-    \/**\n-     * Boolean format item.\n-     *\/\n-    static final class FormatItemBoolean implements FormatConcatItem {\n-        private final boolean value;\n-\n-        FormatItemBoolean(boolean value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return lengthCoder + (value ? \"true\".length() : \"false\".length());\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            if (value) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'r');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'t');\n-            } else {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'s');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'a');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'f');\n-            }\n-\n-            return lengthCoder;\n-         }\n-    }\n-\n-    \/**\n-     * Character format item.\n-     *\/\n-    static final class FormatItemCharacter implements FormatConcatItem {\n-        private final char value;\n-\n-        FormatItemCharacter(char value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return charMix(lengthCoder, value);\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)value);\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-    \/**\n-     * String format item.\n-     *\/\n-    static final class FormatItemString implements FormatConcatItem {\n-        private String value;\n-\n-        FormatItemString(String value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return stringMix(lengthCoder, value);\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            return stringPrepend(lengthCoder, buffer, value);\n-        }\n-    }\n-\n-    \/**\n-     * FormatSpecifier format item.\n-     *\/\n-    static final class FormatItemFormatSpecifier implements FormatConcatItem {\n-        private StringBuilder sb;\n-\n-        FormatItemFormatSpecifier(FormatSpecifier fs, Locale locale, Object value) {\n-            this.sb = new StringBuilder(64);\n-            Formatter formatter = new Formatter(this.sb, locale);\n-\n-            try {\n-                fs.print(formatter, value, locale);\n-            } catch (IOException ex) {\n-                throw new AssertionError(\"FormatItemFormatSpecifier IOException\", ex);\n-            }\n-        }\n-\n-        FormatItemFormatSpecifier(Locale locale,\n-                                  int flags, int width, int precision,\n-                                  Formattable formattable) {\n-            this.sb = new StringBuilder(64);\n-            Formatter formatter = new Formatter(this.sb, locale);\n-            formattable.formatTo(formatter, flags, width, precision);\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return JLA.stringBuilderConcatMix(lengthCoder, sb);\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            return JLA.stringBuilderConcatPrepend(lengthCoder, buffer, sb);\n-        }\n-    }\n-\n-    abstract static sealed class FormatItemModifier implements FormatConcatItem\n-        permits FormatItemFillLeft,\n-                FormatItemFillRight\n-    {\n-        private final long itemLengthCoder;\n-        protected final FormatConcatItem item;\n-\n-        FormatItemModifier(FormatConcatItem item) {\n-            this.itemLengthCoder = item.mix(0L);\n-            this.item = item;\n-        }\n-\n-        int length() {\n-            return (int)itemLengthCoder;\n-        }\n-\n-        long coder() {\n-            return itemLengthCoder & ~Integer.MAX_VALUE;\n-        }\n-\n-        @Override\n-        public abstract long mix(long lengthCoder);\n-\n-        @Override\n-        public abstract long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n-    }\n-\n-    \/**\n-     * Fill left format item.\n-     *\/\n-    static final class FormatItemFillLeft extends FormatItemModifier\n-            implements FormatConcatItem {\n-        private final int width;\n-\n-        FormatItemFillLeft(int width, FormatConcatItem item) {\n-            super(item);\n-            this.width = Integer.max(length(), width);\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return (lengthCoder | coder()) + width;\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            lengthCoder = item.prepend(lengthCoder, buffer);\n-\n-            for (int i = length(); i < width; i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n-            }\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-    \/**\n-     * Fill right format item.\n-     *\/\n-    static final class FormatItemFillRight extends FormatItemModifier\n-            implements FormatConcatItem {\n-        private final int width;\n-\n-        FormatItemFillRight(int width, FormatConcatItem item) {\n-            super(item);\n-            this.width = Integer.max(length(), width);\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return (lengthCoder | coder()) + width;\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            for (int i = length(); i < width; i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n-            }\n-\n-            lengthCoder = item.prepend(lengthCoder, buffer);\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n-\n-    \/**\n-     * Null format item.\n-     *\/\n-    static final class FormatItemNull implements FormatConcatItem {\n-        FormatItemNull() {\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return lengthCoder + \"null\".length();\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'n');\n-\n-            return lengthCoder;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":0,"deletions":540,"binary":false,"changes":540,"status":"deleted"},{"patch":"@@ -1,299 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Alibaba Group Holding Limited. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.util;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.StringTemplate.Processor;\n-import java.lang.StringTemplate.Processor.Linkage;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * This {@link Processor} constructs a {@link String} result using\n- * {@link Formatter} specifications and values found in the {@link StringTemplate}.\n- * Unlike {@link Formatter}, {@link FormatProcessor} uses the value from the\n- * embedded expression that immediately follows, without whitespace, the\n- * <a href=\"..\/util\/Formatter.html#syntax\">format specifier<\/a>.\n- * For example:\n- * {@snippet :\n- * FormatProcessor fmt = FormatProcessor.create(Locale.ROOT);\n- * int x = 10;\n- * int y = 20;\n- * String result = fmt.\"%05d\\{x} + %05d\\{y} = %05d\\{x + y}\";\n- * }\n- * In the above example, the value of {@code result} will be {@code \"00010 + 00020 = 00030\"}.\n- * <p>\n- * Embedded expressions without a preceeding format specifier, use {@code %s}\n- * by default.\n- * {@snippet :\n- * FormatProcessor fmt = FormatProcessor.create(Locale.ROOT);\n- * int x = 10;\n- * int y = 20;\n- * String result1 = fmt.\"\\{x} + \\{y} = \\{x + y}\";\n- * String result2 = fmt.\"%s\\{x} + %s\\{y} = %s\\{x + y}\";\n- * }\n- * In the above example, the value of {@code result1} and {@code result2} will\n- * both be {@code \"10 + 20 = 30\"}.\n- * <p>\n- * The {@link FormatProcessor} format specification used and exceptions thrown are the\n- * same as those of {@link Formatter}.\n- * <p>\n- * However, there are two significant differences related to the position of arguments.\n- * An explict {@code n$} and relative {@code <} index will cause an exception due to\n- * a missing argument list.\n- * Whitespace appearing between the specification and the embedded expression will\n- * also cause an exception.\n- * <p>\n- * {@link FormatProcessor} allows the use of different locales. For example:\n- * {@snippet :\n- * Locale locale = Locale.forLanguageTag(\"th-TH-u-nu-thai\");\n- * FormatProcessor thaiFMT = FormatProcessor.create(locale);\n- * int x = 10;\n- * int y = 20;\n- * String result = thaiFMT.\"%4d\\{x} + %4d\\{y} = %5d\\{x + y}\";\n- * }\n- * In the above example, the value of {@code result} will be\n- * {@code \"  \\u0E51\\u0E50 +   \\u0E52\\u0E50 =    \\u0E53\\u0E50\"}.\n- * <p>\n- * For day to day use, the predefined {@link FormatProcessor#FMT} {@link FormatProcessor}\n- * is available. {@link FormatProcessor#FMT} is defined using the {@link Locale#ROOT}.\n- * Example: {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * String result = FMT.\"0x%04x\\{x} + 0x%04x\\{y} = 0x%04x\\{x + y}\"; \/\/ @highlight substring=\"FMT\"\n- * }\n- * In the above example, the value of {@code result} will be {@code \"0x000a + 0x0014 = 0x001E\"}.\n- *\n- * @since 21\n- *\n- * @see Processor\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-public final class FormatProcessor implements Processor<String, RuntimeException>, Linkage {\n-    \/**\n-     * {@link Locale} used to format\n-     *\/\n-    private final Locale locale;\n-\n-    \/**\n-     * Constructor.\n-     *\n-     * @param locale  {@link Locale} used to format\n-     *\/\n-    private FormatProcessor(Locale locale) {\n-        this.locale = locale;\n-    }\n-\n-    \/**\n-     * Create a new {@link FormatProcessor} using the specified locale.\n-     *\n-     * @param locale {@link Locale} used to format\n-     *\n-     * @return a new instance of {@link FormatProcessor}\n-     *\n-     * @throws java.lang.NullPointerException if locale is null\n-     *\/\n-    public static FormatProcessor create(Locale locale) {\n-        Objects.requireNonNull(locale);\n-        return new FormatProcessor(locale);\n-    }\n-\n-    \/**\n-     * Constructs a {@link String} based on the fragments, format\n-     * specifications found in the fragments and values in the\n-     * supplied {@link StringTemplate} object. This method constructs a\n-     * format string from the fragments, gathers up the values and\n-     * evaluates the expression asif evaulating\n-     * {@code new Formatter(locale).format(format, values).toString()}.\n-     * <p>\n-     * If an embedded expression is not immediately preceded by a\n-     * specifier then a {@code %s} is inserted in the format.\n-     *\n-     * @param stringTemplate  a {@link StringTemplate} instance\n-     *\n-     * @return constructed {@link String}\n-\n-     * @throws  IllegalFormatException\n-     *          If a format specifier contains an illegal syntax, a format\n-     *          specifier that is incompatible with the given arguments,\n-     *          a specifier not followed immediately by an embedded expression or\n-     *          other illegal conditions. For specification of all possible\n-     *          formatting errors, see the\n-     *          <a href=\"..\/util\/Formatter.html#detail\">details<\/a>\n-     *          section of the formatter class specification.\n-     * @throws NullPointerException if stringTemplate is null\n-     *\n-     * @see java.util.Formatter\n-     *\/\n-    @Override\n-    public final String process(StringTemplate stringTemplate) {\n-        Objects.requireNonNull(stringTemplate);\n-        String format = stringTemplateFormat(stringTemplate.fragments());\n-        Object[] values = stringTemplate.values().toArray();\n-\n-        return new Formatter(locale).format(format, values).toString();\n-    }\n-\n-    \/**\n-     * Constructs a {@link MethodHandle} that when supplied with the values from\n-     * a {@link StringTemplate} will produce a result equivalent to that provided by\n-     * {@link FormatProcessor#process(StringTemplate)}. This {@link MethodHandle}\n-     * is used by {@link FormatProcessor#FMT} and the ilk to perform a more\n-     * specialized composition of a result. This specialization is done by\n-     * prescanning the fragments and value types of a {@link StringTemplate}.\n-     * <p>\n-     * Process template expressions can be specialized  when the processor is\n-     * of type {@link Linkage} and fetched from a static constant as is\n-     * {@link FormatProcessor#FMT} ({@code static final FormatProcessor}).\n-     * <p>\n-     * Other {@link FormatProcessor FormatProcessors} can be specialized when stored in a static\n-     * final.\n-     * For example:\n-     * {@snippet :\n-     * FormatProcessor THAI_FMT = FormatProcessor.create(Locale.forLanguageTag(\"th-TH-u-nu-thai\"));\n-     * }\n-     * {@code THAI_FMT} will now produce specialized {@link MethodHandle MethodHandles} by way\n-     * of {@link FormatProcessor#linkage(List, MethodType)}.\n-     *\n-     * See {@link FormatProcessor#process(StringTemplate)} for more information.\n-     *\n-     * @throws  IllegalFormatException\n-     *          If a format specifier contains an illegal syntax, a format\n-     *          specifier that is incompatible with the given arguments,\n-     *          a specifier not followed immediately by an embedded expression or\n-     *          other illegal conditions. For specification of all possible\n-     *          formatting errors, see the\n-     *          <a href=\"..\/util\/Formatter.html#detail\">details<\/a>\n-     *          section of the formatter class specification.\n-     * @throws NullPointerException if fragments or type is null\n-     *\n-     * @see java.util.Formatter\n-     *\/\n-    @Override\n-    public MethodHandle linkage(List<String> fragments, MethodType type) {\n-        Objects.requireNonNull(fragments);\n-        Objects.requireNonNull(type);\n-        String format = stringTemplateFormat(fragments);\n-        Class<?>[] ptypes = type.dropParameterTypes(0, 1).parameterArray();\n-        MethodHandle mh = new FormatterBuilder(format, locale, ptypes).build();\n-        mh = MethodHandles.dropArguments(mh, 0, type.parameterType(0));\n-\n-        return mh;\n-    }\n-\n-    \/**\n-     * Find a format specification at the end of a fragment.\n-     *\n-     * @param fragment  fragment to check\n-     * @param needed    if the specification is needed\n-     *\n-     * @return true if the specification is found and needed\n-     *\n-     * @throws MissingFormatArgumentException if not at end or found and not needed\n-     *\/\n-    private static boolean findFormat(String fragment, boolean needed) {\n-        int max = fragment.length();\n-        for (int i = 0; i < max;) {\n-            int n = fragment.indexOf('%', i);\n-            if (n < 0) {\n-                return false;\n-            }\n-\n-            i = n + 1;\n-            if (i >= max) {\n-                return false;\n-            }\n-\n-            char c = fragment.charAt(i);\n-            if (c == '%' || c == 'n') {\n-                i++;\n-                continue;\n-            }\n-            int off = new Formatter.FormatSpecifierParser(null, c, i, fragment, max)\n-                    .parse();\n-            if (off == 0) {\n-                return false;\n-            }\n-            if (i + off == max && needed) {\n-                return true;\n-            }\n-            throw new MissingFormatArgumentException(\n-                    fragment.substring(i - 1, i + off)\n-                    + \" is not immediately followed by an embedded expression\");\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Convert {@link StringTemplate} fragments, containing format specifications,\n-     * to a form that can be passed on to {@link Formatter}. The method scans each fragment,\n-     * matching up formatter specifications with the following expression. If no\n-     * specification is found, the method inserts \"%s\".\n-     *\n-     * @param fragments  string template fragments\n-     *\n-     * @return  format string\n-     *\/\n-    private static String stringTemplateFormat(List<String> fragments) {\n-        StringBuilder sb = new StringBuilder();\n-        int lastIndex = fragments.size() - 1;\n-        List<String> formats = fragments.subList(0, lastIndex);\n-        String last = fragments.get(lastIndex);\n-\n-        for (String format : formats) {\n-            if (findFormat(format, true)) {\n-                sb.append(format);\n-            } else {\n-                sb.append(format);\n-                sb.append(\"%s\");\n-            }\n-        }\n-\n-        if (!findFormat(last, false)) {\n-            sb.append(last);\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-    \/**\n-     * This predefined {@link FormatProcessor} instance constructs a {@link String} result using\n-     * the Locale.ROOT {@link Locale}. See {@link FormatProcessor} for more details.\n-     * Example: {@snippet :\n-     * int x = 10;\n-     * int y = 20;\n-     * String result = FMT.\"0x%04x\\{x} + 0x%04x\\{y} = 0x%04x\\{x + y}\"; \/\/ @highlight substring=\"FMT\"\n-     * }\n-     * In the above example, the value of {@code result} will be {@code \"0x000a + 0x0014 = 0x001E\"}.\n-     *\n-     * @see java.util.FormatProcessor\n-     *\/\n-    public static final FormatProcessor FMT = FormatProcessor.create(Locale.ROOT);\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":0,"deletions":299,"binary":false,"changes":299,"status":"deleted"},{"patch":"@@ -64,1 +64,0 @@\n-import jdk.internal.javac.PreviewFeature;\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,489 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.util;\n-\n-import java.io.IOException;\n-import java.lang.invoke.*;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.text.DecimalFormat;\n-import java.text.DecimalFormatSymbols;\n-import java.text.NumberFormat;\n-import java.text.spi.NumberFormatProvider;\n-import java.util.FormatItem.*;\n-import java.util.Formatter.*;\n-\n-import jdk.internal.util.FormatConcatItem;\n-\n-import sun.invoke.util.Wrapper;\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-import sun.util.locale.provider.ResourceBundleBasedAdapter;\n-\n-import static java.util.Formatter.Conversion.*;\n-import static java.util.Formatter.Flags.*;\n-import static java.lang.invoke.MethodHandles.*;\n-import static java.lang.invoke.MethodType.*;\n-\n-\/**\n- * This package private class supports the construction of the {@link MethodHandle}\n- * used by {@link FormatProcessor}.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-final class FormatterBuilder {\n-    private static final Lookup LOOKUP = lookup();\n-\n-    private final String format;\n-    private final Locale locale;\n-    private final Class<?>[] ptypes;\n-    private final DecimalFormatSymbols dfs;\n-    private final boolean isGenericDFS;\n-\n-    FormatterBuilder(String format, Locale locale, Class<?>[] ptypes) {\n-        this.format = format;\n-        this.locale = locale;\n-        this.ptypes = ptypes;\n-        this.dfs = DecimalFormatSymbols.getInstance(locale);\n-        this.isGenericDFS = isGenericDFS(this.dfs);\n-    }\n-\n-    private static boolean isGenericDFS(DecimalFormatSymbols dfs) {\n-        return dfs.getZeroDigit() == '0' &&\n-               dfs.getDecimalSeparator() == '.' &&\n-               dfs.getGroupingSeparator() == ',' &&\n-               dfs.getMinusSign() == '-';\n-    }\n-\n-    private static Class<?> mapType(Class<?> type) {\n-        return type.isPrimitive() || type == String.class ? type : Object.class;\n-    }\n-\n-    private static MethodHandle findStringConcatItemConstructor(Class<?> cls,\n-                                          Class<?>... ptypes) {\n-        MethodType methodType = methodType(void.class, ptypes);\n-\n-        try {\n-            MethodHandle mh = LOOKUP.findConstructor(cls, methodType);\n-\n-            return mh.asType(mh.type().changeReturnType(FormatConcatItem.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new AssertionError(\"Missing constructor in \" +\n-                    cls + \": \" + methodType);\n-        }\n-    }\n-\n-    private static MethodHandle findMethod(Class<?> cls, String name,\n-                                           Class<?> rType, Class<?>... ptypes) {\n-        MethodType methodType = methodType(rType, ptypes);\n-\n-        try {\n-            return LOOKUP.findVirtual(cls, name, methodType);\n-        } catch (ReflectiveOperationException e) {\n-            throw new AssertionError(\"Missing method in \" +\n-                    cls + \": \" + name + \" \" + methodType);\n-        }\n-    }\n-\n-    private static MethodHandle findStaticMethod(Class<?> cls, String name,\n-                                                 Class<?> rType, Class<?>... ptypes) {\n-        MethodType methodType = methodType(rType, ptypes);\n-\n-        try {\n-            return LOOKUP.findStatic(cls, name, methodType);\n-        } catch (ReflectiveOperationException e) {\n-            throw new AssertionError(\"Missing static method in \" +\n-                    cls + \": \" + name + \" \" + methodType);\n-        }\n-    }\n-\n-    private static final MethodHandle FIDecimal_MH =\n-            findStringConcatItemConstructor(FormatItemDecimal.class,\n-                    DecimalFormatSymbols.class, int.class, char.class, boolean.class,\n-                    int.class, long.class);\n-\n-    private static final MethodHandle FIHexadecimal_MH =\n-            findStringConcatItemConstructor(FormatItemHexadecimal.class,\n-                    int.class, boolean.class, long.class);\n-\n-    private static final MethodHandle FIOctal_MH =\n-            findStringConcatItemConstructor(FormatItemOctal.class,\n-                    int.class, boolean.class, long.class);\n-\n-    private static final MethodHandle FIBoolean_MH =\n-            findStringConcatItemConstructor(FormatItemBoolean.class,\n-                    boolean.class);\n-\n-    private static final MethodHandle FICharacter_MH =\n-            findStringConcatItemConstructor(FormatItemCharacter.class,\n-                    char.class);\n-\n-    private static final MethodHandle FIString_MH =\n-            findStringConcatItemConstructor(FormatItemString.class,\n-                    String.class);\n-\n-    private static final MethodHandle FIFormatSpecifier_MH =\n-            findStringConcatItemConstructor(FormatItemFormatSpecifier.class,\n-                    FormatSpecifier.class, Locale.class, Object.class);\n-\n-    private static final MethodHandle FIFormattable_MH =\n-            findStringConcatItemConstructor(FormatItemFormatSpecifier.class,\n-                    Locale.class, int.class, int.class, int.class,\n-                    Formattable.class);\n-\n-    private static final MethodHandle FIFillLeft_MH =\n-             findStringConcatItemConstructor(FormatItemFillLeft.class,\n-                    int.class, FormatConcatItem.class);\n-\n-    private static final MethodHandle FIFillRight_MH =\n-            findStringConcatItemConstructor(FormatItemFillRight.class,\n-                     int.class, FormatConcatItem.class);\n-\n-    private static final MethodHandle FINull_MH =\n-            findStringConcatItemConstructor(FormatItemNull.class);\n-\n-    private static final MethodHandle NullCheck_MH =\n-            findStaticMethod(FormatterBuilder.class, \"nullCheck\", boolean.class,\n-                    Object.class);\n-\n-    private static final MethodHandle FormattableCheck_MH =\n-            findStaticMethod(FormatterBuilder.class, \"formattableCheck\", boolean.class,\n-                    Object.class);\n-\n-    private static final MethodHandle ToLong_MH =\n-            findStaticMethod(java.util.FormatterBuilder.class, \"toLong\", long.class,\n-                    int.class);\n-\n-    private static final MethodHandle ToString_MH =\n-            findStaticMethod(String.class, \"valueOf\", String.class,\n-                    Object.class);\n-\n-    private static final MethodHandle HashCode_MH =\n-            findStaticMethod(Objects.class, \"hashCode\", int.class,\n-                    Object.class);\n-\n-    private static boolean nullCheck(Object object) {\n-        return object == null;\n-    }\n-\n-    private static boolean formattableCheck(Object object) {\n-        return Formattable.class.isAssignableFrom(object.getClass());\n-    }\n-\n-    private static long toLong(int value) {\n-        return (long)value & 0xFFFFFFFFL;\n-    }\n-\n-    private static boolean isFlag(int value, int flags) {\n-        return (value & flags) != 0;\n-    }\n-\n-    private static boolean validFlags(int value, int flags) {\n-        return (value & ~flags) == 0;\n-    }\n-\n-    private static int groupSize(Locale locale, DecimalFormatSymbols dfs) {\n-        if (isGenericDFS(dfs)) {\n-            return 3;\n-        }\n-\n-        DecimalFormat df;\n-        NumberFormat nf = NumberFormat.getNumberInstance(locale);\n-\n-        if (nf instanceof DecimalFormat) {\n-            df = (DecimalFormat)nf;\n-        } else {\n-            LocaleProviderAdapter adapter = LocaleProviderAdapter\n-                    .getAdapter(NumberFormatProvider.class, locale);\n-\n-            if (!(adapter instanceof ResourceBundleBasedAdapter)) {\n-                adapter = LocaleProviderAdapter.getResourceBundleBased();\n-            }\n-\n-            String[] all = adapter.getLocaleResources(locale)\n-                    .getNumberPatterns();\n-\n-            df = new DecimalFormat(all[0], dfs);\n-        }\n-\n-        return df.isGroupingUsed() ? df.getGroupingSize() : 0;\n-    }\n-\n-    private MethodHandle formatSpecifier(FormatSpecifier fs, Class<?> ptype) {\n-        boolean isPrimitive = ptype.isPrimitive();\n-        MethodHandle mh = identity(ptype);\n-        MethodType mt = mh.type();\n-\n-\/\/cannot cast to primitive types as it breaks null values formatting\n-\/\/        if (ptype == byte.class || ptype == short.class ||\n-\/\/            ptype == Byte.class || ptype == Short.class ||\n-\/\/            ptype == Integer.class) {\n-\/\/            mt = mt.changeReturnType(int.class);\n-\/\/        } else if (ptype == Long.class) {\n-\/\/            mt = mt.changeReturnType(long.class);\n-\/\/        } else if (ptype == float.class || ptype == Float.class ||\n-\/\/                   ptype == Double.class) {\n-\/\/            mt = mt.changeReturnType(double.class);\n-\/\/        } else if (ptype == Boolean.class) {\n-\/\/            mt = mt.changeReturnType(boolean.class);\n-\/\/        } else if (ptype == Character.class) {\n-\/\/            mt = mt.changeReturnType(char.class);\n-\/\/        }\n-\n-        Class<?> itype = mt.returnType();\n-\n-        if (itype != ptype) {\n-            mh = explicitCastArguments(mh, mt);\n-        }\n-\n-        boolean handled = false;\n-        int flags = fs.flags;\n-        int width = fs.width;\n-        int precision = fs.precision;\n-        Character conv = fs.dt ? 't' : fs.c;\n-\n-        switch (Character.toLowerCase(conv)) {\n-            case BOOLEAN -> {\n-                if (itype == boolean.class && precision == -1) {\n-                    if (flags == 0 && width == -1 && isPrimitive) {\n-                        return null;\n-                    }\n-\n-                    if (validFlags(flags, LEFT_JUSTIFY)) {\n-                        handled = true;\n-                        mh = filterReturnValue(mh, FIBoolean_MH);\n-                    }\n-                }\n-            }\n-            case STRING -> {\n-                if (flags == 0 && width == -1 && precision == -1) {\n-                    if (isPrimitive || ptype == String.class) {\n-                        return null;\n-                    } else if (itype.isPrimitive()) {\n-                        return mh;\n-                    }\n-                }\n-\n-                if (validFlags(flags, LEFT_JUSTIFY) && precision == -1) {\n-                    if (itype == String.class) {\n-                        handled = true;\n-                        mh = filterReturnValue(mh, FIString_MH);\n-                    } else if (!itype.isPrimitive()) {\n-                        handled = true;\n-                        MethodHandle test = FormattableCheck_MH;\n-                        test = test.asType(test.type().changeParameterType(0, ptype));\n-                        MethodHandle pass = insertArguments(FIFormattable_MH,\n-                                0, locale, flags, width, precision);\n-                        pass = pass.asType(pass.type().changeParameterType(0, ptype));\n-                        MethodHandle fail = ToString_MH;\n-                        fail = filterReturnValue(fail, FIString_MH);\n-                        fail = fail.asType(fail.type().changeParameterType(0, ptype));\n-                        mh = guardWithTest(test, pass, fail);\n-                    }\n-                }\n-            }\n-            case CHARACTER -> {\n-                if (itype == char.class && precision == -1) {\n-                    if (flags == 0 && width == -1) {\n-                        return isPrimitive ? null : mh;\n-                    }\n-\n-                    if (validFlags(flags, LEFT_JUSTIFY)) {\n-                        handled = true;\n-                        mh = filterReturnValue(mh, FICharacter_MH);\n-                    }\n-                }\n-            }\n-            case DECIMAL_INTEGER -> {\n-                if ((itype == int.class || itype == long.class) && precision == -1) {\n-                    if (itype == int.class) {\n-                        mh = explicitCastArguments(mh,\n-                                mh.type().changeReturnType(long.class));\n-                    }\n-\n-                    if (flags == 0 && isGenericDFS && width == -1) {\n-                        return mh;\n-                    } else if (validFlags(flags, PLUS | LEADING_SPACE |\n-                                                 ZERO_PAD | GROUP |\n-                                                 PARENTHESES)) {\n-                        handled = true;\n-                        int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n-                        char sign = isFlag(flags, PLUS)          ? '+' :\n-                                    isFlag(flags, LEADING_SPACE) ? ' ' : '\\0';\n-                        boolean parentheses = isFlag(flags, PARENTHESES);\n-                        int groupSize = isFlag(flags, GROUP) ?\n-                                groupSize(locale, dfs) : 0;\n-                        mh = filterReturnValue(mh,\n-                                insertArguments(FIDecimal_MH, 0, dfs, zeroPad,\n-                                        sign, parentheses, groupSize));\n-                    }\n-                }\n-            }\n-            case OCTAL_INTEGER -> {\n-                if ((itype == int.class || itype == long.class) &&\n-                         precision == -1 &&\n-                         validFlags(flags, ZERO_PAD | ALTERNATE)) {\n-                    handled = true;\n-\n-                    if (itype == int.class) {\n-                        mh = filterReturnValue(mh, ToLong_MH);\n-                    }\n-\n-                    int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n-                    boolean hasPrefix = isFlag(flags, ALTERNATE);\n-                    mh = filterReturnValue(mh,\n-                            insertArguments(FIOctal_MH, 0, zeroPad, hasPrefix));\n-                }\n-            }\n-            case HEXADECIMAL_INTEGER -> {\n-                if ((itype == int.class || itype == long.class) &&\n-                        precision == -1 &&\n-                        validFlags(flags, ZERO_PAD | ALTERNATE)) {\n-                    handled = true;\n-\n-                    if (itype == int.class) {\n-                        mh = filterReturnValue(mh, ToLong_MH);\n-                    }\n-\n-                    int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n-                    boolean hasPrefix = isFlag(flags, ALTERNATE);\n-                    mh = filterReturnValue(mh,\n-                            insertArguments(FIHexadecimal_MH, 0, zeroPad, hasPrefix));\n-                }\n-            }\n-            default -> {\n-                \/\/ pass thru\n-            }\n-        }\n-\n-        if (handled) {\n-            if (!isPrimitive) {\n-                MethodHandle test = NullCheck_MH.asType(\n-                        NullCheck_MH.type().changeParameterType(0, ptype));\n-                MethodHandle pass = dropArguments(FINull_MH, 0, ptype);\n-                mh = guardWithTest(test, pass, mh);\n-            }\n-\n-            if (0 < width) {\n-                if (isFlag(flags, LEFT_JUSTIFY)) {\n-                    mh = filterReturnValue(mh,\n-                            insertArguments(FIFillRight_MH, 0, width));\n-                } else {\n-                    mh = filterReturnValue(mh,\n-                            insertArguments(FIFillLeft_MH, 0, width));\n-                }\n-            }\n-\n-            if (!isFlag(flags, UPPERCASE)) {\n-                return mh;\n-            }\n-        }\n-\n-        mh = insertArguments(FIFormatSpecifier_MH, 0, fs, locale);\n-        mh = mh.asType(mh.type().changeParameterType(0, ptype));\n-\n-        return mh;\n-    }\n-\n-    \/**\n-     * Construct concat {@link MethodHandle} for based on format.\n-     *\n-     * @param fsa  list of specifiers\n-     *\n-     * @return concat {@link MethodHandle} for based on format\n-     *\/\n-    private MethodHandle buildFilters(List<FormatString> fsa,\n-                                      List<String> segments,\n-                                      MethodHandle[] filters) {\n-        MethodHandle mh = null;\n-        int iParam = 0;\n-        StringBuilder segment = new StringBuilder();\n-\n-        for (FormatString fs : fsa) {\n-            int index = fs.index();\n-\n-            switch (index) {\n-                case -2:  \/\/ fixed string, \"%n\", or \"%%\"\n-                    String string = fs.toString();\n-\n-                    if (\"%%\".equals(string)) {\n-                        segment.append('%');\n-                    } else if (\"%n\".equals(string)) {\n-                        segment.append(System.lineSeparator());\n-                    } else {\n-                        segment.append(string);\n-                    }\n-                    break;\n-                case 0:  \/\/ ordinary index\n-                    segments.add(segment.toString());\n-                    segment.setLength(0);\n-\n-                    if (iParam < ptypes.length) {\n-                        Class<?> ptype = ptypes[iParam];\n-                        filters[iParam++] = formatSpecifier((FormatSpecifier)fs, ptype);\n-                    } else {\n-                        throw new MissingFormatArgumentException(fs.toString());\n-                    }\n-                    break;\n-                case -1:  \/\/ relative index\n-                default:  \/\/ explicit index\n-                    throw new IllegalFormatFlagsException(\"Indexing not allowed: \" + fs.toString());\n-            }\n-        }\n-\n-        segments.add(segment.toString());\n-\n-        return mh;\n-    }\n-\n-    \/**\n-     * Build a {@link MethodHandle} to format arguments.\n-     *\n-     * @return new {@link MethodHandle} to format arguments\n-     *\/\n-    MethodHandle build() {\n-        List<String> segments = new ArrayList<>();\n-        MethodHandle[] filters = new MethodHandle[ptypes.length];\n-        buildFilters(Formatter.parse(format), segments, filters);\n-        Class<?>[] ftypes = new Class<?>[filters.length];\n-\n-        for (int i = 0; i < filters.length; i++) {\n-            MethodHandle filter = filters[i];\n-            ftypes[i] = filter == null ? ptypes[i] : filter.type().returnType();\n-        }\n-\n-        try {\n-            MethodHandle mh = StringConcatFactory.makeConcatWithTemplate(segments,\n-                    List.of(ftypes));\n-            mh = filterArguments(mh, 0, filters);\n-\n-            return mh;\n-        } catch (StringConcatException ex) {\n-            throw new AssertionError(\"concat fail\", ex);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatterBuilder.java","additions":0,"deletions":489,"binary":false,"changes":489,"status":"deleted"},{"patch":"@@ -367,0 +367,9 @@\n+    \/**\n+     * Put the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     *\/\n+    void putCharUTF16(byte[] bytes, int index, int ch);\n+\n@@ -420,0 +429,6 @@\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\/\n+    long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value);\n+\n@@ -430,10 +445,0 @@\n-   \/**\n-    * Get the coder for the supplied character.\n-    *\/\n-   long stringConcatCoder(char value);\n-\n-   \/**\n-    * Update lengthCoder for StringBuilder.\n-    *\/\n-   long stringBuilderConcatMix(long lengthCoder, StringBuilder sb);\n-\n@@ -441,3 +446,3 @@\n-     * Prepend StringBuilder content.\n-    *\/\n-   long stringBuilderConcatPrepend(long lengthCoder, byte[] buf, StringBuilder sb);\n+     * Mix value length and coder into current length and coder.\n+     *\/\n+    long stringConcatMix(long lengthCoder, char value);\n@@ -457,0 +462,6 @@\n+    int stringSize(long i);\n+\n+    int getCharsLatin1(long i, int index, byte[] buf);\n+\n+    int getCharsUTF16(long i, int index, byte[] buf);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.access;\n-\n-import java.util.List;\n-\n-public interface JavaTemplateAccess {\n-\n-    \/**\n-     * Returns a StringTemplate composed from fragments and values.\n-     *\n-     * @implSpec The {@code fragments} list size must be one more that the\n-     * {@code values} list size.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    list of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n-     *\n-     * @implNote Contents of both lists are copied to construct immutable lists.\n-     *\/\n-    StringTemplate of(List<String> fragments, List<?> values);\n-\n-    \/**\n-     * Creates a string that interleaves the elements of values between the\n-     * elements of fragments.\n-     *\n-     * @param fragments  list of String fragments\n-     * @param values     list of expression values\n-     *\n-     * @return String interpolation of fragments and values\n-     *\/\n-    String interpolate(List<String> fragments, List<?> values);\n-\n-    \/**\n-     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n-     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n-     * }\n-     *\n-     * @param sts  zero or more {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if sts is null or if any element of sts is null\n-     *\/\n-    StringTemplate combine(StringTemplate... sts);\n-\n-}\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaTemplateAccess.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -94,1 +94,0 @@\n-    private static JavaTemplateAccess javaTemplateAccess;\n@@ -535,15 +534,0 @@\n-    public static void setJavaTemplateAccess(JavaTemplateAccess jta) {\n-        javaTemplateAccess = jta;\n-    }\n-\n-    public static JavaTemplateAccess getJavaTemplateAccess() {\n-        var access = javaTemplateAccess;\n-        if (access == null) {\n-            try {\n-                Class.forName(\"java.lang.runtime.TemplateSupport\", true, null);\n-                access = javaTemplateAccess;\n-            } catch (ClassNotFoundException e) {}\n-        }\n-        return access;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public final class DecimalDigits implements Digits {\n+public final class DecimalDigits {\n@@ -75,5 +75,0 @@\n-    \/**\n-     * Singleton instance of DecimalDigits.\n-     *\/\n-    public static final Digits INSTANCE = new DecimalDigits();\n-\n@@ -86,68 +81,0 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n-        boolean negative = value < 0;\n-        if (!negative) {\n-            value = -value;\n-        }\n-\n-        long q;\n-        int r;\n-        while (value <= Integer.MIN_VALUE) {\n-            q = value \/ 100;\n-            r = (int)((q * 100) - value);\n-            value = q;\n-            int digits = DIGITS[r];\n-\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-        }\n-\n-        int iq, ivalue = (int)value;\n-        while (ivalue <= -100) {\n-            iq = ivalue \/ 100;\n-            r = (iq * 100) - ivalue;\n-            ivalue = iq;\n-            int digits = DIGITS[r];\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-        }\n-\n-        if (ivalue < 0) {\n-            ivalue = -ivalue;\n-        }\n-\n-        int digits = DIGITS[ivalue];\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n-\n-        if (9 < ivalue) {\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-        }\n-\n-        if (negative) {\n-            putCharMH.invokeExact(buffer, --index, (int)'-');\n-        }\n-\n-        return index;\n-    }\n-\n-    @Override\n-    public int size(long value) {\n-        boolean negative = value < 0;\n-        int sign = negative ? 1 : 0;\n-\n-        if (!negative) {\n-            value = -value;\n-        }\n-\n-        long precision = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (value > precision)\n-                return i + sign;\n-\n-            precision = 10 * precision;\n-        }\n-\n-        return 19 + sign;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":1,"deletions":74,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * Digits provides a fast methodology for converting integers and longs to\n- * ASCII strings.\n- *\n- * @since 21\n- *\/\n-public sealed interface Digits permits DecimalDigits, HexDigits, OctalDigits {\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param buffer     byte buffer to copy into\n-     * @param index      insert point + 1\n-     * @param putCharMH  method to put character\n-     *\n-     * @return the last index used\n-     *\n-     * @throws Throwable if putCharMH fails (unusual).\n-     *\/\n-    int digits(long value, byte[] buffer, int index,\n-               MethodHandle putCharMH) throws Throwable;\n-\n-    \/**\n-     * Calculate the number of digits required to represent the long.\n-     *\n-     * @param value value to convert\n-     *\n-     * @return number of digits\n-     *\/\n-    int size(long value);\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Digits.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util;\n-\n-\/**\n- * Implementations of this class provide information necessary to\n- * assist {@link java.lang.invoke.StringConcatFactory} perform optimal\n- * insertion.\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-public interface FormatConcatItem {\n-    \/**\n-     * Calculate the length of the insertion.\n-     *\n-     * @param lengthCoder current value of the length + coder\n-     * @return adjusted value of the length + coder\n-     *\/\n-    long mix(long lengthCoder);\n-\n-    \/**\n-     * Insert content into buffer prior to the current length.\n-     *\n-     * @param lengthCoder current value of the length + coder\n-     * @param buffer      buffer to append to\n-     *\n-     * @return adjusted value of the length + coder\n-     *\n-     * @throws Throwable if fails to prepend value (unusual).\n-     *\/\n-    long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/FormatConcatItem.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,1 +35,2 @@\n- * Digits class for hexadecimal digits.\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * hexadecimal digits ASCII strings.\n@@ -37,1 +40,3 @@\n-public final class HexDigits implements Digits {\n+public final class HexDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -68,5 +73,0 @@\n-    \/**\n-     * Singleton instance of HexDigits.\n-     *\/\n-    public static final Digits INSTANCE = new HexDigits();\n-\n@@ -139,3 +139,39 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer) {\n+        while ((value & ~0xFF) != 0) {\n+            short pair = DIGITS[((int) value) & 0xFF];\n+            buffer[--index] = (byte)(pair >> 8);\n+            buffer[--index] = (byte)(pair);\n+            value >>>= 8;\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0xFF)];\n+        buffer[--index] = (byte) (digits >> 8);\n+\n+        if (0xF < value) {\n+            buffer[--index] = (byte) (digits & 0xFF);\n+        }\n+\n+        return index;\n+    }\n+\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer) {\n@@ -143,1 +179,3 @@\n-            int digits = DIGITS[(int) (value & 0xFF)];\n+            int pair = (int) DIGITS[((int) value) & 0xFF];\n+            JLA.putCharUTF16(buffer, --index, pair >> 8);\n+            JLA.putCharUTF16(buffer, --index, pair & 0xFF);\n@@ -145,2 +183,0 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -150,1 +186,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        JLA.putCharUTF16(buffer, --index, (byte) (digits >> 8));\n@@ -153,1 +189,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            JLA.putCharUTF16(buffer, --index, (byte) (digits & 0xFF));\n@@ -159,2 +195,8 @@\n-    @Override\n-    public int size(long value) {\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":59,"deletions":17,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -37,1 +39,9 @@\n-public final class OctalDigits implements Digits {\n+\/**\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * octal digits ASCII strings.\n+ *\n+ * @since 21\n+ *\/\n+public final class OctalDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -41,5 +51,0 @@\n-    \/**\n-     * Singleton instance of OctalDigits.\n-     *\/\n-    public static final Digits INSTANCE = new OctalDigits();\n-\n@@ -67,3 +72,11 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer){\n@@ -71,1 +84,1 @@\n-            int digits = DIGITS[(int) (value & 0x3F)];\n+            int digits = DIGITS[((int) value) & 0x3F];\n@@ -73,2 +86,2 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits >> 8);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -78,1 +91,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        buffer[--index] = (byte) (digits >> 8);\n@@ -81,1 +94,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -87,3 +100,39 @@\n-    @Override\n-    public int size(long value) {\n-        return (66 - Long.numberOfLeadingZeros(value)) \/ 3;\n+\n+    \/**\n+     * This is a variant of {@link OctalDigits#getCharsLatin1(int, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer){\n+        while ((value & ~0x3F) != 0) {\n+            int pair = (int) DIGITS[((int) value) & 0x3F];\n+            JLA.putCharUTF16(buffer, --index, pair >> 8);\n+            JLA.putCharUTF16(buffer, --index, pair & 0xFF);\n+            value >>>= 6;\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0x3F)];\n+        JLA.putCharUTF16(buffer, --index, digits >> 8);\n+\n+        if (7 < value) {\n+            JLA.putCharUTF16(buffer, --index, digits & 0xFF);\n+        }\n+\n+        return index;\n+    }\n+\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n+        return value == 0 ? 1 : ((66 - Long.numberOfLeadingZeros(value)) \/ 3);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OctalDigits.java","additions":66,"deletions":17,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.source.tree;\n-\n-import java.util.List;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * A tree node for a string template expression.\n- *\n- * @since 21\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-public interface StringTemplateTree extends ExpressionTree {\n-    \/**\n-     * Returns templated string processor (may be qualified) or null.\n-     *\n-     * @return templated string processor\n-     *\/\n-    ExpressionTree getProcessor();\n-\n-    \/**\n-     * Returns string fragments.\n-     *\n-     * @return string fragments\n-     *\/\n-    List<String> getFragments();\n-\n-    \/**\n-     * Returns list of expressions.\n-     *\n-     * @return list of expressions\n-     *\/\n-    List<? extends ExpressionTree> getExpressions();\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/StringTemplateTree.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -178,7 +176,0 @@\n-        \/**\n-         * Used for instances of {@link StringTemplateTree}.\n-         * @since 21\n-         *\/\n-        @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-        TEMPLATE(StringTemplateTree.class),\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -262,10 +260,0 @@\n-    \/**\n-     * Visits a StringTemplateTree node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-    R visitStringTemplate(StringTemplateTree node, P p);\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -631,14 +630,0 @@\n-    \/**\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     * @since 21\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-    public R visitStringTemplate(StringTemplateTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -778,18 +777,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     * @since 21\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-    public R visitStringTemplate(StringTemplateTree node, P p) {\n-        R r = scan(node.getProcessor(), p);\n-        r = scanAndReduce(node.getExpressions(), p, r);\n-        return r;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -210,1 +210,0 @@\n-            case STRING_TEMPLATES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -253,1 +253,0 @@\n-        STRING_TEMPLATES(JDK21, Fragments.FeatureStringTemplates, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,6 +245,0 @@\n-    \/\/ For string templates\n-    public final Type stringTemplateType;\n-    public final Type templateRuntimeType;\n-    public final Type processorType;\n-    public final Type linkageType;\n-\n@@ -644,6 +638,0 @@\n-        \/\/ For string templates\n-        stringTemplateType = enterClass(\"java.lang.StringTemplate\");\n-        templateRuntimeType = enterClass(\"java.lang.runtime.TemplateRuntime\");\n-        processorType = enterClass(\"java.lang.StringTemplate$Processor\");\n-        linkageType = enterClass(\"java.lang.StringTemplate$Processor$Linkage\");\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4995,26 +4995,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        JCExpression processor = tree.processor;\n-        Type processorType = attribTree(processor, env, new ResultInfo(KindSelector.VAL, Type.noType));\n-        chk.checkProcessorType(processor, processorType, env);\n-        Type processMethodType = getProcessMethodType(tree, processorType);\n-        tree.processMethodType = processMethodType;\n-        Type resultType = processMethodType.getReturnType();\n-\n-        Env<AttrContext> localEnv = env.dup(tree, env.info.dup());\n-\n-        for (JCExpression arg : tree.expressions) {\n-            chk.checkNonVoid(arg.pos(), attribExpr(arg, localEnv));\n-        }\n-\n-        tree.type = resultType;\n-        result = resultType;\n-        check(tree, resultType, KindSelector.VAL, resultInfo);\n-    }\n-\n-    private Type getProcessMethodType(JCStringTemplate tree, Type processorType) {\n-        MethodSymbol processSymbol = rs.resolveInternalMethod(tree.pos(),\n-                env, types.skipTypeVars(processorType, false),\n-                names.process, List.of(syms.stringTemplateType), List.nil());\n-        return types.memberType(processorType, processSymbol);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4478,20 +4478,0 @@\n-    public Type checkProcessorType(JCExpression processor, Type resultType, Env<AttrContext> env) {\n-        Type processorType = processor.type;\n-        Type interfaceType = types.asSuper(processorType, syms.processorType.tsym);\n-\n-        if (interfaceType != null) {\n-            List<Type> typeArguments = interfaceType.getTypeArguments();\n-\n-            if (typeArguments.size() == 2) {\n-                resultType = typeArguments.head;\n-            } else {\n-                resultType = syms.objectType;\n-            }\n-        } else {\n-            log.error(DiagnosticFlag.RESOLVE_ERROR, processor.pos,\n-                    Errors.NotAProcessorType(processorType.tsym));\n-        }\n-\n-        return resultType;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -62,5 +62,4 @@\n-        TRANSLITERALS(7),\n-        TRANSPATTERNS(8),\n-        UNLAMBDA(9),\n-        LOWER(10),\n-        GENERATE(11);\n+        TRANSPATTERNS(7),\n+        UNLAMBDA(8),\n+        LOWER(9),\n+        GENERATE(10);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1747,9 +1747,0 @@\n-        @Override\n-        public void visitStringTemplate(JCStringTemplate tree) {\n-            for (Type thrown : tree.processMethodType.getThrownTypes()) {\n-                markThrown(tree, thrown);\n-            }\n-\n-            scan(tree.expressions);\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,348 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.comp;\n-\n-import com.sun.tools.javac.code.Flags;\n-import com.sun.tools.javac.code.Symbol;\n-import com.sun.tools.javac.code.Symbol.ClassSymbol;\n-import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;\n-import com.sun.tools.javac.code.Symbol.MethodSymbol;\n-import com.sun.tools.javac.code.Symbol.VarSymbol;\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.code.Type;\n-import com.sun.tools.javac.code.Type.*;\n-import com.sun.tools.javac.code.Types;\n-import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.*;\n-import com.sun.tools.javac.tree.TreeInfo;\n-import com.sun.tools.javac.tree.TreeMaker;\n-import com.sun.tools.javac.tree.TreeTranslator;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.List;\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.javac.util.Names;\n-\n-import java.util.Iterator;\n-\n-\/** This pass translates constructed literals (string templates, ...) to conventional Java.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public final class TransLiterals extends TreeTranslator {\n-    \/**\n-     * The context key for the TransTypes phase.\n-     *\/\n-    protected static final Context.Key<TransLiterals> transLiteralsKey = new Context.Key<>();\n-\n-    \/**\n-     * Get the instance for this context.\n-     *\/\n-    public static TransLiterals instance(Context context) {\n-        TransLiterals instance = context.get(transLiteralsKey);\n-        if (instance == null)\n-            instance = new TransLiterals(context);\n-        return instance;\n-    }\n-\n-    private final Symtab syms;\n-    private final Resolve rs;\n-    private final Types types;\n-    private final Operators operators;\n-    private final Names names;\n-    private TreeMaker make = null;\n-    private Env<AttrContext> env = null;\n-    private ClassSymbol currentClass = null;\n-    private MethodSymbol currentMethodSym = null;\n-\n-    protected TransLiterals(Context context) {\n-        context.put(transLiteralsKey, this);\n-        syms = Symtab.instance(context);\n-        rs = Resolve.instance(context);\n-        make = TreeMaker.instance(context);\n-        types = Types.instance(context);\n-        operators = Operators.instance(context);\n-        names = Names.instance(context);\n-    }\n-\n-    JCExpression makeLit(Type type, Object value) {\n-        return make.Literal(type.getTag(), value).setType(type.constType(value));\n-    }\n-\n-    JCExpression makeString(String string) {\n-        return makeLit(syms.stringType, string);\n-    }\n-\n-    List<JCExpression> makeStringList(List<String> strings) {\n-        List<JCExpression> exprs = List.nil();\n-        for (String string : strings) {\n-            exprs = exprs.append(makeString(string));\n-        }\n-        return exprs;\n-    }\n-\n-    JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {\n-        JCBinary tree = make.Binary(optag, lhs, rhs);\n-        tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);\n-        tree.type = tree.operator.type.getReturnType();\n-        return tree;\n-    }\n-\n-    MethodSymbol lookupMethod(DiagnosticPosition pos, Name name, Type qual, List<Type> args) {\n-        return rs.resolveInternalMethod(pos, env, qual, name, args, List.nil());\n-    }\n-\n-    @Override\n-    public void visitClassDef(JCClassDecl tree) {\n-        ClassSymbol prevCurrentClass = currentClass;\n-        try {\n-            currentClass = tree.sym;\n-            super.visitClassDef(tree);\n-        } finally {\n-            currentClass = prevCurrentClass;\n-        }\n-    }\n-\n-    @Override\n-    public void visitMethodDef(JCMethodDecl tree) {\n-        MethodSymbol prevMethodSym = currentMethodSym;\n-        try {\n-            currentMethodSym = tree.sym;\n-            super.visitMethodDef(tree);\n-        } finally {\n-            currentMethodSym = prevMethodSym;\n-        }\n-    }\n-\n-    final class TransStringTemplate {\n-        final JCStringTemplate tree;\n-        final JCExpression processor;\n-        final List<String> fragments;\n-        final List<JCExpression> expressions;\n-        final List<Type> expressionTypes;\n-        final boolean useValuesList;\n-\n-        TransStringTemplate(JCStringTemplate tree) {\n-            this.tree = tree;\n-            this.processor = tree.processor;\n-            this.fragments = tree.fragments;\n-            this.expressions = translate(tree.expressions);\n-            this.expressionTypes = expressions.stream()\n-                    .map(arg -> arg.type == syms.botType ? syms.objectType : arg.type)\n-                    .collect(List.collector());\n-            int slots = expressionTypes.stream()\n-                    .mapToInt(t -> types.isSameType(t, syms.longType) ||\n-                            types.isSameType(t, syms.doubleType) ? 2 : 1).sum();\n-            this.useValuesList = 200 < slots; \/\/ StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS\n-         }\n-\n-        JCExpression concatExpression(List<String> fragments, List<JCExpression> expressions) {\n-            JCExpression expr = null;\n-            Iterator<JCExpression> iterator = expressions.iterator();\n-            for (String fragment : fragments) {\n-                expr = expr == null ? makeString(fragment)\n-                        : makeBinary(Tag.PLUS, expr, makeString(fragment));\n-                if (iterator.hasNext()) {\n-                    JCExpression expression = iterator.next();\n-                    Type expressionType = expression.type;\n-                    expr = makeBinary(Tag.PLUS, expr, expression.setType(expressionType));\n-                }\n-            }\n-            return expr;\n-        }\n-\n-        JCExpression bsmCall(Name name, Name bootstrapName, Type type,\n-                             List<JCExpression> args,\n-                             List<Type> argTypes,\n-                             List<LoadableConstant> staticArgValues,\n-                             List<Type> staticArgsTypes) {\n-            Symbol bsm = rs.resolveQualifiedMethod(tree.pos(), env,\n-                    syms.templateRuntimeType, bootstrapName, staticArgsTypes, List.nil());\n-            MethodType indyType = new MethodType(argTypes, type, List.nil(), syms.methodClass);\n-            DynamicMethodSymbol dynSym = new DynamicMethodSymbol(\n-                    name,\n-                    syms.noSymbol,\n-                    ((MethodSymbol)bsm).asHandle(),\n-                    indyType,\n-                    staticArgValues.toArray(new LoadableConstant[0])\n-            );\n-            JCFieldAccess qualifier = make.Select(make.Type(syms.processorType), dynSym.name);\n-            qualifier.sym = dynSym;\n-            qualifier.type = type;\n-            JCMethodInvocation apply = make.Apply(List.nil(), qualifier, args);\n-            apply.type = type;\n-            return apply;\n-        }\n-\n-        JCExpression processCall(JCExpression stringTemplate) {\n-            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.process,\n-                    syms.processorType, List.of(syms.stringTemplateType));\n-            JCExpression applySelect = make.Select(processor, appyMeth);\n-            JCExpression process = make.Apply(null, applySelect, List.of(stringTemplate))\n-                    .setType(syms.objectType);\n-            JCTypeCast cast = make.TypeCast(tree.type, process);\n-            return cast;\n-        }\n-\n-        JCExpression newStringTemplate() {\n-            List<LoadableConstant> staticArgValues = List.nil();\n-            List<Type> staticArgsTypes =\n-                    List.of(syms.methodHandleLookupType, syms.stringType,\n-                            syms.methodTypeType);\n-            if (useValuesList) {\n-                JCNewArray fragmentArray = make.NewArray(make.Type(syms.stringType),\n-                        List.nil(), makeStringList(fragments));\n-                fragmentArray.type = new ArrayType(syms.stringType, syms.arrayClass);\n-                JCNewArray valuesArray = make.NewArray(make.Type(syms.objectType),\n-                        List.nil(), expressions);\n-                valuesArray.type = new ArrayType(syms.objectType, syms.arrayClass);\n-                return bsmCall(names.process, names.newLargeStringTemplate, syms.stringTemplateType,\n-                        List.of(fragmentArray, valuesArray),\n-                        List.of(fragmentArray.type, valuesArray.type),\n-                        staticArgValues, staticArgsTypes);\n-            } else {\n-                for (String fragment : fragments) {\n-                    staticArgValues = staticArgValues.append(LoadableConstant.String(fragment));\n-                    staticArgsTypes = staticArgsTypes.append(syms.stringType);\n-                }\n-                return bsmCall(names.process, names.newStringTemplate, syms.stringTemplateType,\n-                        expressions, expressionTypes, staticArgValues, staticArgsTypes);\n-            }\n-        }\n-\n-        JCExpression bsmProcessCall() {\n-            List<JCExpression> args = expressions.prepend(processor);\n-            List<Type> argTypes = expressionTypes.prepend(processor.type);\n-            VarSymbol processorSym = (VarSymbol)TreeInfo.symbol(processor);\n-            List<LoadableConstant> staticArgValues = List.of(processorSym.asMethodHandle(true));\n-            List<Type> staticArgsTypes =\n-                    List.of(syms.methodHandleLookupType, syms.stringType,\n-                            syms.methodTypeType, syms.methodHandleType);\n-            for (String fragment : fragments) {\n-                staticArgValues = staticArgValues.append(LoadableConstant.String(fragment));\n-                staticArgsTypes = staticArgsTypes.append(syms.stringType);\n-            }\n-            return bsmCall(names.process, names.processStringTemplate, tree.type,\n-                    args, argTypes, staticArgValues, staticArgsTypes);\n-        }\n-\n-        boolean isNamedProcessor(Name name) {\n-            Symbol sym = switch (processor) {\n-                case JCIdent ident -> ident.sym;\n-                case JCFieldAccess access -> access.sym;\n-                default -> null;\n-            };\n-            if (sym instanceof VarSymbol varSym) {\n-                if (varSym.flags() == (Flags.PUBLIC | Flags.FINAL | Flags.STATIC) &&\n-                        varSym.name == name &&\n-                        types.isSameType(varSym.owner.type, syms.stringTemplateType)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        boolean isLinkageProcessor() {\n-            return !useValuesList &&\n-                   types.isSubtype(processor.type, syms.linkageType) &&\n-                   processor.type.isFinal() &&\n-                   TreeInfo.symbol(processor) instanceof VarSymbol varSymbol &&\n-                   varSymbol.isStatic() &&\n-                   varSymbol.isFinal();\n-        }\n-\n-        JCExpression visit() {\n-            JCExpression result;\n-            make.at(tree.pos);\n-\n-            if (isNamedProcessor(names.RAW)) {\n-                result = newStringTemplate();\n-            } else if (isNamedProcessor(names.STR)) {\n-                result = concatExpression(fragments, expressions);\n-            } else if (isLinkageProcessor()) {\n-                result = bsmProcessCall();\n-            } else {\n-                result = processCall(newStringTemplate());\n-            }\n-\n-            return result;\n-        }\n-    }\n-\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        int prevPos = make.pos;\n-        try {\n-            tree.processor = translate(tree.processor);\n-            tree.expressions = translate(tree.expressions);\n-\n-            TransStringTemplate transStringTemplate = new TransStringTemplate(tree);\n-\n-            result = transStringTemplate.visit();\n-        } catch (Throwable ex) {\n-            ex.printStackTrace();\n-            throw ex;\n-        } finally {\n-            make.at(prevPos);\n-        }\n-    }\n-\n-    public void visitVarDef(JCVariableDecl tree) {\n-        MethodSymbol prevMethodSym = currentMethodSym;\n-        try {\n-            tree.mods = translate(tree.mods);\n-            tree.vartype = translate(tree.vartype);\n-            if (currentMethodSym == null) {\n-                \/\/ A class or instance field initializer.\n-                currentMethodSym =\n-                        new MethodSymbol((tree.mods.flags& Flags.STATIC) | Flags.BLOCK,\n-                                names.empty, null,\n-                                currentClass);\n-            }\n-            if (tree.init != null) tree.init = translate(tree.init);\n-            result = tree;\n-        } finally {\n-            currentMethodSym = prevMethodSym;\n-        }\n-    }\n-\n-    public JCTree translateTopLevelClass(Env<AttrContext> env, JCTree cdef, TreeMaker make) {\n-        try {\n-            this.make = make;\n-            this.env = env;\n-            translate(cdef);\n-        } finally {\n-            this.make = null;\n-            this.env = null;\n-        }\n-\n-        return cdef;\n-    }\n-\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransLiterals.java","additions":0,"deletions":348,"binary":false,"changes":348,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -839,8 +839,0 @@\n-\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        tree.processor = translate(tree.processor, erasure(tree.processor.type));\n-        tree.expressions = tree.expressions.stream()\n-                .map(e -> translate(e, erasure(e.type))).collect(List.collector());\n-        tree.type = erasure(tree.type);\n-        result = tree;\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -343,23 +343,0 @@\n-        private void staticImports(JCCompilationUnit tree, Env<AttrContext> env, ImportFilter staticImportFilter) {\n-             if (preview.isEnabled() && preview.isPreview(Feature.STRING_TEMPLATES)) {\n-                Lint prevLint = chk.setLint(lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));\n-                boolean prevPreviewCheck = chk.disablePreviewCheck;\n-\n-                try {\n-                    chk.disablePreviewCheck = true;\n-                    String autoImports = \"\"\"\n-                            import static java.lang.StringTemplate.STR;\n-                            \"\"\";\n-                    Parser parser = parserFactory.newParser(autoImports, false, false, false, false);\n-                    JCCompilationUnit importTree = parser.parseCompilationUnit();\n-\n-                    for (JCImport imp : importTree.getImports()) {\n-                        doImport(imp);\n-                    }\n-                } finally {\n-                    chk.setLint(prevLint);\n-                    chk.disablePreviewCheck = prevPreviewCheck;\n-                }\n-            }\n-        }\n-\n@@ -389,1 +366,0 @@\n-                staticImports(tree, env, staticImportFilter);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1615,6 +1615,0 @@\n-            if (shouldStop(CompileState.TRANSLITERALS))\n-                return;\n-\n-            env.tree = TransLiterals.instance(context).translateTopLevelClass(env, env.tree, localMake);\n-            compileStates.put(env, CompileState.TRANSLITERALS);\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,10 +102,0 @@\n-    \/**\n-     * Tokens pending to be read from string template embedded expressions.\n-     *\/\n-    protected List<Token> pendingTokens;\n-\n-    \/**\n-     * String template fragment ranges; end-endPos pairs.\n-     *\/\n-    protected List<Integer> fragmentRanges;\n-\n@@ -142,10 +132,0 @@\n-    \/**\n-     * true if contains templated string escape sequences, set by nextToken().\n-     *\/\n-    protected boolean isStringTemplate;\n-\n-    \/**\n-     * true if errors are pending from embedded expressions.\n-     *\/\n-    protected boolean hasStringTemplateErrors;\n-\n@@ -186,2 +166,0 @@\n-        this.pendingTokens = List.nil();\n-        this.fragmentRanges = List.nil();\n@@ -342,80 +320,0 @@\n-    \/**\n-     * Scan the content of a string template expression.\n-     *\n-     * @param pos     start of literal\n-     * @param endPos  start of embedded expression\n-     *\/\n-    private void scanEmbeddedExpression(int pos, int endPos) {\n-        \/\/ If first embedded expression.\n-        if (!isStringTemplate) {\n-            checkSourceLevel(pos, Feature.STRING_TEMPLATES);\n-            fragmentRanges = fragmentRanges.append(pos);\n-            isStringTemplate = true;\n-        }\n-        \/\/ Track end of previous fragment.\n-        fragmentRanges = fragmentRanges.append(endPos);\n-        \/\/ Keep backslash and add rest of placeholder.\n-        sb.append(\"{}\");\n-\n-        \/\/ Separate tokenizer for the embedded expression.\n-        JavaTokenizer tokenizer = new JavaTokenizer(fac, buffer(), length());\n-        tokenizer.reset(position());\n-\n-        \/\/ Track brace depth.\n-        int braceCount = 0;\n-\n-        \/\/ Accumulate tokens.\n-        List<Token> tokens = List.nil();\n-\n-        \/\/ Stash first left brace.\n-        Token token = tokenizer.readToken();\n-        tokens = tokens.append(token);\n-\n-        while (isAvailable()) {\n-            \/\/ Read and stash next token.\n-            token = tokenizer.readToken();\n-            tokens = tokens.append(token);\n-\n-            \/\/ Intercept errors\n-            if (token.kind == TokenKind.ERROR) {\n-                \/\/ Track start of next fragment.\n-                if (isTextBlock) {\n-                    reset(length());\n-                } else {\n-                    skipToEOLN();\n-                }\n-                hasStringTemplateErrors = true;\n-                return;\n-            }\n-\n-            if (token.kind == TokenKind.RBRACE) {\n-                \/\/ Potential closing brace.\n-                if (braceCount == 0) {\n-                    break;\n-                }\n-\n-                braceCount--;\n-            } else if (token.kind == TokenKind.LBRACE) {\n-                \/\/ Nesting deeper.\n-                braceCount++;\n-            } else if (token.kind == TokenKind.STRINGFRAGMENT) {\n-                tokens = tokens.appendList(tokenizer.pendingTokens);\n-                tokenizer.pendingTokens = List.nil();\n-            } else if (token.kind == TokenKind.EOF) {\n-                break;\n-            }\n-        }\n-\n-        \/\/ If no closing brace will be picked up as an unterminated string.\n-\n-        \/\/ Set main tokenizer to continue at next position.\n-        int position = tokenizer.position();\n-        reset(position);\n-\n-        \/\/ Track start of next fragment.\n-        fragmentRanges = fragmentRanges.append(position);\n-\n-        \/\/ Pend the expression tokens after the STRINGFRAGMENT.\n-        pendingTokens = pendingTokens.appendList(tokens);\n-    }\n-\n@@ -483,11 +381,0 @@\n-                case '{':\n-                    if (isString) {\n-                        scanEmbeddedExpression(pos, backslash);\n-                        if (hasStringTemplateErrors) {\n-                            return;\n-                        }\n-                    } else {\n-                        lexError(position(), Errors.IllegalEscChar);\n-                    }\n-                    break;\n-\n@@ -533,7 +420,1 @@\n-                if (hasStringTemplateErrors) {\n-                    break;\n-                } else if (accept(\"\\\"\\\"\\\"\")) {\n-                    if (isStringTemplate && tk == TokenKind.STRINGLITERAL) {\n-                        tk = TokenKind.STRINGFRAGMENT;\n-                    }\n-\n+                if (accept(\"\\\"\\\"\\\"\")) {\n@@ -563,6 +444,1 @@\n-                if (hasStringTemplateErrors) {\n-                    break;\n-                } else if (accept('\\\"')) {\n-                    if (isStringTemplate && tk == TokenKind.STRINGLITERAL) {\n-                        tk = TokenKind.STRINGFRAGMENT;\n-                    }\n+                if (accept('\\\"')) {\n@@ -583,10 +459,3 @@\n-        \/\/ String ended without close delimiter sequence or has embedded expression errors.\n-        if (isStringTemplate) {\n-            lexError(pos, isTextBlock ? Errors.TextBlockTemplateIsNotWellFormed\n-                                      : Errors.StringTemplateIsNotWellFormed);\n-            fragmentRanges = List.nil();\n-            pendingTokens = List.nil();\n-        } else {\n-            lexError(pos, isTextBlock ? Errors.UnclosedTextBlock\n-                                      : Errors.UnclosedStrLit);\n-        }\n+        \/\/ String ended without close delimiter sequence.\n+        lexError(pos, isTextBlock ? Errors.UnclosedTextBlock\n+                                  : Errors.UnclosedStrLit);\n@@ -594,1 +463,1 @@\n-        if (!hasStringTemplateErrors && firstEOLN  != NOT_FOUND) {\n+        if (firstEOLN  != NOT_FOUND) {\n@@ -909,6 +778,0 @@\n-        if (pendingTokens.nonEmpty()) {\n-            Token token = pendingTokens.head;\n-            pendingTokens = pendingTokens.tail;\n-            return token;\n-        }\n-\n@@ -920,3 +783,0 @@\n-        isStringTemplate = false;\n-        hasStringTemplateErrors = false;\n-        fragmentRanges = List.nil();\n@@ -1137,1 +997,0 @@\n-\n@@ -1184,5 +1043,0 @@\n-            \/\/ Track end of final fragment.\n-            if (isStringTemplate) {\n-                fragmentRanges = fragmentRanges.append(endPos);\n-            }\n-\n@@ -1220,5 +1074,0 @@\n-                if (isStringTemplate) {\n-                    \/\/ Break string into fragments and then return the first of the framents.\n-                    return getFragments(string, comments);\n-                }\n-\n@@ -1254,60 +1103,0 @@\n-    \/**\n-     * Convert the string into a list of pending tokens to precede embedded\n-     * expressions.\n-     *\n-     * @param string    string to fragment\n-     * @param comments  comments for first token\n-     *\n-     * @return first pending token.\n-     *\/\n-    private Token getFragments(String string, List<Comment> comments) {\n-        List<Token> tokens = List.nil();\n-        Iterator<Integer> rangeIter = fragmentRanges.iterator();\n-        for (String fragment : fragment(string)) {\n-            fragment = fragment.translateEscapes();\n-            int fragmentPos = rangeIter.next();\n-            int fragmentEndPos = rangeIter.next();\n-            Token token = new StringToken(TokenKind.STRINGFRAGMENT,\n-                    fragmentPos, fragmentEndPos, fragment, comments);\n-            comments = null;\n-            tokens = tokens.append(token);\n-        }\n-        pendingTokens = tokens.appendList(pendingTokens);\n-        Token first = pendingTokens.head;\n-        pendingTokens = pendingTokens.tail;\n-        return first;\n-    }\n-\n-    \/**\n-     * Break string template up into fragments. \"\\{}\" indicates where\n-     * embedded expressions occur.\n-     *\n-     * @param string string template\n-     *\n-     * @return list of fragment strings\n-     *\/\n-    List<String> fragment(String string) {\n-        List<String> fragments = List.nil();\n-        StringBuilder sb = new StringBuilder();\n-        int length = string.length();\n-        for (int i = 0; i < length; i++) {\n-            char ch = string.charAt(i);\n-            if (ch != '\\\\') {\n-                sb.append(ch);\n-            } else if (i + 2 < length && string.charAt(i + 1) == '{'\n-                    && string.charAt(i + 2) == '}') {\n-                fragments = fragments.append(sb.toString());\n-                sb.setLength(0);\n-                i += 2;\n-            } else if (i + 1 < length){\n-                sb.append('\\\\');\n-                sb.append(string.charAt(i + 1));\n-                i++;\n-            } else {\n-                \/\/ Error already reported.\n-            }\n-        }\n-        fragments = fragments.append(sb.toString());\n-        return fragments;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":6,"deletions":217,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -695,53 +695,0 @@\n-    \/**\n-     * StringTemplate =\n-     *    [STRINGFRAGMENT] [EmbeddedExpression]\n-     *  | STRINGLITERAL\n-     *\n-     * EmbeddedExpression =\n-     *  LBRACE term RBRACE\n-     *\/\n-    JCExpression stringTemplate(JCExpression processor) {\n-        checkSourceLevel(Feature.STRING_TEMPLATES);\n-        \/\/ Disable standalone string templates\n-        if (processor == null) {\n-            log.error(DiagnosticFlag.SYNTAX, token.pos,\n-                    Errors.ProcessorMissingFromStringTemplateExpression);\n-        }\n-        int oldmode = mode;\n-        selectExprMode();\n-        Token stringToken = token;\n-        int pos = stringToken.pos;\n-        int endPos = stringToken.endPos;\n-        TokenKind kind = stringToken.kind;\n-        String string = token.stringVal();\n-        List<String> fragments = List.of(string);\n-        List<JCExpression> expressions = List.nil();\n-        nextToken();\n-        if (kind != STRINGLITERAL) {\n-            while (token.kind == STRINGFRAGMENT) {\n-                stringToken = token;\n-                endPos = stringToken.endPos;\n-                string = stringToken.stringVal();\n-                fragments = fragments.append(string);\n-                nextToken();\n-             }\n-            while (token.pos < endPos && token.kind != DEFAULT && token.kind != ERROR) {\n-                accept(LBRACE);\n-                JCExpression expression = token.kind == RBRACE ? F.at(pos).Literal(TypeTag.BOT, null)\n-                                                               : term(EXPR);\n-                expressions = expressions.append(expression);\n-                if (token.kind != ERROR) {\n-                    accept(RBRACE);\n-                }\n-            }\n-            \/\/ clean up remaining expression tokens if error\n-            while (token.pos < endPos && token.kind != DEFAULT) {\n-                nextToken();\n-            }\n-            S.setPrevToken(stringToken);\n-        }\n-        JCExpression t = toP(F.at(pos).StringTemplate(processor, fragments, expressions));\n-        setMode(oldmode);\n-        return t;\n-    }\n-\n@@ -1425,8 +1372,0 @@\n-         case STRINGFRAGMENT:\n-             if (typeArgs == null && isMode(EXPR)) {\n-                 selectExprMode();\n-                 t = stringTemplate(null);\n-             } else {\n-                 return illegal();\n-             }\n-             break;\n@@ -1563,6 +1502,0 @@\n-                            case STRINGFRAGMENT:\n-                            case STRINGLITERAL:\n-                                if (typeArgs != null) return illegal();\n-                                t = stringTemplate(t);\n-                                typeArgs = null;\n-                                break loop;\n@@ -1792,6 +1725,0 @@\n-                } else if (token.kind == TokenKind.STRINGFRAGMENT ||\n-                           token.kind == TokenKind.STRINGLITERAL) {\n-                    if (typeArgs != null) {\n-                        return illegal();\n-                    }\n-                    t = stringTemplate(t);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1364,13 +1364,0 @@\n-compiler.err.string.template.is.not.well.formed=\\\n-    string template is not well formed\n-\n-compiler.err.text.block.template.is.not.well.formed=\\\n-    text block template is not well formed\n-\n-compiler.err.processor.missing.from.string.template.expression=\\\n-    processor missing from string template expression\n-\n-# 0: symbol\n-compiler.err.not.a.processor.type=\\\n-    not a processor type: {0}\n-\n@@ -3222,3 +3209,0 @@\n-compiler.misc.feature.string.templates=\\\n-    string templates\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,4 +272,0 @@\n-        \/** String template expression.\n-         *\/\n-        STRING_TEMPLATE,\n-\n@@ -2484,53 +2480,0 @@\n-    \/**\n-     * String template expression.\n-     *\/\n-    public static class JCStringTemplate extends JCExpression implements StringTemplateTree {\n-        public JCExpression processor;\n-        public List<String> fragments;\n-        public List<JCExpression> expressions;\n-        public Type processMethodType;\n-\n-        protected JCStringTemplate(JCExpression processor,\n-                                   List<String> fragments,\n-                                   List<JCExpression> expressions) {\n-            this.processor = processor;\n-            this.fragments = fragments;\n-            this.expressions = expressions;\n-        }\n-\n-        @Override\n-        public ExpressionTree getProcessor() {\n-            return processor;\n-        }\n-\n-        @Override\n-        public List<String> getFragments() {\n-            return fragments;\n-        }\n-\n-        @Override\n-        public List<? extends ExpressionTree> getExpressions() {\n-            return expressions;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() {\n-            return Kind.TEMPLATE;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Tag getTag() {\n-            return STRING_TEMPLATE;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public void accept(Visitor v) {\n-            v.visitStringTemplate(this);\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n-            return v.visitStringTemplate(this, d);\n-        }\n-    }\n-\n@@ -3516,3 +3459,0 @@\n-        JCStringTemplate StringTemplate(JCExpression processor,\n-                                        List<String> fragments,\n-                                        List<JCExpression> expressions);\n@@ -3590,1 +3530,0 @@\n-        public void visitStringTemplate(JCStringTemplate that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":62,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1479,15 +1479,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        try {\n-            JCExpression processor = tree.processor;\n-            print(\"[\");\n-            printExpr(processor);\n-            print(\"]\");\n-            print(\"\\\"\" + tree.fragments.stream().collect(Collectors.joining(\"\\\\{}\")) + \"\\\"\");\n-            print(\"(\");\n-            printExprs(tree.expressions);\n-            print(\")\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -287,8 +287,0 @@\n-    public JCTree visitStringTemplate(StringTemplateTree node, P p) {\n-        JCStringTemplate t = (JCStringTemplate) node;\n-        JCExpression processor = copy(t.processor, p);\n-        List<JCExpression> expressions = copy(t.expressions, p);\n-        return M.at(t.pos).StringTemplate(processor, t.fragments, expressions);\n-    }\n-\n-    @DefinedBy(Api.COMPILER_TREE)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,1 +374,0 @@\n-            case STRING_TEMPLATE:\n@@ -590,4 +589,0 @@\n-            case STRING_TEMPLATE: {\n-                JCStringTemplate node = (JCStringTemplate) tree;\n-                return node.processor == null ? node.pos : getStartPos(node.processor);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -551,8 +551,0 @@\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n-    public JCStringTemplate StringTemplate(JCExpression processor,\n-                                           List<String> fragments,\n-                                           List<JCExpression> expressions) {\n-        JCStringTemplate tree = new JCStringTemplate(processor, fragments, expressions);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -356,5 +356,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        scan(tree.processor);\n-        scan(tree.expressions);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,7 +412,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        tree.processor = translate(tree.processor);\n-        tree.expressions = translate(tree.expressions);\n-\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,8 +230,0 @@\n-    \/\/ templated string\n-    public final Name process;\n-    public final Name STR;\n-    public final Name RAW;\n-    public final Name newStringTemplate;\n-    public final Name newLargeStringTemplate;\n-    public final Name processStringTemplate;\n-\n@@ -416,7 +408,0 @@\n-        \/\/ templated string\n-        process = fromString(\"process\");\n-        STR = fromString(\"STR\");\n-        RAW = fromString(\"RAW\");\n-        newStringTemplate = fromString(\"newStringTemplate\");\n-        newLargeStringTemplate = fromString(\"newLargeStringTemplate\");\n-        processStringTemplate = fromString(\"processStringTemplate\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.StringConcatFactory;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-\/**\n- * @test\n- * @summary Test StringConcatFactory.makeConcatWithTemplate... methods.\n- * @enablePreview true\n- *\/\n-\n-public class MakeConcatWithTemplate {\n-    public static void main(String... args) {\n-        makeConcatWithTemplate();\n-        makeConcatWithTemplateCluster();\n-        makeConcatWithTemplateGetters();\n-    }\n-\n-    static List<String> fragments(int n) {\n-        String[] array = new String[n];\n-        Arrays.fill(array, \"abc\");\n-        return Arrays.asList(array);\n-    }\n-\n-    static List<Class<?>> types(int n) {\n-        Class<?>[] array = new Class<?>[n];\n-        Arrays.fill(array, int.class);\n-        return Arrays.asList(array);\n-    }\n-\n-    static List<Integer> values(int n) {\n-        Integer[] array = new Integer[n];\n-        Arrays.fill(array, 123);\n-        return Arrays.asList(array);\n-    }\n-\n-    static List<MethodHandle> getters(int n) {\n-        MethodHandle[] array = new MethodHandle[n];\n-        MethodHandle m = MethodHandles.dropArguments(MethodHandles.constant(int.class, 123), 0, Object.class);\n-        Arrays.fill(array, m);\n-        return Arrays.asList(array);\n-    }\n-\n-    static void makeConcatWithTemplate() {\n-        try {\n-            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS - 1;\n-            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n-            m.invokeWithArguments(values(n));\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        try {\n-            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n-            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n-            m.invokeWithArguments(values(n));\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        boolean threw = false;\n-        try {\n-            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS + 1;\n-            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n-            m.invokeWithArguments(values(n));\n-        } catch (Throwable e) {\n-            threw = true;\n-        }\n-\n-        if (!threw) {\n-            throw new RuntimeException(\"Exception expected - makeConcatWithTemplate\");\n-        }\n-    }\n-\n-    static void makeConcatWithTemplateCluster() {\n-        int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n-        int c = 3;\n-        try {\n-            List<MethodHandle> ms = StringConcatFactory.makeConcatWithTemplateCluster(fragments(c * n + 1), types(c * n), n);\n-            MethodHandle m0 = ms.get(0);\n-            MethodHandle m1 = ms.get(1);\n-            MethodHandle m2 = ms.get(2);\n-            MethodHandle m3 = ms.get(3);\n-\n-            String s = (String)m0.invokeWithArguments(values(n));\n-            List<Object> args = new ArrayList<>();\n-            args.add(s);\n-            args.addAll(values(n - 1)); \/\/ one less for carry over string\n-            s = (String)m1.invokeWithArguments(args);\n-            args.clear();\n-            args.add(s);\n-            args.addAll(values(n - 1)); \/\/ one less for carry over string\n-            s = (String)m2.invokeWithArguments(args);\n-            args.clear();\n-            args.add(s);\n-            args.addAll(values(2)); \/\/ two remaining carry overs\n-            s = (String)m3.invokeWithArguments(args);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static void makeConcatWithTemplateGetters() {\n-        int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n-        int c = 3;\n-        try {\n-            MethodHandle m = StringConcatFactory.makeConcatWithTemplateGetters(fragments(c * n + 1), getters(c * n), n);\n-            String s = (String)m.invoke(null);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/String\/concat\/MakeConcatWithTemplate.java","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -1,504 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 0000000\n- * @summary Exercise runtime handing of templated strings.\n- * @enablePreview true\n- *\/\n-\n-import java.lang.StringTemplate.*;\n-import java.util.*;\n-import java.util.concurrent.*;\n-import java.util.function.*;\n-\n-import static java.lang.StringTemplate.RAW;\n-\n-public class Basic {\n-    public static void main(String... arg) {\n-        equalsHashCode();\n-        concatenationTests();\n-        componentTests();\n-        limitsTests();\n-        processorTests();\n-        stringTemplateCoverage();\n-        simpleProcessorCoverage();\n-    }\n-\n-    static void ASSERT(String a, String b) {\n-        if (!Objects.equals(a, b)) {\n-            System.out.println(a);\n-            System.out.println(b);\n-            throw new RuntimeException(\"Test failed\");\n-        }\n-    }\n-\n-    static void ASSERT(Object a, Object b) {\n-        if (!Objects.deepEquals(a, b)) {\n-            System.out.println(a);\n-            System.out.println(b);\n-            throw new RuntimeException(\"Test failed\");\n-        }\n-    }\n-\n-    \/*\n-     * equals and hashCode tests.\n-     *\/\n-    static void equalsHashCode() {\n-        int x = 10;\n-        int y = 20;\n-        int a = 10;\n-        int b = 20;\n-\n-        StringTemplate st0 = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-        StringTemplate st1 = RAW.\"\\{a} + \\{b} = \\{a + b}\";\n-        StringTemplate st2 = RAW.\"\\{x} + \\{y} = \\{x + y}!\";\n-        x++;\n-        StringTemplate st3 = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-\n-        if (!st0.equals(st1)) throw new RuntimeException(\"st0 != st1\");\n-        if (st0.equals(st2)) throw new RuntimeException(\"st0 == st2\");\n-        if (st0.equals(st3)) throw new RuntimeException(\"st0 == st3\");\n-\n-        if (st0.hashCode() != st1.hashCode()) throw new RuntimeException(\"st0.hashCode() != st1.hashCode()\");\n-    }\n-\n-    \/*\n-     * Concatenation tests.\n-     *\/\n-    static void concatenationTests() {\n-        int x = 10;\n-        int y = 20;\n-\n-        ASSERT(STR.\"\\{x} \\{y}\", x + \" \" + y);\n-        ASSERT(STR.\"\\{x + y}\", \"\" + (x + y));\n-        ASSERT(STR.process(RAW.\"\\{x} \\{y}\"), x + \" \" + y);\n-        ASSERT(STR.process(RAW.\"\\{x + y}\"), \"\" + (x + y));\n-        ASSERT((RAW.\"\\{x} \\{y}\").process(STR), x + \" \" + y);\n-        ASSERT((RAW.\"\\{x + y}\").process(STR), \"\" + (x + y));\n-    }\n-\n-    \/*\n-     * Component tests.\n-     *\/\n-    static void componentTests() {\n-        int x = 10;\n-        int y = 20;\n-\n-        StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-        ASSERT(st.values(), List.of(x, y, x + y));\n-        ASSERT(st.fragments(), List.of(\"\", \" + \", \" = \", \"\"));\n-        ASSERT(st.interpolate(), x + \" + \" + y + \" = \" + (x + y));\n-    }\n-\n-    \/*\n-     * Limits tests.\n-     *\/\n-    static void limitsTests() {\n-        int x = 9;\n-\n-        StringTemplate ts250 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts250.values().size(), 250);\n-        ASSERT(ts250.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999\n-               \"\"\");\n-\n-        StringTemplate ts251 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\n-             \"\"\";\n-        ASSERT(ts251.values().size(), 251);\n-        ASSERT(ts251.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9\n-               \"\"\");\n-\n-        StringTemplate ts252 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts252.values().size(), 252);\n-        ASSERT(ts252.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 99\n-               \"\"\");\n-\n-        StringTemplate ts253 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts253.values().size(), 253);\n-        ASSERT(ts253.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 999\n-               \"\"\");\n-\n-        StringTemplate ts254 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts254.values().size(), 254);\n-        ASSERT(ts254.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999\n-               \"\"\");\n-\n-        StringTemplate ts255 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts255.values().size(), 255);\n-        ASSERT(ts255.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 99999\n-               \"\"\");\n-\n-        StringTemplate ts256 = RAW.\"\"\"\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n-             \"\"\";\n-        ASSERT(ts256.values().size(), 256);\n-        ASSERT(ts256.interpolate(), \"\"\"\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 9999999999\n-\n-               9999999999 9999999999\n-               9999999999 9999999999\n-               9999999999 999999\n-               \"\"\");\n-\n-    }\n-\n-    \/*\n-     * Processor tests.\n-     *\/\n-    public static final Processor<StringTemplate, RuntimeException> STRINGIFY = st -> {\n-        List<Object> values = st.values()\n-                .stream()\n-                .map(v -> (Object)String.valueOf(v))\n-                .toList();\n-\n-        return StringTemplate.of(st.fragments(), values);\n-    };\n-\n-    public static final Processor<StringTemplate, RuntimeException> UPPER = st -> {\n-        List<String> fragments = st.fragments()\n-                .stream()\n-                .map(String::toUpperCase)\n-                .toList();\n-\n-        return StringTemplate.of(fragments, st.values());\n-    };\n-\n-    public static final Processor<String, RuntimeException> CHAIN = st -> {\n-        st = STRINGIFY.process(st);\n-        st = UPPER.process(st);\n-        return STR.process(st);\n-    };\n-\n-    static void processorTests() {\n-        String name = \"Joan\";\n-        int age = 25;\n-        ASSERT(CHAIN.\"\\{name} is \\{age} years old\", \"Joan IS 25 YEARS OLD\");\n-    }\n-\n-    \/*\n-     *  StringTemplate coverage\n-     *\/\n-    static void stringTemplateCoverage() {\n-        StringTemplate tsNoValues = StringTemplate.of(\"No Values\");\n-\n-        ASSERT(tsNoValues.values(), List.of());\n-        ASSERT(tsNoValues.fragments(), List.of(\"No Values\"));\n-        ASSERT(tsNoValues.interpolate(), STR.\"No Values\");\n-\n-        int x = 10, y = 20;\n-        StringTemplate src = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-        StringTemplate tsValues = StringTemplate.of(src.fragments(), src.values());\n-        ASSERT(tsValues.fragments(), List.of(\"\", \" + \", \" = \", \"\"));\n-        ASSERT(tsValues.values(), List.of(x, y, x + y));\n-        ASSERT(tsValues.interpolate(), x + \" + \" + y + \" = \" + (x + y));\n-        ASSERT(StringTemplate.combine(src, src).interpolate(),\n-                RAW.\"\\{x} + \\{y} = \\{x + y}\\{x} + \\{y} = \\{x + y}\".interpolate());\n-        ASSERT(StringTemplate.combine(src), src);\n-        ASSERT(StringTemplate.combine().interpolate(), \"\");\n-        ASSERT(StringTemplate.combine(List.of(src, src)).interpolate(),\n-                RAW.\"\\{x} + \\{y} = \\{x + y}\\{x} + \\{y} = \\{x + y}\".interpolate());\n-    }\n-\n-    \/*\n-     * SimpleProcessor coverage.\n-     *\/\n-\n-    static class Processor0 implements Processor<String, IllegalArgumentException> {\n-        @Override\n-        public String process(StringTemplate stringTemplate) throws IllegalArgumentException {\n-            StringBuilder sb = new StringBuilder();\n-            Iterator<String> fragmentsIter = stringTemplate.fragments().iterator();\n-\n-            for (Object value : stringTemplate.values()) {\n-                sb.append(fragmentsIter.next());\n-\n-                if (value instanceof Boolean) {\n-                    throw new IllegalArgumentException(\"I don't like Booleans\");\n-                }\n-\n-                sb.append(value);\n-            }\n-\n-            sb.append(fragmentsIter.next());\n-\n-            return sb.toString();\n-        }\n-    }\n-\n-    static Processor0 processor0 = new Processor0();\n-\n-    static Processor<String, RuntimeException> processor1 =\n-        st -> st.interpolate();\n-\n-    static Processor<String, RuntimeException> processor2 = st -> st.interpolate();\n-\n-    static Processor<String, RuntimeException> processor3 = st -> st.interpolate();\n-\n-    static Processor<String, RuntimeException> processor4 = st ->\n-        StringTemplate.interpolate(st.fragments(), st.values());\n-\n-\n-    static void simpleProcessorCoverage() {\n-        try {\n-            int x = 10;\n-            int y = 20;\n-            ASSERT(processor0.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n-            ASSERT(processor1.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n-            ASSERT(processor2.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n-            ASSERT(processor3.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n-            ASSERT(processor4.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n-        } catch (IllegalArgumentException ex) {\n-            throw new RuntimeException(\"processor fail\");\n-        }\n-    }\n-\n-    static String justify(String string, int width) {\n-        boolean leftJustify = width < 0;\n-        int length = string.length();\n-        width = Math.abs(width);\n-        int diff = width - length;\n-\n-        if (diff < 0) {\n-            string = \"*\".repeat(width);\n-        } else if (0 < diff) {\n-            if (leftJustify) {\n-                string += \" \".repeat(diff);\n-            } else {\n-                string = \" \".repeat(diff) + string;\n-            }\n-        }\n-\n-        return string;\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/template\/Basic.java","additions":0,"deletions":504,"binary":false,"changes":504,"status":"deleted"},{"patch":"@@ -1,961 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 0000000\n- * @summary Exercise format builder.\n- * @enablePreview true\n- *\/\n-\n-import java.util.FormatProcessor;\n-import java.util.Objects;\n-import java.util.Locale;\n-import java.util.MissingFormatArgumentException;\n-import java.util.UnknownFormatConversionException;\n-\n-import static java.util.FormatProcessor.FMT;\n-\n-public class FormatterBuilder {\n-    public static void main(String... args) {\n-        Locale.setDefault(Locale.US);\n-        suite(FMT);\n-        Locale thai = Locale.forLanguageTag(\"th-TH-u-nu-thai\");\n-        FormatProcessor thaiFormat = FormatProcessor.create(thai);\n-        Locale.setDefault(thai);\n-        suite(thaiFormat);\n-    }\n-\n-    static void test(String a, String b) {\n-        if (!Objects.equals(a, b)) {\n-            throw new RuntimeException(\"format and FMT do not match: \" + a + \" : \" + b);\n-        }\n-    }\n-\n-    public interface Executable {\n-        void execute() throws Throwable;\n-    }\n-\n-    static <T extends Throwable> void assertThrows(Class<T> expectedType, Executable executable, String message) {\n-        Throwable actualException = null;\n-        try {\n-            executable.execute();\n-        } catch (Throwable e) {\n-            actualException = e;\n-        }\n-        if (actualException == null) {\n-            throw new RuntimeException(\"Expected \" + expectedType + \" to be thrown, but nothing was thrown.\");\n-        }\n-        if (!expectedType.isInstance(actualException)) {\n-            throw new RuntimeException(\"Expected \" + expectedType + \" to be thrown, but was thrown \" + actualException.getClass());\n-        }\n-        if (message != null && !message.equals(actualException.getMessage())) {\n-            throw new RuntimeException(\"Expected \" + message + \" to be thrown, but was thrown \" + actualException.getMessage());\n-        }\n-    }\n-\n-    static void suite(FormatProcessor fmt) {\n-        Object nullObject = null;\n-        test(String.format(\"%b\", false), fmt.\"%b\\{false}\");\n-        test(String.format(\"%b\", true), fmt.\"%b\\{true}\");\n-        test(String.format(\"%10b\", false), fmt.\"%10b\\{false}\");\n-        test(String.format(\"%10b\", true), fmt.\"%10b\\{true}\");\n-        test(String.format(\"%-10b\", false), fmt.\"%-10b\\{false}\");\n-        test(String.format(\"%-10b\", true), fmt.\"%-10b\\{true}\");\n-        test(String.format(\"%B\", false), fmt.\"%B\\{false}\");\n-        test(String.format(\"%B\", true), fmt.\"%B\\{true}\");\n-        test(String.format(\"%10B\", false), fmt.\"%10B\\{false}\");\n-        test(String.format(\"%10B\", true), fmt.\"%10B\\{true}\");\n-        test(String.format(\"%-10B\", false), fmt.\"%-10B\\{false}\");\n-        test(String.format(\"%-10B\", true), fmt.\"%-10B\\{true}\");\n-\n-        test(String.format(\"%h\", 12345), fmt.\"%h\\{12345}\");\n-        test(String.format(\"%h\", 0xABCDE), fmt.\"%h\\{0xABCDE}\");\n-        test(String.format(\"%10h\", 12345), fmt.\"%10h\\{12345}\");\n-        test(String.format(\"%10h\", 0xABCDE), fmt.\"%10h\\{0xABCDE}\");\n-        test(String.format(\"%-10h\", 12345), fmt.\"%-10h\\{12345}\");\n-        test(String.format(\"%-10h\", 0xABCDE), fmt.\"%-10h\\{0xABCDE}\");\n-        test(String.format(\"%H\", 12345), fmt.\"%H\\{12345}\");\n-        test(String.format(\"%H\", 0xABCDE), fmt.\"%H\\{0xABCDE}\");\n-        test(String.format(\"%10H\", 12345), fmt.\"%10H\\{12345}\");\n-        test(String.format(\"%10H\", 0xABCDE), fmt.\"%10H\\{0xABCDE}\");\n-        test(String.format(\"%-10H\", 12345), fmt.\"%-10H\\{12345}\");\n-        test(String.format(\"%-10H\", 0xABCDE), fmt.\"%-10H\\{0xABCDE}\");\n-\n-        test(String.format(\"%s\", (byte)0xFF), fmt.\"%s\\{(byte)0xFF}\");\n-        test(String.format(\"%s\", (short)0xFFFF), fmt.\"%s\\{(short)0xFFFF}\");\n-        test(String.format(\"%s\", 12345), fmt.\"%s\\{12345}\");\n-        test(String.format(\"%s\", 12345L), fmt.\"%s\\{12345L}\");\n-        test(String.format(\"%s\", 1.33f), fmt.\"%s\\{1.33f}\");\n-        test(String.format(\"%s\", 1.33), fmt.\"%s\\{1.33}\");\n-        test(String.format(\"%s\", \"abcde\"), fmt.\"%s\\{\"abcde\"}\");\n-        test(String.format(\"%s\", nullObject), fmt.\"%s\\{nullObject}\");\n-        test(String.format(\"%10s\", (byte)0xFF), fmt.\"%10s\\{(byte)0xFF}\");\n-        test(String.format(\"%10s\", (short)0xFFFF), fmt.\"%10s\\{(short)0xFFFF}\");\n-        test(String.format(\"%10s\", 12345), fmt.\"%10s\\{12345}\");\n-        test(String.format(\"%10s\", 12345L), fmt.\"%10s\\{12345L}\");\n-        test(String.format(\"%10s\", 1.33f), fmt.\"%10s\\{1.33f}\");\n-        test(String.format(\"%10s\", 1.33), fmt.\"%10s\\{1.33}\");\n-        test(String.format(\"%10s\", \"abcde\"), fmt.\"%10s\\{\"abcde\"}\");\n-        test(String.format(\"%10s\", nullObject), fmt.\"%10s\\{nullObject}\");\n-        test(String.format(\"%-10s\", (byte)0xFF), fmt.\"%-10s\\{(byte)0xFF}\");\n-        test(String.format(\"%-10s\", (short)0xFFFF), fmt.\"%-10s\\{(short)0xFFFF}\");\n-        test(String.format(\"%-10s\", 12345), fmt.\"%-10s\\{12345}\");\n-        test(String.format(\"%-10s\", 12345L), fmt.\"%-10s\\{12345L}\");\n-        test(String.format(\"%-10s\", 1.33f), fmt.\"%-10s\\{1.33f}\");\n-        test(String.format(\"%-10s\", 1.33), fmt.\"%-10s\\{1.33}\");\n-        test(String.format(\"%-10s\", \"abcde\"), fmt.\"%-10s\\{\"abcde\"}\");\n-        test(String.format(\"%-10s\", nullObject), fmt.\"%-10s\\{nullObject}\");\n-        test(String.format(\"%S\", (byte)0xFF), fmt.\"%S\\{(byte)0xFF}\");\n-        test(String.format(\"%S\", (short)0xFFFF), fmt.\"%S\\{(short)0xFFFF}\");\n-        test(String.format(\"%S\", 12345), fmt.\"%S\\{12345}\");\n-        test(String.format(\"%S\", 12345L), fmt.\"%S\\{12345L}\");\n-        test(String.format(\"%S\", 1.33f), fmt.\"%S\\{1.33f}\");\n-        test(String.format(\"%S\", 1.33), fmt.\"%S\\{1.33}\");\n-        test(String.format(\"%S\", \"abcde\"), fmt.\"%S\\{\"abcde\"}\");\n-        test(String.format(\"%S\", nullObject), fmt.\"%S\\{nullObject}\");\n-        test(String.format(\"%10S\", (byte)0xFF), fmt.\"%10S\\{(byte)0xFF}\");\n-        test(String.format(\"%10S\", (short)0xFFFF), fmt.\"%10S\\{(short)0xFFFF}\");\n-        test(String.format(\"%10S\", 12345), fmt.\"%10S\\{12345}\");\n-        test(String.format(\"%10S\", 12345L), fmt.\"%10S\\{12345L}\");\n-        test(String.format(\"%10S\", 1.33f), fmt.\"%10S\\{1.33f}\");\n-        test(String.format(\"%10S\", 1.33), fmt.\"%10S\\{1.33}\");\n-        test(String.format(\"%10S\", \"abcde\"), fmt.\"%10S\\{\"abcde\"}\");\n-        test(String.format(\"%10S\", nullObject), fmt.\"%10S\\{nullObject}\");\n-        test(String.format(\"%-10S\", (byte)0xFF), fmt.\"%-10S\\{(byte)0xFF}\");\n-        test(String.format(\"%-10S\", (short)0xFFFF), fmt.\"%-10S\\{(short)0xFFFF}\");\n-        test(String.format(\"%-10S\", 12345), fmt.\"%-10S\\{12345}\");\n-        test(String.format(\"%-10S\", 12345L), fmt.\"%-10S\\{12345L}\");\n-        test(String.format(\"%-10S\", 1.33f), fmt.\"%-10S\\{1.33f}\");\n-        test(String.format(\"%-10S\", 1.33), fmt.\"%-10S\\{1.33}\");\n-        test(String.format(\"%-10S\", \"abcde\"), fmt.\"%-10S\\{\"abcde\"}\");\n-        test(String.format(\"%-10S\", nullObject), fmt.\"%-10S\\{nullObject}\");\n-\n-        test(String.format(\"%c\", 'a'), fmt.\"%c\\{'a'}\");\n-        test(String.format(\"%10c\", 'a'), fmt.\"%10c\\{'a'}\");\n-        test(String.format(\"%-10c\", 'a'), fmt.\"%-10c\\{'a'}\");\n-        test(String.format(\"%C\", 'a'), fmt.\"%C\\{'a'}\");\n-        test(String.format(\"%10C\", 'a'), fmt.\"%10C\\{'a'}\");\n-        test(String.format(\"%-10C\", 'a'), fmt.\"%-10C\\{'a'}\");\n-\n-        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n-        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n-        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n-        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n-        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n-        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n-        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n-        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n-        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n-        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n-        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n-        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n-        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n-        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n-        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n-        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n-        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n-        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n-        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n-        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n-        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n-        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n-        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n-        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n-\n-        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n-        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n-        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n-        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n-        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n-        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n-        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n-        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n-        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n-        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n-        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n-        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n-        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n-        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n-        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n-        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n-        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n-        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n-        test(String.format(\"% d\", -12345), fmt.\"% d\\{-12345}\");\n-        test(String.format(\"% d\", 0), fmt.\"% d\\{0}\");\n-        test(String.format(\"% d\", 12345), fmt.\"% d\\{12345}\");\n-        test(String.format(\"% 10d\", -12345), fmt.\"% 10d\\{-12345}\");\n-        test(String.format(\"% 10d\", 0), fmt.\"% 10d\\{0}\");\n-        test(String.format(\"% 10d\", 12345), fmt.\"% 10d\\{12345}\");\n-        test(String.format(\"% -10d\", -12345), fmt.\"% -10d\\{-12345}\");\n-        test(String.format(\"% -10d\", 0), fmt.\"% -10d\\{0}\");\n-        test(String.format(\"% -10d\", 12345), fmt.\"% -10d\\{12345}\");\n-        test(String.format(\"%, d\", -12345), fmt.\"%, d\\{-12345}\");\n-        test(String.format(\"%, d\", 0), fmt.\"%, d\\{0}\");\n-        test(String.format(\"%, d\", 12345), fmt.\"%, d\\{12345}\");\n-        test(String.format(\"%, 10d\", -12345), fmt.\"%, 10d\\{-12345}\");\n-        test(String.format(\"%, 10d\", 0), fmt.\"%, 10d\\{0}\");\n-        test(String.format(\"%, 10d\", 12345), fmt.\"%, 10d\\{12345}\");\n-        test(String.format(\"%, -10d\", -12345), fmt.\"%, -10d\\{-12345}\");\n-        test(String.format(\"%, -10d\", 0), fmt.\"%, -10d\\{0}\");\n-        test(String.format(\"%, -10d\", 12345), fmt.\"%, -10d\\{12345}\");\n-        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n-        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n-        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n-        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n-        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n-        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n-        test(String.format(\"% 010d\", -12345), fmt.\"% 010d\\{-12345}\");\n-        test(String.format(\"% 010d\", 0), fmt.\"% 010d\\{0}\");\n-        test(String.format(\"% 010d\", 12345), fmt.\"% 010d\\{12345}\");\n-        test(String.format(\"%, 010d\", -12345), fmt.\"%, 010d\\{-12345}\");\n-        test(String.format(\"%, 010d\", 0), fmt.\"%, 010d\\{0}\");\n-        test(String.format(\"%, 010d\", 12345), fmt.\"%, 010d\\{12345}\");\n-\n-        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n-        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n-        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n-        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n-        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n-        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n-        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n-        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n-        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n-        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n-        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n-        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n-        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n-        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n-        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n-        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n-        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n-        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n-        test(String.format(\"%+d\", -12345), fmt.\"%+d\\{-12345}\");\n-        test(String.format(\"%+d\", 0), fmt.\"%+d\\{0}\");\n-        test(String.format(\"%+d\", 12345), fmt.\"%+d\\{12345}\");\n-        test(String.format(\"%+10d\", -12345), fmt.\"%+10d\\{-12345}\");\n-        test(String.format(\"%+10d\", 0), fmt.\"%+10d\\{0}\");\n-        test(String.format(\"%+10d\", 12345), fmt.\"%+10d\\{12345}\");\n-        test(String.format(\"%+-10d\", -12345), fmt.\"%+-10d\\{-12345}\");\n-        test(String.format(\"%+-10d\", 0), fmt.\"%+-10d\\{0}\");\n-        test(String.format(\"%+-10d\", 12345), fmt.\"%+-10d\\{12345}\");\n-        test(String.format(\"%,+d\", -12345), fmt.\"%,+d\\{-12345}\");\n-        test(String.format(\"%,+d\", 0), fmt.\"%,+d\\{0}\");\n-        test(String.format(\"%,+d\", 12345), fmt.\"%,+d\\{12345}\");\n-        test(String.format(\"%,+10d\", -12345), fmt.\"%,+10d\\{-12345}\");\n-        test(String.format(\"%,+10d\", 0), fmt.\"%,+10d\\{0}\");\n-        test(String.format(\"%,+10d\", 12345), fmt.\"%,+10d\\{12345}\");\n-        test(String.format(\"%,+-10d\", -12345), fmt.\"%,+-10d\\{-12345}\");\n-        test(String.format(\"%,+-10d\", 0), fmt.\"%,+-10d\\{0}\");\n-        test(String.format(\"%,+-10d\", 12345), fmt.\"%,+-10d\\{12345}\");\n-        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n-        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n-        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n-        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n-        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n-        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n-        test(String.format(\"%+010d\", -12345), fmt.\"%+010d\\{-12345}\");\n-        test(String.format(\"%+010d\", 0), fmt.\"%+010d\\{0}\");\n-        test(String.format(\"%+010d\", 12345), fmt.\"%+010d\\{12345}\");\n-        test(String.format(\"%,+010d\", -12345), fmt.\"%,+010d\\{-12345}\");\n-        test(String.format(\"%,+010d\", 0), fmt.\"%,+010d\\{0}\");\n-        test(String.format(\"%,+010d\", 12345), fmt.\"%,+010d\\{12345}\");\n-\n-        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n-        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n-        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n-        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n-        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n-        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n-        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n-        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n-        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n-        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n-        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n-        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n-        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n-        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n-        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n-        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n-        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n-        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n-        test(String.format(\"%(d\", -12345), fmt.\"%(d\\{-12345}\");\n-        test(String.format(\"%(d\", 0), fmt.\"%(d\\{0}\");\n-        test(String.format(\"%(d\", 12345), fmt.\"%(d\\{12345}\");\n-        test(String.format(\"%(10d\", -12345), fmt.\"%(10d\\{-12345}\");\n-        test(String.format(\"%(10d\", 0), fmt.\"%(10d\\{0}\");\n-        test(String.format(\"%(10d\", 12345), fmt.\"%(10d\\{12345}\");\n-        test(String.format(\"%(-10d\", -12345), fmt.\"%(-10d\\{-12345}\");\n-        test(String.format(\"%(-10d\", 0), fmt.\"%(-10d\\{0}\");\n-        test(String.format(\"%(-10d\", 12345), fmt.\"%(-10d\\{12345}\");\n-        test(String.format(\"%,(d\", -12345), fmt.\"%,(d\\{-12345}\");\n-        test(String.format(\"%,(d\", 0), fmt.\"%,(d\\{0}\");\n-        test(String.format(\"%,(d\", 12345), fmt.\"%,(d\\{12345}\");\n-        test(String.format(\"%,(10d\", -12345), fmt.\"%,(10d\\{-12345}\");\n-        test(String.format(\"%,(10d\", 0), fmt.\"%,(10d\\{0}\");\n-        test(String.format(\"%,(10d\", 12345), fmt.\"%,(10d\\{12345}\");\n-        test(String.format(\"%,(-10d\", -12345), fmt.\"%,(-10d\\{-12345}\");\n-        test(String.format(\"%,(-10d\", 0), fmt.\"%,(-10d\\{0}\");\n-        test(String.format(\"%,(-10d\", 12345), fmt.\"%,(-10d\\{12345}\");\n-        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n-        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n-        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n-        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n-        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n-        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n-        test(String.format(\"%(010d\", -12345), fmt.\"%(010d\\{-12345}\");\n-        test(String.format(\"%(010d\", 0), fmt.\"%(010d\\{0}\");\n-        test(String.format(\"%(010d\", 12345), fmt.\"%(010d\\{12345}\");\n-        test(String.format(\"%,(010d\", -12345), fmt.\"%,(010d\\{-12345}\");\n-        test(String.format(\"%,(010d\", 0), fmt.\"%,(010d\\{0}\");\n-        test(String.format(\"%,(010d\", 12345), fmt.\"%,(010d\\{12345}\");\n-\n-        test(String.format(\"%o\", -12345), fmt.\"%o\\{-12345}\");\n-        test(String.format(\"%o\", 0), fmt.\"%o\\{0}\");\n-        test(String.format(\"%o\", 12345), fmt.\"%o\\{12345}\");\n-        test(String.format(\"%10o\", -12345), fmt.\"%10o\\{-12345}\");\n-        test(String.format(\"%10o\", 0), fmt.\"%10o\\{0}\");\n-        test(String.format(\"%10o\", 12345), fmt.\"%10o\\{12345}\");\n-        test(String.format(\"%-10o\", -12345), fmt.\"%-10o\\{-12345}\");\n-        test(String.format(\"%-10o\", 0), fmt.\"%-10o\\{0}\");\n-        test(String.format(\"%-10o\", 12345), fmt.\"%-10o\\{12345}\");\n-        test(String.format(\"%#o\", -12345), fmt.\"%#o\\{-12345}\");\n-        test(String.format(\"%#o\", 0), fmt.\"%#o\\{0}\");\n-        test(String.format(\"%#o\", 12345), fmt.\"%#o\\{12345}\");\n-        test(String.format(\"%#10o\", -12345), fmt.\"%#10o\\{-12345}\");\n-        test(String.format(\"%#10o\", 0), fmt.\"%#10o\\{0}\");\n-        test(String.format(\"%#10o\", 12345), fmt.\"%#10o\\{12345}\");\n-        test(String.format(\"%#-10o\", -12345), fmt.\"%#-10o\\{-12345}\");\n-        test(String.format(\"%#-10o\", 0), fmt.\"%#-10o\\{0}\");\n-        test(String.format(\"%#-10o\", 12345), fmt.\"%#-10o\\{12345}\");\n-        test(String.format(\"%010o\", -12345), fmt.\"%010o\\{-12345}\");\n-        test(String.format(\"%010o\", 0), fmt.\"%010o\\{0}\");\n-        test(String.format(\"%010o\", 12345), fmt.\"%010o\\{12345}\");\n-        test(String.format(\"%#010o\", -12345), fmt.\"%#010o\\{-12345}\");\n-        test(String.format(\"%#010o\", 0), fmt.\"%#010o\\{0}\");\n-        test(String.format(\"%#010o\", 12345), fmt.\"%#010o\\{12345}\");\n-\n-        test(String.format(\"%x\", -12345), fmt.\"%x\\{-12345}\");\n-        test(String.format(\"%x\", 0), fmt.\"%x\\{0}\");\n-        test(String.format(\"%x\", 12345), fmt.\"%x\\{12345}\");\n-        test(String.format(\"%10x\", -12345), fmt.\"%10x\\{-12345}\");\n-        test(String.format(\"%10x\", 0), fmt.\"%10x\\{0}\");\n-        test(String.format(\"%10x\", 12345), fmt.\"%10x\\{12345}\");\n-        test(String.format(\"%-10x\", -12345), fmt.\"%-10x\\{-12345}\");\n-        test(String.format(\"%-10x\", 0), fmt.\"%-10x\\{0}\");\n-        test(String.format(\"%-10x\", 12345), fmt.\"%-10x\\{12345}\");\n-        test(String.format(\"%X\", -12345), fmt.\"%X\\{-12345}\");\n-        test(String.format(\"%X\", 0), fmt.\"%X\\{0}\");\n-        test(String.format(\"%X\", 12345), fmt.\"%X\\{12345}\");\n-        test(String.format(\"%10X\", -12345), fmt.\"%10X\\{-12345}\");\n-        test(String.format(\"%10X\", 0), fmt.\"%10X\\{0}\");\n-        test(String.format(\"%10X\", 12345), fmt.\"%10X\\{12345}\");\n-        test(String.format(\"%-10X\", -12345), fmt.\"%-10X\\{-12345}\");\n-        test(String.format(\"%-10X\", 0), fmt.\"%-10X\\{0}\");\n-        test(String.format(\"%-10X\", 12345), fmt.\"%-10X\\{12345}\");\n-        test(String.format(\"%#x\", -12345), fmt.\"%#x\\{-12345}\");\n-        test(String.format(\"%#x\", 0), fmt.\"%#x\\{0}\");\n-        test(String.format(\"%#x\", 12345), fmt.\"%#x\\{12345}\");\n-        test(String.format(\"%#10x\", -12345), fmt.\"%#10x\\{-12345}\");\n-        test(String.format(\"%#10x\", 0), fmt.\"%#10x\\{0}\");\n-        test(String.format(\"%#10x\", 12345), fmt.\"%#10x\\{12345}\");\n-        test(String.format(\"%#-10x\", -12345), fmt.\"%#-10x\\{-12345}\");\n-        test(String.format(\"%#-10x\", 0), fmt.\"%#-10x\\{0}\");\n-        test(String.format(\"%#-10x\", 12345), fmt.\"%#-10x\\{12345}\");\n-        test(String.format(\"%#X\", -12345), fmt.\"%#X\\{-12345}\");\n-        test(String.format(\"%#X\", 0), fmt.\"%#X\\{0}\");\n-        test(String.format(\"%#X\", 12345), fmt.\"%#X\\{12345}\");\n-        test(String.format(\"%#10X\", -12345), fmt.\"%#10X\\{-12345}\");\n-        test(String.format(\"%#10X\", 0), fmt.\"%#10X\\{0}\");\n-        test(String.format(\"%#10X\", 12345), fmt.\"%#10X\\{12345}\");\n-        test(String.format(\"%#-10X\", -12345), fmt.\"%#-10X\\{-12345}\");\n-        test(String.format(\"%#-10X\", 0), fmt.\"%#-10X\\{0}\");\n-        test(String.format(\"%#-10X\", 12345), fmt.\"%#-10X\\{12345}\");\n-        test(String.format(\"%010x\", -12345), fmt.\"%010x\\{-12345}\");\n-        test(String.format(\"%010x\", 0), fmt.\"%010x\\{0}\");\n-        test(String.format(\"%010x\", 12345), fmt.\"%010x\\{12345}\");\n-        test(String.format(\"%010X\", -12345), fmt.\"%010X\\{-12345}\");\n-        test(String.format(\"%010X\", 0), fmt.\"%010X\\{0}\");\n-        test(String.format(\"%010X\", 12345), fmt.\"%010X\\{12345}\");\n-        test(String.format(\"%#010x\", -12345), fmt.\"%#010x\\{-12345}\");\n-        test(String.format(\"%#010x\", 0), fmt.\"%#010x\\{0}\");\n-        test(String.format(\"%#010x\", 12345), fmt.\"%#010x\\{12345}\");\n-        test(String.format(\"%#010X\", -12345), fmt.\"%#010X\\{-12345}\");\n-        test(String.format(\"%#010X\", 0), fmt.\"%#010X\\{0}\");\n-        test(String.format(\"%#010X\", 12345), fmt.\"%#010X\\{12345}\");\n-\n-        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n-        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n-        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n-        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n-        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n-        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n-        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n-        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n-        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n-        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n-        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n-        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n-        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n-        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n-        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n-        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n-        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n-        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n-\n-        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n-        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n-        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n-        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n-        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n-        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n-        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n-        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n-        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n-        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n-        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n-        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n-        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n-        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n-        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n-        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n-        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n-        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n-        test(String.format(\"% f\", -12345.6), fmt.\"% f\\{-12345.6}\");\n-        test(String.format(\"% f\", 0.0), fmt.\"% f\\{0.0}\");\n-        test(String.format(\"% f\", 12345.6), fmt.\"% f\\{12345.6}\");\n-        test(String.format(\"% 10f\", -12345.6), fmt.\"% 10f\\{-12345.6}\");\n-        test(String.format(\"% 10f\", 0.0), fmt.\"% 10f\\{0.0}\");\n-        test(String.format(\"% 10f\", 12345.6), fmt.\"% 10f\\{12345.6}\");\n-        test(String.format(\"% -10f\", -12345.6), fmt.\"% -10f\\{-12345.6}\");\n-        test(String.format(\"% -10f\", 0.0), fmt.\"% -10f\\{0.0}\");\n-        test(String.format(\"% -10f\", 12345.6), fmt.\"% -10f\\{12345.6}\");\n-        test(String.format(\"%, f\", -12345.6), fmt.\"%, f\\{-12345.6}\");\n-        test(String.format(\"%, f\", 0.0), fmt.\"%, f\\{0.0}\");\n-        test(String.format(\"%, f\", 12345.6), fmt.\"%, f\\{12345.6}\");\n-        test(String.format(\"%, 10f\", -12345.6), fmt.\"%, 10f\\{-12345.6}\");\n-        test(String.format(\"%, 10f\", 0.0), fmt.\"%, 10f\\{0.0}\");\n-        test(String.format(\"%, 10f\", 12345.6), fmt.\"%, 10f\\{12345.6}\");\n-        test(String.format(\"%, -10f\", -12345.6), fmt.\"%, -10f\\{-12345.6}\");\n-        test(String.format(\"%, -10f\", 0.0), fmt.\"%, -10f\\{0.0}\");\n-        test(String.format(\"%, -10f\", 12345.6), fmt.\"%, -10f\\{12345.6}\");\n-\n-        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n-        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n-        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n-        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n-        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n-        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n-        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n-        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n-        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n-        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n-        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n-        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n-        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n-        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n-        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n-        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n-        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n-        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n-        test(String.format(\"%+f\", -12345.6), fmt.\"%+f\\{-12345.6}\");\n-        test(String.format(\"%+f\", 0.0), fmt.\"%+f\\{0.0}\");\n-        test(String.format(\"%+f\", 12345.6), fmt.\"%+f\\{12345.6}\");\n-        test(String.format(\"%+10f\", -12345.6), fmt.\"%+10f\\{-12345.6}\");\n-        test(String.format(\"%+10f\", 0.0), fmt.\"%+10f\\{0.0}\");\n-        test(String.format(\"%+10f\", 12345.6), fmt.\"%+10f\\{12345.6}\");\n-        test(String.format(\"%+-10f\", -12345.6), fmt.\"%+-10f\\{-12345.6}\");\n-        test(String.format(\"%+-10f\", 0.0), fmt.\"%+-10f\\{0.0}\");\n-        test(String.format(\"%+-10f\", 12345.6), fmt.\"%+-10f\\{12345.6}\");\n-        test(String.format(\"%,+f\", -12345.6), fmt.\"%,+f\\{-12345.6}\");\n-        test(String.format(\"%,+f\", 0.0), fmt.\"%,+f\\{0.0}\");\n-        test(String.format(\"%,+f\", 12345.6), fmt.\"%,+f\\{12345.6}\");\n-        test(String.format(\"%,+10f\", -12345.6), fmt.\"%,+10f\\{-12345.6}\");\n-        test(String.format(\"%,+10f\", 0.0), fmt.\"%,+10f\\{0.0}\");\n-        test(String.format(\"%,+10f\", 12345.6), fmt.\"%,+10f\\{12345.6}\");\n-        test(String.format(\"%,+-10f\", -12345.6), fmt.\"%,+-10f\\{-12345.6}\");\n-        test(String.format(\"%,+-10f\", 0.0), fmt.\"%,+-10f\\{0.0}\");\n-        test(String.format(\"%,+-10f\", 12345.6), fmt.\"%,+-10f\\{12345.6}\");\n-\n-        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n-        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n-        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n-        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n-        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n-        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n-        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n-        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n-        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n-        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n-        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n-        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n-        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n-        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n-        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n-        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n-        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n-        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n-        test(String.format(\"%(f\", -12345.6), fmt.\"%(f\\{-12345.6}\");\n-        test(String.format(\"%(f\", 0.0), fmt.\"%(f\\{0.0}\");\n-        test(String.format(\"%(f\", 12345.6), fmt.\"%(f\\{12345.6}\");\n-        test(String.format(\"%(10f\", -12345.6), fmt.\"%(10f\\{-12345.6}\");\n-        test(String.format(\"%(10f\", 0.0), fmt.\"%(10f\\{0.0}\");\n-        test(String.format(\"%(10f\", 12345.6), fmt.\"%(10f\\{12345.6}\");\n-        test(String.format(\"%(-10f\", -12345.6), fmt.\"%(-10f\\{-12345.6}\");\n-        test(String.format(\"%(-10f\", 0.0), fmt.\"%(-10f\\{0.0}\");\n-        test(String.format(\"%(-10f\", 12345.6), fmt.\"%(-10f\\{12345.6}\");\n-        test(String.format(\"%,(f\", -12345.6), fmt.\"%,(f\\{-12345.6}\");\n-        test(String.format(\"%,(f\", 0.0), fmt.\"%,(f\\{0.0}\");\n-        test(String.format(\"%,(f\", 12345.6), fmt.\"%,(f\\{12345.6}\");\n-        test(String.format(\"%,(10f\", -12345.6), fmt.\"%,(10f\\{-12345.6}\");\n-        test(String.format(\"%,(10f\", 0.0), fmt.\"%,(10f\\{0.0}\");\n-        test(String.format(\"%,(10f\", 12345.6), fmt.\"%,(10f\\{12345.6}\");\n-        test(String.format(\"%,(-10f\", -12345.6), fmt.\"%,(-10f\\{-12345.6}\");\n-        test(String.format(\"%,(-10f\", 0.0), fmt.\"%,(-10f\\{0.0}\");\n-        test(String.format(\"%,(-10f\", 12345.6), fmt.\"%,(-10f\\{12345.6}\");\n-        test(String.format(\"%+f\", -12345.6), fmt.\"%+f\\{-12345.6}\");\n-        test(String.format(\"%+f\", 0.0), fmt.\"%+f\\{0.0}\");\n-        test(String.format(\"%+f\", 12345.6), fmt.\"%+f\\{12345.6}\");\n-        test(String.format(\"%+10f\", -12345.6), fmt.\"%+10f\\{-12345.6}\");\n-        test(String.format(\"%+10f\", 0.0), fmt.\"%+10f\\{0.0}\");\n-        test(String.format(\"%+10f\", 12345.6), fmt.\"%+10f\\{12345.6}\");\n-        test(String.format(\"%+-10f\", -12345.6), fmt.\"%+-10f\\{-12345.6}\");\n-        test(String.format(\"%+-10f\", 0.0), fmt.\"%+-10f\\{0.0}\");\n-        test(String.format(\"%+-10f\", 12345.6), fmt.\"%+-10f\\{12345.6}\");\n-        test(String.format(\"%,+f\", -12345.6), fmt.\"%,+f\\{-12345.6}\");\n-        test(String.format(\"%,+f\", 0.0), fmt.\"%,+f\\{0.0}\");\n-        test(String.format(\"%,+f\", 12345.6), fmt.\"%,+f\\{12345.6}\");\n-        test(String.format(\"%,+10f\", -12345.6), fmt.\"%,+10f\\{-12345.6}\");\n-        test(String.format(\"%,+10f\", 0.0), fmt.\"%,+10f\\{0.0}\");\n-        test(String.format(\"%,+10f\", 12345.6), fmt.\"%,+10f\\{12345.6}\");\n-        test(String.format(\"%,+-10f\", -12345.6), fmt.\"%,+-10f\\{-12345.6}\");\n-        test(String.format(\"%,+-10f\", 0.0), fmt.\"%,+-10f\\{0.0}\");\n-        test(String.format(\"%,+-10f\", 12345.6), fmt.\"%,+-10f\\{12345.6}\");\n-        test(String.format(\"%(+f\", -12345.6), fmt.\"%(+f\\{-12345.6}\");\n-        test(String.format(\"%(+f\", 0.0), fmt.\"%(+f\\{0.0}\");\n-        test(String.format(\"%(+f\", 12345.6), fmt.\"%(+f\\{12345.6}\");\n-        test(String.format(\"%(+10f\", -12345.6), fmt.\"%(+10f\\{-12345.6}\");\n-        test(String.format(\"%(+10f\", 0.0), fmt.\"%(+10f\\{0.0}\");\n-        test(String.format(\"%(+10f\", 12345.6), fmt.\"%(+10f\\{12345.6}\");\n-        test(String.format(\"%(+-10f\", -12345.6), fmt.\"%(+-10f\\{-12345.6}\");\n-        test(String.format(\"%(+-10f\", 0.0), fmt.\"%(+-10f\\{0.0}\");\n-        test(String.format(\"%(+-10f\", 12345.6), fmt.\"%(+-10f\\{12345.6}\");\n-        test(String.format(\"%,(+f\", -12345.6), fmt.\"%,(+f\\{-12345.6}\");\n-        test(String.format(\"%,(+f\", 0.0), fmt.\"%,(+f\\{0.0}\");\n-        test(String.format(\"%,(+f\", 12345.6), fmt.\"%,(+f\\{12345.6}\");\n-        test(String.format(\"%,(+10f\", -12345.6), fmt.\"%,(+10f\\{-12345.6}\");\n-        test(String.format(\"%,(+10f\", 0.0), fmt.\"%,(+10f\\{0.0}\");\n-        test(String.format(\"%,(+10f\", 12345.6), fmt.\"%,(+10f\\{12345.6}\");\n-        test(String.format(\"%,(+-10f\", -12345.6), fmt.\"%,(+-10f\\{-12345.6}\");\n-        test(String.format(\"%,(+-10f\", 0.0), fmt.\"%,(+-10f\\{0.0}\");\n-        test(String.format(\"%,(+-10f\", 12345.6), fmt.\"%,(+-10f\\{12345.6}\");\n-\n-        test(String.format(\"%e\", -12345.6), fmt.\"%e\\{-12345.6}\");\n-        test(String.format(\"%e\", 0.0), fmt.\"%e\\{0.0}\");\n-        test(String.format(\"%e\", 12345.6), fmt.\"%e\\{12345.6}\");\n-        test(String.format(\"%10e\", -12345.6), fmt.\"%10e\\{-12345.6}\");\n-        test(String.format(\"%10e\", 0.0), fmt.\"%10e\\{0.0}\");\n-        test(String.format(\"%10e\", 12345.6), fmt.\"%10e\\{12345.6}\");\n-        test(String.format(\"%-10e\", -12345.6), fmt.\"%-10e\\{-12345.6}\");\n-        test(String.format(\"%-10e\", 0.0), fmt.\"%-10e\\{0.0}\");\n-        test(String.format(\"%-10e\", 12345.6), fmt.\"%-10e\\{12345.6}\");\n-        test(String.format(\"%E\", -12345.6), fmt.\"%E\\{-12345.6}\");\n-        test(String.format(\"%E\", 0.0), fmt.\"%E\\{0.0}\");\n-        test(String.format(\"%E\", 12345.6), fmt.\"%E\\{12345.6}\");\n-        test(String.format(\"%10E\", -12345.6), fmt.\"%10E\\{-12345.6}\");\n-        test(String.format(\"%10E\", 0.0), fmt.\"%10E\\{0.0}\");\n-        test(String.format(\"%10E\", 12345.6), fmt.\"%10E\\{12345.6}\");\n-        test(String.format(\"%-10E\", -12345.6), fmt.\"%-10E\\{-12345.6}\");\n-        test(String.format(\"%-10E\", 0.0), fmt.\"%-10E\\{0.0}\");\n-        test(String.format(\"%-10E\", 12345.6), fmt.\"%-10E\\{12345.6}\");\n-\n-        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n-        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n-        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n-        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n-        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n-        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n-        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n-        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n-        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n-        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n-        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n-        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n-        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n-        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n-        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n-        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n-        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n-        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n-        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n-        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n-        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n-        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n-        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n-        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n-        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n-        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n-        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n-        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n-        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n-        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n-        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n-        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n-        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n-        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n-        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n-        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n-\n-        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n-        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n-        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n-        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n-        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n-        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n-        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n-        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n-        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n-        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n-        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n-        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n-        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n-        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n-        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n-        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n-        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n-        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n-        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n-        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n-        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n-        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n-        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n-        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n-        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n-        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n-        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n-        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n-        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n-        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n-        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n-        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n-        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n-        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n-        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n-        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n-        test(String.format(\"% g\", -12345.6), fmt.\"% g\\{-12345.6}\");\n-        test(String.format(\"% g\", 0.0), fmt.\"% g\\{0.0}\");\n-        test(String.format(\"% g\", 12345.6), fmt.\"% g\\{12345.6}\");\n-        test(String.format(\"% 10g\", -12345.6), fmt.\"% 10g\\{-12345.6}\");\n-        test(String.format(\"% 10g\", 0.0), fmt.\"% 10g\\{0.0}\");\n-        test(String.format(\"% 10g\", 12345.6), fmt.\"% 10g\\{12345.6}\");\n-        test(String.format(\"% -10g\", -12345.6), fmt.\"% -10g\\{-12345.6}\");\n-        test(String.format(\"% -10g\", 0.0), fmt.\"% -10g\\{0.0}\");\n-        test(String.format(\"% -10g\", 12345.6), fmt.\"% -10g\\{12345.6}\");\n-        test(String.format(\"% G\", -12345.6), fmt.\"% G\\{-12345.6}\");\n-        test(String.format(\"% G\", 0.0), fmt.\"% G\\{0.0}\");\n-        test(String.format(\"% G\", 12345.6), fmt.\"% G\\{12345.6}\");\n-        test(String.format(\"% 10G\", -12345.6), fmt.\"% 10G\\{-12345.6}\");\n-        test(String.format(\"% 10G\", 0.0), fmt.\"% 10G\\{0.0}\");\n-        test(String.format(\"% 10G\", 12345.6), fmt.\"% 10G\\{12345.6}\");\n-        test(String.format(\"% -10G\", -12345.6), fmt.\"% -10G\\{-12345.6}\");\n-        test(String.format(\"% -10G\", 0.0), fmt.\"% -10G\\{0.0}\");\n-        test(String.format(\"% -10G\", 12345.6), fmt.\"% -10G\\{12345.6}\");\n-        test(String.format(\"%, g\", -12345.6), fmt.\"%, g\\{-12345.6}\");\n-        test(String.format(\"%, g\", 0.0), fmt.\"%, g\\{0.0}\");\n-        test(String.format(\"%, g\", 12345.6), fmt.\"%, g\\{12345.6}\");\n-        test(String.format(\"%, 10g\", -12345.6), fmt.\"%, 10g\\{-12345.6}\");\n-        test(String.format(\"%, 10g\", 0.0), fmt.\"%, 10g\\{0.0}\");\n-        test(String.format(\"%, 10g\", 12345.6), fmt.\"%, 10g\\{12345.6}\");\n-        test(String.format(\"%, -10g\", -12345.6), fmt.\"%, -10g\\{-12345.6}\");\n-        test(String.format(\"%, -10g\", 0.0), fmt.\"%, -10g\\{0.0}\");\n-        test(String.format(\"%, -10g\", 12345.6), fmt.\"%, -10g\\{12345.6}\");\n-        test(String.format(\"%, G\", -12345.6), fmt.\"%, G\\{-12345.6}\");\n-        test(String.format(\"%, G\", 0.0), fmt.\"%, G\\{0.0}\");\n-        test(String.format(\"%, G\", 12345.6), fmt.\"%, G\\{12345.6}\");\n-        test(String.format(\"%, 10G\", -12345.6), fmt.\"%, 10G\\{-12345.6}\");\n-        test(String.format(\"%, 10G\", 0.0), fmt.\"%, 10G\\{0.0}\");\n-        test(String.format(\"%, 10G\", 12345.6), fmt.\"%, 10G\\{12345.6}\");\n-        test(String.format(\"%, -10G\", -12345.6), fmt.\"%, -10G\\{-12345.6}\");\n-        test(String.format(\"%, -10G\", 0.0), fmt.\"%, -10G\\{0.0}\");\n-        test(String.format(\"%, -10G\", 12345.6), fmt.\"%, -10G\\{12345.6}\");\n-\n-        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n-        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n-        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n-        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n-        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n-        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n-        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n-        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n-        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n-        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n-        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n-        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n-        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n-        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n-        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n-        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n-        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n-        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n-        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n-        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n-        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n-        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n-        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n-        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n-        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n-        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n-        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n-        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n-        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n-        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n-        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n-        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n-        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n-        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n-        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n-        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n-        test(String.format(\"%+g\", -12345.6), fmt.\"%+g\\{-12345.6}\");\n-        test(String.format(\"%+g\", 0.0), fmt.\"%+g\\{0.0}\");\n-        test(String.format(\"%+g\", 12345.6), fmt.\"%+g\\{12345.6}\");\n-        test(String.format(\"%+10g\", -12345.6), fmt.\"%+10g\\{-12345.6}\");\n-        test(String.format(\"%+10g\", 0.0), fmt.\"%+10g\\{0.0}\");\n-        test(String.format(\"%+10g\", 12345.6), fmt.\"%+10g\\{12345.6}\");\n-        test(String.format(\"%+-10g\", -12345.6), fmt.\"%+-10g\\{-12345.6}\");\n-        test(String.format(\"%+-10g\", 0.0), fmt.\"%+-10g\\{0.0}\");\n-        test(String.format(\"%+-10g\", 12345.6), fmt.\"%+-10g\\{12345.6}\");\n-        test(String.format(\"%+G\", -12345.6), fmt.\"%+G\\{-12345.6}\");\n-        test(String.format(\"%+G\", 0.0), fmt.\"%+G\\{0.0}\");\n-        test(String.format(\"%+G\", 12345.6), fmt.\"%+G\\{12345.6}\");\n-        test(String.format(\"%+10G\", -12345.6), fmt.\"%+10G\\{-12345.6}\");\n-        test(String.format(\"%+10G\", 0.0), fmt.\"%+10G\\{0.0}\");\n-        test(String.format(\"%+10G\", 12345.6), fmt.\"%+10G\\{12345.6}\");\n-        test(String.format(\"%+-10G\", -12345.6), fmt.\"%+-10G\\{-12345.6}\");\n-        test(String.format(\"%+-10G\", 0.0), fmt.\"%+-10G\\{0.0}\");\n-        test(String.format(\"%+-10G\", 12345.6), fmt.\"%+-10G\\{12345.6}\");\n-        test(String.format(\"%,+g\", -12345.6), fmt.\"%,+g\\{-12345.6}\");\n-        test(String.format(\"%,+g\", 0.0), fmt.\"%,+g\\{0.0}\");\n-        test(String.format(\"%,+g\", 12345.6), fmt.\"%,+g\\{12345.6}\");\n-        test(String.format(\"%,+10g\", -12345.6), fmt.\"%,+10g\\{-12345.6}\");\n-        test(String.format(\"%,+10g\", 0.0), fmt.\"%,+10g\\{0.0}\");\n-        test(String.format(\"%,+10g\", 12345.6), fmt.\"%,+10g\\{12345.6}\");\n-        test(String.format(\"%,+-10g\", -12345.6), fmt.\"%,+-10g\\{-12345.6}\");\n-        test(String.format(\"%,+-10g\", 0.0), fmt.\"%,+-10g\\{0.0}\");\n-        test(String.format(\"%,+-10g\", 12345.6), fmt.\"%,+-10g\\{12345.6}\");\n-        test(String.format(\"%,+G\", -12345.6), fmt.\"%,+G\\{-12345.6}\");\n-        test(String.format(\"%,+G\", 0.0), fmt.\"%,+G\\{0.0}\");\n-        test(String.format(\"%,+G\", 12345.6), fmt.\"%,+G\\{12345.6}\");\n-        test(String.format(\"%,+10G\", -12345.6), fmt.\"%,+10G\\{-12345.6}\");\n-        test(String.format(\"%,+10G\", 0.0), fmt.\"%,+10G\\{0.0}\");\n-        test(String.format(\"%,+10G\", 12345.6), fmt.\"%,+10G\\{12345.6}\");\n-        test(String.format(\"%,+-10G\", -12345.6), fmt.\"%,+-10G\\{-12345.6}\");\n-        test(String.format(\"%,+-10G\", 0.0), fmt.\"%,+-10G\\{0.0}\");\n-        test(String.format(\"%,+-10G\", 12345.6), fmt.\"%,+-10G\\{12345.6}\");\n-\n-        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n-        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n-        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n-        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n-        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n-        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n-        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n-        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n-        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n-        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n-        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n-        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n-        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n-        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n-        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n-        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n-        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n-        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n-        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n-        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n-        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n-        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n-        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n-        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n-        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n-        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n-        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n-        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n-        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n-        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n-        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n-        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n-        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n-        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n-        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n-        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n-        test(String.format(\"%(g\", -12345.6), fmt.\"%(g\\{-12345.6}\");\n-        test(String.format(\"%(g\", 0.0), fmt.\"%(g\\{0.0}\");\n-        test(String.format(\"%(g\", 12345.6), fmt.\"%(g\\{12345.6}\");\n-        test(String.format(\"%(10g\", -12345.6), fmt.\"%(10g\\{-12345.6}\");\n-        test(String.format(\"%(10g\", 0.0), fmt.\"%(10g\\{0.0}\");\n-        test(String.format(\"%(10g\", 12345.6), fmt.\"%(10g\\{12345.6}\");\n-        test(String.format(\"%(-10g\", -12345.6), fmt.\"%(-10g\\{-12345.6}\");\n-        test(String.format(\"%(-10g\", 0.0), fmt.\"%(-10g\\{0.0}\");\n-        test(String.format(\"%(-10g\", 12345.6), fmt.\"%(-10g\\{12345.6}\");\n-        test(String.format(\"%(G\", -12345.6), fmt.\"%(G\\{-12345.6}\");\n-        test(String.format(\"%(G\", 0.0), fmt.\"%(G\\{0.0}\");\n-        test(String.format(\"%(G\", 12345.6), fmt.\"%(G\\{12345.6}\");\n-        test(String.format(\"%(10G\", -12345.6), fmt.\"%(10G\\{-12345.6}\");\n-        test(String.format(\"%(10G\", 0.0), fmt.\"%(10G\\{0.0}\");\n-        test(String.format(\"%(10G\", 12345.6), fmt.\"%(10G\\{12345.6}\");\n-        test(String.format(\"%(-10G\", -12345.6), fmt.\"%(-10G\\{-12345.6}\");\n-        test(String.format(\"%(-10G\", 0.0), fmt.\"%(-10G\\{0.0}\");\n-        test(String.format(\"%(-10G\", 12345.6), fmt.\"%(-10G\\{12345.6}\");\n-        test(String.format(\"%,(g\", -12345.6), fmt.\"%,(g\\{-12345.6}\");\n-        test(String.format(\"%,(g\", 0.0), fmt.\"%,(g\\{0.0}\");\n-        test(String.format(\"%,(g\", 12345.6), fmt.\"%,(g\\{12345.6}\");\n-        test(String.format(\"%,(10g\", -12345.6), fmt.\"%,(10g\\{-12345.6}\");\n-        test(String.format(\"%,(10g\", 0.0), fmt.\"%,(10g\\{0.0}\");\n-        test(String.format(\"%,(10g\", 12345.6), fmt.\"%,(10g\\{12345.6}\");\n-        test(String.format(\"%,(-10g\", -12345.6), fmt.\"%,(-10g\\{-12345.6}\");\n-        test(String.format(\"%,(-10g\", 0.0), fmt.\"%,(-10g\\{0.0}\");\n-        test(String.format(\"%,(-10g\", 12345.6), fmt.\"%,(-10g\\{12345.6}\");\n-        test(String.format(\"%,(G\", -12345.6), fmt.\"%,(G\\{-12345.6}\");\n-        test(String.format(\"%,(G\", 0.0), fmt.\"%,(G\\{0.0}\");\n-        test(String.format(\"%,(G\", 12345.6), fmt.\"%,(G\\{12345.6}\");\n-        test(String.format(\"%,(10G\", -12345.6), fmt.\"%,(10G\\{-12345.6}\");\n-        test(String.format(\"%,(10G\", 0.0), fmt.\"%,(10G\\{0.0}\");\n-        test(String.format(\"%,(10G\", 12345.6), fmt.\"%,(10G\\{12345.6}\");\n-        test(String.format(\"%,(-10G\", -12345.6), fmt.\"%,(-10G\\{-12345.6}\");\n-        test(String.format(\"%,(-10G\", 0.0), fmt.\"%,(-10G\\{0.0}\");\n-        test(String.format(\"%,(-10G\", 12345.6), fmt.\"%,(-10G\\{12345.6}\");\n-        test(String.format(\"%+g\", -12345.6), fmt.\"%+g\\{-12345.6}\");\n-        test(String.format(\"%+g\", 0.0), fmt.\"%+g\\{0.0}\");\n-        test(String.format(\"%+g\", 12345.6), fmt.\"%+g\\{12345.6}\");\n-        test(String.format(\"%+10g\", -12345.6), fmt.\"%+10g\\{-12345.6}\");\n-        test(String.format(\"%+10g\", 0.0), fmt.\"%+10g\\{0.0}\");\n-        test(String.format(\"%+10g\", 12345.6), fmt.\"%+10g\\{12345.6}\");\n-        test(String.format(\"%+-10g\", -12345.6), fmt.\"%+-10g\\{-12345.6}\");\n-        test(String.format(\"%+-10g\", 0.0), fmt.\"%+-10g\\{0.0}\");\n-        test(String.format(\"%+-10g\", 12345.6), fmt.\"%+-10g\\{12345.6}\");\n-        test(String.format(\"%+G\", -12345.6), fmt.\"%+G\\{-12345.6}\");\n-        test(String.format(\"%+G\", 0.0), fmt.\"%+G\\{0.0}\");\n-        test(String.format(\"%+G\", 12345.6), fmt.\"%+G\\{12345.6}\");\n-        test(String.format(\"%+10G\", -12345.6), fmt.\"%+10G\\{-12345.6}\");\n-        test(String.format(\"%+10G\", 0.0), fmt.\"%+10G\\{0.0}\");\n-        test(String.format(\"%+10G\", 12345.6), fmt.\"%+10G\\{12345.6}\");\n-        test(String.format(\"%+-10G\", -12345.6), fmt.\"%+-10G\\{-12345.6}\");\n-        test(String.format(\"%+-10G\", 0.0), fmt.\"%+-10G\\{0.0}\");\n-        test(String.format(\"%+-10G\", 12345.6), fmt.\"%+-10G\\{12345.6}\");\n-        test(String.format(\"%,+g\", -12345.6), fmt.\"%,+g\\{-12345.6}\");\n-        test(String.format(\"%,+g\", 0.0), fmt.\"%,+g\\{0.0}\");\n-        test(String.format(\"%,+g\", 12345.6), fmt.\"%,+g\\{12345.6}\");\n-        test(String.format(\"%,+10g\", -12345.6), fmt.\"%,+10g\\{-12345.6}\");\n-        test(String.format(\"%,+10g\", 0.0), fmt.\"%,+10g\\{0.0}\");\n-        test(String.format(\"%,+10g\", 12345.6), fmt.\"%,+10g\\{12345.6}\");\n-        test(String.format(\"%,+-10g\", -12345.6), fmt.\"%,+-10g\\{-12345.6}\");\n-        test(String.format(\"%,+-10g\", 0.0), fmt.\"%,+-10g\\{0.0}\");\n-        test(String.format(\"%,+-10g\", 12345.6), fmt.\"%,+-10g\\{12345.6}\");\n-        test(String.format(\"%,+G\", -12345.6), fmt.\"%,+G\\{-12345.6}\");\n-        test(String.format(\"%,+G\", 0.0), fmt.\"%,+G\\{0.0}\");\n-        test(String.format(\"%,+G\", 12345.6), fmt.\"%,+G\\{12345.6}\");\n-        test(String.format(\"%,+10G\", -12345.6), fmt.\"%,+10G\\{-12345.6}\");\n-        test(String.format(\"%,+10G\", 0.0), fmt.\"%,+10G\\{0.0}\");\n-        test(String.format(\"%,+10G\", 12345.6), fmt.\"%,+10G\\{12345.6}\");\n-        test(String.format(\"%,+-10G\", -12345.6), fmt.\"%,+-10G\\{-12345.6}\");\n-        test(String.format(\"%,+-10G\", 0.0), fmt.\"%,+-10G\\{0.0}\");\n-        test(String.format(\"%,+-10G\", 12345.6), fmt.\"%,+-10G\\{12345.6}\");\n-        test(String.format(\"%(+g\", -12345.6), fmt.\"%(+g\\{-12345.6}\");\n-        test(String.format(\"%(+g\", 0.0), fmt.\"%(+g\\{0.0}\");\n-        test(String.format(\"%(+g\", 12345.6), fmt.\"%(+g\\{12345.6}\");\n-        test(String.format(\"%(+10g\", -12345.6), fmt.\"%(+10g\\{-12345.6}\");\n-        test(String.format(\"%(+10g\", 0.0), fmt.\"%(+10g\\{0.0}\");\n-        test(String.format(\"%(+10g\", 12345.6), fmt.\"%(+10g\\{12345.6}\");\n-        test(String.format(\"%(+-10g\", -12345.6), fmt.\"%(+-10g\\{-12345.6}\");\n-        test(String.format(\"%(+-10g\", 0.0), fmt.\"%(+-10g\\{0.0}\");\n-        test(String.format(\"%(+-10g\", 12345.6), fmt.\"%(+-10g\\{12345.6}\");\n-        test(String.format(\"%(+G\", -12345.6), fmt.\"%(+G\\{-12345.6}\");\n-        test(String.format(\"%(+G\", 0.0), fmt.\"%(+G\\{0.0}\");\n-        test(String.format(\"%(+G\", 12345.6), fmt.\"%(+G\\{12345.6}\");\n-        test(String.format(\"%(+10G\", -12345.6), fmt.\"%(+10G\\{-12345.6}\");\n-        test(String.format(\"%(+10G\", 0.0), fmt.\"%(+10G\\{0.0}\");\n-        test(String.format(\"%(+10G\", 12345.6), fmt.\"%(+10G\\{12345.6}\");\n-        test(String.format(\"%(+-10G\", -12345.6), fmt.\"%(+-10G\\{-12345.6}\");\n-        test(String.format(\"%(+-10G\", 0.0), fmt.\"%(+-10G\\{0.0}\");\n-        test(String.format(\"%(+-10G\", 12345.6), fmt.\"%(+-10G\\{12345.6}\");\n-        test(String.format(\"%,(+g\", -12345.6), fmt.\"%,(+g\\{-12345.6}\");\n-        test(String.format(\"%,(+g\", 0.0), fmt.\"%,(+g\\{0.0}\");\n-        test(String.format(\"%,(+g\", 12345.6), fmt.\"%,(+g\\{12345.6}\");\n-        test(String.format(\"%,(+10g\", -12345.6), fmt.\"%,(+10g\\{-12345.6}\");\n-        test(String.format(\"%,(+10g\", 0.0), fmt.\"%,(+10g\\{0.0}\");\n-        test(String.format(\"%,(+10g\", 12345.6), fmt.\"%,(+10g\\{12345.6}\");\n-        test(String.format(\"%,(+-10g\", -12345.6), fmt.\"%,(+-10g\\{-12345.6}\");\n-        test(String.format(\"%,(+-10g\", 0.0), fmt.\"%,(+-10g\\{0.0}\");\n-        test(String.format(\"%,(+-10g\", 12345.6), fmt.\"%,(+-10g\\{12345.6}\");\n-        test(String.format(\"%,(+G\", -12345.6), fmt.\"%,(+G\\{-12345.6}\");\n-        test(String.format(\"%,(+G\", 0.0), fmt.\"%,(+G\\{0.0}\");\n-        test(String.format(\"%,(+G\", 12345.6), fmt.\"%,(+G\\{12345.6}\");\n-        test(String.format(\"%,(+10G\", -12345.6), fmt.\"%,(+10G\\{-12345.6}\");\n-        test(String.format(\"%,(+10G\", 0.0), fmt.\"%,(+10G\\{0.0}\");\n-        test(String.format(\"%,(+10G\", 12345.6), fmt.\"%,(+10G\\{12345.6}\");\n-        test(String.format(\"%,(+-10G\", -12345.6), fmt.\"%,(+-10G\\{-12345.6}\");\n-        test(String.format(\"%,(+-10G\", 0.0), fmt.\"%,(+-10G\\{0.0}\");\n-        test(String.format(\"%,(+-10G\", 12345.6), fmt.\"%,(+-10G\\{12345.6}\");\n-\n-        test(String.format(\"%a\", -12345.6), fmt.\"%a\\{-12345.6}\");\n-        test(String.format(\"%a\", 0.0), fmt.\"%a\\{0.0}\");\n-        test(String.format(\"%a\", 12345.6), fmt.\"%a\\{12345.6}\");\n-        test(String.format(\"%10a\", -12345.6), fmt.\"%10a\\{-12345.6}\");\n-        test(String.format(\"%10a\", 0.0), fmt.\"%10a\\{0.0}\");\n-        test(String.format(\"%10a\", 12345.6), fmt.\"%10a\\{12345.6}\");\n-        test(String.format(\"%-10a\", -12345.6), fmt.\"%-10a\\{-12345.6}\");\n-        test(String.format(\"%-10a\", 0.0), fmt.\"%-10a\\{0.0}\");\n-        test(String.format(\"%-10a\", 12345.6), fmt.\"%-10a\\{12345.6}\");\n-        test(String.format(\"%A\", -12345.6), fmt.\"%A\\{-12345.6}\");\n-        test(String.format(\"%A\", 0.0), fmt.\"%A\\{0.0}\");\n-        test(String.format(\"%A\", 12345.6), fmt.\"%A\\{12345.6}\");\n-        test(String.format(\"%10A\", -12345.6), fmt.\"%10A\\{-12345.6}\");\n-        test(String.format(\"%10A\", 0.0), fmt.\"%10A\\{0.0}\");\n-        test(String.format(\"%10A\", 12345.6), fmt.\"%10A\\{12345.6}\");\n-        test(String.format(\"%-10A\", -12345.6), fmt.\"%-10A\\{-12345.6}\");\n-        test(String.format(\"%-10A\", 0.0), fmt.\"%-10A\\{0.0}\");\n-        test(String.format(\"%-10A\", 12345.6), fmt.\"%-10A\\{12345.6}\");\n-\n-        test(\"aaa%false\", fmt.\"aaa%%%b\\{false}\");\n-        test(\"aaa\" + System.lineSeparator() + \"false\", fmt.\"aaa%n%b\\{false}\");\n-\n-        assertThrows(\n-                MissingFormatArgumentException.class,\n-                () -> fmt. \"%10ba\\{ false }\",\n-                \"Format specifier '%10b is not immediately followed by an embedded expression'\");\n-\n-        assertThrows(\n-                MissingFormatArgumentException.class,\n-                () ->fmt. \"%ba\\{ false }\",\n-                \"Format specifier '%b is not immediately followed by an embedded expression'\");\n-\n-        assertThrows(\n-                MissingFormatArgumentException.class,\n-                () ->fmt. \"%b\",\n-                \"Format specifier '%b is not immediately followed by an embedded expression'\");\n-        assertThrows(\n-                UnknownFormatConversionException.class,\n-                () ->fmt. \"%0\",\n-                \"Conversion = '0'\");\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/template\/FormatterBuilder.java","additions":0,"deletions":961,"binary":false,"changes":961,"status":"deleted"},{"patch":"@@ -1,304 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 0000000\n- * @summary Exercise runtime handing of templated strings.\n- * @enablePreview true\n- *\/\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.FilterOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.net.URI;\n-import java.util.*;\n-import java.util.function.Supplier;\n-import javax.tools.FileObject;\n-import javax.tools.ForwardingJavaFileManager;\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import static javax.tools.StandardLocation.CLASS_OUTPUT;\n-import javax.tools.ToolProvider;\n-\n-public class StringTemplateTest {\n-    enum Category{GENERAL, CHARACTER, INTEGRAL, BIG_INT, FLOATING, BIG_FLOAT, DATE};\n-\n-    static final String[] GENERAL = {\"true\", \"false\", \"(Object)null\", \"STR\", \"BO\", \"BOOL\", \"(Boolean)null\"};\n-    static final String[] CHARS = {\"C\", \"CHAR\", \"(Character)null\"};\n-    static final String[] INTS = {\"L\", \"LONG\", \"I\", \"INT\", \"S\", \"SHORT\", \"BY\", \"BYTE\", \"Long.MAX_VALUE\", \"Long.MIN_VALUE\", \"(Long)null\", \"(Integer)null\", \"(Short)null\", \"(Byte)null\"};\n-    static final String[] BIGINTS = {};\n-    static final String[] FLOATS = {\"F\", \"FLOAT\", \"D\", \"DOUBLE\", \"Double.NEGATIVE_INFINITY\", \"Double.NaN\", \"Double.MAX_VALUE\", \"(Double)null\", \"(Float)null\"};\n-    static final String[] BIGFLOATS = {};\n-    static final String[] DATES = {};\n-\n-    final Random r = new Random(1);\n-\n-    String randomValue(Category category) {\n-        return switch (category) {\n-            case GENERAL -> randomChoice(\n-                    GENERAL,\n-                    () -> randomValue(Category.CHARACTER),\n-                    () -> randomValue(Category.INTEGRAL),\n-                    () -> randomValue(Category.BIG_INT),\n-                    () -> randomValue(Category.FLOATING),\n-                    () -> randomValue(Category.BIG_FLOAT),\n-                    () -> randomValue(Category.DATE),\n-                    () -> \"\\\"\" + randomString(r.nextInt(10)) + \"\\\"\");\n-            case CHARACTER -> randomChoice(\n-                    CHARS,\n-                    () -> \"\\'\" + randomString(1) + \"\\'\");\n-            case INTEGRAL -> randomChoice(\n-                    INTS,\n-                    () -> \"(byte)\" + String.valueOf(r.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE)),\n-                    () -> \"(short)\" + String.valueOf(r.nextInt(Short.MIN_VALUE, Short.MAX_VALUE)),\n-                    () -> String.valueOf(r.nextInt()),\n-                    () -> r.nextLong() + \"l\");\n-            case BIG_INT -> randomChoice(\n-                    BIGINTS,\n-                    () -> \"new java.math.BigInteger(\\\"\" + r.nextLong() + \"\\\")\");\n-            case FLOATING -> randomChoice(\n-                    FLOATS,\n-                    () -> String.valueOf(r.nextDouble()),\n-                    () -> r.nextFloat() + \"f\");\n-            case BIG_FLOAT -> randomChoice(\n-                    BIGFLOATS,\n-                    () -> \"new java.math.BigDecimal(\" + r.nextDouble() + \")\");\n-            case DATE -> randomChoice(\n-                    DATES,\n-                    () -> \"new java.util.Date(\" + r.nextLong() + \"l)\",\n-                    () -> r.nextLong() + \"l\");\n-        };\n-    }\n-\n-    String randomChoice(Supplier<String>... suppl) {\n-        return suppl[r.nextInt(suppl.length)].get();\n-    }\n-\n-    String randomChoice(String... values) {\n-        return values[r.nextInt(values.length)];\n-    }\n-\n-    String randomChoice(String[] values, Supplier<String>... suppl) {\n-        int i = r.nextInt(values.length + suppl.length);\n-        return i < values.length ? values[i] : suppl[i - values.length].get();\n-    }\n-\n-    String randomString(int length) {\n-        var sb = new StringBuilder(length << 2);\n-        while (length-- > 0) {\n-            char ch = (char)r.nextInt(9, 128);\n-            var s = switch (ch) {\n-                case '\\t' -> \"\\\\t\";\n-                case '\\'' -> \"\\\\\\'\";\n-                case '\"' -> \"\\\\\\\"\";\n-                case '\\r' -> \"\\\\r\";\n-                case '\\\\' -> \"\\\\\\\\\";\n-                case '\\n' -> \"\\\\n\";\n-                case '\\f' -> \"\\\\f\";\n-                case '\\b' -> \"\\\\b\";\n-                default -> ch + \"\";\n-            };\n-            sb.append(s);\n-        }\n-        return sb.toString();\n-    }\n-\n-    String randomFormat(Category category) {\n-        char c;\n-        return \"%\" + switch (category) {\n-            case GENERAL -> randomWidth(\"-\") + randomPrecision() + randomChar(\"bBhHsS\");\n-            case CHARACTER -> randomWidth(\"-\") + randomChar(\"cC\");\n-            case INTEGRAL -> switch (c = randomChar(\"doxX\")) {\n-                case 'd' -> randomFlags(\"+ ,(\");\n-                default -> randomFlags(\"\");\n-            } + randomWidth(\"-0\") + c;\n-            case BIG_INT -> switch (c = randomChar(\"doxX\")) {\n-                case 'd' -> randomFlags(\"+ ,(\");\n-                default -> randomFlags(\"+ (\");\n-            } + randomWidth(\"-0\") + c;\n-            case FLOATING -> switch (c = randomChar(\"eEfaAgG\")) {\n-                case 'a', 'A' -> randomFlags(\"+ \") + randomWidth(\"-0\");\n-                case 'e', 'E' -> randomFlags(\"+ (\") + randomWidth(\"-0\") + randomPrecision();\n-                default -> randomFlags(\"+ ,(\") + randomWidth(\"-0\") + randomPrecision();\n-            } + c;\n-            case BIG_FLOAT -> switch (c = randomChar(\"eEfgG\")) {\n-                case 'e', 'E' -> randomFlags(\"+ (\") + randomWidth(\"-0\") + randomPrecision();\n-                default -> randomFlags(\"+ ,(\") + randomWidth(\"-0\") + randomPrecision();\n-            } + c;\n-            case DATE ->  randomWidth(\"-\") + randomChar(\"tT\") + randomChar(\"BbhAaCYyjmdeRTrDFc\");\n-        };\n-    }\n-\n-    String randomFlags(String flags) {\n-        var sb = new StringBuilder(flags.length());\n-        for (var f : flags.toCharArray()) {\n-            if (r.nextBoolean() && (f != ' ' || sb.length() == 0 || sb.charAt(sb.length() - 1) != '+')) sb.append(f);\n-        }\n-        return sb.toString();\n-    }\n-\n-    char randomChar(String chars) {\n-        return chars.charAt(r.nextInt(chars.length()));\n-    }\n-\n-    String randomWidth(String flags) {\n-        var f = r.nextInt(flags.length() + 1);\n-        return r.nextBoolean() ? (r.nextBoolean() ? flags.charAt(r.nextInt(flags.length())) : \"\") + String.valueOf(r.nextInt(10) + 1) : \"\";\n-    }\n-\n-    String randomPrecision() {\n-        return r.nextBoolean() ? '.' + String.valueOf(r.nextInt(10) + 1) : \"\";\n-    }\n-\n-    public Class<?> compile() throws Exception {\n-        var classes = new HashMap<String, byte[]>();\n-        var fileManager = new ForwardingJavaFileManager(ToolProvider.getSystemJavaCompiler().getStandardFileManager(null, null, null)) {\n-            @Override\n-            public ClassLoader getClassLoader(JavaFileManager.Location location) {\n-                return new ClassLoader() {\n-                    @Override\n-                    public Class<?> loadClass(String name) throws ClassNotFoundException {\n-                        try {\n-                            return super.loadClass(name);\n-                        } catch (ClassNotFoundException e) {\n-                            byte[] classData = classes.get(name);\n-                            return defineClass(name, classData, 0, classData.length);\n-                        }\n-                    }\n-                };\n-            }\n-            @Override\n-            public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String name, JavaFileObject.Kind kind, FileObject originatingSource) throws UnsupportedOperationException {\n-                return new SimpleJavaFileObject(URI.create(name + \".class\"), JavaFileObject.Kind.CLASS) {\n-                    @Override\n-                    public OutputStream openOutputStream() {\n-                        return new FilterOutputStream(new ByteArrayOutputStream()) {\n-                            @Override\n-                            public void close() throws IOException {\n-                                classes.put(name, ((ByteArrayOutputStream)out).toByteArray());\n-                            }\n-                        };\n-                    }\n-                };\n-            }\n-        };\n-        var source = genSource();\n-\/\/        System.out.println(source);\n-        if (ToolProvider.getSystemJavaCompiler().getTask(null, fileManager, null,\n-                List.of(\"--enable-preview\", \"-source\", String.valueOf(Runtime.version().feature())), null,\n-                List.of(SimpleJavaFileObject.forSource(URI.create(\"StringTemplateTest$.java\"), source))\n-           ).call()) {\n-            return fileManager.getClassLoader(CLASS_OUTPUT).loadClass(\"StringTemplateTest$\");\n-        } else {\n-            throw new AssertionError(\"compilation failed\");\n-        }\n-    }\n-\n-    String genFragments(Category c) {\n-        var fragments = new LinkedList<String>();\n-        for (int i = 0; i < 1500; i++) {\n-            var format = randomFormat(c);\n-            var value = randomValue(c);\n-            var qValue = value.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\");\n-            fragments.add(STR.\"test(FMT.\\\"\\{format}\\\\{\\{value}}\\\", \\\"\\{format}\\\", \\\"\\{qValue}\\\", \\{value}, log);\");\n-        }\n-        return String.join(\"\\n        \", fragments);\n-    }\n-\n-    String genSource() {\n-        return STR.\"\"\"\n-            import java.util.FormatProcessor;\n-            import java.util.Locale;\n-\n-            public class StringTemplateTest$ {\n-                static final FormatProcessor FMT = FormatProcessor.create(Locale.US);\n-                static String STR = \"this is static String\";\n-                static char C = 'c';\n-                static Character CHAR = 'C';\n-                static long L = -12345678910l;\n-                static Long LONG = 9876543210l;\n-                static int I = 42;\n-                static Integer INT = -49;\n-                static boolean BO = true;\n-                static Boolean BOOL = false;\n-                static short S = 13;\n-                static Short SHORT = -17;\n-                static byte BY = -3;\n-                static Byte BYTE = 12;\n-                static float F = 4.789f;\n-                static Float FLOAT = -0.000006f;\n-                static double D = 6545745.6734654563;\n-                static Double DOUBLE = -4323.7645676574;\n-\n-                public static void run(java.util.List<String> log) {\n-                    runGeneral(log);\n-                    runCharacter(log);\n-                    runIntegral(log);\n-                    runBigInt(log);\n-                    runFloating(log);\n-                    runBigFloat(log);\n-                    runDate(log);\n-                }\n-                public static void runGeneral(java.util.List<String> log) {\n-                    \\{genFragments(Category.GENERAL)}\n-                }\n-                public static void runCharacter(java.util.List<String> log) {\n-                    \\{genFragments(Category.CHARACTER)}\n-                }\n-                public static void runIntegral(java.util.List<String> log) {\n-                    \\{genFragments(Category.INTEGRAL)}\n-                }\n-                public static void runBigInt(java.util.List<String> log) {\n-                    \\{genFragments(Category.BIG_INT)}\n-                }\n-                public static void runFloating(java.util.List<String> log) {\n-                    \\{genFragments(Category.FLOATING)}\n-                }\n-                public static void runBigFloat(java.util.List<String> log) {\n-                    \\{genFragments(Category.BIG_FLOAT)}\n-                }\n-                public static void runDate(java.util.List<String> log) {\n-                    \\{genFragments(Category.DATE)}\n-                }\n-                static void test(String fmt, String format, String expression, Object value, java.util.List<String> log) {\n-                    var formatted = String.format(java.util.Locale.US, format, value);\n-                    if (!fmt.equals(formatted)) {\n-                        log.add(\"  format: '%s' expression: '%s' value: '%s' expected: '%s' found: '%s'\".formatted(format, expression, value, formatted, fmt));\n-                    }\n-                }\n-            }\n-            \"\"\";\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        var log = new LinkedList<String>();\n-        new StringTemplateTest().compile().getMethod(\"run\", List.class).invoke(null, log);\n-        if (!log.isEmpty()) {\n-            log.forEach(System.out::println);\n-            throw new AssertionError(STR.\"failed \\{log.size()} tests\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/template\/StringTemplateTest.java","additions":0,"deletions":304,"binary":false,"changes":304,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8313809\n- * @summary String template fails with java.lang.StringIndexOutOfBoundsException if last fragment is UTF16\n-.\n- * @enablePreview true\n- *\/\n-\n-import static java.util.FormatProcessor.FMT;\n-\n-public class T8313809 {\n-    public static void main(final String[] args) throws Exception {\n-        double sum = 12.34;\n-        final String message = FMT.\"The sum is : %f\\{sum} €\"; \/\/ this fails\n-        if (!message.equals(\"The sum is : 12.340000 €\")) {\n-            throw new RuntimeException(\"Incorrect result\");\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/java\/lang\/template\/T8313809.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -92,2 +92,1 @@\n-        \"record.length()\",\n-        \"\\\"\\\\{0}\\\"\"\n+        \"record.length()\"\n@@ -238,4 +237,1 @@\n-        \"\\\"\\\\\",\n-        \"\\\"\\\\{\",\n-        \"\\\"\\\\{0\",\n-        \"\\\"\\\\{0}\",\n+        \"\\\"\\\\\"\n@@ -387,3 +383,0 @@\n-        assertStatus(\"\\\"\\\"\\\"\\n\\\\{\", DEFINITELY_INCOMPLETE, null);\n-        assertStatus(\"\\\"\\\"\\\"\\n\\\\{0\", DEFINITELY_INCOMPLETE, null);\n-        assertStatus(\"\\\"\\\"\\\"\\n\\\\{0}\", DEFINITELY_INCOMPLETE, null);\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -327,1 +327,2 @@\n-                \"String String.format(java.util.Locale, String, Object...)\");\n+                \"String String.format(java.util.Locale, String, Object...)\"\n+                );\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.misc.feature.string.templates\n- \/\/ key: compiler.warn.preview.feature.use.plural\n- \/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n-\n-class StringTemplate {\n-    String m() {\n-        int x = 10, y = 20;\n-        return STR.\"\\{x} + \\{y} = \\{x + y}\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplate.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.err.processor.missing.from.string.template.expression\n- \/\/ key: compiler.misc.feature.string.templates\n- \/\/ key: compiler.warn.preview.feature.use.plural\n- \/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n-\n-class StringTemplateNoProcessor {\n-    String m() {\n-        int x = 10, y = 20;\n-        return \"\\{x} + \\{y} = \\{x + y}\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateNoProcessor.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.err.cant.resolve.location.args\n- \/\/ key: compiler.misc.location\n- \/\/ key: compiler.note.preview.recompile\n- \/\/ key: compiler.err.not.a.processor.type\n- \/\/ options: --enable-preview  -source ${jdk.version}\n-\n-import java.lang.*;\n-\n-class StringTemplateNotProcessor {\n-    String m() {\n-        String processor = \"\";\n-        int x = 10, y = 20;\n-        return processor.\"\\{x} + \\{y} = \\{x + y}\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateNotProcessor.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n- \/\/ key: compiler.misc.unexpected.ret.val\n- \/\/ key: compiler.err.prob.found.req\n- \/\/ options: --enable-preview -source ${jdk.version}\n-\n-import java.lang.*;\n-import java.lang.StringTemplate.Processor;\n-\n-class StringTemplateRawProcessor {\n-    void m() {\n-        Processor processor = ts -> ts.interpolate();\n-        try {\n-            int x = 10, y = 20;\n-            return processor.\"\\{x} + \\{y} = \\{x + y}\";\n-        } catch (Throwable x) {\n-            throw new RuntimeException(x);\n-        }\n-    }\n-}\n-\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateRawProcessor.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n- \/\/ key: compiler.err.unclosed.str.lit\n- \/\/ key: compiler.err.string.template.is.not.well.formed\n- \/\/ options: --enable-preview -source ${jdk.version}\n-\n-import java.lang.*;\n-\n-class StringTemplateUnclosedString {\n-    String m() {\n-        int x = 10;\n-        return STR.\"\\{x\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateUnclosedString.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n- \/\/ key: compiler.err.unclosed.text.block\n- \/\/ key: compiler.err.text.block.template.is.not.well.formed\n- \/\/ key: compiler.err.premature.eof\n- \/\/ options: --enable-preview -source ${jdk.version}\n-\n-import java.lang.*;\n-\n-class StringTemplateUnclosedTextBlock {\n-    String m() {\n-        int x = 10;\n-        return STR.\"\"\"\n-                aaa\n-                \\{x\n-                \"\"\"\n-        ;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateUnclosedTextBlock.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1920,46 +1920,0 @@\n-    @Test\n-    void testStringTemplate1() throws IOException {\n-        String code = \"\"\"\n-                      package test;\n-                      public class Test {\n-                           Test(int a) {\n-                               String s = \"prefix \\\\{a} suffix\";\n-                           }\n-                      }\n-                      \"\"\";\n-\n-        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,\n-                null, null, Arrays.asList(new MyFileObject(code)));\n-        CompilationUnitTree cut = ct.parse().iterator().next();\n-        ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);\n-        MethodTree constr = (MethodTree) clazz.getMembers().get(0);\n-        VariableTree decl = (VariableTree) constr.getBody().getStatements().get(0);\n-        SourcePositions sp = Trees.instance(ct).getSourcePositions();\n-        int initStart = (int) sp.getStartPosition(cut, decl.getInitializer());\n-        int initEnd   = (int) sp.getEndPosition(cut, decl.getInitializer());\n-        assertEquals(\"correct templated String span expected\", code.substring(initStart, initEnd), \"\\\"prefix \\\\{a} suffix\\\"\");\n-    }\n-\n-    @Test\n-    void testStringTemplate2() throws IOException {\n-        String code = \"\"\"\n-                      package test;\n-                      public class Test {\n-                           Test(int a) {\n-                               String s = STR.\"prefix \\\\{a} suffix\";\n-                           }\n-                      }\n-                      \"\"\";\n-\n-        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,\n-                null, null, Arrays.asList(new MyFileObject(code)));\n-        CompilationUnitTree cut = ct.parse().iterator().next();\n-        ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);\n-        MethodTree constr = (MethodTree) clazz.getMembers().get(0);\n-        VariableTree decl = (VariableTree) constr.getBody().getStatements().get(0);\n-        SourcePositions sp = Trees.instance(ct).getSourcePositions();\n-        int initStart = (int) sp.getStartPosition(cut, decl.getInitializer());\n-        int initEnd   = (int) sp.getEndPosition(cut, decl.getInitializer());\n-        assertEquals(\"correct templated String span expected\", code.substring(initStart, initEnd), \"STR.\\\"prefix \\\\{a} suffix\\\"\");\n-    }\n-\n@@ -2047,57 +2001,0 @@\n-    @Test\n-    void testIncompleteStringTemplate() throws IOException {\n-        String template = \"\\\"\\\\{o.toString()}\\\"\";\n-        String prefix = \"\"\"\n-                      package t;\n-                      class Test {\n-                          void test(Object o) {\n-                              String s = STR.\"\"\";\n-\n-        Worker<Void> verifyParseable = task -> {\n-            try {\n-                task.parse().iterator().next();\n-                return null;\n-            } catch (IOException ex) {\n-                throw new AssertionError(ex);\n-            }\n-        };\n-        JavacTaskPool pool = new JavacTaskPool(1);\n-        DiagnosticListener<JavaFileObject> dl = d -> {};\n-        List<String> options = List.of(\"--enable-preview\",\n-                                       \"-source\", System.getProperty(\"java.specification.version\"));\n-        for (int i = 0; i < template.length(); i++) {\n-            pool.getTask(null, fm, dl, options,\n-                    null, Arrays.asList(new MyFileObject(prefix + template.substring(0, i))),\n-                    verifyParseable\n-            );\n-        }\n-        for (int i = 0; i < template.length() - 1; i++) {\n-            pool.getTask(null, fm, dl, options,\n-                    null, Arrays.asList(new MyFileObject(prefix + template.substring(0, i) + \"\\\"\")),\n-                    verifyParseable);\n-        }\n-        String incomplete = prefix + \"\\\"\\\\{o.\";\n-        pool.getTask(null, fm, dl, options,\n-                null, Arrays.asList(new MyFileObject(incomplete)), task -> {\n-            try {\n-                CompilationUnitTree cut = task.parse().iterator().next();\n-                String result = cut.toString().replaceAll(\"\\\\R\", \"\\n\");\n-                System.out.println(\"RESULT\\n\" + result);\n-                assertEquals(\"incorrect AST\",\n-                             result,\n-                             \"\"\"\n-                             package t;\n-                             \\n\\\n-                             class Test {\n-                                 \\n\\\n-                                 void test(Object o) {\n-                                     String s = STR.<error>;\n-                                 }\n-                             }\"\"\");\n-                return null;\n-            } catch (IOException ex) {\n-                throw new AssertionError(ex);\n-            }\n-        });\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -1,240 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 0000000\n- * @summary Exercise javac handing of templated strings.\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- * @build toolbox.ToolBox toolbox.JavacTask\n- * @run main Basic\n- *\/\n-\n-\n-import toolbox.JavacTask;\n-import toolbox.JavaTask;\n-import toolbox.Task;\n-import toolbox.ToolBox;\n-\n-public class Basic {\n-    private static ToolBox TOOLBOX = new ToolBox();\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n-    public static void main(String... arg) {\n-        primitivesTest();\n-        missingPartsTest();\n-        expressionsTest();\n-        invalidExpressionsTest();\n-        processorTest();\n-    }\n-\n-    \/*\n-     * Primitive types test.\n-     *\/\n-    static void primitivesTest() {\n-        for (String type : new String[] {\n-            \"byte\",\n-            \"short\",\n-            \"int\",\n-            \"long\",\n-            \"float\",\n-            \"double\"\n-        }) {\n-            compPass(type + \" x = 10; \" + type + \"  y = 20; StringTemplate result = RAW.\\\"\\\\{x} + \\\\{y} = \\\\{x + y}\\\";\");\n-        }\n-    }\n-\n-    \/*\n-     * Missing parts test.\n-     *\/\n-    static void missingPartsTest() {\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{x\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{{x}\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{x + }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ * x }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ (x + x }\";\n-        \"\"\");\n-    }\n-\n-    \/*\n-     * Expressions test.\n-     *\/\n-    static void expressionsTest() {\n-        compPass(\"\"\"\n-            int x = 10;\n-            int[] y = new int[] { 10, 20, 30 };\n-            StringTemplate result1 = RAW.\"\\\\{x + 1}\";\n-            StringTemplate result2 = RAW.\"\\\\{x + x}\";\n-            StringTemplate result3 = RAW.\"\\\\{x - x}\";\n-            StringTemplate result4 = RAW.\"\\\\{x * x}\";\n-            StringTemplate result5 = RAW.\"\\\\{x \/ x}\";\n-            StringTemplate result6 = RAW.\"\\\\{x % x}\";\n-            StringTemplate result7 = RAW.\"\\\\{x + (x + x)}\";\n-            StringTemplate result8 = RAW.\"\\\\{y[x - 9]}\";\n-            StringTemplate result9 = RAW.\"\\\\{System.out}\";\n-            StringTemplate result10 = RAW.\\\"\"\"\n-                    \\\\{ \"a string\" }\n-                    \\\"\"\";\n-                    \"\"\");\n-        compPass(\"\"\"\n-            StringTemplate result = RAW.\\\"\"\"\n-                 \\\\{\n-                     new Collection<String>() {\n-                          @Override public int size() { return 0; }\n-                          @Override public boolean isEmpty() { return false; }\n-                          @Override public boolean contains(Object o) { return false; }\n-                          @Override public Iterator<String> iterator() { return null; }\n-                          @Override public Object[] toArray() { return new Object[0]; }\n-                          @Override public <T> T[] toArray(T[] a) { return null; }\n-                          @Override public boolean add(String s) { return false; }\n-                          @Override public boolean remove(Object o) { return false; }\n-                          @Override public boolean containsAll(Collection<?> c) { return false; }\n-                          @Override public boolean addAll(Collection<? extends String> c) { return false; }\n-                          @Override public boolean removeAll(Collection<?> c) { return false; }\n-                          @Override public boolean retainAll(Collection<?> c) { return false; }\n-                          @Override public void clear() { }\n-                      }\n-                 }\n-                 \\\"\"\";\n-         \"\"\");\n-    }\n-\n-    \/*\n-     * Invalid expressions test.\n-     *\/\n-    static void invalidExpressionsTest() {\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ (x == x }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ true ?  : x - 1 }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-             String result = RAW.\"\\\\{ 'a }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ Math.min(, x - 1) }\";\n-        \"\"\");\n-        compFail(\"\"\"\n-            int x = 10;\n-            StringTemplate result = RAW.\"\\\\{ \\\\tx }\";\n-        \"\"\");\n-    }\n-\n-    \/*\n-     * Processor test.\n-     *\/\n-    static void processorTest() {\n-        compPass(\"\"\"\n-         int x = 10, y = 20;\n-         String string = STR.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n-         \"\"\");\n-        compFail(\"\"\"\n-         int x = 10, y = 20;\n-         String processor = \"abc\";\n-         String string = processor.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n-         \"\"\");\n-        compFail(\"\"\"\n-         int x = 10, y = 20;\n-         long processor = 100;\n-         String string = processor.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n-         \"\"\");\n-    }\n-\n-    \/*\n-     * Test source for successful compile.\n-     *\/\n-    static void compPass(String code) {\n-        String source = \"\"\"\n-            import java.lang.*;\n-            import java.util.*;\n-            import static java.lang.StringTemplate.RAW;\n-            public class TEST {\n-                public static void main(String... arg) {\n-            \"\"\" +\n-            code.indent(8) +\n-            \"\"\"\n-                }\n-            }\n-            \"\"\";\n-        String output = new JavacTask(TOOLBOX)\n-                .sources(source)\n-                .classpath(\".\")\n-                .options(\"-encoding\", \"utf8\", \"--enable-preview\", \"-source\", JAVA_VERSION)\n-                .run()\n-                .writeAll()\n-                .getOutput(Task.OutputKind.DIRECT);\n-\n-        if (output.contains(\"compiler.err\")) {\n-            throw new RuntimeException(\"Error detected\");\n-        }\n-    }\n-\n-    \/*\n-     * Test source for unsuccessful compile and specific error.\n-     *\/\n-    static void compFail(String code) {\n-        String source = \"\"\"\n-            import java.lang.*;\n-            import java.util.*;\n-            import static java.lang.StringTemplate.RAW;\n-            public class TEST {\n-                public static void main(String... arg) {\n-            \"\"\" +\n-            code.indent(8) +\n-            \"\"\"\n-                }\n-            }\n-            \"\"\";\n-        String errors = new JavacTask(TOOLBOX)\n-                .sources(source)\n-                .classpath(\".\")\n-                .options(\"-XDrawDiagnostics\", \"-encoding\", \"utf8\", \"--enable-preview\", \"-source\", JAVA_VERSION)\n-                .run(Task.Expect.FAIL)\n-                .writeAll()\n-                .getOutput(Task.OutputKind.DIRECT);\n-\n-        if (!errors.contains(\"compiler.err\")) {\n-            throw new RuntimeException(\"No error detected\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/template\/Basic.java","additions":0,"deletions":240,"binary":false,"changes":240,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test T8312814\n- * @summary Verify proper behavior of TransType w.r.t. templated Strings\n- * @enablePreview\n- * @compile T8312814.java\n- *\/\n-\n-\n-import java.util.List;\n-\n-public class T8312814 {\n-    void x(List<? extends StringTemplate.Processor<String, RuntimeException>> list) {\n-        list.get(0).\"\";\n-    }\n-}\n-\n","filename":"test\/langtools\/tools\/javac\/template\/T8312814.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify proper behavior of TreeScanner w.r.t. templated Strings\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.*;\n-import java.util.*;\n-import javax.tools.*;\n-import com.sun.source.tree.*;\n-import com.sun.source.util.*;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-\n-public class TreeScannerTest {\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n-    public static void main(String... args) throws Exception {\n-        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n-        String code = \"\"\"\n-                      public class Test {\n-                          private void test(int a) {\n-                              String s1 = TEST.\"p\\\\{a}s\";\n-                              String s2 = \"p\\\\{a}s\";\n-                          }\n-                      }\n-                      \"\"\";\n-        JavacTask task = (JavacTask) compiler.getTask(null, null, null,\n-            List.of(\"--enable-preview\", \"-source\", JAVA_VERSION), null, List.of(new TestJFO(code)));\n-        StringBuilder output = new StringBuilder();\n-        TreeScanner<Void,Void> checker = new TreeScanner<Void, Void>() {\n-            private boolean log;\n-\n-            @Override\n-            public Void visitStringTemplate(StringTemplateTree node, Void p) {\n-                boolean prevLog = log;\n-                try {\n-                    log = true;\n-                    return super.visitStringTemplate(node, p);\n-                } finally {\n-                    log = prevLog;\n-                }\n-            }\n-\n-            @Override\n-            public Void scan(Tree tree, Void p) {\n-                if (log) {\n-                    output.append(\"(\");\n-                    output.append(tree != null ? tree.getKind() : \"null\");\n-                    try {\n-                        return super.scan(tree, p);\n-                    } finally {\n-                        output.append(\")\");\n-                    }\n-                } else {\n-                    return super.scan(tree, p);\n-                }\n-            }\n-\n-        };\n-\n-        checker.scan(task.parse(), null);\n-\n-        String expected = \"(IDENTIFIER)(IDENTIFIER)(null)(IDENTIFIER)\";\n-        if (!expected.equals(output.toString())) {\n-            throw new AssertionError(\"expected output not found, found: \" + output);\n-        }\n-    }\n-\n-    private static final class TestJFO extends SimpleJavaFileObject {\n-        private final String code;\n-\n-        public TestJFO(String code) throws URISyntaxException, IOException {\n-            super(new URI(\"mem:\/\/Test.java\"), Kind.SOURCE);\n-            this.code = code;\n-        }\n-\n-        @Override\n-        public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-            return code;\n-        }\n-\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/template\/TreeScannerTest.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -126,4 +126,0 @@\n-            case TEMPLATE:\n-                ok = ok & verify(k, i, i == StringTemplateTree.class);\n-                break;\n-\n","filename":"test\/langtools\/tools\/javac\/tree\/TreeKindTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-                                \"java.base\/jdk.internal.javac\",\n","filename":"test\/langtools\/tools\/jdeps\/listdeps\/ListModuleDeps.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.util.FormatProcessor.FMT;\n-\n-\/*\n- * This benchmark measures StringTemplate.FMT FormatProcessor performance;\n- * exactly mirroring {@link org.openjdk.bench.java.lang.StringFormat} benchmark\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n-public class StringTemplateFMT {\n-\n-    public String s = \"str\";\n-    public int i = 17;\n-\n-    @Benchmark\n-    public String stringFormat() {\n-        return FMT.\"%s\\{s}\";\n-    }\n-\n-    @Benchmark\n-    public String stringIntFormat() {\n-        return FMT.\"%s\\{s} %d\\{i}\";\n-    }\n-\n-    @Benchmark\n-    public String widthStringFormat() {\n-        return FMT.\"%3s\\{s}\";\n-    }\n-\n-    @Benchmark\n-    public String widthStringIntFormat() {\n-        return FMT.\"%3s\\{s} %d\\{i}\";\n-    }\n-\n-    @Benchmark\n-    public String complexFormat() {\n-        return FMT.\"%3s\\{s} %10d\\{i} %4S\\{s} %04X\\{i} %4S\\{s} %04X\\{i} %4S\\{s} %04X\\{i}\";\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringTemplateFMT.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"}]}