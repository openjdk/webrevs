{"files":[{"patch":"@@ -3512,0 +3512,13 @@\n+void Assembler::vmovdqa(Address dst, XMMRegister src) {\n+  assert(UseAVX > 0, \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_256bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.reset_is_clear_context();\n+  \/\/ swap src<->dst for encoding\n+  assert(src != xnoreg, \"sanity\");\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x7F);\n+  emit_operand(src, dst, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1760,0 +1760,1 @@\n+  void vmovdqa(Address dst, XMMRegister src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2024, 2025, Intel Corporation. All rights reserved.\n@@ -286,0 +286,7 @@\n+ * Use vpmadd52{l,h}uq multiply for upper four limbs and use\n+ * scalar mulq for the lowest limb.\n+ *\n+ * One has to be careful with mulq vs vpmadd52 'crossovers'; mulq high\/low\n+ * is split as 40:64 bits vs 52:52 in the vector version. Shifts are required\n+ * to line up values before addition (see following ascii art)\n+ *\n@@ -302,0 +309,2 @@\n+ *                                                     |a5|a4|a3|a2|  |a1|\n+ *          Acc1 += A *  B                            *|bi|bi|bi|bi|  |bi|\n@@ -303,2 +312,0 @@\n- *                                                    *|a5|a4|a3|a2|  |a1|\n- *          Acc1 += A *  B                             |bi|bi|bi|bi|  |bi|\n@@ -306,3 +313,3 @@\n- *                                               Acc2+=| 0| 0| 0| 0|  | 0|\n- *                                                   *h|a5|a4|a3|a2|  |a1|\n- *          Acc2 += A *h B                             |bi|bi|bi|bi|  |bi|\n+ *                                                     |a5|a4|a3|a2|  |a1|\n+ *          Acc2 += A *h B                           *h|bi|bi|bi|bi|  |bi|\n+ *                                               Acc2+=|d5|d4|d3|d2|  |d1|\n@@ -313,3 +320,3 @@\n- *                                               Acc1+=|c5|c4|c3|c2|  |c1|\n- *                                                    *|m5|m4|m3|m2|  |m1|\n- *          Acc1 += M *  N                             |n0|n0|n0|n0|  |n0| Note: 52 low bits of acc1== 0 due to Montgomery!\n+ *                                                     |m5|m4|m3|m2|  |m1|\n+ *          Acc1 += M *  N                            *|n0|n0|n0|n0|  |n0|\n+ *                                               Acc1+=|c5|c4|c3|c2|  |c1| Note: 52 low bits of c1 == 0 due to Montgomery!\n@@ -317,0 +324,2 @@\n+ *                                                     |m5|m4|m3|m2|  |m1|\n+ *          Acc2 += M *h N                           *h|n0|n0|n0|n0|  |n0|\n@@ -318,2 +327,0 @@\n- *                                                   *h|m5|m4|m3|m2|  |m1|\n- *          Acc2 += M *h N                             |n0|n0|n0|n0|  |n0|\n@@ -321,1 +328,0 @@\n- *          if (i == 4) break;\n@@ -323,4 +329,5 @@\n- *                                                     +--+--+--+--+  +--+\n- *          carry = Acc1[0] >> 52                      | 0| 0| 0| 0|  |c1|\n- *                                                     +--+--+--+--+  +--+\n- *          Acc2[0] += carry\n+ *                                                                    +--+\n+ *          carry = Acc1[0] >> 52                                     |c1|\n+ *                                                                    +--+\n+ *          Acc2[0] += carry                                          |d1|\n+ *                                                                    +--+\n@@ -329,0 +336,2 @@\n+ *                                                    +|d5|d4|d3|d2|  |d1|\n+ *          Acc1 = Acc1 + Acc2                   Acc1+=|c5|c4|c3|c2|  |c1|\n@@ -330,1 +339,0 @@\n- *          Acc1 = Acc1 + Acc2\n@@ -332,4 +340,17 @@\n- *\n- * At this point the result in Acc1 can overflow by 1 Modulus and needs carry\n- * propagation. Subtract one modulus, carry-propagate both results and select\n- * (constant-time) the positive number of the two\n+ *                                                     +--+--+--+--+  +--+\n+ *   Acc2 = Acc1 - M                                   |d5|d4|d3|d2|  |d1|\n+ *                                                     +--+--+--+--+  +--+\n+ *   Carry propagate Acc2\n+ *   Carry propagate Acc1\n+ *   Mask = sign(Acc2)\n+ *   Result = Mask\n+ * \n+ * Acc1 can overflow by one modulus (hence Acc2); Either Acc1 or Acc2 contain\n+ * the correct result. However, they both need carry propagation (i.e. normalize\n+ * limbs down to 52 bits each).\n+ * \n+ * Carry propagation would require relatively expensive vector lane operations,\n+ * so instead dump to memory and read as scalar registers\n+ * \n+ * Note: the order of reduce-then-propagate vs propagate-then-reduce is different\n+ * in Java\n@@ -395,0 +416,1 @@\n+        \/\/ Careful with limb size\/carries; from mulq, tmp_rax uses full 64 bits\n@@ -407,1 +429,1 @@\n-      __ movq(N, acc1); \/\/ masking implicit in evpmadd52\n+      __ movq(N, acc1); \/\/ masking implicit in vpmadd52\n@@ -441,1 +463,1 @@\n-  __ vmovdqu(Address(rsp, -32), Acc2); \/\/Assembler::AVX_256bit\n+  __ vmovdqa(Address(rsp, 0), Acc2); \/\/Assembler::AVX_256bit\n@@ -443,5 +465,5 @@\n-  \/\/ Carry propagate the subtraction result first (since the last carry is used\n-  \/\/ to select result)\n-  \/\/ acc1  = tmp2;\n-  \/\/ acc2  = tmp3;\n-  \/\/ mask52 = tmp5\n+  \/\/ Carry propagate the subtraction result Acc2 first (since the last carry is \n+  \/\/ used to select result). Careful, following registers overlap:\n+  \/\/ acc1  = tmp2; acc2  = tmp3; mask52 = tmp5\n+  \/\/ Note that Acc2 limbs are signed (i.e. result of a subtract with modulus)\n+  \/\/ i.e. using signed shift is needed for correctness\n@@ -452,1 +474,1 @@\n-      __ movq(limb[i], Address(rsp, -32-8+i*8));\n+      __ movq(limb[i], Address(rsp, -8+i*8));\n@@ -467,1 +489,1 @@\n-  __ vmovdqu(Address(rsp, -64), Acc1); \/\/Assembler::AVX_256bit\n+  __ vmovdqa(Address(rsp, 0), Acc1); \/\/Assembler::AVX_256bit\n@@ -471,1 +493,1 @@\n-      __ movq(digit, Address(rsp, -64-8+i*8));\n+      __ movq(digit, Address(rsp, -8+i*8));\n@@ -491,2 +513,1 @@\n-  __ vmovdqu(Address(rsp, -32), Acc1); \/\/Assembler::AVX_256bit\n-  __ vmovdqu(Address(rsp, -64), Acc1); \/\/Assembler::AVX_256bit\n+  __ vmovdqa(Address(rsp, 0), Acc1); \/\/Assembler::AVX_256bit\n@@ -509,0 +530,4 @@\n+    __ push(rbp);\n+    __ movq(rbp, rsp);\n+  __ andq(rsp, -32);\n+  __ subptr(rsp, 32);\n@@ -530,0 +555,3 @@\n+\n+    __ movq(rsp, rbp);\n+    __ pop(rbp);\n@@ -566,0 +594,3 @@\n+  \/\/ Original java:\n+  \/\/ long dummyLimbs = maskValue & (a[i] ^ b[i]);\n+  \/\/ a[i] = dummyLimbs ^ a[i];\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":64,"deletions":33,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025 Oracle and\/or its affiliates. All rights reserved.\n@@ -395,0 +395,1 @@\n+        \/\/ Final carry propagate\n@@ -406,1 +407,4 @@\n-        \/\/ At this point, the result could overflow by one modulus.\n+        \/\/ At this point, the result {c5, c6, c7, c8, c9} could overflow by\n+        \/\/ one modulus. Subtract one modulus (with carry propagation), into\n+        \/\/ {c0, c1, c2, c3, c4}. Note that in this calculation, limbs are\n+        \/\/ signed\n@@ -417,2 +421,7 @@\n-        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n-\n+        \/\/ We now must select a result that is in range of [0,modulus). i.e.\n+        \/\/ either {c0-4} or {c5-9}. `If statements` are not allowed here, so use\n+        \/\/ boolean algebra (i.e. a mask). If statement would had been `if {c0-4}\n+        \/\/ is negative`, which essentially means 'what is the sign bit of c4'\n+        \/\/ A signed shift is the easiest way to broadcast c4-sign-bit into a\n+        \/\/ mask\n+        long mask = c4 >> BITS_PER_LIMB;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2024, 2025, Intel Corporation. All rights reserved.\n","filename":"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/MontgomeryPolynomialFuzzTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}