{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,3 +112,10 @@\n-     * Normalize the key by converting to following form.\n-     * First {@code char} upper case, rest lower case.\n-     * key is presumed to be {@code ASCII}.\n+     * {@return the normalized header name of the following form: the first\n+     * character in upper-case, the rest in lower-case}\n+     * The input header name is assumed to be encoded in ASCII.\n+     *\n+     * @implSpec\n+     * This method is performance-sensitive; update with care.\n+     *\n+     * @param key an ASCII-encoded header name\n+     * @throws NullPointerException on null {@code key}\n+     * @throws IllegalArgumentException if {@code key} contains {@code \\r} or {@code \\n}\n@@ -116,1 +123,3 @@\n-    private String normalize(String key) {\n+    private static String normalize(String key) {\n+\n+        \/\/ Fast path for the empty key\n@@ -118,2 +127,2 @@\n-        int len = key.length();\n-        if (len == 0) {\n+        int l = key.length();\n+        if (l == 0) {\n@@ -122,0 +131,2 @@\n+\n+        \/\/ Find the first non-normalized `char`\n@@ -124,5 +135,1 @@\n-        if (c == '\\r' || c == '\\n')\n-            throw new IllegalArgumentException(\"illegal character in key\");\n-        if (c >= 'a' && c <= 'z') {\n-            \/\/ start with lowercase\n-        } else {\n+        if (c >= 'A' && c <= 'Z') {\n@@ -130,1 +137,1 @@\n-            for (; i < len; i++) {\n+            for (; i < l; i++) {\n@@ -132,3 +139,1 @@\n-                if (c == '\\r' || c == '\\n')\n-                    throw new IllegalArgumentException(\"illegal character in key\");\n-                else if (c >= 'A' && c <='Z') {\n+                if (c == '\\r' || c == '\\n' || (c >= 'A' && c <= 'Z')) {\n@@ -139,1 +144,0 @@\n-        if (i == len) return key;\n@@ -141,1 +145,8 @@\n-        char[] b = key.toCharArray();\n+        \/\/ Fast path for the already normalized key\n+        if (i == l) {\n+            return key;\n+        }\n+\n+        \/\/ Normalize the first `char`\n+        char[] cs = key.toCharArray();\n+        int o = 'a' - 'A';\n@@ -143,1 +154,4 @@\n-            b[0] = (char)(b[0] - ('a' - 'A'));\n+            if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+            cs[0] = (char) (c - o);\n@@ -146,2 +160,4 @@\n-        for (; i < len; i++) {\n-            c = b[i];\n+\n+        \/\/ Normalize the secondary `char`s\n+        for (; i < l; i++) {\n+            c = cs[i];\n@@ -149,3 +165,4 @@\n-                b[i] = (char) (c + ('a'-'A'));\n-            } else if (c == '\\r' || c == '\\n')\n-                throw new IllegalArgumentException(\"illegal character in key\");\n+                cs[i] = (char) (c + o);\n+            } else if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n@@ -153,1 +170,3 @@\n-        return new String(b);\n+\n+        return new String(cs);\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Headers.java","additions":44,"deletions":25,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -291,0 +291,1 @@\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"\\r\"))));\n@@ -292,2 +293,6 @@\n-        assertThrows(IAE, () -> h0.putAll(Map.of(\"AbC\\n\", List.of(\"hey\"))));\n-        assertThrows(IAE, () -> h0.putAll(Map.of(\"Ab\\n\", List.of(\"hi\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"a\\r\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"a\\n\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"\\r\", List.of(\"a\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"\\n\", List.of(\"a\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\\r\", List.of(\"a\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\\n\", List.of(\"a\"))));\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HeadersTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.sun.net.httpserver;\n+\n+import com.sun.net.httpserver.Headers;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+\/**\n+ * Benchmarks {@code jdk.httpserver} header normalization.\n+ * <p>\n+ * You can run this benchmark as follows:\n+ * <pre>{@code\n+ * make run-test TEST=\"micro:HeaderNormalization\" MICRO=\"OPTIONS=-prof gc\"\n+ * }<\/pre>\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\n+        \"--add-exports\", \"jdk.httpserver\/com.sun.net.httpserver=ALL-UNNAMED\",\n+        \"--add-opens\", \"jdk.httpserver\/com.sun.net.httpserver=ALL-UNNAMED\",\n+})\n+public class HeaderNormalization {\n+\n+    private static final Function<String, String> NORMALIZE = findNormalize();\n+\n+    private static Function<String, String> findNormalize() {\n+        var lookup = MethodHandles.lookup();\n+        MethodHandle handle;\n+        try {\n+            handle = MethodHandles\n+                    .privateLookupIn(Headers.class, lookup)\n+                    .findStatic(\n+                            Headers.class, \"normalize\",\n+                            MethodType.methodType(String.class, String.class));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        return key -> {\n+            try {\n+                return (String) handle.invokeExact(key);\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        };\n+    }\n+\n+    @Param({\n+            \"Accept-charset\",   \/\/ Already normalized\n+            \"accept-charset\",   \/\/ Only the first `a` must be upper-cased\n+            \"Accept-Charset\",   \/\/ Only `c` must be lower-cased\n+            \"ACCEPT-CHARSET\",   \/\/ All secondary must be lower-cased\n+    })\n+    private String key;\n+\n+    @Benchmark\n+    public String n26() {\n+        return NORMALIZE.apply(key);\n+    }\n+\n+    @Benchmark\n+    public String n25() {\n+        return normalize25(key);\n+    }\n+\n+    \/**\n+     * The {@code com.sun.net.httpserver.Headers::normalize} method used in Java 25 and before.\n+     *\/\n+    private static String normalize25(String key) {\n+        Objects.requireNonNull(key);\n+        int len = key.length();\n+        if (len == 0) {\n+            return key;\n+        }\n+        char[] b = key.toCharArray();\n+        if (b[0] >= 'a' && b[0] <= 'z') {\n+            b[0] = (char)(b[0] - ('a' - 'A'));\n+        } else if (b[0] == '\\r' || b[0] == '\\n')\n+            throw new IllegalArgumentException(\"illegal character in key\");\n+\n+        for (int i=1; i<len; i++) {\n+            if (b[i] >= 'A' && b[i] <= 'Z') {\n+                b[i] = (char) (b[i] + ('a' - 'A'));\n+            } else if (b[i] == '\\r' || b[i] == '\\n')\n+                throw new IllegalArgumentException(\"illegal character in key\");\n+        }\n+        return new String(b);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/sun\/net\/httpserver\/HeaderNormalization.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"}]}