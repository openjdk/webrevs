{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,3 +112,10 @@\n-     * Normalize the key by converting to following form.\n-     * First {@code char} upper case, rest lower case.\n-     * key is presumed to be {@code ASCII}.\n+     * {@return the normalized header name of the following form: the first\n+     * character in upper-case, the rest in lower-case}\n+     * The input header name is assumed to be encoded in ASCII.\n+     *\n+     * @implSpec\n+     * This method is performance-sensitive; update with care.\n+     *\n+     * @param key an ASCII-encoded header name\n+     * @throws NullPointerException on null {@code key}\n+     * @throws IllegalArgumentException if {@code key} contains {@code \\r} or {@code \\n}\n@@ -116,1 +123,3 @@\n-    private String normalize(String key) {\n+    private static String normalize(String key) {\n+\n+        \/\/ Fast path for the empty key\n@@ -118,2 +127,2 @@\n-        int len = key.length();\n-        if (len == 0) {\n+        int l = key.length();\n+        if (l == 0) {\n@@ -122,11 +131,17 @@\n-        char[] b = key.toCharArray();\n-        if (b[0] >= 'a' && b[0] <= 'z') {\n-            b[0] = (char)(b[0] - ('a' - 'A'));\n-        } else if (b[0] == '\\r' || b[0] == '\\n')\n-            throw new IllegalArgumentException(\"illegal character in key\");\n-\n-        for (int i=1; i<len; i++) {\n-            if (b[i] >= 'A' && b[i] <= 'Z') {\n-                b[i] = (char) (b[i] + ('a' - 'A'));\n-            } else if (b[i] == '\\r' || b[i] == '\\n')\n-                throw new IllegalArgumentException(\"illegal character in key\");\n+\n+        \/\/ Find the first non-normalized `char`\n+        int i = 0;\n+        char c = key.charAt(i);\n+        if (!(c == '\\r' || c == '\\n' || (c >= 'a' && c <= 'z'))) {\n+            i++;\n+            for (; i < l; i++) {\n+                c = key.charAt(i);\n+                if (c == '\\r' || c == '\\n' || (c >= 'A' && c <= 'Z')) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        \/\/ Fast path for the already normalized key\n+        if (i == l) {\n+            return key;\n@@ -134,1 +149,26 @@\n-        return new String(b);\n+\n+        \/\/ Upper-case the first `char`\n+        char[] cs = key.toCharArray();\n+        int o = 'a' - 'A';\n+        if (i == 0) {\n+            if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+            if (c >= 'a' && c <= 'z') {\n+                cs[0] = (char) (c - o);\n+            }\n+            i++;\n+        }\n+\n+        \/\/ Lower-case the secondary `char`s\n+        for (; i < l; i++) {\n+            c = cs[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                cs[i] = (char) (c + o);\n+            } else if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+        }\n+\n+        return new String(cs);\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Headers.java","additions":59,"deletions":19,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,3 @@\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n@@ -65,0 +68,2 @@\n+import static org.testng.Assert.assertNotSame;\n+import static org.testng.Assert.assertSame;\n@@ -291,0 +296,1 @@\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"\\r\"))));\n@@ -292,0 +298,6 @@\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"a\\r\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"a\\n\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"\\r\", List.of(\"a\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"\\n\", List.of(\"a\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\\r\", List.of(\"a\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\\n\", List.of(\"a\"))));\n@@ -446,0 +458,76 @@\n+    @Test\n+    public static void testNormalizeOnNull() {\n+        assertThrows(NullPointerException.class, () -> normalize(null));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] illegalKeys() {\n+        var illegalChars = List.of('\\r', '\\n');\n+        var illegalStrings = Stream\n+                \/\/ Insert an illegal char at every possible position of following strings\n+                .of(\"Ab\", \"ab\", \"_a\", \"2a\")\n+                .flatMap(s -> IntStream\n+                        .range(0, s.length() + 1)\n+                        .boxed()\n+                        .flatMap(i -> illegalChars\n+                                .stream()\n+                                .map(c -> s.substring(0, i) + c + s.substring(i))));\n+        return Stream\n+                .concat(illegalChars.stream().map(c -> \"\" + c), illegalStrings)\n+                .map(s -> new Object[]{s})\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"illegalKeys\")\n+    public static void testNormalizeOnIllegalKeys(String illegalKey) {\n+        assertThrows(IllegalArgumentException.class, () -> normalize(illegalKey));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] normalizedKeys() {\n+        return new Object[][]{\n+                \/\/ Empty string\n+                {\"\"},\n+                \/\/ Non-alpha prefix\n+                {\"_\"},\n+                {\"0\"},\n+                {\"_xy-@\"},\n+                {\"0xy-@\"},\n+                \/\/ Upper-case prefix\n+                {\"A\"},\n+                {\"B\"},\n+                {\"Ayz-@\"},\n+                {\"Byz-@\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"normalizedKeys\")\n+    public static void testNormalizeOnNormalizedKeys(String normalizedKey) {\n+        \/\/ Verify that the fast-path is taken\n+        assertSame(normalize(normalizedKey), normalizedKey);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] notNormalizedKeys() {\n+        return new Object[][]{\n+                {\"a\"},\n+                {\"b\"},\n+                {\"axy-@\"},\n+                {\"bxy-@\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"notNormalizedKeys\")\n+    public static void testNormalizeOnNotNormalizedKeys(String notNormalizedKey) {\n+        var normalizedKey = normalize(notNormalizedKey);\n+        \/\/ Verify that the fast-path is *not* taken\n+        assertNotSame(normalizedKey, notNormalizedKey);\n+        \/\/ Verify the result\n+        var expectedNormalizedKey = normalizedKey.substring(0, 1).toUpperCase() + normalizedKey.substring(1);\n+        assertEquals(normalizedKey, expectedNormalizedKey);\n+    }\n+\n+    private static String normalize(String key) {\n+        return Headers.of(key, \"foo\").keySet().iterator().next();\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HeadersTest.java","additions":89,"deletions":1,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.sun.net.httpserver;\n+\n+import com.sun.net.httpserver.Headers;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+\/**\n+ * Benchmarks {@code jdk.httpserver} header normalization.\n+ * <p>\n+ * You can run this benchmark as follows:\n+ * <pre>{@code\n+ * make run-test TEST=\"micro:HeaderNormalization\" MICRO=\"OPTIONS=-prof gc\"\n+ * }<\/pre>\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\n+        \"--add-exports\", \"jdk.httpserver\/com.sun.net.httpserver=ALL-UNNAMED\",\n+        \"--add-opens\", \"jdk.httpserver\/com.sun.net.httpserver=ALL-UNNAMED\",\n+})\n+public class HeaderNormalization {\n+\n+    private static final Function<String, String> NORMALIZE = findNormalize();\n+\n+    private static Function<String, String> findNormalize() {\n+        var lookup = MethodHandles.lookup();\n+        MethodHandle handle;\n+        try {\n+            handle = MethodHandles\n+                    .privateLookupIn(Headers.class, lookup)\n+                    .findStatic(\n+                            Headers.class, \"normalize\",\n+                            MethodType.methodType(String.class, String.class));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        return key -> {\n+            try {\n+                return (String) handle.invokeExact(key);\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        };\n+    }\n+\n+    @Param({\n+            \"Accept-charset\",   \/\/ Already normalized\n+            \"4ccept-charset\",   \/\/ Already normalized with a non-alpha first letter\n+            \"accept-charset\",   \/\/ Only the first `a` must be upper-cased\n+            \"Accept-Charset\",   \/\/ Only `c` must be lower-cased\n+            \"ACCEPT-CHARSET\",   \/\/ All secondary must be lower-cased\n+    })\n+    private String key;\n+\n+    @Benchmark\n+    public String n26() {\n+        return NORMALIZE.apply(key);\n+    }\n+\n+    @Benchmark\n+    public String n25() {\n+        return normalize25(key);\n+    }\n+\n+    \/**\n+     * The {@code com.sun.net.httpserver.Headers::normalize} method used in Java 25 and before.\n+     *\/\n+    private static String normalize25(String key) {\n+        Objects.requireNonNull(key);\n+        int len = key.length();\n+        if (len == 0) {\n+            return key;\n+        }\n+        char[] b = key.toCharArray();\n+        if (b[0] >= 'a' && b[0] <= 'z') {\n+            b[0] = (char)(b[0] - ('a' - 'A'));\n+        } else if (b[0] == '\\r' || b[0] == '\\n')\n+            throw new IllegalArgumentException(\"illegal character in key\");\n+\n+        for (int i=1; i<len; i++) {\n+            if (b[i] >= 'A' && b[i] <= 'Z') {\n+                b[i] = (char) (b[i] + ('a' - 'A'));\n+            } else if (b[i] == '\\r' || b[i] == '\\n')\n+                throw new IllegalArgumentException(\"illegal character in key\");\n+        }\n+        return new String(b);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/sun\/net\/httpserver\/HeaderNormalization.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}