{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,0 +295,1 @@\n+        \/\/ non-null if the QUIC stream was reset, or an exception occurred\n@@ -296,0 +297,1 @@\n+        \/\/ true if close() was called\n@@ -300,2 +302,0 @@\n-        \/\/ Use lock to avoid pinned threads on the blocking queue\n-        final ReentrantLock lock = new ReentrantLock();\n@@ -304,20 +304,17 @@\n-            lock.lock();\n-            try {\n-                while (true) {\n-                    if (current != null && current.hasRemaining()) {\n-                        return current;\n-                    }\n-                    if (current == QuicStreamReader.EOF) return current;\n-                    try {\n-                        if (debug.on())\n-                            debug.log(\"Taking buffer from queue\");\n-                        \/\/ Blocking call\n-                        current = requestBodyQueue.take();\n-                    } catch (InterruptedException e) {\n-                        var io = new InterruptedIOException();\n-                        Thread.currentThread().interrupt();\n-                        io.initCause(e);\n-                        close(io);\n-                        var error = this.error;\n-                        if (error != null) throw error;\n-                    }\n+            while (true) {\n+                if (current != null && current.hasRemaining()) {\n+                    return current;\n+                }\n+                if (current == QuicStreamReader.EOF) return current;\n+                try {\n+                    if (debug.on())\n+                        debug.log(\"Taking buffer from queue\");\n+                    \/\/ Blocking call\n+                    current = requestBodyQueue.take();\n+                } catch (InterruptedException e) {\n+                    var io = new InterruptedIOException();\n+                    Thread.currentThread().interrupt();\n+                    io.initCause(e);\n+                    close(io);\n+                    var error = this.error;\n+                    if (error != null) throw error;\n@@ -325,2 +322,0 @@\n-            } finally {\n-                lock.unlock();\n@@ -332,0 +327,3 @@\n+            if (closed) {\n+                throw new IOException(\"Stream is closed\");\n+            }\n@@ -334,0 +332,3 @@\n+                if (closed) {\n+                    throw new IOException(\"Stream is closed\");\n+                }\n@@ -344,0 +345,3 @@\n+            if (closed) {\n+                throw new IOException(\"Stream is closed\");\n+            }\n@@ -349,0 +353,3 @@\n+                        if (closed) {\n+                            throw new IOException(\"Stream is closed\");\n+                        }\n@@ -363,8 +370,2 @@\n-            lock.lock();\n-            try {\n-                if (closed) return;\n-                closed = true;\n-\n-            } finally {\n-                lock.unlock();\n-            }\n+            if (closed) return;\n+            closed = true;\n@@ -377,8 +378,2 @@\n-            lock.lock();\n-            try {\n-                if (closed) return;\n-                closed = true;\n-                error = io;\n-            } finally {\n-                lock.unlock();\n-            }\n+            if (error != null) return;\n+            error = io;\n@@ -388,1 +383,0 @@\n-            requestBodyQueue.clear();\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http3\/Http3ServerStreamImpl.java","additions":36,"deletions":42,"binary":false,"changes":78,"status":"modified"}]}