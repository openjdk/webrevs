{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -252,1 +252,2 @@\n-    MonitorChunk* chunk = jt->monitor_chunks();\n+    \/\/ Consider removing, chunk will always be null.\n+    MonitorChunk* chunk = jt->monitor_chunks_safe();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1003,1 +1003,2 @@\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n+  \/\/ Consider removing: chunk is always null.\n+  for (MonitorChunk* chunk = monitor_chunks_safe(); chunk != nullptr; chunk = chunk->next()) {\n@@ -1018,0 +1019,31 @@\n+\/\/ Effectively wait for any deoptimization to complete and clear _monitor_chunk.\n+class ReadMonitorChunksHandshake : public HandshakeClosure {\n+  MonitorChunk* _mc;\n+ public:\n+  ReadMonitorChunksHandshake(): HandshakeClosure(\"ReadMonitorChunks\") {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = JavaThread::cast(thr);\n+    _mc = target->monitor_chunks();\n+  }\n+  MonitorChunk* monitor_chunks() {\n+    return _mc;\n+  }\n+};\n+\n+\/\/ _monitor_chunks is set and cleared by deoptimization.\n+\/\/ If non-null, deoptimization is happening and the value\n+\/\/ will be cleared soon.  Waiting for deopt is the only action.\n+\/\/ A ThreadLocalHandshake will mean deopt is complete.\n+MonitorChunk* JavaThread::monitor_chunks_safe() const {\n+  MonitorChunk* chunks = _monitor_chunks;\n+  if (chunks != nullptr) {\n+    \/\/ Deopt is working, not at a safepoint.  Use Handshake:\n+    ReadMonitorChunksHandshake rmch;\n+    ThreadsListHandle tlh;\n+    Handshake::execute(&rmch, &tlh, (JavaThread*) JavaThread::cast(this));\n+    chunks = rmch.monitor_chunks(); \/\/ will be null, deopt has finished after handshake\n+    assert(chunks == nullptr, \"_monitor_chunks not null\");\n+  }\n+  return chunks;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -871,0 +871,1 @@\n+  MonitorChunk* monitor_chunks_safe() const;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}