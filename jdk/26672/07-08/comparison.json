{"files":[{"patch":"@@ -113,0 +113,4 @@\n+        \/\/ 0 < len < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+        \/\/ Strictly, we could check for !src.asSlice(srcOffset, len).overlaps(dst.asSlice(dstOffset, len) but\n+        \/\/ this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n+        \/\/ is an overlap, we could tolerate one particular direction of overlap (but not the other).\n@@ -119,9 +123,2 @@\n-            \/\/ 0 < len < FILL_NATIVE_LIMIT : 0...0X...XXXX\n-            \/\/\n-            \/\/ Strictly, we could check for !src.asSlice(srcOffset, len).overlaps(dst.asSlice(dstOffset, len) but\n-            \/\/ this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n-            \/\/ is an overlap, we could tolerate one particular direction of overlap (but not the other).\n-\n-\n-            if( len > 15) {\n-                copy5AndUpwards(src, srcOffset, dst, dstOffset, len);\n+            if (len > 15) {\n+                copy5AndUpwards(src, srcOffset, src.sessionImpl(), dst, dstOffset, dst.sessionImpl(), len);\n@@ -129,11 +126,1 @@\n-                \/\/ Switch on log2(len) = 64 - Long.numberOfLeadingZeros(len)\n-                switch (64 - Long.numberOfLeadingZeros(len)) {\n-                    case 0 -> { \/* Do nothing *\/ }\n-                    case 1 -> {\n-                        final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n-                        SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v);\n-                    }\n-                    case 2 -> copy2(src, srcOffset, dst, dstOffset, len);\n-                    case 3 -> copy3(src, srcOffset, dst, dstOffset, len);\n-                    case 4 -> copy4(src, srcOffset, dst, dstOffset, len);\n-                }\n+                copy0through4(src, srcOffset, src.sessionImpl(), dst, dstOffset, dst.sessionImpl(), len);\n@@ -144,0 +131,25 @@\n+    @ForceInline\n+    static void copy0through4(AbstractMemorySegmentImpl src, long srcOffset, MemorySessionImpl srcSession,\n+                              AbstractMemorySegmentImpl dst, long dstOffset, MemorySessionImpl dstSession,\n+                              long len) {\n+        \/\/ Switch on log2(len) = 64 - Long.numberOfLeadingZeros(len)\n+        switch (64 - Long.numberOfLeadingZeros(len)) {\n+            case 0 -> { \/* Do nothing *\/ }\n+            case 1 -> copy1(src, srcOffset, srcSession, dst, dstOffset, dstSession);\n+            case 2 -> copy2(src, srcOffset, srcSession, dst, dstOffset, dstSession, len);\n+            case 3 -> copy3(src, srcOffset, srcSession, dst, dstOffset, dstSession, len);\n+            case 4 -> copy4(src, srcOffset, srcSession, dst, dstOffset, dstSession, len);\n+        }\n+    }\n+\n+    @ForceInline\n+    private static void copy1(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              MemorySessionImpl srcSession,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              MemorySessionImpl dstSession) {\n+        final byte v = SCOPED_MEMORY_ACCESS.getByte(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putByte(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v);\n+    }\n+\n@@ -148,0 +160,1 @@\n+                              MemorySessionImpl srcSession,\n@@ -150,0 +163,1 @@\n+                              MemorySessionImpl dstSession,\n@@ -152,3 +166,0 @@\n-        final MemorySessionImpl srcSession = src.sessionImpl();\n-        final MemorySessionImpl dstSession = dst.sessionImpl();\n-\n@@ -157,4 +168,3 @@\n-\n-        \/\/ `putByte()` below is enough as 3 is the maximum number of bytes covered\n-        final byte b = SCOPED_MEMORY_ACCESS.getByte(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Byte.BYTES);\n-        SCOPED_MEMORY_ACCESS.putByte(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Byte.BYTES, b);\n+        if (len == 3) {\n+            copy1(src, srcOffset + Short.BYTES, srcSession, dst, dstOffset + Short.BYTES, dstSession);\n+        }\n@@ -167,0 +177,1 @@\n+                              MemorySessionImpl srcSession,\n@@ -169,0 +180,1 @@\n+                              MemorySessionImpl dstSession,\n@@ -171,3 +183,0 @@\n-        final MemorySessionImpl srcSession = src.sessionImpl();\n-        final MemorySessionImpl dstSession = dst.sessionImpl();\n-\n@@ -176,3 +185,1 @@\n-\n-        final int v1 = SCOPED_MEMORY_ACCESS.getIntUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Integer.BYTES);\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Integer.BYTES, v1);\n+        copy0through4(src, srcOffset + Integer.BYTES, srcSession, dst, dstOffset + Integer.BYTES, dstSession, len - Integer.BYTES);\n@@ -185,0 +192,1 @@\n+                              MemorySessionImpl srcSession,\n@@ -187,0 +195,1 @@\n+                              MemorySessionImpl dstSession,\n@@ -189,3 +198,0 @@\n-        final MemorySessionImpl srcSession = src.sessionImpl();\n-        final MemorySessionImpl dstSession = dst.sessionImpl();\n-\n@@ -194,3 +200,1 @@\n-\n-        final long v1 = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Long.BYTES);\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Long.BYTES, v1);\n+        copy0through4(src, srcOffset + Long.BYTES, srcSession, dst, dstOffset + Long.BYTES, dstSession, len - Long.BYTES);\n@@ -203,0 +207,1 @@\n+                                        MemorySessionImpl srcSession,\n@@ -205,0 +210,1 @@\n+                                        MemorySessionImpl dstSession,\n@@ -207,3 +213,0 @@\n-        final MemorySessionImpl srcSession = src.sessionImpl();\n-        final MemorySessionImpl dstSession = dst.sessionImpl();\n-\n@@ -216,9 +219,1 @@\n-\n-        \/\/ After the loop, the VM is not able to elide redundant stores so unfortunately,\n-        \/\/ we have to do this if statement.\n-        if ((int) len - offset > 0) {\n-            \/\/ It is safe to copy the tail in a single `long` op because we know `len` is at least 8\n-            final long v = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Long.BYTES);\n-            SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Long.BYTES, v);\n-        }\n-\n+        copy0through4(src, srcOffset + offset, srcSession, dst, dstOffset + offset, srcSession, len - offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":46,"deletions":51,"binary":false,"changes":97,"status":"modified"}]}