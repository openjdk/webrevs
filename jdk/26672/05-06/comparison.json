{"files":[{"patch":"@@ -247,2 +247,4 @@\n-        if (overlaps(that) >= 0) {\n-            return Optional.empty();\n+        if (overlaps(that)) {\n+            final long offsetToThat = that.address() - this.address();\n+            final long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n+            return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n@@ -250,3 +252,1 @@\n-        final long offsetToThat = that.address() - this.address();\n-        final long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n-        return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n+        return Optional.empty();\n@@ -255,1 +255,0 @@\n-    \/\/ Returns a negative value if the regions overlap, otherwise a non-negative value.\n@@ -257,1 +256,1 @@\n-    int overlaps(AbstractMemorySegmentImpl that) {\n+    boolean overlaps(AbstractMemorySegmentImpl that) {\n@@ -259,1 +258,0 @@\n-\n@@ -261,1 +259,0 @@\n-            final long thisEnd = thisStart + this.byteSize();\n@@ -263,0 +260,1 @@\n+            final long thisEnd = thisStart + this.byteSize();\n@@ -264,11 +262,1 @@\n-\n-            \/\/ The below computation is a branchless equivalent to\n-            \/\/ `return (thisStart < thatEnd && thisEnd > thatStart)?-something:+somethingElse;`. Here is how:\n-            \/\/ All the variables thisStart, thisEnd, thatStart, and thatEnd are non-negative\n-            \/\/ First, consider (thisStart < thatEnd).\n-            \/\/ We can subtract thatEnd on both sides:\n-            \/\/ (thisStart < thatEnd) -> (thisStart - thatEnd < 0). In the same way we can say:\n-            \/\/ (thatStart < thisEnd) -> (thatStart - thisEnd < 0).\n-            \/\/ A long value that is less than zero has it's 63:th bit set and so,\n-            \/\/ we can just AND the expressions (and the sign bit 63)\n-            return (int) (((thisStart - thatEnd) & (thatStart - thisEnd)));  \/\/ overlap occurs -> negative value\n+            return (thisStart < thatEnd && thisEnd > thatStart); \/\/overlap occurs?\n@@ -276,1 +264,1 @@\n-        return 0;\n+        return false;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -113,1 +113,6 @@\n-        if (len < NATIVE_THRESHOLD_COPY && src.overlaps(dst) == 0) {\n+        if (len >= NATIVE_THRESHOLD_COPY || src.overlaps(dst)) {\n+            \/\/ For larger sizes, the transition to native code pays off\n+            SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n+                    src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, len);\n+        } else {\n@@ -132,5 +137,0 @@\n-        } else {\n-            \/\/ For larger sizes, the transition to native code pays off\n-            SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n-                    src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n-                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, len);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}