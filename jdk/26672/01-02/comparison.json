{"files":[{"patch":"@@ -247,4 +247,2 @@\n-        if (overlaps(that)) {\n-            final long offsetToThat = that.address() - this.address();\n-            final long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n-            return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n+        if (overlaps(that) == 0) {\n+            return Optional.empty();\n@@ -252,1 +250,3 @@\n-        return Optional.empty();\n+        final long offsetToThat = that.address() - this.address();\n+        final long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n+        return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n@@ -255,0 +255,1 @@\n+    \/\/ Returns 1 if the regions overlap, otherwise 0.\n@@ -256,1 +257,1 @@\n-    boolean overlaps(AbstractMemorySegmentImpl that) {\n+    int overlaps(AbstractMemorySegmentImpl that) {\n@@ -258,0 +259,1 @@\n+\n@@ -259,1 +261,0 @@\n-            final long thatStart = that.unsafeGetOffset();\n@@ -261,0 +262,1 @@\n+            final long thatStart = that.unsafeGetOffset();\n@@ -262,1 +264,10 @@\n-            return (thisStart < thatEnd && thisEnd > thatStart); \/\/overlap occurs?\n+\n+            \/\/ The below computation is a branchless equivalent to\n+            \/\/ `return (thisStart < thatEnd && thisEnd > thatStart)?1:0;`. Here is how:\n+            \/\/ First, consider (thisStart < thatEnd).\n+            \/\/ We can subtract (non-negative) thatEnd on both sides:\n+            \/\/ (thisStart < thatEnd) -> (thisStart - thatEnd < 0). In the same way we can say:\n+            \/\/ (thatStart < thisEnd) -> (thatStart - thisEnd < 0).\n+            \/\/ A long value that is less than zero has it's 63:th bit set and so,\n+            \/\/ we can just AND the expressions and shift the sign bit 63 steps to get (0|1)\n+            return (int) ((((thisStart - thatEnd) & (thatStart - thisEnd))) >>> 63);  \/\/overlap occurs?\n@@ -264,1 +275,1 @@\n-        return false;\n+        return 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-        if (len < NATIVE_THRESHOLD_COPY && !src.overlaps(dst)) {\n+        if (len < NATIVE_THRESHOLD_COPY && src.overlaps(dst) == 0) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}