{"files":[{"patch":"@@ -247,4 +247,2 @@\n-        if (overlaps(that)) {\n-            final long offsetToThat = that.address() - this.address();\n-            final long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n-            return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n+        if (overlaps(that) == 0) {\n+            return Optional.empty();\n@@ -252,1 +250,3 @@\n-        return Optional.empty();\n+        final long offsetToThat = that.address() - this.address();\n+        final long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n+        return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n@@ -255,0 +255,1 @@\n+    \/\/ Returns 1 if the regions overlap, otherwise 0.\n@@ -256,1 +257,1 @@\n-    boolean overlaps(AbstractMemorySegmentImpl that) {\n+    int overlaps(AbstractMemorySegmentImpl that) {\n@@ -258,0 +259,1 @@\n+\n@@ -259,1 +261,0 @@\n-            final long thatStart = that.unsafeGetOffset();\n@@ -261,0 +262,1 @@\n+            final long thatStart = that.unsafeGetOffset();\n@@ -262,1 +264,10 @@\n-            return (thisStart < thatEnd && thisEnd > thatStart); \/\/overlap occurs?\n+\n+            \/\/ The below computation is a branchless equivalent to\n+            \/\/ `return (thisStart < thatEnd && thisEnd > thatStart)?1:0;`. Here is how:\n+            \/\/ First, consider (thisStart < thatEnd).\n+            \/\/ We can subtract (non-negative) thatEnd on both sides:\n+            \/\/ (thisStart < thatEnd) -> (thisStart - thatEnd < 0). In the same way we can say:\n+            \/\/ (thatStart < thisEnd) -> (thatStart - thisEnd < 0).\n+            \/\/ A long value that is less than zero has it's 63:th bit set and so,\n+            \/\/ we can just AND the expressions and shift the sign bit 63 steps to get (0|1)\n+            return (int) ((((thisStart - thatEnd) & (thatStart - thisEnd))) >>> 63);  \/\/overlap occurs?\n@@ -264,1 +275,1 @@\n-        return false;\n+        return 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                            long size) {\n+                            long len) {\n@@ -109,1 +109,0 @@\n-        Utils.checkNonNegativeIndex(size, \"size\");\n@@ -111,2 +110,2 @@\n-        src.checkAccess(srcOffset, size, true);\n-        dst.checkAccess(dstOffset, size, false);\n+        src.checkAccess(srcOffset, len, true);\n+        dst.checkAccess(dstOffset, len, false);\n@@ -114,4 +113,2 @@\n-        if (size <= 0) {\n-            \/\/ Do nothing\n-        } else if (size < NATIVE_THRESHOLD_COPY && !src.overlaps(dst)) {\n-            \/\/ 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+        if (len < NATIVE_THRESHOLD_COPY && src.overlaps(dst) == 0) {\n+            \/\/ 0 < len < FILL_NATIVE_LIMIT : 0...0X...XXXX\n@@ -119,1 +116,1 @@\n-            \/\/ Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n+            \/\/ Strictly, we could check for !src.asSlice(srcOffset, len).overlaps(dst.asSlice(dstOffset, len) but\n@@ -123,6 +120,11 @@\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - Long.BYTES));\n-            int offset = 0;\n-            for (; offset < limit; offset += Long.BYTES) {\n-                final long v = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n+            \/\/ Switch on log2(len) = 64 - Long.numberOfLeadingZeros(len)\n+            switch (64 - Long.numberOfLeadingZeros(len)) {\n+                case 0 -> { \/* Do nothing *\/ }\n+                case 1 -> {\n+                    final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+                    SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v);\n+                }\n+                case 2 -> copy2(src, srcOffset, dst, dstOffset, len);\n+                case 3 -> copy3(src, srcOffset, dst, dstOffset, len);\n+                case 4 -> copy4(src, srcOffset, dst, dstOffset, len);\n+                default -> copy5AndUpwards(src, srcOffset, dst, dstOffset, len);\n@@ -130,21 +132,0 @@\n-            int remaining = (int) size - offset;\n-            \/\/ 0...0X00\n-            if (remaining >= Integer.BYTES) {\n-                final int v = SCOPED_MEMORY_ACCESS.getIntUnaligned(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n-                offset += Integer.BYTES;\n-                remaining -= Integer.BYTES;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= Short.BYTES) {\n-                final short v = SCOPED_MEMORY_ACCESS.getShortUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n-                offset += Short.BYTES;\n-                remaining -= Short.BYTES;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n-            }\n-            \/\/ We have now fully handled 0...0X...XXXX\n@@ -155,1 +136,75 @@\n-                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, len);\n+        }\n+    }\n+\n+    \/** This case covers [2, 3] bytes *\/\n+    @ForceInline\n+    private static void copy2(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              long len) {\n+\n+        final MemorySessionImpl srcSession = src.sessionImpl();\n+        final MemorySessionImpl dstSession = dst.sessionImpl();\n+\n+        final short v = SCOPED_MEMORY_ACCESS.getShortUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v);\n+\n+        \/\/ `putByte()` below is enough as 3 is the maximum number of bytes covered\n+        final byte b = SCOPED_MEMORY_ACCESS.getByte(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Byte.BYTES);\n+        SCOPED_MEMORY_ACCESS.putByte(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Byte.BYTES, b);\n+    }\n+\n+    \/** This case covers [4, 7] bytes *\/\n+    @ForceInline\n+    private static void copy3(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              long len) {\n+\n+        final MemorySessionImpl srcSession = src.sessionImpl();\n+        final MemorySessionImpl dstSession = dst.sessionImpl();\n+\n+        final int v0 = SCOPED_MEMORY_ACCESS.getIntUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v0);\n+\n+        final int v1 = SCOPED_MEMORY_ACCESS.getIntUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Integer.BYTES);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Integer.BYTES, v1);\n+    }\n+\n+    \/** This case covers [8, 15] bytes *\/\n+    @ForceInline\n+    private static void copy4(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              long len) {\n+\n+        final MemorySessionImpl srcSession = src.sessionImpl();\n+        final MemorySessionImpl dstSession = dst.sessionImpl();\n+\n+        final long v0 = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v0);\n+\n+        final long v1 = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Long.BYTES);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Long.BYTES, v1);\n+    }\n+\n+    \/** This case covers [16, 2^63) bytes *\/\n+    @ForceInline\n+    private static void copy5AndUpwards(AbstractMemorySegmentImpl src,\n+                                        long srcOffset,\n+                                        AbstractMemorySegmentImpl dst,\n+                                        long dstOffset,\n+                                        long len) {\n+\n+        final MemorySessionImpl srcSession = src.sessionImpl();\n+        final MemorySessionImpl dstSession = dst.sessionImpl();\n+\n+        final int limit = (int) (len & (NATIVE_THRESHOLD_COPY - Long.BYTES));\n+        int offset = 0;\n+        for (; offset < limit; offset += Long.BYTES) {\n+            final long v = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+            SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n@@ -157,0 +212,9 @@\n+\n+        \/\/ After the loop, the VM is not able to elide redundant stores so unfortunately,\n+        \/\/ we have to do this if statement.\n+        if ((int) len - offset > 0) {\n+            \/\/ It is safe to copy the tail in a single `long` op because we know `len` is at least 8\n+            final long v = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Long.BYTES);\n+            SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Long.BYTES, v);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":101,"deletions":37,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -85,0 +85,42 @@\n+\n+    @ForceInline\n+    public $type$ get$Type$Unaligned(MemorySessionImpl session, Object base, long offset) {\n+        try {\n+            return get$Type$UnalignedInternal(session, base, offset);\n+        } catch (ScopedAccessError ex) {\n+            throw ex.newRuntimeException();\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset) {\n+        try {\n+            if (session != null) {\n+                session.checkValidStateRaw();\n+            }\n+            return UNSAFE.get$Type$Unaligned(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(session);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$Unaligned(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$UnalignedInternal(session, base, offset, value);\n+        } catch (ScopedAccessError ex) {\n+            throw ex.newRuntimeException();\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+        try {\n+            if (session != null) {\n+                session.checkValidStateRaw();\n+            }\n+            UNSAFE.put$Type$Unaligned(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(session);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"24\", \"64\", \"512\",\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}