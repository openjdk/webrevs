{"files":[{"patch":"@@ -107,1 +107,1 @@\n-                            long size) {\n+                            long len) {\n@@ -109,1 +109,0 @@\n-        Utils.checkNonNegativeIndex(size, \"size\");\n@@ -111,2 +110,2 @@\n-        src.checkAccess(srcOffset, size, true);\n-        dst.checkAccess(dstOffset, size, false);\n+        src.checkAccess(srcOffset, len, true);\n+        dst.checkAccess(dstOffset, len, false);\n@@ -114,4 +113,7 @@\n-        if (size <= 0) {\n-            \/\/ Do nothing\n-        } else if (size < NATIVE_THRESHOLD_COPY && !src.overlaps(dst)) {\n-            \/\/ 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+        if (len >= NATIVE_THRESHOLD_COPY || src.overlaps(dst)) {\n+            \/\/ For larger sizes, the transition to native code pays off\n+            SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n+                    src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, len);\n+        } else {\n+            \/\/ 0 < len < FILL_NATIVE_LIMIT : 0...0X...XXXX\n@@ -119,1 +121,1 @@\n-            \/\/ Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n+            \/\/ Strictly, we could check for !src.asSlice(srcOffset, len).overlaps(dst.asSlice(dstOffset, len) but\n@@ -123,26 +125,15 @@\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - Long.BYTES));\n-            int offset = 0;\n-            for (; offset < limit; offset += Long.BYTES) {\n-                final long v = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n-            }\n-            int remaining = (int) size - offset;\n-            \/\/ 0...0X00\n-            if (remaining >= Integer.BYTES) {\n-                final int v = SCOPED_MEMORY_ACCESS.getIntUnaligned(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n-                offset += Integer.BYTES;\n-                remaining -= Integer.BYTES;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= Short.BYTES) {\n-                final short v = SCOPED_MEMORY_ACCESS.getShortUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n-                offset += Short.BYTES;\n-                remaining -= Short.BYTES;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+\n+            if( len > 15) {\n+                copy5AndUpwards(src, srcOffset, dst, dstOffset, len);\n+            } else {\n+                \/\/ Switch on log2(len) = 64 - Long.numberOfLeadingZeros(len)\n+                switch (64 - Long.numberOfLeadingZeros(len)) {\n+                    case 0 -> { \/* Do nothing *\/ }\n+                    case 1 -> {\n+                        final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+                        SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v);\n+                    }\n+                    case 2 -> copy2(src, srcOffset, dst, dstOffset, len);\n+                    case 3 -> copy3(src, srcOffset, dst, dstOffset, len);\n+                    case 4 -> copy4(src, srcOffset, dst, dstOffset, len);\n+                }\n@@ -150,6 +141,0 @@\n-            \/\/ We have now fully handled 0...0X...XXXX\n-        } else {\n-            \/\/ For larger sizes, the transition to native code pays off\n-            SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n-                    src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n-                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n@@ -159,0 +144,83 @@\n+    \/** This case covers [2, 3] bytes *\/\n+    @ForceInline\n+    private static void copy2(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              long len) {\n+\n+        final MemorySessionImpl srcSession = src.sessionImpl();\n+        final MemorySessionImpl dstSession = dst.sessionImpl();\n+\n+        final short v = SCOPED_MEMORY_ACCESS.getShortUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v);\n+\n+        \/\/ `putByte()` below is enough as 3 is the maximum number of bytes covered\n+        final byte b = SCOPED_MEMORY_ACCESS.getByte(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Byte.BYTES);\n+        SCOPED_MEMORY_ACCESS.putByte(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Byte.BYTES, b);\n+    }\n+\n+    \/** This case covers [4, 7] bytes *\/\n+    @ForceInline\n+    private static void copy3(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              long len) {\n+\n+        final MemorySessionImpl srcSession = src.sessionImpl();\n+        final MemorySessionImpl dstSession = dst.sessionImpl();\n+\n+        final int v0 = SCOPED_MEMORY_ACCESS.getIntUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v0);\n+\n+        final int v1 = SCOPED_MEMORY_ACCESS.getIntUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Integer.BYTES);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Integer.BYTES, v1);\n+    }\n+\n+    \/** This case covers [8, 15] bytes *\/\n+    @ForceInline\n+    private static void copy4(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              long len) {\n+\n+        final MemorySessionImpl srcSession = src.sessionImpl();\n+        final MemorySessionImpl dstSession = dst.sessionImpl();\n+\n+        final long v0 = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v0);\n+\n+        final long v1 = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Long.BYTES);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Long.BYTES, v1);\n+    }\n+\n+    \/** This case covers [16, 2^63) bytes *\/\n+    @ForceInline\n+    private static void copy5AndUpwards(AbstractMemorySegmentImpl src,\n+                                        long srcOffset,\n+                                        AbstractMemorySegmentImpl dst,\n+                                        long dstOffset,\n+                                        long len) {\n+\n+        final MemorySessionImpl srcSession = src.sessionImpl();\n+        final MemorySessionImpl dstSession = dst.sessionImpl();\n+\n+        final int limit = (int) (len & (NATIVE_THRESHOLD_COPY - Long.BYTES));\n+        int offset = 0;\n+        for (; offset < limit; offset += Long.BYTES) {\n+            final long v = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+            SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+        }\n+\n+        \/\/ After the loop, the VM is not able to elide redundant stores so unfortunately,\n+        \/\/ we have to do this if statement.\n+        if ((int) len - offset > 0) {\n+            \/\/ It is safe to copy the tail in a single `long` op because we know `len` is at least 8\n+            final long v = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + len - Long.BYTES);\n+            SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + len - Long.BYTES, v);\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":109,"deletions":41,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -85,0 +85,42 @@\n+\n+    @ForceInline\n+    public $type$ get$Type$Unaligned(MemorySessionImpl session, Object base, long offset) {\n+        try {\n+            return get$Type$UnalignedInternal(session, base, offset);\n+        } catch (ScopedAccessError ex) {\n+            throw ex.newRuntimeException();\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset) {\n+        try {\n+            if (session != null) {\n+                session.checkValidStateRaw();\n+            }\n+            return UNSAFE.get$Type$Unaligned(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(session);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$Unaligned(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$UnalignedInternal(session, base, offset, value);\n+        } catch (ScopedAccessError ex) {\n+            throw ex.newRuntimeException();\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+        try {\n+            if (session != null) {\n+                session.checkValidStateRaw();\n+            }\n+            UNSAFE.put$Type$Unaligned(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(session);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"24\", \"64\", \"512\",\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}