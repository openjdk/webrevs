{"files":[{"patch":"@@ -107,1 +107,1 @@\n-                            long size) {\n+                            long len) {\n@@ -109,1 +109,0 @@\n-        Utils.checkNonNegativeIndex(size, \"size\");\n@@ -111,41 +110,8 @@\n-        src.checkAccess(srcOffset, size, true);\n-        dst.checkAccess(dstOffset, size, false);\n-\n-        if (size <= 0) {\n-            \/\/ Do nothing\n-        } else if (size < NATIVE_THRESHOLD_COPY && !src.overlaps(dst)) {\n-            \/\/ 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n-            \/\/\n-            \/\/ Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n-            \/\/ this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n-            \/\/ is an overlap, we could tolerate one particular direction of overlap (but not the other).\n-\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - Long.BYTES));\n-            int offset = 0;\n-            for (; offset < limit; offset += Long.BYTES) {\n-                final long v = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n-            }\n-            int remaining = (int) size - offset;\n-            \/\/ 0...0X00\n-            if (remaining >= Integer.BYTES) {\n-                final int v = SCOPED_MEMORY_ACCESS.getIntUnaligned(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n-                offset += Integer.BYTES;\n-                remaining -= Integer.BYTES;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= Short.BYTES) {\n-                final short v = SCOPED_MEMORY_ACCESS.getShortUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n-                offset += Short.BYTES;\n-                remaining -= Short.BYTES;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n-            }\n-            \/\/ We have now fully handled 0...0X...XXXX\n-        } else {\n+        src.checkAccess(srcOffset, len, true);\n+        dst.checkAccess(dstOffset, len, false);\n+\n+        \/\/ 0 < len < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+        \/\/ Strictly, we could check for !src.asSlice(srcOffset, len).overlaps(dst.asSlice(dstOffset, len) but\n+        \/\/ this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n+        \/\/ is an overlap, we could tolerate one particular direction of overlap (but not the other).\n+        if (len >= NATIVE_THRESHOLD_COPY || src.overlaps(dst)) {\n@@ -155,1 +121,97 @@\n-                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, len);\n+        } else {\n+            if (len > 15) {\n+                copy5AndUpwards(src, srcOffset, src.sessionImpl(), dst, dstOffset, dst.sessionImpl(), len);\n+            } else {\n+                copy0through4(src, srcOffset, src.sessionImpl(), dst, dstOffset, dst.sessionImpl(), len);\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    static void copy0through4(AbstractMemorySegmentImpl src, long srcOffset, MemorySessionImpl srcSession,\n+                              AbstractMemorySegmentImpl dst, long dstOffset, MemorySessionImpl dstSession,\n+                              long len) {\n+        \/\/ Switch on log2(len) = 64 - Long.numberOfLeadingZeros(len)\n+        switch (64 - Long.numberOfLeadingZeros(len)) {\n+            case 0 -> { \/* Do nothing *\/ }\n+            case 1 -> copy1(src, srcOffset, srcSession, dst, dstOffset, dstSession);\n+            case 2 -> copy2(src, srcOffset, srcSession, dst, dstOffset, dstSession, len);\n+            case 3 -> copy3(src, srcOffset, srcSession, dst, dstOffset, dstSession, len);\n+            case 4 -> copy4(src, srcOffset, srcSession, dst, dstOffset, dstSession, len);\n+        }\n+    }\n+\n+    @ForceInline\n+    private static void copy1(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              MemorySessionImpl srcSession,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              MemorySessionImpl dstSession) {\n+        final byte v = SCOPED_MEMORY_ACCESS.getByte(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putByte(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v);\n+    }\n+\n+    \/** This case covers [2, 3] bytes *\/\n+    @ForceInline\n+    private static void copy2(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              MemorySessionImpl srcSession,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              MemorySessionImpl dstSession,\n+                              long len) {\n+\n+        final short v = SCOPED_MEMORY_ACCESS.getShortUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v);\n+        if (len == 3) {\n+            copy1(src, srcOffset + Short.BYTES, srcSession, dst, dstOffset + Short.BYTES, dstSession);\n+        }\n+    }\n+\n+    \/** This case covers [4, 7] bytes *\/\n+    @ForceInline\n+    private static void copy3(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              MemorySessionImpl srcSession,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              MemorySessionImpl dstSession,\n+                              long len) {\n+\n+        final int v0 = SCOPED_MEMORY_ACCESS.getIntUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v0);\n+        copy0through4(src, srcOffset + Integer.BYTES, srcSession, dst, dstOffset + Integer.BYTES, dstSession, len - Integer.BYTES);\n+    }\n+\n+    \/** This case covers [8, 15] bytes *\/\n+    @ForceInline\n+    private static void copy4(AbstractMemorySegmentImpl src,\n+                              long srcOffset,\n+                              MemorySessionImpl srcSession,\n+                              AbstractMemorySegmentImpl dst,\n+                              long dstOffset,\n+                              MemorySessionImpl dstSession,\n+                              long len) {\n+\n+        final long v0 = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, v0);\n+        copy0through4(src, srcOffset + Long.BYTES, srcSession, dst, dstOffset + Long.BYTES, dstSession, len - Long.BYTES);\n+    }\n+\n+    \/** This case covers [16, 2^63) bytes *\/\n+    @ForceInline\n+    private static void copy5AndUpwards(AbstractMemorySegmentImpl src,\n+                                        long srcOffset,\n+                                        MemorySessionImpl srcSession,\n+                                        AbstractMemorySegmentImpl dst,\n+                                        long dstOffset,\n+                                        MemorySessionImpl dstSession,\n+                                        long len) {\n+\n+        final int limit = (int) (len & (NATIVE_THRESHOLD_COPY - Long.BYTES));\n+        int offset = 0;\n+        for (; offset < limit; offset += Long.BYTES) {\n+            final long v = SCOPED_MEMORY_ACCESS.getLongUnaligned(srcSession, src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+            SCOPED_MEMORY_ACCESS.putLongUnaligned(dstSession, dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n@@ -157,0 +219,1 @@\n+        copy0through4(src, srcOffset + offset, srcSession, dst, dstOffset + offset, srcSession, len - offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":107,"deletions":44,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -85,0 +85,42 @@\n+\n+    @ForceInline\n+    public $type$ get$Type$Unaligned(MemorySessionImpl session, Object base, long offset) {\n+        try {\n+            return get$Type$UnalignedInternal(session, base, offset);\n+        } catch (ScopedAccessError ex) {\n+            throw ex.newRuntimeException();\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset) {\n+        try {\n+            if (session != null) {\n+                session.checkValidStateRaw();\n+            }\n+            return UNSAFE.get$Type$Unaligned(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(session);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$Unaligned(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$UnalignedInternal(session, base, offset, value);\n+        } catch (ScopedAccessError ex) {\n+            throw ex.newRuntimeException();\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+        try {\n+            if (session != null) {\n+                session.checkValidStateRaw();\n+            }\n+            UNSAFE.put$Type$Unaligned(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(session);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"24\", \"64\", \"512\",\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}