{"files":[{"patch":"@@ -39,0 +39,1 @@\n+class SATBMarkQueueSet;\n@@ -58,0 +59,8 @@\n+class ShenandoahFlushSATBHandshakeClosure : public HandshakeClosure {\n+private:\n+  SATBMarkQueueSet& _qset;\n+public:\n+  inline explicit ShenandoahFlushSATBHandshakeClosure(SATBMarkQueueSet& qset);\n+  inline void do_thread(Thread* thread) override;\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,0 +62,7 @@\n+ShenandoahFlushSATBHandshakeClosure::ShenandoahFlushSATBHandshakeClosure(SATBMarkQueueSet& qset) :\n+  HandshakeClosure(\"Shenandoah Flush SATB\"),\n+  _qset(qset) {}\n+\n+void ShenandoahFlushSATBHandshakeClosure::do_thread(Thread* thread) {\n+  _qset.flush_queue(ShenandoahThreadLocalData::satb_mark_queue(thread));\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -105,0 +105,10 @@\n+void ShenandoahConcurrentGC::entry_concurrent_update_refs_prepare(ShenandoahHeap* const heap) {\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  const char* msg = conc_init_update_refs_event_message();\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_update_refs_prepare);\n+  EventMark em(\"%s\", msg);\n+\n+  \/\/ Evacuation is complete, retire gc labs and change gc state\n+  heap->concurrent_prepare_for_update_refs();\n+}\n+\n@@ -194,2 +204,1 @@\n-    \/\/ Evacuation is complete, retire gc labs\n-    heap->concurrent_prepare_for_update_refs();\n+    entry_concurrent_update_refs_prepare(heap);\n@@ -218,13 +227,3 @@\n-    \/\/ We chose not to evacuate because we found sufficient immediate garbage.\n-    \/\/ However, there may still be regions to promote in place, so do that now.\n-    if (has_in_place_promotions(heap)) {\n-      entry_promote_in_place();\n-\n-      \/\/ If the promote-in-place operation was cancelled, we can have the degenerated\n-      \/\/ cycle complete the operation. It will see that no evacuations are in progress,\n-      \/\/ and that there are regions wanting promotion. The risk with not handling the\n-      \/\/ cancellation would be failing to restore top for these regions and leaving\n-      \/\/ them unable to serve allocations for the old generation.\n-      if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_evac)) {\n-        return false;\n-      }\n+    if (!entry_final_roots()) {\n+      assert(_degen_point != _degenerated_unset, \"Need to know where to start degenerated cycle\");\n+      return false;\n@@ -233,3 +232,3 @@\n-    \/\/ At this point, the cycle is effectively complete. If the cycle has been cancelled here,\n-    \/\/ the control thread will detect it on its next iteration and run a degenerated young cycle.\n-    vmop_entry_final_roots();\n+    if (VerifyAfterGC) {\n+      vmop_entry_verify_final_roots();\n+    }\n@@ -253,0 +252,46 @@\n+bool ShenandoahConcurrentGC::complete_abbreviated_cycle() {\n+  shenandoah_assert_generational();\n+\n+  ShenandoahGenerationalHeap* const heap = ShenandoahGenerationalHeap::heap();\n+\n+  \/\/ We chose not to evacuate because we found sufficient immediate garbage.\n+  \/\/ However, there may still be regions to promote in place, so do that now.\n+  if (heap->old_generation()->has_in_place_promotions()) {\n+    entry_promote_in_place();\n+\n+    \/\/ If the promote-in-place operation was cancelled, we can have the degenerated\n+    \/\/ cycle complete the operation. It will see that no evacuations are in progress,\n+    \/\/ and that there are regions wanting promotion. The risk with not handling the\n+    \/\/ cancellation would be failing to restore top for these regions and leaving\n+    \/\/ them unable to serve allocations for the old generation.This will leave the weak\n+    \/\/ roots flag set (the degenerated cycle will unset it).\n+    if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_evac)) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ At this point, the cycle is effectively complete. If the cycle has been cancelled here,\n+  \/\/ the control thread will detect it on its next iteration and run a degenerated young cycle.\n+  if (!_generation->is_old()) {\n+    heap->update_region_ages(_generation->complete_marking_context());\n+  }\n+\n+  if (!heap->is_concurrent_old_mark_in_progress()) {\n+    heap->concurrent_final_roots();\n+  } else {\n+    \/\/ Since the cycle was shortened for having enough immediate garbage, this will be\n+    \/\/ the last phase before concurrent marking of old resumes. We must be sure\n+    \/\/ that old mark threads don't see any pointers to garbage in the SATB queues. Even\n+    \/\/ though nothing was evacuated, overwriting unreachable weak roots with null may still\n+    \/\/ put pointers to regions that become trash in the SATB queues. The following will\n+    \/\/ piggyback flushing the thread local SATB queues on the same handshake that propagates\n+    \/\/ the gc state change.\n+    ShenandoahSATBMarkQueueSet& satb_queues = ShenandoahBarrierSet::satb_mark_queue_set();\n+    ShenandoahFlushSATBHandshakeClosure complete_thread_local_satb_buffers(satb_queues);\n+    heap->concurrent_final_roots(&complete_thread_local_satb_buffers);\n+    heap->old_generation()->concurrent_transfer_pointers_from_satb();\n+  }\n+  return true;\n+}\n+\n+\n@@ -293,1 +338,1 @@\n-void ShenandoahConcurrentGC::vmop_entry_final_roots() {\n+void ShenandoahConcurrentGC::vmop_entry_verify_final_roots() {\n@@ -349,2 +394,2 @@\n-void ShenandoahConcurrentGC::entry_final_roots() {\n-  const char* msg = final_roots_event_message();\n+void ShenandoahConcurrentGC::entry_verify_final_roots() {\n+  const char* msg = verify_final_roots_event_message();\n@@ -354,1 +399,1 @@\n-  op_final_roots();\n+  op_verify_final_roots();\n@@ -524,1 +569,1 @@\n-void ShenandoahConcurrentGC::entry_promote_in_place() {\n+void ShenandoahConcurrentGC::entry_promote_in_place() const {\n@@ -527,10 +572,3 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n-\n-  static const char* msg = \"Promote in place\";\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::promote_in_place);\n-  EventMark em(\"%s\", msg);\n-\n-  ShenandoahWorkerScope scope(heap->workers(),\n-                              ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),\n-                              \"promote in place\");\n+  ShenandoahTimingsTracker timing(ShenandoahPhaseTimings::promote_in_place);\n+  ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::promote_in_place);\n+  EventMark em(\"%s\", \"Promote in place\");\n@@ -663,0 +701,1 @@\n+    ShenandoahTimingsTracker v(ShenandoahPhaseTimings::init_mark_verify);\n@@ -751,0 +790,1 @@\n+        ShenandoahTimingsTracker v(ShenandoahPhaseTimings::final_mark_verify);\n@@ -767,0 +807,1 @@\n+        ShenandoahTimingsTracker v(ShenandoahPhaseTimings::final_mark_verify);\n@@ -1088,0 +1129,1 @@\n+    ShenandoahTimingsTracker v(ShenandoahPhaseTimings::init_update_refs_verify);\n@@ -1175,0 +1217,1 @@\n+    ShenandoahTimingsTracker v(ShenandoahPhaseTimings::final_update_refs_verify);\n@@ -1190,1 +1233,3 @@\n-void ShenandoahConcurrentGC::op_final_roots() {\n+bool ShenandoahConcurrentGC::entry_final_roots() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n@@ -1192,3 +1237,0 @@\n-  ShenandoahHeap *heap = ShenandoahHeap::heap();\n-  heap->set_concurrent_weak_root_in_progress(false);\n-  heap->set_evacuation_in_progress(false);\n@@ -1196,7 +1238,6 @@\n-  if (heap->mode()->is_generational()) {\n-    \/\/ If the cycle was shortened for having enough immediate garbage, this could be\n-    \/\/ the last GC safepoint before concurrent marking of old resumes. We must be sure\n-    \/\/ that old mark threads don't see any pointers to garbage in the SATB buffers.\n-    if (heap->is_concurrent_old_mark_in_progress()) {\n-      heap->old_generation()->transfer_pointers_from_satb();\n-    }\n+  const char* msg = conc_final_roots_event_message();\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_final_roots);\n+  EventMark em(\"%s\", msg);\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),\n+                              msg);\n@@ -1204,2 +1245,5 @@\n-    if (!_generation->is_old()) {\n-      ShenandoahGenerationalHeap::heap()->update_region_ages(_generation->complete_marking_context());\n+  if (!heap->mode()->is_generational()) {\n+    heap->concurrent_final_roots();\n+  } else {\n+    if (!complete_abbreviated_cycle()) {\n+      return false;\n@@ -1208,0 +1252,2 @@\n+  return true;\n+}\n@@ -1209,0 +1255,1 @@\n+void ShenandoahConcurrentGC::op_verify_final_roots() {\n@@ -1212,5 +1259,0 @@\n-\n-  {\n-    ShenandoahTimingsTracker timing(ShenandoahPhaseTimings::final_roots_propagate_gc_state);\n-    heap->propagate_gc_state_to_all_threads();\n-  }\n@@ -1303,1 +1345,9 @@\n-const char* ShenandoahConcurrentGC::final_roots_event_message() const {\n+const char* ShenandoahConcurrentGC::verify_final_roots_event_message() const {\n+  if (ShenandoahHeap::heap()->unload_classes()) {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Verify Final Roots\", \" (unload classes)\");\n+  } else {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Verify Final Roots\", \"\");\n+  }\n+}\n+\n+const char* ShenandoahConcurrentGC::conc_final_roots_event_message() const {\n@@ -1305,1 +1355,1 @@\n-    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Final Roots\", \" (unload classes)\");\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent Final Roots\", \" (unload classes)\");\n@@ -1307,1 +1357,1 @@\n-    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Final Roots\", \"\");\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent Final Roots\", \"\");\n@@ -1334,0 +1384,8 @@\n+\n+const char* ShenandoahConcurrentGC::conc_init_update_refs_event_message() const {\n+  if (ShenandoahHeap::heap()->unload_classes()) {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent Init Update Refs\", \" (unload classes)\");\n+  } else {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent Init Update Refs\", \"\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":112,"deletions":54,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -62,0 +63,2 @@\n+  void entry_concurrent_update_refs_prepare(ShenandoahHeap* heap);\n+\n@@ -72,1 +75,1 @@\n-  void vmop_entry_final_roots();\n+  void vmop_entry_verify_final_roots();\n@@ -80,1 +83,1 @@\n-  void entry_final_roots();\n+  void entry_verify_final_roots();\n@@ -99,0 +102,3 @@\n+  \/\/ This is the last phase of a cycle which performs no evacuations\n+  bool entry_final_roots();\n+\n@@ -100,1 +106,1 @@\n-  void entry_promote_in_place();\n+  void entry_promote_in_place() const;\n@@ -119,1 +125,2 @@\n-  void op_final_roots();\n+\n+  void op_verify_final_roots();\n@@ -132,1 +139,3 @@\n-  static bool has_in_place_promotions(ShenandoahHeap* heap) ;\n+  bool complete_abbreviated_cycle();\n+\n+  static bool has_in_place_promotions(ShenandoahHeap* heap);\n@@ -138,1 +147,2 @@\n-  const char* final_roots_event_message() const;\n+  const char* verify_final_roots_event_message() const;\n+  const char* conc_final_roots_event_message() const;\n@@ -145,0 +155,1 @@\n+  const char* conc_init_update_refs_event_message() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -215,13 +215,0 @@\n-class ShenandoahFlushSATBHandshakeClosure : public HandshakeClosure {\n-private:\n-  SATBMarkQueueSet& _qset;\n-public:\n-  ShenandoahFlushSATBHandshakeClosure(SATBMarkQueueSet& qset) :\n-    HandshakeClosure(\"Shenandoah Flush SATB\"),\n-    _qset(qset) {}\n-\n-  void do_thread(Thread* thread) {\n-    _qset.flush_queue(ShenandoahThreadLocalData::satb_mark_queue(thread));\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-  heap->prepare_update_heap_references(false \/*concurrent*\/);\n+  heap->prepare_update_heap_references();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1231,1 +1231,1 @@\n-class ShenandoahGCStatePropagator : public ThreadClosure {\n+class ShenandoahGCStatePropagator : public HandshakeClosure {\n@@ -1233,1 +1233,3 @@\n-  explicit ShenandoahGCStatePropagator(char gc_state) : _gc_state(gc_state) {}\n+  explicit ShenandoahGCStatePropagator(char gc_state) :\n+    HandshakeClosure(\"Shenandoah GC State Change\"),\n+    _gc_state(gc_state) {}\n@@ -1290,0 +1292,31 @@\n+class ShenandoahCompositeHandshakeClosure : public HandshakeClosure {\n+  HandshakeClosure* _handshake_1;\n+  HandshakeClosure* _handshake_2;\n+  public:\n+    ShenandoahCompositeHandshakeClosure(HandshakeClosure* handshake_1, HandshakeClosure* handshake_2) :\n+      HandshakeClosure(handshake_2->name()),\n+      _handshake_1(handshake_1), _handshake_2(handshake_2) {}\n+\n+  void do_thread(Thread* thread) override {\n+      _handshake_1->do_thread(thread);\n+      _handshake_2->do_thread(thread);\n+    }\n+};\n+\n+void ShenandoahHeap::concurrent_final_roots(HandshakeClosure* handshake_closure) {\n+  {\n+    assert(!is_evacuation_in_progress(), \"Should not evacuate for abbreviated or old cycles\");\n+    MutexLocker lock(Threads_lock);\n+    set_gc_state_concurrent(WEAK_ROOTS, false);\n+  }\n+\n+  ShenandoahGCStatePropagator propagator(_gc_state.raw_value());\n+  Threads::non_java_threads_do(&propagator);\n+  if (handshake_closure == nullptr) {\n+    Handshake::execute(&propagator);\n+  } else {\n+    ShenandoahCompositeHandshakeClosure composite(&propagator, handshake_closure);\n+    Handshake::execute(&composite);\n+  }\n+}\n+\n@@ -2003,1 +2036,1 @@\n-void ShenandoahHeap::prepare_update_heap_references(bool concurrent) {\n+void ShenandoahHeap::prepare_update_heap_references() {\n@@ -2010,3 +2043,1 @@\n-    ShenandoahGCPhase phase(concurrent ?\n-                            ShenandoahPhaseTimings::init_update_refs_manage_gclabs :\n-                            ShenandoahPhaseTimings::degen_gc_init_update_refs_manage_gclabs);\n+    ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_init_update_refs_manage_gclabs);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -481,1 +481,1 @@\n-  void prepare_update_heap_references(bool concurrent);\n+  void prepare_update_heap_references();\n@@ -486,0 +486,3 @@\n+  \/\/ Turn off weak roots flag, purge old satb buffers in generational mode\n+  void concurrent_final_roots(HandshakeClosure* handshake_closure = nullptr);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  vmop_entry_final_roots();\n+  heap->concurrent_final_roots();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -127,0 +126,27 @@\n+class ShenandoahTransferOldSATBTask : public WorkerTask {\n+  ShenandoahSATBMarkQueueSet&  _satb_queues;\n+  ShenandoahObjToScanQueueSet* _mark_queues;\n+  volatile size_t              _trashed_oops;\n+\n+public:\n+  explicit ShenandoahTransferOldSATBTask(ShenandoahSATBMarkQueueSet& satb_queues, ShenandoahObjToScanQueueSet* mark_queues) :\n+    WorkerTask(\"Transfer SATB\"),\n+    _satb_queues(satb_queues),\n+    _mark_queues(mark_queues),\n+    _trashed_oops(0) {}\n+\n+  ~ShenandoahTransferOldSATBTask() {\n+    if (_trashed_oops > 0) {\n+      log_debug(gc)(\"Purged %zu oops from old generation SATB buffers\", _trashed_oops);\n+    }\n+  }\n+\n+  void work(uint worker_id) override {\n+    ShenandoahObjToScanQueue* mark_queue = _mark_queues->queue(worker_id);\n+    ShenandoahProcessOldSATB processor(mark_queue);\n+    while (_satb_queues.apply_closure_to_completed_buffer(&processor)) {}\n+\n+    Atomic::add(&_trashed_oops, processor.trashed_oops());\n+  }\n+};\n+\n@@ -426,3 +452,2 @@\n-void ShenandoahOldGeneration::transfer_pointers_from_satb() {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  shenandoah_assert_safepoint();\n+void ShenandoahOldGeneration::concurrent_transfer_pointers_from_satb() const {\n+  const ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -431,2 +456,0 @@\n-  uint nworkers = heap->workers()->active_workers();\n-  StrongRootsScope scope(nworkers);\n@@ -434,0 +457,14 @@\n+  \/\/ Step 1. All threads need to 'complete' partially filled, thread local SATB buffers. This\n+  \/\/ is accomplished in ShenandoahConcurrentGC::complete_abbreviated_cycle using a Handshake\n+  \/\/ operation.\n+  \/\/ Step 2. Use worker threads to transfer oops from old, active regions in the completed\n+  \/\/ SATB buffers to old generation mark queues.\n+  ShenandoahSATBMarkQueueSet& satb_queues = ShenandoahBarrierSet::satb_mark_queue_set();\n+  ShenandoahTransferOldSATBTask transfer_task(satb_queues, task_queues());\n+  heap->workers()->run_task(&transfer_task);\n+}\n+\n+void ShenandoahOldGeneration::transfer_pointers_from_satb() const {\n+  const ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  assert(heap->is_concurrent_old_mark_in_progress(), \"Only necessary during old marking.\");\n+  log_debug(gc)(\"Transfer SATB buffers\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -235,1 +235,2 @@\n-  void transfer_pointers_from_satb();\n+  void transfer_pointers_from_satb() const;\n+  void concurrent_transfer_pointers_from_satb() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+    case promote_in_place:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  f(init_mark_verify,                               \"  Verify\")                        \\\n@@ -74,0 +75,1 @@\n+  f(final_mark_verify,                              \"  Verify\")                        \\\n@@ -110,4 +112,4 @@\n-  f(promote_in_place,                               \"Concurrent Promote Regions\")      \\\n-  f(final_roots_gross,                              \"Pause Final Roots (G)\")           \\\n-  f(final_roots,                                    \"Pause Final Roots (N)\")           \\\n-  f(final_roots_propagate_gc_state,                 \"  Propagate GC State\")            \\\n+  f(conc_final_roots,                               \"Concurrent Final Roots\")          \\\n+  f(promote_in_place,                               \"  Promote Regions\")               \\\n+  f(final_roots_gross,                              \"Pause Verify Final Roots (G)\")    \\\n+  f(final_roots,                                    \"Pause Verify Final Roots (N)\")    \\\n@@ -117,1 +119,1 @@\n-  f(init_update_refs_manage_gclabs,                 \"  Manage GCLABs\")                 \\\n+  f(init_update_refs_verify,                        \"  Verify\")                        \\\n@@ -119,0 +121,1 @@\n+  f(conc_update_refs_prepare,                       \"Concurrent Update Refs Prepare\")  \\\n@@ -124,1 +127,1 @@\n-  f(final_update_refs_finish_work,                  \"  Finish Work\")                   \\\n+  f(final_update_refs_verify,                       \"  Verify\")                        \\\n@@ -155,1 +158,0 @@\n-  f(degen_gc_final_update_refs_finish_work,         \"  Finish Work\")                   \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  _gc->entry_final_roots();\n+  _gc->entry_verify_final_roots();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}