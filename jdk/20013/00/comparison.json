{"files":[{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveHeapLoader.hpp\"\n+#include \"cds\/cdsEnumKlass.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+bool CDSEnumKlass::is_enum_obj(oop orig_obj) {\n+  Klass* k = orig_obj->klass();\n+  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(k);\n+  return k->is_instance_klass() &&\n+         InstanceKlass::cast(k)->java_super() == vmClasses::Enum_klass();\n+}\n+\n+\/\/ -- Handling of Enum objects\n+\/\/ Java Enum classes have synthetic <clinit> methods that look like this\n+\/\/     enum MyEnum {FOO, BAR}\n+\/\/     MyEnum::<clinint> {\n+\/\/        \/*static final MyEnum*\/ MyEnum::FOO = new MyEnum(\"FOO\");\n+\/\/        \/*static final MyEnum*\/ MyEnum::BAR = new MyEnum(\"BAR\");\n+\/\/     }\n+\/\/\n+\/\/ If MyEnum::FOO object is referenced by any of the archived subgraphs, we must\n+\/\/ ensure the archived value equals (in object address) to the runtime value of\n+\/\/ MyEnum::FOO.\n+\/\/\n+\/\/ However, since MyEnum::<clinint> is synthetically generated by javac, there's\n+\/\/ no way of programmatically handling this inside the Java code (as you would handle\n+\/\/ ModuleLayer::EMPTY_LAYER, for example).\n+\/\/\n+\/\/ Instead, we archive all static field of such Enum classes. At runtime,\n+\/\/ HeapShared::initialize_enum_klass() skips the <clinit> method and instead pulls\n+\/\/ the static fields out of the archived heap.\n+void CDSEnumKlass::handle_enum_obj(int level,\n+                                   KlassSubGraphInfo* subgraph_info,\n+                                   oop orig_obj) {\n+  assert(level > 1, \"must never be called at the first (outermost) level\");\n+  assert(is_enum_obj(orig_obj), \"must be\");\n+\n+  InstanceKlass* ik = InstanceKlass::cast(orig_obj->klass());\n+  if (ik->has_archived_enum_objs()) {\n+    return;\n+  }\n+\n+  ik->set_has_archived_enum_objs();\n+  ArchiveBuilder::get_buffered_klass(ik)->set_has_archived_enum_objs();\n+\n+  oop mirror = ik->java_mirror();\n+  for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      archive_static_field(level, subgraph_info, ik, mirror, fs);\n+    }\n+  }\n+}\n+\n+void CDSEnumKlass::archive_static_field(int level, KlassSubGraphInfo* subgraph_info,\n+                                        InstanceKlass* ik, oop mirror, JavaFieldStream& fs) {\n+  ResourceMark rm;\n+  fieldDescriptor& fd = fs.field_descriptor();\n+  if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n+    guarantee(false, \"static field %s::%s must be T_OBJECT or T_ARRAY\",\n+              ik->external_name(), fd.name()->as_C_string());\n+  }\n+  oop oop_field = mirror->obj_field(fd.offset());\n+  if (oop_field == nullptr) {\n+    guarantee(false, \"static field %s::%s must not be null\",\n+              ik->external_name(), fd.name()->as_C_string());\n+  } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n+    guarantee(false, \"static field %s::%s is of the wrong type\",\n+              ik->external_name(), fd.name()->as_C_string());\n+  }\n+  bool success = HeapShared::archive_reachable_objects_from(level, subgraph_info, oop_field);\n+  assert(success, \"VM should have exited with unarchivable objects for _level > 1\");\n+  int root_index = HeapShared::append_root(oop_field);\n+  log_info(cds, heap)(\"Archived enum obj @%d %s::%s (\" INTPTR_FORMAT \")\",\n+                      root_index, ik->external_name(), fd.name()->as_C_string(),\n+                      p2i((oopDesc*)oop_field));\n+  SystemDictionaryShared::add_enum_klass_static_field(ik, root_index);\n+}\n+\n+bool CDSEnumKlass::initialize_enum_klass(InstanceKlass* k, TRAPS) {\n+  if (!ArchiveHeapLoader::is_in_use()) {\n+    return false;\n+  }\n+\n+  RunTimeClassInfo* info = RunTimeClassInfo::get_for(k);\n+  assert(info != nullptr, \"sanity\");\n+\n+  if (log_is_enabled(Info, cds, heap)) {\n+    ResourceMark rm;\n+    log_info(cds, heap)(\"Initializing Enum class: %s\", k->external_name());\n+  }\n+\n+  oop mirror = k->java_mirror();\n+  int i = 0;\n+  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      int root_index = info->enum_klass_static_field_root_index_at(i++);\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      assert(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY, \"must be\");\n+      mirror->obj_field_put(fd.offset(), HeapShared::get_root(root_index, \/*clear=*\/true));\n+    }\n+  }\n+  return true;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_CDSENUMKLASS_HPP\n+#define SHARE_CDS_CDSENUMKLASS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class InstanceKlass;\n+class JavaFieldStream;\n+class KlassSubGraphInfo;\n+\n+class CDSEnumKlass: AllStatic {\n+public:\n+  static bool is_enum_obj(oop orig_obj);\n+  static void handle_enum_obj(int level,\n+                              KlassSubGraphInfo* subgraph_info,\n+                              oop orig_obj);\n+  static bool initialize_enum_klass(InstanceKlass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+\n+private:\n+  static void archive_static_field(int level, KlassSubGraphInfo* subgraph_info,\n+                                   InstanceKlass* ik, oop mirror, JavaFieldStream& fs);\n+};\n+\n+#endif \/\/ SHARE_CDS_CDSENUMKLASS_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/cdsEnumKlass.hpp\"\n@@ -454,89 +455,0 @@\n-\/\/ -- Handling of Enum objects\n-\/\/ Java Enum classes have synthetic <clinit> methods that look like this\n-\/\/     enum MyEnum {FOO, BAR}\n-\/\/     MyEnum::<clinint> {\n-\/\/        \/*static final MyEnum*\/ MyEnum::FOO = new MyEnum(\"FOO\");\n-\/\/        \/*static final MyEnum*\/ MyEnum::BAR = new MyEnum(\"BAR\");\n-\/\/     }\n-\/\/\n-\/\/ If MyEnum::FOO object is referenced by any of the archived subgraphs, we must\n-\/\/ ensure the archived value equals (in object address) to the runtime value of\n-\/\/ MyEnum::FOO.\n-\/\/\n-\/\/ However, since MyEnum::<clinint> is synthetically generated by javac, there's\n-\/\/ no way of programmatically handling this inside the Java code (as you would handle\n-\/\/ ModuleLayer::EMPTY_LAYER, for example).\n-\/\/\n-\/\/ Instead, we archive all static field of such Enum classes. At runtime,\n-\/\/ HeapShared::initialize_enum_klass() will skip the <clinit> method and pull\n-\/\/ the static fields out of the archived heap.\n-void HeapShared::check_enum_obj(int level,\n-                                KlassSubGraphInfo* subgraph_info,\n-                                oop orig_obj) {\n-  assert(level > 1, \"must never be called at the first (outermost) level\");\n-  Klass* k = orig_obj->klass();\n-  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(k);\n-  if (!k->is_instance_klass()) {\n-    return;\n-  }\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (ik->java_super() == vmClasses::Enum_klass() && !ik->has_archived_enum_objs()) {\n-    ResourceMark rm;\n-    ik->set_has_archived_enum_objs();\n-    buffered_k->set_has_archived_enum_objs();\n-    oop mirror = ik->java_mirror();\n-\n-    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n-      if (fs.access_flags().is_static()) {\n-        fieldDescriptor& fd = fs.field_descriptor();\n-        if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n-          guarantee(false, \"static field %s::%s must be T_OBJECT or T_ARRAY\",\n-                    ik->external_name(), fd.name()->as_C_string());\n-        }\n-        oop oop_field = mirror->obj_field(fd.offset());\n-        if (oop_field == nullptr) {\n-          guarantee(false, \"static field %s::%s must not be null\",\n-                    ik->external_name(), fd.name()->as_C_string());\n-        } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n-          guarantee(false, \"static field %s::%s is of the wrong type\",\n-                    ik->external_name(), fd.name()->as_C_string());\n-        }\n-        bool success = archive_reachable_objects_from(level, subgraph_info, oop_field);\n-        assert(success, \"VM should have exited with unarchivable objects for _level > 1\");\n-        int root_index = append_root(oop_field);\n-        log_info(cds, heap)(\"Archived enum obj @%d %s::%s (\" INTPTR_FORMAT \")\",\n-                            root_index, ik->external_name(), fd.name()->as_C_string(),\n-                            p2i((oopDesc*)oop_field));\n-        SystemDictionaryShared::add_enum_klass_static_field(ik, root_index);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ See comments in HeapShared::check_enum_obj()\n-bool HeapShared::initialize_enum_klass(InstanceKlass* k, TRAPS) {\n-  if (!ArchiveHeapLoader::is_in_use()) {\n-    return false;\n-  }\n-\n-  RunTimeClassInfo* info = RunTimeClassInfo::get_for(k);\n-  assert(info != nullptr, \"sanity\");\n-\n-  if (log_is_enabled(Info, cds, heap)) {\n-    ResourceMark rm;\n-    log_info(cds, heap)(\"Initializing Enum class: %s\", k->external_name());\n-  }\n-\n-  oop mirror = k->java_mirror();\n-  int i = 0;\n-  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n-    if (fs.access_flags().is_static()) {\n-      int root_index = info->enum_klass_static_field_root_index_at(i++);\n-      fieldDescriptor& fd = fs.field_descriptor();\n-      assert(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY, \"must be\");\n-      mirror->obj_field_put(fd.offset(), get_root(root_index, \/*clear=*\/true));\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -1244,1 +1156,3 @@\n-  check_enum_obj(level + 1, subgraph_info, orig_obj);\n+  if (CDSEnumKlass::is_enum_obj(orig_obj)) {\n+    CDSEnumKlass::handle_enum_obj(level + 1, subgraph_info, orig_obj);\n+  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":90,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -215,3 +215,0 @@\n-  static void check_enum_obj(int level, KlassSubGraphInfo* subgraph_info,\n-                             oop orig_obj);\n-\n@@ -431,1 +428,0 @@\n-  static bool initialize_enum_klass(InstanceKlass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsEnumKlass.hpp\"\n@@ -1579,1 +1580,1 @@\n-    bool initialized = HeapShared::initialize_enum_klass(this, CHECK);\n+    bool initialized = CDSEnumKlass::initialize_enum_klass(this, CHECK);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}