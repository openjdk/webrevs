{"files":[{"patch":"@@ -48,1 +48,1 @@\n-\/\/ - [lo, hi] is the same as [ulo, uhi], lo and hi are both >= 0 or both < 0\n+\/\/ - [lo, hi] is the same as [ulo, uhi], lo and hi are both >= 0 or both < 0.\n@@ -50,2 +50,3 @@\n-\/\/ being [lo, uhi] and [ulo, hi], lo and uhi are < 0 while ulo and hi are >= 0\n-\/\/ This class deals with each interval with both bounds being >= 0 or < 0\n+\/\/ being [lo, uhi] and [ulo, hi], lo and uhi are < 0 while ulo and hi are >= 0.\n+\/\/ This class deals with each interval with both bounds being >= 0 or < 0 in\n+\/\/ the signed domain.\n@@ -291,1 +292,2 @@\n-  \/\/ both < 0 or >= 0. The same for srange._hi and urange._ulo\n+  \/\/ both < 0 or >= 0. The same for srange._hi and urange._ulo. See TypeInt for\n+  \/\/ detailed explanation.\n@@ -293,0 +295,1 @@\n+    \/\/ This means that S(urange._lo) >= 0 and S(urange._hi) < 0\n@@ -294,0 +297,2 @@\n+      \/\/ This means that there should be no element in the interval\n+      \/\/ [min_S, S(urange._hi)], tighten urange._hi to max_S\n@@ -296,0 +301,2 @@\n+      \/\/ This means that there should be no element in the interval\n+      \/\/ [S(urange._lo), max_S], tighten urange._lo to min_S\n@@ -449,1 +456,1 @@\n-const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt) {\n+const Type* int_type_widen(const CT* new_type, const CT* old_type, const CT* limit_type) {\n@@ -453,2 +460,2 @@\n-  if (ot == nullptr) {\n-    return nt;\n+  if (old_type == nullptr) {\n+    return new_type;\n@@ -458,2 +465,2 @@\n-  if (int_type_equal(nt, ot)) {\n-    return ot;\n+  if (int_type_equal(new_type, old_type)) {\n+    return old_type;\n@@ -464,2 +471,2 @@\n-  if (int_type_subset(ot, nt)) {\n-    return ot;\n+  if (int_type_subset(old_type, new_type)) {\n+    return old_type;\n@@ -471,1 +478,1 @@\n-  if (!int_type_subset(nt, ot)) {\n+  if (!int_type_subset(new_type, old_type)) {\n@@ -476,2 +483,2 @@\n-  if (ot->singleton()) {\n-    return nt;\n+  if (old_type->singleton()) {\n+    return new_type;\n@@ -482,2 +489,2 @@\n-  if (nt->_widen > ot->_widen) {\n-    return nt;\n+  if (new_type->_widen > old_type->_widen) {\n+    return new_type;\n@@ -486,1 +493,1 @@\n-  if (nt->_widen < Type::WidenMax) {\n+  if (new_type->_widen < Type::WidenMax) {\n@@ -488,2 +495,2 @@\n-    TypeIntPrototype<S, U> prototype{{nt->_lo, nt->_hi}, {nt->_ulo, nt->_uhi}, nt->_bits};\n-    return CT::try_make(prototype, nt->_widen + 1);\n+    TypeIntPrototype<S, U> prototype{{new_type->_lo, new_type->_hi}, {new_type->_ulo, new_type->_uhi}, new_type->_bits};\n+    return CT::try_make(prototype, new_type->_widen + 1);\n@@ -498,9 +505,9 @@\n-  U zeros = nt->_bits._zeros;\n-  U ones = nt->_bits._ones;\n-  if (lt != nullptr) {\n-    min = lt->_lo;\n-    max = lt->_hi;\n-    umin = lt->_ulo;\n-    umax = lt->_uhi;\n-    zeros |= lt->_bits._zeros;\n-    ones |= lt->_bits._ones;\n+  U zeros = new_type->_bits._zeros;\n+  U ones = new_type->_bits._ones;\n+  if (limit_type != nullptr) {\n+    min = limit_type->_lo;\n+    max = limit_type->_hi;\n+    umin = limit_type->_ulo;\n+    umax = limit_type->_uhi;\n+    zeros |= limit_type->_bits._zeros;\n+    ones |= limit_type->_bits._ones;\n@@ -511,2 +518,2 @@\n-template const Type* int_type_widen(const TypeInt* nt, const TypeInt* ot, const TypeInt* lt);\n-template const Type* int_type_widen(const TypeLong* nt, const TypeLong* ot, const TypeLong* lt);\n+template const Type* int_type_widen(const TypeInt* new_type, const TypeInt* old_type, const TypeInt* limit_type);\n+template const Type* int_type_widen(const TypeLong* new_type, const TypeLong* old_type, const TypeLong* limit_type);\n@@ -518,1 +525,1 @@\n-const Type* int_type_narrow(const CT* nt, const CT* ot) {\n+const Type* int_type_narrow(const CT* new_type, const CT* old_type) {\n@@ -522,2 +529,2 @@\n-  if (nt->singleton() || ot == nullptr) {\n-    return nt;\n+  if (new_type->singleton() || old_type == nullptr) {\n+    return new_type;\n@@ -527,2 +534,2 @@\n-  if (int_type_equal(nt, ot)) {\n-    return ot;\n+  if (int_type_equal(new_type, old_type)) {\n+    return old_type;\n@@ -532,2 +539,2 @@\n-  if (int_type_equal(ot, CT::TYPE_DOMAIN)) {\n-    return nt;\n+  if (int_type_equal(old_type, CT::TYPE_DOMAIN)) {\n+    return new_type;\n@@ -537,2 +544,2 @@\n-  if (!int_type_subset(ot, nt)) {\n-    return nt;\n+  if (!int_type_subset(old_type, new_type)) {\n+    return new_type;\n@@ -542,2 +549,2 @@\n-  if (ot->_bits._zeros != nt->_bits._zeros || ot->_bits._ones != nt->_bits._ones) {\n-    return nt;\n+  if (old_type->_bits._zeros != new_type->_bits._zeros || old_type->_bits._ones != new_type->_bits._ones) {\n+    return new_type;\n@@ -547,5 +554,5 @@\n-  U oc = cardinality_from_bounds(RangeInt<S>{ot->_lo, ot->_hi},\n-                                 RangeInt<U>{ot->_ulo, ot->_uhi});\n-  U nc = cardinality_from_bounds(RangeInt<S>{nt->_lo, nt->_hi},\n-                                 RangeInt<U>{nt->_ulo, nt->_uhi});\n-  return (nc > (oc >> 1) + (SMALLINT * 2)) ? ot : nt;\n+  U oc = cardinality_from_bounds(RangeInt<S>{old_type->_lo, old_type->_hi},\n+                                 RangeInt<U>{old_type->_ulo, old_type->_uhi});\n+  U nc = cardinality_from_bounds(RangeInt<S>{new_type->_lo, new_type->_hi},\n+                                 RangeInt<U>{new_type->_ulo, new_type->_uhi});\n+  return (nc > (oc >> 1) + (SMALLINT * 2)) ? old_type : new_type;\n@@ -553,2 +560,2 @@\n-template const Type* int_type_narrow(const TypeInt* nt, const TypeInt* ot);\n-template const Type* int_type_narrow(const TypeLong* nt, const TypeLong* ot);\n+template const Type* int_type_narrow(const TypeInt* new_type, const TypeInt* old_type);\n+template const Type* int_type_narrow(const TypeLong* new_type, const TypeLong* old_type);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":55,"deletions":48,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  return urange._hi - U(srange._lo) + U(srange._hi) - urange._lo + 1;\n+  return (urange._hi - U(srange._lo)) + (U(srange._hi) - urange._lo) + 1;\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1633,4 +1633,0 @@\n-bool TypeInt::properly_contains(const TypeInt* t) const {\n-  return int_type_subset(this, t) && !int_type_equal(this, t);\n-}\n-\n@@ -1761,4 +1757,0 @@\n-bool TypeLong::properly_contains(const TypeLong* t) const {\n-  return int_type_subset(this, t) && !int_type_equal(this, t);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -583,5 +583,63 @@\n-\n-\n-\/\/------------------------------TypeInt----------------------------------------\n-\/\/ Class of integer ranges, the set of integers between a lower bound and an\n-\/\/ upper bound, inclusive.\n+\/**\n+ * Definition:\n+ *\n+ * A TypeInt represents a set of jint values. An jint v is an element of a\n+ * TypeInt iff:\n+ *\n+ * v >= _lo && v <= _hi && juint(v) >= _ulo && juint(v) <= _uhi && _bits.is_satisfied_by(v)\n+ *\n+ * Multiple set of parameters can represent the same set.\n+ * E.g: consider 2 TypeInt t1, t2\n+ *\n+ * t1._lo = 2, t1._hi = 7, t1._ulo = 0, t1._uhi = 5, t1._bits._zeros = 0x0, t1._bits._ones = 0x1\n+ * t2._lo = 3, t2._hi = 5, t2._ulo = 3, t2._uhi = 5, t2._bits._zeros = 0xFFFFFFF8, t2._bits._ones = 0x1\n+ *\n+ * Then, t1 and t2 both represent the set {3, 5}. We can also see that the\n+ * constraints of t2 are optimal. I.e there exists no TypeInt t3 which also\n+ * represents {3, 5} such that:\n+ *\n+ * t3._lo > t2._lo || t3._hi < t2._hi || t3._ulo > t2._ulo || t3._uhi < t2._uhi ||\n+ *     (t3._bits._zeros & t2._bis._zeros) != t3._bits._zeros || (t3._bits._ones & t2._bits._ones) != t3._bits._ones\n+ *\n+ * The last 2 conditions mean that the bits in t3._bits._zeros is not a subset\n+ * of those in t2._bits._zeros, the same applies to _bits._ones\n+ *\n+ * As a result, every TypeInt is canonicalized to its optimal form upon\n+ * construction. This makes it easier to reason about them in optimizations.\n+ * E.g a TypeInt t with t._lo < 0 will definitely contain negative values. It\n+ * also makes it trivial to determine if a TypeInt instance is a subset of\n+ * another.\n+ *\n+ * Properties:\n+ *\n+ * 1. Since every TypeInt instance is canonicalized, all the bounds must also\n+ * be elements of such TypeInt. Or else, we can tighted the bounds by narrowing\n+ * it by one, which contradicts the assumption of the TypeInt being canonical.\n+ *\n+ * 2. Either _lo == jint(_lo) and _hi == jint(_uhi), or all elements of a\n+ * TypeInt lie in the intervals [_lo, jint(_uhi)] or [jint(_ulo), _hi]\n+ *\n+ * Proof: For 2 jint value x, y such that they are both >= 0 or < 0. Then:\n+ *\n+ * x <= y iff juint(x) <= juint(y)\n+ *\n+ * Then, we have:\n+ *\n+ * For a TypeInt t, there are 3 possible cases:\n+ *\n+ * a. t._lo >= 0. Since 0 <= t._lo <= jint(t._ulo), we have:\n+ *\n+ * juint(t._lo) <= juint(jint(t._ulo)) == t._ulo <= juint(t._lo)\n+ *\n+ * Which means that t._lo == jint(t._ulo). Similarly, t._hi == jint(t._uhi).\n+ *\n+ * b. t._hi < 0. Similarly, t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n+ *\n+ * c. t._lo < 0, t._hi >= 0. Then jint(t._ulo) >= 0 and jint(t._uhi) < 0. In\n+ * this case, all elements of t belongs to either [t._lo, jint(t._uhi)] or\n+ * [jint(t._ulo), t._hi].\n+ *\n+ * This property is useful for our analysis of TypeInt values. Additionally, it\n+ * can be seen that _lo and jint(_uhi) are both < 0 or >= 0, and the same\n+ * applies to jint(_ulo) and _hi.\n+ *\/\n@@ -620,2 +678,0 @@\n-  \/\/ Excluding the cases where this and t are the same\n-  bool properly_contains(const TypeInt* t) const;\n@@ -666,4 +722,1 @@\n-\n-\/\/------------------------------TypeLong---------------------------------------\n-\/\/ Class of long integer ranges, the set of integers between a lower bound and\n-\/\/ an upper bound, inclusive.\n+\/\/ Similar to TypeInt\n@@ -703,2 +756,0 @@\n-  \/\/ Excluding the cases where this and t are the same\n-  bool properly_contains(const TypeLong* t) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":64,"deletions":13,"binary":false,"changes":77,"status":"modified"}]}