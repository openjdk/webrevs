{"files":[{"patch":"@@ -242,10 +242,3 @@\n-    - lo[x] satisfies bits for 0 <= x < i\n-    - zeros[i] = 0\n-    - lo[i] = 0\n-\n-    Call j the largest value such that lo[x] satisfies bits for 0 <= x < j. This\n-    means that j is the smallest value such that lo[j] does not satisfy bits. We\n-    call this the first violation. i then can be computed as the largest value\n-    <= j such that:\n-\n-    zeros[i] == lo[i] == 0\n+    - lo[x] satisfies bits for 0 <= x < i (3.1)\n+    - zeros[i] = 0                        (3.2)\n+    - lo[i] = 0                           (3.3)\n@@ -262,2 +255,12 @@\n-    \/\/ ones is 1, the same bit in zeros is 0. Which means this is the value of\n-    \/\/ i we are looking for.\n+    \/\/ ones is 1, the same bit in zeros is 0.\n+    \/\/\n+    \/\/ From section 3 above, we know i is the largest bit index such that:\n+    \/\/ - lo[x] satisfies bits for 0 <= x < i (3.1)\n+    \/\/ - zeros[i] = 0                        (3.2)\n+    \/\/ - lo[i] = 0                           (3.3)\n+    \/\/\n+    \/\/ For the given i, we know that lo satisfies all bits before i, hence (3.1)\n+    \/\/ holds. Further, lo[i] = 0 (3.3), and we have a one violation at i, hence\n+    \/\/ zero[i] = 0 (3.2). Any smaller i would not be the largest possible such\n+    \/\/ index. Any larger i would violate (3.1), since lo[i] does not satisfy bits.\n+    \/\/ As a result, the first violation is the bit i we are looking for.\n@@ -284,1 +287,1 @@\n-    \/\/ up to this modulo\n+    \/\/ up to a multiple of this modulo.\n@@ -289,1 +292,1 @@\n-    \/\/ operation to align a value up to a certain power of 2.\n+    \/\/ operation to align a value up to a multiple of a certain power of 2.\n@@ -297,0 +300,7 @@\n+    \/\/ Note that this computation cannot overflow as the bit in lo that is at\n+    \/\/ the same position as the only bit 1 in alignment must be 0. As a result,\n+    \/\/ this operation just set that bit to 1 and set all the bits after to 0.\n+    \/\/ We now have:\n+    \/\/ - new_lo[x] = lo[x], for 0 <= x < i (2.5)\n+    \/\/ - new_lo[i] = 1                     (2.6)\n+    \/\/ - new_lo[x] = 0, for x > i          (not yet 2.7)\n@@ -299,2 +309,8 @@\n-    \/\/ Our current new_lo satisfies zeros, just OR it with ones to obtain the\n-    \/\/ correct result\n+    \/\/ Note that there exists no value x not larger than i such that\n+    \/\/ new_lo[x] == 0 and ones[x] == 1. This is because all bits of lo before i\n+    \/\/ should satisfy bits, and new_lo[i] == 1. As a result, doing\n+    \/\/ new_lo |= bits.ones will give us a value such that:\n+    \/\/ - new_lo[x] = lo[x], for 0 <= x < i (2.5)\n+    \/\/ - new_lo[i] = 1                     (2.6)\n+    \/\/ - new_lo[x] = ones[x], for x > i    (2.7)\n+    \/\/ This is the result we are looking for.\n@@ -304,3 +320,1 @@\n-    \/\/ a value not less than lo and satisfies bits. This is because there is\n-    \/\/ always a bit up to first_violation that is 0 in both lo and zeros\n-    \/\/ (trivially, it is the bit at first_violation).\n+    \/\/ a value not less than lo and satisfies bits.\n@@ -312,3 +326,13 @@\n-    \/\/ is a 1 that should be a 0. Trace backward to find the first bit we can\n-    \/\/ flip from 0 to 1 (i in the formality section above), which is the last\n-    \/\/ bit that is 0 in both lo and zeros.\n+    \/\/ is a 1 that should be a 0.\n+    \/\/\n+    \/\/ From section 3 above, we know i is the largest bit index such that:\n+    \/\/ - lo[x] satisfies bits for 0 <= x < i (3.1)\n+    \/\/ - zeros[i] = 0                        (3.2)\n+    \/\/ - lo[i] = 0                           (3.3)\n+    \/\/\n+    \/\/ We know that lo satisfies all bits before first_violation, hence (3.1)\n+    \/\/ holds. However, first_violation is not the value i we are looking for\n+    \/\/ because lo[first_violation] == 1. We can also see that any larger value\n+    \/\/ of i would violate 3.1 since lo[first_violation] does not satisfy bits.\n+    \/\/ As a result, we should find the last i upto first_violation such that\n+    \/\/ lo[i] == zeros[i] == 0.\n@@ -335,1 +359,1 @@\n-    \/\/ This mask out all bits after the first violation\n+    \/\/ This masks out all bits after the first violation\n@@ -342,1 +366,3 @@\n-    \/\/ in both lo and zeros\n+    \/\/ in both lo and zeros. Note that there may not exist such bits. In those\n+    \/\/ cases tmp == 0 and there is no value not less than lo and satisfies\n+    \/\/ bits. We will expand the implication of such cases below.\n@@ -345,4 +371,6 @@\n-    \/\/ i is the last bit being 0 in both lo and zeros that is up to the first\n-    \/\/ violation, which is the last set bit of tmp. i == 2 here, we want to\n-    \/\/ obtain the value with only the bit i set, this is equivalent to\n-    \/\/ extracting the last set bit of tmp, do it directly without going through i\n+    \/\/ According to the conclusion in the overview of this case above, i is the\n+    \/\/ last bit being 0 in both lo and zeros that is upto the first violation,\n+    \/\/ which is the last set bit of tmp.\n+    \/\/ In our example, i == 2 here, we want to obtain the value with only the\n+    \/\/ bit i set, this is equivalent to extracting the last set bit of tmp, do\n+    \/\/ it directly without going through i.\n@@ -353,1 +381,6 @@\n-    \/\/ similar to aligning lo upto alignment\n+    \/\/ similar to aligning lo upto alignment. Also similar to the above case,\n+    \/\/ this computation cannot overflow.\n+    \/\/ We now have:\n+    \/\/ - new_lo[x] = lo[x], for 0 <= x < i (2.5)\n+    \/\/ - new_lo[i] = 1                     (2.6)\n+    \/\/ - new_lo[x] = 0, for x > i          (not yet 2.7)\n@@ -356,1 +389,8 @@\n-    \/\/ Satisfy bits._ones\n+    \/\/ Note that there exists no value x not larger than i such that\n+    \/\/ new_lo[x] == 0 and ones[x] == 1. This is because all bits of lo before i\n+    \/\/ should satisfy bits, and new_lo[i] == 1. As a result, doing\n+    \/\/ new_lo |= bits.ones will give us a value such that:\n+    \/\/ - new_lo[x] = lo[x], for 0 <= x < i (2.5)\n+    \/\/ - new_lo[i] = 1                     (2.6)\n+    \/\/ - new_lo[x] = ones[x], for x > i    (2.7)\n+    \/\/ This is the result we are looking for.\n@@ -360,1 +400,1 @@\n-    \/\/ if there is no bit up to first_violation that is 0 in both lo and zeros,\n+    \/\/ if there is no bit upto first_violation that is 0 in both lo and zeros,\n@@ -363,0 +403,7 @@\n+    \/\/ Note: it can be seen as an overflow because we can say that the\n+    \/\/ computation of tmp above results in 0b...1100..00 with W trailing 0s.\n+    \/\/ As a result, alignment should be 0b100...00 with W trailing 0s. This\n+    \/\/ overflows the W-bit arithmetic and we obtain the value alignment == 0.\n+    \/\/ We can say that the algorithm should round up lo to a multiple of 2**W.\n+    \/\/ This overflows and the highest bit is discarded, leaving us with the\n+    \/\/ result of rounding up being 0.\n@@ -416,5 +463,5 @@\n-  \/\/ larger than hi and k satisfies {bits._zeros, bits._ones}. As a result, ~k\n-  \/\/ would satisfy {bits._ones, bits._zeros}. And since bitwise-not is a\n-  \/\/ strictly decreasing function, given ~h < k <= hi, we have h > ~k >= ~hi.\n-  \/\/ This contradicts the assumption that h is the smallest value not smaller\n-  \/\/ than ~hi and satisfies {bits._ones, bits._zeros}.\n+  \/\/ larger than hi, i.e. ~h < k <= hi, and k satisfies {bits._zeros, bits._ones}.\n+  \/\/ As a result, ~k would satisfy {bits._ones, bits._zeros}. And since bitwise-not\n+  \/\/ is a strictly decreasing function, given ~h < k <= hi, we have h > ~k >= ~hi.\n+  \/\/ This contradicts the assumption that h is the smallest value not smaller than\n+  \/\/ ~hi and satisfies {bits._ones, bits._zeros}.\n@@ -424,2 +471,2 @@\n-  U new_hi = ~adjust_lo(~bounds._hi, {bits._ones, bits._zeros});\n-  if (new_hi > bounds._hi) {\n+  U h = adjust_lo(~bounds._hi, {bits._ones, bits._zeros});\n+  if (h < ~bounds._hi) {\n@@ -429,0 +476,1 @@\n+  U new_hi = ~h;\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":86,"deletions":38,"binary":false,"changes":124,"status":"modified"}]}