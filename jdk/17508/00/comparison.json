{"files":[{"patch":"@@ -991,2 +991,2 @@\n-    const TypeInt* t1x = TypeInt::make(0, round_down_power_of_2(t1i->_hi) + (round_down_power_of_2(t1i->_hi) - 1), t1i->_widen);\n-    const TypeInt* t2x = TypeInt::make(0, round_down_power_of_2(t2i->_hi) + (round_down_power_of_2(t2i->_hi) - 1), t2i->_widen);\n+    const Type* t1x = TypeInt::make(0, round_down_power_of_2(t1i->_hi) + (round_down_power_of_2(t1i->_hi) - 1), t1i->_widen);\n+    const Type* t2x = TypeInt::make(0, round_down_power_of_2(t2i->_hi) + (round_down_power_of_2(t2i->_hi) - 1), t2i->_widen);\n@@ -1076,2 +1076,2 @@\n-    const TypeLong* t1x = TypeLong::make(0, round_down_power_of_2(t1l->_hi) + (round_down_power_of_2(t1l->_hi) - 1), t1l->_widen);\n-    const TypeLong* t2x = TypeLong::make(0, round_down_power_of_2(t2l->_hi) + (round_down_power_of_2(t2l->_hi) - 1), t2l->_widen);\n+    const Type* t1x = TypeLong::make(0, round_down_power_of_2(t1l->_hi) + (round_down_power_of_2(t1l->_hi) - 1), t1l->_widen);\n+    const Type* t2x = TypeLong::make(0, round_down_power_of_2(t2l->_hi) + (round_down_power_of_2(t2l->_hi) - 1), t2l->_widen);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,1 +324,1 @@\n-        const TypeInt* ti = TypeInt::make(checked_cast<jint>(tl->_lo), checked_cast<jint>(tl->_hi), tl->_widen);\n+        const TypeInt* ti = TypeInt::make(checked_cast<jint>(tl->_lo), checked_cast<jint>(tl->_hi), tl->_widen)->is_int();\n@@ -476,1 +476,5 @@\n-  const TypeInteger* this_type = this->type()->is_integer(bt);\n+  const TypeInteger* this_type = this->type()->isa_integer(bt);\n+  if (this_type == nullptr) {\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4500,2 +4500,4 @@\n-  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n-  const TypeInt* iidxtype = TypeInt::make(0, index_max, Type::WidenMax);\n+  if (sizetype != nullptr && sizetype->_hi > 0) {\n+    index_max = sizetype->_hi - 1;\n+  }\n+  const TypeInt* iidxtype = TypeInt::make(0, index_max, Type::WidenMax)->is_int();\n@@ -4518,1 +4520,1 @@\n-  const TypeLong* ltype = TypeLong::make(itype->_lo, itype->_hi, itype->_widen);\n+  const TypeLong* ltype = TypeLong::make(itype->_lo, itype->_hi, itype->_widen)->is_long();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -910,2 +910,2 @@\n-  inline Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n-                                       int idx, bool can_grow = false);\n+  Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n+                                int idx, bool can_grow = false);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -651,2 +651,2 @@\n-  rx = TypeInteger::make(rxlo, rxhi, widen, out_bt);\n-  ry = TypeInteger::make(rylo, ryhi, widen, out_bt);\n+  rx = TypeInteger::make(rxlo, rxhi, widen, out_bt)->is_integer(out_bt);\n+  ry = TypeInteger::make(rylo, ryhi, widen, out_bt)->is_integer(out_bt);\n@@ -794,1 +794,1 @@\n-    ti = TypeInt::make((jint)tl->_lo, (jint)tl->_hi, tl->_widen);\n+    ti = TypeInt::make((jint)tl->_lo, (jint)tl->_hi, tl->_widen)->is_int();\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -3869,2 +3869,4 @@\n-      if (size_max > tilen->_hi)  size_max = tilen->_hi;\n-      const TypeInt* tlcon = TypeInt::make(0, size_max, Type::WidenMin);\n+      if (size_max > tilen->_hi && tilen->_hi >= 0) {\n+        size_max = tilen->_hi;\n+      }\n+      const TypeInt* tlcon = TypeInt::make(0, size_max, Type::WidenMin)->is_int();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -645,1 +645,1 @@\n-                  return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen);\n+                  return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen)->is_int();\n@@ -647,1 +647,1 @@\n-                  return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen);\n+                  return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen)->is_int();\n@@ -677,1 +677,1 @@\n-            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen);\n+            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen)->is_int();\n@@ -1017,2 +1017,1 @@\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->_lo > failtype->_hi) {\n+        if (failtype->filter(type2) == Type::TOP) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -821,1 +821,1 @@\n-      idx_type = TypeInt::make(limit_lo - stride, limit_hi - stride, limit_type->_widen);\n+      idx_type = TypeInt::make(limit_lo - stride, limit_hi - stride, limit_type->_widen)->is_int();\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-  const TypeLong* lidxtype = TypeLong::make(CONST64(0), index_max, Type::WidenMax);\n+  const TypeLong* lidxtype = TypeLong::make(CONST64(0), index_max, Type::WidenMax)->is_long();\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1400,1 +1400,1 @@\n-    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n+    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen))->is_int();\n@@ -1470,1 +1470,1 @@\n-    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n+    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen))->is_long();\n@@ -1656,1 +1656,1 @@\n-    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n+    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen))->is_int();\n@@ -1803,1 +1803,1 @@\n-    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n+    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen))->is_long();\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,536 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n+\n+constexpr juint SMALLINT = 3;  \/\/ a value too insignificant to consider widening\n+\n+template <class T>\n+static bool adjust_bounds_from_bits(bool& empty, T& lo, T& hi, T zeros, T ones) {\n+  static_assert(std::is_unsigned<T>::value, \"\");\n+\n+  auto adjust_lo = [](T lo, T zeros, T ones) {\n+    constexpr size_t W = sizeof(T) * 8;\n+    T zero_violation = lo & zeros;\n+    T one_violation = ~lo & ones;\n+    if (zero_violation == 0 && one_violation == 0) {\n+      return lo;\n+    }\n+\n+    if (zero_violation < one_violation) {\n+      \/\/ Align the last violation of ones unset all the lower bits\n+      \/\/ so we don't care about violations of zeros\n+      juint last_violation = W - 1 - count_leading_zeros(one_violation);\n+      T alignment = T(1) << last_violation;\n+      lo = (lo & -alignment) + alignment;\n+      return lo | ones;\n+    }\n+\n+    \/\/ Suppose lo = 00110010, zeros = 01010010, ones = 10001000\n+    \/\/ Since the 4-th bit must be 0, we need to align up the lower bound.\n+    \/\/ This results in lo = 01000000, but then the 6-th bit does not match,\n+    \/\/ align up again gives us 10000000.\n+    \/\/ We can align up directly to 10000000 by finding the first place after\n+    \/\/ the highest mismatch such that both the corresponding bits are unset.\n+    \/\/ Since all bits lower than the alignment are unset we don't need to\n+    \/\/ align for the violations of ones anymore.\n+    juint last_violation = W - 1 - count_leading_zeros(zero_violation);\n+    T find_mask = std::numeric_limits<T>::max() << last_violation;\n+    T either = lo | zeros;\n+    T tmp = ~either & find_mask;\n+    T alignment = tmp & (-tmp);\n+    lo = (lo & -alignment) + alignment;\n+    return lo | ones;\n+  };\n+\n+  T new_lo = adjust_lo(lo, zeros, ones);\n+  if (new_lo < lo) {\n+    empty = true;\n+    return true;\n+  }\n+\n+  T new_hi = ~adjust_lo(~hi, ones, zeros);\n+  if (new_hi > hi) {\n+    empty = true;\n+    return true;\n+  }\n+  bool progress = (new_lo != lo) || (new_hi != hi);\n+  lo = new_lo;\n+  hi = new_hi;\n+  empty = lo > hi;\n+  return progress;\n+}\n+\n+template <class T>\n+static bool adjust_bits_from_bounds(bool& empty, T& zeros, T& ones, T lo, T hi) {\n+  static_assert(std::is_unsigned<T>::value, \"\");\n+  T mismatch = lo ^ hi;\n+  T match_mask = mismatch == 0 ? std::numeric_limits<T>::max()\n+                               : ~(std::numeric_limits<T>::max() >> count_leading_zeros(mismatch));\n+  T new_zeros = zeros | (match_mask &~ lo);\n+  T new_ones = ones | (match_mask & lo);\n+  bool progress = (new_zeros != zeros) || (new_ones != ones);\n+  zeros = new_zeros;\n+  ones = new_ones;\n+  empty = ((zeros & ones) != 0);\n+  return progress;\n+}\n+\n+template <class T>\n+static void normalize_constraints_simple(bool& empty, T& lo, T& hi, T& zeros, T& ones) {\n+  adjust_bits_from_bounds(empty, zeros, ones, lo, hi);\n+  if (empty) {\n+    return;\n+  }\n+  while (true) {\n+    bool progress = adjust_bounds_from_bits(empty, lo, hi, zeros, ones);\n+    if (!progress || empty) {\n+      return;\n+    }\n+    progress = adjust_bits_from_bounds(empty, zeros, ones, lo, hi);\n+    if (!progress || empty) {\n+      return;\n+    }\n+  }\n+}\n+\n+template <class T, class U>\n+void normalize_constraints(bool& empty, T& lo, T& hi, U& ulo, U& uhi, U& zeros, U& ones) {\n+  static_assert(std::is_signed<T>::value, \"\");\n+  static_assert(std::is_unsigned<U>::value, \"\");\n+  static_assert(sizeof(T) == sizeof(U), \"\");\n+\n+  if (lo > hi || ulo > uhi || (zeros & ones) != 0) {\n+    empty = true;\n+    return;\n+  }\n+\n+  if (T(ulo) > T(uhi)) {\n+    if (T(uhi) < lo) {\n+      uhi = std::numeric_limits<T>::max();\n+    } else if (T(ulo) > hi) {\n+      ulo = std::numeric_limits<T>::min();\n+    }\n+  }\n+\n+  if (T(ulo) <= T(uhi)) {\n+    ulo = MAX2<T>(ulo, lo);\n+    uhi = MIN2<T>(uhi, hi);\n+    if (ulo > uhi) {\n+      empty = true;\n+      return;\n+    }\n+\n+    normalize_constraints_simple(empty, ulo, uhi, zeros, ones);\n+    lo = ulo;\n+    hi = uhi;\n+    return;\n+  }\n+\n+  bool empty1 = false;\n+  U lo1 = lo;\n+  U hi1 = uhi;\n+  U zeros1 = zeros;\n+  U ones1 = ones;\n+  normalize_constraints_simple(empty1, lo1, hi1, zeros1, ones1);\n+\n+  bool empty2 = false;\n+  U lo2 = ulo;\n+  U hi2 = hi;\n+  U zeros2 = zeros;\n+  U ones2 = ones;\n+  normalize_constraints_simple(empty2, lo2, hi2, zeros2, ones2);\n+\n+  if (empty1 & empty2) {\n+    empty = true;\n+  } else if (empty1) {\n+    lo = lo2;\n+    hi = hi2;\n+    ulo = lo2;\n+    uhi = hi2;\n+    zeros = zeros2;\n+    ones = ones2;\n+  } else if (empty2) {\n+    lo = lo1;\n+    hi = hi1;\n+    ulo = lo1;\n+    uhi = hi1;\n+    zeros = zeros1;\n+    ones = ones1;\n+  } else {\n+    lo = lo1;\n+    hi = hi2;\n+    ulo = lo2;\n+    uhi = hi1;\n+    zeros = zeros1 & zeros2;\n+    ones = ones1 & ones2;\n+  }\n+}\n+template void normalize_constraints(bool& empty, jint& lo, jint& hi, juint& ulo, juint& uhi, juint& zeros, juint& ones);\n+template void normalize_constraints(bool& empty, jlong& lo, jlong& hi, julong& ulo, julong& uhi, julong& zeros, julong& ones);\n+\n+template <class T, class U>\n+void verify_constraints(T lo, T hi, U ulo, U uhi, U zeros, U ones) {\n+  static_assert(std::is_signed<T>::value, \"\");\n+  static_assert(std::is_unsigned<U>::value, \"\");\n+  static_assert(sizeof(T) == sizeof(U), \"\");\n+\n+  \/\/ Assert that the bounds cannot be further tightened\n+  assert(lo <= hi && U(lo) >= ulo && U(lo) <= uhi && (lo & zeros) == 0 && (~lo & ones) == 0, \"\");\n+  assert(hi >= lo && U(hi) >= ulo && U(hi) <= uhi && (hi & zeros) == 0 && (~hi & ones) == 0, \"\");\n+  assert(T(ulo) >= lo && T(ulo) <= hi && ulo <= uhi && (ulo & zeros) == 0 && (~ulo & ones) == 0, \"\");\n+  assert(T(uhi) >= lo && T(uhi) <= hi && uhi >= ulo && (uhi & zeros) == 0 && (~uhi & ones) == 0, \"\");\n+\n+  \/\/ Assert that the bits cannot be further tightened\n+  if (U(lo) == ulo) {\n+    bool empty = false;\n+    assert(!adjust_bits_from_bounds(empty, zeros, ones, ulo, uhi), \"\");\n+  } else {\n+    bool empty1 = false;\n+    U lo1 = lo;\n+    U hi1 = uhi;\n+    U zeros1 = zeros;\n+    U ones1 = ones;\n+    adjust_bits_from_bounds(empty1, zeros1, ones1, lo1, hi1);\n+    assert(!empty1, \"\");\n+    assert(!adjust_bounds_from_bits(empty1, lo1, hi1, zeros1, ones1), \"\");\n+\n+    bool empty2 = false;\n+    U lo2 = ulo;\n+    U hi2 = hi;\n+    U zeros2 = zeros;\n+    U ones2 = ones;\n+    adjust_bits_from_bounds(empty2, zeros2, ones2, lo2, hi2);\n+    assert(!empty2, \"\");\n+    assert(!adjust_bounds_from_bits(empty2, lo2, hi2, zeros2, ones2), \"\");\n+\n+    assert((zeros1 & zeros2) == zeros && (ones1 & ones2) == ones, \"\");\n+  }\n+}\n+template void verify_constraints(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones);\n+template void verify_constraints(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones);\n+\n+template <class T, class U>\n+int normalize_widen(T lo, T hi, U ulo, U uhi, U zeros, U ones, int w) {\n+  \/\/ Certain normalizations keep us sane when comparing types.\n+  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n+  if (cardinality_from_bounds(lo, hi, ulo, uhi) <= SMALLINT) {\n+    return Type::WidenMin;\n+  }\n+  if (lo == std::numeric_limits<T>::min() && hi == std::numeric_limits<T>::max() &&\n+      ulo == std::numeric_limits<U>::min() && uhi == std::numeric_limits<U>::max() &&\n+      zeros == 0 && ones == 0) {\n+    \/\/ bottom type\n+    return Type::WidenMax;\n+  }\n+  return w;\n+}\n+template int normalize_widen(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w);\n+template int normalize_widen(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w);\n+\n+template <class CT, class T, class UT>\n+const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(T, T, UT, UT, UT, UT, int, bool), bool dual) {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if (i1 == t2 || t2 == Type::TOP) {\n+    return i1;\n+  }\n+  const CT* i2 = CT::try_cast(t2);\n+  if (i2 != nullptr) {\n+    if (!dual) {\n+    \/\/ meet\n+      return make(MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi), MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi),\n+                  i1->_zeros & i2->_zeros, i1->_ones & i2->_ones, MAX2(i1->_widen, i2->_widen), false);\n+    }\n+    \/\/ join\n+    return make(MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi), MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi),\n+                i1->_zeros | i2->_zeros, i1->_ones | i2->_ones, MIN2(i1->_widen, i2->_widen), true);\n+  }\n+\n+  assert(t2->base() != i1->base(), \"\");\n+  switch (t2->base()) {          \/\/ Switch on original type\n+  case Type::AnyPtr:                  \/\/ Mixing with oops happens when javac\n+  case Type::RawPtr:                  \/\/ reuses local variables\n+  case Type::OopPtr:\n+  case Type::InstPtr:\n+  case Type::AryPtr:\n+  case Type::MetadataPtr:\n+  case Type::KlassPtr:\n+  case Type::InstKlassPtr:\n+  case Type::AryKlassPtr:\n+  case Type::NarrowOop:\n+  case Type::NarrowKlass:\n+  case Type::Int:\n+  case Type::Long:\n+  case Type::FloatTop:\n+  case Type::FloatCon:\n+  case Type::FloatBot:\n+  case Type::DoubleTop:\n+  case Type::DoubleCon:\n+  case Type::DoubleBot:\n+  case Type::Bottom:                  \/\/ Ye Olde Default\n+    return Type::BOTTOM;\n+  default:                      \/\/ All else is a mistake\n+    i1->typerr(t2);\n+    return nullptr;\n+  }\n+}\n+template const Type* int_type_xmeet(const TypeInt* i1, const Type* t2,\n+                                    const Type* (*make)(jint, jint, juint, juint, juint, juint, int, bool), bool dual);\n+template const Type* int_type_xmeet(const TypeLong* i1, const Type* t2,\n+                                    const Type* (*make)(jlong, jlong, julong, julong, julong, julong, int, bool), bool dual);\n+\n+\/\/ Called in PhiNode::Value during CCP, monotically widen the value set, do so rigorously\n+\/\/ first, after WidenMax attempts, if the type has still not converged we speed up the\n+\/\/ convergence by abandoning the bounds\n+template <class CT>\n+const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+\n+  if (ot == nullptr) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no widening\n+  if (int_type_equal(nt, ot)) {\n+    return ot;\n+  }\n+\n+  \/\/ If old guy contains new, then we probably widened too far & dropped to\n+  \/\/ bottom. Return the wider fellow.\n+  if (int_type_subset(ot, nt)) {\n+    return ot;\n+  }\n+\n+  \/\/ Neither contains each other, weird?\n+  \/\/ fatal(\"Integer value range is not subset\");\n+  \/\/ return this;\n+  if (!int_type_subset(nt, ot)) {\n+    return CT::TYPE_DOMAIN;\n+  }\n+\n+  \/\/ If old guy was a constant, do not bother\n+  if (ot->singleton()) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy contains old, then we widened\n+  \/\/ If new guy is already wider than old, no widening\n+  if (nt->_widen > ot->_widen) {\n+    return nt;\n+  }\n+\n+  if (nt->_widen < Type::WidenMax) {\n+    \/\/ Returned widened new guy\n+    return CT::make(nt->_lo, nt->_hi, nt->_ulo, nt->_uhi, nt->_zeros, nt->_ones, nt->_widen + 1);\n+  }\n+\n+  \/\/ Speed up the convergence by abandoning the bounds, there are only a couple of bits so\n+  \/\/ they converge fast\n+  T min = std::numeric_limits<T>::min();\n+  T max = std::numeric_limits<T>::max();\n+  U umin = std::numeric_limits<U>::min();\n+  U umax = std::numeric_limits<U>::max();\n+  U zeros = nt->_zeros;\n+  U ones = nt->_ones;\n+  if (lt != nullptr) {\n+    min = lt->_lo;\n+    max = lt->_hi;\n+    umin = lt->_ulo;\n+    umax = lt->_uhi;\n+    zeros |= lt->_zeros;\n+    ones |= lt->_ones;\n+  }\n+  return CT::make(min, max, umin, umax, zeros, ones, Type::WidenMax);\n+}\n+template const Type* int_type_widen(const TypeInt* nt, const TypeInt* ot, const TypeInt* lt);\n+template const Type* int_type_widen(const TypeLong* nt, const TypeLong* ot, const TypeLong* lt);\n+\n+\/\/ Called by PhiNode::Value during GVN, monotonically narrow the value set, only\n+\/\/ narrow if the bits change or if the bounds are tightened enough to avoid\n+\/\/ slow convergence\n+template <class CT>\n+const Type* int_type_narrow(const CT* nt, const CT* ot) {\n+  using T = decltype(CT::_lo);\n+  using U = decltype(CT::_ulo);\n+\n+  if (nt->singleton() || ot == nullptr) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no narrowing\n+  if (int_type_equal(nt, ot)) {\n+    return ot;\n+  }\n+\n+  \/\/ If old guy was maximum range, allow the narrowing\n+  if (int_type_equal(ot, CT::TYPE_DOMAIN)) {\n+    return nt;\n+  }\n+\n+  \/\/ Doesn't narrow; pretty weird\n+  if (!int_type_subset(ot, nt)) {\n+    return nt;\n+  }\n+\n+  \/\/ Bits change\n+  if (ot->_zeros != nt->_zeros || ot->_ones != nt->_ones) {\n+    return nt;\n+  }\n+\n+  \/\/ Only narrow if the range shrinks a lot\n+  U oc = cardinality_from_bounds(ot->_lo, ot->_hi, ot->_ulo, ot->_uhi);\n+  U nc = cardinality_from_bounds(nt->_lo, nt->_hi, nt->_ulo, nt->_uhi);\n+  return (nc > (oc >> 1) + (SMALLINT * 2)) ? ot : nt;\n+}\n+template const Type* int_type_narrow(const TypeInt* nt, const TypeInt* ot);\n+template const Type* int_type_narrow(const TypeLong* nt, const TypeLong* ot);\n+\n+template <class T>\n+static const char* intnamenear(T origin, const char* xname, char* buf, size_t buf_size, T n) {\n+  if (n < origin) {\n+    if (n <= origin - 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s-\" INT32_FORMAT, xname, jint(origin - n));\n+  } else if (n > origin) {\n+    if (n >= origin + 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s+\" INT32_FORMAT, xname, jint(n - origin));\n+  } else {\n+    return xname;\n+  }\n+  return buf;\n+}\n+\n+const char* intname(char* buf, size_t buf_size, jint n) {\n+  const char* str = intnamenear<jint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jint>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n+  return buf;\n+}\n+\n+const char* uintname(char* buf, size_t buf_size, juint n) {\n+  const char* str = intnamenear<juint>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<juint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, UINT32_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n+const char* longname(char* buf, size_t buf_size, jlong n) {\n+  const char* str = intnamenear<jlong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jlong>(min_jlong, \"minlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jlong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jlong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jlong>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n+  return buf;\n+}\n+\n+const char* ulongname(char* buf, size_t buf_size, julong n) {\n+  const char* str = intnamenear<julong>(max_julong, \"maxulong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<julong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<julong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<julong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JULONG_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n+template <class U>\n+const char* bitname(char* buf, size_t buf_size, U zeros, U ones) {\n+  constexpr juint W = sizeof(U) * 8;\n+\n+  if (buf_size < W + 1) {\n+    return \"#####\";\n+  }\n+\n+  for (juint i = 0; i < W; i++) {\n+    U mask = U(1) << (W - 1 - i);\n+    if ((zeros & mask) != 0) {\n+      buf[i] = '0';\n+    } else if ((ones & mask) != 0) {\n+      buf[i] = '1';\n+    } else {\n+      buf[i] = '*';\n+    }\n+  }\n+  buf[W] = 0;\n+  return buf;\n+}\n+template const char* bitname(char* buf, size_t buf_size, juint zeros, juint ones);\n+template const char* bitname(char* buf, size_t buf_size, julong zeros, julong ones);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":536,"deletions":0,"binary":false,"changes":536,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_RANGEINFERENCE_HPP\n+#define SHARE_OPTO_RANGEINFERENCE_HPP\n+\n+#include \"opto\/type.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+template <class T, class U>\n+void normalize_constraints(bool& empty, T& lo, T& hi, U& ulo, U& uhi, U& zeros, U& ones);\n+\n+#ifdef ASSERT\n+template <class T, class U>\n+void verify_constraints(T lo, T hi, U ulo, U uhi, U zeros, U ones);\n+#endif\n+\n+\/\/ The result is tuned down by one since we do not have empty type\n+\/\/ and this is not required to be accurate\n+template <class T, class U>\n+U cardinality_from_bounds(T lo, T hi, U ulo, U uhi) {\n+  if (U(lo) == ulo) {\n+    return uhi - ulo;\n+  }\n+\n+  return uhi - U(lo) + U(hi) - ulo + 1;\n+}\n+\n+template <class T, class U>\n+int normalize_widen(T lo, T hi, U ulo, U uhi, U zeros, U ones, int w);\n+\n+template <class CT, class T, class UT>\n+const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(T, T, UT, UT, UT, UT, int, bool), bool dual);\n+\n+template <class CT>\n+bool int_type_equal(const CT* t1, const CT* t2) {\n+  return t1->_lo == t2->_lo && t1->_hi == t2->_hi && t1->_ulo == t2->_ulo && t1->_uhi == t2->_uhi &&\n+         t1->_zeros == t2->_zeros && t1->_ones == t2->_ones;\n+}\n+\n+template <class CT>\n+bool int_type_subset(const CT* super, const CT* sub) {\n+  return super->_lo <= sub->_lo && super->_hi >= sub->_hi && super->_ulo <= sub->_ulo && super->_uhi >= sub->_uhi &&\n+         (super->_zeros &~ sub->_zeros) == 0 && (super->_ones &~ sub->_ones) == 0;\n+}\n+\n+template <class CT>\n+const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt);\n+\n+template <class CT>\n+const Type* int_type_narrow(const CT* nt, const CT* ot);\n+\n+#ifndef PRODUCT\n+const char* intname(char* buf, size_t buf_size, jint n);\n+const char* uintname(char* buf, size_t buf_size, juint n);\n+const char* longname(char* buf, size_t buf_size, jlong n);\n+const char* ulongname(char* buf, size_t buf_size, julong n);\n+\n+template <class U>\n+const char* bitname(char* buf, size_t buf_size, U zeros, U ones);\n+#endif \/\/ PRODUCT\n+\n+#endif \/\/ SHARE_OPTO_RANGEINFERENCE_HPP\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -843,2 +843,2 @@\n-        const TypeInt* tr1 = TypeInt::make(lo_tr1, hi_tr1, w);\n-        const TypeInt* tr2 = TypeInt::make(lo_tr2, hi_tr2, w);\n+        const TypeInt* tr1 = TypeInt::make(lo_tr1, hi_tr1, w)->is_int();\n+        const TypeInt* tr2 = TypeInt::make(lo_tr2, hi_tr2, w)->is_int();\n@@ -1455,2 +1455,2 @@\n-        const TypeInt* tr1 = TypeInt::make(min_jint, hi_int, w);\n-        const TypeInt* tr2 = TypeInt::make(lo_int, max_jint, w);\n+        const TypeInt* tr1 = TypeInt::make(min_jint, hi_int, w)->is_int();\n+        const TypeInt* tr2 = TypeInt::make(lo_int, max_jint, w)->is_int();\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -421,1 +422,0 @@\n-#define SMALLINT ((juint)3)  \/\/ a value too insignificant to consider widening\n@@ -471,16 +471,18 @@\n-  TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n-  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n-  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n-  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n-  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n-  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);\n-  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n-  TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); \/\/ Bytes\n-  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); \/\/ Unsigned Bytes\n-  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); \/\/ Java chars\n-  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); \/\/ Java shorts\n-  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); \/\/ Non-neg values\n-  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); \/\/ Positive values\n-  TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); \/\/ 32-bit integers\n-  TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); \/\/ symmetric range\n-  TypeInt::TYPE_DOMAIN  = TypeInt::INT;\n+  TypeInt::BOOL    = TypeInt::make( 0, 1, WidenMin)->is_int();  \/\/ 0 or 1, FALSE or TRUE.\n+  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin)->is_int();  \/\/ -1, 0 or 1, condition codes\n+  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin)->is_int();  \/\/ == TypeInt::MINUS_1\n+  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin)->is_int();  \/\/ == TypeInt::ONE\n+  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin)->is_int();  \/\/ == TypeInt::ZERO\n+  TypeInt::CC_NE   = TypeInt::make(-1, 1, 1, -1, 0, 1, WidenMin)->is_int();\n+  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin)->is_int();\n+  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin)->is_int();  \/\/ == TypeInt::BOOL\n+  TypeInt::BYTE    = TypeInt::make(-128, 127,    WidenMin)->is_int(); \/\/ Bytes\n+  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin)->is_int(); \/\/ Unsigned Bytes\n+  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin)->is_int(); \/\/ Java chars\n+  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin)->is_int(); \/\/ Java shorts\n+  TypeInt::NON_ZERO= TypeInt::make(min_jint, max_jint, 1, -1, 0, 0, WidenMin)->is_int();\n+  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin)->is_int(); \/\/ Non-neg values\n+  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin)->is_int(); \/\/ Positive values\n+  TypeInt::INT     = TypeInt::make(min_jint, max_jint, WidenMax)->is_int(); \/\/ 32-bit integers\n+  TypeInt::SYMINT  = TypeInt::make(-max_jint, max_jint, WidenMin)->is_int(); \/\/ symmetric range\n+  TypeInt::TYPE_DOMAIN = TypeInt::INT;\n@@ -494,1 +496,0 @@\n-  assert( (juint)(TypeInt::CC->_hi - TypeInt::CC->_lo) <= SMALLINT, \"CC is truly small\");\n@@ -501,4 +502,6 @@\n-  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); \/\/ Non-neg values\n-  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); \/\/ 64-bit integers\n-  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);\n-  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);\n+  TypeLong::NON_ZERO= TypeLong::make(min_jlong, max_jlong, 1, -1, 0, 0, WidenMin)->is_long();\n+  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin)->is_long(); \/\/ Non-neg values\n+  TypeLong::NEG     = TypeLong::make(min_jlong, -1, WidenMin)->is_long();\n+  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax)->is_long(); \/\/ 64-bit integers\n+  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin)->is_long();\n+  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin)->is_long();\n@@ -1512,1 +1515,1 @@\n-const TypeInteger* TypeInteger::make(jlong lo, jlong hi, int w, BasicType bt) {\n+const Type* TypeInteger::make(jlong lo, jlong hi, int w, BasicType bt) {\n@@ -1562,25 +1565,23 @@\n-const TypeInt *TypeInt::MAX;    \/\/ INT_MAX\n-const TypeInt *TypeInt::MIN;    \/\/ INT_MIN\n-const TypeInt *TypeInt::MINUS_1;\/\/ -1\n-const TypeInt *TypeInt::ZERO;   \/\/ 0\n-const TypeInt *TypeInt::ONE;    \/\/ 1\n-const TypeInt *TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n-const TypeInt *TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n-const TypeInt *TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n-const TypeInt *TypeInt::CC_GT;  \/\/ [1]   == ONE\n-const TypeInt *TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n-const TypeInt *TypeInt::CC_LE;  \/\/ [-1,0]\n-const TypeInt *TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n-const TypeInt *TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n-const TypeInt *TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n-const TypeInt *TypeInt::CHAR;   \/\/ Java chars, 0-65535\n-const TypeInt *TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n-const TypeInt *TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n-const TypeInt *TypeInt::POS1;   \/\/ Positive 32-bit integers\n-const TypeInt *TypeInt::INT;    \/\/ 32-bit integers\n-const TypeInt *TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-const TypeInt *TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-\/\/------------------------------TypeInt----------------------------------------\n-TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int, w), _lo(lo), _hi(hi) {\n-}\n+const TypeInt* TypeInt::MAX;    \/\/ INT_MAX\n+const TypeInt* TypeInt::MIN;    \/\/ INT_MIN\n+const TypeInt* TypeInt::MINUS_1;\/\/ -1\n+const TypeInt* TypeInt::ZERO;   \/\/ 0\n+const TypeInt* TypeInt::ONE;    \/\/ 1\n+const TypeInt* TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n+const TypeInt* TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n+const TypeInt* TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n+const TypeInt* TypeInt::CC_GT;  \/\/ [1]   == ONE\n+const TypeInt* TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n+const TypeInt* TypeInt::CC_NE;\n+const TypeInt* TypeInt::CC_LE;  \/\/ [-1,0]\n+const TypeInt* TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n+const TypeInt* TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n+const TypeInt* TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n+const TypeInt* TypeInt::CHAR;   \/\/ Java chars, 0-65535\n+const TypeInt* TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n+const TypeInt* TypeInt::NON_ZERO;\n+const TypeInt* TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n+const TypeInt* TypeInt::POS1;   \/\/ Positive 32-bit integers\n+const TypeInt* TypeInt::INT;    \/\/ 32-bit integers\n+const TypeInt* TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+const TypeInt* TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n@@ -1588,3 +1589,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeInt *TypeInt::make( jint lo ) {\n-  return (TypeInt*)(new TypeInt(lo,lo,WidenMin))->hashcons();\n+TypeInt::TypeInt(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual)\n+  : TypeInteger(Int, normalize_widen(lo, hi, ulo, uhi, zeros, ones, w), dual),\n+    _lo(lo), _hi(hi), _ulo(ulo), _uhi(uhi), _zeros(zeros), _ones(ones) {\n+  DEBUG_ONLY(verify_constraints(lo, hi, ulo, uhi, zeros, ones));\n@@ -1593,9 +1595,5 @@\n-static int normalize_int_widen( jint lo, jint hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n-  if (lo <= hi) {\n-    if (((juint)hi - lo) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)hi - lo) >= max_juint) w = Type::WidenMax; \/\/ TypeInt::INT\n-  } else {\n-    if (((juint)lo - hi) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)lo - hi) >= max_juint) w = Type::WidenMin; \/\/ dual TypeInt::INT\n+const Type* TypeInt::make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual) {\n+  bool empty = false;\n+  normalize_constraints(empty, lo, hi, ulo, uhi, zeros, ones);\n+  if (empty) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -1603,1 +1601,1 @@\n-  return w;\n+  return (new TypeInt(lo, hi, ulo, uhi, zeros, ones, w, dual))->hashcons()->is_int();\n@@ -1606,3 +1604,2 @@\n-const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {\n-  w = normalize_int_widen(lo, hi, w);\n-  return (TypeInt*)(new TypeInt(lo,hi,w))->hashcons();\n+const TypeInt* TypeInt::make(jint lo) {\n+  return (new TypeInt(lo, lo, lo, lo, ~lo, lo, WidenMin, false))->hashcons()->is_int();\n@@ -1611,37 +1608,3 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeInt::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeInt\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Long:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Int:                     \/\/ Int vs Int?\n-    break;\n-  }\n+const Type* TypeInt::make(jint lo, jint hi, int w) {\n+  return make(lo, hi, 0, max_juint, 0, 0, w);\n+}\n@@ -1649,3 +1612,2 @@\n-  \/\/ Expand covered set\n-  const TypeInt *r = t->is_int();\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const Type* TypeInt::make_bits(juint zeros, juint ones, int w) {\n+  return make(min_jint, max_jint, 0, max_juint, zeros, ones, w);\n@@ -1654,50 +1616,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeInt::xdual() const {\n-  int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeInt(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeInt::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Int ) return this;\n-  const TypeInt *ot = old->is_int();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      int max = max_jint;\n-      int min = min_jint;\n-      if (limit->isa_int()) {\n-        max = limit->is_int()->_hi;\n-        min = limit->is_int()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((juint)_lo - min) >= ((juint)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 31 bits:\n-          return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeInt::INT;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n+const Type* TypeInt::make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w) {\n+  return make(lo, hi, ulo, uhi, zeros, ones, w, false);\n+}\n@@ -1705,4 +1620,5 @@\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+bool TypeInt::contains(jint i) const {\n+  juint u = i;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi &&\n+         (u & _zeros) == 0 && (~u & _ones) == 0;\n+}\n@@ -1710,3 +1626,2 @@\n-  \/\/fatal(\"Integer value range is not subset\");\n-  \/\/return this;\n-  return TypeInt::INT;\n+bool TypeInt::contains(const TypeInt* t) const {\n+  return int_type_subset(this, t);\n@@ -1715,9 +1630,3 @@\n-\/\/------------------------------narrow---------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeInt::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeInt* ot = old->isa_int();\n-  if (ot == nullptr)  return this;\n-  jint olo = ot->_lo;\n-  jint ohi = ot->_hi;\n+bool TypeInt::properly_contains(const TypeInt* t) const {\n+  return int_type_subset(this, t) && !int_type_equal(this, t);\n+}\n@@ -1725,2 +1634,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type* TypeInt::xmeet(const Type* t) const {\n+  return int_type_xmeet(this, t, TypeInt::make, _dual);\n+}\n@@ -1728,2 +1638,3 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jint && ohi == max_jint)  return this;\n+const Type* TypeInt::xdual() const {\n+  return new TypeInt(_lo, _hi, _ulo, _uhi, _zeros, _ones, _widen, !_dual);\n+}\n@@ -1731,2 +1642,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeInt::widen(const Type* old, const Type* limit) const {\n+  assert(!_dual, \"\");\n+  return int_type_widen(this, old->isa_int(), limit->isa_int());\n+}\n@@ -1734,8 +1647,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  juint nrange = (juint)_hi - _lo;\n-  juint orange = (juint)ohi - olo;\n-  if (nrange < max_juint - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeInt::narrow(const Type* old) const {\n+  assert(!_dual, \"\");\n+  if (old == nullptr) {\n+    return this;\n@@ -1744,1 +1653,1 @@\n-  return this;\n+  return int_type_narrow(this, old->isa_int());\n@@ -1748,1 +1657,2 @@\n-const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeInt::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_dual, \"\");\n@@ -1750,1 +1660,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -1752,0 +1662,2 @@\n+  }\n+  assert(!ft->_dual, \"\");\n@@ -1755,1 +1667,2 @@\n-    ft = TypeInt::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeInt(ft->_lo, ft->_hi, ft->_ulo, ft->_uhi,\n+                        ft->_zeros, ft->_ones, this->_widen, false))->hashcons();\n@@ -1762,3 +1675,3 @@\n-bool TypeInt::eq( const Type *t ) const {\n-  const TypeInt *r = t->is_int(); \/\/ Handy access\n-  return r->_lo == _lo && r->_hi == _hi && r->_widen == _widen;\n+bool TypeInt::eq(const Type* t) const {\n+  const TypeInt* r = t->is_int();\n+  return int_type_equal(this, r) && _widen == r->_widen && _dual == r->_dual;\n@@ -1770,1 +1683,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Int;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_dual + (uint)Type::Int;\n@@ -1779,43 +1693,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeInt\n-#ifndef PRODUCT\n-static const char* intname(char* buf, size_t buf_size, jint n) {\n-  if (n == min_jint)\n-    return \"min\";\n-  else if (n < min_jint + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" INT32_FORMAT, n - min_jint);\n-  else if (n == max_jint)\n-    return \"max\";\n-  else if (n > max_jint - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" INT32_FORMAT, max_jint - n);\n-  else\n-    os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[40], buf2[40];\n-  if (_lo == min_jint && _hi == max_jint)\n-    st->print(\"int\");\n-  else if (is_con())\n-    st->print(\"int:%s\", intname(buf, sizeof(buf), get_con()));\n-  else if (_lo == BOOL->_lo && _hi == BOOL->_hi)\n-    st->print(\"bool\");\n-  else if (_lo == BYTE->_lo && _hi == BYTE->_hi)\n-    st->print(\"byte\");\n-  else if (_lo == CHAR->_lo && _hi == CHAR->_hi)\n-    st->print(\"char\");\n-  else if (_lo == SHORT->_lo && _hi == SHORT->_hi)\n-    st->print(\"short\");\n-  else if (_hi == max_jint)\n-    st->print(\"int:>=%s\", intname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jint)\n-    st->print(\"int:<=%s\", intname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"int:%s..%s\", intname(buf, sizeof(buf), _lo), intname(buf2, sizeof(buf2), _hi));\n-\n-  if (_widen != 0 && this != TypeInt::INT)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -1826,1 +1697,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -1830,1 +1701,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -1835,10 +1706,12 @@\n-const TypeLong *TypeLong::MAX;\n-const TypeLong *TypeLong::MIN;\n-const TypeLong *TypeLong::MINUS_1;\/\/ -1\n-const TypeLong *TypeLong::ZERO; \/\/ 0\n-const TypeLong *TypeLong::ONE;  \/\/ 1\n-const TypeLong *TypeLong::POS;  \/\/ >=0\n-const TypeLong *TypeLong::LONG; \/\/ 64-bit integers\n-const TypeLong *TypeLong::INT;  \/\/ 32-bit subrange\n-const TypeLong *TypeLong::UINT; \/\/ 32-bit unsigned subrange\n-const TypeLong *TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+const TypeLong* TypeLong::MAX;\n+const TypeLong* TypeLong::MIN;\n+const TypeLong* TypeLong::MINUS_1;\/\/ -1\n+const TypeLong* TypeLong::ZERO; \/\/ 0\n+const TypeLong* TypeLong::ONE;  \/\/ 1\n+const TypeLong* TypeLong::NON_ZERO;\n+const TypeLong* TypeLong::POS;  \/\/ >=0\n+const TypeLong* TypeLong::NEG;\n+const TypeLong* TypeLong::LONG; \/\/ 64-bit integers\n+const TypeLong* TypeLong::INT;  \/\/ 32-bit subrange\n+const TypeLong* TypeLong::UINT; \/\/ 32-bit unsigned subrange\n+const TypeLong* TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -1846,7 +1719,4 @@\n-\/\/------------------------------TypeLong---------------------------------------\n-TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long, w), _lo(lo), _hi(hi) {\n-}\n-\n-\/\/------------------------------make-------------------------------------------\n-const TypeLong *TypeLong::make( jlong lo ) {\n-  return (TypeLong*)(new TypeLong(lo,lo,WidenMin))->hashcons();\n+TypeLong::TypeLong(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual)\n+  : TypeInteger(Long, normalize_widen(lo, hi, ulo, uhi, zeros, ones, w), dual),\n+    _lo(lo), _hi(hi), _ulo(ulo), _uhi(uhi), _zeros(zeros), _ones(ones) {\n+  DEBUG_ONLY(verify_constraints(lo, hi, ulo, uhi, zeros, ones));\n@@ -1855,9 +1725,5 @@\n-static int normalize_long_widen( jlong lo, jlong hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants.\n-  if (lo <= hi) {\n-    if (((julong)hi - lo) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)hi - lo) >= max_julong) w = Type::WidenMax; \/\/ TypeLong::LONG\n-  } else {\n-    if (((julong)lo - hi) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)lo - hi) >= max_julong) w = Type::WidenMin; \/\/ dual TypeLong::LONG\n+const Type* TypeLong::make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual) {\n+  bool empty = false;\n+  normalize_constraints(empty, lo, hi, ulo, uhi, zeros, ones);\n+  if (empty) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -1865,1 +1731,1 @@\n-  return w;\n+  return (new TypeLong(lo, hi, ulo, uhi, zeros, ones, w, dual))->hashcons()->is_long();\n@@ -1868,3 +1734,2 @@\n-const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {\n-  w = normalize_long_widen(lo, hi, w);\n-  return (TypeLong*)(new TypeLong(lo,hi,w))->hashcons();\n+const TypeLong* TypeLong::make(jlong lo ) {\n+  return (new TypeLong(lo, lo, lo, lo, ~lo, lo, WidenMin, false))->hashcons()->is_long();\n@@ -1873,0 +1738,3 @@\n+const Type* TypeLong::make(jlong lo, jlong hi, int w) {\n+  return make(lo, hi, 0, max_julong, 0, 0, w);\n+}\n@@ -1874,41 +1742,2 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeLong::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeLong\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Long:                    \/\/ Long vs Long?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeLong *r = t->is_long(); \/\/ Turn into a TypeLong\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const Type* TypeLong::make_bits(julong zeros, julong ones, int w) {\n+  return make(min_jlong, max_jlong, 0, max_julong, zeros, ones, w);\n@@ -1917,53 +1746,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeLong::xdual() const {\n-  int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeLong(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeLong::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Long ) return this;\n-  const TypeLong *ot = old->is_long();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      jlong max = max_jlong;\n-      jlong min = min_jlong;\n-      if (limit->isa_long()) {\n-        max = limit->is_long()->_hi;\n-        min = limit->is_long()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((julong)_lo - min) >= ((julong)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 32\/63 bits:\n-          if (max >= max_juint && _hi < max_juint)\n-            return make(_lo, max_juint, WidenMax);\n-          else\n-            return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeLong::LONG;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n+const Type* TypeLong::make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w) {\n+  return make(lo, hi, ulo, uhi, zeros, ones, w, false);\n+}\n@@ -1971,4 +1750,5 @@\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+bool TypeLong::contains(jlong i) const {\n+  julong u = i;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi &&\n+         (u & _zeros) == 0 && (~u & _ones) == 0;\n+}\n@@ -1976,3 +1756,2 @@\n-  \/\/  fatal(\"Long value range is not subset\");\n-  \/\/ return this;\n-  return TypeLong::LONG;\n+bool TypeLong::contains(const TypeLong* t) const {\n+  return int_type_subset(this, t);\n@@ -1981,9 +1760,3 @@\n-\/\/------------------------------narrow----------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeLong::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeLong* ot = old->isa_long();\n-  if (ot == nullptr)  return this;\n-  jlong olo = ot->_lo;\n-  jlong ohi = ot->_hi;\n+bool TypeLong::properly_contains(const TypeLong* t) const {\n+  return int_type_subset(this, t) && !int_type_equal(this, t);\n+}\n@@ -1991,2 +1764,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type *TypeLong::xmeet(const Type* t) const {\n+  return int_type_xmeet(this, t, TypeLong::make, _dual);\n+}\n@@ -1994,2 +1768,3 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jlong && ohi == max_jlong)  return this;\n+const Type* TypeLong::xdual() const {\n+  return new TypeLong(_lo, _hi, _ulo, _uhi, _zeros, _ones, _widen, !_dual);\n+}\n@@ -1997,2 +1772,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeLong::widen(const Type* old, const Type* limit) const {\n+  assert(!_dual, \"\");\n+  return int_type_widen(this, old->isa_long(), limit->isa_long());\n+}\n@@ -2000,8 +1777,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  julong nrange = (julong)_hi - _lo;\n-  julong orange = (julong)ohi - olo;\n-  if (nrange < max_julong - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeLong::narrow(const Type* old) const {\n+  assert(!_dual, \"\");\n+  if (old == nullptr) {\n+    return this;\n@@ -2010,1 +1783,1 @@\n-  return this;\n+  return int_type_narrow(this, old->isa_long());\n@@ -2014,1 +1787,2 @@\n-const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeLong::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_dual, \"\");\n@@ -2016,1 +1790,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -2018,0 +1792,2 @@\n+  }\n+  assert(!ft->_dual, \"\");\n@@ -2021,1 +1797,2 @@\n-    ft = TypeLong::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeLong(ft->_lo, ft->_hi, ft->_ulo, ft->_uhi,\n+                         ft->_zeros, ft->_ones, this->_widen, false))->hashcons();\n@@ -2028,3 +1805,3 @@\n-bool TypeLong::eq( const Type *t ) const {\n-  const TypeLong *r = t->is_long(); \/\/ Handy access\n-  return r->_lo == _lo &&  r->_hi == _hi  && r->_widen == _widen;\n+bool TypeLong::eq(const Type* t) const {\n+  const TypeLong* r = t->is_long();\n+  return int_type_equal(this, r) && _widen == r->_widen && _dual == r->_dual;\n@@ -2036,1 +1813,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Long;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_dual + (uint)Type::Long;\n@@ -2045,0 +1823,11 @@\n+\/\/------------------------------singleton--------------------------------------\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n+\/\/ constants\n+bool TypeLong::singleton(void) const {\n+  return _lo == _hi;\n+}\n+\n+bool TypeLong::empty(void) const {\n+  return false;\n+}\n+\n@@ -2046,1 +1835,0 @@\n-\/\/ Dump TypeLong\n@@ -2048,7 +1836,14 @@\n-static const char* longnamenear(jlong x, const char* xname, char* buf, size_t buf_size, jlong n) {\n-  if (n > x) {\n-    if (n >= x + 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s+\" JLONG_FORMAT, xname, n - x);\n-  } else if (n < x) {\n-    if (n <= x - 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s-\" JLONG_FORMAT, xname, x - n);\n+void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n+  char buf1[40], buf2[40], buf3[40], buf4[40], buf5[40];\n+  if (int_type_equal(this, TypeInt::INT)) {\n+    st->print(\"int\");\n+  } else if (is_con()) {\n+    st->print(\"int:%s\", intname(buf1, sizeof(buf1), get_con()));\n+  } else if (int_type_equal(this, TypeInt::BOOL)) {\n+    st->print(\"bool\");\n+  } else if (int_type_equal(this, TypeInt::BYTE)) {\n+    st->print(\"byte\");\n+  } else if (int_type_equal(this, TypeInt::CHAR)) {\n+    st->print(\"char\");\n+  } else if (int_type_equal(this, TypeInt::SHORT)) {\n+    st->print(\"short\");\n@@ -2056,24 +1851,9 @@\n-    return xname;\n-  }\n-  return buf;\n-}\n-\n-static const char* longname(char* buf, size_t buf_size, jlong n) {\n-  const char* str;\n-  if (n == min_jlong)\n-    return \"min\";\n-  else if (n < min_jlong + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" JLONG_FORMAT, n - min_jlong);\n-  else if (n == max_jlong)\n-    return \"max\";\n-  else if (n > max_jlong - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" JLONG_FORMAT, max_jlong - n);\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else\n-    os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n-  return buf;\n+    st->print(\"int:%s..%s ^ %s..%s, bits:%s\",\n+              intname(buf1, sizeof(buf1), _lo), intname(buf2, sizeof(buf2), _hi),\n+              uintname(buf3, sizeof(buf3), _ulo), uintname(buf4, sizeof(buf4), _uhi),\n+              bitname(buf5, sizeof(buf5), _zeros, _ones));\n+  }\n+\n+  if (_widen > 0 && this != TypeInt::INT) {\n+    st->print(\", widen: %d\", _widen);\n+  }\n@@ -2083,2 +1863,2 @@\n-  char buf[80], buf2[80];\n-  if (_lo == min_jlong && _hi == max_jlong)\n+  char buf1[80], buf2[80], buf3[80], buf4[80], buf5[80];\n+  if (int_type_equal(this, TypeLong::LONG)) {\n@@ -2086,8 +1866,8 @@\n-  else if (is_con())\n-    st->print(\"long:%s\", longname(buf, sizeof(buf), get_con()));\n-  else if (_hi == max_jlong)\n-    st->print(\"long:>=%s\", longname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jlong)\n-    st->print(\"long:<=%s\", longname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"long:%s..%s\", longname(buf, sizeof(buf), _lo), longname(buf2,sizeof(buf2),  _hi));\n+  } else if (is_con()) {\n+    st->print(\"long:%s\", longname(buf1, sizeof(buf1), get_con()));\n+  } else {\n+    st->print(\"long:%s..%s ^ %s..%s, bits:%s\",\n+              longname(buf1, sizeof(buf1), _lo), longname(buf2,sizeof(buf2),  _hi),\n+              ulongname(buf3, sizeof(buf3), _ulo), ulongname(buf4, sizeof(buf4), _uhi),\n+              bitname(buf5, sizeof(buf5), _zeros, _ones));\n+  }\n@@ -2095,2 +1875,3 @@\n-  if (_widen != 0 && this != TypeLong::LONG)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n+  if (_widen > 0 && this != TypeLong::LONG) {\n+    st->print(\", widen: %d\", _widen);\n+  }\n@@ -2100,11 +1881,0 @@\n-\/\/------------------------------singleton--------------------------------------\n-\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n-\/\/ constants\n-bool TypeLong::singleton(void) const {\n-  return _lo >= _hi;\n-}\n-\n-bool TypeLong::empty(void) const {\n-  return _lo > _hi;\n-}\n-\n@@ -2332,1 +2102,1 @@\n-    return TypeInt::make(size->_lo, size->_hi, Type::WidenMin);\n+    return TypeInt::make(size->_lo, size->_hi, Type::WidenMin)->is_int();\n@@ -2362,1 +2132,6 @@\n-    const TypeAry *a = t->is_ary();\n+    const TypeAry* a = t->is_ary();\n+    const Type* size = _size->xmeet(a->_size);\n+    const TypeInt* isize = size->isa_int();\n+    if (isize == nullptr) {\n+      return size;\n+    }\n@@ -2364,2 +2139,1 @@\n-                         _size->xmeet(a->_size)->is_int(),\n-                         _stable && a->_stable);\n+                         isize, _stable && a->_stable);\n@@ -4789,1 +4563,1 @@\n-  if (lo > hi)\n+  if (lo > hi) {\n@@ -4791,1 +4565,2 @@\n-  if (!chg)\n+  }\n+  if (!chg) {\n@@ -4793,1 +4568,2 @@\n-  return TypeInt::make(lo, hi, Type::WidenMin);\n+  }\n+  return TypeInt::make(lo, hi, Type::WidenMin)->is_int();\n@@ -4954,1 +4730,5 @@\n-    const TypeAry *tary = _ary->meet_speculative(tap->_ary)->is_ary();\n+    const Type* tm = _ary->meet_speculative(tap->_ary);\n+    const TypeAry* tary = tm->isa_ary();\n+    if (tary == nullptr) {\n+      return tm;\n+    }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":243,"deletions":463,"binary":false,"changes":706,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"opto\/compile.hpp\"\n@@ -554,1 +555,4 @@\n-  TypeInteger(TYPES t, int w) : Type(t), _widen(w) {}\n+  TypeInteger(TYPES t, int w, bool dual) : Type(t), _dual(dual), _widen(w) {}\n+\n+  \/\/ Use to compute join of 2 sets\n+  const bool _dual;\n@@ -565,1 +569,1 @@\n-  static const TypeInteger* make(jlong lo, jlong hi, int w, BasicType bt);\n+  static const Type* make(jlong lo, jlong hi, int w, BasicType bt);\n@@ -579,1 +583,2 @@\n-  TypeInt( jint lo, jint hi, int w );\n+  TypeInt(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual);\n+  static const Type* make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual);\n@@ -581,1 +586,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -585,1 +590,1 @@\n-  virtual bool eq( const Type *t ) const;\n+  virtual bool eq(const Type* t) const;\n@@ -590,0 +595,2 @@\n+  const juint _ulo, _uhi;\n+  const juint _zeros, _ones;\n@@ -591,1 +598,3 @@\n-  static const TypeInt *make(jint lo);\n+  static const TypeInt* cast(const Type* t) { return t->is_int(); }\n+  static const TypeInt* try_cast(const Type* t) { return t->isa_int(); }\n+  static const TypeInt* make(jint lo);\n@@ -593,1 +602,3 @@\n-  static const TypeInt *make(jint lo, jint hi, int w);\n+  static const Type* make(jint lo, jint hi, int w);\n+  static const Type* make_bits(juint zeros, juint ones, int w);\n+  static const Type* make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w);\n@@ -596,1 +607,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -598,1 +609,4 @@\n-  jint get_con() const { assert(is_con(), \"\" );  return _lo; }\n+  jint get_con() const { assert(is_con(), \"\");  return _lo; }\n+  bool contains(jint i) const;\n+  bool contains(const TypeInt* t) const;\n+  bool properly_contains(const TypeInt* t) const;\n@@ -600,1 +614,1 @@\n-  virtual bool        is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n@@ -602,4 +616,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -612,21 +626,23 @@\n-  static const TypeInt *MAX;\n-  static const TypeInt *MIN;\n-  static const TypeInt *MINUS_1;\n-  static const TypeInt *ZERO;\n-  static const TypeInt *ONE;\n-  static const TypeInt *BOOL;\n-  static const TypeInt *CC;\n-  static const TypeInt *CC_LT;  \/\/ [-1]  == MINUS_1\n-  static const TypeInt *CC_GT;  \/\/ [1]   == ONE\n-  static const TypeInt *CC_EQ;  \/\/ [0]   == ZERO\n-  static const TypeInt *CC_LE;  \/\/ [-1,0]\n-  static const TypeInt *CC_GE;  \/\/ [0,1] == BOOL (!)\n-  static const TypeInt *BYTE;\n-  static const TypeInt *UBYTE;\n-  static const TypeInt *CHAR;\n-  static const TypeInt *SHORT;\n-  static const TypeInt *POS;\n-  static const TypeInt *POS1;\n-  static const TypeInt *INT;\n-  static const TypeInt *SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-  static const TypeInt *TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n+  static const TypeInt* MAX;\n+  static const TypeInt* MIN;\n+  static const TypeInt* MINUS_1;\n+  static const TypeInt* ZERO;\n+  static const TypeInt* ONE;\n+  static const TypeInt* BOOL;\n+  static const TypeInt* CC;\n+  static const TypeInt* CC_LT;  \/\/ [-1]  == MINUS_1\n+  static const TypeInt* CC_GT;  \/\/ [1]   == ONE\n+  static const TypeInt* CC_EQ;  \/\/ [0]   == ZERO\n+  static const TypeInt* CC_NE;  \/\/ [-1, 1]\n+  static const TypeInt* CC_LE;  \/\/ [-1,0]\n+  static const TypeInt* CC_GE;  \/\/ [0,1] == BOOL (!)\n+  static const TypeInt* BYTE;\n+  static const TypeInt* UBYTE;\n+  static const TypeInt* CHAR;\n+  static const TypeInt* SHORT;\n+  static const TypeInt* NON_ZERO;\n+  static const TypeInt* POS;\n+  static const TypeInt* POS1;\n+  static const TypeInt* INT;\n+  static const TypeInt* SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+  static const TypeInt* TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n@@ -645,1 +661,2 @@\n-  TypeLong( jlong lo, jlong hi, int w );\n+  TypeLong(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual);\n+  static const Type* make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual);\n@@ -648,1 +665,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -657,0 +674,2 @@\n+  const julong _ulo, _uhi;\n+  const julong _zeros, _ones;\n@@ -658,1 +677,3 @@\n-  static const TypeLong *make(jlong lo);\n+  static const TypeLong* cast(const Type* t) { return t->is_long(); }\n+  static const TypeLong* try_cast(const Type* t) { return t->isa_long(); }\n+  static const TypeLong* make(jlong lo);\n@@ -660,1 +681,3 @@\n-  static const TypeLong *make(jlong lo, jlong hi, int w);\n+  static const Type* make(jlong lo, jlong hi, int w);\n+  static const Type* make_bits(julong zeros, julong ones, int w);\n+  static const Type* make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w);\n@@ -663,1 +686,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -666,0 +689,3 @@\n+  bool contains(jlong i) const;\n+  bool contains(const TypeLong* t) const;\n+  bool properly_contains(const TypeLong* t) const;\n@@ -675,4 +701,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -680,10 +706,12 @@\n-  static const TypeLong *MAX;\n-  static const TypeLong *MIN;\n-  static const TypeLong *MINUS_1;\n-  static const TypeLong *ZERO;\n-  static const TypeLong *ONE;\n-  static const TypeLong *POS;\n-  static const TypeLong *LONG;\n-  static const TypeLong *INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n-  static const TypeLong *UINT;   \/\/ 32-bit unsigned [0..max_juint]\n-  static const TypeLong *TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+  static const TypeLong* MAX;\n+  static const TypeLong* MIN;\n+  static const TypeLong* MINUS_1;\n+  static const TypeLong* ZERO;\n+  static const TypeLong* ONE;\n+  static const TypeLong* NON_ZERO;\n+  static const TypeLong* POS;\n+  static const TypeLong* NEG;\n+  static const TypeLong* LONG;\n+  static const TypeLong* INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n+  static const TypeLong* UINT;   \/\/ 32-bit unsigned [0..max_juint]\n+  static const TypeLong* TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":83,"deletions":55,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+#include <limits>\n+\n+template <class U>\n+static U uniform_random();\n+\n+template <>\n+juint uniform_random<juint>() {\n+  return os::random();\n+}\n+\n+template <>\n+julong uniform_random<julong>() {\n+  return (julong(os::random()) << 32) | julong(juint(os::random()));\n+}\n+\n+template <class T, class U>\n+static void test_normalize_constraints_simple() {\n+  constexpr int parameters = 10;\n+  for (int i = 0; i < parameters; i++) {\n+    T a = uniform_random<U>();\n+    T b = uniform_random<U>();\n+\n+    {\n+      T lo = MIN2<T>(a, b);\n+      T hi = MAX2<T>(a, b);\n+      T nlo = lo;\n+      T nhi = hi;\n+      U nulo = std::numeric_limits<U>::min();\n+      U nuhi = std::numeric_limits<U>::max();\n+      U nzeros = 0;\n+      U nones = 0;\n+      bool empty = false;\n+      normalize_constraints(empty, nlo, nhi, nulo, nuhi, nzeros, nones);\n+      ASSERT_FALSE(empty);\n+      ASSERT_EQ(lo, nlo);\n+      ASSERT_EQ(hi, nhi);\n+      if (U(lo) <= U(hi)) {\n+        ASSERT_EQ(U(lo), nulo);\n+        ASSERT_EQ(U(hi), nuhi);\n+      } else {\n+        ASSERT_EQ(std::numeric_limits<U>::min(), nulo);\n+        ASSERT_EQ(std::numeric_limits<U>::max(), nuhi);\n+      }\n+    }\n+\n+    {\n+      U ulo = MIN2<U>(a, b);\n+      U uhi = MAX2<U>(a, b);\n+      T nlo = std::numeric_limits<T>::min();\n+      T nhi = std::numeric_limits<T>::max();\n+      U nulo = ulo;\n+      U nuhi = uhi;\n+      U nzeros = 0;\n+      U nones = 0;\n+      bool empty = false;\n+      normalize_constraints(empty, nlo, nhi, nulo, nuhi, nzeros, nones);\n+      ASSERT_FALSE(empty);\n+      ASSERT_EQ(ulo, nulo);\n+      ASSERT_EQ(uhi, nuhi);\n+      if (T(ulo) <= T(uhi)) {\n+        ASSERT_EQ(T(ulo), nlo);\n+        ASSERT_EQ(T(uhi), nhi);\n+      } else {\n+        ASSERT_EQ(std::numeric_limits<T>::min(), nlo);\n+        ASSERT_EQ(std::numeric_limits<T>::max(), nhi);\n+      }\n+    }\n+\n+    {\n+      U intersection = a & b;\n+      U zeros = a ^ intersection;\n+      U ones = b ^ intersection;\n+      T nlo = std::numeric_limits<T>::min();\n+      T nhi = std::numeric_limits<T>::max();\n+      U nulo = std::numeric_limits<U>::min();\n+      U nuhi = std::numeric_limits<U>::max();\n+      U nzeros = zeros;\n+      U nones = ones;\n+      bool empty = false;\n+      normalize_constraints(empty, nlo, nhi, nulo, nuhi, nzeros, nones);\n+      ASSERT_FALSE(empty);\n+      ASSERT_EQ(zeros, nzeros);\n+      ASSERT_EQ(ones, nones);\n+      ASSERT_EQ(ones, nulo);\n+      ASSERT_EQ(~zeros, nuhi);\n+    }\n+  }\n+}\n+\n+template <class T, class U>\n+static void test_normalize_constraints_random() {\n+  constexpr int samples = 1000;\n+  constexpr int parameters = 1000;\n+  int non_empty = 0;\n+  for (int i = 0; i < parameters; i++) {\n+    T s1 = uniform_random<U>();\n+    T s2 = uniform_random<U>();\n+    T lo = MIN2(s1, s2);\n+    T hi = MAX2(s1, s2);\n+    U u1 = uniform_random<U>();\n+    U u2 = uniform_random<U>();\n+    U ulo = MIN2(u1, u2);\n+    U uhi = MAX2(u1, u2);\n+    U b1 = uniform_random<U>();\n+    U b2 = uniform_random<U>();\n+    U intersection = b1 & b2;\n+    U zeros = b1 ^ intersection;\n+    U ones = b2 ^ intersection;\n+    T ns1 = s1;\n+    T ns2 = s2;\n+    U nu1 = u1;\n+    U nu2 = u2;\n+    U nzeros = zeros;\n+    U nones = ones;\n+    bool empty = false;\n+    normalize_constraints(empty, ns1, ns2, nu1, nu2, nzeros, nones);\n+    auto contains = [](T lo, T hi, U ulo, U uhi, U zeros, U ones, T value) {\n+      U u = value;\n+      return value >= lo && value <= hi && u >= ulo && u <= uhi &&\n+             (u & zeros) == 0 && (~u & ones) == 0;\n+    };\n+    if (!empty) {\n+      non_empty++;\n+    }\n+    for (int j = 0; j < samples; j++) {\n+      T v = uniform_random<U>();\n+      if (empty) {\n+        ASSERT_FALSE(contains(s1, s2, u1, u2, zeros, ones, v));\n+      } else {\n+        ASSERT_EQ(contains(s1, s2, u1, u2, zeros, ones, v), contains(ns1, ns2, nu1, nu2, nzeros, nones, v));\n+      }\n+    }\n+  }\n+}\n+\n+TEST_VM(opto, normalize_constraints) {\n+  test_normalize_constraints_simple<jint, juint>();\n+  test_normalize_constraints_simple<jlong, julong>();\n+  test_normalize_constraints_random<jint, juint>();\n+  test_normalize_constraints_random<jlong, julong>();\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"}]}