{"files":[{"patch":"@@ -51,9 +51,2 @@\n-\/\/ In the canonical form, when intersecting [lo, hi] in the signed domain with\n-\/\/ [ulo, uhi] in the unsigned domain, there can be 2 cases (see TypeInt in\n-\/\/ type.hpp for more details):\n-\/\/ - [lo, hi] is the same as [ulo, uhi], lo and hi are both >= 0 or both < 0.\n-\/\/ - [lo, hi] is not the same as [ulo, uhi], which results in the intersections\n-\/\/   being [lo, uhi] and [ulo, hi], lo and uhi are < 0 while ulo and hi are >= 0.\n-\/\/ This class deals with each interval with both bounds being >= 0 or < 0 in\n-\/\/ the signed domain. We call it Simple because a canonicalized TypeIntPrototype\n-\/\/ may contain 1 or 2 SimpleCanonicalResult.\n+\/\/ This is the result of canonicalizing a simple interval (see TypeInt at\n+\/\/ type.hpp)\n@@ -64,2 +57,2 @@\n-  bool _present; \/\/ whether this is an empty set\n-  RangeInt<U> _bounds;\n+  bool _present;       \/\/ whether this is an empty set\n+  RangeInt<U> _bounds; \/\/ The bounds must be in the same half of the integer domain (see TypeInt)\n@@ -85,1 +78,2 @@\n-\/\/ significant.\n+\/\/ significant. For a value n with w bits, we denote n[0] the first (highest)\n+\/\/ bit of n, n[1] the second bit, ..., n[w - 1] the last (lowest) bit of n.\n@@ -95,1 +89,1 @@\n-  \/\/ results in us having to find the smallest value that satisfies bits\n+  \/\/ results in us having to find the smallest value that satisfies bits.\n@@ -106,5 +100,6 @@\n-  Call res the lowest value not smaller than lo that satisfies bits, consider\n-  the first bit in res that is different from the corresponding bit in lo,\n-  since res is larger than lo the bit must be 0 in lo and 1 in res. Since res\n-  must satisify bits the bit must be 0 in zeros. Finally, as res should be the\n-  smallest value, this bit should be the last one possible.\n+  Call r the lowest value not smaller than lo that satisfies bits, consider the\n+  first bit in r that is different from the corresponding bit in lo:\n+    - Since r is larger than lo the bit must be 0 in lo and 1 in r\n+    - Since r must satisify bits the bit must be 0 in zeros\n+    - Since r should be the smallest value, this bit should be the lowest one\n+      possible\n@@ -126,2 +121,1 @@\n-  Call i the largest value such that (with v[0] being the first bit of v, v[1]\n-  being the second bit of v and so on):\n+  Call i the largest bit index such that:\n@@ -129,3 +123,3 @@\n-  - lo[x] satisfies bits for 0 <= x < i\n-  - zeros[i] = 0\n-  - lo[i] = 0\n+  - lo[x] satisfies bits for 0 <= x < i (2.1)\n+  - zeros[i] = 0                        (2.2)\n+  - lo[i] = 0                           (2.3)\n@@ -135,3 +129,3 @@\n-  - v[x] = lo[x], for 0 <= x < i\n-  - v[i] = 1\n-  - v[x] = ones[x], for j > i\n+  - v[x] = lo[x], for 0 <= x < i        (2.4)\n+  - v[i] = 1                            (2.5)\n+  - v[x] = ones[x], for x > i           (2.6)\n@@ -142,1 +136,2 @@\n-  Call r the smallest value not smaller than lo that satisfies bits.\n+  Call r the smallest value not smaller than lo that satisfies bits. Since lo\n+  does not satisfy bits, lo < r (2.7)\n@@ -146,1 +141,4 @@\n-  Trivially, lo < v since lo[i] < v[i] and lo[x] == v[x] for x < i.\n+    Trivially, lo < v since:\n+      lo[x] = v[x], for 0 <= x < i (according to 2.4)\n+      lo[i] < v[i] (according to 2.3 and 2.5, lo[i] == 0 < v[i] == 1)\n+      bits at x > i have lower significance, and are thus irrelevant\n@@ -148,3 +146,4 @@\n-  As established above, the first (i + 1) bits of v satisfy bits.\n-  The remaining bits satisfy zeros, since any bit x > i such that zeros[x] == 1, v[x] == ones[x] == 0\n-  They also satisfy ones, since any bit j > i such that ones[x] == 1, v[x] == ones[x] == 1\n+    As established above, the first (i + 1) bits of v satisfy bits.\n+    The remaining bits satisfy zeros, since any bit x > i such that zeros[x] == 1,\n+      v[x] == ones[x] == 0 (according to 2.6, we assume bits is not contradictory here)\n+    They also satisfy ones, since any bit j > i such that ones[x] == 1, v[x] == ones[x] == 1 (according to 2.6)\n@@ -152,2 +151,2 @@\n-  As a result, v > lo and v satisfies bits since all of its bits satisfy bits. Which\n-  means r <= v since r is the smallest such value.\n+    As a result, v > lo and v satisfies bits since all of its bits satisfy bits. Which\n+    means r <= v since r is the smallest such value.\n@@ -155,1 +154,1 @@\n-  b. Secondly, we prove that r >= v. Suppose r < v:\n+  b. Secondly, we prove that r == v. Suppose r < v:\n@@ -157,1 +156,1 @@\n-  Since r < v, there must be a bit position j that:\n+    Since r < v, there must be a bit position j that:\n@@ -159,2 +158,3 @@\n-  r[j] == 0, v[j] == 1\n-  r[x] == v[x], for x < j\n+    r[j] == 0               (2.b.1)\n+    v[j] == 1               (2.b.2)\n+    r[x] == v[x], for x < j (2.b.3)\n@@ -162,3 +162,6 @@\n-  - If j < i\n-  r[j] == 0, v[j] == lo[j] == 1\n-  r[x] == v[x] == lo[x], for x < j\n+    - If j < i\n+      r[j] == 0 (according to 2.b.1)\n+      v[j] == lo[j] (according to 2.4 because j < i)\n+      v[j] == 1 (according to 2.b.2)\n+      r[x] == v[x], for x < j (according to 2.b.3)\n+      v[x] == lo[x], for x < j (according to 2,4 because j < i)\n@@ -166,1 +169,4 @@\n-  This means r < lo, which contradicts that r >= lo\n+      This means that:\n+      r[j] == 0\n+      lo[j] == 1\n+      r[x] == lo[x], for x < j\n@@ -168,2 +174,1 @@\n-  - If j == i\n-  This means that lo[i] == r[i]. Call k the bit position such that:\n+      Which leads to r < lo, which contradicts that r >= lo\n@@ -171,2 +176,4 @@\n-  r[k] == 1, lo[k] == 0\n-  r[x] == lo[x], for x < k\n+    - If j == i\n+      Since lo[i] == 0 (according to 2.3) and r[i] == 0 (according to 2.b.1),\n+      we have lo[i] == r[i]. Since r > lo (according to 2.7), there must exist\n+      a bit index k such that:\n@@ -174,4 +181,3 @@\n-  k > i since r[x] == lo[x], for x <= i\n-  lo[x] satisfies bits for 0 <= x < k\n-  zeros[k] == 0\n-  This contradicts the assumption that i being the largest value satisfying such conditions.\n+      r[k] == 1\n+      lo[k] == 0\n+      r[x] == lo[x], for x < k\n@@ -179,2 +185,5 @@\n-  - If j > i:\n-  ones[j] == v[j] == 1, which contradicts that r satisfies bits.\n+      Then, since we have:\n+      r[x] == v[x], for x < i (according to 2.b.3 because j == i)\n+      v[x] == lo[x], for x < i (according to 2.4)\n+      r[j] == 0 (according to 2.b.1)\n+      lo[j] == 0 (according to 2.3)\n@@ -182,2 +191,2 @@\n-  All cases lead to contradictions, which mean r < v is incorrect, which means\n-  that r >= v.\n+      this leads to: r[x] == lo[x], for x <= i\n+      while r[k] == 1 != lo[k] == 0, we can conclude that k > i\n@@ -185,2 +194,4 @@\n-  As a result, r == v, which means the value v having the above form is the\n-  lowest value not smaller than lo that satisfies bits.\n+      However, since:\n+      lo[x] satisfies bits for 0 <= x < k (because r satisfies bits and lo[x] == r[x] for 0 <= x < k)\n+      zeros[k] == 0 (because r[k] == 1, which means zeros[k] != 1 because r satisfies bits)\n+      lo[k] == 0 (the definition of k above)\n@@ -188,4 +199,1 @@\n-  Our objective now is to find the largest value i that satisfies:\n-  - lo[x] satisfies bits for 0 <= x < i\n-  - zeros[i] = 0\n-  - lo[i] = 0\n+      This contradicts the assumption that i is the largest bit index satisfying such conditions.\n@@ -193,4 +201,4 @@\n-  Call j the largest value such that lo[x] satisfies bits for 0 <= x < j. This\n-  means that j is the smallest value such that lo[j] does not satisfy bits. We\n-  call this the first violation. i then can be computed as the largest value\n-  <= j such that:\n+    - If j > i\n+      ones[j] == v[j] (according to 2.6 since j > i)\n+      v[j] == 1 (according to 2.b.2)\n+      r[j] == 0 (according to 2.b.1)\n@@ -198,1 +206,19 @@\n-  zeros[i] == lo[i] == 0\n+      This means that r[j] == 0 and ones[j] == 1, this contradicts the assumption that r\n+      satisfies bits.\n+\n+    All cases lead to contradictions, which mean r < v is incorrect, which means\n+    that r == v, which means the value v having the above form is the\n+    lowest value not smaller than lo that satisfies bits.\n+\n+  3. Conclusion\n+    Our objective now is to find the largest value i that satisfies:\n+    - lo[x] satisfies bits for 0 <= x < i\n+    - zeros[i] = 0\n+    - lo[i] = 0\n+\n+    Call j the largest value such that lo[x] satisfies bits for 0 <= x < j. This\n+    means that j is the smallest value such that lo[j] does not satisfy bits. We\n+    call this the first violation. i then can be computed as the largest value\n+    <= j such that:\n+\n+    zeros[i] == lo[i] == 0\n@@ -359,3 +385,2 @@\n-\/\/ This function is called simple because it deals with a SimpleCanonicalResult,\n-\/\/ and a canonicalization of a TypeIntPrototype may require 1 or 2 calls to this\n-\/\/ function, one for the non-negative range and one for the negative range.\n+\/\/ This function is called simple because it deals with a simple intervals (see\n+\/\/ TypeInt at type.hpp).\n@@ -418,0 +443,3 @@\n+  \/\/ Now [srange._lo, jint(urange._hi)] and [jint(urange._lo), srange._hi] are\n+  \/\/ both simple intervals (as defined in TypeInt at type.hpp), we process them\n+  \/\/ separately and combine the results\n@@ -419,1 +447,1 @@\n-    \/\/ [lo, hi] and [ulo, uhi] represent the same range\n+    \/\/ The 2 simple intervals should be tightened to the same result\n@@ -431,4 +459,1 @@\n-  \/\/ [lo, hi] intersects with [ulo, uhi] in 2 ranges:\n-  \/\/ [lo, uhi], which consists of negative values\n-  \/\/ [ulo, hi] which consists of non-negative values\n-  \/\/ We process these 2 separately and combine the results\n+  \/\/ The 2 simple intervals can be tightened into 2 separate results\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":97,"deletions":72,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -592,2 +592,2 @@\n- * A TypeInt represents a set of jint values. An jint v is an element of a\n- * TypeInt iff:\n+ * A TypeInt represents a set of non-empty jint values. A jint v is an element\n+ * of a TypeInt iff:\n@@ -597,1 +597,1 @@\n- * Multiple set of parameters can represent the same set.\n+ * Multiple sets of parameters can represent the same set.\n@@ -600,1 +600,1 @@\n- * t1._lo = 2, t1._hi = 7, t1._ulo = 0, t1._uhi = 5, t1._bits._zeros = 0x0, t1._bits._ones = 0x1\n+ * t1._lo = 2, t1._hi = 7, t1._ulo = 0, t1._uhi = 5, t1._bits._zeros = 0x00000000, t1._bits._ones = 0x1\n@@ -604,2 +604,2 @@\n- * constraints of t2 are optimal. I.e there exists no TypeInt t3 which also\n- * represents {3, 5} such that:\n+ * constraints of t2 are tightest possible. I.e there exists no TypeInt t3\n+ * which also represents {3, 5} such that:\n@@ -608,1 +608,1 @@\n- *     (t3._bits._zeros & t2._bis._zeros) != t3._bits._zeros || (t3._bits._ones & t2._bits._ones) != t3._bits._ones\n+ *     (t3._bits._zeros &~ t2._bis._zeros) != 0 || (t3._bits._ones &~ t2._bits._ones) != 0\n@@ -610,2 +610,4 @@\n- * The last 2 conditions mean that the bits in t3._bits._zeros is not a subset\n- * of those in t2._bits._zeros, the same applies to _bits._ones\n+ * The 5-th condition mean that the subtraction of the bitsets represented by\n+ * t3._bits._zeros and t2._bits._zeros is not empty, which means that the\n+ * bits in t3._bits._zeros is not a subset of those in t2._bits._zeros, the\n+ * same applies to _bits._ones\n@@ -613,1 +615,1 @@\n- * As a result, every TypeInt is canonicalized to its optimal form upon\n+ * As a result, every TypeInt is canonicalized to its tightest form upon\n@@ -621,17 +623,18 @@\n- * 1. Since every TypeInt instance is canonicalized, all the bounds must also\n- * be elements of such TypeInt. Or else, we can tighten the bounds by narrowing\n- * it by one, which contradicts the assumption of the TypeInt being canonical.\n- *\n- * 2. _lo <= jint(_ulo)\n- *    _lo <= _hi\n- *    _lo <= jint(_uhi)\n- *    _ulo <= juint(_lo)\n- *    _ulo <= _uhi\n- *    _ulo <= juint(_hi)\n- *    _hi >= jint(_uhi)\n- *    _hi >= _lo\n- *    _hi >= jint(_ulo)\n- *    _hi >= jint(_uhi)\n- *    _uhi >= juint(_hi)\n- *    _uhi >= juint(_lo)\n- *    _uhi >= _ulo\n+ * 1. Since every TypeInt instance is non-empty and canonicalized, all the\n+ *   bounds must also be elements of such TypeInt. Or else, we can tighten the\n+ *   bounds by narrowing it by one, which contradicts the assumption of the\n+ *   TypeInt being canonical.\n+ *\n+ * 2.\n+ *   2.1.  _lo <= jint(_ulo)\n+ *   2.2.  _lo <= _hi\n+ *   2.3.  _lo <= jint(_uhi)\n+ *   2.4.  _ulo <= juint(_lo)\n+ *   2.5.  _ulo <= juint(_hi)\n+ *   2.6.  _ulo <= _uhi\n+ *   2.7.  _hi >= _lo\n+ *   2.8.  _hi >= jint(_ulo)\n+ *   2.9.  _hi >= jint(_uhi)\n+ *   2.10. _uhi >= juint(_lo)\n+ *   2.11. _uhi >= _ulo\n+ *   2.12. _uhi >= juint(_hi)\n@@ -641,5 +644,10 @@\n- *   _lo <= jint(_ulo):\n- *   According the lemma 1, _ulo is an element of the TypeInt, so in the signed\n- *   domain, it must not be less than the smallest element of that TypeInt, which\n- *   is _lo. Which means that _lo <= _ulo in the signed domain, or in a more\n- *   programmatical way, _lo <= jint(_ulo).\n+ *   2.1. _lo <= jint(_ulo):\n+ *     According the lemma 1, _ulo is an element of the TypeInt, so in the\n+ *     signed domain, it must not be less than the smallest element of that\n+ *     TypeInt, which is _lo. Which means that _lo <= _ulo in the signed\n+ *     domain, or in a more programmatical way, _lo <= jint(_ulo).\n+ *   2.2. _lo <= _hi:\n+ *     According the lemma 1, _hi is an element of the TypeInt, so in the\n+ *     signed domain, it must not be less than the smallest element of that\n+ *     TypeInt, which is _lo. Which means that _lo <= _hi.\n+ *\n@@ -649,2 +657,2 @@\n- * TypeInt lie in the intervals [_lo, jint(_uhi)] or [jint(_ulo), _hi] (note\n- * that these intervals are disjoint in this case).\n+ *   TypeInt lie in the intervals [_lo, jint(_uhi)] or [jint(_ulo), _hi] (note\n+ *   that these intervals are disjoint in this case).\n@@ -653,2 +661,2 @@\n- *   We have a preliminary: For 2 jint value x, y such that they are both >= 0\n- *   or both < 0. Then:\n+ *   Lemma 3.1: For 2 jint value x, y such that they are both >= 0 or both < 0.\n+ *   Then:\n@@ -663,1 +671,1 @@\n- *   a. t._lo >= 0. Since 0 <= t._lo <= jint(t._ulo) (lemma 2), we have:\n+ *   a. t._lo >= 0, we have:\n@@ -665,1 +673,4 @@\n- *     juint(t._lo) <= juint(jint(t._ulo)) == t._ulo <= juint(t._lo)\n+ *     0 <= t_lo <= jint(t._ulo)           (lemma 2.1)\n+ *     juint(t._lo) <= juint(jint(t._ulo)) (lemma 3.1)\n+ *                  == t._ulo              (juint(jint(v)) == v with juint v)\n+ *                  <= juint(t._lo)        (lemma 2.4)\n@@ -669,2 +680,5 @@\n- *     Furthermore, 0 <= t._lo <= t._hi and 0 <= t._lo <= jint(t._uhi) (lemma 2),\n- *     since t._hi >= jint(t._uhi), we have:\n+ *     Furthermore,\n+ *\n+ *     0 <= t._lo <= t._hi                 (lemma 2.2)\n+ *     0 <= t._lo <= jint(t._uhi)          (lemma 2.3)\n+ *     t._hi >= jint(t._uhi)               (lemma 2.9)\n@@ -672,1 +686,3 @@\n- *     juint(t._hi) >= juint(jint(t._uhi)) == t._uhi >= juint(t._hi)\n+ *     juint(t._hi) >= juint(jint(t._uhi)) (lemma 3.1)\n+ *                  == t._uhi              (juint(jint(v)) == v with juint v)\n+ *                  >= juint(t._hi)        (lemma 2.12)\n@@ -680,2 +696,3 @@\n- *     Since t._ulo <= juint(t._hi), we must have jint(t._ulo) >= 0 because all\n- *     negative values is larger than all positive values in the unsigned domain.\n+ *     Since t._ulo <= juint(t._hi) (lemma 2.5), we must have jint(t._ulo) >= 0\n+ *     because all negative values is larger than all non-negative values in the\n+ *     unsigned domain.\n@@ -683,2 +700,2 @@\n- *     Since t._uhi >= juint(t._lo), we must have jint(t._uhi) < 0, similar to the\n- *     reasoning above.\n+ *     Since t._uhi >= juint(t._lo) (lemma 2.10), we must have jint(t._uhi) < 0\n+ *     similar to the reasoning above.\n@@ -698,3 +715,12 @@\n- *   This property is useful for our analysis of TypeInt values. Additionally, it\n- *   can be seen that _lo and jint(_uhi) are both < 0 or both >= 0, and the same\n- *   applies to jint(_ulo) and _hi.\n+ *   This property is useful for our analysis of TypeInt values. Additionally,\n+ *   it can be seen that _lo and jint(_uhi) are both < 0 or both >= 0, and the\n+ *   same applies to jint(_ulo) and _hi.\n+ *\n+ *   We call [_lo, jint(_uhi)] and [jint(_ulo), _hi] \"simple intervals\". Then,\n+ *   a TypeInt consists of 2 simple intervals, each of which has its bounds\n+ *   being both >= 0 or both < 0. If both simple intervals lie in the same half\n+ *   of the integer domain, they must be the same (i.e _lo == jint(_ulo) and\n+ *   _hi == jint(_uhi)). Otherwise, [_lo, jint(_uhi)] must lie in the negative\n+ *   half and [jint(_ulo), _hi] must lie in the non-negative half of the signed\n+ *   domain (equivalently, [_lo, jint(_uhi)] must lie in the upper half and\n+ *   [jint(_ulo), _hi] must lie in the lower half of the unsigned domain).\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":74,"deletions":48,"binary":false,"changes":122,"status":"modified"}]}