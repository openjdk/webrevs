{"files":[{"patch":"@@ -90,16 +90,96 @@\n-  \/\/ The principle here is that, consider the first bit in result that is\n-  \/\/ different from the corresponding bit in lo, since result is larger than lo\n-  \/\/ the bit must be 0 in lo and 1 in result. As result should be the smallest\n-  \/\/ value, this bit should be the last one possible.\n-  \/\/ E.g:      1 2 3 4 5 6\n-  \/\/      lo = 1 0 0 1 1 0\n-  \/\/       x = 1 0 1 0 1 0\n-  \/\/       y = 0 1 1 1 1 1\n-  \/\/ x would be larger than lo since the first different bit is the 3rd one,\n-  \/\/ while y is smaller than lo because the first different bit is the 1st bit.\n-  \/\/ Next consider:\n-  \/\/      x1 = 1 0 1 0 1 0\n-  \/\/      x2 = 1 0 0 1 1 1\n-  \/\/ Both x1 and x2 are larger than lo, but x1 > x2 since its first different\n-  \/\/ bit from lo is the 3rd one, while with x2 it is the 7th one. As a result,\n-  \/\/ if both x1 and x2 satisfy bits, x2 would be closer to our true result.\n+  \/*\n+  1. Intuition:\n+  Call res the lowest value not smaller than lo that satisfies bits, consider\n+  the first bit in res that is different from the corresponding bit in lo,\n+  since res is larger than lo the bit must be 0 in lo and 1 in res. Since res\n+  must satisify bits the bit must be 0 in zeros. Finally, as res should be the\n+  smallest value, this bit should be the last one possible.\n+\n+  E.g:      1 2 3 4 5 6\n+       lo = 1 0 0 1 1 0\n+        x = 1 0 1 0 1 0\n+        y = 0 1 1 1 1 1\n+  x would be larger than lo since the first different bit is the 3rd one,\n+  while y is smaller than lo because the first different bit is the 1st bit.\n+  Next, consider:\n+       x1 = 1 0 1 0 1 0\n+       x2 = 1 0 0 1 1 1\n+  Both x1 and x2 are larger than lo, but x1 > x2 since its first different\n+  bit from lo is the 3rd one, while with x2 it is the 7th one. As a result,\n+  if both x1 and x2 satisfy bits, x2 would be closer to our true result.\n+\n+  2. Formality:\n+  Call i the largest value such that (with v[0] being the first bit of v, v[1]\n+  being the second bit of v and so on):\n+\n+  - lo[x] satisfies bits for 0 <= x < i\n+  - zeros[i] = 0\n+  - lo[i] = 0\n+\n+  Consider v:\n+\n+  - v[x] = lo[x], for 0 <= x < i\n+  - v[i] = 1\n+  - v[x] = ones[x], for j > i\n+\n+  We will prove that v is the smallest value not smaller than lo that\n+  satisfies bits.\n+\n+  Call r the smallest value not smaller than lo that satisfies bits.\n+\n+  a. Firstly, we prove that r <= v:\n+\n+  Trivially, lo < v since lo[i] < v[i] and lo[x] == v[x] for x < i.\n+\n+  As established above, the first (i + 1) bits of v satisfy bits.\n+  The remaining bits satisfy zeros, since any bit x > i such that zeros[x] == 1, v[x] == ones[x] == 0\n+  They also satisfy ones, since any bit j > i such that ones[x] == 1, v[x] == ones[x] == 1\n+\n+  As a result, v > lo and v satisfies bits since all of its bits satisfy bits. Which\n+  means r <= v since r is the smallest such value.\n+\n+  b. Secondly, we prove that r >= v. Suppose r < v:\n+\n+  Since r < v, there must be a bit position j that:\n+\n+  r[j] == 0, v[j] == 1\n+  r[x] == v[x], for x < j\n+\n+  - If j < i\n+  r[j] == 0, v[j] == lo[j] == 1\n+  r[x] == v[x] == lo[x], for x < j\n+\n+  This means r < lo, which contradicts that r >= lo\n+\n+  - If j == i\n+  This means that lo[i] == r[i]. Call k the bit position such that:\n+\n+  r[k] == 1, lo[k] == 0\n+  r[x] == lo[x], for x < k\n+\n+  k > i since r[x] == lo[x], for x <= i\n+  lo[x] satisfies bits for 0 <= x < k\n+  zeros[k] == 0\n+  This contradicts the assumption that i being the largest value satisfying such conditions.\n+\n+  - If j > i:\n+  ones[j] == v[j] == 1, which contradicts that r satisfies bits.\n+\n+  All cases lead to contradictions, which mean r < v is incorrect, which means\n+  that r >= v.\n+\n+  As a result, r == v, which means the value v having the above form is the\n+  lowest value not smaller than lo that satisfies bits.\n+\n+  Our objective now is to find the largest value i that satisfies:\n+  - lo[x] satisfies bits for 0 <= x < i\n+  - zeros[i] = 0\n+  - lo[i] = 0\n+\n+  Call j the largest value such that lo[x] satisfies bits for 0 <= x < j. This\n+  means that j is the smallest value such that lo[j] does not satisfy bits. We\n+  call this the first violation. i then can be computed as the largest value\n+  <= j such that:\n+\n+  zeros[i] == lo[i] == 0\n+  *\/\n@@ -114,6 +194,3 @@\n-    \/\/ is a 0 that should be a 1, this may be the first different bit we want\n-    \/\/ to find. The smallest value higher than lo with this bit being 1 would\n-    \/\/ have all lower bits being 0. This value satisfies zeros, because all\n-    \/\/ bits before the first violation have already satisfied zeros, and all\n-    \/\/ bits after the first violation are 0. To satisfy 1, simply | this value\n-    \/\/ with ones\n+    \/\/ is a 0 that should be a 1. Obviously, since the bit at that position in\n+    \/\/ ones is 1, the same bit in zeros is 0. Which means this is the value of\n+    \/\/ i we are looking for.\n@@ -131,1 +208,1 @@\n-    \/\/ Just | this value with ones to obtain the final result.\n+    \/\/ Just OR this value with ones to obtain the final result.\n@@ -134,1 +211,1 @@\n-    \/\/ lowest bit up (0-based)\n+    \/\/ lowest bit up (0-based), since i == 2, first_difference == 6\n@@ -138,1 +215,1 @@\n-    \/\/ This is the first value which have the violated bit set, which means\n+    \/\/ This is the first value which have the violated bit being 1, which means\n@@ -145,9 +222,3 @@\n-    \/\/ This is more difficult because trying to unset a bit requires us to flip\n-    \/\/ some bits before it.\n-    \/\/ Consider the first bit that is changed, it must not be 1 already, and it\n-    \/\/ must not be 1 in zeros. As a result, it must be the last bit before the\n-    \/\/ first bit violation that is 0 in both zeros and lo. As a result, the\n-    \/\/ smallest number not smaller than lo that satisfies zeros would have this\n-    \/\/ bit being 1 and all lower bits being 0. Similar to the case with\n-    \/\/ zero_violation < one_violation, | this value with ones gives us the\n-    \/\/ final result.\n+    \/\/ This means that the first bit that does not satisfy the bit requirement\n+    \/\/ is a 1 that should be a 0. Trace backward to find i which is the last\n+    \/\/ bit that is 0 in both lo and zeros.\n@@ -177,2 +248,2 @@\n-    \/\/ The bit we want to set is the last bit unset in either that stands before\n-    \/\/ the first violation, which is the last set bit of tmp\n+    \/\/ i is the last bit being 0 in either that stands before the first\n+    \/\/ violation, which is the last set bit of tmp\n@@ -181,1 +252,2 @@\n-    \/\/ Isolate the last bit\n+    \/\/ i == 2 here, shortcut the calculation instead of explicitly spelling out\n+    \/\/ i\n@@ -184,2 +256,2 @@\n-    \/\/ Set the bit and unset all the bit after, this is the smallest value that\n-    \/\/ satisfies bits._zeros\n+    \/\/ Set the bit at i and unset all the bit after, this is the smallest value\n+    \/\/ that satisfies bits._zeros\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":111,"deletions":39,"binary":false,"changes":150,"status":"modified"}]}