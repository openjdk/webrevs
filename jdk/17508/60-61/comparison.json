{"files":[{"patch":"@@ -286,1 +286,1 @@\n-    \/\/ up to a multiple of this modulo.\n+    \/\/ up to the next multiple of this modulo.\n@@ -290,9 +290,9 @@\n-    \/\/ that the result should not be smaller than this. This is a standard\n-    \/\/ operation to align a value up to a multiple of a certain power of 2.\n-    \/\/ Since alignment is a power of 2, -alignment is a value having all the\n-    \/\/ bits being 1 upto the location of the bit in alignment (in the example,\n-    \/\/ -alignment = 11110000). As a result, lo & -alignment set all bits after\n-    \/\/ the bit in alignment to 0, which is equivalent to rounding lo down to a\n-    \/\/ multiple of alignment. Since lo is not divisible by alignment, to round\n-    \/\/ lo up to a multiple of alignment, we add alignment to the rounded down\n-    \/\/ value.\n+    \/\/ that the result should not be smaller than this.\n+    \/\/ This is a standard operation to align a value up to the next multiple of\n+    \/\/ a certain power of 2. Since alignment is a power of 2, -alignment is a\n+    \/\/ value having all the bits being 1 upto the location of the bit in\n+    \/\/ alignment (in the example, -alignment = 11110000). As a result,\n+    \/\/ lo & -alignment set all bits after the bit in alignment to 0, which is\n+    \/\/ equivalent to rounding lo down to a multiple of alignment. To round lo\n+    \/\/ up to the next multiple of alignment, we add alignment to the rounded\n+    \/\/ down value.\n@@ -382,2 +382,2 @@\n-    \/\/ this is similar to aligning lo up to a multiple of alignment. Also\n-    \/\/ similar to the above case, this computation cannot overflow.\n+    \/\/ this is similar to aligning lo up to the next multiple of alignment.\n+    \/\/ Also similar to the above case, this computation cannot overflow.\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"}]}