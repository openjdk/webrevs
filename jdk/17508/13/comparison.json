{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -476,1 +476,5 @@\n-  const TypeInteger* this_type = this->type()->is_integer(bt);\n+  const TypeInteger* this_type = this->type()->isa_integer(bt);\n+  if (this_type == nullptr) {\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4482,1 +4482,3 @@\n-  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n+  if (sizetype != nullptr && sizetype->_hi > 0) {\n+    index_max = sizetype->_hi - 1;\n+  }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -927,2 +927,2 @@\n-  inline Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n-                                       int idx, bool can_grow = false);\n+  Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n+                                int idx, bool can_grow = false);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3884,1 +3884,3 @@\n-      if (size_max > tilen->_hi)  size_max = tilen->_hi;\n+      if (size_max > tilen->_hi && tilen->_hi >= 0) {\n+        size_max = tilen->_hi;\n+      }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1052,2 +1052,1 @@\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->empty()) {\n+        if (failtype->filter(type2) == Type::TOP) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,769 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n+#include \"opto\/type.hpp\"\n+#include \"utilities\/tuple.hpp\"\n+\n+constexpr juint SMALLINT = 3; \/\/ a value too insignificant to consider widening\n+\n+template <class T>\n+class AdjustResult {\n+public:\n+  \/\/ Denote whether there is a change in _data compared to the previous\n+  \/\/ iteration\n+  bool _progress;\n+  bool _present; \/\/ whether the constraints are contradictory\n+  T _data;\n+\n+  static AdjustResult<T> make_empty() {\n+    return {true, false, {}};\n+  }\n+};\n+\n+\/\/ In the canonical form, [lo, hi] intersects with [ulo, uhi] can result in 2\n+\/\/ cases:\n+\/\/ - [lo, hi] is the same as [ulo, uhi], lo and hi are both >= 0 or both < 0\n+\/\/ - [lo, hi] is not the same as [ulo, uhi], which results in the intersections\n+\/\/ being [lo, uhi] and [ulo, hi], lo and uhi are < 0 while ulo and hi are >= 0\n+\/\/ This class deals with each interval with both bounds being >= 0 or < 0\n+template <class U>\n+class SimpleCanonicalResult {\n+  static_assert(std::is_unsigned<U>::value, \"bit info should be unsigned\");\n+public:\n+  bool _present; \/\/ whether this is an empty set\n+  RangeInt<U> _bounds;\n+  KnownBits<U> _bits;\n+\n+  static SimpleCanonicalResult<U> make_empty() {\n+    return {false, {}, {}};\n+  }\n+};\n+\n+\/\/ Find the minimum value that is not less than lo and satisfies bits\n+template <class U>\n+static U adjust_lo(U lo, const KnownBits<U>& bits) {\n+  constexpr size_t W = sizeof(U) * 8;\n+  \/\/ Violation of lo with respects to bits\n+  \/\/ E.g: lo    = 1100\n+  \/\/      zeros = 0100\n+  \/\/      ones  = 1001\n+  \/\/ zero_violation = 0100, i.e the second bit should be zero, but it is 1 in\n+  \/\/ lo. Similarly, one_violation = 0001, i.e the forth bit should be one, but\n+  \/\/ it is 0 in lo. These make lo not satisfy the bit constraints, which\n+  \/\/ results in us having to find the smallest value that satisfies bits\n+  U zero_violation = lo & bits._zeros;\n+  U one_violation = ~lo & bits._ones;\n+  if (zero_violation == one_violation) {\n+    \/\/ This means lo does not violate bits, it is the result\n+    assert(zero_violation == 0, \"\");\n+    return lo;\n+  }\n+\n+  \/\/ The principal here is that, consider the first bit in result that is\n+  \/\/ different from the corresponding bit in lo, since result is larger than lo\n+  \/\/ the bit must be unset in lo and set in result. As result should be the\n+  \/\/ smallest value, the position of this bit should be as low as possible\n+  \/\/ E.g:      1 2 3 4 5 6\n+  \/\/      lo = 1 0 0 1 1 0\n+  \/\/       x = 1 0 1 0 1 0\n+  \/\/       y = 0 1 1 1 1 1\n+  \/\/ x would be larger than lo since the first different bit is the 3rd one,\n+  \/\/ while y is smaller than lo because the first different bit is the 1st bit.\n+  \/\/ Next consider:\n+  \/\/      x1 = 1 0 1 0 1 0\n+  \/\/      x2 = 1 0 0 1 1 1\n+  \/\/ Both x1 and x2 are larger than lo, but x1 > x2 since its first different\n+  \/\/ bit from lo is the 3rd one, while with x2 it is the 7th one. As a result,\n+  \/\/ if both x1 and x2 satisfy bits, x2 would be closer to our true result.\n+  if (zero_violation < one_violation) {\n+    \/\/ This means that the first bit that does not satisfy the bit requirement\n+    \/\/ is a 0 that should be a 1, this may be the first different bit we want\n+    \/\/ to find.\n+    \/\/ E.g:      1 2 3 4 5 6 7 8\n+    \/\/      lo = 1 0 0 1 0 0 1 0\n+    \/\/   zeros = 0 0 1 0 0 1 0 0\n+    \/\/    ones = 0 1 0 0 1 0 1 0\n+    \/\/   1-vio = 0 1 0 0 1 0 0 0\n+    \/\/   0-vio = 0 0 0 0 0 0 0 0\n+    \/\/ Since the result must have the 2nd bit set, it must be at least:\n+    \/\/           1 1 0 0 0 0 0 0\n+    \/\/ This value must satisfy zeros, because all bits before the 2nd bit have\n+    \/\/ already satisfied zeros, and all bits after the 2nd bit are all 0 now.\n+    \/\/ Continue the logic with each set bit in ones, we will set each bit in\n+    \/\/ our new lo (11000000 -> 11001000 -> 11001010). The final value is our\n+    \/\/ result.\n+    \/\/ Implementationwise, from 11000000 we can just | with ones to obtain the\n+    \/\/ final result.\n+\n+    \/\/ first_violation is the position of the violation counting from the\n+    \/\/ lowest bit up (0-based)\n+    juint first_violation = W - 1 - count_leading_zeros(one_violation); \/\/ 6\n+    \/\/           0 1 0 0 0 0 0 0\n+    U alignment = U(1) << first_violation;\n+    \/\/ This is the first value which have the violated bit set, which means\n+    \/\/ that the result should not be smaller than this\n+    \/\/           1 1 0 0 0 0 0 0\n+    lo = (lo & -alignment) + alignment;\n+    \/\/           1 1 0 0 1 0 1 0\n+    return lo | bits._ones;\n+  }\n+\n+  \/\/ This is more difficult because trying to unset a bit requires us to flip\n+  \/\/ some bits before it (higher bits).\n+  \/\/ Consider the first bit that is change, it must not be set already, and it\n+  \/\/ must not be set in zeros. As a result, it must be the last bit before the\n+  \/\/ first bit violation that is unset in both zeros and lo.\n+  \/\/ E.g:      1 2 3 4 5 6 7 8\n+  \/\/      lo = 1 0 0 0 1 1 1 0\n+  \/\/   zeros = 0 0 0 1 0 1 0 0\n+  \/\/    ones = 1 0 0 0 0 0 1 1\n+  \/\/   1-vio = 0 0 0 0 0 0 0 1\n+  \/\/   0-vio = 0 0 0 0 0 1 0 0\n+  \/\/ The first violation is the 6th bit, which should be 0. The 5th cannot be\n+  \/\/ the first different bit we are looking for, because it is already 1, the\n+  \/\/ 4th bit also cannot be, because it must be 0. As a result, the first\n+  \/\/ different bit between the result and lo must be the 3rd bit. As a result,\n+  \/\/ the result must not be smaller than:\n+  \/\/           1 0 1 0 0 0 0 0\n+  \/\/ This one satisfies zeros so we can use the logic in the previous case to\n+  \/\/ obtain our final result, which is:\n+  \/\/           1 0 1 0 0 0 1 1\n+\n+  juint first_violation = W - count_leading_zeros(zero_violation);\n+  \/\/ This mask out all bits from the first violation\n+  \/\/           1 1 1 1 1 0 0 0\n+  U find_mask = std::numeric_limits<U>::max() << first_violation;\n+  \/\/           1 0 0 1 1 1 1 0\n+  U either = lo | bits._zeros;\n+  \/\/ The bit we want to set is the last bit unset in either that stands before\n+  \/\/ the first violation, which is the last set bit of tmp\n+  \/\/           0 1 1 0 0 0 0 0\n+  U tmp = ~either & find_mask;\n+  \/\/ Isolate the last bit\n+  \/\/           0 0 1 0 0 0 0 0\n+  U alignment = tmp & (-tmp);\n+  \/\/ Set the bit and unset all the bit after, this is the smallest value that\n+  \/\/ satisfies bits._zeros\n+  \/\/           1 0 1 0 0 0 0 0\n+  lo = (lo & -alignment) + alignment;\n+  \/\/ Satisfy bits._ones\n+  \/\/           1 0 1 0 0 0 1 1\n+  return lo | bits._ones;\n+}\n+\n+\/\/ Try to tighten the bound constraints from the known bit information. I.e, we\n+\/\/ find the smallest value not smaller than lo, as well as the largest value\n+\/\/ not larger than hi both of which satisfy bits\n+\/\/ E.g: lo = 0010, hi = 1001\n+\/\/ zeros = 0011\n+\/\/ ones  = 0000\n+\/\/ -> 4-aligned\n+\/\/\n+\/\/         0    1    2    3    4    5    6    7    8    9    10\n+\/\/         0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010\n+\/\/ bits:   ok   .    .    .    ok   .    .    .    ok   .    .\n+\/\/ bounds:           lo                                 hi\n+\/\/ adjust:           --------> lo                  hi <---\n+template <class U>\n+static AdjustResult<RangeInt<U>>\n+adjust_bounds_from_bits(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n+  U new_lo = adjust_lo(bounds._lo, bits);\n+  if (new_lo < bounds._lo) {\n+    \/\/ This means we wrapped around, which means no value not less than lo\n+    \/\/ satisfies bits\n+    return AdjustResult<RangeInt<U>>::make_empty();\n+  }\n+\n+  \/\/ We need to find the largest value not larger than hi that satisfies bits\n+  \/\/ One possible method is to do similar to adjust_lo, just with the other\n+  \/\/ direction\n+  \/\/ However, we can observe that if v satisfies {bits._zeros, bits._ones},\n+  \/\/ then ~v would satisfy {bits._ones, bits._zeros}. Combine with the fact\n+  \/\/ that ~ is a strictly decreasing function, if new_hi is the largest value\n+  \/\/ not larger than hi that satisfies {bits._zeros, bits._ones}, then ~new_hi\n+  \/\/ is the smallest value not smaller than ~hi that satisfies\n+  \/\/ {bits._ones, bits._zeros}\n+  U new_hi = ~adjust_lo(~bounds._hi, {bits._ones, bits._zeros});\n+  if (new_hi > bounds._hi) {\n+    return AdjustResult<RangeInt<U>>::make_empty();\n+  }\n+\n+  bool progress = (new_lo != bounds._lo) || (new_hi != bounds._hi);\n+  bool present = new_lo <= new_hi;\n+  return {progress, present, {new_lo, new_hi}};\n+}\n+\n+\/\/ Try to tighten the known bit constraints from the bound information by\n+\/\/ extracting the common prefix of lo and hi and combining with the current\n+\/\/ bit constraints\n+\/\/ E.g: lo = 010011\n+\/\/      hi = 010100,\n+\/\/ then all values in [lo, hi] would be\n+\/\/           010***\n+template <class U>\n+static AdjustResult<KnownBits<U>>\n+adjust_bits_from_bounds(const KnownBits<U>& bits, const RangeInt<U>& bounds) {\n+  \/\/ Find the mask to filter the common prefix, all values between bounds._lo\n+  \/\/ and bounds._hi should share this common prefix in terms of bits\n+  U mismatch = bounds._lo ^ bounds._hi;\n+  \/\/ Find the first mismatch, all bits before it is the same in bounds._lo and\n+  \/\/ bounds._hi\n+  U match_mask = mismatch == 0 ? std::numeric_limits<U>::max()\n+                               : ~(std::numeric_limits<U>::max() >> count_leading_zeros(mismatch));\n+  \/\/ match_mask & bounds._lo is the common prefix, extract zeros and ones from\n+  \/\/ it\n+  U new_zeros = bits._zeros | (match_mask &~ bounds._lo);\n+  U new_ones = bits._ones | (match_mask & bounds._lo);\n+  bool progress = (new_zeros != bits._zeros) || (new_ones != bits._ones);\n+  bool present = ((new_zeros & new_ones) == 0);\n+  return {progress, present, {new_zeros, new_ones}};\n+}\n+\n+\/\/ Try to tighten both the bounds and the bits at the same time\n+\/\/ Iteratively tighten 1 using the other until no progress is made.\n+\/\/ This function converges because at each iteration, some bits that are\n+\/\/ unknown is made known. As there are at most 64 bits, the number of\n+\/\/ iterations should not be larger than 64\n+template <class U>\n+static SimpleCanonicalResult<U>\n+canonicalize_constraints_simple(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n+  AdjustResult<KnownBits<U>> nbits = adjust_bits_from_bounds(bits, bounds);\n+  if (!nbits._present) {\n+    return SimpleCanonicalResult<U>::make_empty();\n+  }\n+  AdjustResult<RangeInt<U>> nbounds{true, true, bounds};\n+  \/\/ Since bits are derived from bounds in the previous iteration and vice\n+  \/\/ versa, if one does not show progress, the other will also not show\n+  \/\/ progress, so we terminate early\n+  while (true) {\n+    nbounds = adjust_bounds_from_bits(nbounds._data, nbits._data);\n+    if (!nbounds._progress || !nbounds._present) {\n+      return {nbounds._present, nbounds._data, nbits._data};\n+    }\n+    nbits = adjust_bits_from_bounds(nbits._data, nbounds._data);\n+    if (!nbits._progress || !nbits._present) {\n+      return {nbits._present, nbounds._data, nbits._data};\n+    }\n+  }\n+}\n+\n+\/\/ Tighten all constraints of a TypeIntPrototype to its canonical form.\n+\/\/ i.e the result represents the same set as the input, each bound belongs to\n+\/\/ the set and for each bit position that is not constrained, there exists 2\n+\/\/ values with the bit value at that position being set and unset, respectively,\n+\/\/ such that both belong to the set represented by the constraints.\n+template <class S, class U>\n+CanonicalizedTypeIntPrototype<S, U>\n+TypeIntPrototype<S, U>::canonicalize_constraints() const {\n+  RangeInt<S> srange = _srange;\n+  RangeInt<U> urange = _urange;\n+  \/\/ Trivial contradictions\n+  if (srange._lo > srange._hi ||\n+      urange._lo > urange._hi ||\n+      (_bits._zeros & _bits._ones) != 0) {\n+    return CanonicalizedTypeIntPrototype<S, U>::make_empty();\n+  }\n+\n+  \/\/ Trivially canonicalize the bounds so that srange._lo and urange._hi are\n+  \/\/ both < 0 or >= 0. The same for srange._hi and urange._ulo\n+  if (S(urange._lo) > S(urange._hi)) {\n+    if (S(urange._hi) < srange._lo) {\n+      urange._hi = std::numeric_limits<S>::max();\n+    } else if (S(urange._lo) > srange._hi) {\n+      urange._lo = std::numeric_limits<S>::min();\n+    }\n+  }\n+\n+  if (S(urange._lo) <= S(urange._hi)) {\n+    \/\/ [lo, hi] and [ulo, uhi] represent the same range\n+    urange._lo = MAX2<S>(urange._lo, srange._lo);\n+    urange._hi = MIN2<S>(urange._hi, srange._hi);\n+    if (urange._lo > urange._hi) {\n+      return CanonicalizedTypeIntPrototype<S, U>::make_empty();\n+    }\n+\n+    auto type = canonicalize_constraints_simple(urange, _bits);\n+    return {type._present, {{S(type._bounds._lo), S(type._bounds._hi)},\n+                            type._bounds, type._bits}};\n+  }\n+\n+  \/\/ [lo, hi] intersects with [ulo, uhi] in 2 ranges:\n+  \/\/ [lo, uhi], which consists of negative values\n+  \/\/ [ulo, hi] which consists of non-negative values\n+  \/\/ We process these 2 separately and combine the results\n+  auto neg_type = canonicalize_constraints_simple({U(srange._lo), urange._hi}, _bits);\n+  auto pos_type = canonicalize_constraints_simple({urange._lo, U(srange._hi)}, _bits);\n+\n+  if (!neg_type._present && !pos_type._present) {\n+    return CanonicalizedTypeIntPrototype<S, U>::make_empty();\n+  } else if (!neg_type._present) {\n+    return {true, {{S(pos_type._bounds._lo), S(pos_type._bounds._hi)},\n+                   pos_type._bounds, pos_type._bits}};\n+  } else if (!pos_type._present) {\n+    return {true, {{S(neg_type._bounds._lo), S(neg_type._bounds._hi)},\n+                   neg_type._bounds, neg_type._bits}};\n+  } else {\n+    return {true, {{S(neg_type._bounds._lo), S(pos_type._bounds._hi)},\n+                   {pos_type._bounds._lo, neg_type._bounds._hi},\n+                   {neg_type._bits._zeros & pos_type._bits._zeros, neg_type._bits._ones & pos_type._bits._ones}}};\n+  }\n+}\n+\n+template <class S, class U>\n+int TypeIntPrototype<S, U>::normalize_widen(int w) const {\n+  \/\/ Certain normalizations keep us sane when comparing types.\n+  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n+  if (cardinality_from_bounds(_srange, _urange) <= SMALLINT) {\n+    return Type::WidenMin;\n+  }\n+  if (_srange._lo == std::numeric_limits<S>::min() && _srange._hi == std::numeric_limits<S>::max() &&\n+      _urange._lo == std::numeric_limits<U>::min() && _urange._hi == std::numeric_limits<U>::max() &&\n+      _bits._zeros == 0 && _bits._ones == 0) {\n+    \/\/ bottom type\n+    return Type::WidenMax;\n+  }\n+  return w;\n+}\n+\n+#ifdef ASSERT\n+template <class S, class U>\n+bool TypeIntPrototype<S, U>::contains(S v) const {\n+  U u = v;\n+  return v >= _srange._lo && v <= _srange._hi && u >= _urange._lo && u <= _urange._hi && _bits.is_satisfied_by(u);\n+}\n+\n+\/\/ Verify that this set representation is canonical\n+template <class S, class U>\n+void TypeIntPrototype<S, U>::verify_constraints() const {\n+  \/\/ Assert that the bounds cannot be further tightened\n+  assert(contains(_srange._lo) && contains(_srange._hi) &&\n+         contains(_urange._lo) && contains(_urange._hi), \"\");\n+\n+  \/\/ Assert that the bits cannot be further tightened\n+  if (U(_srange._lo) == _urange._lo) {\n+    assert(!adjust_bits_from_bounds(_bits, _urange)._progress, \"\");\n+  } else {\n+    RangeInt<U> neg_range{U(_srange._lo), _urange._hi};\n+    auto neg_bits = adjust_bits_from_bounds(_bits, neg_range);\n+    assert(neg_bits._present, \"\");\n+    assert(!adjust_bounds_from_bits(neg_range, neg_bits._data)._progress, \"\");\n+\n+    RangeInt<U> pos_range{_urange._lo, U(_srange._hi)};\n+    auto pos_bits = adjust_bits_from_bounds(_bits, pos_range);\n+    assert(pos_bits._present, \"\");\n+    assert(!adjust_bounds_from_bits(pos_range, pos_bits._data)._progress, \"\");\n+\n+    assert((neg_bits._data._zeros & pos_bits._data._zeros) == _bits._zeros &&\n+           (neg_bits._data._ones & pos_bits._data._ones) == _bits._ones, \"\");\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+template class TypeIntPrototype<jint, juint>;\n+template class TypeIntPrototype<jlong, julong>;\n+\n+\/\/ Compute the meet of 2 types, when dual is true, we are actually computing the\n+\/\/ join.\n+template <class CT, class S, class U>\n+const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<S, U>&, int, bool), bool dual) {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if (i1 == t2 || t2 == Type::TOP) {\n+    return i1;\n+  }\n+  const CT* i2 = CT::try_cast(t2);\n+  if (i2 != nullptr) {\n+    if (!dual) {\n+    \/\/ meet\n+      return make(TypeIntPrototype<S, U>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n+                                         {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n+                                         {i1->_bits._zeros & i2->_bits._zeros, i1->_bits._ones & i2->_bits._ones}},\n+                  MAX2(i1->_widen, i2->_widen), false);\n+    }\n+    \/\/ join\n+    return make(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n+                                       {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n+                                       {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n+                MIN2(i1->_widen, i2->_widen), true);\n+  }\n+\n+  assert(t2->base() != i1->base(), \"\");\n+  switch (t2->base()) {          \/\/ Switch on original type\n+  case Type::AnyPtr:                  \/\/ Mixing with oops happens when javac\n+  case Type::RawPtr:                  \/\/ reuses local variables\n+  case Type::OopPtr:\n+  case Type::InstPtr:\n+  case Type::AryPtr:\n+  case Type::MetadataPtr:\n+  case Type::KlassPtr:\n+  case Type::InstKlassPtr:\n+  case Type::AryKlassPtr:\n+  case Type::NarrowOop:\n+  case Type::NarrowKlass:\n+  case Type::Int:\n+  case Type::Long:\n+  case Type::FloatTop:\n+  case Type::FloatCon:\n+  case Type::FloatBot:\n+  case Type::DoubleTop:\n+  case Type::DoubleCon:\n+  case Type::DoubleBot:\n+  case Type::Bottom:                  \/\/ Ye Olde Default\n+    return Type::BOTTOM;\n+  default:                      \/\/ All else is a mistake\n+    i1->typerr(t2);\n+    return nullptr;\n+  }\n+}\n+template const Type* int_type_xmeet(const TypeInt* i1, const Type* t2,\n+                                    const Type* (*make)(const TypeIntPrototype<jint, juint>&, int, bool), bool dual);\n+template const Type* int_type_xmeet(const TypeLong* i1, const Type* t2,\n+                                    const Type* (*make)(const TypeIntPrototype<jlong, julong>&, int, bool), bool dual);\n+\n+\/\/ Called in PhiNode::Value during CCP, monotically widen the value set, do so rigorously\n+\/\/ first, after WidenMax attempts, if the type has still not converged we speed up the\n+\/\/ convergence by abandoning the bounds\n+template <class CT>\n+const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt) {\n+  using S = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+\n+  if (ot == nullptr) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no widening\n+  if (int_type_equal(nt, ot)) {\n+    return ot;\n+  }\n+\n+  \/\/ If old guy contains new, then we probably widened too far & dropped to\n+  \/\/ bottom. Return the wider fellow.\n+  if (int_type_subset(ot, nt)) {\n+    return ot;\n+  }\n+\n+  \/\/ Neither contains each other, weird?\n+  \/\/ fatal(\"Integer value range is not subset\");\n+  \/\/ return this;\n+  if (!int_type_subset(nt, ot)) {\n+    return CT::TYPE_DOMAIN;\n+  }\n+\n+  \/\/ If old guy was a constant, do not bother\n+  if (ot->singleton()) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy contains old, then we widened\n+  \/\/ If new guy is already wider than old, no widening\n+  if (nt->_widen > ot->_widen) {\n+    return nt;\n+  }\n+\n+  if (nt->_widen < Type::WidenMax) {\n+    \/\/ Returned widened new guy\n+    TypeIntPrototype<S, U> prototype{{nt->_lo, nt->_hi}, {nt->_ulo, nt->_uhi}, nt->_bits};\n+    return CT::try_make(prototype, nt->_widen + 1);\n+  }\n+\n+  \/\/ Speed up the convergence by abandoning the bounds, there are only a couple of bits so\n+  \/\/ they converge fast\n+  S min = std::numeric_limits<S>::min();\n+  S max = std::numeric_limits<S>::max();\n+  U umin = std::numeric_limits<U>::min();\n+  U umax = std::numeric_limits<U>::max();\n+  U zeros = nt->_bits._zeros;\n+  U ones = nt->_bits._ones;\n+  if (lt != nullptr) {\n+    min = lt->_lo;\n+    max = lt->_hi;\n+    umin = lt->_ulo;\n+    umax = lt->_uhi;\n+    zeros |= lt->_bits._zeros;\n+    ones |= lt->_bits._ones;\n+  }\n+  TypeIntPrototype<S, U> prototype{{min, max}, {umin, umax}, {zeros, ones}};\n+  return CT::try_make(prototype, Type::WidenMax);\n+}\n+template const Type* int_type_widen(const TypeInt* nt, const TypeInt* ot, const TypeInt* lt);\n+template const Type* int_type_widen(const TypeLong* nt, const TypeLong* ot, const TypeLong* lt);\n+\n+\/\/ Called by PhiNode::Value during GVN, monotonically narrow the value set, only\n+\/\/ narrow if the bits change or if the bounds are tightened enough to avoid\n+\/\/ slow convergence\n+template <class CT>\n+const Type* int_type_narrow(const CT* nt, const CT* ot) {\n+  using S = decltype(CT::_lo);\n+  using U = decltype(CT::_ulo);\n+\n+  if (nt->singleton() || ot == nullptr) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no narrowing\n+  if (int_type_equal(nt, ot)) {\n+    return ot;\n+  }\n+\n+  \/\/ If old guy was maximum range, allow the narrowing\n+  if (int_type_equal(ot, CT::TYPE_DOMAIN)) {\n+    return nt;\n+  }\n+\n+  \/\/ Doesn't narrow; pretty weird\n+  if (!int_type_subset(ot, nt)) {\n+    return nt;\n+  }\n+\n+  \/\/ Bits change\n+  if (ot->_bits._zeros != nt->_bits._zeros || ot->_bits._ones != nt->_bits._ones) {\n+    return nt;\n+  }\n+\n+  \/\/ Only narrow if the range shrinks a lot\n+  U oc = cardinality_from_bounds(RangeInt<S>{ot->_lo, ot->_hi},\n+                                 RangeInt<U>{ot->_ulo, ot->_uhi});\n+  U nc = cardinality_from_bounds(RangeInt<S>{nt->_lo, nt->_hi},\n+                                 RangeInt<U>{nt->_ulo, nt->_uhi});\n+  return (nc > (oc >> 1) + (SMALLINT * 2)) ? ot : nt;\n+}\n+template const Type* int_type_narrow(const TypeInt* nt, const TypeInt* ot);\n+template const Type* int_type_narrow(const TypeLong* nt, const TypeLong* ot);\n+\n+\n+#ifndef PRODUCT\n+template <class T>\n+static const char* int_name_near(T origin, const char* xname, char* buf, size_t buf_size, T n) {\n+  if (n < origin) {\n+    if (n <= origin - 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s-\" INT32_FORMAT, xname, jint(origin - n));\n+  } else if (n > origin) {\n+    if (n >= origin + 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s+\" INT32_FORMAT, xname, jint(n - origin));\n+  } else {\n+    return xname;\n+  }\n+  return buf;\n+}\n+\n+const char* intname(char* buf, size_t buf_size, jint n) {\n+  const char* str = int_name_near<jint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jint>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n+  return buf;\n+}\n+\n+const char* uintname(char* buf, size_t buf_size, juint n) {\n+  const char* str = int_name_near<juint>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<juint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, UINT32_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n+const char* longname(char* buf, size_t buf_size, jlong n) {\n+  const char* str = int_name_near<jlong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(min_jlong, \"minlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n+  return buf;\n+}\n+\n+const char* ulongname(char* buf, size_t buf_size, julong n) {\n+  const char* str = int_name_near<julong>(max_julong, \"maxulong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<julong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<julong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<julong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JULONG_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n+template <class U>\n+const char* bitname(char* buf, size_t buf_size, U zeros, U ones) {\n+  constexpr juint W = sizeof(U) * 8;\n+\n+  if (buf_size < W + 1) {\n+    return \"#####\";\n+  }\n+\n+  for (juint i = 0; i < W; i++) {\n+    U mask = U(1) << (W - 1 - i);\n+    if ((zeros & mask) != 0) {\n+      buf[i] = '0';\n+    } else if ((ones & mask) != 0) {\n+      buf[i] = '1';\n+    } else {\n+      buf[i] = '*';\n+    }\n+  }\n+  buf[W] = 0;\n+  return buf;\n+}\n+template const char* bitname(char* buf, size_t buf_size, juint zeros, juint ones);\n+template const char* bitname(char* buf, size_t buf_size, julong zeros, julong ones);\n+\n+void int_type_dump(const TypeInt* t, outputStream* st, bool verbose) {\n+  char buf1[40], buf2[40], buf3[40], buf4[40], buf5[40];\n+  if (int_type_equal(t, TypeInt::INT)) {\n+    st->print(\"int\");\n+  } else if (t->is_con()) {\n+    st->print(\"int:%s\", intname(buf1, sizeof(buf1), t->get_con()));\n+  } else if (int_type_equal(t, TypeInt::BOOL)) {\n+    st->print(\"bool\");\n+  } else if (int_type_equal(t, TypeInt::BYTE)) {\n+    st->print(\"byte\");\n+  } else if (int_type_equal(t, TypeInt::CHAR)) {\n+    st->print(\"char\");\n+  } else if (int_type_equal(t, TypeInt::SHORT)) {\n+    st->print(\"short\");\n+  } else {\n+    if (verbose) {\n+      st->print(\"int:%s..%s, %s..%s, %s\",\n+                intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi),\n+                uintname(buf3, sizeof(buf3), t->_ulo), uintname(buf4, sizeof(buf4), t->_uhi),\n+                bitname(buf5, sizeof(buf5), t->_bits._zeros, t->_bits._ones));\n+    } else {\n+      if (t->_lo >= 0) {\n+        if (t->_hi == max_jint) {\n+          st->print(\"int:>=%s\", intname(buf1, sizeof(buf1), t->_lo));\n+        } else {\n+          st->print(\"int:%s..%s\", intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else if (t->_hi < 0) {\n+        if (t->_lo == min_jint) {\n+          st->print(\"int:<=%s\", intname(buf1, sizeof(buf1), t->_hi));\n+        } else {\n+          st->print(\"int:%s..%s\", intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else {\n+        st->print(\"int:%s..%s, %s..%s\",\n+                  intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi),\n+                  uintname(buf3, sizeof(buf3), t->_ulo), uintname(buf4, sizeof(buf4), t->_uhi));\n+      }\n+\n+    }\n+  }\n+\n+  if (t->_widen > 0 && t != TypeInt::INT) {\n+    st->print(\", widen: %d\", t->_widen);\n+  }\n+}\n+\n+void int_type_dump(const TypeLong* t, outputStream* st, bool verbose) {\n+  char buf1[80], buf2[80], buf3[80], buf4[80], buf5[80];\n+  if (int_type_equal(t, TypeLong::LONG)) {\n+    st->print(\"long\");\n+  } else if (t->is_con()) {\n+    st->print(\"long:%s\", longname(buf1, sizeof(buf1), t->get_con()));\n+  } else {\n+    if (verbose) {\n+      st->print(\"long:%s..%s ^ %s..%s, bits:%s\",\n+                longname(buf1, sizeof(buf1), t->_lo), longname(buf2,sizeof(buf2), t-> _hi),\n+                ulongname(buf3, sizeof(buf3), t->_ulo), ulongname(buf4, sizeof(buf4), t->_uhi),\n+                bitname(buf5, sizeof(buf5), t->_bits._zeros, t->_bits._ones));\n+    } else {\n+      if (t->_lo >= 0) {\n+        if (t->_hi == max_jint) {\n+          st->print(\"long:>=%s\", longname(buf1, sizeof(buf1), t->_lo));\n+        } else {\n+          st->print(\"long:%s..%s\", longname(buf1, sizeof(buf1), t->_lo), longname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else if (t->_hi < 0) {\n+        if (t->_lo == min_jint) {\n+          st->print(\"long:<=%s\", longname(buf1, sizeof(buf1), t->_hi));\n+        } else {\n+          st->print(\"long:%s..%s\", longname(buf1, sizeof(buf1), t->_lo), longname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else {\n+        st->print(\"long:%s..%s ^ %s..%s\",\n+                  longname(buf1, sizeof(buf1), t->_lo), longname(buf2,sizeof(buf2), t-> _hi),\n+                  ulongname(buf3, sizeof(buf3), t->_ulo), ulongname(buf4, sizeof(buf4), t->_uhi));\n+      }\n+    }\n+  }\n+\n+  if (t->_widen > 0 && t != TypeLong::LONG) {\n+    st->print(\", widen: %d\", t->_widen);\n+  }\n+}\n+#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":769,"deletions":0,"binary":false,"changes":769,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_RANGEINFERENCE_HPP\n+#define SHARE_OPTO_RANGEINFERENCE_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include <type_traits>\n+\n+class outputStream;\n+class Type;\n+class TypeInt;\n+class TypeLong;\n+\n+template <class T>\n+class RangeInt {\n+public:\n+  T _lo;\n+  T _hi;\n+};\n+\n+\/**\n+ * Bits that are known to be 0 or 1. A value v satisfies this constraint iff\n+ * (v & zeros) == 0 && (~v & ones) == 0. I.e, all bits that is set in zeros\n+ * must be unset in v, and all bits that is set in ones must be set in v.\n+ *\n+ * E.g:\n+ * zeros: 00110100\n+ * ones:  10000010\n+ * Then:  10001010 would satisfy the bit constraints\n+ * while: 10011000 would not since the bit at the 4th position violates\n+ * zeros and the bit at the 7th position violates ones\n+ *\/\n+template <class U>\n+class KnownBits {\n+  static_assert(std::is_unsigned<U>::value, \"bit info should be unsigned\");\n+\n+public:\n+  U _zeros;\n+  U _ones;\n+\n+  bool is_satisfied_by(U v) const {\n+    return (v & _zeros) == 0 && (~v & _ones) == 0;\n+  }\n+};\n+\n+template <class S, class U>\n+class TypeIntPrototype;\n+\n+template <class S, class U>\n+class CanonicalizedTypeIntPrototype {\n+public:\n+  bool _present;\n+  TypeIntPrototype<S, U> _data;\n+\n+  static CanonicalizedTypeIntPrototype<S, U> make_empty() {\n+    return {false, {}};\n+  }\n+};\n+\n+template <class S, class U>\n+class TypeIntPrototype {\n+public:\n+  static_assert(std::is_signed<S>::value, \"\");\n+  static_assert(std::is_unsigned<U>::value, \"\");\n+  static_assert(sizeof(S) == sizeof(U), \"\");\n+\n+  RangeInt<S> _srange;\n+  RangeInt<U> _urange;\n+  KnownBits<U> _bits;\n+\n+  CanonicalizedTypeIntPrototype<S, U> canonicalize_constraints() const;\n+  int normalize_widen(int w) const;\n+#ifdef ASSERT\n+  bool contains(S v) const;\n+  void verify_constraints() const;\n+#endif \/\/ ASSERT\n+};\n+\n+\/\/ The result is tuned down by one since we do not have empty type\n+\/\/ and this is not required to be accurate\n+template <class S, class U>\n+U cardinality_from_bounds(const RangeInt<S>& srange, const RangeInt<U>& urange) {\n+  if (U(srange._lo) == urange._lo) {\n+    return urange._hi - urange._lo;\n+  }\n+\n+  return urange._hi - U(srange._lo) + U(srange._hi) - urange._lo + 1;\n+}\n+\n+template <class CT, class S, class U>\n+const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<S, U>&, int, bool), bool dual);\n+\n+template <class CT>\n+bool int_type_equal(const CT* t1, const CT* t2) {\n+  return t1->_lo == t2->_lo && t1->_hi == t2->_hi && t1->_ulo == t2->_ulo && t1->_uhi == t2->_uhi &&\n+         t1->_bits._zeros == t2->_bits._zeros && t1->_bits._ones == t2->_bits._ones;\n+}\n+\n+template <class CT>\n+bool int_type_subset(const CT* super, const CT* sub) {\n+  return super->_lo <= sub->_lo && super->_hi >= sub->_hi && super->_ulo <= sub->_ulo && super->_uhi >= sub->_uhi &&\n+         (super->_bits._zeros &~ sub->_bits._zeros) == 0 && (super->_bits._ones &~ sub->_bits._ones) == 0;\n+}\n+\n+template <class CT>\n+const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt);\n+\n+template <class CT>\n+const Type* int_type_narrow(const CT* nt, const CT* ot);\n+\n+#ifndef PRODUCT\n+const char* intname(char* buf, size_t buf_size, jint n);\n+const char* uintname(char* buf, size_t buf_size, juint n);\n+const char* longname(char* buf, size_t buf_size, jlong n);\n+const char* ulongname(char* buf, size_t buf_size, julong n);\n+\n+template <class U>\n+const char* bitname(char* buf, size_t buf_size, U zeros, U ones);\n+\n+void int_type_dump(const TypeInt* t, outputStream* st, bool verbose);\n+void int_type_dump(const TypeLong* t, outputStream* st, bool verbose);\n+#endif \/\/ PRODUCT\n+\n+#endif \/\/ SHARE_OPTO_RANGEINFERENCE_HPP\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -423,1 +424,0 @@\n-#define SMALLINT ((juint)3)  \/\/ a value too insignificant to consider widening\n@@ -474,19 +474,21 @@\n-  TypeInt::MINUS_1 = TypeInt::make(-1);  \/\/ -1\n-  TypeInt::ZERO    = TypeInt::make( 0);  \/\/  0\n-  TypeInt::ONE     = TypeInt::make( 1);  \/\/  1\n-  TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n-  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n-  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n-  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n-  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n-  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);\n-  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n-  TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); \/\/ Bytes\n-  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); \/\/ Unsigned Bytes\n-  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); \/\/ Java chars\n-  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); \/\/ Java shorts\n-  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); \/\/ Non-neg values\n-  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); \/\/ Positive values\n-  TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); \/\/ 32-bit integers\n-  TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); \/\/ symmetric range\n-  TypeInt::TYPE_DOMAIN  = TypeInt::INT;\n+  TypeInt::MINUS_1  = TypeInt::make(-1);  \/\/ -1\n+  TypeInt::ZERO     = TypeInt::make( 0);  \/\/  0\n+  TypeInt::ONE      = TypeInt::make( 1);  \/\/  1\n+  TypeInt::BOOL     = TypeInt::make( 0, 1, WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n+  TypeInt::CC       = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n+  TypeInt::CC_LT    = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n+  TypeInt::CC_GT    = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n+  TypeInt::CC_EQ    = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n+  TypeInt::CC_NE    = TypeInt::try_make(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n+  TypeInt::CC_LE    = TypeInt::make(-1, 0, WidenMin);\n+  TypeInt::CC_GE    = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n+  TypeInt::BYTE     = TypeInt::make(-128, 127,     WidenMin); \/\/ Bytes\n+  TypeInt::UBYTE    = TypeInt::make(0, 255,        WidenMin); \/\/ Unsigned Bytes\n+  TypeInt::CHAR     = TypeInt::make(0, 65535,      WidenMin); \/\/ Java chars\n+  TypeInt::SHORT    = TypeInt::make(-32768, 32767, WidenMin); \/\/ Java shorts\n+  TypeInt::NON_ZERO = TypeInt::try_make(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n+  TypeInt::POS      = TypeInt::make(0, max_jint,   WidenMin); \/\/ Non-neg values\n+  TypeInt::POS1     = TypeInt::make(1, max_jint,   WidenMin); \/\/ Positive values\n+  TypeInt::INT      = TypeInt::make(min_jint, max_jint, WidenMax); \/\/ 32-bit integers\n+  TypeInt::SYMINT   = TypeInt::make(-max_jint, max_jint, WidenMin); \/\/ symmetric range\n+  TypeInt::TYPE_DOMAIN = TypeInt::INT;\n@@ -494,1 +496,1 @@\n-  \/\/ a trinary (-1,0,+1) integer result AND as an efficient long\n+  \/\/ a trinary (-1, 0, +1) integer result AND as an efficient long\n@@ -496,16 +498,17 @@\n-  assert( TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n-  assert( (juint)(TypeInt::CC->_hi - TypeInt::CC->_lo) <= SMALLINT, \"CC is truly small\");\n-\n-  TypeLong::MAX = TypeLong::make(max_jlong);  \/\/ Long MAX\n-  TypeLong::MIN = TypeLong::make(min_jlong);  \/\/ Long MIN\n-  TypeLong::MINUS_1 = TypeLong::make(-1);        \/\/ -1\n-  TypeLong::ZERO    = TypeLong::make( 0);        \/\/  0\n-  TypeLong::ONE     = TypeLong::make( 1);        \/\/  1\n-  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); \/\/ Non-neg values\n-  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); \/\/ 64-bit integers\n-  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);\n-  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);\n-  TypeLong::TYPE_DOMAIN  = TypeLong::LONG;\n+  assert(TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n+\n+  TypeLong::MAX = TypeLong::make(max_jlong); \/\/ Long MAX\n+  TypeLong::MIN = TypeLong::make(min_jlong); \/\/ Long MIN\n+  TypeLong::MINUS_1  = TypeLong::make(-1);   \/\/ -1\n+  TypeLong::ZERO     = TypeLong::make( 0);   \/\/  0\n+  TypeLong::ONE      = TypeLong::make( 1);   \/\/  1\n+  TypeLong::NON_ZERO = TypeLong::try_make(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n+  TypeLong::POS      = TypeLong::make(0, max_jlong, WidenMin); \/\/ Non-neg values\n+  TypeLong::NEG      = TypeLong::make(min_jlong, -1, WidenMin);\n+  TypeLong::LONG     = TypeLong::make(min_jlong, max_jlong, WidenMax); \/\/ 64-bit integers\n+  TypeLong::INT      = TypeLong::make((jlong)min_jint, (jlong)max_jint,WidenMin);\n+  TypeLong::UINT     = TypeLong::make(0, (jlong)max_juint, WidenMin);\n+  TypeLong::TYPE_DOMAIN = TypeLong::LONG;\n@@ -1568,25 +1571,23 @@\n-const TypeInt *TypeInt::MAX;    \/\/ INT_MAX\n-const TypeInt *TypeInt::MIN;    \/\/ INT_MIN\n-const TypeInt *TypeInt::MINUS_1;\/\/ -1\n-const TypeInt *TypeInt::ZERO;   \/\/ 0\n-const TypeInt *TypeInt::ONE;    \/\/ 1\n-const TypeInt *TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n-const TypeInt *TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n-const TypeInt *TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n-const TypeInt *TypeInt::CC_GT;  \/\/ [1]   == ONE\n-const TypeInt *TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n-const TypeInt *TypeInt::CC_LE;  \/\/ [-1,0]\n-const TypeInt *TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n-const TypeInt *TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n-const TypeInt *TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n-const TypeInt *TypeInt::CHAR;   \/\/ Java chars, 0-65535\n-const TypeInt *TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n-const TypeInt *TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n-const TypeInt *TypeInt::POS1;   \/\/ Positive 32-bit integers\n-const TypeInt *TypeInt::INT;    \/\/ 32-bit integers\n-const TypeInt *TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-const TypeInt *TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-\/\/------------------------------TypeInt----------------------------------------\n-TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int, w), _lo(lo), _hi(hi) {\n-}\n+const TypeInt* TypeInt::MAX;    \/\/ INT_MAX\n+const TypeInt* TypeInt::MIN;    \/\/ INT_MIN\n+const TypeInt* TypeInt::MINUS_1;\/\/ -1\n+const TypeInt* TypeInt::ZERO;   \/\/ 0\n+const TypeInt* TypeInt::ONE;    \/\/ 1\n+const TypeInt* TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n+const TypeInt* TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n+const TypeInt* TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n+const TypeInt* TypeInt::CC_GT;  \/\/ [1]   == ONE\n+const TypeInt* TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n+const TypeInt* TypeInt::CC_NE;\n+const TypeInt* TypeInt::CC_LE;  \/\/ [-1,0]\n+const TypeInt* TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n+const TypeInt* TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n+const TypeInt* TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n+const TypeInt* TypeInt::CHAR;   \/\/ Java chars, 0-65535\n+const TypeInt* TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n+const TypeInt* TypeInt::NON_ZERO;\n+const TypeInt* TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n+const TypeInt* TypeInt::POS1;   \/\/ Positive 32-bit integers\n+const TypeInt* TypeInt::INT;    \/\/ 32-bit integers\n+const TypeInt* TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+const TypeInt* TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n@@ -1594,3 +1595,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeInt *TypeInt::make( jint lo ) {\n-  return (TypeInt*)(new TypeInt(lo,lo,WidenMin))->hashcons();\n+TypeInt::TypeInt(const TypeIntPrototype<jint, juint>& t, int w, bool dual)\n+  : TypeInteger(Int, t.normalize_widen(w), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -1599,9 +1601,4 @@\n-static int normalize_int_widen( jint lo, jint hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n-  if (lo <= hi) {\n-    if (((juint)hi - lo) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)hi - lo) >= max_juint) w = Type::WidenMax; \/\/ TypeInt::INT\n-  } else {\n-    if (((juint)lo - hi) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)lo - hi) >= max_juint) w = Type::WidenMin; \/\/ dual TypeInt::INT\n+const Type* TypeInt::try_make(const TypeIntPrototype<jint, juint>& t, int w, bool dual) {\n+  auto new_t = t.canonicalize_constraints();\n+  if (!new_t._present) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -1609,1 +1606,1 @@\n-  return w;\n+  return (new TypeInt(new_t._data, w, dual))->hashcons()->is_int();\n@@ -1612,3 +1609,4 @@\n-const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {\n-  w = normalize_int_widen(lo, hi, w);\n-  return (TypeInt*)(new TypeInt(lo,hi,w))->hashcons();\n+const TypeInt* TypeInt::make(jint lo) {\n+  juint ulo = lo;\n+  return (new TypeInt(TypeIntPrototype<jint, juint>{{lo, lo}, {ulo, ulo}, {~ulo, ulo}},\n+                      WidenMin, false))->hashcons()->is_int();\n@@ -1617,41 +1615,3 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeInt::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeInt\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Long:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Int:                     \/\/ Int vs Int?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeInt *r = t->is_int();\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const TypeInt* TypeInt::make(jint lo, jint hi, int w) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return try_make(TypeIntPrototype<jint, juint>{{lo, hi}, {0, max_juint}, {0, 0}}, w)->is_int();\n@@ -1660,50 +1620,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeInt::xdual() const {\n-  int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeInt(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeInt::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Int ) return this;\n-  const TypeInt *ot = old->is_int();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      int max = max_jint;\n-      int min = min_jint;\n-      if (limit->isa_int()) {\n-        max = limit->is_int()->_hi;\n-        min = limit->is_int()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((juint)_lo - min) >= ((juint)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 31 bits:\n-          return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeInt::INT;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n+const Type* TypeInt::try_make(const TypeIntPrototype<jint, juint>& t, int w) {\n+  return try_make(t, w, false);\n+}\n@@ -1711,4 +1624,4 @@\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+bool TypeInt::contains(jint i) const {\n+  juint u = i;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi && _bits.is_satisfied_by(u);\n+}\n@@ -1716,3 +1629,2 @@\n-  \/\/fatal(\"Integer value range is not subset\");\n-  \/\/return this;\n-  return TypeInt::INT;\n+bool TypeInt::contains(const TypeInt* t) const {\n+  return int_type_subset(this, t);\n@@ -1721,9 +1633,3 @@\n-\/\/------------------------------narrow---------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeInt::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeInt* ot = old->isa_int();\n-  if (ot == nullptr)  return this;\n-  jint olo = ot->_lo;\n-  jint ohi = ot->_hi;\n+bool TypeInt::properly_contains(const TypeInt* t) const {\n+  return int_type_subset(this, t) && !int_type_equal(this, t);\n+}\n@@ -1731,2 +1637,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type* TypeInt::xmeet(const Type* t) const {\n+  return int_type_xmeet(this, t, TypeInt::try_make, _is_dual);\n+}\n@@ -1734,2 +1641,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jint && ohi == max_jint)  return this;\n+const Type* TypeInt::xdual() const {\n+  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                     _widen, !_is_dual);\n+}\n@@ -1737,2 +1646,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeInt::widen(const Type* old, const Type* limit) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  return int_type_widen(this, old->isa_int(), limit->isa_int());\n+}\n@@ -1740,8 +1651,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  juint nrange = (juint)_hi - _lo;\n-  juint orange = (juint)ohi - olo;\n-  if (nrange < max_juint - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeInt::narrow(const Type* old) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -1750,1 +1657,1 @@\n-  return this;\n+  return int_type_narrow(this, old->isa_int());\n@@ -1754,1 +1661,2 @@\n-const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeInt::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1756,1 +1664,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -1758,0 +1666,2 @@\n+  }\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -1761,1 +1671,2 @@\n-    ft = TypeInt::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeInt(TypeIntPrototype<jint, juint>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n+                        this->_widen, false))->hashcons();\n@@ -1768,3 +1679,3 @@\n-bool TypeInt::eq( const Type *t ) const {\n-  const TypeInt *r = t->is_int(); \/\/ Handy access\n-  return r->_lo == _lo && r->_hi == _hi && r->_widen == _widen;\n+bool TypeInt::eq(const Type* t) const {\n+  const TypeInt* r = t->is_int();\n+  return int_type_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -1776,1 +1687,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Int;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Int;\n@@ -1785,43 +1697,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeInt\n-#ifndef PRODUCT\n-static const char* intname(char* buf, size_t buf_size, jint n) {\n-  if (n == min_jint)\n-    return \"min\";\n-  else if (n < min_jint + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" INT32_FORMAT, n - min_jint);\n-  else if (n == max_jint)\n-    return \"max\";\n-  else if (n > max_jint - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" INT32_FORMAT, max_jint - n);\n-  else\n-    os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[40], buf2[40];\n-  if (_lo == min_jint && _hi == max_jint)\n-    st->print(\"int\");\n-  else if (is_con())\n-    st->print(\"int:%s\", intname(buf, sizeof(buf), get_con()));\n-  else if (_lo == BOOL->_lo && _hi == BOOL->_hi)\n-    st->print(\"bool\");\n-  else if (_lo == BYTE->_lo && _hi == BYTE->_hi)\n-    st->print(\"byte\");\n-  else if (_lo == CHAR->_lo && _hi == CHAR->_hi)\n-    st->print(\"char\");\n-  else if (_lo == SHORT->_lo && _hi == SHORT->_hi)\n-    st->print(\"short\");\n-  else if (_hi == max_jint)\n-    st->print(\"int:>=%s\", intname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jint)\n-    st->print(\"int:<=%s\", intname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"int:%s..%s\", intname(buf, sizeof(buf), _lo), intname(buf2, sizeof(buf2), _hi));\n-\n-  if (_widen != 0 && this != TypeInt::INT)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -1832,1 +1701,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -1836,1 +1705,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -1841,10 +1710,12 @@\n-const TypeLong *TypeLong::MAX;\n-const TypeLong *TypeLong::MIN;\n-const TypeLong *TypeLong::MINUS_1;\/\/ -1\n-const TypeLong *TypeLong::ZERO; \/\/ 0\n-const TypeLong *TypeLong::ONE;  \/\/ 1\n-const TypeLong *TypeLong::POS;  \/\/ >=0\n-const TypeLong *TypeLong::LONG; \/\/ 64-bit integers\n-const TypeLong *TypeLong::INT;  \/\/ 32-bit subrange\n-const TypeLong *TypeLong::UINT; \/\/ 32-bit unsigned subrange\n-const TypeLong *TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+const TypeLong* TypeLong::MAX;\n+const TypeLong* TypeLong::MIN;\n+const TypeLong* TypeLong::MINUS_1;\/\/ -1\n+const TypeLong* TypeLong::ZERO; \/\/ 0\n+const TypeLong* TypeLong::ONE;  \/\/ 1\n+const TypeLong* TypeLong::NON_ZERO;\n+const TypeLong* TypeLong::POS;  \/\/ >=0\n+const TypeLong* TypeLong::NEG;\n+const TypeLong* TypeLong::LONG; \/\/ 64-bit integers\n+const TypeLong* TypeLong::INT;  \/\/ 32-bit subrange\n+const TypeLong* TypeLong::UINT; \/\/ 32-bit unsigned subrange\n+const TypeLong* TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -1852,2 +1723,4 @@\n-\/\/------------------------------TypeLong---------------------------------------\n-TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long, w), _lo(lo), _hi(hi) {\n+TypeLong::TypeLong(const TypeIntPrototype<jlong, julong>& t, int w, bool dual)\n+  : TypeInteger(Long, t.normalize_widen(w), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -1856,14 +1729,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeLong *TypeLong::make( jlong lo ) {\n-  return (TypeLong*)(new TypeLong(lo,lo,WidenMin))->hashcons();\n-}\n-\n-static int normalize_long_widen( jlong lo, jlong hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants.\n-  if (lo <= hi) {\n-    if (((julong)hi - lo) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)hi - lo) >= max_julong) w = Type::WidenMax; \/\/ TypeLong::LONG\n-  } else {\n-    if (((julong)lo - hi) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)lo - hi) >= max_julong) w = Type::WidenMin; \/\/ dual TypeLong::LONG\n+const Type* TypeLong::try_make(const TypeIntPrototype<jlong, julong>& t, int w, bool dual) {\n+  auto new_t = t.canonicalize_constraints();\n+  if (!new_t._present) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -1871,1 +1734,1 @@\n-  return w;\n+  return (new TypeLong(new_t._data, w, dual))->hashcons()->is_long();\n@@ -1874,3 +1737,4 @@\n-const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {\n-  w = normalize_long_widen(lo, hi, w);\n-  return (TypeLong*)(new TypeLong(lo,hi,w))->hashcons();\n+const TypeLong* TypeLong::make(jlong lo) {\n+  julong ulo = lo;\n+  return (new TypeLong(TypeIntPrototype<jlong, julong>{{lo, lo}, {ulo, ulo}, {~ulo, ulo}},\n+                       WidenMin, false))->hashcons()->is_long();\n@@ -1879,42 +1743,3 @@\n-\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeLong::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeLong\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Long:                    \/\/ Long vs Long?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeLong *r = t->is_long(); \/\/ Turn into a TypeLong\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const TypeLong* TypeLong::make(jlong lo, jlong hi, int w) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return try_make(TypeIntPrototype<jlong, julong>{{lo, hi}, {0, max_julong}, {0, 0}}, w)->is_long();\n@@ -1923,53 +1748,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeLong::xdual() const {\n-  int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeLong(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeLong::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Long ) return this;\n-  const TypeLong *ot = old->is_long();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      jlong max = max_jlong;\n-      jlong min = min_jlong;\n-      if (limit->isa_long()) {\n-        max = limit->is_long()->_hi;\n-        min = limit->is_long()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((julong)_lo - min) >= ((julong)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 32\/63 bits:\n-          if (max >= max_juint && _hi < max_juint)\n-            return make(_lo, max_juint, WidenMax);\n-          else\n-            return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeLong::LONG;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n+const Type* TypeLong::try_make(const TypeIntPrototype<jlong, julong>& t, int w) {\n+  return try_make(t, w, false);\n+}\n@@ -1977,4 +1752,4 @@\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+bool TypeLong::contains(jlong i) const {\n+  julong u = i;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi && _bits.is_satisfied_by(u);\n+}\n@@ -1982,3 +1757,2 @@\n-  \/\/  fatal(\"Long value range is not subset\");\n-  \/\/ return this;\n-  return TypeLong::LONG;\n+bool TypeLong::contains(const TypeLong* t) const {\n+  return int_type_subset(this, t);\n@@ -1987,9 +1761,3 @@\n-\/\/------------------------------narrow----------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeLong::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeLong* ot = old->isa_long();\n-  if (ot == nullptr)  return this;\n-  jlong olo = ot->_lo;\n-  jlong ohi = ot->_hi;\n+bool TypeLong::properly_contains(const TypeLong* t) const {\n+  return int_type_subset(this, t) && !int_type_equal(this, t);\n+}\n@@ -1997,2 +1765,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type *TypeLong::xmeet(const Type* t) const {\n+  return int_type_xmeet(this, t, TypeLong::try_make, _is_dual);\n+}\n@@ -2000,2 +1769,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jlong && ohi == max_jlong)  return this;\n+const Type* TypeLong::xdual() const {\n+  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                      _widen, !_is_dual);\n+}\n@@ -2003,2 +1774,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeLong::widen(const Type* old, const Type* limit) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  return int_type_widen(this, old->isa_long(), limit->isa_long());\n+}\n@@ -2006,8 +1779,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  julong nrange = (julong)_hi - _lo;\n-  julong orange = (julong)ohi - olo;\n-  if (nrange < max_julong - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeLong::narrow(const Type* old) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -2016,1 +1785,1 @@\n-  return this;\n+  return int_type_narrow(this, old->isa_long());\n@@ -2020,1 +1789,2 @@\n-const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeLong::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -2022,1 +1792,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -2024,0 +1794,2 @@\n+  }\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -2027,1 +1799,2 @@\n-    ft = TypeLong::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeLong(TypeIntPrototype<jlong, julong>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n+                         this->_widen, false))->hashcons();\n@@ -2034,3 +1807,3 @@\n-bool TypeLong::eq( const Type *t ) const {\n-  const TypeLong *r = t->is_long(); \/\/ Handy access\n-  return r->_lo == _lo &&  r->_hi == _hi  && r->_widen == _widen;\n+bool TypeLong::eq(const Type* t) const {\n+  const TypeLong* r = t->is_long();\n+  return int_type_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -2042,1 +1815,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Long;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Long;\n@@ -2051,55 +1825,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeLong\n-#ifndef PRODUCT\n-static const char* longnamenear(jlong x, const char* xname, char* buf, size_t buf_size, jlong n) {\n-  if (n > x) {\n-    if (n >= x + 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s+\" JLONG_FORMAT, xname, n - x);\n-  } else if (n < x) {\n-    if (n <= x - 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s-\" JLONG_FORMAT, xname, x - n);\n-  } else {\n-    return xname;\n-  }\n-  return buf;\n-}\n-\n-static const char* longname(char* buf, size_t buf_size, jlong n) {\n-  const char* str;\n-  if (n == min_jlong)\n-    return \"min\";\n-  else if (n < min_jlong + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" JLONG_FORMAT, n - min_jlong);\n-  else if (n == max_jlong)\n-    return \"max\";\n-  else if (n > max_jlong - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" JLONG_FORMAT, max_jlong - n);\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else\n-    os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeLong::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[80], buf2[80];\n-  if (_lo == min_jlong && _hi == max_jlong)\n-    st->print(\"long\");\n-  else if (is_con())\n-    st->print(\"long:%s\", longname(buf, sizeof(buf), get_con()));\n-  else if (_hi == max_jlong)\n-    st->print(\"long:>=%s\", longname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jlong)\n-    st->print(\"long:<=%s\", longname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"long:%s..%s\", longname(buf, sizeof(buf), _lo), longname(buf2,sizeof(buf2),  _hi));\n-\n-  if (_widen != 0 && this != TypeLong::LONG)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -2110,1 +1829,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -2114,1 +1833,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -2117,0 +1836,19 @@\n+\/\/------------------------------dump2------------------------------------------\n+#ifndef PRODUCT\n+void TypeInt::dump2(Dict& d, uint depth, outputStream* st) const {\n+  int_type_dump(this, st, false);\n+}\n+\n+void TypeInt::dump_verbose() const {\n+  int_type_dump(this, tty, true);\n+}\n+\n+void TypeLong::dump2(Dict& d, uint depth, outputStream* st) const {\n+  int_type_dump(this, st, false);\n+}\n+\n+void TypeLong::dump_verbose() const {\n+  int_type_dump(this, tty, true);\n+}\n+#endif\n+\n@@ -2368,1 +2106,6 @@\n-    const TypeAry *a = t->is_ary();\n+    const TypeAry* a = t->is_ary();\n+    const Type* size = _size->xmeet(a->_size);\n+    const TypeInt* isize = size->isa_int();\n+    if (isize == nullptr) {\n+      return size;\n+    }\n@@ -2370,2 +2113,1 @@\n-                         _size->xmeet(a->_size)->is_int(),\n-                         _stable && a->_stable);\n+                         isize, _stable && a->_stable);\n@@ -4799,1 +4541,1 @@\n-  if (lo > hi)\n+  if (lo > hi) {\n@@ -4801,1 +4543,2 @@\n-  if (!chg)\n+  }\n+  if (!chg) {\n@@ -4803,0 +4546,1 @@\n+  }\n@@ -4964,1 +4708,5 @@\n-    const TypeAry *tary = _ary->meet_speculative(tap->_ary)->is_ary();\n+    const Type* tm = _ary->meet_speculative(tap->_ary);\n+    const TypeAry* tary = tm->isa_ary();\n+    if (tary == nullptr) {\n+      return tm;\n+    }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":226,"deletions":478,"binary":false,"changes":704,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n@@ -75,0 +77,3 @@\n+template <class T, class U>\n+class TypeIntPrototype;\n+\n@@ -554,1 +559,6 @@\n-  TypeInteger(TYPES t, int w) : Type(t), _widen(w) {}\n+  TypeInteger(TYPES t, int w, bool dual) : Type(t), _is_dual(dual), _widen(w) {}\n+\n+  \/\/ Denote that a set is a dual set.\n+  \/\/ Dual sets are only used to compute the join of 2 sets, and not used\n+  \/\/ outside.\n+  const bool _is_dual;\n@@ -579,1 +589,2 @@\n-  TypeInt( jint lo, jint hi, int w );\n+  TypeInt(const TypeIntPrototype<jint, juint>& t, int w, bool dual);\n+  static const Type* try_make(const TypeIntPrototype<jint, juint>& t, int w, bool dual);\n@@ -581,1 +592,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -585,1 +596,1 @@\n-  virtual bool eq( const Type *t ) const;\n+  virtual bool eq(const Type* t) const;\n@@ -589,3 +600,8 @@\n-  const jint _lo, _hi;          \/\/ Lower bound, upper bound\n-\n-  static const TypeInt *make(jint lo);\n+  \/\/ A value is in the set represented by this TypeInt if it satisfies all\n+  \/\/ the below constraints, see contains(jint)\n+  const jint _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const juint _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const KnownBits<juint> _bits;\n+\n+  static const TypeInt* try_cast(const Type* t) { return t->isa_int(); }\n+  static const TypeInt* make(jint lo);\n@@ -593,1 +609,2 @@\n-  static const TypeInt *make(jint lo, jint hi, int w);\n+  static const TypeInt* make(jint lo, jint hi, int w);\n+  static const Type* try_make(const TypeIntPrototype<jint, juint>& t, int w);\n@@ -596,1 +613,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -598,1 +615,7 @@\n-  jint get_con() const { assert(is_con(), \"\" );  return _lo; }\n+  jint get_con() const { assert(is_con(), \"\");  return _lo; }\n+  \/\/ Check if a jint\/TypeInt is a subset of this TypeInt (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jint i) const;\n+  bool contains(const TypeInt* t) const;\n+  \/\/ Excluding the cases where this and t are the same\n+  bool properly_contains(const TypeInt* t) const;\n@@ -600,1 +623,1 @@\n-  virtual bool        is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n@@ -602,4 +625,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -612,23 +635,25 @@\n-  static const TypeInt *MAX;\n-  static const TypeInt *MIN;\n-  static const TypeInt *MINUS_1;\n-  static const TypeInt *ZERO;\n-  static const TypeInt *ONE;\n-  static const TypeInt *BOOL;\n-  static const TypeInt *CC;\n-  static const TypeInt *CC_LT;  \/\/ [-1]  == MINUS_1\n-  static const TypeInt *CC_GT;  \/\/ [1]   == ONE\n-  static const TypeInt *CC_EQ;  \/\/ [0]   == ZERO\n-  static const TypeInt *CC_LE;  \/\/ [-1,0]\n-  static const TypeInt *CC_GE;  \/\/ [0,1] == BOOL (!)\n-  static const TypeInt *BYTE;\n-  static const TypeInt *UBYTE;\n-  static const TypeInt *CHAR;\n-  static const TypeInt *SHORT;\n-  static const TypeInt *POS;\n-  static const TypeInt *POS1;\n-  static const TypeInt *INT;\n-  static const TypeInt *SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-  static const TypeInt *TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-  static const TypeInt *as_self(const Type *t) { return t->is_int(); }\n+  static const TypeInt* MAX;\n+  static const TypeInt* MIN;\n+  static const TypeInt* MINUS_1;\n+  static const TypeInt* ZERO;\n+  static const TypeInt* ONE;\n+  static const TypeInt* BOOL;\n+  static const TypeInt* CC;\n+  static const TypeInt* CC_LT;  \/\/ [-1]  == MINUS_1\n+  static const TypeInt* CC_GT;  \/\/ [1]   == ONE\n+  static const TypeInt* CC_EQ;  \/\/ [0]   == ZERO\n+  static const TypeInt* CC_NE;  \/\/ [-1, 1]\n+  static const TypeInt* CC_LE;  \/\/ [-1,0]\n+  static const TypeInt* CC_GE;  \/\/ [0,1] == BOOL (!)\n+  static const TypeInt* BYTE;\n+  static const TypeInt* UBYTE;\n+  static const TypeInt* CHAR;\n+  static const TypeInt* SHORT;\n+  static const TypeInt* NON_ZERO;\n+  static const TypeInt* POS;\n+  static const TypeInt* POS1;\n+  static const TypeInt* INT;\n+  static const TypeInt* SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+  static const TypeInt* TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n+\n+  static const TypeInt* as_self(const Type* t) { return t->is_int(); }\n@@ -636,1 +661,2 @@\n-  virtual void dump2( Dict &d, uint depth, outputStream *st ) const;\n+  virtual void dump2(Dict& d, uint depth, outputStream* st) const;\n+  void dump_verbose() const;\n@@ -645,1 +671,2 @@\n-  TypeLong( jlong lo, jlong hi, int w );\n+  TypeLong(const TypeIntPrototype<jlong, julong>& t, int w, bool dual);\n+  static const Type* try_make(const TypeIntPrototype<jlong, julong>& t, int w, bool dual);\n@@ -648,1 +675,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -656,3 +683,8 @@\n-  const jlong _lo, _hi;         \/\/ Lower bound, upper bound\n-\n-  static const TypeLong *make(jlong lo);\n+  \/\/ A value is in the set represented by this TypeLong if it satisfies all\n+  \/\/ the below constraints, see contains(jlong)\n+  const jlong _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const julong _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const KnownBits<julong> _bits;\n+\n+  static const TypeLong* try_cast(const Type* t) { return t->isa_long(); }\n+  static const TypeLong* make(jlong lo);\n@@ -660,1 +692,2 @@\n-  static const TypeLong *make(jlong lo, jlong hi, int w);\n+  static const TypeLong* make(jlong lo, jlong hi, int w);\n+  static const Type* try_make(const TypeIntPrototype<jlong, julong>& t, int w);\n@@ -663,1 +696,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -666,0 +699,6 @@\n+  \/\/ Check if a jlong\/TypeLong is a subset of this TypeLong (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jlong i) const;\n+  bool contains(const TypeLong* t) const;\n+  \/\/ Excluding the cases where this and t are the same\n+  bool properly_contains(const TypeLong* t) const;\n@@ -675,4 +714,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -680,10 +719,12 @@\n-  static const TypeLong *MAX;\n-  static const TypeLong *MIN;\n-  static const TypeLong *MINUS_1;\n-  static const TypeLong *ZERO;\n-  static const TypeLong *ONE;\n-  static const TypeLong *POS;\n-  static const TypeLong *LONG;\n-  static const TypeLong *INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n-  static const TypeLong *UINT;   \/\/ 32-bit unsigned [0..max_juint]\n-  static const TypeLong *TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+  static const TypeLong* MAX;\n+  static const TypeLong* MIN;\n+  static const TypeLong* MINUS_1;\n+  static const TypeLong* ZERO;\n+  static const TypeLong* ONE;\n+  static const TypeLong* NON_ZERO;\n+  static const TypeLong* POS;\n+  static const TypeLong* NEG;\n+  static const TypeLong* LONG;\n+  static const TypeLong* INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n+  static const TypeLong* UINT;   \/\/ 32-bit unsigned [0..max_juint]\n+  static const TypeLong* TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -692,1 +733,1 @@\n-  static const TypeLong *as_self(const Type *t) { return t->is_long(); }\n+  static const TypeLong* as_self(const Type* t) { return t->is_long(); }\n@@ -695,1 +736,2 @@\n-  virtual void dump2( Dict &d, uint, outputStream *st  ) const;\/\/ Specialized per-Type dumping\n+  virtual void dump2(Dict& d, uint, outputStream* st) const;\/\/ Specialized per-Type dumping\n+  void dump_verbose() const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":104,"deletions":62,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n+#include \"opto\/type.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+#include <limits>\n+\n+#ifdef ASSERT\n+\n+template <class U>\n+static U uniform_random();\n+\n+template <>\n+juint uniform_random<juint>() {\n+  return os::random();\n+}\n+\n+template <>\n+julong uniform_random<julong>() {\n+  return (julong(os::random()) << 32) | julong(juint(os::random()));\n+}\n+\n+static void test_canonicalize_constraints_trivial() {\n+  ASSERT_FALSE(TypeInt::NON_ZERO->contains(0));\n+  ASSERT_TRUE(TypeInt::NON_ZERO->contains(1));\n+  ASSERT_TRUE(TypeInt::NON_ZERO->contains(-1));\n+  ASSERT_TRUE(TypeInt::CC_NE->contains(-1));\n+  ASSERT_TRUE(TypeInt::CC_NE->contains(1));\n+  ASSERT_FALSE(TypeInt::CC_NE->contains(0));\n+  ASSERT_FALSE(TypeInt::CC_NE->contains(-2));\n+  ASSERT_FALSE(TypeInt::CC_NE->contains(2));\n+  ASSERT_FALSE(TypeLong::NON_ZERO->contains(0L));\n+  ASSERT_TRUE(TypeLong::NON_ZERO->contains(1L));\n+  ASSERT_TRUE(TypeLong::NON_ZERO->contains(-1L));\n+}\n+\n+template <class S, class U>\n+static void test_canonicalize_constraints_simple() {\n+  constexpr int parameters = 10;\n+  for (int i = 0; i < parameters; i++) {\n+    S a = uniform_random<U>();\n+    S b = uniform_random<U>();\n+\n+    {\n+      S lo = MIN2<S>(a, b);\n+      S hi = MAX2<S>(a, b);\n+      TypeIntPrototype<S, U> t{{lo, hi}, {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()},\n+                               {0, 0}};\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(lo, new_t._data._srange._lo);\n+      ASSERT_EQ(hi, new_t._data._srange._hi);\n+      if (U(lo) <= U(hi)) {\n+        ASSERT_EQ(U(lo), new_t._data._urange._lo);\n+        ASSERT_EQ(U(hi), new_t._data._urange._hi);\n+      } else {\n+        ASSERT_EQ(std::numeric_limits<U>::min(), new_t._data._urange._lo);\n+        ASSERT_EQ(std::numeric_limits<U>::max(), new_t._data._urange._hi);\n+      }\n+    }\n+\n+    {\n+      U ulo = MIN2<U>(a, b);\n+      U uhi = MAX2<U>(a, b);\n+      TypeIntPrototype<S, U> t{{std::numeric_limits<S>::min(), std::numeric_limits<S>::max()},\n+                               {ulo, uhi}, {0, 0}};\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(ulo, new_t._data._urange._lo);\n+      ASSERT_EQ(uhi, new_t._data._urange._hi);\n+      if (S(ulo) <= S(uhi)) {\n+        ASSERT_EQ(S(ulo), new_t._data._srange._lo);\n+        ASSERT_EQ(S(uhi), new_t._data._srange._hi);\n+      } else {\n+        ASSERT_EQ(std::numeric_limits<S>::min(), new_t._data._srange._lo);\n+        ASSERT_EQ(std::numeric_limits<S>::max(), new_t._data._srange._hi);\n+      }\n+    }\n+\n+    {\n+      U intersection = a & b;\n+      U zeros = a ^ intersection;\n+      U ones = b ^ intersection;\n+      TypeIntPrototype<S, U> t{{std::numeric_limits<S>::min(), std::numeric_limits<S>::max()},\n+                               {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()}, {zeros, ones}};\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(zeros, new_t._data._bits._zeros);\n+      ASSERT_EQ(ones, new_t._data._bits._ones);\n+      ASSERT_EQ(ones, new_t._data._urange._lo);\n+      ASSERT_EQ(~zeros, new_t._data._urange._hi);\n+    }\n+  }\n+}\n+\n+template <class S, class U>\n+static void test_canonicalize_constraints_random() {\n+  constexpr int samples = 1000;\n+  constexpr int parameters = 1000;\n+  for (int i = 0; i < parameters; i++) {\n+    S s1 = uniform_random<U>();\n+    S s2 = uniform_random<U>();\n+    S lo = MIN2(s1, s2);\n+    S hi = MAX2(s1, s2);\n+    U u1 = uniform_random<U>();\n+    U u2 = uniform_random<U>();\n+    U ulo = MIN2(u1, u2);\n+    U uhi = MAX2(u1, u2);\n+    U b1 = uniform_random<U>();\n+    U b2 = uniform_random<U>();\n+    U intersection = b1 & b2;\n+    U zeros = b1 ^ intersection;\n+    U ones = b2 ^ intersection;\n+    TypeIntPrototype<S, U> t{{lo, hi}, {ulo, uhi}, {zeros, ones}};\n+    auto new_t = t.canonicalize_constraints();\n+    if (new_t._present) {\n+      new_t._data.verify_constraints();\n+    }\n+    for (int j = 0; j < samples; j++) {\n+      S v = uniform_random<U>();\n+      if (!new_t._present) {\n+        ASSERT_FALSE(t.contains(v));\n+      } else {\n+        ASSERT_EQ(t.contains(v), new_t._data.contains(v));\n+      }\n+    }\n+  }\n+}\n+\n+TEST_VM(opto, canonicalize_constraints) {\n+  test_canonicalize_constraints_trivial();\n+  test_canonicalize_constraints_simple<jint, juint>();\n+  test_canonicalize_constraints_simple<jlong, julong>();\n+  test_canonicalize_constraints_random<jint, juint>();\n+  test_canonicalize_constraints_random<jlong, julong>();\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}