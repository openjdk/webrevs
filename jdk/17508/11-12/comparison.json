{"files":[{"patch":"@@ -85,0 +85,16 @@\n+  \/\/ The principal here is that, consider the first bit in result that is\n+  \/\/ different from the corresponding bit in lo, since result is larger than lo\n+  \/\/ the bit must be unset in lo and set in result. As result should be the\n+  \/\/ smallest value, the position of this bit should be as low as possible\n+  \/\/ E.g:      1 2 3 4 5 6\n+  \/\/      lo = 1 0 0 1 1 0\n+  \/\/       x = 1 0 1 0 1 0\n+  \/\/       y = 0 1 1 1 1 1\n+  \/\/ x would be larger than lo since the first different bit is the 3rd one,\n+  \/\/ while y is smaller than lo because the first different bit is the 1st bit.\n+  \/\/ Next consider:\n+  \/\/      x1 = 1 0 1 0 1 0\n+  \/\/      x2 = 1 0 0 1 1 1\n+  \/\/ Both x1 and x2 are larger than lo, but x1 > x2 since its first different\n+  \/\/ bit from lo is the 3rd one, while with x2 it is the 7th one. As a result,\n+  \/\/ if both x1 and x2 satisfy bits, x2 would be closer to our true result.\n@@ -86,3 +102,19 @@\n-    \/\/ This means that the first bit that does not satisfy the bit\n-    \/\/ requirement is a 0 that should be a 1, try to set that bit\n-    \/\/ E.g: lo = 10010010, zeros = 00100100, ones = 01001000\n+    \/\/ This means that the first bit that does not satisfy the bit requirement\n+    \/\/ is a 0 that should be a 1, this may be the first different bit we want\n+    \/\/ to find.\n+    \/\/ E.g:      1 2 3 4 5 6 7 8\n+    \/\/      lo = 1 0 0 1 0 0 1 0\n+    \/\/   zeros = 0 0 1 0 0 1 0 0\n+    \/\/    ones = 0 1 0 0 1 0 1 0\n+    \/\/   1-vio = 0 1 0 0 1 0 0 0\n+    \/\/   0-vio = 0 0 0 0 0 0 0 0\n+    \/\/ Since the result must have the 2nd bit set, it must be at least:\n+    \/\/           1 1 0 0 0 0 0 0\n+    \/\/ This value must satisfy zeros, because all bits before the 2nd bit have\n+    \/\/ already satisfied zeros, and all bits after the 2nd bit are all 0 now.\n+    \/\/ Continue the logic with each set bit in ones, we will set each bit in\n+    \/\/ our new lo (11000000 -> 11001000 -> 11001010). The final value is our\n+    \/\/ result.\n+    \/\/ Implementationwise, from 11000000 we can just | with ones to obtain the\n+    \/\/ final result.\n+\n@@ -91,1 +123,2 @@\n-    juint first_violation = W - 1 - count_leading_zeros(one_violation);\n+    juint first_violation = W - 1 - count_leading_zeros(one_violation); \/\/ 6\n+    \/\/           0 1 0 0 0 0 0 0\n@@ -95,2 +128,1 @@\n-    \/\/ 11000000, notice that all bits after the second digit are zeroed,\n-    \/\/ which automatically satisfies bits._zeros\n+    \/\/           1 1 0 0 0 0 0 0\n@@ -98,2 +130,2 @@\n-    \/\/ Simply satisfy bits._ones\n-    return lo | bits._ones; \/\/ 11001000\n+    \/\/           1 1 0 0 1 0 1 0\n+    return lo | bits._ones;\n@@ -103,14 +135,26 @@\n-  \/\/ some bits before it (higher bits)\n-  \/\/ Suppose lo = 11000110, zeros = 00001010, ones = 10000001\n-  \/\/ The smallest value with the 7-th bit unset would be 11001000 but then the\n-  \/\/ 5-th bit does not match, the smallest value with both bits unset would be\n-  \/\/ 11010000\n-  \/\/ We can obtain this number directly by finding the last place before\n-  \/\/ the first mismatch such that it is 0 in lo and not required to be unset\n-  juint first_violation = W - 1 - count_leading_zeros(zero_violation);\n-  \/\/ This mask out all bits after the first violation\n-  U find_mask = std::numeric_limits<U>::max() << first_violation; \/\/ 11111100\n-  \/\/ The smallest value which satisfies bits._zeros will need to set a bit in\n-  \/\/ lo that is previously unset (because the value needs to be larger than lo)\n-  \/\/ and that bit will need to be unset in bits._zeros as well\n-  U either = lo | bits._zeros; \/\/ 11001110\n+  \/\/ some bits before it (higher bits).\n+  \/\/ Consider the first bit that is change, it must not be set already, and it\n+  \/\/ must not be set in zeros. As a result, it must be the last bit before the\n+  \/\/ first bit violation that is unset in both zeros and lo.\n+  \/\/ E.g:      1 2 3 4 5 6 7 8\n+  \/\/      lo = 1 0 0 0 1 1 1 0\n+  \/\/   zeros = 0 0 0 1 0 1 0 0\n+  \/\/    ones = 1 0 0 0 0 0 1 1\n+  \/\/   1-vio = 0 0 0 0 0 0 0 1\n+  \/\/   0-vio = 0 0 0 0 0 1 0 0\n+  \/\/ The first violation is the 6th bit, which should be 0. The 5th cannot be\n+  \/\/ the first different bit we are looking for, because it is already 1, the\n+  \/\/ 4th bit also cannot be, because it must be 0. As a result, the first\n+  \/\/ different bit between the result and lo must be the 3rd bit. As a result,\n+  \/\/ the result must not be smaller than:\n+  \/\/           1 0 1 0 0 0 0 0\n+  \/\/ This one satisfies zeros so we can use the logic in the previous case to\n+  \/\/ obtain our final result, which is:\n+  \/\/           1 0 1 0 0 0 1 1\n+\n+  juint first_violation = W - count_leading_zeros(zero_violation);\n+  \/\/ This mask out all bits from the first violation\n+  \/\/           1 1 1 1 1 0 0 0\n+  U find_mask = std::numeric_limits<U>::max() << first_violation;\n+  \/\/           1 0 0 1 1 1 1 0\n+  U either = lo | bits._zeros;\n@@ -119,1 +163,2 @@\n-  U tmp = ~either & find_mask; \/\/ 00110000\n+  \/\/           0 1 1 0 0 0 0 0\n+  U tmp = ~either & find_mask;\n@@ -121,1 +166,2 @@\n-  U alignment = tmp & (-tmp); \/\/ 00010000\n+  \/\/           0 0 1 0 0 0 0 0\n+  U alignment = tmp & (-tmp);\n@@ -124,1 +170,2 @@\n-  lo = (lo & -alignment) + alignment; \/\/ 11010000\n+  \/\/           1 0 1 0 0 0 0 0\n+  lo = (lo & -alignment) + alignment;\n@@ -126,1 +173,2 @@\n-  return lo | bits._ones; \/\/ 11010001\n+  \/\/           1 0 1 0 0 0 1 1\n+  return lo | bits._ones;\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":74,"deletions":26,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-static void test_normalize_constraints_simple() {\n+static void test_canonicalize_constraints_simple() {\n@@ -110,1 +110,1 @@\n-static void test_normalize_constraints_random() {\n+static void test_canonicalize_constraints_random() {\n@@ -143,5 +143,5 @@\n-TEST_VM(opto, normalize_constraints) {\n-  test_normalize_constraints_simple<jint, juint>();\n-  test_normalize_constraints_simple<jlong, julong>();\n-  test_normalize_constraints_random<jint, juint>();\n-  test_normalize_constraints_random<jlong, julong>();\n+TEST_VM(opto, canonicalize_constraints) {\n+  test_canonicalize_constraints_simple<jint, juint>();\n+  test_canonicalize_constraints_simple<jlong, julong>();\n+  test_canonicalize_constraints_random<jint, juint>();\n+  test_canonicalize_constraints_random<jlong, julong>();\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}