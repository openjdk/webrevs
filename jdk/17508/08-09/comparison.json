{"files":[{"patch":"@@ -35,0 +35,2 @@\n+  \/\/ Denote whether there is a change in _data compared to the previous\n+  \/\/ iteration\n@@ -36,1 +38,1 @@\n-  bool _present;\n+  bool _present; \/\/ whether the constraints are contradictory\n@@ -38,0 +40,4 @@\n+\n+  static AdjustResult<T> make_empty() {\n+    return {true, false, {}};\n+  }\n@@ -40,0 +46,6 @@\n+\/\/ In the canonical form, [lo, hi] intersects with [ulo, uhi] can result in 2\n+\/\/ cases:\n+\/\/ - [lo, hi] is the same as [ulo, uhi], lo and hi are both >= 0 or both < 0\n+\/\/ - [lo, hi] is not the same as [ulo, uhi], which results in the intersections\n+\/\/ being [lo, uhi] and [ulo, hi], lo and uhi are < 0 while ulo and hi are >= 0\n+\/\/ This class deals with each interval with both bounds being >= 0 or < 0\n@@ -42,0 +54,1 @@\n+  static_assert(std::is_unsigned<U>::value, \"bit info should be unsigned\");\n@@ -43,1 +56,1 @@\n-  bool _present;\n+  bool _present; \/\/ whether this is an empty set\n@@ -46,0 +59,4 @@\n+\n+  static SimpleCanonicalResult<U> make_empty() {\n+    return {false, {}, {}};\n+  }\n@@ -48,3 +65,77 @@\n-\/\/ Try to tighten the bound constraints from the known bit information\n-\/\/ E.g: if lo = 0 but the lowest bit is always 1 then we can tighten\n-\/\/ lo = 1\n+\/\/ Find the minimum value that is not less than lo and satisfies bits\n+template <class U>\n+static U adjust_lo(U lo, const KnownBits<U>& bits) {\n+  constexpr size_t W = sizeof(U) * 8;\n+  \/\/ Violation of lo with respects to bits\n+  \/\/ E.g: lo    = 1100\n+  \/\/      zeros = 0100\n+  \/\/      ones  = 1001\n+  \/\/ zero_violation = 0100, i.e the second bit should be zero, but it is 1 in\n+  \/\/ lo. Similarly, one_violation = 0001, i.e the forth bit should be one, but\n+  \/\/ it is 0 in lo. These make lo not satisfy the bit constraints, which\n+  \/\/ results in us having to find the smallest value that satisfies bits\n+  U zero_violation = lo & bits._zeros;\n+  U one_violation = ~lo & bits._ones;\n+  if (zero_violation == one_violation) {\n+    \/\/ This means lo does not violate bits, it is the result\n+    assert(zero_violation == 0, \"\");\n+    return lo;\n+  }\n+\n+  if (zero_violation < one_violation) {\n+    \/\/ This means that the first bit that does not satisfy the bit\n+    \/\/ requirement is a 0 that should be a 1, try to set that bit\n+    \/\/ E.g: lo = 10010010, zeros = 00100100, ones = 01001000\n+    \/\/ first_violation is the position of the violation counting from the\n+    \/\/ lowest bit up (0-based)\n+    juint first_violation = W - 1 - count_leading_zeros(one_violation);\n+    U alignment = U(1) << first_violation;\n+    \/\/ This is the first value which have the violated bit set, which means\n+    \/\/ that the result should not be smaller than this\n+    \/\/ 11000000, notice that all bits after the second digit are zeroed,\n+    \/\/ which automatically satisfies bits._zeros\n+    lo = (lo & -alignment) + alignment;\n+    \/\/ Simply satisfy bits._ones\n+    return lo | bits._ones; \/\/ 11001000\n+  }\n+\n+  \/\/ This is more difficult because trying to unset a bit requires us to flip\n+  \/\/ some bits before it (higher bits)\n+  \/\/ Suppose lo = 11000110, zeros = 00001010, ones = 10000001\n+  \/\/ The smallest value with the 7-th bit unset would be 11001000 but then the\n+  \/\/ 5-th bit does not match, the smallest value with both bits unset would be\n+  \/\/ 11010000\n+  \/\/ We can obtain this number directly by finding the last place before\n+  \/\/ the first mismatch such that it is 0 in lo and not required to be unset\n+  juint first_violation = W - 1 - count_leading_zeros(zero_violation);\n+  \/\/ This mask out all bits after the first violation\n+  U find_mask = std::numeric_limits<U>::max() << first_violation; \/\/ 11111100\n+  \/\/ The smallest value which satisfies bits._zeros will need to set a bit in\n+  \/\/ lo that is previously unset (because the value needs to be larger than lo)\n+  \/\/ and that bit will need to be unset in bits._zeros as well\n+  U either = lo | bits._zeros; \/\/ 11001110\n+  \/\/ The bit we want to set is the last bit unset in either that stands before\n+  \/\/ the first violation, which is the last set bit of tmp\n+  U tmp = ~either & find_mask; \/\/ 00110000\n+  \/\/ Isolate the last bit\n+  U alignment = tmp & (-tmp); \/\/ 00010000\n+  \/\/ Set the bit and unset all the bit after, this is the smallest value that\n+  \/\/ satisfies bits._zeros\n+  lo = (lo & -alignment) + alignment; \/\/ 11010000\n+  \/\/ Satisfy bits._ones\n+  return lo | bits._ones; \/\/ 11010001\n+}\n+\n+\/\/ Try to tighten the bound constraints from the known bit information. I.e, we\n+\/\/ find the smallest value not smaller than lo, as well as the largest value\n+\/\/ not larger than hi both of which satisfy bits\n+\/\/ E.g: lo = 0010, hi = 1001\n+\/\/ zeros = 0011\n+\/\/ ones  = 0000\n+\/\/ -> 4-aligned\n+\/\/\n+\/\/         0    1    2    3    4    5    6    7    8    9    10\n+\/\/         0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010\n+\/\/ bits:   ok   .    .    .    ok   .    .    .    ok   .    .\n+\/\/ bounds:           lo                                 hi\n+\/\/ adjust:           --------> lo                  hi <---\n@@ -54,44 +145,0 @@\n-  \/\/ Find the minimum value that is not less than lo and satisfies bits\n-  auto adjust_lo = [](U lo, const KnownBits<U>& bits) {\n-    constexpr size_t W = sizeof(U) * 8;\n-    \/\/ Violation of lo with respects to bits\n-    U zero_violation = lo & bits._zeros;\n-    U one_violation = ~lo & bits._ones;\n-    if (zero_violation == one_violation) {\n-      \/\/ This means lo does not violate bits, it is the result\n-      assert(zero_violation == 0, \"\");\n-      return lo;\n-    }\n-\n-    if (zero_violation < one_violation) {\n-      \/\/ This means that the first bit that does not satisfy the bit\n-      \/\/ requirement is a 0 that should be a 1\n-      \/\/ Try to set that bit, the smallest value will have all the following\n-      \/\/ bits being zeros\n-      \/\/ E.g: lo = 10010010, zeros = 00100100, ones = 01001000\n-      juint first_violation = W - 1 - count_leading_zeros(one_violation);\n-      U alignment = U(1) << first_violation;\n-      \/\/ 11000000, notice that all bits after the second digit are zeroed,\n-      \/\/ which automatically satisfies the unset bit requirement\n-      lo = (lo & -alignment) + alignment;\n-      \/\/ Simply satisfy the set bit requirement\n-      return lo | bits._ones; \/\/ 11001000\n-    }\n-\n-    \/\/ This is more difficult because trying to unset a bit requires us to flip\n-    \/\/ some bits before it (higher bits)\n-    \/\/ Suppose lo = 11000110, zeros = 00001010, ones = 10010001\n-    \/\/ Since the 2-nd bit must be 0, we need to align up the lower bound.\n-    \/\/ This results in lo = 11001000, but then the 4-th bit does not match,\n-    \/\/ align up again gives us 11010000\n-    \/\/ We can align up directly to 11010000 by finding the last place before\n-    \/\/ the first mismatch such that it is 0 in lo and not required to be unset\n-    juint first_violation = W - 1 - count_leading_zeros(zero_violation);\n-    U find_mask = std::numeric_limits<U>::max() << first_violation; \/\/ 11111100\n-    U either = lo | bits._zeros; \/\/ 11001110\n-    U tmp = ~either & find_mask; \/\/ 00110000\n-    U alignment = tmp & (-tmp); \/\/ 00010000\n-    lo = (lo & -alignment) + alignment; \/\/ 11010000\n-    return lo | bits._ones; \/\/ 11010001\n-  };\n-\n@@ -102,3 +149,12 @@\n-    return {true, false, {}};\n-  }\n-  \/\/ Adjust hi by adjusting its bitwise negation\n+    return AdjustResult<RangeInt<U>>::make_empty();\n+  }\n+\n+  \/\/ We need to find the largest value not larger than hi that satisfies bits\n+  \/\/ One possible method is to do similar to adjust_lo, just with the other\n+  \/\/ direction\n+  \/\/ However, we can observe that if v satisfies {bits._zeros, bits._ones},\n+  \/\/ then ~v would satisfy {bits._ones, bits._zeros}. Combine with the fact\n+  \/\/ that ~ is a strictly decreasing function, if new_hi is the largest value\n+  \/\/ not larger than hi that satisfies {bits._zeros, bits._ones}, then ~new_hi\n+  \/\/ is the smallest value not smaller than ~hi that satisfies\n+  \/\/ {bits._ones, bits._zeros}\n@@ -107,1 +163,1 @@\n-    return {true, false, {}};\n+    return AdjustResult<RangeInt<U>>::make_empty();\n@@ -118,1 +174,4 @@\n-\/\/ E.g: if lo = 0 and hi = 10, then all but the lowest 4 bits must be 0\n+\/\/ E.g: lo = 010011\n+\/\/      hi = 010100,\n+\/\/ then all values in [lo, hi] would be\n+\/\/           010***\n@@ -122,1 +181,2 @@\n-  \/\/ Find the mask to filter the common prefix\n+  \/\/ Find the mask to filter the common prefix, all values between bounds._lo\n+  \/\/ and bounds._hi should share this common prefix in terms of bits\n@@ -124,0 +184,2 @@\n+  \/\/ Find the first mismatch, all bits before it is the same in bounds._lo and\n+  \/\/ bounds._hi\n@@ -126,1 +188,2 @@\n-  \/\/ match_mask & bounds._lo is the common prefix\n+  \/\/ match_mask & bounds._lo is the common prefix, extract zeros and ones from\n+  \/\/ it\n@@ -136,1 +199,3 @@\n-\/\/ This function converges because bit constraints converge fast.\n+\/\/ This function converges because at each iteration, some bits that are\n+\/\/ unknown is made known. As there are at most 64 bits, the number of\n+\/\/ iterations should not be larger than 64\n@@ -139,1 +204,1 @@\n-normalize_constraints_simple(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n+canonicalize_constraints_simple(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n@@ -142,1 +207,1 @@\n-    return {false, {}, {}};\n+    return SimpleCanonicalResult<U>::make_empty();\n@@ -145,0 +210,3 @@\n+  \/\/ Since bits are derived from bounds in the previous iteration and vice\n+  \/\/ versa, if one does not show progress, the other will also not show\n+  \/\/ progress, so we terminate early\n@@ -167,0 +235,1 @@\n+  \/\/ Trivial contradictions\n@@ -170,1 +239,1 @@\n-    return {false, {}};\n+    return CanonicalizedTypeIntPrototype<S, U>::make_empty();\n@@ -173,0 +242,2 @@\n+  \/\/ Trivially canonicalize the bounds so that srange._lo and urange._hi are\n+  \/\/ both < 0 or >= 0. The same for srange._hi and urange._ulo\n@@ -186,1 +257,1 @@\n-      return {false, {}};\n+      return CanonicalizedTypeIntPrototype<S, U>::make_empty();\n@@ -189,1 +260,1 @@\n-    auto type = normalize_constraints_simple(urange, _bits);\n+    auto type = canonicalize_constraints_simple(urange, _bits);\n@@ -198,2 +269,2 @@\n-  auto neg_type = normalize_constraints_simple({U(srange._lo), urange._hi}, _bits);\n-  auto pos_type = normalize_constraints_simple({urange._lo, U(srange._hi)}, _bits);\n+  auto neg_type = canonicalize_constraints_simple({U(srange._lo), urange._hi}, _bits);\n+  auto pos_type = canonicalize_constraints_simple({urange._lo, U(srange._hi)}, _bits);\n@@ -202,1 +273,1 @@\n-    return {false, {}};\n+    return CanonicalizedTypeIntPrototype<S, U>::make_empty();\n@@ -235,2 +306,2 @@\n-  return v >= _srange._lo && v <= _srange._hi && U(v) >= _urange._lo && U(v) <= _urange._hi &&\n-         (v & _bits._zeros) == 0 && (~v & _bits._ones) == 0;\n+  U u = v;\n+  return v >= _srange._lo && v <= _srange._hi && u >= _urange._lo && u <= _urange._hi && _bits.is_satisfied_by(u);\n@@ -283,1 +354,1 @@\n-                                         {i1->_zeros & i2->_zeros, i1->_ones & i2->_ones}},\n+                                         {i1->_bits._zeros & i2->_bits._zeros, i1->_bits._ones & i2->_bits._ones}},\n@@ -289,1 +360,1 @@\n-                                       {i1->_zeros | i2->_zeros, i1->_ones | i2->_ones}},\n+                                       {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n@@ -369,1 +440,1 @@\n-    TypeIntPrototype<S, U> prototype{{nt->_lo, nt->_hi}, {nt->_ulo, nt->_uhi}, {nt->_zeros, nt->_ones}};\n+    TypeIntPrototype<S, U> prototype{{nt->_lo, nt->_hi}, {nt->_ulo, nt->_uhi}, nt->_bits};\n@@ -379,2 +450,2 @@\n-  U zeros = nt->_zeros;\n-  U ones = nt->_ones;\n+  U zeros = nt->_bits._zeros;\n+  U ones = nt->_bits._ones;\n@@ -386,2 +457,2 @@\n-    zeros |= lt->_zeros;\n-    ones |= lt->_ones;\n+    zeros |= lt->_bits._zeros;\n+    ones |= lt->_bits._ones;\n@@ -423,1 +494,1 @@\n-  if (ot->_zeros != nt->_zeros || ot->_ones != nt->_ones) {\n+  if (ot->_bits._zeros != nt->_bits._zeros || ot->_bits._ones != nt->_bits._ones) {\n@@ -582,1 +653,1 @@\n-      st->print(\"int:%s..%s ^ %s..%s, bits:%s\",\n+      st->print(\"int:%s..%s, %s..%s, %s\",\n@@ -585,1 +656,1 @@\n-                bitname(buf5, sizeof(buf5), t->_zeros, t->_ones));\n+                bitname(buf5, sizeof(buf5), t->_bits._zeros, t->_bits._ones));\n@@ -587,3 +658,18 @@\n-      st->print(\"int:%s..%s ^ %s..%s\",\n-                intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi),\n-                uintname(buf3, sizeof(buf3), t->_ulo), uintname(buf4, sizeof(buf4), t->_uhi));\n+      if (t->_lo >= 0) {\n+        if (t->_hi == max_jint) {\n+          st->print(\"int:>=%s\", intname(buf1, sizeof(buf1), t->_lo));\n+        } else {\n+          st->print(\"int:%s..%s\", intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else if (t->_hi < 0) {\n+        if (t->_lo == min_jint) {\n+          st->print(\"int:<=%s\", intname(buf1, sizeof(buf1), t->_hi));\n+        } else {\n+          st->print(\"int:%s..%s\", intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else {\n+        st->print(\"int:%s..%s, %s..%s\",\n+                  intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi),\n+                  uintname(buf3, sizeof(buf3), t->_ulo), uintname(buf4, sizeof(buf4), t->_uhi));\n+      }\n+\n@@ -609,1 +695,1 @@\n-                bitname(buf5, sizeof(buf5), t->_zeros, t->_ones));\n+                bitname(buf5, sizeof(buf5), t->_bits._zeros, t->_bits._ones));\n@@ -611,3 +697,17 @@\n-      st->print(\"long:%s..%s ^ %s..%s\",\n-                longname(buf1, sizeof(buf1), t->_lo), longname(buf2,sizeof(buf2), t-> _hi),\n-                ulongname(buf3, sizeof(buf3), t->_ulo), ulongname(buf4, sizeof(buf4), t->_uhi));\n+      if (t->_lo >= 0) {\n+        if (t->_hi == max_jint) {\n+          st->print(\"long:>=%s\", longname(buf1, sizeof(buf1), t->_lo));\n+        } else {\n+          st->print(\"long:%s..%s\", longname(buf1, sizeof(buf1), t->_lo), longname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else if (t->_hi < 0) {\n+        if (t->_lo == min_jint) {\n+          st->print(\"long:<=%s\", longname(buf1, sizeof(buf1), t->_hi));\n+        } else {\n+          st->print(\"long:%s..%s\", longname(buf1, sizeof(buf1), t->_lo), longname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else {\n+        st->print(\"long:%s..%s ^ %s..%s\",\n+                  longname(buf1, sizeof(buf1), t->_lo), longname(buf2,sizeof(buf2), t-> _hi),\n+                  ulongname(buf3, sizeof(buf3), t->_ulo), ulongname(buf4, sizeof(buf4), t->_uhi));\n+      }\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":184,"deletions":84,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include <type_traits>\n+\n@@ -39,0 +41,12 @@\n+\/**\n+ * Bits that are known to be 0 or 1. A value v satisfies this constraint iff\n+ * (v & zeros) == 0 && (~v & ones) == 0. I.e, all bits that is set in zeros\n+ * must be unset in v, and all bits that is set in ones must be set in v.\n+ *\n+ * E.g:\n+ * zeros: 00110100\n+ * ones:  10000010\n+ * Then:  10001010 would satisfy the bit constraints\n+ * while: 10011000 would not since the bit at the 4th position violates\n+ * zeros and the bit at the 7th position violates ones\n+ *\/\n@@ -41,1 +55,1 @@\n-  static_assert(std::is_unsigned<U>::value, \"\");\n+  static_assert(std::is_unsigned<U>::value, \"bit info should be unsigned\");\n@@ -46,0 +60,4 @@\n+\n+  bool is_satisfied_by(U v) const {\n+    return (v & _zeros) == 0 && (~v & _ones) == 0;\n+  }\n@@ -56,0 +74,4 @@\n+\n+  static CanonicalizedTypeIntPrototype<S, U> make_empty() {\n+    return {false, {}};\n+  }\n@@ -94,1 +116,1 @@\n-         t1->_zeros == t2->_zeros && t1->_ones == t2->_ones;\n+         t1->_bits._zeros == t2->_bits._zeros && t1->_bits._ones == t2->_bits._ones;\n@@ -100,1 +122,1 @@\n-         (super->_zeros &~ sub->_zeros) == 0 && (super->_ones &~ sub->_ones) == 0;\n+         (super->_bits._zeros &~ sub->_bits._zeros) == 0 && (super->_bits._ones &~ sub->_bits._ones) == 0;\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1596,3 +1596,2 @@\n-  : TypeInteger(Int, t.normalize_widen(w), dual),\n-    _lo(t._srange._lo), _hi(t._srange._hi), _ulo(t._urange._lo), _uhi(t._urange._hi),\n-    _zeros(t._bits._zeros), _ones(t._bits._ones) {\n+  : TypeInteger(Int, t.normalize_widen(w), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n@@ -1626,2 +1625,1 @@\n-  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi &&\n-         (u & _zeros) == 0 && (~u & _ones) == 0;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi && _bits.is_satisfied_by(u);\n@@ -1643,1 +1641,1 @@\n-  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, {_zeros, _ones}},\n+  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n@@ -1672,2 +1670,1 @@\n-    return (new TypeInt(TypeIntPrototype<jint, juint>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi},\n-                                                      {ft->_zeros, ft->_ones}},\n+    return (new TypeInt(TypeIntPrototype<jint, juint>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n@@ -1690,1 +1687,1 @@\n-         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_is_dual + (uint)Type::Int;\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Int;\n@@ -1726,3 +1723,2 @@\n-  : TypeInteger(Long, t.normalize_widen(w), dual),\n-    _lo(t._srange._lo), _hi(t._srange._hi), _ulo(t._urange._lo), _uhi(t._urange._hi),\n-    _zeros(t._bits._zeros), _ones(t._bits._ones) {\n+  : TypeInteger(Long, t.normalize_widen(w), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n@@ -1756,2 +1752,1 @@\n-  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi &&\n-         (u & _zeros) == 0 && (~u & _ones) == 0;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi && _bits.is_satisfied_by(u);\n@@ -1773,1 +1768,1 @@\n-  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, {_zeros, _ones}},\n+  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n@@ -1802,2 +1797,1 @@\n-    return (new TypeLong(TypeIntPrototype<jlong, julong>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi},\n-                                                         {ft->_zeros, ft->_ones}},\n+    return (new TypeLong(TypeIntPrototype<jlong, julong>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n@@ -1820,1 +1814,1 @@\n-         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_is_dual + (uint)Type::Long;\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Long;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -603,1 +604,1 @@\n-  const juint _zeros, _ones; \/\/ Bits that are known to be 0 or 1\n+  const KnownBits<juint> _bits;\n@@ -686,1 +687,1 @@\n-  const julong _zeros, _ones; \/\/ Bits that are known to be 0 or 1\n+  const KnownBits<julong> _bits;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}