{"files":[{"patch":"@@ -32,0 +32,1 @@\n+\/\/ This represents the result of an iterative calculation\n@@ -35,4 +36,2 @@\n-  \/\/ Denote whether there is a change in _data compared to the previous\n-  \/\/ iteration\n-  bool _progress;\n-  bool _present; \/\/ whether the constraints are contradictory\n+  bool _progress; \/\/ whether there is progress compared to the last iteration\n+  bool _present;  \/\/ whether the calculation arrives at contradiction\n@@ -280,1 +279,1 @@\n-CanonicalizedTypeIntPrototype<S, U>\n+typename TypeIntPrototype<S, U>::CanonicalizedTypeIntPrototype\n@@ -288,1 +287,1 @@\n-    return CanonicalizedTypeIntPrototype<S, U>::make_empty();\n+    return CanonicalizedTypeIntPrototype::make_empty();\n@@ -312,1 +311,1 @@\n-      return CanonicalizedTypeIntPrototype<S, U>::make_empty();\n+      return CanonicalizedTypeIntPrototype::make_empty();\n@@ -328,1 +327,1 @@\n-    return CanonicalizedTypeIntPrototype<S, U>::make_empty();\n+    return CanonicalizedTypeIntPrototype::make_empty();\n@@ -346,1 +345,1 @@\n-  if (cardinality_from_bounds(_srange, _urange) <= SMALLINT) {\n+  if (TypeIntHelper::cardinality_from_bounds(_srange, _urange) <= SMALLINT) {\n@@ -398,1 +397,1 @@\n-const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<S, U>&, int, bool), bool dual) {\n+const Type* TypeIntHelper::int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<S, U>&, int, bool), bool dual) {\n@@ -447,4 +446,4 @@\n-template const Type* int_type_xmeet(const TypeInt* i1, const Type* t2,\n-                                    const Type* (*make)(const TypeIntPrototype<jint, juint>&, int, bool), bool dual);\n-template const Type* int_type_xmeet(const TypeLong* i1, const Type* t2,\n-                                    const Type* (*make)(const TypeIntPrototype<jlong, julong>&, int, bool), bool dual);\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeInt* i1, const Type* t2,\n+                                                   const Type* (*make)(const TypeIntPrototype<jint, juint>&, int, bool), bool dual);\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeLong* i1, const Type* t2,\n+                                                   const Type* (*make)(const TypeIntPrototype<jlong, julong>&, int, bool), bool dual);\n@@ -456,1 +455,1 @@\n-const Type* int_type_widen(const CT* new_type, const CT* old_type, const CT* limit_type) {\n+const Type* TypeIntHelper::int_type_widen(const CT* new_type, const CT* old_type, const CT* limit_type) {\n@@ -516,2 +515,2 @@\n-template const Type* int_type_widen(const TypeInt* new_type, const TypeInt* old_type, const TypeInt* limit_type);\n-template const Type* int_type_widen(const TypeLong* new_type, const TypeLong* old_type, const TypeLong* limit_type);\n+template const Type* TypeIntHelper::int_type_widen(const TypeInt* new_type, const TypeInt* old_type, const TypeInt* limit_type);\n+template const Type* TypeIntHelper::int_type_widen(const TypeLong* new_type, const TypeLong* old_type, const TypeLong* limit_type);\n@@ -523,1 +522,1 @@\n-const Type* int_type_narrow(const CT* new_type, const CT* old_type) {\n+const Type* TypeIntHelper::int_type_narrow(const CT* new_type, const CT* old_type) {\n@@ -558,2 +557,2 @@\n-template const Type* int_type_narrow(const TypeInt* new_type, const TypeInt* old_type);\n-template const Type* int_type_narrow(const TypeLong* new_type, const TypeLong* old_type);\n+template const Type* TypeIntHelper::int_type_narrow(const TypeInt* new_type, const TypeInt* old_type);\n+template const Type* TypeIntHelper::int_type_narrow(const TypeLong* new_type, const TypeLong* old_type);\n@@ -581,1 +580,1 @@\n-const char* intname(char* buf, size_t buf_size, jint n) {\n+const char* TypeIntHelper::intname(char* buf, size_t buf_size, jint n) {\n@@ -596,1 +595,1 @@\n-const char* uintname(char* buf, size_t buf_size, juint n) {\n+const char* TypeIntHelper::uintname(char* buf, size_t buf_size, juint n) {\n@@ -611,1 +610,1 @@\n-const char* longname(char* buf, size_t buf_size, jlong n) {\n+const char* TypeIntHelper::longname(char* buf, size_t buf_size, jlong n) {\n@@ -641,1 +640,1 @@\n-const char* ulongname(char* buf, size_t buf_size, julong n) {\n+const char* TypeIntHelper::ulongname(char* buf, size_t buf_size, julong n) {\n@@ -667,1 +666,1 @@\n-const char* bitname(char* buf, size_t buf_size, U zeros, U ones) {\n+const char* TypeIntHelper::bitname(char* buf, size_t buf_size, U zeros, U ones) {\n@@ -687,2 +686,2 @@\n-template const char* bitname(char* buf, size_t buf_size, juint zeros, juint ones);\n-template const char* bitname(char* buf, size_t buf_size, julong zeros, julong ones);\n+template const char* TypeIntHelper::bitname(char* buf, size_t buf_size, juint zeros, juint ones);\n+template const char* TypeIntHelper::bitname(char* buf, size_t buf_size, julong zeros, julong ones);\n@@ -690,1 +689,1 @@\n-void int_type_dump(const TypeInt* t, outputStream* st, bool verbose) {\n+void TypeIntHelper::int_type_dump(const TypeInt* t, outputStream* st, bool verbose) {\n@@ -737,1 +736,1 @@\n-void int_type_dump(const TypeLong* t, outputStream* st, bool verbose) {\n+void TypeIntHelper::int_type_dump(const TypeLong* t, outputStream* st, bool verbose) {\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":28,"deletions":29,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+\/\/ A simple range in the signed or unsigned domain\n@@ -45,2 +46,11 @@\n- * (v & zeros) == 0 && (v & ones) == ones. I.e, all bits that is set in zeros\n- * must be unset in v, and all bits that is set in ones must be set in v.\n+ * (v & zeros) == 0 && (v & ones) == ones. I.e, any bit that is 1 in zeros must\n+ * be 0 in v, and any bit that is 1 in ones must be 1 in v.\n+ *\n+ * I.e, for each bit position from 0 to sizeof(U) - 1, the corresponding bits\n+ * of zeros, ones and the allowed bit in v must follow:\n+ *\n+ * zeros    ones    allowed bits\n+ * 0        0       0 or 1\n+ * 1        0       0\n+ * 0        1       1\n+ * 1        1       none (impossible state)\n@@ -71,14 +81,3 @@\n-template <class S, class U>\n-class TypeIntPrototype;\n-\n-template <class S, class U>\n-class CanonicalizedTypeIntPrototype {\n-public:\n-  bool _present;\n-  TypeIntPrototype<S, U> _data;\n-\n-  static CanonicalizedTypeIntPrototype<S, U> make_empty() {\n-    return {false, {}};\n-  }\n-};\n-\n+\/\/ All the information needed to construct a TypeInt\/TypeLong, the constraints\n+\/\/ here may be arbitrary and need to be canonicalized to construct a\n+\/\/ TypeInt\/TypeLong\n@@ -96,1 +95,23 @@\n-  CanonicalizedTypeIntPrototype<S, U> canonicalize_constraints() const;\n+private:\n+  friend class TypeInt;\n+  friend class TypeLong;\n+\n+  template <class T1, class T2>\n+  friend void test_canonicalize_constraints_simple();\n+\n+  template <class T1, class T2>\n+  friend void test_canonicalize_constraints_random();\n+\n+  \/\/ A canonicalized version of a TypeIntPrototype, if the prototype represents\n+  \/\/ an empty type, _present is false, otherwise, _data is canonical\n+  class CanonicalizedTypeIntPrototype {\n+  public:\n+    bool _present; \/\/ whether this is an empty set\n+    TypeIntPrototype<S, U> _data;\n+\n+    static CanonicalizedTypeIntPrototype make_empty() {\n+      return {false, {}};\n+    }\n+  };\n+\n+  CanonicalizedTypeIntPrototype canonicalize_constraints() const;\n@@ -104,6 +125,17 @@\n-\/\/ The result is tuned down by one since we do not have empty type\n-\/\/ and this is not required to be accurate\n-template <class S, class U>\n-U cardinality_from_bounds(const RangeInt<S>& srange, const RangeInt<U>& urange) {\n-  if (U(srange._lo) == urange._lo) {\n-    return urange._hi - urange._lo;\n+\/\/ Various helper functions for TypeInt\/TypeLong operations\n+class TypeIntHelper {\n+public:\n+  \/\/ Calculate the cardinality of a TypeInt\/TypeLong ignoring the bits\n+  \/\/ constraints, the result is tuned down by 1 to ensure the bottom type is\n+  \/\/ correctly calculated\n+  template <class S, class U>\n+  static U cardinality_from_bounds(const RangeInt<S>& srange, const RangeInt<U>& urange) {\n+    static_assert(std::is_signed<S>::value, \"\");\n+    static_assert(std::is_unsigned<U>::value, \"\");\n+    static_assert(sizeof(S) == sizeof(U), \"\");\n+\n+    if (U(srange._lo) == urange._lo) {\n+      return urange._hi - urange._lo;\n+    }\n+\n+    return (urange._hi - U(srange._lo)) + (U(srange._hi) - urange._lo) + 1;\n@@ -112,2 +144,2 @@\n-  return (urange._hi - U(srange._lo)) + (U(srange._hi) - urange._lo) + 1;\n-}\n+  template <class CT, class S, class U>\n+  static const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<S, U>&, int, bool), bool dual);\n@@ -115,8 +147,5 @@\n-template <class CT, class S, class U>\n-const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<S, U>&, int, bool), bool dual);\n-\n-template <class CT>\n-bool int_type_equal(const CT* t1, const CT* t2) {\n-  return t1->_lo == t2->_lo && t1->_hi == t2->_hi && t1->_ulo == t2->_ulo && t1->_uhi == t2->_uhi &&\n-         t1->_bits._zeros == t2->_bits._zeros && t1->_bits._ones == t2->_bits._ones;\n-}\n+  template <class CT>\n+  static bool int_type_equal(const CT* t1, const CT* t2) {\n+    return t1->_lo == t2->_lo && t1->_hi == t2->_hi && t1->_ulo == t2->_ulo && t1->_uhi == t2->_uhi &&\n+          t1->_bits._zeros == t2->_bits._zeros && t1->_bits._ones == t2->_bits._ones;\n+  }\n@@ -124,5 +153,5 @@\n-template <class CT>\n-bool int_type_subset(const CT* super, const CT* sub) {\n-  return super->_lo <= sub->_lo && super->_hi >= sub->_hi && super->_ulo <= sub->_ulo && super->_uhi >= sub->_uhi &&\n-         (super->_bits._zeros &~ sub->_bits._zeros) == 0 && (super->_bits._ones &~ sub->_bits._ones) == 0;\n-}\n+  template <class CT>\n+  static bool int_type_subset(const CT* super, const CT* sub) {\n+    return super->_lo <= sub->_lo && super->_hi >= sub->_hi && super->_ulo <= sub->_ulo && super->_uhi >= sub->_uhi &&\n+          (super->_bits._zeros &~ sub->_bits._zeros) == 0 && (super->_bits._ones &~ sub->_bits._ones) == 0;\n+  }\n@@ -130,2 +159,2 @@\n-template <class CT>\n-const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt);\n+  template <class CT>\n+  static const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt);\n@@ -133,2 +162,2 @@\n-template <class CT>\n-const Type* int_type_narrow(const CT* nt, const CT* ot);\n+  template <class CT>\n+  static const Type* int_type_narrow(const CT* nt, const CT* ot);\n@@ -137,4 +166,4 @@\n-const char* intname(char* buf, size_t buf_size, jint n);\n-const char* uintname(char* buf, size_t buf_size, juint n);\n-const char* longname(char* buf, size_t buf_size, jlong n);\n-const char* ulongname(char* buf, size_t buf_size, julong n);\n+  static const char* intname(char* buf, size_t buf_size, jint n);\n+  static const char* uintname(char* buf, size_t buf_size, juint n);\n+  static const char* longname(char* buf, size_t buf_size, jlong n);\n+  static const char* ulongname(char* buf, size_t buf_size, julong n);\n@@ -142,2 +171,2 @@\n-template <class U>\n-const char* bitname(char* buf, size_t buf_size, U zeros, U ones);\n+  template <class U>\n+  static const char* bitname(char* buf, size_t buf_size, U zeros, U ones);\n@@ -145,2 +174,2 @@\n-void int_type_dump(const TypeInt* t, outputStream* st, bool verbose);\n-void int_type_dump(const TypeLong* t, outputStream* st, bool verbose);\n+  static void int_type_dump(const TypeInt* t, outputStream* st, bool verbose);\n+  static void int_type_dump(const TypeLong* t, outputStream* st, bool verbose);\n@@ -148,0 +177,1 @@\n+};\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":80,"deletions":50,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -1630,1 +1630,1 @@\n-  return int_type_subset(this, t);\n+  return TypeIntHelper::int_type_subset(this, t);\n@@ -1634,1 +1634,1 @@\n-  return int_type_xmeet(this, t, TypeInt::try_make, _is_dual);\n+  return TypeIntHelper::int_type_xmeet(this, t, TypeInt::try_make, _is_dual);\n@@ -1644,1 +1644,1 @@\n-  return int_type_widen(this, old->isa_int(), limit->isa_int());\n+  return TypeIntHelper::int_type_widen(this, old->isa_int(), limit->isa_int());\n@@ -1653,1 +1653,1 @@\n-  return int_type_narrow(this, old->isa_int());\n+  return TypeIntHelper::int_type_narrow(this, old->isa_int());\n@@ -1677,1 +1677,1 @@\n-  return int_type_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n+  return TypeIntHelper::int_type_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -1754,1 +1754,1 @@\n-  return int_type_subset(this, t);\n+  return TypeIntHelper::int_type_subset(this, t);\n@@ -1758,1 +1758,1 @@\n-  return int_type_xmeet(this, t, TypeLong::try_make, _is_dual);\n+  return TypeIntHelper::int_type_xmeet(this, t, TypeLong::try_make, _is_dual);\n@@ -1768,1 +1768,1 @@\n-  return int_type_widen(this, old->isa_long(), limit->isa_long());\n+  return TypeIntHelper::int_type_widen(this, old->isa_long(), limit->isa_long());\n@@ -1777,1 +1777,1 @@\n-  return int_type_narrow(this, old->isa_long());\n+  return TypeIntHelper::int_type_narrow(this, old->isa_long());\n@@ -1801,1 +1801,1 @@\n-  return int_type_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n+  return TypeIntHelper::int_type_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -1831,1 +1831,1 @@\n-  int_type_dump(this, st, false);\n+  TypeIntHelper::int_type_dump(this, st, false);\n@@ -1835,1 +1835,1 @@\n-  int_type_dump(this, tty, true);\n+  TypeIntHelper::int_type_dump(this, tty, true);\n@@ -1839,1 +1839,1 @@\n-  int_type_dump(this, st, false);\n+  TypeIntHelper::int_type_dump(this, st, false);\n@@ -1843,1 +1843,1 @@\n-  int_type_dump(this, tty, true);\n+  TypeIntHelper::int_type_dump(this, tty, true);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"}]}