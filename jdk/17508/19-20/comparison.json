{"files":[{"patch":"@@ -36,3 +36,3 @@\n-  bool _progress; \/\/ whether there is progress compared to the last iteration\n-  bool _present;  \/\/ whether the calculation arrives at contradiction\n-  T _data;\n+  bool _progress;             \/\/ whether there is progress compared to the last iteration\n+  bool _is_result_consistent; \/\/ whether the calculation arrives at contradiction\n+  T _result;\n@@ -65,1 +65,6 @@\n-\/\/ Find the minimum value that is not less than lo and satisfies bits\n+\/\/ Find the minimum value that is not less than lo and satisfies bits.\n+\/\/ Here, we view a number in binary as a bit string. As a result,  the first\n+\/\/ bit refers to the highest bit (the MSB), the last bit refers to the lowest\n+\/\/ bit (the LSB), a bit comes before (being higher than) another if it is more\n+\/\/ significant, and a bit comes after (being lower than) another if it is less\n+\/\/ significant.\n@@ -74,3 +79,3 @@\n-  \/\/ lo. Similarly, one_violation = 0001, i.e the LSB should be one, but it is\n-  \/\/ 0 in lo. These make lo not satisfy the bit constraints, which results in\n-  \/\/ us having to find the smallest value that satisfies bits\n+  \/\/ lo. Similarly, one_violation = 0001, i.e the last bit should be one, but\n+  \/\/ it is 0 in lo. These make lo not satisfy the bit constraints, which\n+  \/\/ results in us having to find the smallest value that satisfies bits\n@@ -88,1 +93,1 @@\n-  \/\/ value, this bit should be the rightmost one possible.\n+  \/\/ value, this bit should be the last one possible.\n@@ -101,0 +106,6 @@\n+\n+  \/\/ The algorithm depends on whether the first violation violates zeros or\n+  \/\/ ones, if it violates zeros, we have the bit being 1 in zero_violation and\n+  \/\/ 0 in one_violation. Since all higher bits are 0 in zero_violation and\n+  \/\/ one_violation, we have zero_violation > one_violation. Similarly, if the\n+  \/\/ first violation violates ones, we have zero_violation < one_violation.\n@@ -104,1 +115,6 @@\n-    \/\/ to find.\n+    \/\/ to find. The smallest value higher than lo with this bit being 1 would\n+    \/\/ have all lower bits being 0. This value satisfies zeros, because all\n+    \/\/ bits before the first violation have already satisfied zeros, and all\n+    \/\/ bits after the first violation are 0. To satisfy 1, simply | this value\n+    \/\/ with ones\n+    \/\/\n@@ -115,5 +131,1 @@\n-    \/\/ Continue the logic with each 1 bit in ones, we will set each bit in our\n-    \/\/ new lo (11000000 -> 11001000 -> 11001010). The final value is our\n-    \/\/ result.\n-    \/\/ Implementationwise, from 11000000 we can just | with ones to obtain the\n-    \/\/ final result.\n+    \/\/ Just | this value with ones to obtain the final result.\n@@ -132,22 +144,26 @@\n-  }\n-\n-  \/\/ This is more difficult because trying to unset a bit requires us to flip\n-  \/\/ some bits before it (higher bits).\n-  \/\/ Consider the first bit that is changed, it must not be 1 already, and it\n-  \/\/ must not be 1 in zeros. As a result, it must be the last bit before the\n-  \/\/ first bit violation that is 0 in both zeros and lo.\n-  \/\/ E.g:      1 2 3 4 5 6 7 8\n-  \/\/      lo = 1 0 0 0 1 1 1 0\n-  \/\/   zeros = 0 0 0 1 0 1 0 0\n-  \/\/    ones = 1 0 0 0 0 0 1 1\n-  \/\/   1-vio = 0 0 0 0 0 0 0 1\n-  \/\/   0-vio = 0 0 0 0 0 1 0 0\n-  \/\/ The first violation is the 6th bit, which should be 0. The 5th cannot be\n-  \/\/ the first different bit we are looking for, because it is already 1, the\n-  \/\/ 4th bit also cannot be, because it must be 0. As a result, the first\n-  \/\/ different bit between the result and lo must be the 3rd bit. As a result,\n-  \/\/ the result must not be smaller than:\n-  \/\/           1 0 1 0 0 0 0 0\n-  \/\/ This one satisfies zeros so we can use the logic in the previous case to\n-  \/\/ obtain our final result, which is:\n-  \/\/           1 0 1 0 0 0 1 1\n+  } else {\n+    \/\/ This is more difficult because trying to unset a bit requires us to flip\n+    \/\/ some bits before it.\n+    \/\/ Consider the first bit that is changed, it must not be 1 already, and it\n+    \/\/ must not be 1 in zeros. As a result, it must be the last bit before the\n+    \/\/ first bit violation that is 0 in both zeros and lo. As a result, the\n+    \/\/ smallest number not smaller than lo that satisfies zeros would have this\n+    \/\/ bit being 1 and all lower bits being 0. Similar to the case with\n+    \/\/ zero_violation < one_violation, | this value with ones gives us the\n+    \/\/ final result.\n+    \/\/\n+    \/\/ E.g:      1 2 3 4 5 6 7 8\n+    \/\/      lo = 1 0 0 0 1 1 1 0\n+    \/\/   zeros = 0 0 0 1 0 1 0 0\n+    \/\/    ones = 1 0 0 0 0 0 1 1\n+    \/\/   1-vio = 0 0 0 0 0 0 0 1\n+    \/\/   0-vio = 0 0 0 0 0 1 0 0\n+    \/\/ The first violation is the 6th bit, which should be 0. The 5th cannot be\n+    \/\/ the first different bit we are looking for, because it is already 1, the\n+    \/\/ 4th bit also cannot be, because it must be 0. As a result, the first\n+    \/\/ different bit between the result and lo must be the 3rd bit. As a result,\n+    \/\/ the result must not be smaller than:\n+    \/\/           1 0 1 0 0 0 0 0\n+    \/\/ This one satisfies zeros so we can use the logic in the previous case to\n+    \/\/ obtain our final result, which is:\n+    \/\/           1 0 1 0 0 0 1 1\n@@ -155,20 +171,21 @@\n-  juint first_violation = W - count_leading_zeros(zero_violation);\n-  \/\/ This mask out all bits from the first violation\n-  \/\/           1 1 1 1 1 0 0 0\n-  U find_mask = std::numeric_limits<U>::max() << first_violation;\n-  \/\/           1 0 0 1 1 1 1 0\n-  U either = lo | bits._zeros;\n-  \/\/ The bit we want to set is the last bit unset in either that stands before\n-  \/\/ the first violation, which is the last set bit of tmp\n-  \/\/           0 1 1 0 0 0 0 0\n-  U tmp = ~either & find_mask;\n-  \/\/ Isolate the last bit\n-  \/\/           0 0 1 0 0 0 0 0\n-  U alignment = tmp & (-tmp);\n-  \/\/ Set the bit and unset all the bit after, this is the smallest value that\n-  \/\/ satisfies bits._zeros\n-  \/\/           1 0 1 0 0 0 0 0\n-  lo = (lo & -alignment) + alignment;\n-  \/\/ Satisfy bits._ones\n-  \/\/           1 0 1 0 0 0 1 1\n-  return lo | bits._ones;\n+    juint first_violation = W - count_leading_zeros(zero_violation);\n+    \/\/ This mask out all bits from the first violation\n+    \/\/           1 1 1 1 1 0 0 0\n+    U find_mask = std::numeric_limits<U>::max() << first_violation;\n+    \/\/           1 0 0 1 1 1 1 0\n+    U either = lo | bits._zeros;\n+    \/\/ The bit we want to set is the last bit unset in either that stands before\n+    \/\/ the first violation, which is the last set bit of tmp\n+    \/\/           0 1 1 0 0 0 0 0\n+    U tmp = ~either & find_mask;\n+    \/\/ Isolate the last bit\n+    \/\/           0 0 1 0 0 0 0 0\n+    U alignment = tmp & (-tmp);\n+    \/\/ Set the bit and unset all the bit after, this is the smallest value that\n+    \/\/ satisfies bits._zeros\n+    \/\/           1 0 1 0 0 0 0 0\n+    lo = (lo & -alignment) + alignment;\n+    \/\/ Satisfy bits._ones\n+    \/\/           1 0 1 0 0 0 1 1\n+    return lo | bits._ones;\n+  }\n@@ -254,1 +271,1 @@\n-  if (!nbits._present) {\n+  if (!nbits._is_result_consistent) {\n@@ -262,3 +279,3 @@\n-    nbounds = adjust_bounds_from_bits(nbounds._data, nbits._data);\n-    if (!nbounds._progress || !nbounds._present) {\n-      return {nbounds._present, nbounds._data, nbits._data};\n+    nbounds = adjust_bounds_from_bits(nbounds._result, nbits._result);\n+    if (!nbounds._progress || !nbounds._is_result_consistent) {\n+      return {nbounds._is_result_consistent, nbounds._result, nbits._result};\n@@ -266,3 +283,3 @@\n-    nbits = adjust_bits_from_bounds(nbits._data, nbounds._data);\n-    if (!nbits._progress || !nbits._present) {\n-      return {nbits._present, nbounds._data, nbits._data};\n+    nbits = adjust_bits_from_bounds(nbits._result, nbounds._result);\n+    if (!nbits._progress || !nbits._is_result_consistent) {\n+      return {nbits._is_result_consistent, nbounds._result, nbits._result};\n@@ -377,2 +394,2 @@\n-    assert(neg_bits._present, \"\");\n-    assert(!adjust_bounds_from_bits(neg_range, neg_bits._data)._progress, \"\");\n+    assert(neg_bits._is_result_consistent, \"\");\n+    assert(!adjust_bounds_from_bits(neg_range, neg_bits._result)._progress, \"\");\n@@ -382,2 +399,2 @@\n-    assert(pos_bits._present, \"\");\n-    assert(!adjust_bounds_from_bits(pos_range, pos_bits._data)._progress, \"\");\n+    assert(pos_bits._is_result_consistent, \"\");\n+    assert(!adjust_bounds_from_bits(pos_range, pos_bits._result)._progress, \"\");\n@@ -385,2 +402,2 @@\n-    assert((neg_bits._data._zeros & pos_bits._data._zeros) == _bits._zeros &&\n-           (neg_bits._data._ones & pos_bits._data._ones) == _bits._ones, \"\");\n+    assert((neg_bits._result._zeros & pos_bits._result._zeros) == _bits._zeros &&\n+           (neg_bits._result._ones & pos_bits._result._ones) == _bits._ones, \"\");\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":86,"deletions":69,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -129,2 +129,2 @@\n-  \/\/ constraints, the result is tuned down by 1 to ensure the bottom type is\n-  \/\/ correctly calculated\n+  \/\/ constraints, the return value is the cardinality minus 1 to not overflow\n+  \/\/ with the bottom type\n@@ -138,0 +138,2 @@\n+      \/\/ srange is the same as urange\n+      assert(U(srange._hi) == urange._hi, \"\");\n@@ -141,0 +143,2 @@\n+    \/\/ srange intersects with urange in 2 intervals [srange._lo, urange._hi]\n+    \/\/ and [urange._lo, srange._hi]\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}