{"files":[{"patch":"@@ -430,1 +430,1 @@\n-adjust_bounds_from_bits(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n+adjust_unsigned_bounds_from_bits(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n@@ -491,1 +491,1 @@\n-adjust_bits_from_bounds(const KnownBits<U>& bits, const RangeInt<U>& bounds) {\n+adjust_bits_from_unsigned_bounds(const KnownBits<U>& bits, const RangeInt<U>& bounds) {\n@@ -495,1 +495,1 @@\n-  \/\/ Find the first mismatch, all bits before it is the same in bounds._lo and\n+  \/\/ Find the first mismatch, all bits before it are the same in bounds._lo and\n@@ -501,2 +501,8 @@\n-  U new_zeros = bits._zeros | (match_mask & ~bounds._lo);\n-  U new_ones = bits._ones | (match_mask & bounds._lo);\n+  U common_prefix_zeros = match_mask & ~bounds._lo;\n+  assert(common_prefix_zeros == (match_mask & ~bounds._hi), \"\");\n+  U new_zeros = bits._zeros | common_prefix_zeros;\n+\n+  U common_prefix_ones = match_mask & bounds._lo;\n+  assert(common_prefix_ones == (match_mask & bounds._hi), \"\");\n+  U new_ones = bits._ones | common_prefix_ones;\n+\n@@ -518,1 +524,3 @@\n-  AdjustResult<KnownBits<U>> canonicalized_bits = adjust_bits_from_bounds(bits, bounds);\n+  assert((bounds._lo ^ bounds._hi) < (std::numeric_limits<U>::max() >> 1) + U(1), \"bounds must be a simple interval\");\n+\n+  AdjustResult<KnownBits<U>> canonicalized_bits = adjust_bits_from_unsigned_bounds(bits, bounds);\n@@ -527,1 +535,1 @@\n-    canonicalized_bounds = adjust_bounds_from_bits(canonicalized_bounds._result, canonicalized_bits._result);\n+    canonicalized_bounds = adjust_unsigned_bounds_from_bits(canonicalized_bounds._result, canonicalized_bits._result);\n@@ -531,1 +539,1 @@\n-    canonicalized_bits = adjust_bits_from_bounds(canonicalized_bits._result, canonicalized_bounds._result);\n+    canonicalized_bits = adjust_bits_from_unsigned_bounds(canonicalized_bits._result, canonicalized_bounds._result);\n@@ -555,3 +563,3 @@\n-  \/\/ Trivially canonicalize the bounds so that srange._lo and urange._hi are\n-  \/\/ both < 0 or >= 0. The same for srange._hi and urange._ulo. See TypeInt for\n-  \/\/ detailed explanation.\n+  \/\/ We try to make [srange._lo, S(urange._hi)] and\n+  \/\/ [S(urange._lo), srange._hi] be both simple intervals (as defined in\n+  \/\/ TypeInt at type.hpp)\n@@ -559,1 +567,2 @@\n-    \/\/ This means that S(urange._lo) >= 0 and S(urange._hi) < 0\n+    \/\/ This means that S(urange._lo) >= 0 and S(urange._hi) < 0 because here we\n+    \/\/ know that U(urange._lo) <= U(urange._hi)\n@@ -563,0 +572,4 @@\n+      \/\/ Signed:\n+      \/\/ min_S----uhi---------lo---------0--------ulo==========hi----max_S\n+      \/\/ Unsigned:\n+      \/\/                                 0--------ulo==========hi----max_S min_S-----uhi---------lo---------\n@@ -567,0 +580,4 @@\n+      \/\/ Signed:\n+      \/\/ min_S----lo=========uhi---------0--------hi----------ulo----max_S\n+      \/\/ Unsigned:\n+      \/\/                                 0--------hi----------ulo----max_S min_S----lo=========uhi---------\n@@ -571,2 +588,2 @@\n-  \/\/ Now [srange._lo, jint(urange._hi)] and [jint(urange._lo), srange._hi] are\n-  \/\/ both simple intervals (as defined in TypeInt at type.hpp), we process them\n+  \/\/ Now [srange._lo, S(urange._hi)] and [S(urange._lo), srange._hi] are both\n+  \/\/ simple intervals (as defined in TypeInt at type.hpp), we process them\n@@ -626,1 +643,3 @@\n-  return v >= _srange._lo && v <= _srange._hi && u >= _urange._lo && u <= _urange._hi && _bits.is_satisfied_by(u);\n+  return v >= _srange._lo && v <= _srange._hi &&\n+         u >= _urange._lo && u <= _urange._hi &&\n+         _bits.is_satisfied_by(u);\n@@ -638,1 +657,1 @@\n-    assert(!adjust_bits_from_bounds(_bits, _urange)._progress, \"\");\n+    assert(!adjust_bits_from_unsigned_bounds(_bits, _urange)._progress, \"\");\n@@ -641,1 +660,1 @@\n-    auto neg_bits = adjust_bits_from_bounds(_bits, neg_range);\n+    auto neg_bits = adjust_bits_from_unsigned_bounds(_bits, neg_range);\n@@ -643,1 +662,1 @@\n-    assert(!adjust_bounds_from_bits(neg_range, neg_bits._result)._progress, \"\");\n+    assert(!adjust_unsigned_bounds_from_bits(neg_range, neg_bits._result)._progress, \"\");\n@@ -646,1 +665,1 @@\n-    auto pos_bits = adjust_bits_from_bounds(_bits, pos_range);\n+    auto pos_bits = adjust_bits_from_unsigned_bounds(_bits, pos_range);\n@@ -648,1 +667,1 @@\n-    assert(!adjust_bounds_from_bits(pos_range, pos_bits._result)._progress, \"\");\n+    assert(!adjust_unsigned_bounds_from_bits(pos_range, pos_bits._result)._progress, \"\");\n@@ -663,2 +682,6 @@\n-\/\/ Compute the meet of 2 types, when dual is true, we are actually computing the\n-\/\/ join.\n+\/\/ Compute the meet of 2 types. When dual is true, the subset relation in CT is\n+\/\/ reversed. This means that the result of 2 CTs would be the intersection of\n+\/\/ them if dual is true, and be the union of them if dual is false. The subset\n+\/\/ relation in the Type hierarchy is still the same, however. E.g. the result\n+\/\/ of 1 CT and Type::BOTTOM would always be Type::BOTTOM, and the result of 1\n+\/\/ CT and Type::TOP would always be the CT instance itself.\n@@ -674,1 +697,1 @@\n-    \/\/ meet\n+    \/\/ meet (a.k.a union)\n@@ -680,1 +703,1 @@\n-    \/\/ join\n+    \/\/ join (a.k.a intersection)\n@@ -1016,1 +1039,1 @@\n-      st->print(\"long:%s..%s ^ %s..%s, bits:%s\",\n+      st->print(\"long:%s..%s, %s..%s, bits:%s\",\n@@ -1034,1 +1057,1 @@\n-        st->print(\"long:%s..%s ^ %s..%s\",\n+        st->print(\"long:%s..%s, %s..%s\",\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":49,"deletions":26,"binary":false,"changes":75,"status":"modified"}]}