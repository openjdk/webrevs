{"files":[{"patch":"@@ -702,4 +702,4 @@\n-      return CT::try_make(TypeIntPrototype<S, U>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n-                                                 {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n-                                                 {i1->_bits._zeros & i2->_bits._zeros, i1->_bits._ones & i2->_bits._ones}},\n-                          MAX2(i1->_widen, i2->_widen), false);\n+      return CT::make_or_top(TypeIntPrototype<S, U>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n+                                                    {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n+                                                    {i1->_bits._zeros & i2->_bits._zeros, i1->_bits._ones & i2->_bits._ones}},\n+                             MAX2(i1->_widen, i2->_widen), false);\n@@ -708,4 +708,4 @@\n-    return CT::try_make(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n-                                               {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n-                                               {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n-                        MIN2(i1->_widen, i2->_widen), true);\n+    return CT::make_or_top(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n+                                                  {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n+                                                  {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n+                           MIN2(i1->_widen, i2->_widen), true);\n@@ -790,1 +790,1 @@\n-    return CT::try_make(prototype, new_type->_widen + 1);\n+    return CT::make_or_top(prototype, new_type->_widen + 1);\n@@ -810,1 +810,1 @@\n-  return CT::try_make(prototype, Type::WidenMax);\n+  return CT::make_or_top(prototype, Type::WidenMax);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -498,1 +498,1 @@\n-  TypeInt::CC_NE    = TypeInt::try_make(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n+  TypeInt::CC_NE    = TypeInt::make_or_top(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n@@ -505,1 +505,1 @@\n-  TypeInt::NON_ZERO = TypeInt::try_make(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n+  TypeInt::NON_ZERO = TypeInt::make_or_top(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n@@ -524,1 +524,1 @@\n-  TypeLong::NON_ZERO = TypeLong::try_make(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n+  TypeLong::NON_ZERO = TypeLong::make_or_top(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n@@ -1781,1 +1781,1 @@\n-const Type* TypeInt::try_make(const TypeIntPrototype<jint, juint>& t, int widen, bool dual) {\n+const Type* TypeInt::make_or_top(const TypeIntPrototype<jint, juint>& t, int widen, bool dual) {\n@@ -1797,1 +1797,1 @@\n-  return try_make(TypeIntPrototype<jint, juint>{{lo, hi}, {0, max_juint}, {0, 0}}, widen)->is_int();\n+  return make_or_top(TypeIntPrototype<jint, juint>{{lo, hi}, {0, max_juint}, {0, 0}}, widen)->is_int();\n@@ -1800,2 +1800,2 @@\n-const Type* TypeInt::try_make(const TypeIntPrototype<jint, juint>& t, int widen) {\n-  return try_make(t, widen, false);\n+const Type* TypeInt::make_or_top(const TypeIntPrototype<jint, juint>& t, int widen) {\n+  return make_or_top(t, widen, false);\n@@ -1909,1 +1909,1 @@\n-const Type* TypeLong::try_make(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual) {\n+const Type* TypeLong::make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual) {\n@@ -1925,1 +1925,1 @@\n-  return try_make(TypeIntPrototype<jlong, julong>{{lo, hi}, {0, max_julong}, {0, 0}}, widen)->is_long();\n+  return make_or_top(TypeIntPrototype<jlong, julong>{{lo, hi}, {0, max_julong}, {0, 0}}, widen)->is_long();\n@@ -1928,2 +1928,2 @@\n-const Type* TypeLong::try_make(const TypeIntPrototype<jlong, julong>& t, int widen) {\n-  return try_make(t, widen, false);\n+const Type* TypeLong::make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen) {\n+  return make_or_top(t, widen, false);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+  \/\/ This has the same semantics as std::dynamic_cast<TypeClass*>(this)\n@@ -636,1 +637,3 @@\n- * v >= _lo && v <= _hi && juint(v) >= _ulo && juint(v) <= _uhi && _bits.is_satisfied_by(v)\n+ *   v >= _lo && v <= _hi &&\n+ *   juint(v) >= _ulo && juint(v) <= _uhi &&\n+ *   _bits.is_satisfied_by(v)\n@@ -645,2 +648,2 @@\n- * constraints of t2 are tightest possible. I.e there exists no TypeInt t3\n- * which also represents {3, 5} such that:\n+ * constraints of t2 are the tightest possible. I.e there exists no TypeInt t3\n+ * which also represents {3, 5} such that any of these would be true:\n@@ -648,2 +651,6 @@\n- * t3._lo > t2._lo || t3._hi < t2._hi || t3._ulo > t2._ulo || t3._uhi < t2._uhi ||\n- *     (t3._bits._zeros &~ t2._bis._zeros) != 0 || (t3._bits._ones &~ t2._bits._ones) != 0\n+ *  1)  t3._lo  > t2._lo\n+ *  2)  t3._hi  < t2._hi\n+ *  3)  t3._ulo > t2._ulo\n+ *  4)  t3._uhi < t2._uhi\n+ *  5)  (t3._bits._zeros &~ t2._bis._zeros) != 0\n+ *  6)  (t3._bits._ones  &~ t2._bits._ones) != 0\n@@ -656,5 +663,4 @@\n- * As a result, every TypeInt is canonicalized to its tightest form upon\n- * construction. This makes it easier to reason about them in optimizations.\n- * E.g a TypeInt t with t._lo < 0 will definitely contain negative values. It\n- * also makes it trivial to determine if a TypeInt instance is a subset of\n- * another.\n+ * To simplify reasoning about the types in optimizations, we canonicalize\n+ * every TypeInt to its tightest form, already at construction. E.g a TypeInt\n+ * t with t._lo < 0 will definitely contain negative values. It also makes it\n+ * trivial to determine if a TypeInt instance is a subset of another.\n@@ -697,7 +703,1 @@\n- * 3. Either _lo == jint(_ulo) and _hi == jint(_uhi), or all elements of a\n- *   TypeInt lie in the intervals [_lo, jint(_uhi)] or [jint(_ulo), _hi] (note\n- *   that these intervals are disjoint in this case).\n- *\n- *   Proof of lemma 3:\n- *   Lemma 3.1: For 2 jint value x, y such that they are both >= 0 or both < 0.\n- *   Then:\n+ * 3. Given 2 jint values x, y where either both >= 0 or both < 0. Then:\n@@ -708,1 +708,5 @@\n- *   Then, we have:\n+ * 4. Either _lo == jint(_ulo) and _hi == jint(_uhi), or each element of a\n+ *   TypeInt lies in either interval [_lo, jint(_uhi)] or [jint(_ulo), _hi]\n+ *   (note that these intervals are disjoint in this case).\n+ *\n+ *   Proof of lemma 4:\n@@ -715,1 +719,1 @@\n- *     juint(t._lo) <= juint(jint(t._ulo)) (lemma 3.1)\n+ *     juint(t._lo) <= juint(jint(t._ulo)) (lemma 3)\n@@ -727,1 +731,1 @@\n- *     juint(t._hi) >= juint(jint(t._uhi)) (lemma 3.1)\n+ *     juint(t._hi) >= juint(jint(t._uhi)) (lemma 3)\n@@ -731,1 +735,2 @@\n- *     Which means that t._hi = jint(t._uhi)\n+ *     Which means that t._hi == jint(t._uhi).\n+ *     In this case, t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n@@ -733,1 +738,2 @@\n- *   b. t._hi < 0. Similarly, t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n+ *   b. t._hi < 0. Similarly, we can conclude that:\n+ *     t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n@@ -744,1 +750,1 @@\n- *     In this case, all elements of t belongs to either [t._lo, jint(t._uhi)] or\n+ *     In this case, each element of t belongs to either [t._lo, jint(t._uhi)] or\n@@ -747,3 +753,3 @@\n- *     Below is an illustration of the TypeInt in this case, the intervals that the\n- *     elements can be in are marked using the = symbol. Note how the negative range\n- *     in the signed domain wrap around in the unsigned domain.\n+ *     Below is an illustration of the TypeInt in this case, the intervals that\n+ *     the elements can be in are marked using the = symbol. Note how the\n+ *     negative range in the signed domain wrap around in the unsigned domain.\n@@ -772,1 +778,1 @@\n-  static const Type* try_make(const TypeIntPrototype<jint, juint>& t, int widen, bool dual);\n+  static const Type* make_or_top(const TypeIntPrototype<jint, juint>& t, int widen, bool dual);\n@@ -794,1 +800,1 @@\n-  static const Type* try_make(const TypeIntPrototype<jint, juint>& t, int widen);\n+  static const Type* make_or_top(const TypeIntPrototype<jint, juint>& t, int widen);\n@@ -852,1 +858,1 @@\n-  static const Type* try_make(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual);\n+  static const Type* make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual);\n@@ -875,1 +881,1 @@\n-  static const Type* try_make(const TypeIntPrototype<jlong, julong>& t, int widen);\n+  static const Type* make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"}]}