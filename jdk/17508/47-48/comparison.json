{"files":[{"patch":"@@ -284,0 +284,1 @@\n+    assert(zero_violation > one_violation, \"remaining case\");\n@@ -285,1 +286,2 @@\n-    \/\/ is a 1 that should be a 0. Trace backward to find i which is the last\n+    \/\/ is a 1 that should be a 0. Trace backward to find the first bit we can\n+    \/\/ flip from 0 to 1 (i in the formality section above), which is the last\n@@ -294,5 +296,7 @@\n-    \/\/ The first violation is the 6th bit, which should be 0. The 5th cannot be\n-    \/\/ the first different bit we are looking for, because it is already 1, the\n-    \/\/ 4th bit also cannot be, because it must be 0. As a result, the first\n-    \/\/ different bit between the result and lo must be the 3rd bit. As a result,\n-    \/\/ the result must not be smaller than:\n+    \/\/ The first violation is the 6th bit, which should be 0. We want to flip\n+    \/\/ it to 0. However, since we must obtain a value larger than lo, we must\n+    \/\/ find an earlier bit that can be flipped from 0 to 1. The 5th cannot be\n+    \/\/ the bit we are looking for, because it is already 1, the 4th bit also\n+    \/\/ cannot be, because it must be 0. As a result, the last bit we can flip,\n+    \/\/ which is the first different bit between the result and lo must be the\n+    \/\/ 3rd bit. As a result, the result must not be smaller than:\n@@ -300,2 +304,2 @@\n-    \/\/ This one satisfies zeros so we can use the logic in the previous case to\n-    \/\/ obtain our final result, which is:\n+    \/\/ This one satisfies zeros so we can use the logic in the previous case,\n+    \/\/ just OR with ones to obtain the final result, which is:\n@@ -305,1 +309,1 @@\n-    \/\/ This mask out all bits from the first violation\n+    \/\/ This mask out all bits after the first violation\n@@ -308,0 +312,1 @@\n+    \/\/ A bit that is 0 in both lo and zeros must be 0 in either\n@@ -310,2 +315,2 @@\n-    \/\/ i is the last bit being 0 in either that stands before the first\n-    \/\/ violation, which is the last set bit of tmp\n+    \/\/ This is all the bits that are not lower than first_violation and are 0\n+    \/\/ in both lo and zeros\n@@ -314,2 +319,4 @@\n-    \/\/ i == 2 here, shortcut the calculation instead of explicitly spelling out\n-    \/\/ i\n+    \/\/ i is the last bit being 0 in both lo and zeros that stands before the\n+    \/\/ first violation, which is the last set bit of tmp. i == 2 here, we want\n+    \/\/ to obtain the value with only the bit i set, this is equivalent to\n+    \/\/ extracting the last set bit of tmp, do it directly without going through i\n@@ -318,3 +325,3 @@\n-    \/\/ Set the bit at i and unset all the bit after, this is the smallest value\n-    \/\/ that satisfies bits._zeros. Similar to the above case, this is similar\n-    \/\/ to aligning lo upto alignment\n+    \/\/ Set the bit of lo at i and unset all the bits after, this is the smallest\n+    \/\/ value that satisfies bits._zeros. Similar to the above case, this is\n+    \/\/ similar to aligning lo upto alignment\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"}]}