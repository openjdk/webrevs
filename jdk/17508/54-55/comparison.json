{"files":[{"patch":"@@ -688,2 +688,2 @@\n-template <class CT, class S, class U>\n-const Type* TypeIntHelper::int_type_xmeet(const CT* i1, const Type* t2, make_type_t<S, U> make, bool dual) {\n+template <class CT>\n+const Type* TypeIntHelper::int_type_xmeet(const CT* i1, const Type* t2) {\n@@ -696,1 +696,5 @@\n-    if (!dual) {\n+    assert(i1->_is_dual == i2->_is_dual, \"must have the same duality\");\n+    using S = std::remove_const_t<decltype(CT::_lo)>;\n+    using U = std::remove_const_t<decltype(CT::_ulo)>;\n+\n+    if (!i1->_is_dual) {\n@@ -698,4 +702,4 @@\n-      return make(TypeIntPrototype<S, U>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n-                                         {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n-                                         {i1->_bits._zeros & i2->_bits._zeros, i1->_bits._ones & i2->_bits._ones}},\n-                  MAX2(i1->_widen, i2->_widen), false);\n+      return CT::try_make(TypeIntPrototype<S, U>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n+                                                 {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n+                                                 {i1->_bits._zeros & i2->_bits._zeros, i1->_bits._ones & i2->_bits._ones}},\n+                          MAX2(i1->_widen, i2->_widen), false);\n@@ -704,4 +708,4 @@\n-    return make(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n-                                       {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n-                                       {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n-                MIN2(i1->_widen, i2->_widen), true);\n+    return CT::try_make(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n+                                               {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n+                                               {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n+                        MIN2(i1->_widen, i2->_widen), true);\n@@ -741,4 +745,2 @@\n-template const Type* TypeIntHelper::int_type_xmeet(const TypeInt* i1, const Type* t2,\n-                                                   const Type* (*make)(const TypeIntPrototype<jint, juint>&, int, bool), bool dual);\n-template const Type* TypeIntHelper::int_type_xmeet(const TypeLong* i1, const Type* t2,\n-                                                   const Type* (*make)(const TypeIntPrototype<jlong, julong>&, int, bool), bool dual);\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeInt* i1, const Type* t2);\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeLong* i1, const Type* t2);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -158,5 +158,2 @@\n-  template <class S, class U>\n-  using make_type_t = const Type* (*)(const TypeIntPrototype<S, U>&, int, bool);\n-\n-  template <class CT, class S, class U>\n-  static const Type* int_type_xmeet(const CT* i1, const Type* t2, make_type_t<S, U> make, bool dual);\n+  template <class CT>\n+  static const Type* int_type_xmeet(const CT* i1, const Type* t2);\n@@ -182,1 +179,1 @@\n-  static const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt);\n+  static const Type* int_type_widen(const CT* new_type, const CT* old_type, const CT* limit_type);\n@@ -185,1 +182,1 @@\n-  static const Type* int_type_narrow(const CT* nt, const CT* ot);\n+  static const Type* int_type_narrow(const CT* new_type, const CT* old_type);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1805,0 +1805,1 @@\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1806,1 +1807,3 @@\n-  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi && _bits.is_satisfied_by(u);\n+  return i >= _lo && i <= _hi &&\n+         u >= _ulo && u <= _uhi &&\n+         _bits.is_satisfied_by(u);\n@@ -1810,0 +1813,1 @@\n+  assert(!_is_dual && !t->_is_dual, \"dual types should only be used for join calculation\");\n@@ -1814,1 +1818,1 @@\n-  return TypeIntHelper::int_type_xmeet(this, t, TypeInt::try_make, _is_dual);\n+  return TypeIntHelper::int_type_xmeet(this, t);\n@@ -1929,0 +1933,1 @@\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1930,1 +1935,3 @@\n-  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi && _bits.is_satisfied_by(u);\n+  return i >= _lo && i <= _hi &&\n+         u >= _ulo && u <= _uhi &&\n+         _bits.is_satisfied_by(u);\n@@ -1934,0 +1941,1 @@\n+  assert(!_is_dual && !t->_is_dual, \"dual types should only be used for join calculation\");\n@@ -1937,2 +1945,2 @@\n-const Type *TypeLong::xmeet(const Type* t) const {\n-  return TypeIntHelper::int_type_xmeet(this, t, TypeLong::try_make, _is_dual);\n+const Type* TypeLong::xmeet(const Type* t) const {\n+  return TypeIntHelper::int_type_xmeet(this, t);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -770,0 +770,1 @@\n+private:\n@@ -772,0 +773,3 @@\n+\n+  friend class TypeIntHelper;\n+\n@@ -846,0 +850,1 @@\n+private:\n@@ -848,0 +853,3 @@\n+\n+  friend class TypeIntHelper;\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}