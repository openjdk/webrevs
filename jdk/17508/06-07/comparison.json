{"files":[{"patch":"@@ -40,2 +40,2 @@\n-template <class T>\n-class NormalizeSimpleResult {\n+template <class U>\n+class SimpleCanonicalResult {\n@@ -44,2 +44,2 @@\n-  RangeInt<T> _bounds;\n-  KnownBits<T> _bits;\n+  RangeInt<U> _bounds;\n+  KnownBits<U> _bits;\n@@ -51,9 +51,9 @@\n-template <class T>\n-static AdjustResult<RangeInt<T>>\n-adjust_bounds_from_bits(const RangeInt<T>& bounds, const KnownBits<T>& bits) {\n-  static_assert(std::is_unsigned<T>::value, \"\");\n-\n-  auto adjust_lo = [](T lo, const KnownBits<T>& bits) {\n-    constexpr size_t W = sizeof(T) * 8;\n-    T zero_violation = lo & bits._zeros;\n-    T one_violation = ~lo & bits._ones;\n+template <class U>\n+static AdjustResult<RangeInt<U>>\n+adjust_bounds_from_bits(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n+  \/\/ Find the minimum value that is not less than lo and satisfies bits\n+  auto adjust_lo = [](U lo, const KnownBits<U>& bits) {\n+    constexpr size_t W = sizeof(U) * 8;\n+    \/\/ Violation of lo with respects to bits\n+    U zero_violation = lo & bits._zeros;\n+    U one_violation = ~lo & bits._ones;\n@@ -61,0 +61,2 @@\n+      \/\/ This means lo does not violate bits, it is the result\n+      assert(zero_violation == 0, \"\");\n@@ -65,4 +67,9 @@\n-      \/\/ Align the last violation of ones unset all the lower bits\n-      \/\/ so we don't care about violations of zeros\n-      juint last_violation = W - 1 - count_leading_zeros(one_violation);\n-      T alignment = T(1) << last_violation;\n+      \/\/ This means that the first bit that does not satisfy the bit\n+      \/\/ requirement is a 0 that should be a 1\n+      \/\/ Try to set that bit, the smallest value will have all the following\n+      \/\/ bits being zeros\n+      \/\/ E.g: lo = 10010010, zeros = 00100100, ones = 01001000\n+      juint first_violation = W - 1 - count_leading_zeros(one_violation);\n+      U alignment = U(1) << first_violation;\n+      \/\/ 11000000, notice that all bits after the second digit are zeroed,\n+      \/\/ which automatically satisfies the unset bit requirement\n@@ -70,1 +77,2 @@\n-      return lo | bits._ones;\n+      \/\/ Simply satisfy the set bit requirement\n+      return lo | bits._ones; \/\/ 11001000\n@@ -73,15 +81,15 @@\n-    \/\/ Suppose lo = 00110010, zeros = 01010010, ones = 10001000\n-    \/\/ Since the 4-th bit must be 0, we need to align up the lower bound.\n-    \/\/ This results in lo = 01000000, but then the 6-th bit does not match,\n-    \/\/ align up again gives us 10000000.\n-    \/\/ We can align up directly to 10000000 by finding the first place after\n-    \/\/ the highest mismatch such that both the corresponding bits are unset.\n-    \/\/ Since all bits lower than the alignment are unset we don't need to\n-    \/\/ align for the violations of ones anymore.\n-    juint last_violation = W - 1 - count_leading_zeros(zero_violation);\n-    T find_mask = std::numeric_limits<T>::max() << last_violation;\n-    T either = lo | bits._zeros;\n-    T tmp = ~either & find_mask;\n-    T alignment = tmp & (-tmp);\n-    lo = (lo & -alignment) + alignment;\n-    return lo | bits._ones;\n+    \/\/ This is more difficult because trying to unset a bit requires us to flip\n+    \/\/ some bits before it (higher bits)\n+    \/\/ Suppose lo = 11000110, zeros = 00001010, ones = 10010001\n+    \/\/ Since the 2-nd bit must be 0, we need to align up the lower bound.\n+    \/\/ This results in lo = 11001000, but then the 4-th bit does not match,\n+    \/\/ align up again gives us 11010000\n+    \/\/ We can align up directly to 11010000 by finding the last place before\n+    \/\/ the first mismatch such that it is 0 in lo and not required to be unset\n+    juint first_violation = W - 1 - count_leading_zeros(zero_violation);\n+    U find_mask = std::numeric_limits<U>::max() << first_violation; \/\/ 11111100\n+    U either = lo | bits._zeros; \/\/ 11001110\n+    U tmp = ~either & find_mask; \/\/ 00110000\n+    U alignment = tmp & (-tmp); \/\/ 00010000\n+    lo = (lo & -alignment) + alignment; \/\/ 11010000\n+    return lo | bits._ones; \/\/ 11010001\n@@ -90,1 +98,1 @@\n-  T new_lo = adjust_lo(bounds._lo, bits);\n+  U new_lo = adjust_lo(bounds._lo, bits);\n@@ -92,0 +100,2 @@\n+    \/\/ This means we wrapped around, which means no value not less than lo\n+    \/\/ satisfies bits\n@@ -94,1 +104,2 @@\n-  T new_hi = ~adjust_lo(~bounds._hi, {bits._ones, bits._zeros});\n+  \/\/ Adjust hi by adjusting its bitwise negation\n+  U new_hi = ~adjust_lo(~bounds._hi, {bits._ones, bits._zeros});\n@@ -104,1 +115,3 @@\n-\/\/ Try to tighten the known bit constraints from the bound information\n+\/\/ Try to tighten the known bit constraints from the bound information by\n+\/\/ extracting the common prefix of lo and hi and combining with the current\n+\/\/ bit constraints\n@@ -106,9 +119,10 @@\n-template <class T>\n-static AdjustResult<KnownBits<T>>\n-adjust_bits_from_bounds(const KnownBits<T>& bits, const RangeInt<T>& bounds) {\n-  static_assert(std::is_unsigned<T>::value, \"\");\n-  T mismatch = bounds._lo ^ bounds._hi;\n-  T match_mask = mismatch == 0 ? std::numeric_limits<T>::max()\n-                               : ~(std::numeric_limits<T>::max() >> count_leading_zeros(mismatch));\n-  T new_zeros = bits._zeros | (match_mask &~ bounds._lo);\n-  T new_ones = bits._ones | (match_mask & bounds._lo);\n+template <class U>\n+static AdjustResult<KnownBits<U>>\n+adjust_bits_from_bounds(const KnownBits<U>& bits, const RangeInt<U>& bounds) {\n+  \/\/ Find the mask to filter the common prefix\n+  U mismatch = bounds._lo ^ bounds._hi;\n+  U match_mask = mismatch == 0 ? std::numeric_limits<U>::max()\n+                               : ~(std::numeric_limits<U>::max() >> count_leading_zeros(mismatch));\n+  \/\/ match_mask & bounds._lo is the common prefix\n+  U new_zeros = bits._zeros | (match_mask &~ bounds._lo);\n+  U new_ones = bits._ones | (match_mask & bounds._lo);\n@@ -123,4 +137,4 @@\n-template <class T>\n-static NormalizeSimpleResult<T>\n-normalize_constraints_simple(const RangeInt<T>& bounds, const KnownBits<T>& bits) {\n-  AdjustResult<KnownBits<T>> nbits = adjust_bits_from_bounds(bits, bounds);\n+template <class U>\n+static SimpleCanonicalResult<U>\n+normalize_constraints_simple(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n+  AdjustResult<KnownBits<U>> nbits = adjust_bits_from_bounds(bits, bounds);\n@@ -130,1 +144,1 @@\n-  AdjustResult<RangeInt<T>> nbounds{true, true, bounds};\n+  AdjustResult<RangeInt<U>> nbounds{true, true, bounds};\n@@ -148,4 +162,4 @@\n-template <class T, class U>\n-Pair<bool, TypeIntPrototype<T, U>>\n-TypeIntPrototype<T, U>::normalize_constraints() const {\n-  static_assert(std::is_signed<T>::value, \"\");\n+template <class S, class U>\n+CanonicalizedTypeIntPrototype<S, U>\n+TypeIntPrototype<S, U>::canonicalize_constraints() const {\n+  static_assert(std::is_signed<S>::value, \"\");\n@@ -153,1 +167,1 @@\n-  static_assert(sizeof(T) == sizeof(U), \"\");\n+  static_assert(sizeof(S) == sizeof(U), \"\");\n@@ -155,1 +169,1 @@\n-  RangeInt<T> srange = _srange;\n+  RangeInt<S> srange = _srange;\n@@ -163,5 +177,5 @@\n-  if (T(urange._lo) > T(urange._hi)) {\n-    if (T(urange._hi) < srange._lo) {\n-      urange._hi = std::numeric_limits<T>::max();\n-    } else if (T(urange._lo) > srange._hi) {\n-      urange._lo = std::numeric_limits<T>::min();\n+  if (S(urange._lo) > S(urange._hi)) {\n+    if (S(urange._hi) < srange._lo) {\n+      urange._hi = std::numeric_limits<S>::max();\n+    } else if (S(urange._lo) > srange._hi) {\n+      urange._lo = std::numeric_limits<S>::min();\n@@ -171,1 +185,1 @@\n-  if (T(urange._lo) <= T(urange._hi)) {\n+  if (S(urange._lo) <= S(urange._hi)) {\n@@ -173,2 +187,2 @@\n-    urange._lo = MAX2<T>(urange._lo, srange._lo);\n-    urange._hi = MIN2<T>(urange._hi, srange._hi);\n+    urange._lo = MAX2<S>(urange._lo, srange._lo);\n+    urange._hi = MIN2<S>(urange._hi, srange._hi);\n@@ -180,1 +194,1 @@\n-    return {type._present, {{T(type._bounds._lo), T(type._bounds._hi)},\n+    return {type._present, {{S(type._bounds._lo), S(type._bounds._hi)},\n@@ -194,1 +208,1 @@\n-    return {true, {{T(pos_type._bounds._lo), T(pos_type._bounds._hi)},\n+    return {true, {{S(pos_type._bounds._lo), S(pos_type._bounds._hi)},\n@@ -197,1 +211,1 @@\n-    return {true, {{T(neg_type._bounds._lo), T(neg_type._bounds._hi)},\n+    return {true, {{S(neg_type._bounds._lo), S(neg_type._bounds._hi)},\n@@ -200,1 +214,1 @@\n-    return {true, {{T(neg_type._bounds._lo), T(pos_type._bounds._hi)},\n+    return {true, {{S(neg_type._bounds._lo), S(pos_type._bounds._hi)},\n@@ -206,2 +220,2 @@\n-template <class T, class U>\n-int TypeIntPrototype<T, U>::normalize_widen(int w) const {\n+template <class S, class U>\n+int TypeIntPrototype<S, U>::normalize_widen(int w) const {\n@@ -213,1 +227,1 @@\n-  if (_srange._lo == std::numeric_limits<T>::min() && _srange._hi == std::numeric_limits<T>::max() &&\n+  if (_srange._lo == std::numeric_limits<S>::min() && _srange._hi == std::numeric_limits<S>::max() &&\n@@ -223,2 +237,2 @@\n-template <class T, class U>\n-bool TypeIntPrototype<T, U>::contains(T v) const {\n+template <class S, class U>\n+bool TypeIntPrototype<S, U>::contains(S v) const {\n@@ -230,3 +244,3 @@\n-template <class T, class U>\n-void TypeIntPrototype<T, U>::verify_constraints() const {\n-  static_assert(std::is_signed<T>::value, \"\");\n+template <class S, class U>\n+void TypeIntPrototype<S, U>::verify_constraints() const {\n+  static_assert(std::is_signed<S>::value, \"\");\n@@ -234,1 +248,1 @@\n-  static_assert(sizeof(T) == sizeof(U), \"\");\n+  static_assert(sizeof(S) == sizeof(U), \"\");\n@@ -265,2 +279,2 @@\n-template <class CT, class T, class UT>\n-const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<T, UT>&, int, bool), bool dual) {\n+template <class CT, class S, class U>\n+const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<S, U>&, int, bool), bool dual) {\n@@ -275,3 +289,3 @@\n-      return make(TypeIntPrototype<T, UT>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n-                                          {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n-                                          {i1->_zeros & i2->_zeros, i1->_ones & i2->_ones}},\n+      return make(TypeIntPrototype<S, U>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n+                                         {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n+                                         {i1->_zeros & i2->_zeros, i1->_ones & i2->_ones}},\n@@ -281,3 +295,3 @@\n-    return make(TypeIntPrototype<T, UT>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n-                                        {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n-                                        {i1->_zeros | i2->_zeros, i1->_ones | i2->_ones}},\n+    return make(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n+                                       {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n+                                       {i1->_zeros | i2->_zeros, i1->_ones | i2->_ones}},\n@@ -325,1 +339,1 @@\n-  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  using S = std::remove_const_t<decltype(CT::_lo)>;\n@@ -363,1 +377,1 @@\n-    TypeIntPrototype<T, U> prototype{{nt->_lo, nt->_hi}, {nt->_ulo, nt->_uhi}, {nt->_zeros, nt->_ones}};\n+    TypeIntPrototype<S, U> prototype{{nt->_lo, nt->_hi}, {nt->_ulo, nt->_uhi}, {nt->_zeros, nt->_ones}};\n@@ -369,2 +383,2 @@\n-  T min = std::numeric_limits<T>::min();\n-  T max = std::numeric_limits<T>::max();\n+  S min = std::numeric_limits<S>::min();\n+  S max = std::numeric_limits<S>::max();\n@@ -383,1 +397,1 @@\n-  TypeIntPrototype<T, U> prototype{{min, max}, {umin, umax}, {zeros, ones}};\n+  TypeIntPrototype<S, U> prototype{{min, max}, {umin, umax}, {zeros, ones}};\n@@ -394,1 +408,1 @@\n-  using T = decltype(CT::_lo);\n+  using S = decltype(CT::_lo);\n@@ -422,1 +436,1 @@\n-  U oc = cardinality_from_bounds(RangeInt<T>{ot->_lo, ot->_hi},\n+  U oc = cardinality_from_bounds(RangeInt<S>{ot->_lo, ot->_hi},\n@@ -424,1 +438,1 @@\n-  U nc = cardinality_from_bounds(RangeInt<T>{nt->_lo, nt->_hi},\n+  U nc = cardinality_from_bounds(RangeInt<S>{nt->_lo, nt->_hi},\n@@ -434,1 +448,1 @@\n-static const char* intnamenear(T origin, const char* xname, char* buf, size_t buf_size, T n) {\n+static const char* int_name_near(T origin, const char* xname, char* buf, size_t buf_size, T n) {\n@@ -452,1 +466,1 @@\n-  const char* str = intnamenear<jint>(max_jint, \"maxint\", buf, buf_size, n);\n+  const char* str = int_name_near<jint>(max_jint, \"maxint\", buf, buf_size, n);\n@@ -457,1 +471,1 @@\n-  str = intnamenear<jint>(min_jint, \"minint\", buf, buf_size, n);\n+  str = int_name_near<jint>(min_jint, \"minint\", buf, buf_size, n);\n@@ -467,1 +481,1 @@\n-  const char* str = intnamenear<juint>(max_juint, \"maxuint\", buf, buf_size, n);\n+  const char* str = int_name_near<juint>(max_juint, \"maxuint\", buf, buf_size, n);\n@@ -472,1 +486,1 @@\n-  str = intnamenear<juint>(max_jint, \"maxint\", buf, buf_size, n);\n+  str = int_name_near<juint>(max_jint, \"maxint\", buf, buf_size, n);\n@@ -482,1 +496,1 @@\n-  const char* str = intnamenear<jlong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  const char* str = int_name_near<jlong>(max_jlong, \"maxlong\", buf, buf_size, n);\n@@ -487,1 +501,1 @@\n-  str = intnamenear<jlong>(min_jlong, \"minlong\", buf, buf_size, n);\n+  str = int_name_near<jlong>(min_jlong, \"minlong\", buf, buf_size, n);\n@@ -492,1 +506,1 @@\n-  str = intnamenear<jlong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  str = int_name_near<jlong>(max_juint, \"maxuint\", buf, buf_size, n);\n@@ -497,1 +511,1 @@\n-  str = intnamenear<jlong>(max_jint, \"maxint\", buf, buf_size, n);\n+  str = int_name_near<jlong>(max_jint, \"maxint\", buf, buf_size, n);\n@@ -502,1 +516,1 @@\n-  str = intnamenear<jlong>(min_jint, \"minint\", buf, buf_size, n);\n+  str = int_name_near<jlong>(min_jint, \"minint\", buf, buf_size, n);\n@@ -512,1 +526,1 @@\n-  const char* str = intnamenear<julong>(max_julong, \"maxulong\", buf, buf_size, n);\n+  const char* str = int_name_near<julong>(max_julong, \"maxulong\", buf, buf_size, n);\n@@ -517,1 +531,1 @@\n-  str = intnamenear<julong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  str = int_name_near<julong>(max_jlong, \"maxlong\", buf, buf_size, n);\n@@ -522,1 +536,1 @@\n-  str = intnamenear<julong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  str = int_name_near<julong>(max_juint, \"maxuint\", buf, buf_size, n);\n@@ -527,1 +541,1 @@\n-  str = intnamenear<julong>(max_jint, \"maxint\", buf, buf_size, n);\n+  str = int_name_near<julong>(max_jint, \"maxint\", buf, buf_size, n);\n@@ -559,0 +573,56 @@\n+\n+void int_type_dump(const TypeInt* t, outputStream* st, bool verbose) {\n+  char buf1[40], buf2[40], buf3[40], buf4[40], buf5[40];\n+  if (int_type_equal(t, TypeInt::INT)) {\n+    st->print(\"int\");\n+  } else if (t->is_con()) {\n+    st->print(\"int:%s\", intname(buf1, sizeof(buf1), t->get_con()));\n+  } else if (int_type_equal(t, TypeInt::BOOL)) {\n+    st->print(\"bool\");\n+  } else if (int_type_equal(t, TypeInt::BYTE)) {\n+    st->print(\"byte\");\n+  } else if (int_type_equal(t, TypeInt::CHAR)) {\n+    st->print(\"char\");\n+  } else if (int_type_equal(t, TypeInt::SHORT)) {\n+    st->print(\"short\");\n+  } else {\n+    if (verbose) {\n+      st->print(\"int:%s..%s ^ %s..%s, bits:%s\",\n+                intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi),\n+                uintname(buf3, sizeof(buf3), t->_ulo), uintname(buf4, sizeof(buf4), t->_uhi),\n+                bitname(buf5, sizeof(buf5), t->_zeros, t->_ones));\n+    } else {\n+      st->print(\"int:%s..%s ^ %s..%s\",\n+                intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi),\n+                uintname(buf3, sizeof(buf3), t->_ulo), uintname(buf4, sizeof(buf4), t->_uhi));\n+    }\n+  }\n+\n+  if (t->_widen > 0 && t != TypeInt::INT) {\n+    st->print(\", widen: %d\", t->_widen);\n+  }\n+}\n+\n+void int_type_dump(const TypeLong* t, outputStream* st, bool verbose) {\n+  char buf1[80], buf2[80], buf3[80], buf4[80], buf5[80];\n+  if (int_type_equal(t, TypeLong::LONG)) {\n+    st->print(\"long\");\n+  } else if (t->is_con()) {\n+    st->print(\"long:%s\", longname(buf1, sizeof(buf1), t->get_con()));\n+  } else {\n+    if (verbose) {\n+      st->print(\"long:%s..%s ^ %s..%s, bits:%s\",\n+                longname(buf1, sizeof(buf1), t->_lo), longname(buf2,sizeof(buf2), t-> _hi),\n+                ulongname(buf3, sizeof(buf3), t->_ulo), ulongname(buf4, sizeof(buf4), t->_uhi),\n+                bitname(buf5, sizeof(buf5), t->_zeros, t->_ones));\n+    } else {\n+      st->print(\"long:%s..%s ^ %s..%s\",\n+                longname(buf1, sizeof(buf1), t->_lo), longname(buf2,sizeof(buf2), t-> _hi),\n+                ulongname(buf3, sizeof(buf3), t->_ulo), ulongname(buf4, sizeof(buf4), t->_uhi));\n+    }\n+  }\n+\n+  if (t->_widen > 0 && t != TypeLong::LONG) {\n+    st->print(\", widen: %d\", t->_widen);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":177,"deletions":107,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"utilities\/pair.hpp\"\n-\n@@ -31,0 +29,2 @@\n+class TypeInt;\n+class TypeLong;\n@@ -39,1 +39,1 @@\n-template <class T>\n+template <class U>\n@@ -42,2 +42,12 @@\n-  T _zeros;\n-  T _ones;\n+  U _zeros;\n+  U _ones;\n+};\n+\n+template <class S, class U>\n+class TypeIntPrototype;\n+\n+template <class S, class U>\n+class CanonicalizedTypeIntPrototype {\n+public:\n+  bool _present;\n+  TypeIntPrototype<S, U> _data;\n@@ -46,1 +56,1 @@\n-template <class T, class U>\n+template <class S, class U>\n@@ -49,1 +59,1 @@\n-  RangeInt<T> _srange;\n+  RangeInt<S> _srange;\n@@ -53,1 +63,1 @@\n-  Pair<bool, TypeIntPrototype<T, U>> normalize_constraints() const;\n+  CanonicalizedTypeIntPrototype<S, U> canonicalize_constraints() const;\n@@ -56,1 +66,1 @@\n-  bool contains(T v) const;\n+  bool contains(S v) const;\n@@ -63,2 +73,2 @@\n-template <class T, class U>\n-U cardinality_from_bounds(const RangeInt<T>& srange, const RangeInt<U>& urange) {\n+template <class S, class U>\n+U cardinality_from_bounds(const RangeInt<S>& srange, const RangeInt<U>& urange) {\n@@ -72,2 +82,2 @@\n-template <class CT, class T, class UT>\n-const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<T, UT>&, int, bool), bool dual);\n+template <class CT, class S, class U>\n+const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<S, U>&, int, bool), bool dual);\n@@ -101,0 +111,3 @@\n+\n+void int_type_dump(const TypeInt* t, outputStream* st, bool verbose);\n+void int_type_dump(const TypeLong* t, outputStream* st, bool verbose);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -474,20 +474,20 @@\n-  TypeInt::MINUS_1 = TypeInt::make(-1);  \/\/ -1\n-  TypeInt::ZERO    = TypeInt::make( 0);  \/\/  0\n-  TypeInt::ONE     = TypeInt::make( 1);  \/\/  1\n-  TypeInt::BOOL    = TypeInt::make( 0, 1, WidenMin)->is_int();  \/\/ 0 or 1, FALSE or TRUE.\n-  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin)->is_int();  \/\/ -1, 0 or 1, condition codes\n-  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin)->is_int();  \/\/ == TypeInt::MINUS_1\n-  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin)->is_int();  \/\/ == TypeInt::ONE\n-  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin)->is_int();  \/\/ == TypeInt::ZERO\n-  TypeInt::CC_NE   = TypeInt::make(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n-  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin)->is_int();\n-  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin)->is_int();  \/\/ == TypeInt::BOOL\n-  TypeInt::BYTE    = TypeInt::make(-128, 127,    WidenMin)->is_int(); \/\/ Bytes\n-  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin)->is_int(); \/\/ Unsigned Bytes\n-  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin)->is_int(); \/\/ Java chars\n-  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin)->is_int(); \/\/ Java shorts\n-  TypeInt::NON_ZERO= TypeInt::make(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n-  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin)->is_int(); \/\/ Non-neg values\n-  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin)->is_int(); \/\/ Positive values\n-  TypeInt::INT     = TypeInt::make(min_jint, max_jint, WidenMax)->is_int(); \/\/ 32-bit integers\n-  TypeInt::SYMINT  = TypeInt::make(-max_jint, max_jint, WidenMin)->is_int(); \/\/ symmetric range\n+  TypeInt::MINUS_1  = TypeInt::make(-1);  \/\/ -1\n+  TypeInt::ZERO     = TypeInt::make( 0);  \/\/  0\n+  TypeInt::ONE      = TypeInt::make( 1);  \/\/  1\n+  TypeInt::BOOL     = TypeInt::make( 0, 1, WidenMin)->is_int();  \/\/ 0 or 1, FALSE or TRUE.\n+  TypeInt::CC       = TypeInt::make(-1, 1, WidenMin)->is_int();  \/\/ -1, 0 or 1, condition codes\n+  TypeInt::CC_LT    = TypeInt::make(-1,-1, WidenMin)->is_int();  \/\/ == TypeInt::MINUS_1\n+  TypeInt::CC_GT    = TypeInt::make( 1, 1, WidenMin)->is_int();  \/\/ == TypeInt::ONE\n+  TypeInt::CC_EQ    = TypeInt::make( 0, 0, WidenMin)->is_int();  \/\/ == TypeInt::ZERO\n+  TypeInt::CC_NE    = TypeInt::make(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n+  TypeInt::CC_LE    = TypeInt::make(-1, 0, WidenMin)->is_int();\n+  TypeInt::CC_GE    = TypeInt::make( 0, 1, WidenMin)->is_int();  \/\/ == TypeInt::BOOL\n+  TypeInt::BYTE     = TypeInt::make(-128, 127,     WidenMin)->is_int(); \/\/ Bytes\n+  TypeInt::UBYTE    = TypeInt::make(0, 255,        WidenMin)->is_int(); \/\/ Unsigned Bytes\n+  TypeInt::CHAR     = TypeInt::make(0, 65535,      WidenMin)->is_int(); \/\/ Java chars\n+  TypeInt::SHORT    = TypeInt::make(-32768, 32767, WidenMin)->is_int(); \/\/ Java shorts\n+  TypeInt::NON_ZERO = TypeInt::make(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n+  TypeInt::POS      = TypeInt::make(0, max_jint,   WidenMin)->is_int(); \/\/ Non-neg values\n+  TypeInt::POS1     = TypeInt::make(1, max_jint,   WidenMin)->is_int(); \/\/ Positive values\n+  TypeInt::INT      = TypeInt::make(min_jint, max_jint, WidenMax)->is_int(); \/\/ 32-bit integers\n+  TypeInt::SYMINT   = TypeInt::make(-max_jint, max_jint, WidenMin)->is_int(); \/\/ symmetric range\n@@ -496,1 +496,1 @@\n-  \/\/ a trinary (-1,0,+1) integer result AND as an efficient long\n+  \/\/ a trinary (-1, 0, +1) integer result AND as an efficient long\n@@ -498,17 +498,17 @@\n-  assert( TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n-\n-  TypeLong::MAX = TypeLong::make(max_jlong);  \/\/ Long MAX\n-  TypeLong::MIN = TypeLong::make(min_jlong);  \/\/ Long MIN\n-  TypeLong::MINUS_1 = TypeLong::make(-1);        \/\/ -1\n-  TypeLong::ZERO    = TypeLong::make( 0);        \/\/  0\n-  TypeLong::ONE     = TypeLong::make( 1);        \/\/  1\n-  TypeLong::NON_ZERO= TypeLong::make(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n-  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin)->is_long(); \/\/ Non-neg values\n-  TypeLong::NEG     = TypeLong::make(min_jlong, -1, WidenMin)->is_long();\n-  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax)->is_long(); \/\/ 64-bit integers\n-  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin)->is_long();\n-  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin)->is_long();\n-  TypeLong::TYPE_DOMAIN  = TypeLong::LONG;\n+  assert(TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n+\n+  TypeLong::MAX = TypeLong::make(max_jlong); \/\/ Long MAX\n+  TypeLong::MIN = TypeLong::make(min_jlong); \/\/ Long MIN\n+  TypeLong::MINUS_1  = TypeLong::make(-1);   \/\/ -1\n+  TypeLong::ZERO     = TypeLong::make( 0);   \/\/  0\n+  TypeLong::ONE      = TypeLong::make( 1);   \/\/  1\n+  TypeLong::NON_ZERO = TypeLong::make(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n+  TypeLong::POS      = TypeLong::make(0, max_jlong, WidenMin)->is_long(); \/\/ Non-neg values\n+  TypeLong::NEG      = TypeLong::make(min_jlong, -1, WidenMin)->is_long();\n+  TypeLong::LONG     = TypeLong::make(min_jlong, max_jlong, WidenMax)->is_long(); \/\/ 64-bit integers\n+  TypeLong::INT      = TypeLong::make((jlong)min_jint, (jlong)max_jint,WidenMin)->is_long();\n+  TypeLong::UINT     = TypeLong::make(0, (jlong)max_juint, WidenMin)->is_long();\n+  TypeLong::TYPE_DOMAIN = TypeLong::LONG;\n@@ -1603,2 +1603,2 @@\n-  auto new_t = t.normalize_constraints();\n-  if (!new_t.first) {\n+  auto new_t = t.canonicalize_constraints();\n+  if (!new_t._present) {\n@@ -1607,1 +1607,1 @@\n-  return (new TypeInt(new_t.second, w, dual))->hashcons()->is_int();\n+  return (new TypeInt(new_t._data, w, dual))->hashcons()->is_int();\n@@ -1639,1 +1639,1 @@\n-  return int_type_xmeet(this, t, TypeInt::make, _dual);\n+  return int_type_xmeet(this, t, TypeInt::make, _is_dual);\n@@ -1644,1 +1644,1 @@\n-                     _widen, !_dual);\n+                     _widen, !_is_dual);\n@@ -1648,1 +1648,1 @@\n-  assert(!_dual, \"dual types should only be used for join calculation\");\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1653,1 +1653,1 @@\n-  assert(!_dual, \"dual types should only be used for join calculation\");\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1663,1 +1663,1 @@\n-  assert(!_dual, \"dual types should only be used for join calculation\");\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1668,1 +1668,1 @@\n-  assert(!ft->_dual, \"dual types should only be used for join calculation\");\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -1683,1 +1683,1 @@\n-  return int_type_equal(this, r) && _widen == r->_widen && _dual == r->_dual;\n+  return int_type_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -1690,1 +1690,1 @@\n-         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_dual + (uint)Type::Int;\n+         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_is_dual + (uint)Type::Int;\n@@ -1733,2 +1733,2 @@\n-  auto new_t = t.normalize_constraints();\n-  if (!new_t.first) {\n+  auto new_t = t.canonicalize_constraints();\n+  if (!new_t._present) {\n@@ -1737,1 +1737,1 @@\n-  return (new TypeLong(new_t.second, w, dual))->hashcons()->is_long();\n+  return (new TypeLong(new_t._data, w, dual))->hashcons()->is_long();\n@@ -1769,1 +1769,1 @@\n-  return int_type_xmeet(this, t, TypeLong::make, _dual);\n+  return int_type_xmeet(this, t, TypeLong::make, _is_dual);\n@@ -1774,1 +1774,1 @@\n-                      _widen, !_dual);\n+                      _widen, !_is_dual);\n@@ -1778,1 +1778,1 @@\n-  assert(!_dual, \"dual types should only be used for join calculation\");\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1783,1 +1783,1 @@\n-  assert(!_dual, \"dual types should only be used for join calculation\");\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1793,1 +1793,1 @@\n-  assert(!_dual, \"dual types should only be used for join calculation\");\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1798,1 +1798,1 @@\n-  assert(!ft->_dual, \"dual types should only be used for join calculation\");\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -1813,1 +1813,1 @@\n-  return int_type_equal(this, r) && _widen == r->_widen && _dual == r->_dual;\n+  return int_type_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -1820,1 +1820,1 @@\n-         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_dual + (uint)Type::Long;\n+         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_is_dual + (uint)Type::Long;\n@@ -1842,20 +1842,3 @@\n-void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf1[40], buf2[40], buf3[40], buf4[40], buf5[40];\n-  if (int_type_equal(this, TypeInt::INT)) {\n-    st->print(\"int\");\n-  } else if (is_con()) {\n-    st->print(\"int:%s\", intname(buf1, sizeof(buf1), get_con()));\n-  } else if (int_type_equal(this, TypeInt::BOOL)) {\n-    st->print(\"bool\");\n-  } else if (int_type_equal(this, TypeInt::BYTE)) {\n-    st->print(\"byte\");\n-  } else if (int_type_equal(this, TypeInt::CHAR)) {\n-    st->print(\"char\");\n-  } else if (int_type_equal(this, TypeInt::SHORT)) {\n-    st->print(\"short\");\n-  } else {\n-    st->print(\"int:%s..%s ^ %s..%s, bits:%s\",\n-              intname(buf1, sizeof(buf1), _lo), intname(buf2, sizeof(buf2), _hi),\n-              uintname(buf3, sizeof(buf3), _ulo), uintname(buf4, sizeof(buf4), _uhi),\n-              bitname(buf5, sizeof(buf5), _zeros, _ones));\n-  }\n+void TypeInt::dump2(Dict& d, uint depth, outputStream* st) const {\n+  int_type_dump(this, st, false);\n+}\n@@ -1863,3 +1846,2 @@\n-  if (_widen > 0 && this != TypeInt::INT) {\n-    st->print(\", widen: %d\", _widen);\n-  }\n+void TypeInt::dump_verbose() const {\n+  int_type_dump(this, tty, true);\n@@ -1868,12 +1850,3 @@\n-void TypeLong::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf1[80], buf2[80], buf3[80], buf4[80], buf5[80];\n-  if (int_type_equal(this, TypeLong::LONG)) {\n-    st->print(\"long\");\n-  } else if (is_con()) {\n-    st->print(\"long:%s\", longname(buf1, sizeof(buf1), get_con()));\n-  } else {\n-    st->print(\"long:%s..%s ^ %s..%s, bits:%s\",\n-              longname(buf1, sizeof(buf1), _lo), longname(buf2,sizeof(buf2),  _hi),\n-              ulongname(buf3, sizeof(buf3), _ulo), ulongname(buf4, sizeof(buf4), _uhi),\n-              bitname(buf5, sizeof(buf5), _zeros, _ones));\n-  }\n+void TypeLong::dump2(Dict& d, uint depth, outputStream* st) const {\n+  int_type_dump(this, st, false);\n+}\n@@ -1881,3 +1854,2 @@\n-  if (_widen > 0 && this != TypeLong::LONG) {\n-    st->print(\", widen: %d\", _widen);\n-  }\n+void TypeLong::dump_verbose() const {\n+  int_type_dump(this, tty, true);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":70,"deletions":98,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-  TypeInteger(TYPES t, int w, bool dual) : Type(t), _dual(dual), _widen(w) {}\n+  TypeInteger(TYPES t, int w, bool dual) : Type(t), _is_dual(dual), _widen(w) {}\n@@ -560,4 +560,1 @@\n-  \/\/ Previously, we signify that a set is in the dual space if _lo > _hi.\n-  \/\/ However, with the addition of unsigned range and known bits, this becomes\n-  \/\/ ambiguous whether the set is empty or a dual of a non-empty set.\n-  \/\/ As a result, we use this field to denote that a set is a dual set.\n+  \/\/ Denote that a set is a dual set.\n@@ -566,1 +563,1 @@\n-  const bool _dual;\n+  const bool _is_dual;\n@@ -602,0 +599,2 @@\n+  \/\/ A value is in the set represented by this TypeInt if it satisfies all\n+  \/\/ the below constraints, see contains(jint)\n@@ -606,1 +605,0 @@\n-  static const TypeInt* cast(const Type* t) { return t->is_int(); }\n@@ -617,1 +615,1 @@\n-  \/\/ Check if a TypeInt is a subset of this TypeInt (i.e. all elements of the\n+  \/\/ Check if a jint\/TypeInt is a subset of this TypeInt (i.e. all elements of the\n@@ -660,1 +658,1 @@\n-  static const TypeInt *as_self(const Type *t) { return t->is_int(); }\n+  static const TypeInt* as_self(const Type* t) { return t->is_int(); }\n@@ -662,1 +660,2 @@\n-  virtual void dump2( Dict &d, uint depth, outputStream *st ) const;\n+  virtual void dump2(Dict& d, uint depth, outputStream* st) const;\n+  void dump_verbose() const;\n@@ -683,0 +682,2 @@\n+  \/\/ A value is in the set represented by this TypeLong if it satisfies all\n+  \/\/ the below constraints, see contains(jlong)\n@@ -687,1 +688,0 @@\n-  static const TypeLong* cast(const Type* t) { return t->is_long(); }\n@@ -698,1 +698,1 @@\n-  \/\/ Check if a TypeLong is a subset of this TypeLong (i.e. all elements of the\n+  \/\/ Check if a jlong\/TypeLong is a subset of this TypeLong (i.e. all elements of the\n@@ -732,1 +732,1 @@\n-  static const TypeLong *as_self(const Type *t) { return t->is_long(); }\n+  static const TypeLong* as_self(const Type* t) { return t->is_long(); }\n@@ -735,1 +735,2 @@\n-  virtual void dump2( Dict &d, uint, outputStream *st  ) const;\/\/ Specialized per-Type dumping\n+  virtual void dump2(Dict& d, uint, outputStream* st) const;\/\/ Specialized per-Type dumping\n+  void dump_verbose() const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-template <class T, class U>\n+template <class S, class U>\n@@ -51,2 +51,2 @@\n-    T a = uniform_random<U>();\n-    T b = uniform_random<U>();\n+    S a = uniform_random<U>();\n+    S b = uniform_random<U>();\n@@ -55,3 +55,3 @@\n-      T lo = MIN2<T>(a, b);\n-      T hi = MAX2<T>(a, b);\n-      TypeIntPrototype<T, U> t{{lo, hi}, {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()},\n+      S lo = MIN2<S>(a, b);\n+      S hi = MAX2<S>(a, b);\n+      TypeIntPrototype<S, U> t{{lo, hi}, {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()},\n@@ -59,5 +59,5 @@\n-      auto new_t = t.normalize_constraints();\n-      ASSERT_TRUE(new_t.first);\n-      DEBUG_ONLY(new_t.second.verify_constraints());\n-      ASSERT_EQ(lo, new_t.second._srange._lo);\n-      ASSERT_EQ(hi, new_t.second._srange._hi);\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(lo, new_t._data._srange._lo);\n+      ASSERT_EQ(hi, new_t._data._srange._hi);\n@@ -65,2 +65,2 @@\n-        ASSERT_EQ(U(lo), new_t.second._urange._lo);\n-        ASSERT_EQ(U(hi), new_t.second._urange._hi);\n+        ASSERT_EQ(U(lo), new_t._data._urange._lo);\n+        ASSERT_EQ(U(hi), new_t._data._urange._hi);\n@@ -68,2 +68,2 @@\n-        ASSERT_EQ(std::numeric_limits<U>::min(), new_t.second._urange._lo);\n-        ASSERT_EQ(std::numeric_limits<U>::max(), new_t.second._urange._hi);\n+        ASSERT_EQ(std::numeric_limits<U>::min(), new_t._data._urange._lo);\n+        ASSERT_EQ(std::numeric_limits<U>::max(), new_t._data._urange._hi);\n@@ -76,1 +76,1 @@\n-      TypeIntPrototype<T, U> t{{std::numeric_limits<T>::min(), std::numeric_limits<T>::max()},\n+      TypeIntPrototype<S, U> t{{std::numeric_limits<S>::min(), std::numeric_limits<S>::max()},\n@@ -78,8 +78,8 @@\n-      auto new_t = t.normalize_constraints();\n-      ASSERT_TRUE(new_t.first);\n-      DEBUG_ONLY(new_t.second.verify_constraints());\n-      ASSERT_EQ(ulo, new_t.second._urange._lo);\n-      ASSERT_EQ(uhi, new_t.second._urange._hi);\n-      if (T(ulo) <= T(uhi)) {\n-        ASSERT_EQ(T(ulo), new_t.second._srange._lo);\n-        ASSERT_EQ(T(uhi), new_t.second._srange._hi);\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(ulo, new_t._data._urange._lo);\n+      ASSERT_EQ(uhi, new_t._data._urange._hi);\n+      if (S(ulo) <= S(uhi)) {\n+        ASSERT_EQ(S(ulo), new_t._data._srange._lo);\n+        ASSERT_EQ(S(uhi), new_t._data._srange._hi);\n@@ -87,2 +87,2 @@\n-        ASSERT_EQ(std::numeric_limits<T>::min(), new_t.second._srange._lo);\n-        ASSERT_EQ(std::numeric_limits<T>::max(), new_t.second._srange._hi);\n+        ASSERT_EQ(std::numeric_limits<S>::min(), new_t._data._srange._lo);\n+        ASSERT_EQ(std::numeric_limits<S>::max(), new_t._data._srange._hi);\n@@ -96,1 +96,1 @@\n-      TypeIntPrototype<T, U> t{{std::numeric_limits<T>::min(), std::numeric_limits<T>::max()},\n+      TypeIntPrototype<S, U> t{{std::numeric_limits<S>::min(), std::numeric_limits<S>::max()},\n@@ -98,7 +98,7 @@\n-      auto new_t = t.normalize_constraints();\n-      ASSERT_TRUE(new_t.first);\n-      DEBUG_ONLY(new_t.second.verify_constraints());\n-      ASSERT_EQ(zeros, new_t.second._bits._zeros);\n-      ASSERT_EQ(ones, new_t.second._bits._ones);\n-      ASSERT_EQ(ones, new_t.second._urange._lo);\n-      ASSERT_EQ(~zeros, new_t.second._urange._hi);\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(zeros, new_t._data._bits._zeros);\n+      ASSERT_EQ(ones, new_t._data._bits._ones);\n+      ASSERT_EQ(ones, new_t._data._urange._lo);\n+      ASSERT_EQ(~zeros, new_t._data._urange._hi);\n@@ -109,1 +109,1 @@\n-template <class T, class U>\n+template <class S, class U>\n@@ -114,4 +114,4 @@\n-    T s1 = uniform_random<U>();\n-    T s2 = uniform_random<U>();\n-    T lo = MIN2(s1, s2);\n-    T hi = MAX2(s1, s2);\n+    S s1 = uniform_random<U>();\n+    S s2 = uniform_random<U>();\n+    S lo = MIN2(s1, s2);\n+    S hi = MAX2(s1, s2);\n@@ -127,4 +127,4 @@\n-    TypeIntPrototype<T, U> t{{lo, hi}, {ulo, uhi}, {zeros, ones}};\n-    auto new_t = t.normalize_constraints();\n-    if (new_t.first) {\n-      new_t.second.verify_constraints();\n+    TypeIntPrototype<S, U> t{{lo, hi}, {ulo, uhi}, {zeros, ones}};\n+    auto new_t = t.canonicalize_constraints();\n+    if (new_t._present) {\n+      new_t._data.verify_constraints();\n@@ -133,2 +133,2 @@\n-      T v = uniform_random<U>();\n-      if (!new_t.first) {\n+      S v = uniform_random<U>();\n+      if (!new_t._present) {\n@@ -137,1 +137,1 @@\n-        ASSERT_EQ(t.contains(v), new_t.second.contains(v));\n+        ASSERT_EQ(t.contains(v), new_t._data.contains(v));\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"}]}