{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"utilities\/intn_t.hpp\"\n@@ -61,1 +62,1 @@\n-  static_assert(std::is_unsigned<U>::value, \"bit info should be unsigned\");\n+  static_assert(U(-1) > U(0), \"bit info should be unsigned\");\n@@ -87,1 +88,0 @@\n-  constexpr size_t W = sizeof(U) * 8;\n@@ -100,1 +100,1 @@\n-    assert(zero_violation == 0, \"\");\n+    assert(zero_violation == U(0), \"\");\n@@ -225,2 +225,2 @@\n-    \/\/ lowest bit up (0-based), since i == 2, first_difference == 6\n-    juint first_violation = W - 1 - count_leading_zeros(one_violation); \/\/ 6\n+    \/\/ highest bit down (0-based), since i == 2, first_difference == 1\n+    juint first_violation = count_leading_zeros<U>(one_violation); \/\/ 1\n@@ -228,1 +228,4 @@\n-    U alignment = U(1) << first_violation;\n+    \/\/ This is the same as U(1) << (W - 1 - first_violation), we avoid using\n+    \/\/ W so that this can be used with intn_t<n>\n+    U alignment = one_violation == U(1) ? U(1)\n+                                        : (std::numeric_limits<U>::max() >> (first_violation + 1)) + U(1);\n@@ -258,1 +261,1 @@\n-    juint first_violation = W - count_leading_zeros(zero_violation);\n+    juint first_violation = count_leading_zeros<U>(zero_violation);\n@@ -261,1 +264,3 @@\n-    U find_mask = std::numeric_limits<U>::max() << first_violation;\n+    \/\/ This is the same as max << (W - first_violation), we avoid using W so\n+    \/\/ that this can be used with intn_t<n>\n+    U find_mask = ~(std::numeric_limits<U>::max() >> first_violation);\n@@ -341,2 +346,2 @@\n-  U match_mask = mismatch == 0 ? std::numeric_limits<U>::max()\n-                               : ~(std::numeric_limits<U>::max() >> count_leading_zeros(mismatch));\n+  U match_mask = mismatch == U(0) ? std::numeric_limits<U>::max()\n+                                  : ~(std::numeric_limits<U>::max() >> count_leading_zeros<U>(mismatch));\n@@ -348,1 +353,1 @@\n-  bool present = ((new_zeros & new_ones) == 0);\n+  bool present = ((new_zeros & new_ones) == U(0));\n@@ -396,1 +401,1 @@\n-      (_bits._zeros & _bits._ones) != 0) {\n+      (_bits._zeros & _bits._ones) != U(0)) {\n@@ -408,1 +413,1 @@\n-      urange._hi = std::numeric_limits<S>::max();\n+      urange._hi = U(std::numeric_limits<S>::max());\n@@ -412,1 +417,1 @@\n-      urange._lo = std::numeric_limits<S>::min();\n+      urange._lo = U(std::numeric_limits<S>::min());\n@@ -418,3 +423,3 @@\n-    urange._lo = MAX2<S>(urange._lo, srange._lo);\n-    urange._hi = MIN2<S>(urange._hi, srange._hi);\n-    if (urange._lo > urange._hi) {\n+    urange._lo = U(MAX2(S(urange._lo), srange._lo));\n+    urange._hi = U(MIN2(S(urange._hi), srange._hi));\n+    if (urange._lo > urange._hi || S(urange._lo) > S(urange._hi)) {\n@@ -452,1 +457,1 @@\n-int TypeIntPrototype<S, U>::normalize_widen(int w) const {\n+int TypeIntPrototype<S, U>::normalize_widen(int widen) const {\n@@ -455,1 +460,1 @@\n-  if (TypeIntHelper::cardinality_from_bounds(_srange, _urange) <= SMALL_TYPEINT_THRESHOLD) {\n+  if (TypeIntHelper::cardinality_from_bounds(_srange, _urange) <= U(SMALL_TYPEINT_THRESHOLD)) {\n@@ -460,1 +465,1 @@\n-      _bits._zeros == 0 && _bits._ones == 0) {\n+      _bits._zeros == U(0) && _bits._ones == U(0)) {\n@@ -464,1 +469,1 @@\n-  return w;\n+  return widen;\n@@ -470,1 +475,1 @@\n-  U u = v;\n+  U u(v);\n@@ -479,1 +484,1 @@\n-         contains(_urange._lo) && contains(_urange._hi), \"\");\n+         contains(S(_urange._lo)) && contains(S(_urange._hi)), \"\");\n@@ -503,0 +508,4 @@\n+template class TypeIntPrototype<intn_t<1>, uintn_t<1>>;\n+template class TypeIntPrototype<intn_t<2>, uintn_t<2>>;\n+template class TypeIntPrototype<intn_t<3>, uintn_t<3>>;\n+template class TypeIntPrototype<intn_t<4>, uintn_t<4>>;\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":32,"deletions":23,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  static_assert(std::is_unsigned<U>::value, \"bit info should be unsigned\");\n+  static_assert(U(-1) > U(0), \"bit info should be unsigned\");\n@@ -77,1 +77,1 @@\n-    return (v & _zeros) == 0 && (v & _ones) == _ones;\n+    return (v & _zeros) == U(0) && (v & _ones) == _ones;\n@@ -87,2 +87,2 @@\n-  static_assert(std::is_signed<S>::value, \"\");\n-  static_assert(std::is_unsigned<U>::value, \"\");\n+  static_assert(S(-1) < S(0), \"\");\n+  static_assert(U(-1) > U(0), \"\");\n@@ -99,0 +99,3 @@\n+  template <class T1, class T2>\n+  friend void test_canonicalize_constraints_exhaustive();\n+\n@@ -137,2 +140,2 @@\n-    static_assert(std::is_signed<S>::value, \"\");\n-    static_assert(std::is_unsigned<U>::value, \"\");\n+    static_assert(S(-1) < S(0), \"\");\n+    static_assert(U(-1) > U(0), \"\");\n@@ -152,1 +155,1 @@\n-    return (urange._hi - U(srange._lo)) + (U(srange._hi) - urange._lo) + 1;\n+    return (urange._hi - U(srange._lo)) + (U(srange._hi) - urange._lo) + U(1);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_INTN_T_HPP\n+#define SHARE_UTILITIES_INTN_T_HPP\n+\n+#include \"utilities\/count_leading_zeros.hpp\"\n+\n+#include <limits>\n+\n+template <unsigned int n>\n+class uintn_t;\n+\n+template <unsigned int n>\n+class intn_t {\n+  static_assert(n > 0 && n <= 8, \"should not be larger than char\");\n+\n+private:\n+  uint _v;\n+\n+  constexpr static uint _mask = (1 << n) - 1;\n+\n+  friend class uintn_t<n>;\n+\n+public:\n+  explicit constexpr intn_t(int v) : _v(v) {}\n+  constexpr intn_t() : _v(0) {}\n+  constexpr intn_t(const intn_t&) = default;\n+  explicit constexpr intn_t(uintn_t<n> v);\n+\n+  operator int() const {\n+    int shift = 32 - n;\n+    return int(_v << shift) >> shift;\n+  }\n+\n+  constexpr static int min = std::numeric_limits<unsigned int>::max() << (n - 1);\n+  constexpr static int max = (1 << (n - 1)) - 1;\n+  static_assert(min < max, \"\");\n+\n+  constexpr bool operator==(intn_t o) const { return (_v & _mask) == (o._v & _mask); }\n+  constexpr bool operator<(intn_t o) const {\n+    \/\/ Shift the highest bit of intn_t to the highest bit of the int representation\n+    int shift = 32 - n;\n+    return int(_v << shift) < int(o._v << shift);\n+  }\n+  constexpr bool operator>(intn_t o) const { return o < *this; }\n+  constexpr bool operator<=(intn_t o) const { return !(o < *this); }\n+  constexpr bool operator>=(intn_t o) const { return !(*this < o); }\n+};\n+\n+template <unsigned int n>\n+class uintn_t {\n+  static_assert(n > 0 && n <= 8, \"should not be larger than char\");\n+\n+private:\n+  uint _v;\n+\n+  constexpr static uint _mask = (1 << n) - 1;\n+\n+  friend class intn_t<n>;\n+\n+  template <class T>\n+  friend unsigned count_leading_zeros(T);\n+\n+public:\n+  explicit constexpr uintn_t(int v) : _v(v) {}\n+  constexpr uintn_t() : _v(0) {}\n+  constexpr uintn_t(const uintn_t&) = default;\n+  explicit constexpr uintn_t(intn_t<n> v) : _v(v._v) {}\n+  operator uint() const { return _v & _mask; }\n+\n+  constexpr static int min = 0;\n+  constexpr static int max = _mask;\n+  static_assert(min < max, \"\");\n+\n+  constexpr bool operator==(uintn_t o) const { return (_v & _mask) == (o._v & _mask); }\n+  constexpr bool operator!=(uintn_t o) const { return !(*this == o); }\n+  constexpr bool operator<(uintn_t o) const { return (_v & _mask) < (o._v & _mask); }\n+  constexpr bool operator>(uintn_t o) const { return o < *this; }\n+  constexpr bool operator<=(uintn_t o) const { return !(o < *this); }\n+  constexpr bool operator>=(uintn_t o) const { return !(*this < o); }\n+  constexpr uintn_t operator+(uintn_t o) const { return uintn_t(_v + o._v); }\n+  constexpr uintn_t operator-(uintn_t o) const { return uintn_t(_v - o._v); }\n+  constexpr uintn_t operator&(uintn_t o) const { return uintn_t(_v & o._v); }\n+  constexpr uintn_t operator|(uintn_t o) const { return uintn_t(_v | o._v); }\n+  constexpr uintn_t operator^(uintn_t o) const { return uintn_t(_v ^ o._v); }\n+  constexpr uintn_t operator>>(unsigned int s) const { return uintn_t((_v & _mask) >> s); }\n+  constexpr uintn_t operator<<(unsigned int s) const { return uintn_t(_v << s); }\n+  constexpr uintn_t operator~() const { return uintn_t(~_v); }\n+  constexpr uintn_t operator-() const { return uintn_t(-_v); }\n+  constexpr uintn_t& operator|=(uintn_t o) { _v |= o._v; return *this; }\n+};\n+\n+template <unsigned int n>\n+constexpr intn_t<n>::intn_t(uintn_t<n> v) : _v(v._v) {}\n+\n+namespace std {\n+\n+template <unsigned int n>\n+class numeric_limits<intn_t<n>> {\n+public:\n+  constexpr static intn_t<n> min() { return intn_t<n>(intn_t<n>::min); }\n+  constexpr static intn_t<n> max() { return intn_t<n>(intn_t<n>::max); }\n+};\n+\n+template <unsigned int n>\n+class numeric_limits<uintn_t<n>> {\n+public:\n+  constexpr static uintn_t<n> min() { return uintn_t<n>(uintn_t<n>::min); }\n+  constexpr static uintn_t<n> max() { return uintn_t<n>(uintn_t<n>::max); }\n+};\n+\n+}\n+\n+template <>\n+inline unsigned count_leading_zeros<uintn_t<1>>(uintn_t<1> v) {\n+  return count_leading_zeros<unsigned int>(v._v & uintn_t<1>::_mask) - (32 - 1);\n+}\n+\n+template <>\n+inline unsigned count_leading_zeros<uintn_t<2>>(uintn_t<2> v) {\n+  return count_leading_zeros<unsigned int>(v._v & uintn_t<2>::_mask) - (32 - 2);\n+}\n+\n+template <>\n+inline unsigned count_leading_zeros<uintn_t<3>>(uintn_t<3> v) {\n+  return count_leading_zeros<unsigned int>(v._v & uintn_t<3>::_mask) - (32 - 3);\n+}\n+\n+template <>\n+inline unsigned count_leading_zeros<uintn_t<4>>(uintn_t<4> v) {\n+  return count_leading_zeros<unsigned int>(v._v & uintn_t<4>::_mask) - (32 - 4);\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_INTN_T_HPP\n","filename":"src\/hotspot\/share\/utilities\/intn_t.hpp","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/intn_t.hpp\"\n@@ -30,2 +31,0 @@\n-#include <limits>\n-\n@@ -59,0 +58,50 @@\n+template <class S, class U>\n+static void test_canonicalize_constraints_exhaustive() {\n+  {\n+    TypeIntPrototype<S, U> t{{S(0), S(0)}, {U(0), U(0)}, {U(-1), U(0)}};\n+    auto new_t = t.canonicalize_constraints();\n+    ASSERT_TRUE(new_t._present);\n+    DEBUG_ONLY(ASSERT_TRUE(t.contains(S(0))));\n+    DEBUG_ONLY(ASSERT_FALSE(t.contains(S(1))));\n+  }\n+  {\n+    TypeIntPrototype<S, U> t{{S(0), S(0)}, {U(1), U(1)}, {U(-1), U(0)}};\n+    auto new_t = t.canonicalize_constraints();\n+    ASSERT_FALSE(new_t._present);\n+    DEBUG_ONLY(ASSERT_FALSE(t.contains(S(0))));\n+    DEBUG_ONLY(ASSERT_FALSE(t.contains(S(1))));\n+  }\n+  {\n+    TypeIntPrototype<S, U> t{{S(S::min), S(S::max)}, {U(U::min), U(U::max)}, {U(0), U(0)}};\n+    auto new_t = t.canonicalize_constraints();\n+    ASSERT_TRUE(new_t._present);\n+    for (int v = S::min; v <= S::max; v++) {\n+      DEBUG_ONLY(ASSERT_TRUE(t.contains(S(v))));\n+    }\n+  }\n+  for (int lo = S::min; lo <= S::max; lo++) {\n+    for (int hi = lo; hi <= S::max; hi++) {\n+      for (int ulo = U::min; ulo <= U::max; ulo++) {\n+        for (int uhi = ulo; uhi <= U::max; uhi++) {\n+          for (int zeros = U::min; zeros <= U::max; zeros++) {\n+            for (int ones = U::min; ones <= U::max; ones++) {\n+              TypeIntPrototype<S, U> t{{S(lo), S(hi)}, {U(ulo), U(uhi)}, {U(zeros), U(ones)}};\n+              auto new_t = t.canonicalize_constraints();\n+              if (new_t._present) {\n+                DEBUG_ONLY(new_t._data.verify_constraints());\n+              }\n+              for (int v = S::min; v <= S::max; v++) {\n+                if (!new_t._present) {\n+                  DEBUG_ONLY(ASSERT_FALSE(t.contains(S(v))));\n+                } else {\n+                  DEBUG_ONLY(ASSERT_EQ(t.contains(S(v)), new_t._data.contains(S(v))));\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -157,0 +206,4 @@\n+  test_canonicalize_constraints_exhaustive<intn_t<1>, uintn_t<1>>();\n+  test_canonicalize_constraints_exhaustive<intn_t<2>, uintn_t<2>>();\n+  test_canonicalize_constraints_exhaustive<intn_t<3>, uintn_t<3>>();\n+  test_canonicalize_constraints_exhaustive<intn_t<4>, uintn_t<4>>();\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"}]}