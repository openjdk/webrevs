{"files":[{"patch":"@@ -495,1 +495,5 @@\n-  const TypeInteger* this_type = this->type()->is_integer(bt);\n+  const TypeInteger* this_type = this->type()->isa_integer(bt);\n+  if (this_type == nullptr) {\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4430,1 +4430,3 @@\n-  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n+  if (sizetype != nullptr && sizetype->_hi > 0) {\n+    index_max = sizetype->_hi - 1;\n+  }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -914,2 +914,2 @@\n-  inline Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n-                                       int idx, bool can_grow = false);\n+  Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n+                                int idx, bool can_grow = false);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3886,1 +3886,3 @@\n-      if (size_max > tilen->_hi)  size_max = tilen->_hi;\n+      if (size_max > tilen->_hi && tilen->_hi >= 0) {\n+        size_max = tilen->_hi;\n+      }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1049,2 +1049,1 @@\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->empty()) {\n+        if (failtype->filter(type2) == Type::TOP) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,929 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"opto\/rangeinference.hpp\"\n+#include \"opto\/type.hpp\"\n+#include \"utilities\/intn_t.hpp\"\n+#include \"utilities\/tuple.hpp\"\n+\n+\/\/ If the cardinality of a TypeInt is below this threshold, use min widen, see\n+\/\/ TypeIntPrototype<S, U>::normalize_widen\n+constexpr juint SMALL_TYPEINT_THRESHOLD = 3;\n+\n+\/\/ This represents the result of an iterative calculation\n+template <class T>\n+class AdjustResult {\n+public:\n+  bool _progress; \/\/ whether there is progress compared to the last iteration\n+  bool _present;  \/\/ whether the result is empty, typically due to the calculation arriving at contradiction\n+  T _result;\n+\n+  bool empty() const {\n+    return !_present;\n+  }\n+\n+  static AdjustResult<T> make_empty() {\n+    return {true, false, {}};\n+  }\n+};\n+\n+\/\/ This is the result of canonicalizing a simple interval (see TypeInt at\n+\/\/ type.hpp)\n+template <class U>\n+class SimpleCanonicalResult {\n+  static_assert(U(-1) > U(0), \"bit info should be unsigned\");\n+public:\n+  const bool _present;       \/\/ whether this is an empty set\n+  const RangeInt<U> _bounds; \/\/ The bounds must be in the same half of the integer domain (see TypeInt)\n+  const KnownBits<U> _bits;\n+\n+  SimpleCanonicalResult(bool present, const RangeInt<U>& bounds, const KnownBits<U>& bits)\n+    : _present(present), _bounds(bounds), _bits(bits) {\n+    if (!present) {\n+      return;\n+    }\n+    \/\/ Do some verification\n+    assert(bits.is_satisfied_by(bounds._lo) && bits.is_satisfied_by(bounds._hi), \"must be canonical\");\n+    \/\/ 0b1000...\n+    constexpr U mid_point = (std::numeric_limits<U>::max() >> 1) + U(1);\n+    assert((bounds._lo < mid_point) == (bounds._hi < mid_point), \"must be a simple interval\");\n+  }\n+\n+  bool empty() const {\n+    return !_present;\n+  }\n+\n+  static SimpleCanonicalResult<U> make_empty() {\n+    return SimpleCanonicalResult(false, {}, {});\n+  }\n+};\n+\n+\/\/ Find the minimum value that is not less than lo and satisfies bits. If there\n+\/\/ does not exist one such number, the calculation will overflow and return a\n+\/\/ value < lo.\n+\/\/\n+\/\/ Here, we view a number in binary as a bit string. As a result,  the first\n+\/\/ bit refers to the highest bit (the MSB), the last bit refers to the lowest\n+\/\/ bit (the LSB), a bit comes before (being higher than) another if it is more\n+\/\/ significant, and a bit comes after (being lower than) another if it is less\n+\/\/ significant. For a value n with w bits, we denote n[0] the first (highest)\n+\/\/ bit of n, n[1] the second bit, ..., n[w - 1] the last (lowest) bit of n.\n+template <class U>\n+static U adjust_lo(U lo, const KnownBits<U>& bits) {\n+  \/\/ Violation of lo with respects to bits\n+  \/\/ E.g: lo    = 1100\n+  \/\/      zeros = 0100\n+  \/\/      ones  = 1001\n+  \/\/ zero_violation = 0100, i.e the second bit should be zero, but it is 1 in\n+  \/\/ lo. Similarly, one_violation = 0001, i.e the last bit should be one, but\n+  \/\/ it is 0 in lo. These make lo not satisfy the bit constraints, which\n+  \/\/ results in us having to find the smallest value that satisfies bits.\n+  U zero_violation = lo & bits._zeros;\n+  U one_violation = ~lo & bits._ones;\n+  if (zero_violation == one_violation) {\n+    \/\/ This means lo does not violate bits, it is the result\n+    assert(zero_violation == U(0), \"\");\n+    return lo;\n+  }\n+\n+  \/*\n+  1. Intuition:\n+  Call r the lowest value not smaller than lo that satisfies bits, consider the\n+  first bit in r that is different from the corresponding bit in lo:\n+    - Since r is larger than lo the bit must be 0 in lo and 1 in r\n+    - Since r must satisify bits the bit must be 0 in zeros\n+    - Since r should be the smallest value, this bit should be the lowest one\n+      possible\n+\n+  E.g:      1 2 3 4 5 6\n+       lo = 1 0 0 1 1 0\n+        x = 1 0 1 0 1 0\n+        y = 0 1 1 1 1 1\n+  x would be larger than lo since the first different bit is the 3rd one,\n+  while y is smaller than lo because the first different bit is the 1st bit.\n+  Next, consider:\n+       x1 = 1 0 1 0 1 0\n+       x2 = 1 0 0 1 1 1\n+  Both x1 and x2 are larger than lo, but x1 > x2 since its first different\n+  bit from lo is the 3rd one, while with x2 it is the 7th one. As a result,\n+  if both x1 and x2 satisfy bits, x2 would be closer to our true result.\n+\n+  2. Formality:\n+\n+  Call r the smallest value not smaller than lo that satisfies bits. Since lo\n+  does not satisfy bits, lo < r (2.1)\n+\n+  Call i the largest bit index such that:\n+\n+  - lo[x] satisfies bits for 0 <= x < i (2.2)\n+  - zeros[i] = 0                        (2.3)\n+  - lo[i]    = 0                        (2.4)\n+\n+  Consider v:\n+\n+  - v[x] = lo[x], for 0 <= x < i        (2.5)\n+  - v[i] = 1                            (2.6)\n+  - v[x] = ones[x], for x > i           (2.7)\n+\n+  We will prove that v == r.\n+\n+  a. Firstly, we prove that r <= v:\n+\n+    a.1. lo < v, since:\n+      lo[x] == v[x], for 0 <= x < i (according to 2.5)\n+      lo[i] <  v[i] (according to 2.4 and 2.6, lo[i] == 0 < v[i] == 1)\n+      bits at x > i have lower significance, and are thus irrelevant\n+\n+    a.2. v satisfies bits, because:\n+      v[x] satisfies bits for 0 <= x < i (according to 2.2 and 2.5)\n+      v[i] satisfies bits:\n+        According to 2.3 and 2.6, zeros[i] == 0 and v[i] == 1, v[i] does not violate\n+        bits, which means v[i] satisfies bits\n+      v[x] satisfies bits for x > i:\n+        Assume bits is not contradictory, we cannot have:\n+          ones[x]  == 1, v[x] == 0 (according to 2.7, v[x] == ones[x])\n+          zeros[x] == 1, v[x] == 1 (according to 2.7, ones[x] == v[x] == 1, which means\n+                                    bits is contradictory)\n+\n+    From a.1 and a.2, v > lo and v satisfies bits. Which means r <= v since r is the\n+    smallest such value.\n+\n+  b. Secondly, from r <= v, we prove that r == v. Suppose the contradiction r < v:\n+\n+    Since r < v, there must be a bit position j that:\n+\n+    r[j] == 0               (2.b.1)\n+    v[j] == 1               (2.b.2)\n+    r[x] == v[x], for x < j (2.b.3)\n+\n+    b.1. If j < i\n+      This means that:\n+      r[j]  == 0                (according to 2.b.1)\n+      lo[j] == 1                (according to 2.b.2 and 2.5, lo[j] == v[j] == 1 because j < i)\n+      r[x]  == lo[x], for x < j (according to 2.b.3 and 2.5, lo[x] == v[x] == r[x] with x < j < i)\n+      bits at x > j have lower significance, and are thus irrelevant\n+\n+      Which leads to r < lo, which contradicts that lo < r (acording to 2.1)\n+\n+    b.2. If j == i\n+      Since r > lo (according to 2.1), there must exist a bit index k such that:\n+\n+      r[k]  == 1                (2.b.2.1)\n+      lo[k] == 0                (2.b.2.2)\n+      r[x]  == lo[x], for x < k (2.b.2.3)\n+\n+      Then, since we have:\n+      r[x]  == v[x],  for x < i (according to 2.b.3)\n+      v[x]  == lo[x], for x < i (according to 2.5)\n+      r[i]  == 0                (according to 2.b.1 because i == j)\n+      lo[i] == 0                (according to 2.4)\n+\n+      this leads to: r[x] == lo[x], for x <= i\n+      while r[k] == 1 != lo[k] == 0, we can conclude that k > i\n+\n+      However, since:\n+      lo[x] satisfies bits for 0 <= x < k:\n+        According to 2.b.2.3, lo[x] == r[x] and r satisfies bits\n+      zeros[k] == 0 (according to 2.b.2.1, r[k] == 1 and r satisfies bits)\n+      lo[k]    == 0 (according to 2.b.2.2)\n+\n+      This contradicts the assumption that i is the largest bit index satisfying such conditions.\n+\n+    b.3. If j > i\n+      ones[j] == v[j] (according to 2.7 since j > i)\n+      v[j]    == 1    (according to 2.b.2)\n+      r[j]    == 0    (according to 2.b.1)\n+\n+      This means that r[j] == 0 and ones[j] == 1, this contradicts the assumption that r\n+      satisfies bits.\n+\n+    All cases lead to contradictions, which mean r < v is incorrect, which means that\n+    r == v, which means the value v having the above form is the lowest value not smaller\n+    than lo that satisfies bits.\n+\n+  3. Conclusion\n+    Our objective now is to find the largest value i that satisfies:\n+    - lo[x] satisfies bits for 0 <= x < i\n+    - zeros[i] = 0\n+    - lo[i] = 0\n+\n+    Call j the largest value such that lo[x] satisfies bits for 0 <= x < j. This\n+    means that j is the smallest value such that lo[j] does not satisfy bits. We\n+    call this the first violation. i then can be computed as the largest value\n+    <= j such that:\n+\n+    zeros[i] == lo[i] == 0\n+  *\/\n+\n+  \/\/ The algorithm depends on whether the first violation violates zeros or\n+  \/\/ ones, if it violates zeros, we have the bit being 1 in zero_violation and\n+  \/\/ 0 in one_violation. Since all higher bits are 0 in zero_violation and\n+  \/\/ one_violation, we have zero_violation > one_violation. Similarly, if the\n+  \/\/ first violation violates ones, we have zero_violation < one_violation.\n+  if (zero_violation < one_violation) {\n+    \/\/ This means that the first bit that does not satisfy the bit requirement\n+    \/\/ is a 0 that should be a 1. Obviously, since the bit at that position in\n+    \/\/ ones is 1, the same bit in zeros is 0. Which means this is the value of\n+    \/\/ i we are looking for.\n+    \/\/\n+    \/\/ E.g:      1 2 3 4 5 6 7 8\n+    \/\/      lo = 1 0 0 1 0 0 1 0\n+    \/\/   zeros = 0 0 1 0 0 1 0 0\n+    \/\/    ones = 0 1 0 0 1 0 1 0\n+    \/\/   1-vio = 0 1 0 0 1 0 0 0\n+    \/\/   0-vio = 0 0 0 0 0 0 0 0\n+    \/\/ Since the result must have the 2nd bit set, it must be at least:\n+    \/\/           1 1 0 0 0 0 0 0\n+    \/\/ This value must satisfy zeros, because all bits before the 2nd bit have\n+    \/\/ already satisfied zeros, and all bits after the 2nd bit are all 0 now.\n+    \/\/ Just OR this value with ones to obtain the final result.\n+\n+    \/\/ first_violation is the position of the violation counting from the\n+    \/\/ highest bit down (0-based), since i == 2, first_difference == 1\n+    juint first_violation = count_leading_zeros(one_violation); \/\/ 1\n+    \/\/           1 0 0 0 0 0 0 0\n+    constexpr U highest_bit = (std::numeric_limits<U>::max() >> 1) + U(1);\n+    \/\/           0 1 0 0 0 0 0 0\n+    U alignment = highest_bit >> first_violation;\n+    \/\/ This is the first value which have the violated bit being 1, which means\n+    \/\/ that the result should not be smaller than this\n+    \/\/           1 1 0 0 0 0 0 0\n+    U new_lo = (lo & -alignment) + alignment;\n+    \/\/           1 1 0 0 1 0 1 0\n+    new_lo |= bits._ones;\n+    assert(lo < new_lo, \"this case cannot overflow\");\n+    return new_lo;\n+  } else {\n+    \/\/ This means that the first bit that does not satisfy the bit requirement\n+    \/\/ is a 1 that should be a 0. Trace backward to find i which is the last\n+    \/\/ bit that is 0 in both lo and zeros.\n+    \/\/\n+    \/\/ E.g:      1 2 3 4 5 6 7 8\n+    \/\/      lo = 1 0 0 0 1 1 1 0\n+    \/\/   zeros = 0 0 0 1 0 1 0 0\n+    \/\/    ones = 1 0 0 0 0 0 1 1\n+    \/\/   1-vio = 0 0 0 0 0 0 0 1\n+    \/\/   0-vio = 0 0 0 0 0 1 0 0\n+    \/\/ The first violation is the 6th bit, which should be 0. The 5th cannot be\n+    \/\/ the first different bit we are looking for, because it is already 1, the\n+    \/\/ 4th bit also cannot be, because it must be 0. As a result, the first\n+    \/\/ different bit between the result and lo must be the 3rd bit. As a result,\n+    \/\/ the result must not be smaller than:\n+    \/\/           1 0 1 0 0 0 0 0\n+    \/\/ This one satisfies zeros so we can use the logic in the previous case to\n+    \/\/ obtain our final result, which is:\n+    \/\/           1 0 1 0 0 0 1 1\n+\n+    juint first_violation = count_leading_zeros(zero_violation);\n+    \/\/ This mask out all bits from the first violation\n+    \/\/           1 1 1 1 1 0 0 0\n+    U find_mask = ~(std::numeric_limits<U>::max() >> first_violation);\n+    \/\/           1 0 0 1 1 1 1 0\n+    U either = lo | bits._zeros;\n+    \/\/ i is the last bit being 0 in either that stands before the first\n+    \/\/ violation, which is the last set bit of tmp\n+    \/\/           0 1 1 0 0 0 0 0\n+    U tmp = ~either & find_mask;\n+    \/\/ i == 2 here, shortcut the calculation instead of explicitly spelling out\n+    \/\/ i\n+    \/\/           0 0 1 0 0 0 0 0\n+    U alignment = tmp & (-tmp);\n+    \/\/ Set the bit at i and unset all the bit after, this is the smallest value\n+    \/\/ that satisfies bits._zeros\n+    \/\/           1 0 1 0 0 0 0 0\n+    U new_lo = (lo & -alignment) + alignment;\n+    \/\/ Satisfy bits._ones\n+    \/\/           1 0 1 0 0 0 1 1\n+    new_lo |= bits._ones;\n+    assert(lo < new_lo || new_lo == bits._ones, \"overflow must return bits._ones\");\n+    return new_lo;\n+  }\n+}\n+\n+\/\/ Try to tighten the bound constraints from the known bit information. I.e, we\n+\/\/ find the smallest value not smaller than lo, as well as the largest value\n+\/\/ not larger than hi both of which satisfy bits\n+\/\/ E.g: lo = 0010, hi = 1001\n+\/\/ zeros = 0011\n+\/\/ ones  = 0000\n+\/\/ -> 4-aligned\n+\/\/\n+\/\/         0    1    2    3    4    5    6    7    8    9    10\n+\/\/         0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010\n+\/\/ bits:   ok   .    .    .    ok   .    .    .    ok   .    .\n+\/\/ bounds:           lo                                 hi\n+\/\/ adjust:           --------> lo                  hi <---\n+template <class U>\n+static AdjustResult<RangeInt<U>>\n+adjust_bounds_from_bits(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n+  U new_lo = adjust_lo(bounds._lo, bits);\n+  if (new_lo < bounds._lo) {\n+    \/\/ This means we wrapped around, which means no value not less than lo\n+    \/\/ satisfies bits\n+    return AdjustResult<RangeInt<U>>::make_empty();\n+  }\n+\n+  \/\/ We need to find the largest value not larger than hi that satisfies bits\n+  \/\/ One possible method is to do similar to adjust_lo, just with the other\n+  \/\/ direction\n+  \/\/ However, we can observe that if v satisfies {bits._zeros, bits._ones},\n+  \/\/ then ~v would satisfy {bits._ones, bits._zeros}. Combine with the fact\n+  \/\/ that ~ is a strictly decreasing function, if new_hi is the largest value\n+  \/\/ not larger than hi that satisfies {bits._zeros, bits._ones}, then ~new_hi\n+  \/\/ is the smallest value not smaller than ~hi that satisfies\n+  \/\/ {bits._ones, bits._zeros}\n+  U new_hi = ~adjust_lo(~bounds._hi, {bits._ones, bits._zeros});\n+  if (new_hi > bounds._hi) {\n+    return AdjustResult<RangeInt<U>>::make_empty();\n+  }\n+\n+  bool progress = (new_lo != bounds._lo) || (new_hi != bounds._hi);\n+  bool present = new_lo <= new_hi;\n+  return {progress, present, {new_lo, new_hi}};\n+}\n+\n+\/\/ Try to tighten the known bit constraints from the bound information by\n+\/\/ extracting the common prefix of lo and hi and combining with the current\n+\/\/ bit constraints\n+\/\/ E.g: lo = 010011\n+\/\/      hi = 010100,\n+\/\/ then all values in [lo, hi] would be\n+\/\/           010***\n+template <class U>\n+static AdjustResult<KnownBits<U>>\n+adjust_bits_from_bounds(const KnownBits<U>& bits, const RangeInt<U>& bounds) {\n+  \/\/ Find the mask to filter the common prefix, all values between bounds._lo\n+  \/\/ and bounds._hi should share this common prefix in terms of bits\n+  U mismatch = bounds._lo ^ bounds._hi;\n+  \/\/ Find the first mismatch, all bits before it is the same in bounds._lo and\n+  \/\/ bounds._hi\n+  U match_mask = mismatch == U(0) ? std::numeric_limits<U>::max()\n+                                  : ~(std::numeric_limits<U>::max() >> count_leading_zeros(mismatch));\n+  \/\/ match_mask & bounds._lo is the common prefix, extract zeros and ones from\n+  \/\/ it\n+  U new_zeros = bits._zeros | (match_mask & ~bounds._lo);\n+  U new_ones = bits._ones | (match_mask & bounds._lo);\n+  bool progress = (new_zeros != bits._zeros) || (new_ones != bits._ones);\n+  bool present = ((new_zeros & new_ones) == U(0));\n+  return {progress, present, {new_zeros, new_ones}};\n+}\n+\n+\/\/ Try to tighten both the bounds and the bits at the same time.\n+\/\/ Iteratively tighten one using the other until no progress is made.\n+\/\/ This function converges because at each iteration, some bits that are unknown\n+\/\/ are made known. As there are at most 64 bits, the number of iterations should\n+\/\/ not be larger than 64.\n+\/\/ This function is called simple because it deals with a simple intervals (see\n+\/\/ TypeInt at type.hpp).\n+template <class U>\n+static SimpleCanonicalResult<U>\n+canonicalize_constraints_simple(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n+  AdjustResult<KnownBits<U>> canonicalized_bits = adjust_bits_from_bounds(bits, bounds);\n+  if (canonicalized_bits.empty()) {\n+    return SimpleCanonicalResult<U>::make_empty();\n+  }\n+  AdjustResult<RangeInt<U>> canonicalized_bounds{true, true, bounds};\n+  \/\/ Since bits are derived from bounds in the previous iteration and vice\n+  \/\/ versa, if one does not show progress, the other will also not show\n+  \/\/ progress, so we terminate early\n+  while (true) {\n+    canonicalized_bounds = adjust_bounds_from_bits(canonicalized_bounds._result, canonicalized_bits._result);\n+    if (!canonicalized_bounds._progress || canonicalized_bounds.empty()) {\n+      return SimpleCanonicalResult<U>(canonicalized_bounds._present, canonicalized_bounds._result, canonicalized_bits._result);\n+    }\n+    canonicalized_bits = adjust_bits_from_bounds(canonicalized_bits._result, canonicalized_bounds._result);\n+    if (!canonicalized_bits._progress || canonicalized_bits.empty()) {\n+      return SimpleCanonicalResult<U>(canonicalized_bits._present, canonicalized_bounds._result, canonicalized_bits._result);\n+    }\n+  }\n+}\n+\n+\/\/ Tighten all constraints of a TypeIntPrototype to its canonical form.\n+\/\/ i.e the result represents the same set as the input, each bound belongs to\n+\/\/ the set and for each bit position that is not constrained, there exists 2\n+\/\/ values with the bit value at that position being set and unset, respectively,\n+\/\/ such that both belong to the set represented by the constraints.\n+template <class S, class U>\n+typename TypeIntPrototype<S, U>::CanonicalizedTypeIntPrototype\n+TypeIntPrototype<S, U>::canonicalize_constraints() const {\n+  RangeInt<S> srange = _srange;\n+  RangeInt<U> urange = _urange;\n+  \/\/ Trivial contradictions\n+  if (srange._lo > srange._hi ||\n+      urange._lo > urange._hi ||\n+      (_bits._zeros & _bits._ones) != U(0)) {\n+    return CanonicalizedTypeIntPrototype::make_empty();\n+  }\n+\n+  \/\/ Trivially canonicalize the bounds so that srange._lo and urange._hi are\n+  \/\/ both < 0 or >= 0. The same for srange._hi and urange._ulo. See TypeInt for\n+  \/\/ detailed explanation.\n+  if (S(urange._lo) > S(urange._hi)) {\n+    \/\/ This means that S(urange._lo) >= 0 and S(urange._hi) < 0\n+    if (S(urange._hi) < srange._lo) {\n+      \/\/ This means that there should be no element in the interval\n+      \/\/ [min_S, S(urange._hi)], tighten urange._hi to max_S\n+      urange._hi = U(std::numeric_limits<S>::max());\n+    } else if (S(urange._lo) > srange._hi) {\n+      \/\/ This means that there should be no element in the interval\n+      \/\/ [S(urange._lo), max_S], tighten urange._lo to min_S\n+      urange._lo = U(std::numeric_limits<S>::min());\n+    }\n+  }\n+\n+  \/\/ Now [srange._lo, jint(urange._hi)] and [jint(urange._lo), srange._hi] are\n+  \/\/ both simple intervals (as defined in TypeInt at type.hpp), we process them\n+  \/\/ separately and combine the results\n+  if (S(urange._lo) <= S(urange._hi)) {\n+    \/\/ The 2 simple intervals should be tightened to the same result\n+    urange._lo = U(MAX2(S(urange._lo), srange._lo));\n+    urange._hi = U(MIN2(S(urange._hi), srange._hi));\n+    if (urange._lo > urange._hi || S(urange._lo) > S(urange._hi)) {\n+      return CanonicalizedTypeIntPrototype::make_empty();\n+    }\n+\n+    auto type = canonicalize_constraints_simple(urange, _bits);\n+    return {type._present, {{S(type._bounds._lo), S(type._bounds._hi)},\n+                            type._bounds, type._bits}};\n+  }\n+\n+  \/\/ The 2 simple intervals can be tightened into 2 separate results\n+  auto neg_type = canonicalize_constraints_simple({U(srange._lo), urange._hi}, _bits);\n+  auto pos_type = canonicalize_constraints_simple({urange._lo, U(srange._hi)}, _bits);\n+\n+  if (neg_type.empty() && pos_type.empty()) {\n+    return CanonicalizedTypeIntPrototype::make_empty();\n+  } else if (neg_type.empty()) {\n+    return {true, {{S(pos_type._bounds._lo), S(pos_type._bounds._hi)},\n+                   pos_type._bounds, pos_type._bits}};\n+  } else if (pos_type.empty()) {\n+    return {true, {{S(neg_type._bounds._lo), S(neg_type._bounds._hi)},\n+                   neg_type._bounds, neg_type._bits}};\n+  } else {\n+    return {true, {{S(neg_type._bounds._lo), S(pos_type._bounds._hi)},\n+                   {pos_type._bounds._lo, neg_type._bounds._hi},\n+                   {neg_type._bits._zeros & pos_type._bits._zeros, neg_type._bits._ones & pos_type._bits._ones}}};\n+  }\n+}\n+\n+template <class S, class U>\n+int TypeIntPrototype<S, U>::normalize_widen(int widen) const {\n+  \/\/ Certain normalizations keep us sane when comparing types.\n+  \/\/ The 'SMALL_TYPEINT_THRESHOLD' covers constants and also CC and its relatives.\n+  if (TypeIntHelper::cardinality_from_bounds(_srange, _urange) <= U(SMALL_TYPEINT_THRESHOLD)) {\n+    return Type::WidenMin;\n+  }\n+  if (_srange._lo == std::numeric_limits<S>::min() && _srange._hi == std::numeric_limits<S>::max() &&\n+      _urange._lo == std::numeric_limits<U>::min() && _urange._hi == std::numeric_limits<U>::max() &&\n+      _bits._zeros == U(0) && _bits._ones == U(0)) {\n+    \/\/ bottom type\n+    return Type::WidenMax;\n+  }\n+  return widen;\n+}\n+\n+#ifdef ASSERT\n+template <class S, class U>\n+bool TypeIntPrototype<S, U>::contains(S v) const {\n+  U u(v);\n+  return v >= _srange._lo && v <= _srange._hi && u >= _urange._lo && u <= _urange._hi && _bits.is_satisfied_by(u);\n+}\n+\n+\/\/ Verify that this set representation is canonical\n+template <class S, class U>\n+void TypeIntPrototype<S, U>::verify_constraints() const {\n+  \/\/ Assert that the bounds cannot be further tightened\n+  assert(contains(_srange._lo) && contains(_srange._hi) &&\n+         contains(S(_urange._lo)) && contains(S(_urange._hi)), \"\");\n+\n+  \/\/ Assert that the bits cannot be further tightened\n+  if (U(_srange._lo) == _urange._lo) {\n+    assert(!adjust_bits_from_bounds(_bits, _urange)._progress, \"\");\n+  } else {\n+    RangeInt<U> neg_range{U(_srange._lo), _urange._hi};\n+    auto neg_bits = adjust_bits_from_bounds(_bits, neg_range);\n+    assert(neg_bits._present, \"\");\n+    assert(!adjust_bounds_from_bits(neg_range, neg_bits._result)._progress, \"\");\n+\n+    RangeInt<U> pos_range{_urange._lo, U(_srange._hi)};\n+    auto pos_bits = adjust_bits_from_bounds(_bits, pos_range);\n+    assert(pos_bits._present, \"\");\n+    assert(!adjust_bounds_from_bits(pos_range, pos_bits._result)._progress, \"\");\n+\n+    assert((neg_bits._result._zeros & pos_bits._result._zeros) == _bits._zeros &&\n+           (neg_bits._result._ones & pos_bits._result._ones) == _bits._ones, \"\");\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+template class TypeIntPrototype<jint, juint>;\n+template class TypeIntPrototype<jlong, julong>;\n+template class TypeIntPrototype<intn_t<1>, uintn_t<1>>;\n+template class TypeIntPrototype<intn_t<2>, uintn_t<2>>;\n+template class TypeIntPrototype<intn_t<3>, uintn_t<3>>;\n+template class TypeIntPrototype<intn_t<4>, uintn_t<4>>;\n+\n+\/\/ Compute the meet of 2 types, when dual is true, we are actually computing the\n+\/\/ join.\n+template <class CT, class S, class U>\n+const Type* TypeIntHelper::int_type_xmeet(const CT* i1, const Type* t2, make_type_t<S, U> make, bool dual) {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if (i1 == t2 || t2 == Type::TOP) {\n+    return i1;\n+  }\n+  const CT* i2 = t2->try_cast<CT>();\n+  if (i2 != nullptr) {\n+    if (!dual) {\n+    \/\/ meet\n+      return make(TypeIntPrototype<S, U>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n+                                         {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n+                                         {i1->_bits._zeros & i2->_bits._zeros, i1->_bits._ones & i2->_bits._ones}},\n+                  MAX2(i1->_widen, i2->_widen), false);\n+    }\n+    \/\/ join\n+    return make(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n+                                       {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n+                                       {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n+                MIN2(i1->_widen, i2->_widen), true);\n+  }\n+\n+  assert(t2->base() != i1->base(), \"\");\n+  switch (t2->base()) {          \/\/ Switch on original type\n+  case Type::AnyPtr:                  \/\/ Mixing with oops happens when javac\n+  case Type::RawPtr:                  \/\/ reuses local variables\n+  case Type::OopPtr:\n+  case Type::InstPtr:\n+  case Type::AryPtr:\n+  case Type::MetadataPtr:\n+  case Type::KlassPtr:\n+  case Type::InstKlassPtr:\n+  case Type::AryKlassPtr:\n+  case Type::NarrowOop:\n+  case Type::NarrowKlass:\n+  case Type::Int:\n+  case Type::Long:\n+  case Type::HalfFloatTop:\n+  case Type::HalfFloatCon:\n+  case Type::HalfFloatBot:\n+  case Type::FloatTop:\n+  case Type::FloatCon:\n+  case Type::FloatBot:\n+  case Type::DoubleTop:\n+  case Type::DoubleCon:\n+  case Type::DoubleBot:\n+  case Type::Bottom:                  \/\/ Ye Olde Default\n+    return Type::BOTTOM;\n+  default:                      \/\/ All else is a mistake\n+    i1->typerr(t2);\n+    return nullptr;\n+  }\n+}\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeInt* i1, const Type* t2,\n+                                                   const Type* (*make)(const TypeIntPrototype<jint, juint>&, int, bool), bool dual);\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeLong* i1, const Type* t2,\n+                                                   const Type* (*make)(const TypeIntPrototype<jlong, julong>&, int, bool), bool dual);\n+\n+\/\/ Called in PhiNode::Value during CCP, monotically widen the value set, do so rigorously\n+\/\/ first, after WidenMax attempts, if the type has still not converged we speed up the\n+\/\/ convergence by abandoning the bounds\n+template <class CT>\n+const Type* TypeIntHelper::int_type_widen(const CT* new_type, const CT* old_type, const CT* limit_type) {\n+  using S = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+\n+  if (old_type == nullptr) {\n+    return new_type;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no widening\n+  if (int_type_is_equal(new_type, old_type)) {\n+    return old_type;\n+  }\n+\n+  \/\/ If old guy contains new, then we probably widened too far & dropped to\n+  \/\/ bottom. Return the wider fellow.\n+  if (int_type_is_subset(old_type, new_type)) {\n+    return old_type;\n+  }\n+\n+  \/\/ Neither contains each other, weird?\n+  if (!int_type_is_subset(new_type, old_type)) {\n+    return CT::TYPE_DOMAIN;\n+  }\n+\n+  \/\/ If old guy was a constant, do not bother\n+  if (old_type->singleton()) {\n+    return new_type;\n+  }\n+\n+  \/\/ If new guy contains old, then we widened\n+  \/\/ If new guy is already wider than old, no widening\n+  if (new_type->_widen > old_type->_widen) {\n+    return new_type;\n+  }\n+\n+  if (new_type->_widen < Type::WidenMax) {\n+    \/\/ Returned widened new guy\n+    TypeIntPrototype<S, U> prototype{{new_type->_lo, new_type->_hi}, {new_type->_ulo, new_type->_uhi}, new_type->_bits};\n+    return CT::try_make(prototype, new_type->_widen + 1);\n+  }\n+\n+  \/\/ Speed up the convergence by abandoning the bounds, there are only a couple of bits so\n+  \/\/ they converge fast\n+  S min = std::numeric_limits<S>::min();\n+  S max = std::numeric_limits<S>::max();\n+  U umin = std::numeric_limits<U>::min();\n+  U umax = std::numeric_limits<U>::max();\n+  U zeros = new_type->_bits._zeros;\n+  U ones = new_type->_bits._ones;\n+  if (limit_type != nullptr) {\n+    min = limit_type->_lo;\n+    max = limit_type->_hi;\n+    umin = limit_type->_ulo;\n+    umax = limit_type->_uhi;\n+    zeros |= limit_type->_bits._zeros;\n+    ones |= limit_type->_bits._ones;\n+  }\n+  TypeIntPrototype<S, U> prototype{{min, max}, {umin, umax}, {zeros, ones}};\n+  return CT::try_make(prototype, Type::WidenMax);\n+}\n+template const Type* TypeIntHelper::int_type_widen(const TypeInt* new_type, const TypeInt* old_type, const TypeInt* limit_type);\n+template const Type* TypeIntHelper::int_type_widen(const TypeLong* new_type, const TypeLong* old_type, const TypeLong* limit_type);\n+\n+\/\/ Called by PhiNode::Value during GVN, monotonically narrow the value set, only\n+\/\/ narrow if the bits change or if the bounds are tightened enough to avoid\n+\/\/ slow convergence\n+template <class CT>\n+const Type* TypeIntHelper::int_type_narrow(const CT* new_type, const CT* old_type) {\n+  using S = decltype(CT::_lo);\n+  using U = decltype(CT::_ulo);\n+\n+  if (new_type->singleton() || old_type == nullptr) {\n+    return new_type;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no narrowing\n+  if (int_type_is_equal(new_type, old_type)) {\n+    return old_type;\n+  }\n+\n+  \/\/ If old guy was maximum range, allow the narrowing\n+  if (int_type_is_equal(old_type, CT::TYPE_DOMAIN)) {\n+    return new_type;\n+  }\n+\n+  \/\/ Doesn't narrow; pretty weird\n+  if (!int_type_is_subset(old_type, new_type)) {\n+    return new_type;\n+  }\n+\n+  \/\/ Bits change\n+  if (old_type->_bits._zeros != new_type->_bits._zeros || old_type->_bits._ones != new_type->_bits._ones) {\n+    return new_type;\n+  }\n+\n+  \/\/ Only narrow if the range shrinks a lot\n+  U oc = cardinality_from_bounds(RangeInt<S>{old_type->_lo, old_type->_hi},\n+                                 RangeInt<U>{old_type->_ulo, old_type->_uhi});\n+  U nc = cardinality_from_bounds(RangeInt<S>{new_type->_lo, new_type->_hi},\n+                                 RangeInt<U>{new_type->_ulo, new_type->_uhi});\n+  return (nc > (oc >> 1) + (SMALL_TYPEINT_THRESHOLD * 2)) ? old_type : new_type;\n+}\n+template const Type* TypeIntHelper::int_type_narrow(const TypeInt* new_type, const TypeInt* old_type);\n+template const Type* TypeIntHelper::int_type_narrow(const TypeLong* new_type, const TypeLong* old_type);\n+\n+\n+#ifndef PRODUCT\n+template <class T>\n+static const char* int_name_near(T origin, const char* xname, char* buf, size_t buf_size, T n) {\n+  if (n < origin) {\n+    if (n <= origin - 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s-\" INT32_FORMAT, xname, jint(origin - n));\n+  } else if (n > origin) {\n+    if (n >= origin + 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s+\" INT32_FORMAT, xname, jint(n - origin));\n+  } else {\n+    return xname;\n+  }\n+  return buf;\n+}\n+\n+const char* TypeIntHelper::intname(char* buf, size_t buf_size, jint n) {\n+  const char* str = int_name_near<jint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jint>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n+  return buf;\n+}\n+\n+const char* TypeIntHelper::uintname(char* buf, size_t buf_size, juint n) {\n+  const char* str = int_name_near<juint>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<juint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, UINT32_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n+const char* TypeIntHelper::longname(char* buf, size_t buf_size, jlong n) {\n+  const char* str = int_name_near<jlong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(min_jlong, \"minlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n+  return buf;\n+}\n+\n+const char* TypeIntHelper::ulongname(char* buf, size_t buf_size, julong n) {\n+  const char* str = int_name_near<julong>(max_julong, \"maxulong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<julong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<julong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<julong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JULONG_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n+template <class U>\n+const char* TypeIntHelper::bitname(char* buf, size_t buf_size, U zeros, U ones) {\n+  constexpr juint W = sizeof(U) * 8;\n+\n+  if (buf_size < W + 1) {\n+    return \"#####\";\n+  }\n+\n+  for (juint i = 0; i < W; i++) {\n+    U mask = U(1) << (W - 1 - i);\n+    if ((zeros & mask) != 0) {\n+      buf[i] = '0';\n+    } else if ((ones & mask) != 0) {\n+      buf[i] = '1';\n+    } else {\n+      buf[i] = '*';\n+    }\n+  }\n+  buf[W] = 0;\n+  return buf;\n+}\n+template const char* TypeIntHelper::bitname(char* buf, size_t buf_size, juint zeros, juint ones);\n+template const char* TypeIntHelper::bitname(char* buf, size_t buf_size, julong zeros, julong ones);\n+\n+void TypeIntHelper::int_type_dump(const TypeInt* t, outputStream* st, bool verbose) {\n+  char buf1[40], buf2[40], buf3[40], buf4[40], buf5[40];\n+  if (int_type_is_equal(t, TypeInt::INT)) {\n+    st->print(\"int\");\n+  } else if (t->is_con()) {\n+    st->print(\"int:%s\", intname(buf1, sizeof(buf1), t->get_con()));\n+  } else if (int_type_is_equal(t, TypeInt::BOOL)) {\n+    st->print(\"bool\");\n+  } else if (int_type_is_equal(t, TypeInt::BYTE)) {\n+    st->print(\"byte\");\n+  } else if (int_type_is_equal(t, TypeInt::CHAR)) {\n+    st->print(\"char\");\n+  } else if (int_type_is_equal(t, TypeInt::SHORT)) {\n+    st->print(\"short\");\n+  } else {\n+    if (verbose) {\n+      st->print(\"int:%s..%s, %s..%s, %s\",\n+                intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi),\n+                uintname(buf3, sizeof(buf3), t->_ulo), uintname(buf4, sizeof(buf4), t->_uhi),\n+                bitname(buf5, sizeof(buf5), t->_bits._zeros, t->_bits._ones));\n+    } else {\n+      if (t->_lo >= 0) {\n+        if (t->_hi == max_jint) {\n+          st->print(\"int:>=%s\", intname(buf1, sizeof(buf1), t->_lo));\n+        } else {\n+          st->print(\"int:%s..%s\", intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else if (t->_hi < 0) {\n+        if (t->_lo == min_jint) {\n+          st->print(\"int:<=%s\", intname(buf1, sizeof(buf1), t->_hi));\n+        } else {\n+          st->print(\"int:%s..%s\", intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else {\n+        st->print(\"int:%s..%s, %s..%s\",\n+                  intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi),\n+                  uintname(buf3, sizeof(buf3), t->_ulo), uintname(buf4, sizeof(buf4), t->_uhi));\n+      }\n+\n+    }\n+  }\n+\n+  if (t->_widen > 0 && t != TypeInt::INT) {\n+    st->print(\", widen: %d\", t->_widen);\n+  }\n+}\n+\n+void TypeIntHelper::int_type_dump(const TypeLong* t, outputStream* st, bool verbose) {\n+  char buf1[80], buf2[80], buf3[80], buf4[80], buf5[80];\n+  if (int_type_is_equal(t, TypeLong::LONG)) {\n+    st->print(\"long\");\n+  } else if (t->is_con()) {\n+    st->print(\"long:%s\", longname(buf1, sizeof(buf1), t->get_con()));\n+  } else {\n+    if (verbose) {\n+      st->print(\"long:%s..%s ^ %s..%s, bits:%s\",\n+                longname(buf1, sizeof(buf1), t->_lo), longname(buf2,sizeof(buf2), t-> _hi),\n+                ulongname(buf3, sizeof(buf3), t->_ulo), ulongname(buf4, sizeof(buf4), t->_uhi),\n+                bitname(buf5, sizeof(buf5), t->_bits._zeros, t->_bits._ones));\n+    } else {\n+      if (t->_lo >= 0) {\n+        if (t->_hi == max_jint) {\n+          st->print(\"long:>=%s\", longname(buf1, sizeof(buf1), t->_lo));\n+        } else {\n+          st->print(\"long:%s..%s\", longname(buf1, sizeof(buf1), t->_lo), longname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else if (t->_hi < 0) {\n+        if (t->_lo == min_jint) {\n+          st->print(\"long:<=%s\", longname(buf1, sizeof(buf1), t->_hi));\n+        } else {\n+          st->print(\"long:%s..%s\", longname(buf1, sizeof(buf1), t->_lo), longname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else {\n+        st->print(\"long:%s..%s ^ %s..%s\",\n+                  longname(buf1, sizeof(buf1), t->_lo), longname(buf2,sizeof(buf2), t-> _hi),\n+                  ulongname(buf3, sizeof(buf3), t->_ulo), ulongname(buf4, sizeof(buf4), t->_uhi));\n+      }\n+    }\n+  }\n+\n+  if (t->_widen > 0 && t != TypeLong::LONG) {\n+    st->print(\", widen: %d\", t->_widen);\n+  }\n+}\n+#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":929,"deletions":0,"binary":false,"changes":929,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_RANGEINFERENCE_HPP\n+#define SHARE_OPTO_RANGEINFERENCE_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include <type_traits>\n+\n+class outputStream;\n+class Type;\n+class TypeInt;\n+class TypeLong;\n+\n+\/\/ A simple range in the signed or unsigned domain\n+template <class T>\n+class RangeInt {\n+public:\n+  T _lo;\n+  T _hi;\n+};\n+\n+\/**\n+ * Bits that are known to be 0 or 1. A value v satisfies this constraint iff\n+ * (v & zeros) == 0 && (v & ones) == ones. I.e, any bit that is 1 in zeros must\n+ * be 0 in v, and any bit that is 1 in ones must be 1 in v.\n+ *\n+ * I.e, for each bit position from 0 to sizeof(U) - 1, the corresponding bits\n+ * of zeros, ones and the allowed bit in v must follow:\n+ *\n+ * zeros    ones    allowed bits\n+ * 0        0       0 or 1\n+ * 1        0       0\n+ * 0        1       1\n+ * 1        1       none (impossible state)\n+ *\n+ * E.g:\n+ * zeros: 00110100\n+ * ones:  10000010\n+ * Then:  10001010 would satisfy the bit constraints\n+ * while: 10011000 would not since the bit at the 4th position violates\n+ * zeros and the bit at the 7th position violates ones\n+ *\n+ * A KnownBits is sane if there is no position at which a bit must be both set\n+ * and unset at the same time. That is (zeros & ones) == 0.\n+ *\/\n+template <class U>\n+class KnownBits {\n+  static_assert(U(-1) > U(0), \"bit info should be unsigned\");\n+\n+public:\n+  U _zeros;\n+  U _ones;\n+\n+  bool is_satisfied_by(U v) const {\n+    return (v & _zeros) == U(0) && (v & _ones) == _ones;\n+  }\n+};\n+\n+\/\/ All the information needed to construct a TypeInt\/TypeLong, the constraints\n+\/\/ here may be arbitrary and need to be canonicalized to construct a\n+\/\/ TypeInt\/TypeLong\n+template <class S, class U>\n+class TypeIntPrototype {\n+public:\n+  static_assert(S(-1) < S(0), \"\");\n+  static_assert(U(-1) > U(0), \"\");\n+  static_assert(sizeof(S) == sizeof(U), \"\");\n+\n+  RangeInt<S> _srange;\n+  RangeInt<U> _urange;\n+  KnownBits<U> _bits;\n+\n+private:\n+  friend class TypeInt;\n+  friend class TypeLong;\n+\n+  template <class T1, class T2>\n+  friend void test_canonicalize_constraints_exhaustive();\n+\n+  template <class T1, class T2>\n+  friend void test_canonicalize_constraints_simple();\n+\n+  template <class T1, class T2>\n+  friend void test_canonicalize_constraints_random();\n+\n+  \/\/ A canonicalized version of a TypeIntPrototype, if the prototype represents\n+  \/\/ an empty type, _present is false, otherwise, _data is canonical\n+  class CanonicalizedTypeIntPrototype {\n+  public:\n+    bool _present; \/\/ whether this is an empty set\n+    TypeIntPrototype<S, U> _data;\n+\n+    bool empty() const {\n+      return !_present;\n+    }\n+\n+    static CanonicalizedTypeIntPrototype make_empty() {\n+      return {false, {}};\n+    }\n+  };\n+\n+  CanonicalizedTypeIntPrototype canonicalize_constraints() const;\n+  int normalize_widen(int w) const;\n+#ifdef ASSERT\n+  bool contains(S v) const;\n+  void verify_constraints() const;\n+#endif \/\/ ASSERT\n+};\n+\n+\/\/ Various helper functions for TypeInt\/TypeLong operations\n+class TypeIntHelper {\n+public:\n+  \/\/ Calculate the cardinality of a TypeInt\/TypeLong ignoring the bits\n+  \/\/ constraints, the return value is the cardinality minus 1 to not overflow\n+  \/\/ with the bottom type\n+  template <class S, class U>\n+  static U cardinality_from_bounds(const RangeInt<S>& srange, const RangeInt<U>& urange) {\n+    static_assert(S(-1) < S(0), \"\");\n+    static_assert(U(-1) > U(0), \"\");\n+    static_assert(sizeof(S) == sizeof(U), \"\");\n+\n+    if (U(srange._lo) == urange._lo) {\n+      \/\/ srange is the same as urange\n+      assert(U(srange._hi) == urange._hi, \"\");\n+      \/\/ The cardinality is (hi - lo + 1), we return the result minus 1\n+      return urange._hi - urange._lo;\n+    }\n+\n+    \/\/ srange intersects with urange in 2 intervals [srange._lo, urange._hi]\n+    \/\/ and [urange._lo, srange._hi]\n+    \/\/ The cardinality is (uhi - lo + 1) + (hi - ulo + 1), we return the result\n+    \/\/ minus 1\n+    return (urange._hi - U(srange._lo)) + (U(srange._hi) - urange._lo) + U(1);\n+  }\n+\n+  template <class S, class U>\n+  using make_type_t = const Type* (*)(const TypeIntPrototype<S, U>&, int, bool);\n+\n+  template <class CT, class S, class U>\n+  static const Type* int_type_xmeet(const CT* i1, const Type* t2, make_type_t<S, U> make, bool dual);\n+\n+  template <class CT>\n+  static bool int_type_is_equal(const CT* t1, const CT* t2) {\n+    return t1->_lo == t2->_lo && t1->_hi == t2->_hi &&\n+           t1->_ulo == t2->_ulo && t1->_uhi == t2->_uhi &&\n+           t1->_bits._zeros == t2->_bits._zeros && t1->_bits._ones == t2->_bits._ones;\n+  }\n+\n+  template <class CT>\n+  static bool int_type_is_subset(const CT* super, const CT* sub) {\n+    return super->_lo <= sub->_lo && super->_hi >= sub->_hi &&\n+           super->_ulo <= sub->_ulo && super->_uhi >= sub->_uhi &&\n+           \/\/ All bits that are known in super must also be known to be the same\n+           \/\/ value in sub, &~ (and not) is the same as a set subtraction on bit\n+           \/\/ sets\n+           (super->_bits._zeros &~ sub->_bits._zeros) == 0 && (super->_bits._ones &~ sub->_bits._ones) == 0;\n+  }\n+\n+  template <class CT>\n+  static const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt);\n+\n+  template <class CT>\n+  static const Type* int_type_narrow(const CT* nt, const CT* ot);\n+\n+#ifndef PRODUCT\n+  static const char* intname(char* buf, size_t buf_size, jint n);\n+  static const char* uintname(char* buf, size_t buf_size, juint n);\n+  static const char* longname(char* buf, size_t buf_size, jlong n);\n+  static const char* ulongname(char* buf, size_t buf_size, julong n);\n+\n+  template <class U>\n+  static const char* bitname(char* buf, size_t buf_size, U zeros, U ones);\n+\n+  static void int_type_dump(const TypeInt* t, outputStream* st, bool verbose);\n+  static void int_type_dump(const TypeLong* t, outputStream* st, bool verbose);\n+#endif \/\/ PRODUCT\n+};\n+\n+#endif \/\/ SHARE_OPTO_RANGEINFERENCE_HPP\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -431,1 +432,0 @@\n-#define SMALLINT ((juint)3)  \/\/ a value too insignificant to consider widening\n@@ -490,19 +490,21 @@\n-  TypeInt::MINUS_1 = TypeInt::make(-1);  \/\/ -1\n-  TypeInt::ZERO    = TypeInt::make( 0);  \/\/  0\n-  TypeInt::ONE     = TypeInt::make( 1);  \/\/  1\n-  TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n-  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n-  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n-  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n-  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n-  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);\n-  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n-  TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); \/\/ Bytes\n-  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); \/\/ Unsigned Bytes\n-  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); \/\/ Java chars\n-  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); \/\/ Java shorts\n-  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); \/\/ Non-neg values\n-  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); \/\/ Positive values\n-  TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); \/\/ 32-bit integers\n-  TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); \/\/ symmetric range\n-  TypeInt::TYPE_DOMAIN  = TypeInt::INT;\n+  TypeInt::MINUS_1  = TypeInt::make(-1);  \/\/ -1\n+  TypeInt::ZERO     = TypeInt::make( 0);  \/\/  0\n+  TypeInt::ONE      = TypeInt::make( 1);  \/\/  1\n+  TypeInt::BOOL     = TypeInt::make( 0, 1, WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n+  TypeInt::CC       = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n+  TypeInt::CC_LT    = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n+  TypeInt::CC_GT    = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n+  TypeInt::CC_EQ    = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n+  TypeInt::CC_NE    = TypeInt::try_make(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n+  TypeInt::CC_LE    = TypeInt::make(-1, 0, WidenMin);\n+  TypeInt::CC_GE    = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n+  TypeInt::BYTE     = TypeInt::make(-128, 127,     WidenMin); \/\/ Bytes\n+  TypeInt::UBYTE    = TypeInt::make(0, 255,        WidenMin); \/\/ Unsigned Bytes\n+  TypeInt::CHAR     = TypeInt::make(0, 65535,      WidenMin); \/\/ Java chars\n+  TypeInt::SHORT    = TypeInt::make(-32768, 32767, WidenMin); \/\/ Java shorts\n+  TypeInt::NON_ZERO = TypeInt::try_make(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n+  TypeInt::POS      = TypeInt::make(0, max_jint,   WidenMin); \/\/ Non-neg values\n+  TypeInt::POS1     = TypeInt::make(1, max_jint,   WidenMin); \/\/ Positive values\n+  TypeInt::INT      = TypeInt::make(min_jint, max_jint, WidenMax); \/\/ 32-bit integers\n+  TypeInt::SYMINT   = TypeInt::make(-max_jint, max_jint, WidenMin); \/\/ symmetric range\n+  TypeInt::TYPE_DOMAIN = TypeInt::INT;\n@@ -510,1 +512,1 @@\n-  \/\/ a trinary (-1,0,+1) integer result AND as an efficient long\n+  \/\/ a trinary (-1, 0, +1) integer result AND as an efficient long\n@@ -512,16 +514,17 @@\n-  assert( TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n-  assert( (juint)(TypeInt::CC->_hi - TypeInt::CC->_lo) <= SMALLINT, \"CC is truly small\");\n-\n-  TypeLong::MAX = TypeLong::make(max_jlong);  \/\/ Long MAX\n-  TypeLong::MIN = TypeLong::make(min_jlong);  \/\/ Long MIN\n-  TypeLong::MINUS_1 = TypeLong::make(-1);        \/\/ -1\n-  TypeLong::ZERO    = TypeLong::make( 0);        \/\/  0\n-  TypeLong::ONE     = TypeLong::make( 1);        \/\/  1\n-  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); \/\/ Non-neg values\n-  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); \/\/ 64-bit integers\n-  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);\n-  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);\n-  TypeLong::TYPE_DOMAIN  = TypeLong::LONG;\n+  assert(TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n+\n+  TypeLong::MAX = TypeLong::make(max_jlong); \/\/ Long MAX\n+  TypeLong::MIN = TypeLong::make(min_jlong); \/\/ Long MIN\n+  TypeLong::MINUS_1  = TypeLong::make(-1);   \/\/ -1\n+  TypeLong::ZERO     = TypeLong::make( 0);   \/\/  0\n+  TypeLong::ONE      = TypeLong::make( 1);   \/\/  1\n+  TypeLong::NON_ZERO = TypeLong::try_make(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n+  TypeLong::POS      = TypeLong::make(0, max_jlong, WidenMin); \/\/ Non-neg values\n+  TypeLong::NEG      = TypeLong::make(min_jlong, -1, WidenMin);\n+  TypeLong::LONG     = TypeLong::make(min_jlong, max_jlong, WidenMax); \/\/ 64-bit integers\n+  TypeLong::INT      = TypeLong::make((jlong)min_jint, (jlong)max_jint,WidenMin);\n+  TypeLong::UINT     = TypeLong::make(0, (jlong)max_juint, WidenMin);\n+  TypeLong::TYPE_DOMAIN = TypeLong::LONG;\n@@ -1744,25 +1747,23 @@\n-const TypeInt *TypeInt::MAX;    \/\/ INT_MAX\n-const TypeInt *TypeInt::MIN;    \/\/ INT_MIN\n-const TypeInt *TypeInt::MINUS_1;\/\/ -1\n-const TypeInt *TypeInt::ZERO;   \/\/ 0\n-const TypeInt *TypeInt::ONE;    \/\/ 1\n-const TypeInt *TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n-const TypeInt *TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n-const TypeInt *TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n-const TypeInt *TypeInt::CC_GT;  \/\/ [1]   == ONE\n-const TypeInt *TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n-const TypeInt *TypeInt::CC_LE;  \/\/ [-1,0]\n-const TypeInt *TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n-const TypeInt *TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n-const TypeInt *TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n-const TypeInt *TypeInt::CHAR;   \/\/ Java chars, 0-65535\n-const TypeInt *TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n-const TypeInt *TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n-const TypeInt *TypeInt::POS1;   \/\/ Positive 32-bit integers\n-const TypeInt *TypeInt::INT;    \/\/ 32-bit integers\n-const TypeInt *TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-const TypeInt *TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-\/\/------------------------------TypeInt----------------------------------------\n-TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int, w), _lo(lo), _hi(hi) {\n-}\n+const TypeInt* TypeInt::MAX;    \/\/ INT_MAX\n+const TypeInt* TypeInt::MIN;    \/\/ INT_MIN\n+const TypeInt* TypeInt::MINUS_1;\/\/ -1\n+const TypeInt* TypeInt::ZERO;   \/\/ 0\n+const TypeInt* TypeInt::ONE;    \/\/ 1\n+const TypeInt* TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n+const TypeInt* TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n+const TypeInt* TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n+const TypeInt* TypeInt::CC_GT;  \/\/ [1]   == ONE\n+const TypeInt* TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n+const TypeInt* TypeInt::CC_NE;\n+const TypeInt* TypeInt::CC_LE;  \/\/ [-1,0]\n+const TypeInt* TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n+const TypeInt* TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n+const TypeInt* TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n+const TypeInt* TypeInt::CHAR;   \/\/ Java chars, 0-65535\n+const TypeInt* TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n+const TypeInt* TypeInt::NON_ZERO;\n+const TypeInt* TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n+const TypeInt* TypeInt::POS1;   \/\/ Positive 32-bit integers\n+const TypeInt* TypeInt::INT;    \/\/ 32-bit integers\n+const TypeInt* TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+const TypeInt* TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n@@ -1770,3 +1771,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeInt *TypeInt::make( jint lo ) {\n-  return (TypeInt*)(new TypeInt(lo,lo,WidenMin))->hashcons();\n+TypeInt::TypeInt(const TypeIntPrototype<jint, juint>& t, int widen, bool dual)\n+  : TypeInteger(Int, t.normalize_widen(widen), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -1775,9 +1777,4 @@\n-static int normalize_int_widen( jint lo, jint hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n-  if (lo <= hi) {\n-    if (((juint)hi - lo) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)hi - lo) >= max_juint) w = Type::WidenMax; \/\/ TypeInt::INT\n-  } else {\n-    if (((juint)lo - hi) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)lo - hi) >= max_juint) w = Type::WidenMin; \/\/ dual TypeInt::INT\n+const Type* TypeInt::try_make(const TypeIntPrototype<jint, juint>& t, int widen, bool dual) {\n+  auto canonicalized_t = t.canonicalize_constraints();\n+  if (canonicalized_t.empty()) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -1785,1 +1782,1 @@\n-  return w;\n+  return (new TypeInt(canonicalized_t._data, widen, dual))->hashcons()->is_int();\n@@ -1788,3 +1785,4 @@\n-const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {\n-  w = normalize_int_widen(lo, hi, w);\n-  return (TypeInt*)(new TypeInt(lo,hi,w))->hashcons();\n+const TypeInt* TypeInt::make(jint con) {\n+  juint ucon = con;\n+  return (new TypeInt(TypeIntPrototype<jint, juint>{{con, con}, {ucon, ucon}, {~ucon, ucon}},\n+                      WidenMin, false))->hashcons()->is_int();\n@@ -1793,44 +1791,3 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeInt::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeInt\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Long:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Int:                     \/\/ Int vs Int?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeInt *r = t->is_int();\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const TypeInt* TypeInt::make(jint lo, jint hi, int widen) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return try_make(TypeIntPrototype<jint, juint>{{lo, hi}, {0, max_juint}, {0, 0}}, widen)->is_int();\n@@ -1839,55 +1796,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeInt::xdual() const {\n-  int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeInt(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeInt::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Int ) return this;\n-  const TypeInt *ot = old->is_int();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      int max = max_jint;\n-      int min = min_jint;\n-      if (limit->isa_int()) {\n-        max = limit->is_int()->_hi;\n-        min = limit->is_int()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((juint)_lo - min) >= ((juint)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 31 bits:\n-          return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeInt::INT;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n-\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+const Type* TypeInt::try_make(const TypeIntPrototype<jint, juint>& t, int widen) {\n+  return try_make(t, widen, false);\n+}\n@@ -1895,3 +1800,3 @@\n-  \/\/fatal(\"Integer value range is not subset\");\n-  \/\/return this;\n-  return TypeInt::INT;\n+bool TypeInt::contains(jint i) const {\n+  juint u = i;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi && _bits.is_satisfied_by(u);\n@@ -1900,9 +1805,3 @@\n-\/\/------------------------------narrow---------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeInt::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeInt* ot = old->isa_int();\n-  if (ot == nullptr)  return this;\n-  jint olo = ot->_lo;\n-  jint ohi = ot->_hi;\n+bool TypeInt::contains(const TypeInt* t) const {\n+  return TypeIntHelper::int_type_is_subset(this, t);\n+}\n@@ -1910,2 +1809,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type* TypeInt::xmeet(const Type* t) const {\n+  return TypeIntHelper::int_type_xmeet(this, t, TypeInt::try_make, _is_dual);\n+}\n@@ -1913,2 +1813,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jint && ohi == max_jint)  return this;\n+const Type* TypeInt::xdual() const {\n+  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                     _widen, !_is_dual);\n+}\n@@ -1916,2 +1818,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeInt::widen(const Type* old, const Type* limit) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_widen(this, old->isa_int(), limit->isa_int());\n+}\n@@ -1919,8 +1823,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  juint nrange = (juint)_hi - _lo;\n-  juint orange = (juint)ohi - olo;\n-  if (nrange < max_juint - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeInt::narrow(const Type* old) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -1929,1 +1829,1 @@\n-  return this;\n+  return TypeIntHelper::int_type_narrow(this, old->isa_int());\n@@ -1933,1 +1833,2 @@\n-const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeInt::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -1935,1 +1836,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -1937,0 +1838,2 @@\n+  }\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -1940,1 +1843,2 @@\n-    ft = TypeInt::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeInt(TypeIntPrototype<jint, juint>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n+                        this->_widen, false))->hashcons();\n@@ -1947,3 +1851,3 @@\n-bool TypeInt::eq( const Type *t ) const {\n-  const TypeInt *r = t->is_int(); \/\/ Handy access\n-  return r->_lo == _lo && r->_hi == _hi && r->_widen == _widen;\n+bool TypeInt::eq(const Type* t) const {\n+  const TypeInt* r = t->is_int();\n+  return TypeIntHelper::int_type_is_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -1955,1 +1859,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Int;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Int;\n@@ -1964,43 +1869,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeInt\n-#ifndef PRODUCT\n-static const char* intname(char* buf, size_t buf_size, jint n) {\n-  if (n == min_jint)\n-    return \"min\";\n-  else if (n < min_jint + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" INT32_FORMAT, n - min_jint);\n-  else if (n == max_jint)\n-    return \"max\";\n-  else if (n > max_jint - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" INT32_FORMAT, max_jint - n);\n-  else\n-    os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[40], buf2[40];\n-  if (_lo == min_jint && _hi == max_jint)\n-    st->print(\"int\");\n-  else if (is_con())\n-    st->print(\"int:%s\", intname(buf, sizeof(buf), get_con()));\n-  else if (_lo == BOOL->_lo && _hi == BOOL->_hi)\n-    st->print(\"bool\");\n-  else if (_lo == BYTE->_lo && _hi == BYTE->_hi)\n-    st->print(\"byte\");\n-  else if (_lo == CHAR->_lo && _hi == CHAR->_hi)\n-    st->print(\"char\");\n-  else if (_lo == SHORT->_lo && _hi == SHORT->_hi)\n-    st->print(\"short\");\n-  else if (_hi == max_jint)\n-    st->print(\"int:>=%s\", intname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jint)\n-    st->print(\"int:<=%s\", intname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"int:%s..%s\", intname(buf, sizeof(buf), _lo), intname(buf2, sizeof(buf2), _hi));\n-\n-  if (_widen != 0 && this != TypeInt::INT)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -2011,1 +1873,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -2015,1 +1877,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -2020,14 +1882,12 @@\n-const TypeLong *TypeLong::MAX;\n-const TypeLong *TypeLong::MIN;\n-const TypeLong *TypeLong::MINUS_1;\/\/ -1\n-const TypeLong *TypeLong::ZERO; \/\/ 0\n-const TypeLong *TypeLong::ONE;  \/\/ 1\n-const TypeLong *TypeLong::POS;  \/\/ >=0\n-const TypeLong *TypeLong::LONG; \/\/ 64-bit integers\n-const TypeLong *TypeLong::INT;  \/\/ 32-bit subrange\n-const TypeLong *TypeLong::UINT; \/\/ 32-bit unsigned subrange\n-const TypeLong *TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n-\n-\/\/------------------------------TypeLong---------------------------------------\n-TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long, w), _lo(lo), _hi(hi) {\n-}\n+const TypeLong* TypeLong::MAX;\n+const TypeLong* TypeLong::MIN;\n+const TypeLong* TypeLong::MINUS_1;\/\/ -1\n+const TypeLong* TypeLong::ZERO; \/\/ 0\n+const TypeLong* TypeLong::ONE;  \/\/ 1\n+const TypeLong* TypeLong::NON_ZERO;\n+const TypeLong* TypeLong::POS;  \/\/ >=0\n+const TypeLong* TypeLong::NEG;\n+const TypeLong* TypeLong::LONG; \/\/ 64-bit integers\n+const TypeLong* TypeLong::INT;  \/\/ 32-bit subrange\n+const TypeLong* TypeLong::UINT; \/\/ 32-bit unsigned subrange\n+const TypeLong* TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -2035,3 +1895,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeLong *TypeLong::make( jlong lo ) {\n-  return (TypeLong*)(new TypeLong(lo,lo,WidenMin))->hashcons();\n+TypeLong::TypeLong(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual)\n+  : TypeInteger(Long, t.normalize_widen(widen), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -2040,9 +1901,4 @@\n-static int normalize_long_widen( jlong lo, jlong hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants.\n-  if (lo <= hi) {\n-    if (((julong)hi - lo) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)hi - lo) >= max_julong) w = Type::WidenMax; \/\/ TypeLong::LONG\n-  } else {\n-    if (((julong)lo - hi) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)lo - hi) >= max_julong) w = Type::WidenMin; \/\/ dual TypeLong::LONG\n+const Type* TypeLong::try_make(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual) {\n+  auto canonicalized_t = t.canonicalize_constraints();\n+  if (canonicalized_t.empty()) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -2050,1 +1906,1 @@\n-  return w;\n+  return (new TypeLong(canonicalized_t._data, widen, dual))->hashcons()->is_long();\n@@ -2053,3 +1909,4 @@\n-const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {\n-  w = normalize_long_widen(lo, hi, w);\n-  return (TypeLong*)(new TypeLong(lo,hi,w))->hashcons();\n+const TypeLong* TypeLong::make(jlong con) {\n+  julong ucon = con;\n+  return (new TypeLong(TypeIntPrototype<jlong, julong>{{con, con}, {ucon, ucon}, {~ucon, ucon}},\n+                       WidenMin, false))->hashcons()->is_long();\n@@ -2058,45 +1915,3 @@\n-\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeLong::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeLong\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Long:                    \/\/ Long vs Long?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeLong *r = t->is_long(); \/\/ Turn into a TypeLong\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const TypeLong* TypeLong::make(jlong lo, jlong hi, int widen) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return try_make(TypeIntPrototype<jlong, julong>{{lo, hi}, {0, max_julong}, {0, 0}}, widen)->is_long();\n@@ -2105,58 +1920,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeLong::xdual() const {\n-  int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeLong(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeLong::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Long ) return this;\n-  const TypeLong *ot = old->is_long();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      jlong max = max_jlong;\n-      jlong min = min_jlong;\n-      if (limit->isa_long()) {\n-        max = limit->is_long()->_hi;\n-        min = limit->is_long()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((julong)_lo - min) >= ((julong)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 32\/63 bits:\n-          if (max >= max_juint && _hi < max_juint)\n-            return make(_lo, max_juint, WidenMax);\n-          else\n-            return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeLong::LONG;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n-\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+const Type* TypeLong::try_make(const TypeIntPrototype<jlong, julong>& t, int widen) {\n+  return try_make(t, widen, false);\n+}\n@@ -2164,3 +1924,3 @@\n-  \/\/  fatal(\"Long value range is not subset\");\n-  \/\/ return this;\n-  return TypeLong::LONG;\n+bool TypeLong::contains(jlong i) const {\n+  julong u = i;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi && _bits.is_satisfied_by(u);\n@@ -2169,9 +1929,3 @@\n-\/\/------------------------------narrow----------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeLong::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeLong* ot = old->isa_long();\n-  if (ot == nullptr)  return this;\n-  jlong olo = ot->_lo;\n-  jlong ohi = ot->_hi;\n+bool TypeLong::contains(const TypeLong* t) const {\n+  return TypeIntHelper::int_type_is_subset(this, t);\n+}\n@@ -2179,2 +1933,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type *TypeLong::xmeet(const Type* t) const {\n+  return TypeIntHelper::int_type_xmeet(this, t, TypeLong::try_make, _is_dual);\n+}\n@@ -2182,2 +1937,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jlong && ohi == max_jlong)  return this;\n+const Type* TypeLong::xdual() const {\n+  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                      _widen, !_is_dual);\n+}\n@@ -2185,2 +1942,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeLong::widen(const Type* old, const Type* limit) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_widen(this, old->isa_long(), limit->isa_long());\n+}\n@@ -2188,8 +1947,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  julong nrange = (julong)_hi - _lo;\n-  julong orange = (julong)ohi - olo;\n-  if (nrange < max_julong - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeLong::narrow(const Type* old) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -2198,1 +1953,1 @@\n-  return this;\n+  return TypeIntHelper::int_type_narrow(this, old->isa_long());\n@@ -2202,1 +1957,2 @@\n-const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeLong::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -2204,1 +1960,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -2206,0 +1962,2 @@\n+  }\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -2209,1 +1967,2 @@\n-    ft = TypeLong::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeLong(TypeIntPrototype<jlong, julong>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n+                         this->_widen, false))->hashcons();\n@@ -2216,3 +1975,3 @@\n-bool TypeLong::eq( const Type *t ) const {\n-  const TypeLong *r = t->is_long(); \/\/ Handy access\n-  return r->_lo == _lo &&  r->_hi == _hi  && r->_widen == _widen;\n+bool TypeLong::eq(const Type* t) const {\n+  const TypeLong* r = t->is_long();\n+  return TypeIntHelper::int_type_is_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -2224,1 +1983,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Long;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Long;\n@@ -2233,55 +1993,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeLong\n-#ifndef PRODUCT\n-static const char* longnamenear(jlong x, const char* xname, char* buf, size_t buf_size, jlong n) {\n-  if (n > x) {\n-    if (n >= x + 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s+\" JLONG_FORMAT, xname, n - x);\n-  } else if (n < x) {\n-    if (n <= x - 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s-\" JLONG_FORMAT, xname, x - n);\n-  } else {\n-    return xname;\n-  }\n-  return buf;\n-}\n-\n-static const char* longname(char* buf, size_t buf_size, jlong n) {\n-  const char* str;\n-  if (n == min_jlong)\n-    return \"min\";\n-  else if (n < min_jlong + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" JLONG_FORMAT, n - min_jlong);\n-  else if (n == max_jlong)\n-    return \"max\";\n-  else if (n > max_jlong - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" JLONG_FORMAT, max_jlong - n);\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else\n-    os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeLong::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[80], buf2[80];\n-  if (_lo == min_jlong && _hi == max_jlong)\n-    st->print(\"long\");\n-  else if (is_con())\n-    st->print(\"long:%s\", longname(buf, sizeof(buf), get_con()));\n-  else if (_hi == max_jlong)\n-    st->print(\"long:>=%s\", longname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jlong)\n-    st->print(\"long:<=%s\", longname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"long:%s..%s\", longname(buf, sizeof(buf), _lo), longname(buf2,sizeof(buf2),  _hi));\n-\n-  if (_widen != 0 && this != TypeLong::LONG)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -2292,1 +1997,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -2296,1 +2001,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -2299,0 +2004,19 @@\n+\/\/------------------------------dump2------------------------------------------\n+#ifndef PRODUCT\n+void TypeInt::dump2(Dict& d, uint depth, outputStream* st) const {\n+  TypeIntHelper::int_type_dump(this, st, false);\n+}\n+\n+void TypeInt::dump_verbose() const {\n+  TypeIntHelper::int_type_dump(this, tty, true);\n+}\n+\n+void TypeLong::dump2(Dict& d, uint depth, outputStream* st) const {\n+  TypeIntHelper::int_type_dump(this, st, false);\n+}\n+\n+void TypeLong::dump_verbose() const {\n+  TypeIntHelper::int_type_dump(this, tty, true);\n+}\n+#endif\n+\n@@ -2550,1 +2274,7 @@\n-    const TypeAry *a = t->is_ary();\n+    const TypeAry* a = t->is_ary();\n+    const Type* size = _size->xmeet(a->_size);\n+    const TypeInt* isize = size->isa_int();\n+    if (isize == nullptr) {\n+      assert(size == Type::TOP || size == Type::BOTTOM, \"\");\n+      return size;\n+    }\n@@ -2552,2 +2282,1 @@\n-                         _size->xmeet(a->_size)->is_int(),\n-                         _stable && a->_stable);\n+                         isize, _stable && a->_stable);\n@@ -4977,1 +4706,1 @@\n-  if (lo > hi)\n+  if (lo > hi) {\n@@ -4979,1 +4708,2 @@\n-  if (!chg)\n+  }\n+  if (!chg) {\n@@ -4981,0 +4711,1 @@\n+  }\n@@ -5145,1 +4876,6 @@\n-    const TypeAry *tary = _ary->meet_speculative(tap->_ary)->is_ary();\n+    const Type* tm = _ary->meet_speculative(tap->_ary);\n+    const TypeAry* tary = tm->isa_ary();\n+    if (tary == nullptr) {\n+      assert(tm == Type::TOP || tm == Type::BOTTOM, \"\");\n+      return tm;\n+    }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":222,"deletions":486,"binary":false,"changes":708,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n@@ -76,0 +78,3 @@\n+template <class T, class U>\n+class TypeIntPrototype;\n+\n@@ -287,0 +292,3 @@\n+  template <typename TypeClass>\n+  const TypeClass* try_cast() const;\n+\n@@ -597,1 +605,6 @@\n-  TypeInteger(TYPES t, int w) : Type(t), _widen(w) {}\n+  TypeInteger(TYPES t, int w, bool dual) : Type(t), _is_dual(dual), _widen(w) {}\n+\n+  \/\/ Denote that a set is a dual set.\n+  \/\/ Dual sets are only used to compute the join of 2 sets, and not used\n+  \/\/ outside.\n+  const bool _is_dual;\n@@ -616,5 +629,139 @@\n-\n-\n-\/\/------------------------------TypeInt----------------------------------------\n-\/\/ Class of integer ranges, the set of integers between a lower bound and an\n-\/\/ upper bound, inclusive.\n+\/**\n+ * Definition:\n+ *\n+ * A TypeInt represents a set of non-empty jint values. A jint v is an element\n+ * of a TypeInt iff:\n+ *\n+ * v >= _lo && v <= _hi && juint(v) >= _ulo && juint(v) <= _uhi && _bits.is_satisfied_by(v)\n+ *\n+ * Multiple sets of parameters can represent the same set.\n+ * E.g: consider 2 TypeInt t1, t2\n+ *\n+ * t1._lo = 2, t1._hi = 7, t1._ulo = 0, t1._uhi = 5, t1._bits._zeros = 0x00000000, t1._bits._ones = 0x1\n+ * t2._lo = 3, t2._hi = 5, t2._ulo = 3, t2._uhi = 5, t2._bits._zeros = 0xFFFFFFF8, t2._bits._ones = 0x1\n+ *\n+ * Then, t1 and t2 both represent the set {3, 5}. We can also see that the\n+ * constraints of t2 are tightest possible. I.e there exists no TypeInt t3\n+ * which also represents {3, 5} such that:\n+ *\n+ * t3._lo > t2._lo || t3._hi < t2._hi || t3._ulo > t2._ulo || t3._uhi < t2._uhi ||\n+ *     (t3._bits._zeros &~ t2._bis._zeros) != 0 || (t3._bits._ones &~ t2._bits._ones) != 0\n+ *\n+ * The 5-th condition mean that the subtraction of the bitsets represented by\n+ * t3._bits._zeros and t2._bits._zeros is not empty, which means that the\n+ * bits in t3._bits._zeros is not a subset of those in t2._bits._zeros, the\n+ * same applies to _bits._ones\n+ *\n+ * As a result, every TypeInt is canonicalized to its tightest form upon\n+ * construction. This makes it easier to reason about them in optimizations.\n+ * E.g a TypeInt t with t._lo < 0 will definitely contain negative values. It\n+ * also makes it trivial to determine if a TypeInt instance is a subset of\n+ * another.\n+ *\n+ * Lemmas:\n+ *\n+ * 1. Since every TypeInt instance is non-empty and canonicalized, all the\n+ *   bounds must also be elements of such TypeInt. Or else, we can tighten the\n+ *   bounds by narrowing it by one, which contradicts the assumption of the\n+ *   TypeInt being canonical.\n+ *\n+ * 2.\n+ *   2.1.  _lo <= jint(_ulo)\n+ *   2.2.  _lo <= _hi\n+ *   2.3.  _lo <= jint(_uhi)\n+ *   2.4.  _ulo <= juint(_lo)\n+ *   2.5.  _ulo <= juint(_hi)\n+ *   2.6.  _ulo <= _uhi\n+ *   2.7.  _hi >= _lo\n+ *   2.8.  _hi >= jint(_ulo)\n+ *   2.9.  _hi >= jint(_uhi)\n+ *   2.10. _uhi >= juint(_lo)\n+ *   2.11. _uhi >= _ulo\n+ *   2.12. _uhi >= juint(_hi)\n+ *\n+ *   Proof of lemma 2:\n+ *\n+ *   2.1. _lo <= jint(_ulo):\n+ *     According the lemma 1, _ulo is an element of the TypeInt, so in the\n+ *     signed domain, it must not be less than the smallest element of that\n+ *     TypeInt, which is _lo. Which means that _lo <= _ulo in the signed\n+ *     domain, or in a more programmatical way, _lo <= jint(_ulo).\n+ *   2.2. _lo <= _hi:\n+ *     According the lemma 1, _hi is an element of the TypeInt, so in the\n+ *     signed domain, it must not be less than the smallest element of that\n+ *     TypeInt, which is _lo. Which means that _lo <= _hi.\n+ *\n+ *   The other inequalities can be proved in a similar manner.\n+ *\n+ * 3. Either _lo == jint(_ulo) and _hi == jint(_uhi), or all elements of a\n+ *   TypeInt lie in the intervals [_lo, jint(_uhi)] or [jint(_ulo), _hi] (note\n+ *   that these intervals are disjoint in this case).\n+ *\n+ *   Proof of lemma 3:\n+ *   Lemma 3.1: For 2 jint value x, y such that they are both >= 0 or both < 0.\n+ *   Then:\n+ *\n+ *   x <= y iff juint(x) <= juint(y)\n+ *   I.e. x <= y in the signed domain iff x <= y in the unsigned domain\n+ *\n+ *   Then, we have:\n+ *\n+ *   For a TypeInt t, there are 3 possible cases:\n+ *\n+ *   a. t._lo >= 0, we have:\n+ *\n+ *     0 <= t_lo <= jint(t._ulo)           (lemma 2.1)\n+ *     juint(t._lo) <= juint(jint(t._ulo)) (lemma 3.1)\n+ *                  == t._ulo              (juint(jint(v)) == v with juint v)\n+ *                  <= juint(t._lo)        (lemma 2.4)\n+ *\n+ *     Which means that t._lo == jint(t._ulo).\n+ *\n+ *     Furthermore,\n+ *\n+ *     0 <= t._lo <= t._hi                 (lemma 2.2)\n+ *     0 <= t._lo <= jint(t._uhi)          (lemma 2.3)\n+ *     t._hi >= jint(t._uhi)               (lemma 2.9)\n+ *\n+ *     juint(t._hi) >= juint(jint(t._uhi)) (lemma 3.1)\n+ *                  == t._uhi              (juint(jint(v)) == v with juint v)\n+ *                  >= juint(t._hi)        (lemma 2.12)\n+ *\n+ *     Which means that t._hi = jint(t._uhi)\n+ *\n+ *   b. t._hi < 0. Similarly, t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n+ *\n+ *   c. t._lo < 0, t._hi >= 0.\n+ *\n+ *     Since t._ulo <= juint(t._hi) (lemma 2.5), we must have jint(t._ulo) >= 0\n+ *     because all negative values is larger than all non-negative values in the\n+ *     unsigned domain.\n+ *\n+ *     Since t._uhi >= juint(t._lo) (lemma 2.10), we must have jint(t._uhi) < 0\n+ *     similar to the reasoning above.\n+ *\n+ *     In this case, all elements of t belongs to either [t._lo, jint(t._uhi)] or\n+ *     [jint(t._ulo), t._hi].\n+ *\n+ *     Below is an illustration of the TypeInt in this case, the intervals that the\n+ *     elements can be in are marked using the = symbol. Note how the negative range\n+ *     in the signed domain wrap around in the unsigned domain.\n+ *\n+ *     Signed:\n+ *     -----lo=========uhi---------0--------ulo==========hi-----\n+ *     Unsigned:\n+ *                                 0--------ulo==========hi----------lo=========uhi---------\n+ *\n+ *   This property is useful for our analysis of TypeInt values. Additionally,\n+ *   it can be seen that _lo and jint(_uhi) are both < 0 or both >= 0, and the\n+ *   same applies to jint(_ulo) and _hi.\n+ *\n+ *   We call [_lo, jint(_uhi)] and [jint(_ulo), _hi] \"simple intervals\". Then,\n+ *   a TypeInt consists of 2 simple intervals, each of which has its bounds\n+ *   being both >= 0 or both < 0. If both simple intervals lie in the same half\n+ *   of the integer domain, they must be the same (i.e _lo == jint(_ulo) and\n+ *   _hi == jint(_uhi)). Otherwise, [_lo, jint(_uhi)] must lie in the negative\n+ *   half and [jint(_ulo), _hi] must lie in the non-negative half of the signed\n+ *   domain (equivalently, [_lo, jint(_uhi)] must lie in the upper half and\n+ *   [jint(_ulo), _hi] must lie in the lower half of the unsigned domain).\n+ *\/\n@@ -622,1 +769,2 @@\n-  TypeInt( jint lo, jint hi, int w );\n+  TypeInt(const TypeIntPrototype<jint, juint>& t, int w, bool dual);\n+  static const Type* try_make(const TypeIntPrototype<jint, juint>& t, int widen, bool dual);\n@@ -624,1 +772,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -628,1 +776,1 @@\n-  virtual bool eq( const Type *t ) const;\n+  virtual bool eq(const Type* t) const;\n@@ -632,1 +780,5 @@\n-  const jint _lo, _hi;          \/\/ Lower bound, upper bound\n+  \/\/ A value is in the set represented by this TypeInt if it satisfies all\n+  \/\/ the below constraints, see contains(jint)\n+  const jint _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const juint _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const KnownBits<juint> _bits;\n@@ -634,1 +786,1 @@\n-  static const TypeInt *make(jint lo);\n+  static const TypeInt* make(jint con);\n@@ -636,1 +788,2 @@\n-  static const TypeInt *make(jint lo, jint hi, int w);\n+  static const TypeInt* make(jint lo, jint hi, int widen);\n+  static const Type* try_make(const TypeIntPrototype<jint, juint>& t, int widen);\n@@ -639,1 +792,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -641,1 +794,5 @@\n-  jint get_con() const { assert(is_con(), \"\" );  return _lo; }\n+  jint get_con() const { assert(is_con(), \"\");  return _lo; }\n+  \/\/ Check if a jint\/TypeInt is a subset of this TypeInt (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jint i) const;\n+  bool contains(const TypeInt* t) const;\n@@ -643,1 +800,1 @@\n-  virtual bool        is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n@@ -645,4 +802,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -655,23 +812,25 @@\n-  static const TypeInt *MAX;\n-  static const TypeInt *MIN;\n-  static const TypeInt *MINUS_1;\n-  static const TypeInt *ZERO;\n-  static const TypeInt *ONE;\n-  static const TypeInt *BOOL;\n-  static const TypeInt *CC;\n-  static const TypeInt *CC_LT;  \/\/ [-1]  == MINUS_1\n-  static const TypeInt *CC_GT;  \/\/ [1]   == ONE\n-  static const TypeInt *CC_EQ;  \/\/ [0]   == ZERO\n-  static const TypeInt *CC_LE;  \/\/ [-1,0]\n-  static const TypeInt *CC_GE;  \/\/ [0,1] == BOOL (!)\n-  static const TypeInt *BYTE;\n-  static const TypeInt *UBYTE;\n-  static const TypeInt *CHAR;\n-  static const TypeInt *SHORT;\n-  static const TypeInt *POS;\n-  static const TypeInt *POS1;\n-  static const TypeInt *INT;\n-  static const TypeInt *SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-  static const TypeInt *TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-  static const TypeInt *as_self(const Type *t) { return t->is_int(); }\n+  static const TypeInt* MAX;\n+  static const TypeInt* MIN;\n+  static const TypeInt* MINUS_1;\n+  static const TypeInt* ZERO;\n+  static const TypeInt* ONE;\n+  static const TypeInt* BOOL;\n+  static const TypeInt* CC;\n+  static const TypeInt* CC_LT;  \/\/ [-1]  == MINUS_1\n+  static const TypeInt* CC_GT;  \/\/ [1]   == ONE\n+  static const TypeInt* CC_EQ;  \/\/ [0]   == ZERO\n+  static const TypeInt* CC_NE;  \/\/ [-1, 1]\n+  static const TypeInt* CC_LE;  \/\/ [-1,0]\n+  static const TypeInt* CC_GE;  \/\/ [0,1] == BOOL (!)\n+  static const TypeInt* BYTE;\n+  static const TypeInt* UBYTE;\n+  static const TypeInt* CHAR;\n+  static const TypeInt* SHORT;\n+  static const TypeInt* NON_ZERO;\n+  static const TypeInt* POS;\n+  static const TypeInt* POS1;\n+  static const TypeInt* INT;\n+  static const TypeInt* SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+  static const TypeInt* TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n+\n+  static const TypeInt* as_self(const Type* t) { return t->is_int(); }\n@@ -679,1 +838,2 @@\n-  virtual void dump2( Dict &d, uint depth, outputStream *st ) const;\n+  virtual void dump2(Dict& d, uint depth, outputStream* st) const;\n+  void dump_verbose() const;\n@@ -683,4 +843,1 @@\n-\n-\/\/------------------------------TypeLong---------------------------------------\n-\/\/ Class of long integer ranges, the set of integers between a lower bound and\n-\/\/ an upper bound, inclusive.\n+\/\/ Similar to TypeInt\n@@ -688,1 +845,2 @@\n-  TypeLong( jlong lo, jlong hi, int w );\n+  TypeLong(const TypeIntPrototype<jlong, julong>& t, int w, bool dual);\n+  static const Type* try_make(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual);\n@@ -691,1 +849,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -699,1 +857,5 @@\n-  const jlong _lo, _hi;         \/\/ Lower bound, upper bound\n+  \/\/ A value is in the set represented by this TypeLong if it satisfies all\n+  \/\/ the below constraints, see contains(jlong)\n+  const jlong _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const julong _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const KnownBits<julong> _bits;\n@@ -701,1 +863,1 @@\n-  static const TypeLong *make(jlong lo);\n+  static const TypeLong* make(jlong con);\n@@ -703,1 +865,2 @@\n-  static const TypeLong *make(jlong lo, jlong hi, int w);\n+  static const TypeLong* make(jlong lo, jlong hi, int widen);\n+  static const Type* try_make(const TypeIntPrototype<jlong, julong>& t, int widen);\n@@ -706,1 +869,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -709,0 +872,4 @@\n+  \/\/ Check if a jlong\/TypeLong is a subset of this TypeLong (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jlong i) const;\n+  bool contains(const TypeLong* t) const;\n@@ -718,4 +885,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -723,10 +890,12 @@\n-  static const TypeLong *MAX;\n-  static const TypeLong *MIN;\n-  static const TypeLong *MINUS_1;\n-  static const TypeLong *ZERO;\n-  static const TypeLong *ONE;\n-  static const TypeLong *POS;\n-  static const TypeLong *LONG;\n-  static const TypeLong *INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n-  static const TypeLong *UINT;   \/\/ 32-bit unsigned [0..max_juint]\n-  static const TypeLong *TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+  static const TypeLong* MAX;\n+  static const TypeLong* MIN;\n+  static const TypeLong* MINUS_1;\n+  static const TypeLong* ZERO;\n+  static const TypeLong* ONE;\n+  static const TypeLong* NON_ZERO;\n+  static const TypeLong* POS;\n+  static const TypeLong* NEG;\n+  static const TypeLong* LONG;\n+  static const TypeLong* INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n+  static const TypeLong* UINT;   \/\/ 32-bit unsigned [0..max_juint]\n+  static const TypeLong* TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -735,1 +904,1 @@\n-  static const TypeLong *as_self(const Type *t) { return t->is_long(); }\n+  static const TypeLong* as_self(const Type* t) { return t->is_long(); }\n@@ -738,1 +907,2 @@\n-  virtual void dump2( Dict &d, uint, outputStream *st  ) const;\/\/ Specialized per-Type dumping\n+  virtual void dump2(Dict& d, uint, outputStream* st) const;\/\/ Specialized per-Type dumping\n+  void dump_verbose() const;\n@@ -2244,0 +2414,10 @@\n+template <>\n+inline const TypeInt* Type::try_cast<TypeInt>() const {\n+  return isa_int();\n+}\n+\n+template <>\n+inline const TypeLong* Type::try_cast<TypeLong>() const {\n+  return isa_long();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":249,"deletions":69,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -39,1 +40,2 @@\n-template <typename T> unsigned count_leading_zeros(T v) {\n+template <typename T, ENABLE_IF(std::is_arithmetic<T>::value)>\n+unsigned count_leading_zeros(T v) {\n","filename":"src\/hotspot\/share\/utilities\/count_leading_zeros.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_INTN_T_HPP\n+#define SHARE_UTILITIES_INTN_T_HPP\n+\n+#include \"utilities\/count_leading_zeros.hpp\"\n+\n+#include <limits>\n+\n+template <unsigned int n>\n+class uintn_t;\n+\n+template <unsigned int n>\n+class intn_t {\n+  static_assert(n > 0 && n <= 8, \"should not be larger than char\");\n+\n+private:\n+  uint _v;\n+\n+  constexpr static uint _mask = (1 << n) - 1;\n+\n+  friend class uintn_t<n>;\n+\n+public:\n+  explicit constexpr intn_t(int v) : _v(v) {}\n+  constexpr intn_t() : _v(0) {}\n+  constexpr intn_t(const intn_t&) = default;\n+  constexpr intn_t& operator=(const intn_t&) = default;\n+  explicit constexpr intn_t(uintn_t<n> v);\n+\n+  explicit constexpr operator int() const {\n+    int shift = 32 - n;\n+    return int(_v << shift) >> shift;\n+  }\n+\n+  constexpr static int min = std::numeric_limits<unsigned int>::max() << (n - 1);\n+  constexpr static int max = (1 << (n - 1)) - 1;\n+  static_assert(min < max, \"\");\n+\n+  constexpr bool operator==(intn_t o) const { return (_v & _mask) == (o._v & _mask); }\n+  constexpr bool operator<(intn_t o) const { return int(*this) < int(o); }\n+  constexpr bool operator>(intn_t o) const { return int(*this) > int(o); }\n+  constexpr bool operator<=(intn_t o) const { return int(*this) <= int(o); }\n+  constexpr bool operator>=(intn_t o) const { return int(*this) >= int(o); }\n+};\n+\n+template <unsigned int n>\n+unsigned count_leading_zeros(uintn_t<n>);\n+\n+template <unsigned int n>\n+class uintn_t {\n+  static_assert(n > 0 && n <= 8, \"should not be larger than char\");\n+\n+private:\n+  uint _v;\n+\n+  constexpr static uint _mask = (1 << n) - 1;\n+\n+  friend class intn_t<n>;\n+\n+  friend unsigned count_leading_zeros<n>(uintn_t<n>);\n+\n+public:\n+  explicit constexpr uintn_t(int v) : _v(v) {}\n+  constexpr uintn_t() : _v(0) {}\n+  constexpr uintn_t(const uintn_t&) = default;\n+  constexpr uintn_t& operator=(const uintn_t&) = default;\n+  explicit constexpr uintn_t(intn_t<n> v) : _v(v._v) {}\n+  explicit constexpr operator uint() const { return _v & _mask; }\n+\n+  constexpr static int min = 0;\n+  constexpr static int max = _mask;\n+  static_assert(min < max, \"\");\n+\n+  constexpr bool operator==(uintn_t o) const { return (_v & _mask) == (o._v & _mask); }\n+  constexpr bool operator!=(uintn_t o) const { return (_v & _mask) != (o._v & _mask); }\n+  constexpr bool operator<(uintn_t o) const { return (_v & _mask) < (o._v & _mask); }\n+  constexpr bool operator>(uintn_t o) const { return (_v & _mask) > (o._v & _mask); }\n+  constexpr bool operator<=(uintn_t o) const { return (_v & _mask) <= (o._v & _mask); }\n+  constexpr bool operator>=(uintn_t o) const { return (_v & _mask) >= (o._v & _mask); }\n+  constexpr uintn_t operator+(uintn_t o) const { return uintn_t(_v + o._v); }\n+  constexpr uintn_t operator-(uintn_t o) const { return uintn_t(_v - o._v); }\n+  constexpr uintn_t operator&(uintn_t o) const { return uintn_t(_v & o._v); }\n+  constexpr uintn_t operator|(uintn_t o) const { return uintn_t(_v | o._v); }\n+  constexpr uintn_t operator^(uintn_t o) const { return uintn_t(_v ^ o._v); }\n+  constexpr uintn_t operator>>(unsigned int s) const { return uintn_t((_v & _mask) >> s); }\n+  constexpr uintn_t operator<<(unsigned int s) const { return uintn_t(_v << s); }\n+  constexpr uintn_t operator~() const { return uintn_t(~_v); }\n+  constexpr uintn_t operator-() const { return uintn_t(-_v); }\n+  constexpr uintn_t& operator|=(uintn_t o) { _v |= o._v; return *this; }\n+};\n+\n+template <unsigned int n>\n+constexpr intn_t<n>::intn_t(uintn_t<n> v) : _v(v._v) {}\n+\n+namespace std {\n+\n+template <unsigned int n>\n+class numeric_limits<intn_t<n>> {\n+public:\n+  constexpr static intn_t<n> min() { return intn_t<n>(intn_t<n>::min); }\n+  constexpr static intn_t<n> max() { return intn_t<n>(intn_t<n>::max); }\n+};\n+\n+template <unsigned int n>\n+class numeric_limits<uintn_t<n>> {\n+public:\n+  constexpr static uintn_t<n> min() { return uintn_t<n>(uintn_t<n>::min); }\n+  constexpr static uintn_t<n> max() { return uintn_t<n>(uintn_t<n>::max); }\n+};\n+\n+}\n+\n+template <unsigned int n>\n+inline unsigned count_leading_zeros(uintn_t<n> v) {\n+  return count_leading_zeros<unsigned int>(v._v & uintn_t<n>::_mask) - (32 - n);\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_INTN_T_HPP\n","filename":"src\/hotspot\/share\/utilities\/intn_t.hpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"opto\/rangeinference.hpp\"\n+#include \"opto\/type.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/intn_t.hpp\"\n+#include \"unittest.hpp\"\n+\n+template <class U>\n+static U uniform_random();\n+\n+template <>\n+juint uniform_random<juint>() {\n+  return os::random();\n+}\n+\n+template <>\n+julong uniform_random<julong>() {\n+  return (julong(os::random()) << 32) | julong(juint(os::random()));\n+}\n+\n+static void test_canonicalize_constraints_trivial() {\n+  ASSERT_FALSE(TypeInt::NON_ZERO->contains(0));\n+  ASSERT_TRUE(TypeInt::NON_ZERO->contains(1));\n+  ASSERT_TRUE(TypeInt::NON_ZERO->contains(-1));\n+  ASSERT_TRUE(TypeInt::CC_NE->contains(-1));\n+  ASSERT_TRUE(TypeInt::CC_NE->contains(1));\n+  ASSERT_FALSE(TypeInt::CC_NE->contains(0));\n+  ASSERT_FALSE(TypeInt::CC_NE->contains(-2));\n+  ASSERT_FALSE(TypeInt::CC_NE->contains(2));\n+  ASSERT_FALSE(TypeLong::NON_ZERO->contains(jlong(0)));\n+  ASSERT_TRUE(TypeLong::NON_ZERO->contains(jlong(1)));\n+  ASSERT_TRUE(TypeLong::NON_ZERO->contains(jlong(-1)));\n+}\n+\n+template <class S, class U>\n+static void test_canonicalize_constraints_exhaustive() {\n+  {\n+    TypeIntPrototype<S, U> t{{S(0), S(0)}, {U(0), U(0)}, {U(-1), U(0)}};\n+    auto new_t = t.canonicalize_constraints();\n+    ASSERT_TRUE(new_t._present);\n+    DEBUG_ONLY(ASSERT_TRUE(t.contains(S(0))));\n+    DEBUG_ONLY(ASSERT_FALSE(t.contains(S(1))));\n+  }\n+  {\n+    TypeIntPrototype<S, U> t{{S(0), S(0)}, {U(1), U(1)}, {U(-1), U(0)}};\n+    auto new_t = t.canonicalize_constraints();\n+    ASSERT_FALSE(new_t._present);\n+    DEBUG_ONLY(ASSERT_FALSE(t.contains(S(0))));\n+    DEBUG_ONLY(ASSERT_FALSE(t.contains(S(1))));\n+  }\n+  {\n+    TypeIntPrototype<S, U> t{{S(S::min), S(S::max)}, {U(U::min), U(U::max)}, {U(0), U(0)}};\n+    auto new_t = t.canonicalize_constraints();\n+    ASSERT_TRUE(new_t._present);\n+    for (int v = S::min; v <= S::max; v++) {\n+      DEBUG_ONLY(ASSERT_TRUE(t.contains(S(v))));\n+    }\n+  }\n+  for (int lo = S::min; lo <= S::max; lo++) {\n+    for (int hi = lo; hi <= S::max; hi++) {\n+      for (int ulo = U::min; ulo <= U::max; ulo++) {\n+        for (int uhi = ulo; uhi <= U::max; uhi++) {\n+          for (int zeros = U::min; zeros <= U::max; zeros++) {\n+            for (int ones = U::min; ones <= U::max; ones++) {\n+              TypeIntPrototype<S, U> t{{S(lo), S(hi)}, {U(ulo), U(uhi)}, {U(zeros), U(ones)}};\n+              auto new_t = t.canonicalize_constraints();\n+              if (new_t._present) {\n+                DEBUG_ONLY(new_t._data.verify_constraints());\n+              }\n+              for (int v = S::min; v <= S::max; v++) {\n+                if (!new_t._present) {\n+                  DEBUG_ONLY(ASSERT_FALSE(t.contains(S(v))));\n+                } else {\n+                  DEBUG_ONLY(ASSERT_EQ(t.contains(S(v)), new_t._data.contains(S(v))));\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+template <class S, class U>\n+static void test_canonicalize_constraints_simple() {\n+  constexpr int parameters = 10;\n+  for (int i = 0; i < parameters; i++) {\n+    S a = uniform_random<U>();\n+    S b = uniform_random<U>();\n+\n+    {\n+      S lo = MIN2<S>(a, b);\n+      S hi = MAX2<S>(a, b);\n+      TypeIntPrototype<S, U> t{{lo, hi}, {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()},\n+                               {0, 0}};\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(lo, new_t._data._srange._lo);\n+      ASSERT_EQ(hi, new_t._data._srange._hi);\n+      if (U(lo) <= U(hi)) {\n+        ASSERT_EQ(U(lo), new_t._data._urange._lo);\n+        ASSERT_EQ(U(hi), new_t._data._urange._hi);\n+      } else {\n+        ASSERT_EQ(std::numeric_limits<U>::min(), new_t._data._urange._lo);\n+        ASSERT_EQ(std::numeric_limits<U>::max(), new_t._data._urange._hi);\n+      }\n+    }\n+\n+    {\n+      U ulo = MIN2<U>(a, b);\n+      U uhi = MAX2<U>(a, b);\n+      TypeIntPrototype<S, U> t{{std::numeric_limits<S>::min(), std::numeric_limits<S>::max()},\n+                               {ulo, uhi}, {0, 0}};\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(ulo, new_t._data._urange._lo);\n+      ASSERT_EQ(uhi, new_t._data._urange._hi);\n+      if (S(ulo) <= S(uhi)) {\n+        ASSERT_EQ(S(ulo), new_t._data._srange._lo);\n+        ASSERT_EQ(S(uhi), new_t._data._srange._hi);\n+      } else {\n+        ASSERT_EQ(std::numeric_limits<S>::min(), new_t._data._srange._lo);\n+        ASSERT_EQ(std::numeric_limits<S>::max(), new_t._data._srange._hi);\n+      }\n+    }\n+\n+    {\n+      U intersection = a & b;\n+      U zeros = a ^ intersection;\n+      U ones = b ^ intersection;\n+      TypeIntPrototype<S, U> t{{std::numeric_limits<S>::min(), std::numeric_limits<S>::max()},\n+                               {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()}, {zeros, ones}};\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(zeros, new_t._data._bits._zeros);\n+      ASSERT_EQ(ones, new_t._data._bits._ones);\n+      ASSERT_EQ(ones, new_t._data._urange._lo);\n+      ASSERT_EQ(~zeros, new_t._data._urange._hi);\n+    }\n+  }\n+}\n+\n+template <class S, class U>\n+static void test_canonicalize_constraints_random() {\n+  constexpr int samples = 1000;\n+  constexpr int parameters = 1000;\n+  for (int i = 0; i < parameters; i++) {\n+    S s1 = uniform_random<U>();\n+    S s2 = uniform_random<U>();\n+    S lo = MIN2(s1, s2);\n+    S hi = MAX2(s1, s2);\n+    U u1 = uniform_random<U>();\n+    U u2 = uniform_random<U>();\n+    U ulo = MIN2(u1, u2);\n+    U uhi = MAX2(u1, u2);\n+    U b1 = uniform_random<U>();\n+    U b2 = uniform_random<U>();\n+    U intersection = b1 & b2;\n+    U zeros = b1 ^ intersection;\n+    U ones = b2 ^ intersection;\n+    TypeIntPrototype<S, U> t{{lo, hi}, {ulo, uhi}, {zeros, ones}};\n+    auto new_t = t.canonicalize_constraints();\n+    if (new_t._present) {\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+    }\n+    for (int j = 0; j < samples; j++) {\n+      S v = uniform_random<U>();\n+      if (!new_t._present) {\n+        DEBUG_ONLY(ASSERT_FALSE(t.contains(v)));\n+      } else {\n+        DEBUG_ONLY(ASSERT_EQ(t.contains(v), new_t._data.contains(v)));\n+      }\n+    }\n+  }\n+}\n+\n+TEST_VM(opto, canonicalize_constraints) {\n+  test_canonicalize_constraints_trivial();\n+  test_canonicalize_constraints_exhaustive<intn_t<1>, uintn_t<1>>();\n+  test_canonicalize_constraints_exhaustive<intn_t<2>, uintn_t<2>>();\n+  test_canonicalize_constraints_exhaustive<intn_t<3>, uintn_t<3>>();\n+  test_canonicalize_constraints_exhaustive<intn_t<4>, uintn_t<4>>();\n+  test_canonicalize_constraints_simple<jint, juint>();\n+  test_canonicalize_constraints_simple<jlong, julong>();\n+  test_canonicalize_constraints_random<jint, juint>();\n+  test_canonicalize_constraints_random<jlong, julong>();\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"utilities\/intn_t.hpp\"\n+#include \"unittest.hpp\"\n+\n+template <unsigned int n>\n+static void test_intn_t() {\n+  static_assert(std::numeric_limits<intn_t<n>>::min() <= intn_t<n>(-1) && intn_t<n>(-1) < intn_t<n>(0) && intn_t<n>(0) <= std::numeric_limits<intn_t<n>>::max(), \"basic sanity\");\n+  for (int i = intn_t<n>::min; i <= intn_t<n>::max; i++) {\n+    ASSERT_EQ(i, int(intn_t<n>(i)));\n+    if (i > intn_t<n>::min) {\n+      ASSERT_TRUE(intn_t<n>(i - 1) < intn_t<n>(i));\n+    }\n+    if (i < intn_t<n>::max) {\n+      ASSERT_TRUE(intn_t<n>(i) < intn_t<n>(i + 1));\n+    }\n+  }\n+}\n+\n+TEST(utilities, intn_t) {\n+  test_intn_t<1>();\n+  test_intn_t<2>();\n+  test_intn_t<3>();\n+  test_intn_t<4>();\n+  test_intn_t<5>();\n+  test_intn_t<6>();\n+  test_intn_t<7>();\n+  test_intn_t<8>();\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_intn_t.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}