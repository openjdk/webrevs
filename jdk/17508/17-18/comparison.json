{"files":[{"patch":"@@ -75,3 +75,3 @@\n-  \/\/ lo. Similarly, one_violation = 0001, i.e the forth bit should be one, but\n-  \/\/ it is 0 in lo. These make lo not satisfy the bit constraints, which\n-  \/\/ results in us having to find the smallest value that satisfies bits\n+  \/\/ lo. Similarly, one_violation = 0001, i.e the LSB should be one, but it is\n+  \/\/ 0 in lo. These make lo not satisfy the bit constraints, which results in\n+  \/\/ us having to find the smallest value that satisfies bits\n@@ -86,1 +86,1 @@\n-  \/\/ The principal here is that, consider the first bit in result that is\n+  \/\/ The principle here is that, consider the first bit in result that is\n@@ -88,2 +88,2 @@\n-  \/\/ the bit must be unset in lo and set in result. As result should be the\n-  \/\/ smallest value, the position of this bit should be as low as possible\n+  \/\/ the bit must be 0 in lo and 1 in result. As result should be the smallest\n+  \/\/ value, this bit should be the rightmost one possible.\n@@ -116,2 +116,2 @@\n-    \/\/ Continue the logic with each set bit in ones, we will set each bit in\n-    \/\/ our new lo (11000000 -> 11001000 -> 11001010). The final value is our\n+    \/\/ Continue the logic with each 1 bit in ones, we will set each bit in our\n+    \/\/ new lo (11000000 -> 11001000 -> 11001010). The final value is our\n@@ -137,3 +137,3 @@\n-  \/\/ Consider the first bit that is change, it must not be set already, and it\n-  \/\/ must not be set in zeros. As a result, it must be the last bit before the\n-  \/\/ first bit violation that is unset in both zeros and lo.\n+  \/\/ Consider the first bit that is changed, it must not be 1 already, and it\n+  \/\/ must not be 1 in zeros. As a result, it must be the last bit before the\n+  \/\/ first bit violation that is 0 in both zeros and lo.\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"}]}