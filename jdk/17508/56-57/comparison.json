{"files":[{"patch":"@@ -32,1 +32,1 @@\n-template <unsigned int n>\n+template <unsigned int nbits>\n@@ -35,1 +35,11 @@\n-template <unsigned int n>\n+\/\/ This class represents a signed integer type with the width of exactly nbits\n+\/\/ bits. Conceptually, nbits == 8 gives a type equivalent to int8_t,\n+\/\/ nbits == 16 gives a type equivalent to int16_t, and so on. This class may be\n+\/\/ used to verify the correctness of an algorithm that is supposed to be\n+\/\/ applicable to all fixed-width integral types. With a few bits, it makes it\n+\/\/ possible to perform an exhaustive test that exercises the algorithm with all\n+\/\/ possible input values.\n+\/\/ Implementation-wise, this class currently only supports 0 < nbits <= 8. Also\n+\/\/ note that this class is implemented so that overflows in alrithmetic\n+\/\/ operations are well-defined and wrap-around.\n+template <unsigned int nbits>\n@@ -37,1 +47,1 @@\n-  static_assert(n > 0 && n <= 8, \"should not be larger than char\");\n+  static_assert(0 < nbits && nbits <= 8, \"should not be larger than char\");\n@@ -40,0 +50,9 @@\n+  \/\/ Only the lowest nbits bits are important, operations should act as if it\n+  \/\/ sign extends the lowest nbits to an int, performs the calculation on ints,\n+  \/\/ then truncates the result to nbits. In practice, we do not need to\n+  \/\/ truncate the result, as the lowest nbits will be sign extended in the next\n+  \/\/ operations. We can also sign extends the operands sparingly, for example,\n+  \/\/ addition or subtraction do not need this sign extension, and we can add or\n+  \/\/ subtract the value of _v directly. This is because the lowest nbits bits\n+  \/\/ of a sum or a difference only depends on the lowest nbits bits of the\n+  \/\/ operands.\n@@ -42,1 +61,1 @@\n-  constexpr static uint _mask = (1 << n) - 1;\n+  constexpr static uint _mask = (1 << nbits) - 1;\n@@ -44,1 +63,1 @@\n-  friend class uintn_t<n>;\n+  friend class uintn_t<nbits>;\n@@ -51,1 +70,1 @@\n-  explicit constexpr intn_t(uintn_t<n> v);\n+  explicit constexpr intn_t(uintn_t<nbits> v);\n@@ -53,0 +72,1 @@\n+  \/\/ Sign extension\n@@ -54,1 +74,1 @@\n-    int shift = 32 - n;\n+    int shift = 32 - nbits;\n@@ -58,2 +78,2 @@\n-  constexpr static int min = std::numeric_limits<unsigned int>::max() << (n - 1);\n-  constexpr static int max = (1 << (n - 1)) - 1;\n+  constexpr static int min = std::numeric_limits<unsigned int>::max() << (nbits - 1);\n+  constexpr static int max = (1 << (nbits - 1)) - 1;\n@@ -69,2 +89,2 @@\n-template <unsigned int n>\n-unsigned count_leading_zeros(uintn_t<n>);\n+template <unsigned int nbits>\n+unsigned count_leading_zeros(uintn_t<nbits>);\n@@ -72,1 +92,2 @@\n-template <unsigned int n>\n+\/\/ The unsigned version of intn_t<nbits>\n+template <unsigned int nbits>\n@@ -74,1 +95,1 @@\n-  static_assert(n > 0 && n <= 8, \"should not be larger than char\");\n+  static_assert(0 < nbits && nbits <= 8, \"should not be larger than char\");\n@@ -77,0 +98,2 @@\n+  \/\/ Similar to intn_t<nbits>, the difference is that the operation should act\n+  \/\/ as if it zero extends the lowest nbits bits of the operands.\n@@ -79,1 +102,1 @@\n-  constexpr static uint _mask = (1 << n) - 1;\n+  constexpr static uint _mask = (1 << nbits) - 1;\n@@ -81,1 +104,1 @@\n-  friend class intn_t<n>;\n+  friend class intn_t<nbits>;\n@@ -83,1 +106,1 @@\n-  friend unsigned count_leading_zeros<n>(uintn_t<n>);\n+  friend unsigned count_leading_zeros<nbits>(uintn_t<nbits>);\n@@ -90,1 +113,3 @@\n-  explicit constexpr uintn_t(intn_t<n> v) : _v(v._v) {}\n+  explicit constexpr uintn_t(intn_t<nbits> v) : _v(v._v) {}\n+\n+  \/\/ Zero extension\n@@ -115,2 +140,2 @@\n-template <unsigned int n>\n-constexpr intn_t<n>::intn_t(uintn_t<n> v) : _v(v._v) {}\n+template <unsigned int nbits>\n+constexpr intn_t<nbits>::intn_t(uintn_t<nbits> v) : _v(v._v) {}\n@@ -120,2 +145,2 @@\n-template <unsigned int n>\n-class numeric_limits<intn_t<n>> {\n+template <unsigned int nbits>\n+class numeric_limits<intn_t<nbits>> {\n@@ -123,2 +148,2 @@\n-  constexpr static intn_t<n> min() { return intn_t<n>(intn_t<n>::min); }\n-  constexpr static intn_t<n> max() { return intn_t<n>(intn_t<n>::max); }\n+  constexpr static intn_t<nbits> min() { return intn_t<nbits>(intn_t<nbits>::min); }\n+  constexpr static intn_t<nbits> max() { return intn_t<nbits>(intn_t<nbits>::max); }\n@@ -127,2 +152,2 @@\n-template <unsigned int n>\n-class numeric_limits<uintn_t<n>> {\n+template <unsigned int nbits>\n+class numeric_limits<uintn_t<nbits>> {\n@@ -130,2 +155,2 @@\n-  constexpr static uintn_t<n> min() { return uintn_t<n>(uintn_t<n>::min); }\n-  constexpr static uintn_t<n> max() { return uintn_t<n>(uintn_t<n>::max); }\n+  constexpr static uintn_t<nbits> min() { return uintn_t<nbits>(uintn_t<nbits>::min); }\n+  constexpr static uintn_t<nbits> max() { return uintn_t<nbits>(uintn_t<nbits>::max); }\n@@ -134,1 +159,1 @@\n-}\n+} \/\/ namespace std\n@@ -136,3 +161,3 @@\n-template <unsigned int n>\n-inline unsigned count_leading_zeros(uintn_t<n> v) {\n-  return count_leading_zeros<unsigned int>(v._v & uintn_t<n>::_mask) - (32 - n);\n+template <unsigned int nbits>\n+inline unsigned count_leading_zeros(uintn_t<nbits> v) {\n+  return count_leading_zeros<unsigned int>(v._v & uintn_t<nbits>::_mask) - (32 - nbits);\n","filename":"src\/hotspot\/share\/utilities\/intn_t.hpp","additions":56,"deletions":31,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-template <unsigned int n>\n+template <unsigned int nbits>\n@@ -30,5 +30,9 @@\n-  static_assert(std::numeric_limits<intn_t<n>>::min() <= intn_t<n>(-1) && intn_t<n>(-1) < intn_t<n>(0) && intn_t<n>(0) <= std::numeric_limits<intn_t<n>>::max(), \"basic sanity\");\n-  for (int i = intn_t<n>::min; i <= intn_t<n>::max; i++) {\n-    ASSERT_EQ(i, int(intn_t<n>(i)));\n-    if (i > intn_t<n>::min) {\n-      ASSERT_TRUE(intn_t<n>(i - 1) < intn_t<n>(i));\n+  static_assert(std::numeric_limits<intn_t<nbits>>::min() <= intn_t<nbits>(-1) &&\n+                intn_t<nbits>(-1) < intn_t<nbits>(0) &&\n+                intn_t<nbits>(0) <= std::numeric_limits<intn_t<nbits>>::max(), \"basic sanity\");\n+  for (int i = intn_t<nbits>::min; i <= intn_t<nbits>::max; i++) {\n+    ASSERT_EQ(i, int(intn_t<nbits>(i)));\n+    if (i > intn_t<nbits>::min) {\n+      ASSERT_TRUE(intn_t<nbits>(i - 1) < intn_t<nbits>(i));\n+    } else {\n+      ASSERT_TRUE(intn_t<nbits>(i - 1) > intn_t<nbits>(i));\n@@ -36,2 +40,4 @@\n-    if (i < intn_t<n>::max) {\n-      ASSERT_TRUE(intn_t<n>(i) < intn_t<n>(i + 1));\n+    if (i < intn_t<nbits>::max) {\n+      ASSERT_TRUE(intn_t<nbits>(i) < intn_t<nbits>(i + 1));\n+    } else {\n+      ASSERT_TRUE(intn_t<nbits>(i) > intn_t<nbits>(i + 1));\n","filename":"test\/hotspot\/gtest\/utilities\/test_intn_t.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"}]}