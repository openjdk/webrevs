{"files":[{"patch":"@@ -991,2 +991,2 @@\n-    const TypeInt* t1x = TypeInt::make(0, round_down_power_of_2(t1i->_hi) + (round_down_power_of_2(t1i->_hi) - 1), t1i->_widen);\n-    const TypeInt* t2x = TypeInt::make(0, round_down_power_of_2(t2i->_hi) + (round_down_power_of_2(t2i->_hi) - 1), t2i->_widen);\n+    const Type* t1x = TypeInt::make(0, round_down_power_of_2(t1i->_hi) + (round_down_power_of_2(t1i->_hi) - 1), t1i->_widen);\n+    const Type* t2x = TypeInt::make(0, round_down_power_of_2(t2i->_hi) + (round_down_power_of_2(t2i->_hi) - 1), t2i->_widen);\n@@ -1076,2 +1076,2 @@\n-    const TypeLong* t1x = TypeLong::make(0, round_down_power_of_2(t1l->_hi) + (round_down_power_of_2(t1l->_hi) - 1), t1l->_widen);\n-    const TypeLong* t2x = TypeLong::make(0, round_down_power_of_2(t2l->_hi) + (round_down_power_of_2(t2l->_hi) - 1), t2l->_widen);\n+    const Type* t1x = TypeLong::make(0, round_down_power_of_2(t1l->_hi) + (round_down_power_of_2(t1l->_hi) - 1), t1l->_widen);\n+    const Type* t2x = TypeLong::make(0, round_down_power_of_2(t2l->_hi) + (round_down_power_of_2(t2l->_hi) - 1), t2l->_widen);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,1 +324,1 @@\n-        const TypeInt* ti = TypeInt::make(checked_cast<jint>(tl->_lo), checked_cast<jint>(tl->_hi), tl->_widen);\n+        const TypeInt* ti = TypeInt::make(checked_cast<jint>(tl->_lo), checked_cast<jint>(tl->_hi), tl->_widen)->is_int();\n@@ -476,1 +476,5 @@\n-  const TypeInteger* this_type = this->type()->is_integer(bt);\n+  const TypeInteger* this_type = this->type()->isa_integer(bt);\n+  if (this_type == nullptr) {\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4482,2 +4482,4 @@\n-  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n-  const TypeInt* iidxtype = TypeInt::make(0, index_max, Type::WidenMax);\n+  if (sizetype != nullptr && sizetype->_hi > 0) {\n+    index_max = sizetype->_hi - 1;\n+  }\n+  const TypeInt* iidxtype = TypeInt::make(0, index_max, Type::WidenMax)->is_int();\n@@ -4500,1 +4502,1 @@\n-  const TypeLong* ltype = TypeLong::make(itype->_lo, itype->_hi, itype->_widen);\n+  const TypeLong* ltype = TypeLong::make(itype->_lo, itype->_hi, itype->_widen)->is_long();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -927,2 +927,2 @@\n-  inline Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n-                                       int idx, bool can_grow = false);\n+  Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n+                                int idx, bool can_grow = false);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -651,2 +651,2 @@\n-  rx = TypeInteger::make(rxlo, rxhi, widen, out_bt);\n-  ry = TypeInteger::make(rylo, ryhi, widen, out_bt);\n+  rx = TypeInteger::make(rxlo, rxhi, widen, out_bt)->is_integer(out_bt);\n+  ry = TypeInteger::make(rylo, ryhi, widen, out_bt)->is_integer(out_bt);\n@@ -794,1 +794,1 @@\n-    ti = TypeInt::make((jint)tl->_lo, (jint)tl->_hi, tl->_widen);\n+    ti = TypeInt::make((jint)tl->_lo, (jint)tl->_hi, tl->_widen)->is_int();\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3884,2 +3884,4 @@\n-      if (size_max > tilen->_hi)  size_max = tilen->_hi;\n-      const TypeInt* tlcon = TypeInt::make(0, size_max, Type::WidenMin);\n+      if (size_max > tilen->_hi && tilen->_hi >= 0) {\n+        size_max = tilen->_hi;\n+      }\n+      const TypeInt* tlcon = TypeInt::make(0, size_max, Type::WidenMin)->is_int();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -679,1 +679,1 @@\n-                  return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen);\n+                  return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen)->is_int();\n@@ -681,1 +681,1 @@\n-                  return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen);\n+                  return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen)->is_int();\n@@ -711,1 +711,1 @@\n-            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen);\n+            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen)->is_int();\n@@ -1052,2 +1052,1 @@\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->empty()) {\n+        if (failtype->filter(type2) == Type::TOP) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -801,1 +801,1 @@\n-      idx_type = TypeInt::make(limit_lo - stride, limit_hi - stride, limit_type->_widen);\n+      idx_type = TypeInt::make(limit_lo - stride, limit_hi - stride, limit_type->_widen)->is_int();\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -944,1 +944,1 @@\n-  const TypeInteger* inner_iters_actual_range = TypeInteger::make(0, iters_limit, Type::WidenMin, bt);\n+  const TypeInteger* inner_iters_actual_range = TypeInteger::make(0, iters_limit, Type::WidenMin, bt)->is_integer(bt);\n@@ -955,1 +955,1 @@\n-    const TypeInt* inner_iters_actual_int_range = TypeInt::make(0, iters_limit, Type::WidenMin);\n+    const TypeInt* inner_iters_actual_int_range = TypeInt::make(0, iters_limit, Type::WidenMin)->is_int();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  const TypeLong* lidxtype = TypeLong::make(CONST64(0), index_max, Type::WidenMax);\n+  const TypeLong* lidxtype = TypeLong::make(CONST64(0), index_max, Type::WidenMax)->is_long();\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1400,1 +1400,1 @@\n-    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n+    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen))->is_int();\n@@ -1470,1 +1470,1 @@\n-    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n+    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen))->is_long();\n@@ -1656,1 +1656,1 @@\n-    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n+    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen))->is_int();\n@@ -1803,1 +1803,1 @@\n-    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n+    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen))->is_long();\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,559 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n+#include \"opto\/type.hpp\"\n+#include \"utilities\/tuple.hpp\"\n+\n+constexpr juint SMALLINT = 3; \/\/ a value too insignificant to consider widening\n+\n+template <class T>\n+class AdjustResult {\n+public:\n+  bool _progress;\n+  bool _present;\n+  T _data;\n+};\n+\n+template <class T>\n+class NormalizeSimpleResult {\n+public:\n+  bool _present;\n+  RangeInt<T> _bounds;\n+  KnownBits<T> _bits;\n+};\n+\n+\/\/ Try to tighten the bound constraints from the known bit information\n+\/\/ E.g: if lo = 0 but the lowest bit is always 1 then we can tighten\n+\/\/ lo = 1\n+template <class T>\n+static AdjustResult<RangeInt<T>>\n+adjust_bounds_from_bits(const RangeInt<T>& bounds, const KnownBits<T>& bits) {\n+  static_assert(std::is_unsigned<T>::value, \"\");\n+\n+  auto adjust_lo = [](T lo, const KnownBits<T>& bits) {\n+    constexpr size_t W = sizeof(T) * 8;\n+    T zero_violation = lo & bits._zeros;\n+    T one_violation = ~lo & bits._ones;\n+    if (zero_violation == one_violation) {\n+      return lo;\n+    }\n+\n+    if (zero_violation < one_violation) {\n+      \/\/ Align the last violation of ones unset all the lower bits\n+      \/\/ so we don't care about violations of zeros\n+      juint last_violation = W - 1 - count_leading_zeros(one_violation);\n+      T alignment = T(1) << last_violation;\n+      lo = (lo & -alignment) + alignment;\n+      return lo | bits._ones;\n+    }\n+\n+    \/\/ Suppose lo = 00110010, zeros = 01010010, ones = 10001000\n+    \/\/ Since the 4-th bit must be 0, we need to align up the lower bound.\n+    \/\/ This results in lo = 01000000, but then the 6-th bit does not match,\n+    \/\/ align up again gives us 10000000.\n+    \/\/ We can align up directly to 10000000 by finding the first place after\n+    \/\/ the highest mismatch such that both the corresponding bits are unset.\n+    \/\/ Since all bits lower than the alignment are unset we don't need to\n+    \/\/ align for the violations of ones anymore.\n+    juint last_violation = W - 1 - count_leading_zeros(zero_violation);\n+    T find_mask = std::numeric_limits<T>::max() << last_violation;\n+    T either = lo | bits._zeros;\n+    T tmp = ~either & find_mask;\n+    T alignment = tmp & (-tmp);\n+    lo = (lo & -alignment) + alignment;\n+    return lo | bits._ones;\n+  };\n+\n+  T new_lo = adjust_lo(bounds._lo, bits);\n+  if (new_lo < bounds._lo) {\n+    return {true, false, {}};\n+  }\n+  T new_hi = ~adjust_lo(~bounds._hi, {bits._ones, bits._zeros});\n+  if (new_hi > bounds._hi) {\n+    return {true, false, {}};\n+  }\n+\n+  bool progress = (new_lo != bounds._lo) || (new_hi != bounds._hi);\n+  bool present = new_lo <= new_hi;\n+  return {progress, present, {new_lo, new_hi}};\n+}\n+\n+\/\/ Try to tighten the known bit constraints from the bound information\n+\/\/ E.g: if lo = 0 and hi = 10, then all but the lowest 4 bits must be 0\n+template <class T>\n+static AdjustResult<KnownBits<T>>\n+adjust_bits_from_bounds(const KnownBits<T>& bits, const RangeInt<T>& bounds) {\n+  static_assert(std::is_unsigned<T>::value, \"\");\n+  T mismatch = bounds._lo ^ bounds._hi;\n+  T match_mask = mismatch == 0 ? std::numeric_limits<T>::max()\n+                               : ~(std::numeric_limits<T>::max() >> count_leading_zeros(mismatch));\n+  T new_zeros = bits._zeros | (match_mask &~ bounds._lo);\n+  T new_ones = bits._ones | (match_mask & bounds._lo);\n+  bool progress = (new_zeros != bits._zeros) || (new_ones != bits._ones);\n+  bool present = ((new_zeros & new_ones) == 0);\n+  return {progress, present, {new_zeros, new_ones}};\n+}\n+\n+\/\/ Try to tighten both the bounds and the bits at the same time\n+\/\/ Iteratively tighten 1 using the other until no progress is made.\n+\/\/ This function converges because bit constraints converge fast.\n+template <class T>\n+static NormalizeSimpleResult<T>\n+normalize_constraints_simple(const RangeInt<T>& bounds, const KnownBits<T>& bits) {\n+  AdjustResult<KnownBits<T>> nbits = adjust_bits_from_bounds(bits, bounds);\n+  if (!nbits._present) {\n+    return {false, {}, {}};\n+  }\n+  AdjustResult<RangeInt<T>> nbounds{true, true, bounds};\n+  while (true) {\n+    nbounds = adjust_bounds_from_bits(nbounds._data, nbits._data);\n+    if (!nbounds._progress || !nbounds._present) {\n+      return {nbounds._present, nbounds._data, nbits._data};\n+    }\n+    nbits = adjust_bits_from_bounds(nbits._data, nbounds._data);\n+    if (!nbits._progress || !nbits._present) {\n+      return {nbits._present, nbounds._data, nbits._data};\n+    }\n+  }\n+}\n+\n+\/\/ Tighten all constraints of a TypeIntPrototype to its canonical form.\n+\/\/ i.e the result represents the same set as the input, each bound belongs to\n+\/\/ the set and for each bit position that is not constrained, there exists 2\n+\/\/ values with the bit value at that position being set and unset, respectively,\n+\/\/ such that both belong to the set represented by the constraints.\n+template <class T, class U>\n+Pair<bool, TypeIntPrototype<T, U>>\n+TypeIntPrototype<T, U>::normalize_constraints() const {\n+  static_assert(std::is_signed<T>::value, \"\");\n+  static_assert(std::is_unsigned<U>::value, \"\");\n+  static_assert(sizeof(T) == sizeof(U), \"\");\n+\n+  RangeInt<T> srange = _srange;\n+  RangeInt<U> urange = _urange;\n+  if (srange._lo > srange._hi ||\n+      urange._lo > urange._hi ||\n+      (_bits._zeros & _bits._ones) != 0) {\n+    return {false, {}};\n+  }\n+\n+  if (T(urange._lo) > T(urange._hi)) {\n+    if (T(urange._hi) < srange._lo) {\n+      urange._hi = std::numeric_limits<T>::max();\n+    } else if (T(urange._lo) > srange._hi) {\n+      urange._lo = std::numeric_limits<T>::min();\n+    }\n+  }\n+\n+  if (T(urange._lo) <= T(urange._hi)) {\n+    \/\/ [lo, hi] and [ulo, uhi] represent the same range\n+    urange._lo = MAX2<T>(urange._lo, srange._lo);\n+    urange._hi = MIN2<T>(urange._hi, srange._hi);\n+    if (urange._lo > urange._hi) {\n+      return {false, {}};\n+    }\n+\n+    auto type = normalize_constraints_simple(urange, _bits);\n+    return {type._present, {{T(type._bounds._lo), T(type._bounds._hi)},\n+                            type._bounds, type._bits}};\n+  }\n+\n+  \/\/ [lo, hi] intersects with [ulo, uhi] in 2 ranges:\n+  \/\/ [lo, uhi], which consists of negative values\n+  \/\/ [ulo, hi] which consists of non-negative values\n+  \/\/ We process these 2 separately and combine the results\n+  auto neg_type = normalize_constraints_simple({U(srange._lo), urange._hi}, _bits);\n+  auto pos_type = normalize_constraints_simple({urange._lo, U(srange._hi)}, _bits);\n+\n+  if (!neg_type._present && !pos_type._present) {\n+    return {false, {}};\n+  } else if (!neg_type._present) {\n+    return {true, {{T(pos_type._bounds._lo), T(pos_type._bounds._hi)},\n+                   pos_type._bounds, pos_type._bits}};\n+  } else if (!pos_type._present) {\n+    return {true, {{T(neg_type._bounds._lo), T(neg_type._bounds._hi)},\n+                   neg_type._bounds, neg_type._bits}};\n+  } else {\n+    return {true, {{T(neg_type._bounds._lo), T(pos_type._bounds._hi)},\n+                   {pos_type._bounds._lo, neg_type._bounds._hi},\n+                   {neg_type._bits._zeros & pos_type._bits._zeros, neg_type._bits._ones & pos_type._bits._ones}}};\n+  }\n+}\n+\n+template <class T, class U>\n+int TypeIntPrototype<T, U>::normalize_widen(int w) const {\n+  \/\/ Certain normalizations keep us sane when comparing types.\n+  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n+  if (cardinality_from_bounds(_srange, _urange) <= SMALLINT) {\n+    return Type::WidenMin;\n+  }\n+  if (_srange._lo == std::numeric_limits<T>::min() && _srange._hi == std::numeric_limits<T>::max() &&\n+      _urange._lo == std::numeric_limits<U>::min() && _urange._hi == std::numeric_limits<U>::max() &&\n+      _bits._zeros == 0 && _bits._ones == 0) {\n+    \/\/ bottom type\n+    return Type::WidenMax;\n+  }\n+  return w;\n+}\n+\n+#ifdef ASSERT\n+template <class T, class U>\n+bool TypeIntPrototype<T, U>::contains(T v) const {\n+  return v >= _srange._lo && v <= _srange._hi && U(v) >= _urange._lo && U(v) <= _urange._hi &&\n+         (v & _bits._zeros) == 0 && (~v & _bits._ones) == 0;\n+}\n+\n+\/\/ Verify that this set representation is canonical\n+template <class T, class U>\n+void TypeIntPrototype<T, U>::verify_constraints() const {\n+  static_assert(std::is_signed<T>::value, \"\");\n+  static_assert(std::is_unsigned<U>::value, \"\");\n+  static_assert(sizeof(T) == sizeof(U), \"\");\n+\n+  \/\/ Assert that the bounds cannot be further tightened\n+  assert(contains(_srange._lo) && contains(_srange._hi) &&\n+         contains(_urange._lo) && contains(_urange._hi), \"\");\n+\n+  \/\/ Assert that the bits cannot be further tightened\n+  if (U(_srange._lo) == _urange._lo) {\n+    assert(!adjust_bits_from_bounds(_bits, _urange)._progress, \"\");\n+  } else {\n+    RangeInt<U> neg_range{U(_srange._lo), _urange._hi};\n+    auto neg_bits = adjust_bits_from_bounds(_bits, neg_range);\n+    assert(neg_bits._present, \"\");\n+    assert(!adjust_bounds_from_bits(neg_range, neg_bits._data)._progress, \"\");\n+\n+    RangeInt<U> pos_range{_urange._lo, U(_srange._hi)};\n+    auto pos_bits = adjust_bits_from_bounds(_bits, pos_range);\n+    assert(pos_bits._present, \"\");\n+    assert(!adjust_bounds_from_bits(pos_range, pos_bits._data)._progress, \"\");\n+\n+    assert((neg_bits._data._zeros & pos_bits._data._zeros) == _bits._zeros &&\n+           (neg_bits._data._ones & pos_bits._data._ones) == _bits._ones, \"\");\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+template class TypeIntPrototype<jint, juint>;\n+template class TypeIntPrototype<jlong, julong>;\n+\n+\/\/ Compute the meet of 2 types, when dual is true, we are actually computing the\n+\/\/ join.\n+template <class CT, class T, class UT>\n+const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<T, UT>&, int, bool), bool dual) {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if (i1 == t2 || t2 == Type::TOP) {\n+    return i1;\n+  }\n+  const CT* i2 = CT::try_cast(t2);\n+  if (i2 != nullptr) {\n+    if (!dual) {\n+    \/\/ meet\n+      return make(TypeIntPrototype<T, UT>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n+                                          {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n+                                          {i1->_zeros & i2->_zeros, i1->_ones & i2->_ones}},\n+                  MAX2(i1->_widen, i2->_widen), false);\n+    }\n+    \/\/ join\n+    return make(TypeIntPrototype<T, UT>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n+                                        {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n+                                        {i1->_zeros | i2->_zeros, i1->_ones | i2->_ones}},\n+                MIN2(i1->_widen, i2->_widen), true);\n+  }\n+\n+  assert(t2->base() != i1->base(), \"\");\n+  switch (t2->base()) {          \/\/ Switch on original type\n+  case Type::AnyPtr:                  \/\/ Mixing with oops happens when javac\n+  case Type::RawPtr:                  \/\/ reuses local variables\n+  case Type::OopPtr:\n+  case Type::InstPtr:\n+  case Type::AryPtr:\n+  case Type::MetadataPtr:\n+  case Type::KlassPtr:\n+  case Type::InstKlassPtr:\n+  case Type::AryKlassPtr:\n+  case Type::NarrowOop:\n+  case Type::NarrowKlass:\n+  case Type::Int:\n+  case Type::Long:\n+  case Type::FloatTop:\n+  case Type::FloatCon:\n+  case Type::FloatBot:\n+  case Type::DoubleTop:\n+  case Type::DoubleCon:\n+  case Type::DoubleBot:\n+  case Type::Bottom:                  \/\/ Ye Olde Default\n+    return Type::BOTTOM;\n+  default:                      \/\/ All else is a mistake\n+    i1->typerr(t2);\n+    return nullptr;\n+  }\n+}\n+template const Type* int_type_xmeet(const TypeInt* i1, const Type* t2,\n+                                    const Type* (*make)(const TypeIntPrototype<jint, juint>&, int, bool), bool dual);\n+template const Type* int_type_xmeet(const TypeLong* i1, const Type* t2,\n+                                    const Type* (*make)(const TypeIntPrototype<jlong, julong>&, int, bool), bool dual);\n+\n+\/\/ Called in PhiNode::Value during CCP, monotically widen the value set, do so rigorously\n+\/\/ first, after WidenMax attempts, if the type has still not converged we speed up the\n+\/\/ convergence by abandoning the bounds\n+template <class CT>\n+const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+\n+  if (ot == nullptr) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no widening\n+  if (int_type_equal(nt, ot)) {\n+    return ot;\n+  }\n+\n+  \/\/ If old guy contains new, then we probably widened too far & dropped to\n+  \/\/ bottom. Return the wider fellow.\n+  if (int_type_subset(ot, nt)) {\n+    return ot;\n+  }\n+\n+  \/\/ Neither contains each other, weird?\n+  \/\/ fatal(\"Integer value range is not subset\");\n+  \/\/ return this;\n+  if (!int_type_subset(nt, ot)) {\n+    return CT::TYPE_DOMAIN;\n+  }\n+\n+  \/\/ If old guy was a constant, do not bother\n+  if (ot->singleton()) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy contains old, then we widened\n+  \/\/ If new guy is already wider than old, no widening\n+  if (nt->_widen > ot->_widen) {\n+    return nt;\n+  }\n+\n+  if (nt->_widen < Type::WidenMax) {\n+    \/\/ Returned widened new guy\n+    TypeIntPrototype<T, U> prototype{{nt->_lo, nt->_hi}, {nt->_ulo, nt->_uhi}, {nt->_zeros, nt->_ones}};\n+    return CT::make(prototype, nt->_widen + 1);\n+  }\n+\n+  \/\/ Speed up the convergence by abandoning the bounds, there are only a couple of bits so\n+  \/\/ they converge fast\n+  T min = std::numeric_limits<T>::min();\n+  T max = std::numeric_limits<T>::max();\n+  U umin = std::numeric_limits<U>::min();\n+  U umax = std::numeric_limits<U>::max();\n+  U zeros = nt->_zeros;\n+  U ones = nt->_ones;\n+  if (lt != nullptr) {\n+    min = lt->_lo;\n+    max = lt->_hi;\n+    umin = lt->_ulo;\n+    umax = lt->_uhi;\n+    zeros |= lt->_zeros;\n+    ones |= lt->_ones;\n+  }\n+  TypeIntPrototype<T, U> prototype{{min, max}, {umin, umax}, {zeros, ones}};\n+  return CT::make(prototype, Type::WidenMax);\n+}\n+template const Type* int_type_widen(const TypeInt* nt, const TypeInt* ot, const TypeInt* lt);\n+template const Type* int_type_widen(const TypeLong* nt, const TypeLong* ot, const TypeLong* lt);\n+\n+\/\/ Called by PhiNode::Value during GVN, monotonically narrow the value set, only\n+\/\/ narrow if the bits change or if the bounds are tightened enough to avoid\n+\/\/ slow convergence\n+template <class CT>\n+const Type* int_type_narrow(const CT* nt, const CT* ot) {\n+  using T = decltype(CT::_lo);\n+  using U = decltype(CT::_ulo);\n+\n+  if (nt->singleton() || ot == nullptr) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no narrowing\n+  if (int_type_equal(nt, ot)) {\n+    return ot;\n+  }\n+\n+  \/\/ If old guy was maximum range, allow the narrowing\n+  if (int_type_equal(ot, CT::TYPE_DOMAIN)) {\n+    return nt;\n+  }\n+\n+  \/\/ Doesn't narrow; pretty weird\n+  if (!int_type_subset(ot, nt)) {\n+    return nt;\n+  }\n+\n+  \/\/ Bits change\n+  if (ot->_zeros != nt->_zeros || ot->_ones != nt->_ones) {\n+    return nt;\n+  }\n+\n+  \/\/ Only narrow if the range shrinks a lot\n+  U oc = cardinality_from_bounds(RangeInt<T>{ot->_lo, ot->_hi},\n+                                 RangeInt<U>{ot->_ulo, ot->_uhi});\n+  U nc = cardinality_from_bounds(RangeInt<T>{nt->_lo, nt->_hi},\n+                                 RangeInt<U>{nt->_ulo, nt->_uhi});\n+  return (nc > (oc >> 1) + (SMALLINT * 2)) ? ot : nt;\n+}\n+template const Type* int_type_narrow(const TypeInt* nt, const TypeInt* ot);\n+template const Type* int_type_narrow(const TypeLong* nt, const TypeLong* ot);\n+\n+\n+#ifndef PRODUCT\n+template <class T>\n+static const char* intnamenear(T origin, const char* xname, char* buf, size_t buf_size, T n) {\n+  if (n < origin) {\n+    if (n <= origin - 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s-\" INT32_FORMAT, xname, jint(origin - n));\n+  } else if (n > origin) {\n+    if (n >= origin + 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s+\" INT32_FORMAT, xname, jint(n - origin));\n+  } else {\n+    return xname;\n+  }\n+  return buf;\n+}\n+\n+const char* intname(char* buf, size_t buf_size, jint n) {\n+  const char* str = intnamenear<jint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jint>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n+  return buf;\n+}\n+\n+const char* uintname(char* buf, size_t buf_size, juint n) {\n+  const char* str = intnamenear<juint>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<juint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, UINT32_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n+const char* longname(char* buf, size_t buf_size, jlong n) {\n+  const char* str = intnamenear<jlong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jlong>(min_jlong, \"minlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jlong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jlong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jlong>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n+  return buf;\n+}\n+\n+const char* ulongname(char* buf, size_t buf_size, julong n) {\n+  const char* str = intnamenear<julong>(max_julong, \"maxulong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<julong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<julong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<julong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JULONG_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n+template <class U>\n+const char* bitname(char* buf, size_t buf_size, U zeros, U ones) {\n+  constexpr juint W = sizeof(U) * 8;\n+\n+  if (buf_size < W + 1) {\n+    return \"#####\";\n+  }\n+\n+  for (juint i = 0; i < W; i++) {\n+    U mask = U(1) << (W - 1 - i);\n+    if ((zeros & mask) != 0) {\n+      buf[i] = '0';\n+    } else if ((ones & mask) != 0) {\n+      buf[i] = '1';\n+    } else {\n+      buf[i] = '*';\n+    }\n+  }\n+  buf[W] = 0;\n+  return buf;\n+}\n+template const char* bitname(char* buf, size_t buf_size, juint zeros, juint ones);\n+template const char* bitname(char* buf, size_t buf_size, julong zeros, julong ones);\n+#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":559,"deletions":0,"binary":false,"changes":559,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_RANGEINFERENCE_HPP\n+#define SHARE_OPTO_RANGEINFERENCE_HPP\n+\n+#include \"utilities\/pair.hpp\"\n+\n+class Type;\n+\n+template <class T>\n+class RangeInt {\n+public:\n+  T _lo;\n+  T _hi;\n+};\n+\n+template <class T>\n+class KnownBits {\n+public:\n+  T _zeros;\n+  T _ones;\n+};\n+\n+template <class T, class U>\n+class TypeIntPrototype {\n+public:\n+  RangeInt<T> _srange;\n+  RangeInt<U> _urange;\n+  KnownBits<U> _bits;\n+\n+  Pair<bool, TypeIntPrototype<T, U>> normalize_constraints() const;\n+  int normalize_widen(int w) const;\n+#ifdef ASSERT\n+  bool contains(T v) const;\n+  void verify_constraints() const;\n+#endif \/\/ ASSERT\n+};\n+\n+\/\/ The result is tuned down by one since we do not have empty type\n+\/\/ and this is not required to be accurate\n+template <class T, class U>\n+U cardinality_from_bounds(const RangeInt<T>& srange, const RangeInt<U>& urange) {\n+  if (U(srange._lo) == urange._lo) {\n+    return urange._hi - urange._lo;\n+  }\n+\n+  return urange._hi - U(srange._lo) + U(srange._hi) - urange._lo + 1;\n+}\n+\n+template <class CT, class T, class UT>\n+const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<T, UT>&, int, bool), bool dual);\n+\n+template <class CT>\n+bool int_type_equal(const CT* t1, const CT* t2) {\n+  return t1->_lo == t2->_lo && t1->_hi == t2->_hi && t1->_ulo == t2->_ulo && t1->_uhi == t2->_uhi &&\n+         t1->_zeros == t2->_zeros && t1->_ones == t2->_ones;\n+}\n+\n+template <class CT>\n+bool int_type_subset(const CT* super, const CT* sub) {\n+  return super->_lo <= sub->_lo && super->_hi >= sub->_hi && super->_ulo <= sub->_ulo && super->_uhi >= sub->_uhi &&\n+         (super->_zeros &~ sub->_zeros) == 0 && (super->_ones &~ sub->_ones) == 0;\n+}\n+\n+template <class CT>\n+const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt);\n+\n+template <class CT>\n+const Type* int_type_narrow(const CT* nt, const CT* ot);\n+\n+#ifndef PRODUCT\n+const char* intname(char* buf, size_t buf_size, jint n);\n+const char* uintname(char* buf, size_t buf_size, juint n);\n+const char* longname(char* buf, size_t buf_size, jlong n);\n+const char* ulongname(char* buf, size_t buf_size, julong n);\n+\n+template <class U>\n+const char* bitname(char* buf, size_t buf_size, U zeros, U ones);\n+#endif \/\/ PRODUCT\n+\n+#endif \/\/ SHARE_OPTO_RANGEINFERENCE_HPP\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -851,2 +851,2 @@\n-        const TypeInt* tr1 = TypeInt::make(lo_tr1, hi_tr1, w);\n-        const TypeInt* tr2 = TypeInt::make(lo_tr2, hi_tr2, w);\n+        const TypeInt* tr1 = TypeInt::make(lo_tr1, hi_tr1, w)->is_int();\n+        const TypeInt* tr2 = TypeInt::make(lo_tr2, hi_tr2, w)->is_int();\n@@ -1463,2 +1463,2 @@\n-        const TypeInt* tr1 = TypeInt::make(min_jint, hi_int, w);\n-        const TypeInt* tr2 = TypeInt::make(lo_int, max_jint, w);\n+        const TypeInt* tr1 = TypeInt::make(min_jint, hi_int, w)->is_int();\n+        const TypeInt* tr2 = TypeInt::make(lo_int, max_jint, w)->is_int();\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -423,1 +424,0 @@\n-#define SMALLINT ((juint)3)  \/\/ a value too insignificant to consider widening\n@@ -477,16 +477,18 @@\n-  TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n-  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n-  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n-  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n-  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n-  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);\n-  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n-  TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); \/\/ Bytes\n-  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); \/\/ Unsigned Bytes\n-  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); \/\/ Java chars\n-  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); \/\/ Java shorts\n-  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); \/\/ Non-neg values\n-  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); \/\/ Positive values\n-  TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); \/\/ 32-bit integers\n-  TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); \/\/ symmetric range\n-  TypeInt::TYPE_DOMAIN  = TypeInt::INT;\n+  TypeInt::BOOL    = TypeInt::make( 0, 1, WidenMin)->is_int();  \/\/ 0 or 1, FALSE or TRUE.\n+  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin)->is_int();  \/\/ -1, 0 or 1, condition codes\n+  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin)->is_int();  \/\/ == TypeInt::MINUS_1\n+  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin)->is_int();  \/\/ == TypeInt::ONE\n+  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin)->is_int();  \/\/ == TypeInt::ZERO\n+  TypeInt::CC_NE   = TypeInt::make(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n+  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin)->is_int();\n+  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin)->is_int();  \/\/ == TypeInt::BOOL\n+  TypeInt::BYTE    = TypeInt::make(-128, 127,    WidenMin)->is_int(); \/\/ Bytes\n+  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin)->is_int(); \/\/ Unsigned Bytes\n+  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin)->is_int(); \/\/ Java chars\n+  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin)->is_int(); \/\/ Java shorts\n+  TypeInt::NON_ZERO= TypeInt::make(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n+  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin)->is_int(); \/\/ Non-neg values\n+  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin)->is_int(); \/\/ Positive values\n+  TypeInt::INT     = TypeInt::make(min_jint, max_jint, WidenMax)->is_int(); \/\/ 32-bit integers\n+  TypeInt::SYMINT  = TypeInt::make(-max_jint, max_jint, WidenMin)->is_int(); \/\/ symmetric range\n+  TypeInt::TYPE_DOMAIN = TypeInt::INT;\n@@ -500,1 +502,0 @@\n-  assert( (juint)(TypeInt::CC->_hi - TypeInt::CC->_lo) <= SMALLINT, \"CC is truly small\");\n@@ -507,4 +508,6 @@\n-  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); \/\/ Non-neg values\n-  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); \/\/ 64-bit integers\n-  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);\n-  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);\n+  TypeLong::NON_ZERO= TypeLong::make(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n+  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin)->is_long(); \/\/ Non-neg values\n+  TypeLong::NEG     = TypeLong::make(min_jlong, -1, WidenMin)->is_long();\n+  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax)->is_long(); \/\/ 64-bit integers\n+  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin)->is_long();\n+  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin)->is_long();\n@@ -1518,1 +1521,1 @@\n-const TypeInteger* TypeInteger::make(jlong lo, jlong hi, int w, BasicType bt) {\n+const Type* TypeInteger::make(jlong lo, jlong hi, int w, BasicType bt) {\n@@ -1568,25 +1571,23 @@\n-const TypeInt *TypeInt::MAX;    \/\/ INT_MAX\n-const TypeInt *TypeInt::MIN;    \/\/ INT_MIN\n-const TypeInt *TypeInt::MINUS_1;\/\/ -1\n-const TypeInt *TypeInt::ZERO;   \/\/ 0\n-const TypeInt *TypeInt::ONE;    \/\/ 1\n-const TypeInt *TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n-const TypeInt *TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n-const TypeInt *TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n-const TypeInt *TypeInt::CC_GT;  \/\/ [1]   == ONE\n-const TypeInt *TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n-const TypeInt *TypeInt::CC_LE;  \/\/ [-1,0]\n-const TypeInt *TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n-const TypeInt *TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n-const TypeInt *TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n-const TypeInt *TypeInt::CHAR;   \/\/ Java chars, 0-65535\n-const TypeInt *TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n-const TypeInt *TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n-const TypeInt *TypeInt::POS1;   \/\/ Positive 32-bit integers\n-const TypeInt *TypeInt::INT;    \/\/ 32-bit integers\n-const TypeInt *TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-const TypeInt *TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-\/\/------------------------------TypeInt----------------------------------------\n-TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int, w), _lo(lo), _hi(hi) {\n-}\n+const TypeInt* TypeInt::MAX;    \/\/ INT_MAX\n+const TypeInt* TypeInt::MIN;    \/\/ INT_MIN\n+const TypeInt* TypeInt::MINUS_1;\/\/ -1\n+const TypeInt* TypeInt::ZERO;   \/\/ 0\n+const TypeInt* TypeInt::ONE;    \/\/ 1\n+const TypeInt* TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n+const TypeInt* TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n+const TypeInt* TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n+const TypeInt* TypeInt::CC_GT;  \/\/ [1]   == ONE\n+const TypeInt* TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n+const TypeInt* TypeInt::CC_NE;\n+const TypeInt* TypeInt::CC_LE;  \/\/ [-1,0]\n+const TypeInt* TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n+const TypeInt* TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n+const TypeInt* TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n+const TypeInt* TypeInt::CHAR;   \/\/ Java chars, 0-65535\n+const TypeInt* TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n+const TypeInt* TypeInt::NON_ZERO;\n+const TypeInt* TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n+const TypeInt* TypeInt::POS1;   \/\/ Positive 32-bit integers\n+const TypeInt* TypeInt::INT;    \/\/ 32-bit integers\n+const TypeInt* TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+const TypeInt* TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n@@ -1594,3 +1595,5 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeInt *TypeInt::make( jint lo ) {\n-  return (TypeInt*)(new TypeInt(lo,lo,WidenMin))->hashcons();\n+TypeInt::TypeInt(const TypeIntPrototype<jint, juint>& t, int w, bool dual)\n+  : TypeInteger(Int, t.normalize_widen(w), dual),\n+    _lo(t._srange._lo), _hi(t._srange._hi), _ulo(t._urange._lo), _uhi(t._urange._hi),\n+    _zeros(t._bits._zeros), _ones(t._bits._ones) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -1599,9 +1602,4 @@\n-static int normalize_int_widen( jint lo, jint hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n-  if (lo <= hi) {\n-    if (((juint)hi - lo) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)hi - lo) >= max_juint) w = Type::WidenMax; \/\/ TypeInt::INT\n-  } else {\n-    if (((juint)lo - hi) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)lo - hi) >= max_juint) w = Type::WidenMin; \/\/ dual TypeInt::INT\n+const Type* TypeInt::make(const TypeIntPrototype<jint, juint>& t, int w, bool dual) {\n+  auto new_t = t.normalize_constraints();\n+  if (!new_t.first) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -1609,1 +1607,1 @@\n-  return w;\n+  return (new TypeInt(new_t.second, w, dual))->hashcons()->is_int();\n@@ -1612,3 +1610,4 @@\n-const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {\n-  w = normalize_int_widen(lo, hi, w);\n-  return (TypeInt*)(new TypeInt(lo,hi,w))->hashcons();\n+const TypeInt* TypeInt::make(jint lo) {\n+  juint ulo = lo;\n+  return (new TypeInt(TypeIntPrototype<jint, juint>{{lo, lo}, {ulo, ulo}, {~ulo, ulo}},\n+                      WidenMin, false))->hashcons()->is_int();\n@@ -1617,41 +1616,2 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeInt::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeInt\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Long:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Int:                     \/\/ Int vs Int?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeInt *r = t->is_int();\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const Type* TypeInt::make(jint lo, jint hi, int w) {\n+  return make(TypeIntPrototype<jint, juint>{{lo, hi}, {0, max_juint}, {0, 0}}, w);\n@@ -1660,50 +1620,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeInt::xdual() const {\n-  int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeInt(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeInt::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Int ) return this;\n-  const TypeInt *ot = old->is_int();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      int max = max_jint;\n-      int min = min_jint;\n-      if (limit->isa_int()) {\n-        max = limit->is_int()->_hi;\n-        min = limit->is_int()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((juint)_lo - min) >= ((juint)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 31 bits:\n-          return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeInt::INT;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n+const Type* TypeInt::make(const TypeIntPrototype<jint, juint>& t, int w) {\n+  return make(t, w, false);\n+}\n@@ -1711,4 +1624,5 @@\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+bool TypeInt::contains(jint i) const {\n+  juint u = i;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi &&\n+         (u & _zeros) == 0 && (~u & _ones) == 0;\n+}\n@@ -1716,3 +1630,2 @@\n-  \/\/fatal(\"Integer value range is not subset\");\n-  \/\/return this;\n-  return TypeInt::INT;\n+bool TypeInt::contains(const TypeInt* t) const {\n+  return int_type_subset(this, t);\n@@ -1721,9 +1634,3 @@\n-\/\/------------------------------narrow---------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeInt::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeInt* ot = old->isa_int();\n-  if (ot == nullptr)  return this;\n-  jint olo = ot->_lo;\n-  jint ohi = ot->_hi;\n+bool TypeInt::properly_contains(const TypeInt* t) const {\n+  return int_type_subset(this, t) && !int_type_equal(this, t);\n+}\n@@ -1731,2 +1638,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type* TypeInt::xmeet(const Type* t) const {\n+  return int_type_xmeet(this, t, TypeInt::make, _dual);\n+}\n@@ -1734,2 +1642,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jint && ohi == max_jint)  return this;\n+const Type* TypeInt::xdual() const {\n+  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, {_zeros, _ones}},\n+                     _widen, !_dual);\n+}\n@@ -1737,2 +1647,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeInt::widen(const Type* old, const Type* limit) const {\n+  assert(!_dual, \"dual types should only be used for join calculation\");\n+  return int_type_widen(this, old->isa_int(), limit->isa_int());\n+}\n@@ -1740,8 +1652,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  juint nrange = (juint)_hi - _lo;\n-  juint orange = (juint)ohi - olo;\n-  if (nrange < max_juint - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeInt::narrow(const Type* old) const {\n+  assert(!_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -1750,1 +1658,1 @@\n-  return this;\n+  return int_type_narrow(this, old->isa_int());\n@@ -1754,1 +1662,2 @@\n-const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeInt::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_dual, \"dual types should only be used for join calculation\");\n@@ -1756,1 +1665,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -1758,0 +1667,2 @@\n+  }\n+  assert(!ft->_dual, \"dual types should only be used for join calculation\");\n@@ -1761,1 +1672,3 @@\n-    ft = TypeInt::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeInt(TypeIntPrototype<jint, juint>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi},\n+                                                      {ft->_zeros, ft->_ones}},\n+                        this->_widen, false))->hashcons();\n@@ -1768,3 +1681,3 @@\n-bool TypeInt::eq( const Type *t ) const {\n-  const TypeInt *r = t->is_int(); \/\/ Handy access\n-  return r->_lo == _lo && r->_hi == _hi && r->_widen == _widen;\n+bool TypeInt::eq(const Type* t) const {\n+  const TypeInt* r = t->is_int();\n+  return int_type_equal(this, r) && _widen == r->_widen && _dual == r->_dual;\n@@ -1776,1 +1689,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Int;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_dual + (uint)Type::Int;\n@@ -1785,43 +1699,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeInt\n-#ifndef PRODUCT\n-static const char* intname(char* buf, size_t buf_size, jint n) {\n-  if (n == min_jint)\n-    return \"min\";\n-  else if (n < min_jint + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" INT32_FORMAT, n - min_jint);\n-  else if (n == max_jint)\n-    return \"max\";\n-  else if (n > max_jint - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" INT32_FORMAT, max_jint - n);\n-  else\n-    os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[40], buf2[40];\n-  if (_lo == min_jint && _hi == max_jint)\n-    st->print(\"int\");\n-  else if (is_con())\n-    st->print(\"int:%s\", intname(buf, sizeof(buf), get_con()));\n-  else if (_lo == BOOL->_lo && _hi == BOOL->_hi)\n-    st->print(\"bool\");\n-  else if (_lo == BYTE->_lo && _hi == BYTE->_hi)\n-    st->print(\"byte\");\n-  else if (_lo == CHAR->_lo && _hi == CHAR->_hi)\n-    st->print(\"char\");\n-  else if (_lo == SHORT->_lo && _hi == SHORT->_hi)\n-    st->print(\"short\");\n-  else if (_hi == max_jint)\n-    st->print(\"int:>=%s\", intname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jint)\n-    st->print(\"int:<=%s\", intname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"int:%s..%s\", intname(buf, sizeof(buf), _lo), intname(buf2, sizeof(buf2), _hi));\n-\n-  if (_widen != 0 && this != TypeInt::INT)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -1832,1 +1703,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -1836,1 +1707,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -1841,10 +1712,12 @@\n-const TypeLong *TypeLong::MAX;\n-const TypeLong *TypeLong::MIN;\n-const TypeLong *TypeLong::MINUS_1;\/\/ -1\n-const TypeLong *TypeLong::ZERO; \/\/ 0\n-const TypeLong *TypeLong::ONE;  \/\/ 1\n-const TypeLong *TypeLong::POS;  \/\/ >=0\n-const TypeLong *TypeLong::LONG; \/\/ 64-bit integers\n-const TypeLong *TypeLong::INT;  \/\/ 32-bit subrange\n-const TypeLong *TypeLong::UINT; \/\/ 32-bit unsigned subrange\n-const TypeLong *TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+const TypeLong* TypeLong::MAX;\n+const TypeLong* TypeLong::MIN;\n+const TypeLong* TypeLong::MINUS_1;\/\/ -1\n+const TypeLong* TypeLong::ZERO; \/\/ 0\n+const TypeLong* TypeLong::ONE;  \/\/ 1\n+const TypeLong* TypeLong::NON_ZERO;\n+const TypeLong* TypeLong::POS;  \/\/ >=0\n+const TypeLong* TypeLong::NEG;\n+const TypeLong* TypeLong::LONG; \/\/ 64-bit integers\n+const TypeLong* TypeLong::INT;  \/\/ 32-bit subrange\n+const TypeLong* TypeLong::UINT; \/\/ 32-bit unsigned subrange\n+const TypeLong* TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -1852,7 +1725,5 @@\n-\/\/------------------------------TypeLong---------------------------------------\n-TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long, w), _lo(lo), _hi(hi) {\n-}\n-\n-\/\/------------------------------make-------------------------------------------\n-const TypeLong *TypeLong::make( jlong lo ) {\n-  return (TypeLong*)(new TypeLong(lo,lo,WidenMin))->hashcons();\n+TypeLong::TypeLong(const TypeIntPrototype<jlong, julong>& t, int w, bool dual)\n+  : TypeInteger(Long, t.normalize_widen(w), dual),\n+    _lo(t._srange._lo), _hi(t._srange._hi), _ulo(t._urange._lo), _uhi(t._urange._hi),\n+    _zeros(t._bits._zeros), _ones(t._bits._ones) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -1861,9 +1732,4 @@\n-static int normalize_long_widen( jlong lo, jlong hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants.\n-  if (lo <= hi) {\n-    if (((julong)hi - lo) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)hi - lo) >= max_julong) w = Type::WidenMax; \/\/ TypeLong::LONG\n-  } else {\n-    if (((julong)lo - hi) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)lo - hi) >= max_julong) w = Type::WidenMin; \/\/ dual TypeLong::LONG\n+const Type* TypeLong::make(const TypeIntPrototype<jlong, julong>& t, int w, bool dual) {\n+  auto new_t = t.normalize_constraints();\n+  if (!new_t.first) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -1871,1 +1737,1 @@\n-  return w;\n+  return (new TypeLong(new_t.second, w, dual))->hashcons()->is_long();\n@@ -1874,3 +1740,4 @@\n-const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {\n-  w = normalize_long_widen(lo, hi, w);\n-  return (TypeLong*)(new TypeLong(lo,hi,w))->hashcons();\n+const TypeLong* TypeLong::make(jlong lo) {\n+  julong ulo = lo;\n+  return (new TypeLong(TypeIntPrototype<jlong, julong>{{lo, lo}, {ulo, ulo}, {~ulo, ulo}},\n+                       WidenMin, false))->hashcons()->is_long();\n@@ -1879,42 +1746,2 @@\n-\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeLong::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeLong\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Long:                    \/\/ Long vs Long?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeLong *r = t->is_long(); \/\/ Turn into a TypeLong\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const Type* TypeLong::make(jlong lo, jlong hi, int w) {\n+  return make(TypeIntPrototype<jlong, julong>{{lo, hi}, {0, max_julong}, {0, 0}}, w);\n@@ -1923,53 +1750,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeLong::xdual() const {\n-  int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeLong(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeLong::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Long ) return this;\n-  const TypeLong *ot = old->is_long();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      jlong max = max_jlong;\n-      jlong min = min_jlong;\n-      if (limit->isa_long()) {\n-        max = limit->is_long()->_hi;\n-        min = limit->is_long()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((julong)_lo - min) >= ((julong)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 32\/63 bits:\n-          if (max >= max_juint && _hi < max_juint)\n-            return make(_lo, max_juint, WidenMax);\n-          else\n-            return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeLong::LONG;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n+const Type* TypeLong::make(const TypeIntPrototype<jlong, julong>& t, int w) {\n+  return make(t, w, false);\n+}\n@@ -1977,4 +1754,5 @@\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+bool TypeLong::contains(jlong i) const {\n+  julong u = i;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi &&\n+         (u & _zeros) == 0 && (~u & _ones) == 0;\n+}\n@@ -1982,3 +1760,2 @@\n-  \/\/  fatal(\"Long value range is not subset\");\n-  \/\/ return this;\n-  return TypeLong::LONG;\n+bool TypeLong::contains(const TypeLong* t) const {\n+  return int_type_subset(this, t);\n@@ -1987,9 +1764,3 @@\n-\/\/------------------------------narrow----------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeLong::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeLong* ot = old->isa_long();\n-  if (ot == nullptr)  return this;\n-  jlong olo = ot->_lo;\n-  jlong ohi = ot->_hi;\n+bool TypeLong::properly_contains(const TypeLong* t) const {\n+  return int_type_subset(this, t) && !int_type_equal(this, t);\n+}\n@@ -1997,2 +1768,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type *TypeLong::xmeet(const Type* t) const {\n+  return int_type_xmeet(this, t, TypeLong::make, _dual);\n+}\n@@ -2000,2 +1772,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jlong && ohi == max_jlong)  return this;\n+const Type* TypeLong::xdual() const {\n+  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, {_zeros, _ones}},\n+                      _widen, !_dual);\n+}\n@@ -2003,2 +1777,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeLong::widen(const Type* old, const Type* limit) const {\n+  assert(!_dual, \"dual types should only be used for join calculation\");\n+  return int_type_widen(this, old->isa_long(), limit->isa_long());\n+}\n@@ -2006,8 +1782,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  julong nrange = (julong)_hi - _lo;\n-  julong orange = (julong)ohi - olo;\n-  if (nrange < max_julong - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeLong::narrow(const Type* old) const {\n+  assert(!_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -2016,1 +1788,1 @@\n-  return this;\n+  return int_type_narrow(this, old->isa_long());\n@@ -2020,1 +1792,2 @@\n-const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeLong::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_dual, \"dual types should only be used for join calculation\");\n@@ -2022,1 +1795,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -2024,0 +1797,2 @@\n+  }\n+  assert(!ft->_dual, \"dual types should only be used for join calculation\");\n@@ -2027,1 +1802,3 @@\n-    ft = TypeLong::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeLong(TypeIntPrototype<jlong, julong>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi},\n+                                                         {ft->_zeros, ft->_ones}},\n+                         this->_widen, false))->hashcons();\n@@ -2034,3 +1811,3 @@\n-bool TypeLong::eq( const Type *t ) const {\n-  const TypeLong *r = t->is_long(); \/\/ Handy access\n-  return r->_lo == _lo &&  r->_hi == _hi  && r->_widen == _widen;\n+bool TypeLong::eq(const Type* t) const {\n+  const TypeLong* r = t->is_long();\n+  return int_type_equal(this, r) && _widen == r->_widen && _dual == r->_dual;\n@@ -2042,1 +1819,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Long;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_dual + (uint)Type::Long;\n@@ -2051,0 +1829,11 @@\n+\/\/------------------------------singleton--------------------------------------\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n+\/\/ constants\n+bool TypeLong::singleton(void) const {\n+  return _lo == _hi;\n+}\n+\n+bool TypeLong::empty(void) const {\n+  return false;\n+}\n+\n@@ -2052,1 +1841,0 @@\n-\/\/ Dump TypeLong\n@@ -2054,7 +1842,14 @@\n-static const char* longnamenear(jlong x, const char* xname, char* buf, size_t buf_size, jlong n) {\n-  if (n > x) {\n-    if (n >= x + 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s+\" JLONG_FORMAT, xname, n - x);\n-  } else if (n < x) {\n-    if (n <= x - 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s-\" JLONG_FORMAT, xname, x - n);\n+void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n+  char buf1[40], buf2[40], buf3[40], buf4[40], buf5[40];\n+  if (int_type_equal(this, TypeInt::INT)) {\n+    st->print(\"int\");\n+  } else if (is_con()) {\n+    st->print(\"int:%s\", intname(buf1, sizeof(buf1), get_con()));\n+  } else if (int_type_equal(this, TypeInt::BOOL)) {\n+    st->print(\"bool\");\n+  } else if (int_type_equal(this, TypeInt::BYTE)) {\n+    st->print(\"byte\");\n+  } else if (int_type_equal(this, TypeInt::CHAR)) {\n+    st->print(\"char\");\n+  } else if (int_type_equal(this, TypeInt::SHORT)) {\n+    st->print(\"short\");\n@@ -2062,24 +1857,9 @@\n-    return xname;\n-  }\n-  return buf;\n-}\n-\n-static const char* longname(char* buf, size_t buf_size, jlong n) {\n-  const char* str;\n-  if (n == min_jlong)\n-    return \"min\";\n-  else if (n < min_jlong + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" JLONG_FORMAT, n - min_jlong);\n-  else if (n == max_jlong)\n-    return \"max\";\n-  else if (n > max_jlong - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" JLONG_FORMAT, max_jlong - n);\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else\n-    os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n-  return buf;\n+    st->print(\"int:%s..%s ^ %s..%s, bits:%s\",\n+              intname(buf1, sizeof(buf1), _lo), intname(buf2, sizeof(buf2), _hi),\n+              uintname(buf3, sizeof(buf3), _ulo), uintname(buf4, sizeof(buf4), _uhi),\n+              bitname(buf5, sizeof(buf5), _zeros, _ones));\n+  }\n+\n+  if (_widen > 0 && this != TypeInt::INT) {\n+    st->print(\", widen: %d\", _widen);\n+  }\n@@ -2089,2 +1869,2 @@\n-  char buf[80], buf2[80];\n-  if (_lo == min_jlong && _hi == max_jlong)\n+  char buf1[80], buf2[80], buf3[80], buf4[80], buf5[80];\n+  if (int_type_equal(this, TypeLong::LONG)) {\n@@ -2092,8 +1872,8 @@\n-  else if (is_con())\n-    st->print(\"long:%s\", longname(buf, sizeof(buf), get_con()));\n-  else if (_hi == max_jlong)\n-    st->print(\"long:>=%s\", longname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jlong)\n-    st->print(\"long:<=%s\", longname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"long:%s..%s\", longname(buf, sizeof(buf), _lo), longname(buf2,sizeof(buf2),  _hi));\n+  } else if (is_con()) {\n+    st->print(\"long:%s\", longname(buf1, sizeof(buf1), get_con()));\n+  } else {\n+    st->print(\"long:%s..%s ^ %s..%s, bits:%s\",\n+              longname(buf1, sizeof(buf1), _lo), longname(buf2,sizeof(buf2),  _hi),\n+              ulongname(buf3, sizeof(buf3), _ulo), ulongname(buf4, sizeof(buf4), _uhi),\n+              bitname(buf5, sizeof(buf5), _zeros, _ones));\n+  }\n@@ -2101,2 +1881,3 @@\n-  if (_widen != 0 && this != TypeLong::LONG)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n+  if (_widen > 0 && this != TypeLong::LONG) {\n+    st->print(\", widen: %d\", _widen);\n+  }\n@@ -2106,11 +1887,0 @@\n-\/\/------------------------------singleton--------------------------------------\n-\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n-\/\/ constants\n-bool TypeLong::singleton(void) const {\n-  return _lo >= _hi;\n-}\n-\n-bool TypeLong::empty(void) const {\n-  return _lo > _hi;\n-}\n-\n@@ -2338,1 +2108,1 @@\n-    return TypeInt::make(size->_lo, size->_hi, Type::WidenMin);\n+    return TypeInt::make(size->_lo, size->_hi, Type::WidenMin)->is_int();\n@@ -2368,1 +2138,6 @@\n-    const TypeAry *a = t->is_ary();\n+    const TypeAry* a = t->is_ary();\n+    const Type* size = _size->xmeet(a->_size);\n+    const TypeInt* isize = size->isa_int();\n+    if (isize == nullptr) {\n+      return size;\n+    }\n@@ -2370,2 +2145,1 @@\n-                         _size->xmeet(a->_size)->is_int(),\n-                         _stable && a->_stable);\n+                         isize, _stable && a->_stable);\n@@ -4799,1 +4573,1 @@\n-  if (lo > hi)\n+  if (lo > hi) {\n@@ -4801,1 +4575,2 @@\n-  if (!chg)\n+  }\n+  if (!chg) {\n@@ -4803,1 +4578,2 @@\n-  return TypeInt::make(lo, hi, Type::WidenMin);\n+  }\n+  return TypeInt::make(lo, hi, Type::WidenMin)->is_int();\n@@ -4964,1 +4740,5 @@\n-    const TypeAry *tary = _ary->meet_speculative(tap->_ary)->is_ary();\n+    const Type* tm = _ary->meet_speculative(tap->_ary);\n+    const TypeAry* tary = tm->isa_ary();\n+    if (tary == nullptr) {\n+      return tm;\n+    }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":244,"deletions":464,"binary":false,"changes":708,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/compile.hpp\"\n@@ -75,0 +76,3 @@\n+template <class T, class U>\n+class TypeIntPrototype;\n+\n@@ -554,1 +558,9 @@\n-  TypeInteger(TYPES t, int w) : Type(t), _widen(w) {}\n+  TypeInteger(TYPES t, int w, bool dual) : Type(t), _dual(dual), _widen(w) {}\n+\n+  \/\/ Previously, we signify that a set is in the dual space if _lo > _hi.\n+  \/\/ However, with the addition of unsigned range and known bits, this becomes\n+  \/\/ ambiguous whether the set is empty or a dual of a non-empty set.\n+  \/\/ As a result, we use this field to denote that a set is a dual set.\n+  \/\/ Dual sets are only used to compute the join of 2 sets, and not used\n+  \/\/ outside.\n+  const bool _dual;\n@@ -565,1 +577,1 @@\n-  static const TypeInteger* make(jlong lo, jlong hi, int w, BasicType bt);\n+  static const Type* make(jlong lo, jlong hi, int w, BasicType bt);\n@@ -579,1 +591,2 @@\n-  TypeInt( jint lo, jint hi, int w );\n+  TypeInt(const TypeIntPrototype<jint, juint>& t, int w, bool dual);\n+  static const Type* make(const TypeIntPrototype<jint, juint>& t, int w, bool dual);\n@@ -581,1 +594,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -585,1 +598,1 @@\n-  virtual bool eq( const Type *t ) const;\n+  virtual bool eq(const Type* t) const;\n@@ -589,1 +602,3 @@\n-  const jint _lo, _hi;          \/\/ Lower bound, upper bound\n+  const jint _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const juint _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const juint _zeros, _ones; \/\/ Bits that are known to be 0 or 1\n@@ -591,1 +606,3 @@\n-  static const TypeInt *make(jint lo);\n+  static const TypeInt* cast(const Type* t) { return t->is_int(); }\n+  static const TypeInt* try_cast(const Type* t) { return t->isa_int(); }\n+  static const TypeInt* make(jint lo);\n@@ -593,1 +610,2 @@\n-  static const TypeInt *make(jint lo, jint hi, int w);\n+  static const Type* make(jint lo, jint hi, int w);\n+  static const Type* make(const TypeIntPrototype<jint, juint>& t, int w);\n@@ -596,1 +614,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -598,1 +616,7 @@\n-  jint get_con() const { assert(is_con(), \"\" );  return _lo; }\n+  jint get_con() const { assert(is_con(), \"\");  return _lo; }\n+  \/\/ Check if a TypeInt is a subset of this TypeInt (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jint i) const;\n+  bool contains(const TypeInt* t) const;\n+  \/\/ Excluding the cases where this and t are the same\n+  bool properly_contains(const TypeInt* t) const;\n@@ -600,1 +624,1 @@\n-  virtual bool        is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n@@ -602,4 +626,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -612,21 +636,23 @@\n-  static const TypeInt *MAX;\n-  static const TypeInt *MIN;\n-  static const TypeInt *MINUS_1;\n-  static const TypeInt *ZERO;\n-  static const TypeInt *ONE;\n-  static const TypeInt *BOOL;\n-  static const TypeInt *CC;\n-  static const TypeInt *CC_LT;  \/\/ [-1]  == MINUS_1\n-  static const TypeInt *CC_GT;  \/\/ [1]   == ONE\n-  static const TypeInt *CC_EQ;  \/\/ [0]   == ZERO\n-  static const TypeInt *CC_LE;  \/\/ [-1,0]\n-  static const TypeInt *CC_GE;  \/\/ [0,1] == BOOL (!)\n-  static const TypeInt *BYTE;\n-  static const TypeInt *UBYTE;\n-  static const TypeInt *CHAR;\n-  static const TypeInt *SHORT;\n-  static const TypeInt *POS;\n-  static const TypeInt *POS1;\n-  static const TypeInt *INT;\n-  static const TypeInt *SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-  static const TypeInt *TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n+  static const TypeInt* MAX;\n+  static const TypeInt* MIN;\n+  static const TypeInt* MINUS_1;\n+  static const TypeInt* ZERO;\n+  static const TypeInt* ONE;\n+  static const TypeInt* BOOL;\n+  static const TypeInt* CC;\n+  static const TypeInt* CC_LT;  \/\/ [-1]  == MINUS_1\n+  static const TypeInt* CC_GT;  \/\/ [1]   == ONE\n+  static const TypeInt* CC_EQ;  \/\/ [0]   == ZERO\n+  static const TypeInt* CC_NE;  \/\/ [-1, 1]\n+  static const TypeInt* CC_LE;  \/\/ [-1,0]\n+  static const TypeInt* CC_GE;  \/\/ [0,1] == BOOL (!)\n+  static const TypeInt* BYTE;\n+  static const TypeInt* UBYTE;\n+  static const TypeInt* CHAR;\n+  static const TypeInt* SHORT;\n+  static const TypeInt* NON_ZERO;\n+  static const TypeInt* POS;\n+  static const TypeInt* POS1;\n+  static const TypeInt* INT;\n+  static const TypeInt* SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+  static const TypeInt* TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n@@ -645,1 +671,2 @@\n-  TypeLong( jlong lo, jlong hi, int w );\n+  TypeLong(const TypeIntPrototype<jlong, julong>& t, int w, bool dual);\n+  static const Type* make(const TypeIntPrototype<jlong, julong>& t, int w, bool dual);\n@@ -648,1 +675,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -656,1 +683,3 @@\n-  const jlong _lo, _hi;         \/\/ Lower bound, upper bound\n+  const jlong _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const julong _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const julong _zeros, _ones; \/\/ Bits that are known to be 0 or 1\n@@ -658,1 +687,3 @@\n-  static const TypeLong *make(jlong lo);\n+  static const TypeLong* cast(const Type* t) { return t->is_long(); }\n+  static const TypeLong* try_cast(const Type* t) { return t->isa_long(); }\n+  static const TypeLong* make(jlong lo);\n@@ -660,1 +691,2 @@\n-  static const TypeLong *make(jlong lo, jlong hi, int w);\n+  static const Type* make(jlong lo, jlong hi, int w);\n+  static const Type* make(const TypeIntPrototype<jlong, julong>& t, int w);\n@@ -663,1 +695,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -666,0 +698,6 @@\n+  \/\/ Check if a TypeLong is a subset of this TypeLong (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jlong i) const;\n+  bool contains(const TypeLong* t) const;\n+  \/\/ Excluding the cases where this and t are the same\n+  bool properly_contains(const TypeLong* t) const;\n@@ -675,4 +713,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -680,10 +718,12 @@\n-  static const TypeLong *MAX;\n-  static const TypeLong *MIN;\n-  static const TypeLong *MINUS_1;\n-  static const TypeLong *ZERO;\n-  static const TypeLong *ONE;\n-  static const TypeLong *POS;\n-  static const TypeLong *LONG;\n-  static const TypeLong *INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n-  static const TypeLong *UINT;   \/\/ 32-bit unsigned [0..max_juint]\n-  static const TypeLong *TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+  static const TypeLong* MAX;\n+  static const TypeLong* MIN;\n+  static const TypeLong* MINUS_1;\n+  static const TypeLong* ZERO;\n+  static const TypeLong* ONE;\n+  static const TypeLong* NON_ZERO;\n+  static const TypeLong* POS;\n+  static const TypeLong* NEG;\n+  static const TypeLong* LONG;\n+  static const TypeLong* INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n+  static const TypeLong* UINT;   \/\/ 32-bit unsigned [0..max_juint]\n+  static const TypeLong* TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":96,"deletions":56,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+#include <limits>\n+\n+#ifdef ASSERT\n+\n+template <class U>\n+static U uniform_random();\n+\n+template <>\n+juint uniform_random<juint>() {\n+  return os::random();\n+}\n+\n+template <>\n+julong uniform_random<julong>() {\n+  return (julong(os::random()) << 32) | julong(juint(os::random()));\n+}\n+\n+template <class T, class U>\n+static void test_normalize_constraints_simple() {\n+  constexpr int parameters = 10;\n+  for (int i = 0; i < parameters; i++) {\n+    T a = uniform_random<U>();\n+    T b = uniform_random<U>();\n+\n+    {\n+      T lo = MIN2<T>(a, b);\n+      T hi = MAX2<T>(a, b);\n+      TypeIntPrototype<T, U> t{{lo, hi}, {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()},\n+                               {0, 0}};\n+      auto new_t = t.normalize_constraints();\n+      ASSERT_TRUE(new_t.first);\n+      DEBUG_ONLY(new_t.second.verify_constraints());\n+      ASSERT_EQ(lo, new_t.second._srange._lo);\n+      ASSERT_EQ(hi, new_t.second._srange._hi);\n+      if (U(lo) <= U(hi)) {\n+        ASSERT_EQ(U(lo), new_t.second._urange._lo);\n+        ASSERT_EQ(U(hi), new_t.second._urange._hi);\n+      } else {\n+        ASSERT_EQ(std::numeric_limits<U>::min(), new_t.second._urange._lo);\n+        ASSERT_EQ(std::numeric_limits<U>::max(), new_t.second._urange._hi);\n+      }\n+    }\n+\n+    {\n+      U ulo = MIN2<U>(a, b);\n+      U uhi = MAX2<U>(a, b);\n+      TypeIntPrototype<T, U> t{{std::numeric_limits<T>::min(), std::numeric_limits<T>::max()},\n+                               {ulo, uhi}, {0, 0}};\n+      auto new_t = t.normalize_constraints();\n+      ASSERT_TRUE(new_t.first);\n+      DEBUG_ONLY(new_t.second.verify_constraints());\n+      ASSERT_EQ(ulo, new_t.second._urange._lo);\n+      ASSERT_EQ(uhi, new_t.second._urange._hi);\n+      if (T(ulo) <= T(uhi)) {\n+        ASSERT_EQ(T(ulo), new_t.second._srange._lo);\n+        ASSERT_EQ(T(uhi), new_t.second._srange._hi);\n+      } else {\n+        ASSERT_EQ(std::numeric_limits<T>::min(), new_t.second._srange._lo);\n+        ASSERT_EQ(std::numeric_limits<T>::max(), new_t.second._srange._hi);\n+      }\n+    }\n+\n+    {\n+      U intersection = a & b;\n+      U zeros = a ^ intersection;\n+      U ones = b ^ intersection;\n+      TypeIntPrototype<T, U> t{{std::numeric_limits<T>::min(), std::numeric_limits<T>::max()},\n+                               {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()}, {zeros, ones}};\n+      auto new_t = t.normalize_constraints();\n+      ASSERT_TRUE(new_t.first);\n+      DEBUG_ONLY(new_t.second.verify_constraints());\n+      ASSERT_EQ(zeros, new_t.second._bits._zeros);\n+      ASSERT_EQ(ones, new_t.second._bits._ones);\n+      ASSERT_EQ(ones, new_t.second._urange._lo);\n+      ASSERT_EQ(~zeros, new_t.second._urange._hi);\n+    }\n+  }\n+}\n+\n+template <class T, class U>\n+static void test_normalize_constraints_random() {\n+  constexpr int samples = 1000;\n+  constexpr int parameters = 1000;\n+  for (int i = 0; i < parameters; i++) {\n+    T s1 = uniform_random<U>();\n+    T s2 = uniform_random<U>();\n+    T lo = MIN2(s1, s2);\n+    T hi = MAX2(s1, s2);\n+    U u1 = uniform_random<U>();\n+    U u2 = uniform_random<U>();\n+    U ulo = MIN2(u1, u2);\n+    U uhi = MAX2(u1, u2);\n+    U b1 = uniform_random<U>();\n+    U b2 = uniform_random<U>();\n+    U intersection = b1 & b2;\n+    U zeros = b1 ^ intersection;\n+    U ones = b2 ^ intersection;\n+    TypeIntPrototype<T, U> t{{lo, hi}, {ulo, uhi}, {zeros, ones}};\n+    auto new_t = t.normalize_constraints();\n+    if (new_t.first) {\n+      new_t.second.verify_constraints();\n+    }\n+    for (int j = 0; j < samples; j++) {\n+      T v = uniform_random<U>();\n+      if (!new_t.first) {\n+        ASSERT_FALSE(t.contains(v));\n+      } else {\n+        ASSERT_EQ(t.contains(v), new_t.second.contains(v));\n+      }\n+    }\n+  }\n+}\n+\n+TEST_VM(opto, normalize_constraints) {\n+  test_normalize_constraints_simple<jint, juint>();\n+  test_normalize_constraints_simple<jlong, julong>();\n+  test_normalize_constraints_random<jint, juint>();\n+  test_normalize_constraints_random<jlong, julong>();\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"}]}