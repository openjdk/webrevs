{"files":[{"patch":"@@ -90,3 +90,3 @@\n-\/\/ function will always find one such value. The conversion is also true, that\n-\/\/ is if this function finds a value not less than lo and satisfies bits, then\n-\/\/ it must trivially be the case that there exists one such value. As a result,\n+\/\/ function will always find one such value. The converse is also true, that is\n+\/\/ if this function finds a value not less than lo and satisfies bits, then it\n+\/\/ must trivially be the case that there exists one such value. As a result,\n@@ -366,1 +366,1 @@\n-    U either = lo | bits._zeros;\n+    U neither = ~(lo | bits._zeros);\n@@ -370,1 +370,1 @@\n-    U tmp = ~either & find_mask;\n+    U neither_upto_first_violation = neither & find_mask;\n@@ -375,2 +375,4 @@\n-    \/\/ i set, this is equivalent to extracting the last set bit of tmp, do it\n-    \/\/ directly without going through i.\n+    \/\/ i set, this is equivalent to extracting the last set bit of\n+    \/\/ neither_upto_first_violation, do it directly without going through i.\n+    \/\/ The formula x & (-x) will give us the last set bit of an integer x\n+    \/\/ (please see the x86 instruction blsi).\n@@ -379,1 +381,1 @@\n-    U alignment = tmp & (-tmp);\n+    U alignment = neither_upto_first_violation & (-neither_upto_first_violation);\n@@ -402,14 +404,16 @@\n-    \/\/ index i satisfies (3.1-3.3), which means that tmp != 0. The converse is\n-    \/\/ also true, if tmp != 0, then an index i satisfies (3.1-3.3) exists,\n-    \/\/ which implies the existence of a value not smaller than lo and satisfies\n-    \/\/ bits. As a result, the negation of those statements are equivalent.\n-    \/\/ tmp == 0 if and only if there does not exists a value not smaller than\n-    \/\/ lo and satisfies bits. In this case, alignment == 0 and\n-    \/\/ new_lo == bits._ones. We know that, if the assumption of this function\n-    \/\/ holds, we return a value satisfying bits, and if the assumption of this\n-    \/\/ function does not hold, the returned value would be bits._ones, which\n-    \/\/ also satisfies bits. As a result, this function always returns a value\n-    \/\/ satisfying bits, regardless whether if the assumption of this function\n-    \/\/ holds. In conclusion, the caller only needs to check lo <= new_lo to\n-    \/\/ find the cases where there exists no value not smaller than lo and\n-    \/\/ satisfies bits (see the overview of the function).\n+    \/\/ index i satisfies (3.1-3.3), which means that\n+    \/\/ neither_upto_first_violation != 0. The converse is\n+    \/\/ also true, if neither_upto_first_violation != 0, then an index i\n+    \/\/ satisfies (3.1-3.3) exists, which implies the existence of a value not\n+    \/\/ smaller than lo and satisfies bits. As a result, the negation of those\n+    \/\/ statements are equivalent. neither_upto_first_violation == 0 if and only\n+    \/\/ if there does not exists a value not smaller than lo and satisfies bits.\n+    \/\/ In this case, alignment == 0 and new_lo == bits._ones. We know that, if\n+    \/\/ the assumption of this function holds, we return a value satisfying\n+    \/\/ bits, and if the assumption of this function does not hold, the returned\n+    \/\/ value would be bits._ones, which also satisfies bits. As a result, this\n+    \/\/ function always returns a value satisfying bits, regardless whether if\n+    \/\/ the assumption of this function holds. In conclusion, the caller only\n+    \/\/ needs to check lo <= new_lo to find the cases where there exists no\n+    \/\/ value not smaller than lo and satisfies bits (see the overview of the\n+    \/\/ function).\n@@ -707,1 +711,1 @@\n-    \/\/ meet (a.k.a union)\n+      \/\/ meet (a.k.a union)\n@@ -712,0 +716,6 @@\n+    } else {\n+      \/\/ join (a.k.a intersection)\n+      return CT::make_or_top(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n+                                                    {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n+                                                    {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n+                             MIN2(i1->_widen, i2->_widen), true);\n@@ -713,5 +723,0 @@\n-    \/\/ join (a.k.a intersection)\n-    return CT::make_or_top(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n-                                                  {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n-                                                  {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n-                           MIN2(i1->_widen, i2->_widen), true);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":33,"deletions":28,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-\/\/ applicable to all fixed-width integral types. With a few bits, it makes it\n+\/\/ applicable to all fixed-width integral types. With small nbits, it makes it\n","filename":"src\/hotspot\/share\/utilities\/intn_t.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}