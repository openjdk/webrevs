{"files":[{"patch":"@@ -70,1 +70,1 @@\n-    assert((bounds._lo < mid_point) == (bounds._hi < mid_point), \"must be a simple interval\");\n+    assert((bounds._lo < mid_point) == (bounds._hi < mid_point), \"must be a simple interval, see Lemma 4\");\n@@ -83,2 +83,1 @@\n-\/\/ does not exist one such number, the calculation will overflow and return a\n-\/\/ value < lo.\n+\/\/ does not exist one such number, the calculation will return a value < lo.\n@@ -248,1 +247,1 @@\n-  \/\/ ones, if it violates zeros, we have the bit being 1 in zero_violation and\n+  \/\/ ones. If it violates zeros, we have the bit being 1 in zero_violation and\n@@ -321,1 +320,1 @@\n-    assert(lo < new_lo, \"this case cannot overflow\");\n+    assert(lo < new_lo, \"the result must be valid\");\n@@ -336,3 +335,4 @@\n-    \/\/ of i would violate 3.1 since lo[first_violation] does not satisfy bits.\n-    \/\/ As a result, we should find the last i upto first_violation such that\n-    \/\/ lo[i] == zeros[i] == 0.\n+    \/\/ of i would violate (3.1) since lo[first_violation] does not satisfy\n+    \/\/ bits. As a result, we should find the last index x upto first_violation\n+    \/\/ such that lo[x] == zeros[x] == 0. That value of x would be the value of\n+    \/\/ i we are looking for.\n@@ -362,2 +362,4 @@\n-    \/\/ A bit that is 0 in both lo and zeros must be 0 in either\n-    \/\/           1 0 0 1 1 1 1 0\n+    \/\/ We want to find the last index x upto first_violation such that\n+    \/\/ lo[x] == zeros[x] == 0.\n+    \/\/ We start with all bits where lo[x] == zeros[x] == 0:\n+    \/\/           0 1 1 0 0 0 0 1\n@@ -365,4 +367,2 @@\n-    \/\/ This is all the bits that are not lower than first_violation and are 0\n-    \/\/ in both lo and zeros. Note that there may not exist such bits. In those\n-    \/\/ cases tmp == 0 and there is no value not less than lo and satisfies\n-    \/\/ bits. We will expand the implication of such cases below.\n+    \/\/ Now let us find all the bit indices x upto first_violation such that\n+    \/\/ lo[x] == zeros[x] == 0. The last one of these bits must be at index i.\n@@ -371,6 +371,7 @@\n-    \/\/ According to the conclusion in the overview of this case above, i is the\n-    \/\/ last bit being 0 in both lo and zeros that is upto the first violation,\n-    \/\/ which is the last set bit of tmp.\n-    \/\/ In our example, i == 2 here, we want to obtain the value with only the\n-    \/\/ bit i set, this is equivalent to extracting the last set bit of tmp, do\n-    \/\/ it directly without going through i.\n+    \/\/ We now want to select the last one of these candidates, which is exactly\n+    \/\/ the last index x upto first_violation such that lo[x] == zeros[x] == 0.\n+    \/\/ This would be the value i we are looking for.\n+    \/\/ Similar to the other case, we want to obtain the value with only the bit\n+    \/\/ i set, this is equivalent to extracting the last set bit of tmp, do it\n+    \/\/ directly without going through i.\n+    \/\/ In our example, i == 2\n@@ -379,4 +380,4 @@\n-    \/\/ Set the bit of lo at i and unset all the bits after, this is the smallest\n-    \/\/ value that satisfies bits._zeros. Similar to the above case, this is\n-    \/\/ similar to aligning lo upto alignment. Also similar to the above case,\n-    \/\/ this computation cannot overflow.\n+    \/\/ Set the bit of lo at i and unset all the bits after, this is the\n+    \/\/ smallest value that satisfies bits._zeros. Similar to the above case,\n+    \/\/ this is similar to aligning lo up to a multiple of alignment. Also\n+    \/\/ similar to the above case, this computation cannot overflow.\n@@ -399,12 +400,14 @@\n-    \/\/ In this case, new_lo may not always be a valid answer. This can happen\n-    \/\/ if there is no bit upto first_violation that is 0 in both lo and zeros,\n-    \/\/ i.e. tmp == 0. In such cases, alignment == 0 && lo == bits._ones. It is\n-    \/\/ the only case when this function does not return a valid answer.\n-    \/\/ Note: it can be seen as an overflow because we can say that the\n-    \/\/ computation of tmp above results in 0b...1100..00 with W trailing 0s.\n-    \/\/ As a result, alignment should be 0b100...00 with W trailing 0s. This\n-    \/\/ overflows the W-bit arithmetic and we obtain the value alignment == 0.\n-    \/\/ We can say that the algorithm should round up lo to a multiple of 2**W.\n-    \/\/ This overflows and the highest bit is discarded, leaving us with the\n-    \/\/ result of rounding up being 0.\n-    assert(lo < new_lo || new_lo == bits._ones, \"overflow must return bits._ones\");\n+    \/\/ Note that formally, this function assumes that there exists a value not\n+    \/\/ smaller than lo and satisfies bits. This implies the existence of the\n+    \/\/ index i satisfies (3.1-3.3), which means that tmp != 0. The converse is\n+    \/\/ also true, if tmp != 0, then an index i satisfies (3.1-3.3) exists,\n+    \/\/ which implies the existence of a value not smaller than lo and satisfies\n+    \/\/ bits. As a result, the negation of those statements are equivalent.\n+    \/\/ tmp == 0 if and only if there does not exists a value not smaller than\n+    \/\/ lo and satisfies bits. In this case, alignment == 0 and\n+    \/\/ new_lo == bits._ones, since bits._ones satisfies bits. This function\n+    \/\/ always returns a value satisfying bits, regardless whether if it is a\n+    \/\/ formally valid one. As a result, the caller only needs to check\n+    \/\/ lo <= new_lo to find the cases where there exists no value not smaller\n+    \/\/ than lo and satisfies bits.\n+    assert(lo < new_lo || new_lo == bits._ones, \"invalid result must be bits._ones\");\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":39,"deletions":36,"binary":false,"changes":75,"status":"modified"}]}