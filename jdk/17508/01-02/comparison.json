{"files":[{"patch":"@@ -27,0 +27,2 @@\n+#include \"opto\/type.hpp\"\n+#include \"utilities\/tuple.hpp\"\n@@ -28,1 +30,1 @@\n-constexpr juint SMALLINT = 3;  \/\/ a value too insignificant to consider widening\n+constexpr juint SMALLINT = 3; \/\/ a value too insignificant to consider widening\n@@ -31,1 +33,21 @@\n-static bool adjust_bounds_from_bits(bool& empty, T& lo, T& hi, T zeros, T ones) {\n+class AdjustResult {\n+public:\n+  bool _progress;\n+  bool _present;\n+  T _data;\n+};\n+\n+template <class T>\n+class NormalizeSimpleResult {\n+public:\n+  bool _present;\n+  RangeInt<T> _bounds;\n+  KnownBits<T> _bits;\n+};\n+\n+\/\/ Try to tighten the bound constraints from the known bit information\n+\/\/ E.g: if lo = 0 but the lowest bit is always 1 then we can tighten\n+\/\/ lo = 1\n+template <class T>\n+static AdjustResult<RangeInt<T>>\n+adjust_bounds_from_bits(const RangeInt<T>& bounds, const KnownBits<T>& bits) {\n@@ -34,1 +56,1 @@\n-  auto adjust_lo = [](T lo, T zeros, T ones) {\n+  auto adjust_lo = [](T lo, const KnownBits<T>& bits) {\n@@ -36,3 +58,3 @@\n-    T zero_violation = lo & zeros;\n-    T one_violation = ~lo & ones;\n-    if (zero_violation == 0 && one_violation == 0) {\n+    T zero_violation = lo & bits._zeros;\n+    T one_violation = ~lo & bits._ones;\n+    if (zero_violation == one_violation) {\n@@ -48,1 +70,1 @@\n-      return lo | ones;\n+      return lo | bits._ones;\n@@ -61,1 +83,1 @@\n-    T either = lo | zeros;\n+    T either = lo | bits._zeros;\n@@ -65,1 +87,1 @@\n-    return lo | ones;\n+    return lo | bits._ones;\n@@ -68,4 +90,3 @@\n-  T new_lo = adjust_lo(lo, zeros, ones);\n-  if (new_lo < lo) {\n-    empty = true;\n-    return true;\n+  T new_lo = adjust_lo(bounds._lo, bits);\n+  if (new_lo < bounds._lo) {\n+    return {true, false, {}};\n@@ -73,5 +94,3 @@\n-\n-  T new_hi = ~adjust_lo(~hi, ones, zeros);\n-  if (new_hi > hi) {\n-    empty = true;\n-    return true;\n+  T new_hi = ~adjust_lo(~bounds._hi, {bits._ones, bits._zeros});\n+  if (new_hi > bounds._hi) {\n+    return {true, false, {}};\n@@ -79,5 +98,4 @@\n-  bool progress = (new_lo != lo) || (new_hi != hi);\n-  lo = new_lo;\n-  hi = new_hi;\n-  empty = lo > hi;\n-  return progress;\n+\n+  bool progress = (new_lo != bounds._lo) || (new_hi != bounds._hi);\n+  bool present = new_lo <= new_hi;\n+  return {progress, present, {new_lo, new_hi}};\n@@ -86,0 +104,2 @@\n+\/\/ Try to tighten the known bit constraints from the bound information\n+\/\/ E.g: if lo = 0 and hi = 10, then all but the lowest 4 bits must be 0\n@@ -87,1 +107,2 @@\n-static bool adjust_bits_from_bounds(bool& empty, T& zeros, T& ones, T lo, T hi) {\n+static AdjustResult<KnownBits<T>>\n+adjust_bits_from_bounds(const KnownBits<T>& bits, const RangeInt<T>& bounds) {\n@@ -89,1 +110,1 @@\n-  T mismatch = lo ^ hi;\n+  T mismatch = bounds._lo ^ bounds._hi;\n@@ -92,7 +113,5 @@\n-  T new_zeros = zeros | (match_mask &~ lo);\n-  T new_ones = ones | (match_mask & lo);\n-  bool progress = (new_zeros != zeros) || (new_ones != ones);\n-  zeros = new_zeros;\n-  ones = new_ones;\n-  empty = ((zeros & ones) != 0);\n-  return progress;\n+  T new_zeros = bits._zeros | (match_mask &~ bounds._lo);\n+  T new_ones = bits._ones | (match_mask & bounds._lo);\n+  bool progress = (new_zeros != bits._zeros) || (new_ones != bits._ones);\n+  bool present = ((new_zeros & new_ones) == 0);\n+  return {progress, present, {new_zeros, new_ones}};\n@@ -101,0 +120,3 @@\n+\/\/ Try to tighten both the bounds and the bits at the same time\n+\/\/ Iteratively tighten 1 using the other until no progress is made.\n+\/\/ This function converges because bit constraints converge fast.\n@@ -102,4 +124,5 @@\n-static void normalize_constraints_simple(bool& empty, T& lo, T& hi, T& zeros, T& ones) {\n-  adjust_bits_from_bounds(empty, zeros, ones, lo, hi);\n-  if (empty) {\n-    return;\n+static NormalizeSimpleResult<T>\n+normalize_constraints_simple(const RangeInt<T>& bounds, const KnownBits<T>& bits) {\n+  AdjustResult<KnownBits<T>> nbits = adjust_bits_from_bounds(bits, bounds);\n+  if (!nbits._present) {\n+    return {false, {}, {}};\n@@ -107,0 +130,1 @@\n+  AdjustResult<RangeInt<T>> nbounds{true, true, bounds};\n@@ -108,3 +132,3 @@\n-    bool progress = adjust_bounds_from_bits(empty, lo, hi, zeros, ones);\n-    if (!progress || empty) {\n-      return;\n+    nbounds = adjust_bounds_from_bits(nbounds._data, nbits._data);\n+    if (!nbounds._progress || !nbounds._present) {\n+      return {nbounds._present, nbounds._data, nbits._data};\n@@ -112,3 +136,3 @@\n-    progress = adjust_bits_from_bounds(empty, zeros, ones, lo, hi);\n-    if (!progress || empty) {\n-      return;\n+    nbits = adjust_bits_from_bounds(nbits._data, nbounds._data);\n+    if (!nbits._progress || !nbits._present) {\n+      return {nbits._present, nbounds._data, nbits._data};\n@@ -119,0 +143,5 @@\n+\/\/ Tighten all constraints of a TypeIntPrototype to its canonical form.\n+\/\/ i.e the result represents the same set as the input, each bound belongs to\n+\/\/ the set and for each bit position that is not constrained, there exists 2\n+\/\/ values with the bit value at that position being set and unset, respectively,\n+\/\/ such that both belong to the set represented by the constraints.\n@@ -120,1 +149,2 @@\n-void normalize_constraints(bool& empty, T& lo, T& hi, U& ulo, U& uhi, U& zeros, U& ones) {\n+Pair<bool, TypeIntPrototype<T, U>>\n+TypeIntPrototype<T, U>::normalize_constraints() const {\n@@ -125,3 +155,6 @@\n-  if (lo > hi || ulo > uhi || (zeros & ones) != 0) {\n-    empty = true;\n-    return;\n+  RangeInt<T> srange = _srange;\n+  RangeInt<U> urange = _urange;\n+  if (srange._lo > srange._hi ||\n+      urange._lo > urange._hi ||\n+      (_bits._zeros & _bits._ones) != 0) {\n+    return {false, {}};\n@@ -130,5 +163,5 @@\n-  if (T(ulo) > T(uhi)) {\n-    if (T(uhi) < lo) {\n-      uhi = std::numeric_limits<T>::max();\n-    } else if (T(ulo) > hi) {\n-      ulo = std::numeric_limits<T>::min();\n+  if (T(urange._lo) > T(urange._hi)) {\n+    if (T(urange._hi) < srange._lo) {\n+      urange._hi = std::numeric_limits<T>::max();\n+    } else if (T(urange._lo) > srange._hi) {\n+      urange._lo = std::numeric_limits<T>::min();\n@@ -138,6 +171,6 @@\n-  if (T(ulo) <= T(uhi)) {\n-    ulo = MAX2<T>(ulo, lo);\n-    uhi = MIN2<T>(uhi, hi);\n-    if (ulo > uhi) {\n-      empty = true;\n-      return;\n+  if (T(urange._lo) <= T(urange._hi)) {\n+    \/\/ [lo, hi] and [ulo, uhi] represent the same range\n+    urange._lo = MAX2<T>(urange._lo, srange._lo);\n+    urange._hi = MIN2<T>(urange._hi, srange._hi);\n+    if (urange._lo > urange._hi) {\n+      return {false, {}};\n@@ -146,36 +179,20 @@\n-    normalize_constraints_simple(empty, ulo, uhi, zeros, ones);\n-    lo = ulo;\n-    hi = uhi;\n-    return;\n-  }\n-\n-  bool empty1 = false;\n-  U lo1 = lo;\n-  U hi1 = uhi;\n-  U zeros1 = zeros;\n-  U ones1 = ones;\n-  normalize_constraints_simple(empty1, lo1, hi1, zeros1, ones1);\n-\n-  bool empty2 = false;\n-  U lo2 = ulo;\n-  U hi2 = hi;\n-  U zeros2 = zeros;\n-  U ones2 = ones;\n-  normalize_constraints_simple(empty2, lo2, hi2, zeros2, ones2);\n-\n-  if (empty1 && empty2) {\n-    empty = true;\n-  } else if (empty1) {\n-    lo = lo2;\n-    hi = hi2;\n-    ulo = lo2;\n-    uhi = hi2;\n-    zeros = zeros2;\n-    ones = ones2;\n-  } else if (empty2) {\n-    lo = lo1;\n-    hi = hi1;\n-    ulo = lo1;\n-    uhi = hi1;\n-    zeros = zeros1;\n-    ones = ones1;\n+    auto type = normalize_constraints_simple(urange, _bits);\n+    return {type._present, {{T(type._bounds._lo), T(type._bounds._hi)},\n+                            type._bounds, type._bits}};\n+  }\n+\n+  \/\/ [lo, hi] intersects with [ulo, uhi] in 2 ranges:\n+  \/\/ [lo, uhi], which consists of negative values\n+  \/\/ [ulo, hi] which consists of non-negative values\n+  \/\/ We process these 2 separately and combine the results\n+  auto neg_type = normalize_constraints_simple({U(srange._lo), urange._hi}, _bits);\n+  auto pos_type = normalize_constraints_simple({urange._lo, U(srange._hi)}, _bits);\n+\n+  if (!neg_type._present && !pos_type._present) {\n+    return {false, {}};\n+  } else if (!neg_type._present) {\n+    return {true, {{T(pos_type._bounds._lo), T(pos_type._bounds._hi)},\n+                   pos_type._bounds, pos_type._bits}};\n+  } else if (!pos_type._present) {\n+    return {true, {{T(neg_type._bounds._lo), T(neg_type._bounds._hi)},\n+                   neg_type._bounds, neg_type._bits}};\n@@ -183,6 +200,12 @@\n-    lo = lo1;\n-    hi = hi2;\n-    ulo = lo2;\n-    uhi = hi1;\n-    zeros = zeros1 & zeros2;\n-    ones = ones1 & ones2;\n+    return {true, {{T(neg_type._bounds._lo), T(pos_type._bounds._hi)},\n+                   {pos_type._bounds._lo, neg_type._bounds._hi},\n+                   {neg_type._bits._zeros & pos_type._bits._zeros, neg_type._bits._ones & pos_type._bits._ones}}};\n+  }\n+}\n+\n+template <class T, class U>\n+int TypeIntPrototype<T, U>::normalize_widen(int w) const {\n+  \/\/ Certain normalizations keep us sane when comparing types.\n+  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n+  if (cardinality_from_bounds(_srange, _urange) <= SMALLINT) {\n+    return Type::WidenMin;\n@@ -190,0 +213,7 @@\n+  if (_srange._lo == std::numeric_limits<T>::min() && _srange._hi == std::numeric_limits<T>::max() &&\n+      _urange._lo == std::numeric_limits<U>::min() && _urange._hi == std::numeric_limits<U>::max() &&\n+      _bits._zeros == 0 && _bits._ones == 0) {\n+    \/\/ bottom type\n+    return Type::WidenMax;\n+  }\n+  return w;\n@@ -191,2 +221,0 @@\n-template void normalize_constraints(bool& empty, jint& lo, jint& hi, juint& ulo, juint& uhi, juint& zeros, juint& ones);\n-template void normalize_constraints(bool& empty, jlong& lo, jlong& hi, julong& ulo, julong& uhi, julong& zeros, julong& ones);\n@@ -194,0 +222,1 @@\n+#ifdef ASSERT\n@@ -195,1 +224,8 @@\n-void verify_constraints(T lo, T hi, U ulo, U uhi, U zeros, U ones) {\n+bool TypeIntPrototype<T, U>::contains(T v) const {\n+  return v >= _srange._lo && v <= _srange._hi && U(v) >= _urange._lo && U(v) <= _urange._hi &&\n+         (v & _bits._zeros) == 0 && (~v & _bits._ones) == 0;\n+}\n+\n+\/\/ Verify that this set representation is canonical\n+template <class T, class U>\n+void TypeIntPrototype<T, U>::verify_constraints() const {\n@@ -201,4 +237,2 @@\n-  assert(lo <= hi && U(lo) >= ulo && U(lo) <= uhi && (lo & zeros) == 0 && (~lo & ones) == 0, \"\");\n-  assert(hi >= lo && U(hi) >= ulo && U(hi) <= uhi && (hi & zeros) == 0 && (~hi & ones) == 0, \"\");\n-  assert(T(ulo) >= lo && T(ulo) <= hi && ulo <= uhi && (ulo & zeros) == 0 && (~ulo & ones) == 0, \"\");\n-  assert(T(uhi) >= lo && T(uhi) <= hi && uhi >= ulo && (uhi & zeros) == 0 && (~uhi & ones) == 0, \"\");\n+  assert(contains(_srange._lo) && contains(_srange._hi) &&\n+         contains(_urange._lo) && contains(_urange._hi), \"\");\n@@ -207,3 +241,2 @@\n-  if (U(lo) == ulo) {\n-    bool empty = false;\n-    assert(!adjust_bits_from_bounds(empty, zeros, ones, ulo, uhi), \"\");\n+  if (U(_srange._lo) == _urange._lo) {\n+    assert(!adjust_bits_from_bounds(_bits, _urange)._progress, \"\");\n@@ -211,23 +244,4 @@\n-    bool empty1 = false;\n-    U lo1 = lo;\n-    U hi1 = uhi;\n-    U zeros1 = zeros;\n-    U ones1 = ones;\n-    adjust_bits_from_bounds(empty1, zeros1, ones1, lo1, hi1);\n-    assert(!empty1, \"\");\n-    assert(!adjust_bounds_from_bits(empty1, lo1, hi1, zeros1, ones1), \"\");\n-\n-    bool empty2 = false;\n-    U lo2 = ulo;\n-    U hi2 = hi;\n-    U zeros2 = zeros;\n-    U ones2 = ones;\n-    adjust_bits_from_bounds(empty2, zeros2, ones2, lo2, hi2);\n-    assert(!empty2, \"\");\n-    assert(!adjust_bounds_from_bits(empty2, lo2, hi2, zeros2, ones2), \"\");\n-\n-    assert((zeros1 & zeros2) == zeros && (ones1 & ones2) == ones, \"\");\n-  }\n-}\n-template void verify_constraints(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones);\n-template void verify_constraints(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones);\n+    RangeInt<U> neg_range{U(_srange._lo), _urange._hi};\n+    auto neg_bits = adjust_bits_from_bounds(_bits, neg_range);\n+    assert(neg_bits._present, \"\");\n+    assert(!adjust_bounds_from_bits(neg_range, neg_bits._data)._progress, \"\");\n@@ -235,12 +249,7 @@\n-template <class T, class U>\n-int normalize_widen(T lo, T hi, U ulo, U uhi, U zeros, U ones, int w) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n-  if (cardinality_from_bounds(lo, hi, ulo, uhi) <= SMALLINT) {\n-    return Type::WidenMin;\n-  }\n-  if (lo == std::numeric_limits<T>::min() && hi == std::numeric_limits<T>::max() &&\n-      ulo == std::numeric_limits<U>::min() && uhi == std::numeric_limits<U>::max() &&\n-      zeros == 0 && ones == 0) {\n-    \/\/ bottom type\n-    return Type::WidenMax;\n+    RangeInt<U> pos_range{_urange._lo, U(_srange._hi)};\n+    auto pos_bits = adjust_bits_from_bounds(_bits, pos_range);\n+    assert(pos_bits._present, \"\");\n+    assert(!adjust_bounds_from_bits(pos_range, pos_bits._data)._progress, \"\");\n+\n+    assert((neg_bits._data._zeros & pos_bits._data._zeros) == _bits._zeros &&\n+           (neg_bits._data._ones & pos_bits._data._ones) == _bits._ones, \"\");\n@@ -248,1 +257,0 @@\n-  return w;\n@@ -250,2 +258,1 @@\n-template int normalize_widen(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w);\n-template int normalize_widen(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w);\n+#endif \/\/ ASSERT\n@@ -253,0 +260,5 @@\n+template class TypeIntPrototype<jint, juint>;\n+template class TypeIntPrototype<jlong, julong>;\n+\n+\/\/ Compute the meet of 2 types, when dual is true, we are actually computing the\n+\/\/ join.\n@@ -254,1 +266,1 @@\n-const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(T, T, UT, UT, UT, UT, int, bool), bool dual) {\n+const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<T, UT>&, int, bool), bool dual) {\n@@ -263,2 +275,4 @@\n-      return make(MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi), MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi),\n-                  i1->_zeros & i2->_zeros, i1->_ones & i2->_ones, MAX2(i1->_widen, i2->_widen), false);\n+      return make(TypeIntPrototype<T, UT>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n+                                          {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n+                                          {i1->_zeros & i2->_zeros, i1->_ones & i2->_ones}},\n+                  MAX2(i1->_widen, i2->_widen), false);\n@@ -267,2 +281,4 @@\n-    return make(MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi), MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi),\n-                i1->_zeros | i2->_zeros, i1->_ones | i2->_ones, MIN2(i1->_widen, i2->_widen), true);\n+    return make(TypeIntPrototype<T, UT>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n+                                        {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n+                                        {i1->_zeros | i2->_zeros, i1->_ones | i2->_ones}},\n+                MIN2(i1->_widen, i2->_widen), true);\n@@ -300,1 +316,1 @@\n-                                    const Type* (*make)(jint, jint, juint, juint, juint, juint, int, bool), bool dual);\n+                                    const Type* (*make)(const TypeIntPrototype<jint, juint>&, int, bool), bool dual);\n@@ -302,1 +318,1 @@\n-                                    const Type* (*make)(jlong, jlong, julong, julong, julong, julong, int, bool), bool dual);\n+                                    const Type* (*make)(const TypeIntPrototype<jlong, julong>&, int, bool), bool dual);\n@@ -347,1 +363,2 @@\n-    return CT::make(nt->_lo, nt->_hi, nt->_ulo, nt->_uhi, nt->_zeros, nt->_ones, nt->_widen + 1);\n+    TypeIntPrototype<T, U> prototype{{nt->_lo, nt->_hi}, {nt->_ulo, nt->_uhi}, {nt->_zeros, nt->_ones}};\n+    return CT::make(prototype, nt->_widen + 1);\n@@ -366,1 +383,2 @@\n-  return CT::make(min, max, umin, umax, zeros, ones, Type::WidenMax);\n+  TypeIntPrototype<T, U> prototype{{min, max}, {umin, umax}, {zeros, ones}};\n+  return CT::make(prototype, Type::WidenMax);\n@@ -404,2 +422,4 @@\n-  U oc = cardinality_from_bounds(ot->_lo, ot->_hi, ot->_ulo, ot->_uhi);\n-  U nc = cardinality_from_bounds(nt->_lo, nt->_hi, nt->_ulo, nt->_uhi);\n+  U oc = cardinality_from_bounds(RangeInt<T>{ot->_lo, ot->_hi},\n+                                 RangeInt<U>{ot->_ulo, ot->_uhi});\n+  U nc = cardinality_from_bounds(RangeInt<T>{nt->_lo, nt->_hi},\n+                                 RangeInt<U>{nt->_ulo, nt->_uhi});\n@@ -411,0 +431,2 @@\n+\n+#ifndef PRODUCT\n@@ -537,0 +559,1 @@\n+#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":181,"deletions":158,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -28,2 +28,17 @@\n-#include \"opto\/type.hpp\"\n-#include \"runtime\/os.hpp\"\n+#include \"utilities\/pair.hpp\"\n+\n+class Type;\n+\n+template <class T>\n+class RangeInt {\n+public:\n+  T _lo;\n+  T _hi;\n+};\n+\n+template <class T>\n+class KnownBits {\n+public:\n+  T _zeros;\n+  T _ones;\n+};\n@@ -32,1 +47,5 @@\n-void normalize_constraints(bool& empty, T& lo, T& hi, U& ulo, U& uhi, U& zeros, U& ones);\n+class TypeIntPrototype {\n+public:\n+  RangeInt<T> _srange;\n+  RangeInt<U> _urange;\n+  KnownBits<U> _bits;\n@@ -34,0 +53,2 @@\n+  Pair<bool, TypeIntPrototype<T, U>> normalize_constraints() const;\n+  int normalize_widen(int w) const;\n@@ -35,3 +56,4 @@\n-template <class T, class U>\n-void verify_constraints(T lo, T hi, U ulo, U uhi, U zeros, U ones);\n-#endif\n+  bool contains(T v) const;\n+  void verify_constraints() const;\n+#endif \/\/ ASSERT\n+};\n@@ -42,3 +64,3 @@\n-U cardinality_from_bounds(T lo, T hi, U ulo, U uhi) {\n-  if (U(lo) == ulo) {\n-    return uhi - ulo;\n+U cardinality_from_bounds(const RangeInt<T>& srange, const RangeInt<U>& urange) {\n+  if (U(srange._lo) == urange._lo) {\n+    return urange._hi - urange._lo;\n@@ -47,1 +69,1 @@\n-  return uhi - U(lo) + U(hi) - ulo + 1;\n+  return urange._hi - U(srange._lo) + U(srange._hi) - urange._lo + 1;\n@@ -50,3 +72,0 @@\n-template <class T, class U>\n-int normalize_widen(T lo, T hi, U ulo, U uhi, U zeros, U ones, int w);\n-\n@@ -54,1 +73,1 @@\n-const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(T, T, UT, UT, UT, UT, int, bool), bool dual);\n+const Type* int_type_xmeet(const CT* i1, const Type* t2, const Type* (*make)(const TypeIntPrototype<T, UT>&, int, bool), bool dual);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-  TypeInt::CC_NE   = TypeInt::make(-1, 1, 1, -1, 0, 1, WidenMin)->is_int();\n+  TypeInt::CC_NE   = TypeInt::make(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n@@ -483,1 +483,1 @@\n-  TypeInt::NON_ZERO= TypeInt::make(min_jint, max_jint, 1, -1, 0, 0, WidenMin)->is_int();\n+  TypeInt::NON_ZERO= TypeInt::make(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n@@ -502,1 +502,1 @@\n-  TypeLong::NON_ZERO= TypeLong::make(min_jlong, max_jlong, 1, -1, 0, 0, WidenMin)->is_long();\n+  TypeLong::NON_ZERO= TypeLong::make(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n@@ -1589,4 +1589,5 @@\n-TypeInt::TypeInt(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual)\n-  : TypeInteger(Int, normalize_widen(lo, hi, ulo, uhi, zeros, ones, w), dual),\n-    _lo(lo), _hi(hi), _ulo(ulo), _uhi(uhi), _zeros(zeros), _ones(ones) {\n-  DEBUG_ONLY(verify_constraints(lo, hi, ulo, uhi, zeros, ones));\n+TypeInt::TypeInt(const TypeIntPrototype<jint, juint>& t, int w, bool dual)\n+  : TypeInteger(Int, t.normalize_widen(w), dual),\n+    _lo(t._srange._lo), _hi(t._srange._hi), _ulo(t._urange._lo), _uhi(t._urange._hi),\n+    _zeros(t._bits._zeros), _ones(t._bits._ones) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -1595,4 +1596,3 @@\n-const Type* TypeInt::make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual) {\n-  bool empty = false;\n-  normalize_constraints(empty, lo, hi, ulo, uhi, zeros, ones);\n-  if (empty) {\n+const Type* TypeInt::make(const TypeIntPrototype<jint, juint>& t, int w, bool dual) {\n+  auto new_t = t.normalize_constraints();\n+  if (!new_t.first) {\n@@ -1601,1 +1601,1 @@\n-  return (new TypeInt(lo, hi, ulo, uhi, zeros, ones, w, dual))->hashcons()->is_int();\n+  return (new TypeInt(new_t.second, w, dual))->hashcons()->is_int();\n@@ -1605,1 +1605,3 @@\n-  return (new TypeInt(lo, lo, lo, lo, ~lo, lo, WidenMin, false))->hashcons()->is_int();\n+  juint ulo = lo;\n+  return (new TypeInt(TypeIntPrototype<jint, juint>{{lo, lo}, {ulo, ulo}, {~ulo, ulo}},\n+                      WidenMin, false))->hashcons()->is_int();\n@@ -1609,1 +1611,1 @@\n-  return make(lo, hi, 0, max_juint, 0, 0, w);\n+  return make(TypeIntPrototype<jint, juint>{{lo, hi}, {0, max_juint}, {0, 0}}, w);\n@@ -1612,6 +1614,2 @@\n-const Type* TypeInt::make_bits(juint zeros, juint ones, int w) {\n-  return make(min_jint, max_jint, 0, max_juint, zeros, ones, w);\n-}\n-\n-const Type* TypeInt::make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w) {\n-  return make(lo, hi, ulo, uhi, zeros, ones, w, false);\n+const Type* TypeInt::make(const TypeIntPrototype<jint, juint>& t, int w) {\n+  return make(t, w, false);\n@@ -1639,1 +1637,2 @@\n-  return new TypeInt(_lo, _hi, _ulo, _uhi, _zeros, _ones, _widen, !_dual);\n+  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, {_zeros, _ones}},\n+                     _widen, !_dual);\n@@ -1667,2 +1666,3 @@\n-    return (new TypeInt(ft->_lo, ft->_hi, ft->_ulo, ft->_uhi,\n-                        ft->_zeros, ft->_ones, this->_widen, false))->hashcons();\n+    return (new TypeInt(TypeIntPrototype<jint, juint>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi},\n+                                                      {ft->_zeros, ft->_ones}},\n+                        this->_widen, false))->hashcons();\n@@ -1719,4 +1719,5 @@\n-TypeLong::TypeLong(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual)\n-  : TypeInteger(Long, normalize_widen(lo, hi, ulo, uhi, zeros, ones, w), dual),\n-    _lo(lo), _hi(hi), _ulo(ulo), _uhi(uhi), _zeros(zeros), _ones(ones) {\n-  DEBUG_ONLY(verify_constraints(lo, hi, ulo, uhi, zeros, ones));\n+TypeLong::TypeLong(const TypeIntPrototype<jlong, julong>& t, int w, bool dual)\n+  : TypeInteger(Long, t.normalize_widen(w), dual),\n+    _lo(t._srange._lo), _hi(t._srange._hi), _ulo(t._urange._lo), _uhi(t._urange._hi),\n+    _zeros(t._bits._zeros), _ones(t._bits._ones) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -1725,4 +1726,3 @@\n-const Type* TypeLong::make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual) {\n-  bool empty = false;\n-  normalize_constraints(empty, lo, hi, ulo, uhi, zeros, ones);\n-  if (empty) {\n+const Type* TypeLong::make(const TypeIntPrototype<jlong, julong>& t, int w, bool dual) {\n+  auto new_t = t.normalize_constraints();\n+  if (!new_t.first) {\n@@ -1731,1 +1731,1 @@\n-  return (new TypeLong(lo, hi, ulo, uhi, zeros, ones, w, dual))->hashcons()->is_long();\n+  return (new TypeLong(new_t.second, w, dual))->hashcons()->is_long();\n@@ -1734,2 +1734,4 @@\n-const TypeLong* TypeLong::make(jlong lo ) {\n-  return (new TypeLong(lo, lo, lo, lo, ~lo, lo, WidenMin, false))->hashcons()->is_long();\n+const TypeLong* TypeLong::make(jlong lo) {\n+  julong ulo = lo;\n+  return (new TypeLong(TypeIntPrototype<jlong, julong>{{lo, lo}, {ulo, ulo}, {~ulo, ulo}},\n+                       WidenMin, false))->hashcons()->is_long();\n@@ -1739,5 +1741,1 @@\n-  return make(lo, hi, 0, max_julong, 0, 0, w);\n-}\n-\n-const Type* TypeLong::make_bits(julong zeros, julong ones, int w) {\n-  return make(min_jlong, max_jlong, 0, max_julong, zeros, ones, w);\n+  return make(TypeIntPrototype<jlong, julong>{{lo, hi}, {0, max_julong}, {0, 0}}, w);\n@@ -1746,2 +1744,2 @@\n-const Type* TypeLong::make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w) {\n-  return make(lo, hi, ulo, uhi, zeros, ones, w, false);\n+const Type* TypeLong::make(const TypeIntPrototype<jlong, julong>& t, int w) {\n+  return make(t, w, false);\n@@ -1769,1 +1767,2 @@\n-  return new TypeLong(_lo, _hi, _ulo, _uhi, _zeros, _ones, _widen, !_dual);\n+  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, {_zeros, _ones}},\n+                      _widen, !_dual);\n@@ -1797,2 +1796,3 @@\n-    return (new TypeLong(ft->_lo, ft->_hi, ft->_ulo, ft->_uhi,\n-                         ft->_zeros, ft->_ones, this->_widen, false))->hashcons();\n+    return (new TypeLong(TypeIntPrototype<jlong, julong>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi},\n+                                                         {ft->_zeros, ft->_ones}},\n+                         this->_widen, false))->hashcons();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+template <class T, class U>\n+class TypeIntPrototype;\n+\n@@ -557,1 +560,6 @@\n-  \/\/ Use to compute join of 2 sets\n+  \/\/ Previously, we signify that a set is in the dual space if _lo > _hi.\n+  \/\/ However, with the addition of unsigned range and known bits, this becomes\n+  \/\/ ambiguous whether the set is empty or a dual of a non-empty set.\n+  \/\/ As a result, we use this field to denote that a set is a dual set.\n+  \/\/ Dual sets are only used to compute the join of 2 sets, and not used\n+  \/\/ outside.\n@@ -583,2 +591,2 @@\n-  TypeInt(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual);\n-  static const Type* make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual);\n+  TypeInt(const TypeIntPrototype<jint, juint>& t, int w, bool dual);\n+  static const Type* make(const TypeIntPrototype<jint, juint>& t, int w, bool dual);\n@@ -594,3 +602,3 @@\n-  const jint _lo, _hi;          \/\/ Lower bound, upper bound\n-  const juint _ulo, _uhi;\n-  const juint _zeros, _ones;\n+  const jint _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const juint _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const juint _zeros, _ones; \/\/ Bits that are known to be 0 or 1\n@@ -603,2 +611,1 @@\n-  static const Type* make_bits(juint zeros, juint ones, int w);\n-  static const Type* make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w);\n+  static const Type* make(const TypeIntPrototype<jint, juint>& t, int w);\n@@ -661,2 +668,2 @@\n-  TypeLong(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual);\n-  static const Type* make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual);\n+  TypeLong(const TypeIntPrototype<jlong, julong>& t, int w, bool dual);\n+  static const Type* make(const TypeIntPrototype<jlong, julong>& t, int w, bool dual);\n@@ -673,3 +680,3 @@\n-  const jlong _lo, _hi;         \/\/ Lower bound, upper bound\n-  const julong _ulo, _uhi;\n-  const julong _zeros, _ones;\n+  const jlong _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const julong _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const julong _zeros, _ones; \/\/ Bits that are known to be 0 or 1\n@@ -682,2 +689,1 @@\n-  static const Type* make_bits(julong zeros, julong ones, int w);\n-  static const Type* make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w);\n+  static const Type* make(const TypeIntPrototype<jlong, julong>& t, int w);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -55,12 +55,7 @@\n-      T nlo = lo;\n-      T nhi = hi;\n-      U nulo = std::numeric_limits<U>::min();\n-      U nuhi = std::numeric_limits<U>::max();\n-      U nzeros = 0;\n-      U nones = 0;\n-      bool empty = false;\n-      normalize_constraints(empty, nlo, nhi, nulo, nuhi, nzeros, nones);\n-      DEBUG_ONLY(verify_constraints(nlo, nhi, nulo, nuhi, nzeros, nones));\n-      ASSERT_FALSE(empty);\n-      ASSERT_EQ(lo, nlo);\n-      ASSERT_EQ(hi, nhi);\n+      TypeIntPrototype<T, U> t{{lo, hi}, {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()},\n+                               {0, 0}};\n+      auto new_t = t.normalize_constraints();\n+      ASSERT_TRUE(new_t.first);\n+      DEBUG_ONLY(new_t.second.verify_constraints());\n+      ASSERT_EQ(lo, new_t.second._srange._lo);\n+      ASSERT_EQ(hi, new_t.second._srange._hi);\n@@ -68,2 +63,2 @@\n-        ASSERT_EQ(U(lo), nulo);\n-        ASSERT_EQ(U(hi), nuhi);\n+        ASSERT_EQ(U(lo), new_t.second._urange._lo);\n+        ASSERT_EQ(U(hi), new_t.second._urange._hi);\n@@ -71,2 +66,2 @@\n-        ASSERT_EQ(std::numeric_limits<U>::min(), nulo);\n-        ASSERT_EQ(std::numeric_limits<U>::max(), nuhi);\n+        ASSERT_EQ(std::numeric_limits<U>::min(), new_t.second._urange._lo);\n+        ASSERT_EQ(std::numeric_limits<U>::max(), new_t.second._urange._hi);\n@@ -79,12 +74,7 @@\n-      T nlo = std::numeric_limits<T>::min();\n-      T nhi = std::numeric_limits<T>::max();\n-      U nulo = ulo;\n-      U nuhi = uhi;\n-      U nzeros = 0;\n-      U nones = 0;\n-      bool empty = false;\n-      normalize_constraints(empty, nlo, nhi, nulo, nuhi, nzeros, nones);\n-      DEBUG_ONLY(verify_constraints(nlo, nhi, nulo, nuhi, nzeros, nones));\n-      ASSERT_FALSE(empty);\n-      ASSERT_EQ(ulo, nulo);\n-      ASSERT_EQ(uhi, nuhi);\n+      TypeIntPrototype<T, U> t{{std::numeric_limits<T>::min(), std::numeric_limits<T>::max()},\n+                               {ulo, uhi}, {0, 0}};\n+      auto new_t = t.normalize_constraints();\n+      ASSERT_TRUE(new_t.first);\n+      DEBUG_ONLY(new_t.second.verify_constraints());\n+      ASSERT_EQ(ulo, new_t.second._urange._lo);\n+      ASSERT_EQ(uhi, new_t.second._urange._hi);\n@@ -92,2 +82,2 @@\n-        ASSERT_EQ(T(ulo), nlo);\n-        ASSERT_EQ(T(uhi), nhi);\n+        ASSERT_EQ(T(ulo), new_t.second._srange._lo);\n+        ASSERT_EQ(T(uhi), new_t.second._srange._hi);\n@@ -95,2 +85,2 @@\n-        ASSERT_EQ(std::numeric_limits<T>::min(), nlo);\n-        ASSERT_EQ(std::numeric_limits<T>::max(), nhi);\n+        ASSERT_EQ(std::numeric_limits<T>::min(), new_t.second._srange._lo);\n+        ASSERT_EQ(std::numeric_limits<T>::max(), new_t.second._srange._hi);\n@@ -104,14 +94,9 @@\n-      T nlo = std::numeric_limits<T>::min();\n-      T nhi = std::numeric_limits<T>::max();\n-      U nulo = std::numeric_limits<U>::min();\n-      U nuhi = std::numeric_limits<U>::max();\n-      U nzeros = zeros;\n-      U nones = ones;\n-      bool empty = false;\n-      normalize_constraints(empty, nlo, nhi, nulo, nuhi, nzeros, nones);\n-      DEBUG_ONLY(verify_constraints(nlo, nhi, nulo, nuhi, nzeros, nones));\n-      ASSERT_FALSE(empty);\n-      ASSERT_EQ(zeros, nzeros);\n-      ASSERT_EQ(ones, nones);\n-      ASSERT_EQ(ones, nulo);\n-      ASSERT_EQ(~zeros, nuhi);\n+      TypeIntPrototype<T, U> t{{std::numeric_limits<T>::min(), std::numeric_limits<T>::max()},\n+                               {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()}, {zeros, ones}};\n+      auto new_t = t.normalize_constraints();\n+      ASSERT_TRUE(new_t.first);\n+      DEBUG_ONLY(new_t.second.verify_constraints());\n+      ASSERT_EQ(zeros, new_t.second._bits._zeros);\n+      ASSERT_EQ(ones, new_t.second._bits._ones);\n+      ASSERT_EQ(ones, new_t.second._urange._lo);\n+      ASSERT_EQ(~zeros, new_t.second._urange._hi);\n@@ -141,13 +126,2 @@\n-    T nlo = lo;\n-    T nhi = hi;\n-    U nulo = ulo;\n-    U nuhi = uhi;\n-    U nzeros = zeros;\n-    U nones = ones;\n-    bool empty = false;\n-    normalize_constraints(empty, nlo, nhi, nulo, nuhi, nzeros, nones);\n-    auto contains = [](T lo, T hi, U ulo, U uhi, U zeros, U ones, T value) {\n-      U u = value;\n-      return value >= lo && value <= hi && u >= ulo && u <= uhi &&\n-             (u & zeros) == 0 && (~u & ones) == 0;\n-    };\n+    TypeIntPrototype<T, U> t{{lo, hi}, {ulo, uhi}, {zeros, ones}};\n+    auto new_t = t.normalize_constraints();\n@@ -155,2 +129,2 @@\n-    if (!empty) {\n-      verify_constraints(nlo, nhi, nulo, nuhi, nzeros, nones);\n+    if (new_t.first) {\n+      new_t.second.verify_constraints();\n@@ -158,1 +132,0 @@\n-#endif \/\/ ASSERT\n@@ -161,2 +134,2 @@\n-      if (empty) {\n-        ASSERT_FALSE(contains(lo, hi, ulo, uhi, zeros, ones, v));\n+      if (!new_t.first) {\n+        ASSERT_FALSE(t.contains(v));\n@@ -164,1 +137,1 @@\n-        ASSERT_EQ(contains(lo, hi, ulo, uhi, zeros, ones, v), contains(nlo, nhi, nulo, nuhi, nzeros, nones, v));\n+        ASSERT_EQ(t.contains(v), new_t.second.contains(v));\n@@ -168,0 +141,1 @@\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":39,"deletions":65,"binary":false,"changes":104,"status":"modified"}]}