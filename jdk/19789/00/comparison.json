{"files":[{"patch":"@@ -3432,0 +3432,1 @@\n+    call->_has_ea_local_in_scope = _has_ea_local_in_scope;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+        new EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target()                .run();\n@@ -416,0 +417,1 @@\n+        new EARelockingSimpleWithAccessInOtherThread_02_DynamicCall()                 .run(this);\n@@ -1854,0 +1856,89 @@\n+\/\/ The debugger reads and publishes an object with eliminated locking to an instance field.\n+\/\/ A 2nd thread in the debuggee finds it there and changes its state using a synchronized method.\n+\/\/ Without eager relocking the accesses are unsynchronized which can be observed.\n+\/\/ This is a variant of EARelockingSimpleWithAccessInOtherThread with a dynamic call (not devirtualized).\n+class EARelockingSimpleWithAccessInOtherThread_02_DynamicCall extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        String l1ClassName = EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target.SyncCounter.class.getName();\n+        ObjectReference ctr = getLocalRef(bpe.thread().frame(2), l1ClassName, \"l1\");\n+        setField(testCase, \"sharedCounter\", ctr);\n+        terminateEndlessLoop();\n+    }\n+}\n+\n+class EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target extends EATestCaseBaseTarget {\n+\n+    public static final BrkPtDispatchA[] disp =\n+        {new BrkPtDispatchA(), new BrkPtDispatchB(), new BrkPtDispatchC(), new BrkPtDispatchD()};\n+\n+    public static class BrkPtDispatchA {\n+        public EATestCaseBaseTarget testCase;\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchB extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchC extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchD extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() {\n+            testCase.dontinline_brkpt();\n+        }\n+    }\n+\n+    public static class SyncCounter {\n+        private int val;\n+        public synchronized int inc() { return val++; }\n+    }\n+\n+    public volatile SyncCounter sharedCounter;\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        for (BrkPtDispatchA d : disp) {\n+            d.testCase = this;\n+        }\n+        doLoop = true;\n+        new Thread(() -> {\n+                while (doLoop) {\n+                    SyncCounter ctr = sharedCounter;\n+                    if (ctr != null) {\n+                        ctr.inc();\n+                    }\n+                }\n+            }).start();\n+    }\n+\n+    public int dispCount;\n+    public void dontinline_testMethod() {\n+        SyncCounter l1 = new SyncCounter();\n+        synchronized (l1) {      \/\/ Eliminated locking\n+            l1.inc();\n+            \/\/ Use different types for the subsequent call to prevent devirtualization.\n+            BrkPtDispatchA d = disp[(dispCount++) & 3];\n+            d.dontinline_brkpt();  \/\/ Dynamic call. Debugger publishes l1 to sharedCounter.\n+            iResult = l1.inc();    \/\/ Changes by the 2nd thread will be observed if l1\n+                                   \/\/ was not relocked before passing it to the debugger.\n+        }\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 1;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"}]}