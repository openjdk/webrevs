{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -797,0 +797,9 @@\n+            \/\/ In the Middlebox Compatibility Mode the server sends a\n+            \/\/ dummy change_cipher_spec record immediately after its\n+            \/\/ first handshake message. This may either be after\n+            \/\/ a ServerHello or a HelloRetryRequest.\n+            \/\/(RFC 8446, Appendix D.4)\n+            shc.conContext.outputRecord.changeWriteCiphers(\n+                SSLWriteCipher.nullTlsWriteCipher(),\n+                    (clientHello.sessionId.length() != 0));\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test for out-of-sequence change_cipher_spec in TLSv1.3\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm EngineOutOfSeqCCS isHRRTest\n+ * @run main\/othervm EngineOutOfSeqCCS\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLParameters;\n+\n+\n+\n+public class EngineOutOfSeqCCS extends SSLEngineTemplate {\n+\n+    \/*\n+     * Enables logging of the SSLEngine operations.\n+     *\/\n+    private static final boolean logging = true;\n+    private static final boolean dumpBufs = true;\n+\n+    \/\/ Define a few basic TLS records we might need\n+    private static final int TLS_RECTYPE_CCS = 0x14;\n+    private static final int TLS_RECTYPE_ALERT = 0x15;\n+    private static final int TLS_RECTYPE_HANDSHAKE = 0x16;\n+    private static final int TLS_RECTYPE_APPDATA = 0x17;\n+\n+    SSLEngineResult clientResult, serverResult;\n+\n+    public EngineOutOfSeqCCS() throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String args[]) throws Exception{\n+        if(args.length > 0 && args[0].compareTo(\"isHRRTest\") == 0){\n+                new EngineOutOfSeqCCS().runDemo(true);\n+        }\n+        else\n+            new EngineOutOfSeqCCS().runDemo(false);\n+    }\n+\n+    private void runDemo(boolean isHRRTest) throws Exception {\n+\n+            if(isHRRTest){\n+                SSLParameters sslParams = new SSLParameters();\n+                sslParams.setNamedGroups(new String[] {\"secp384r1\"});\n+                serverEngine.setSSLParameters(sslParams);\n+            }\n+            \/\/ Client generates Client Hello\n+            clientResult = clientEngine.wrap(clientOut, cTOs);\n+            log(\"client wrap: \", clientResult);\n+            runDelegatedTasks(clientEngine);\n+            cTOs.flip();\n+            dumpByteBuffer(\"CLIENT-TO-SERVER\", cTOs);\n+\n+            \/\/ Server consumes Client Hello\n+            serverResult = serverEngine.unwrap(cTOs, serverIn);\n+            log(\"server unwrap: \", serverResult);\n+            runDelegatedTasks(serverEngine);\n+            cTOs.compact();\n+\n+            \/\/ Server generates ServerHello\/HelloRetryRequest\n+            serverResult = serverEngine.wrap(serverOut, sTOc);\n+            log(\"server wrap: \", serverResult);\n+            runDelegatedTasks(serverEngine);\n+            sTOc.flip();\n+\n+            dumpByteBuffer(\"SERVER-TO-CLIENT\", sTOc);\n+\n+            \/\/ client consumes ServerHello\/HelloRetryRequest\n+            clientResult = clientEngine.unwrap(sTOc, clientIn);\n+            log(\"client unwrap: \", clientResult);\n+            runDelegatedTasks(clientEngine);\n+            sTOc.compact();\n+\n+            \/\/ Server generates CCS\n+            serverResult = serverEngine.wrap(serverOut, sTOc);\n+            log(\"server wrap: \", serverResult);\n+            runDelegatedTasks(serverEngine);\n+            sTOc.flip();\n+            dumpByteBuffer(\"SERVER-TO-CLIENT\", sTOc);\n+\n+            if (isTlsMessage(sTOc, TLS_RECTYPE_CCS)) {\n+                System.out.println(\"=========== CCS found ===========\");\n+            }\n+            else{\n+                \/\/ In the Middlebox Compatibility Mode the server sends a\n+                \/\/ dummy change_cipher_spec record immediately after its\n+                \/\/ first handshake message. This may either be after\n+                \/\/ a ServerHello or a HelloRetryRequest.\n+                \/\/(RFC 8446, Appendix D.4)\n+                throw new SSLException(\n+                    \"Server should generate change_cipher_spec record\");\n+            }\n+            clientEngine.closeOutbound();\n+            serverEngine.closeOutbound();\n+    }\n+\n+    \/**\n+     * Look at an incoming TLS record and see if it is the desired\n+     * record type, and where appropriate the correct subtype.\n+     *\n+     * @param srcRecord The input TLS record to be evaluated.  This\n+     *        method will only look at the leading message if multiple\n+     *        TLS handshake messages are coalesced into a single record.\n+     * @param reqRecType The requested TLS record type\n+     * @param recParams Zero or more integer sub type fields.  For CCS\n+     *        and ApplicationData, no params are used.  For handshake records,\n+     *        one value corresponding to the HandshakeType is required.\n+     *        For Alerts, two values corresponding to AlertLevel and\n+     *        AlertDescription are necessary.\n+     *\n+     * @return true if the proper handshake message is the first one\n+     *         in the input record, false otherwise.\n+     *\/\n+    private boolean isTlsMessage(ByteBuffer srcRecord, int reqRecType,\n+            int... recParams) {\n+        boolean foundMsg = false;\n+\n+        if (srcRecord.hasRemaining()) {\n+            srcRecord.mark();\n+\n+            \/\/ Grab the fields from the TLS Record\n+            int recordType = Byte.toUnsignedInt(srcRecord.get());\n+            byte ver_major = srcRecord.get();\n+            byte ver_minor = srcRecord.get();\n+            int recLen = Short.toUnsignedInt(srcRecord.getShort());\n+\n+            if (recordType == reqRecType) {\n+                \/\/ For any zero-length recParams, making sure the requested\n+                \/\/ type is sufficient.\n+                if (recParams.length == 0) {\n+                    foundMsg = true;\n+                } else {\n+                    switch (recordType) {\n+                        case TLS_RECTYPE_CCS:\n+                        case TLS_RECTYPE_APPDATA:\n+                            \/\/ We really shouldn't find ourselves here, but\n+                            \/\/ if someone asked for these types and had more\n+                            \/\/ recParams we can ignore them.\n+                            foundMsg = true;\n+                            break;\n+                        case TLS_RECTYPE_ALERT:\n+                            \/\/ Needs two params, AlertLevel and\n+                            \/\/AlertDescription\n+                            if (recParams.length != 2) {\n+                                throw new RuntimeException(\n+                                    \"Test for Alert requires level and desc.\");\n+                            } else {\n+                                int level = Byte.toUnsignedInt(\n+                                            srcRecord.get());\n+                                int desc = Byte.toUnsignedInt(srcRecord.get());\n+                                if (level == recParams[0] &&\n+                                        desc == recParams[1]) {\n+                                    foundMsg = true;\n+                                }\n+                            }\n+                            break;\n+                        case TLS_RECTYPE_HANDSHAKE:\n+                            \/\/ Needs one parameter, HandshakeType\n+                            if (recParams.length != 1) {\n+                                throw new RuntimeException(\n+                                    \"Test for Handshake requires only HS type\");\n+                            } else {\n+                                \/\/ Go into the first handhshake message in the\n+                                \/\/ record and grab the handshake message header.\n+                                \/\/ All we need to do is parse out the leading\n+                                \/\/ byte.\n+                                int msgHdr = srcRecord.getInt();\n+                                int msgType = (msgHdr >> 24) & 0x000000FF;\n+                                if (msgType == recParams[0]) {\n+                                foundMsg = true;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            srcRecord.reset();\n+        }\n+\n+        return foundMsg;\n+    }\n+\n+    private static String tlsRecType(int type) {\n+        switch (type) {\n+            case 20:\n+                return \"Change Cipher Spec\";\n+            case 21:\n+                return \"Alert\";\n+            case 22:\n+                return \"Handshake\";\n+            case 23:\n+                return \"Application Data\";\n+            default:\n+                return (\"Unknown (\" + type + \")\");\n+        }\n+    }\n+\n+    \/*\n+     * Logging code\n+     *\/\n+    private static boolean resultOnce = true;\n+\n+    private static void log(String str, SSLEngineResult result) {\n+        if (!logging) {\n+            return;\n+        }\n+        if (resultOnce) {\n+            resultOnce = false;\n+            System.out.println(\"The format of the SSLEngineResult is: \\n\" +\n+                \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\" +\n+                \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n+        }\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+        log(str +\n+            result.getStatus() + \"\/\" + hsStatus + \", \" +\n+            result.bytesConsumed() + \"\/\" + result.bytesProduced() +\n+            \" bytes\");\n+        if (hsStatus == HandshakeStatus.FINISHED) {\n+            log(\"\\t...ready for application data\");\n+        }\n+    }\n+\n+    private static void log(String str) {\n+        if (logging) {\n+            System.out.println(str);\n+        }\n+    }\n+\n+    \/**\n+     * Hex-dumps a ByteBuffer to stdout.\n+     *\/\n+    private static void dumpByteBuffer(String header, ByteBuffer bBuf) {\n+        if (dumpBufs == false) {\n+            return;\n+        }\n+\n+        int bufLen = bBuf.remaining();\n+        if (bufLen > 0) {\n+            bBuf.mark();\n+\n+            \/\/ We expect the position of the buffer to be at the\n+            \/\/ beginning of a TLS record.  Get the type, version and length.\n+            int type = Byte.toUnsignedInt(bBuf.get());\n+            int ver_major = Byte.toUnsignedInt(bBuf.get());\n+            int ver_minor = Byte.toUnsignedInt(bBuf.get());\n+            int recLen = Short.toUnsignedInt(bBuf.getShort());\n+\n+            log(\"===== \" + header + \" (\" + tlsRecType(type) + \" \/ \" +\n+                ver_major + \".\" + ver_minor + \" \/ \" +\n+                bufLen + \" bytes) =====\");\n+            bBuf.reset();\n+            for (int i = 0; i < bufLen; i++) {\n+                if (i != 0 && i % 16 == 0) {\n+                    System.out.print(\"\\n\");\n+                }\n+                System.out.format(\"%02X \", bBuf.get(i));\n+            }\n+            log(\"\\n===============================================\");\n+            bBuf.reset();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/EngineOutOfSeqCCS.java","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"}]}