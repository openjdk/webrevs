{"files":[{"patch":"@@ -1845,0 +1845,3 @@\n+  assert(type == T_VOID || current_frame.interpreter_frame_expression_stack_size() > 0,\n+      \"Stack shouldn't be empty\");\n+\n@@ -1848,3 +1851,0 @@\n-  \/\/ Deferred transition to VM, so we can stash away the return oop before GC\n-  \/\/ Note that this transition is not needed when throwing an exception, because\n-  \/\/ there is no oop to retain.\n@@ -1852,2 +1852,3 @@\n-  {\n-    ThreadInVMfromJava tiv(thread);\n+  \/\/ Deferred transition to VM, so we can stash away the return oop before GC\n+  JavaThread* current = thread; \/\/ for JRT_BLOCK\n+  JRT_BLOCK\n@@ -1855,1 +1856,0 @@\n-  }\n@@ -1857,10 +1857,10 @@\n-  if (state == nullptr || !state->is_interp_only_mode()) {\n-    \/\/ for any thread that actually wants method exit, interp_only_mode is set\n-    return;\n-  }\n-  if (state->is_enabled(JVMTI_EVENT_METHOD_EXIT) && is_reference_type(type)) {\n-    value.l = JNIHandles::make_local(thread, result());\n-  }\n-  \/\/ Do not allow NotifyFramePop to add new FramePop event request at\n-  \/\/ depth 0 as it is already late in the method exiting dance.\n-  state->set_top_frame_is_exiting();\n+    if (state == nullptr || !state->is_interp_only_mode()) {\n+      \/\/ for any thread that actually wants method exit, interp_only_mode is set\n+      return;\n+    }\n+    if (state->is_enabled(JVMTI_EVENT_METHOD_EXIT) && is_reference_type(type)) {\n+      value.l = JNIHandles::make_local(thread, result());\n+    }\n+    \/\/ Do not allow NotifyFramePop to add new FramePop event request at\n+    \/\/ depth 0 as it is already late in the method exiting dance.\n+    state->set_top_frame_is_exiting();\n@@ -1868,2 +1868,0 @@\n-  JavaThread* current = thread; \/\/ for JRT_BLOCK\n-  JRT_BLOCK\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-            disableAndCheck();\n@@ -54,1 +53,1 @@\n-            \/\/expected\n+            disableAndCheck();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/ExceptionOccurred.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,10 @@\n+  jstring upcall_result = (jstring) jni->CallStaticObjectMethod(main_class, upcall_method);\n+  const char *str = jni->GetStringUTFChars(upcall_result, NULL);\n+  if (str == NULL) {\n+    fatal(jni ,\"Failed to convert Java string to C string.\");\n+    return;\n+  }\n+  if (strcmp(\"MyNewString\", str) != 0) {\n+    fatal(jni, \"The upCall result value is incorrect.\");\n+  }\n+  jni->ReleaseStringUTFChars(upcall_result, str);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/ExceptionOccurred\/libExceptionOccurred.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}