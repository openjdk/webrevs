{"files":[{"patch":"@@ -423,0 +423,1 @@\n+  assert(thread->thread_state() == _thread_in_vm, \"thread should be in vm\");\n@@ -1833,11 +1834,1 @@\n-\n-  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n-\n-  if (state == nullptr || !state->is_interp_only_mode()) {\n-    \/\/ for any thread that actually wants method exit, interp_only_mode is set\n-    return;\n-  }\n-\n-  \/\/ return a flag when a method terminates by throwing an exception\n-  \/\/ i.e. if an exception is thrown and it's not caught by the current method\n-  bool exception_exit = state->is_exception_detected() && !state->is_exception_caught();\n+  oop oop_result;\n@@ -1846,16 +1837,7 @@\n-  value.j = 0L;\n-\n-  if (state->is_enabled(JVMTI_EVENT_METHOD_EXIT)) {\n-    \/\/ if the method hasn't been popped because of an exception then we populate\n-    \/\/ the return_value parameter for the callback. At this point we only have\n-    \/\/ the address of a \"raw result\" and we just call into the interpreter to\n-    \/\/ convert this into a jvalue.\n-    if (!exception_exit) {\n-      oop oop_result;\n-      BasicType type = current_frame.interpreter_frame_result(&oop_result, &value);\n-      if (is_reference_type(type)) {\n-        result = Handle(thread, oop_result);\n-        value.l = JNIHandles::make_local(thread, result());\n-      }\n-    }\n-  }\n+  value.l = 0L;\n+  \/\/ post_method_exit is only called when the method exits normally,\n+  \/\/ so result should be always initialized.\n+  \/\/ At this point we only have the address of a \"raw result\" and\n+  \/\/ we just call into the interpreter to convert this into a jvalue.\n+  \/\/ Additionally, the result oop should be preserved while the thread is in java.\n+  BasicType type = current_frame.interpreter_frame_result(&oop_result, &value);\n@@ -1863,3 +1845,2 @@\n-  \/\/ Do not allow NotifyFramePop to add new FramePop event request at\n-  \/\/ depth 0 as it is already late in the method exiting dance.\n-  state->set_top_frame_is_exiting();\n+  assert(type == T_VOID || current_frame.interpreter_frame_expression_stack_size() > 0,\n+      \"Stack shouldn't be empty\");\n@@ -1867,0 +1848,4 @@\n+  if (is_reference_type(type)) {\n+    result = Handle(thread, oop_result);\n+  }\n+  JvmtiThreadState *state;\n@@ -1868,2 +1853,0 @@\n-  \/\/ Note that this transition is not needed when throwing an exception, because\n-  \/\/ there is no oop to retain.\n@@ -1872,1 +1855,14 @@\n-    post_method_exit_inner(thread, mh, state, exception_exit, current_frame, value);\n+    state = get_jvmti_thread_state(thread);\n+\n+    if (state == nullptr || !state->is_interp_only_mode()) {\n+      \/\/ for any thread that actually wants method exit, interp_only_mode is set\n+      return;\n+    }\n+    if (state->is_enabled(JVMTI_EVENT_METHOD_EXIT) && is_reference_type(type)) {\n+      value.l = JNIHandles::make_local(thread, result());\n+    }\n+    \/\/ Do not allow NotifyFramePop to add new FramePop event request at\n+    \/\/ depth 0 as it is already late in the method exiting dance.\n+    state->set_top_frame_is_exiting();\n+\n+    post_method_exit_inner(thread, mh, state,false, current_frame, value);\n@@ -1875,1 +1871,1 @@\n-  \/\/ The JRT_BLOCK_END can safepoint in ThreadInVMfromJava desctructor. Now it is safe to allow\n+  \/\/ The JRT_BLOCK_END can safepoint in ThreadInVMfromJava destructor. Now it is safe to allow\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":30,"deletions":34,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test verifies that MethodExit event is correctly posted\n+ * if method is called while there is a pending exception on this thread.\n+ *\n+ * @bug 8365192\n+ * @run main\/othervm\/native -agentlib:TestMethodExitWithPendingException TestMethodExitWithPendingException\n+ *\/\n+public class TestMethodExitWithPendingException {\n+\n+    private static native void enable();\n+    private static native void disableAndCheck();\n+\n+    static String exceptionExit() {\n+        throw new RuntimeException(\"MyRuntimeException\");\n+    }\n+\n+\n+    \/\/ Called from ExceptionExit MethodExit callback via JNI\n+    static String upCall() {\n+        return \"MyNewString\";\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        System.loadLibrary(\"TestMethodExitWithPendingException\");\n+        try {\n+            enable();\n+            exceptionExit();\n+        } catch (RuntimeException e){\n+            disableAndCheck();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/PendingException\/TestMethodExitWithPendingException.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+#include \"jvmti_common.hpp\"\n+\n+jvmtiEnv* jvmti_env;\n+\n+bool method_exit_posted = false;\n+\/\/ This method exit callback actually works only for 2 methods:\n+\/\/ 1) for ExceptionExit it verifies that method exit\n+\/\/    has been popped by exception and call 'upCall' mthod using JNI.\n+\/\/ 2) for upCall method it verifies that event has correct\n+\/\/    return value and was not popped by exception.\n+\/\/ The event callback just exits for all other methods.\n+static void JNICALL\n+cbMethodExit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+             jboolean was_popped_by_exception, jvalue return_value) {\n+  const char * mname = get_method_name(jvmti, jni, method);\n+  if (strcmp(\"upCall\", mname) == 0) {\n+    if (was_popped_by_exception) {\n+      fatal(jni, \"The method's was_popped_by_exception value is incorrect.\");\n+    }\n+    jstring upcall_result = (jstring) return_value.l;\n+    const char *str = jni->GetStringUTFChars(upcall_result, nullptr);\n+    if (str == nullptr) {\n+      fatal(jni ,\"Failed to convert Java string to C string.\");\n+    }\n+    if (strcmp(\"MyNewString\", str) != 0) {\n+      fatal(jni, \"The upCall result value is incorrect.\");\n+    }\n+    method_exit_posted = true;\n+  }\n+  if (strcmp(\"exceptionExit\", mname) != 0) {\n+    return;\n+  }\n+  if (!was_popped_by_exception) {\n+    fatal(jni, \"Should have was_popped_by_esxception = true.\");\n+  }\n+  jclass main_class = jni->FindClass(\"TestMethodExitWithPendingException\");\n+  if (main_class == nullptr) {\n+    fatal(jni,\"Can't find TestMethodExitWithPendingException class.\");\n+    return;\n+  }\n+  jmethodID upcall_method = jni->GetStaticMethodID(main_class,\n+      \"upCall\", \"()Ljava\/lang\/String;\");\n+  if (upcall_method == nullptr) {\n+    fatal(jni,\"Can't find upCall method.\");\n+  }\n+  \/\/ Call 'upCall' method while current thread has exception\n+  \/\/ that has been thrown but hasn't been caught yet.\n+  jstring upcall_result = (jstring) jni->CallStaticObjectMethod(main_class, upcall_method);\n+  const char *str = jni->GetStringUTFChars(upcall_result, nullptr);\n+  if (str == nullptr) {\n+    fatal(jni ,\"Failed to convert Java string to C string.\");\n+    return;\n+  }\n+  if (strcmp(\"MyNewString\", str) != 0) {\n+    fatal(jni, \"The upCall result value is incorrect.\");\n+  }\n+  jni->ReleaseStringUTFChars(upcall_result, str);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  capabilities.can_generate_method_exit_events = true;\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+  jvmtiEventCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.MethodExit = &cbMethodExit;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+  jvmti_env = jvmti;\n+ return JNI_OK;\n+}\n+\n+\n+extern \"C\" {\n+JNIEXPORT void JNICALL\n+Java_TestMethodExitWithPendingException_enable(JNIEnv *jni, jclass clazz) {\n+  jthread thread = get_current_thread(jvmti_env, jni);\n+  jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, thread);\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_TestMethodExitWithPendingException_disableAndCheck(JNIEnv *jni, jclass clazz) {\n+  jthread thread = get_current_thread(jvmti_env, jni);\n+  jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_EXIT, thread);\n+  if (!method_exit_posted) {\n+    fatal(jni, \"Failed to post method exit event.\");\n+  }\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/PendingException\/libTestMethodExitWithPendingException.cpp","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"}]}