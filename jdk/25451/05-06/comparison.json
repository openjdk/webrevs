{"files":[{"patch":"@@ -2237,10 +2237,3 @@\n-     * Return the base type of t or any of its strictly enclosing types that start\n-     * with the given symbol. If none exists, return null.\n-     *\n-     * This is typically used when there is an explicit qualification of a type.\n-     * The qualified part may either be a parameter or not.\n-     * Example: user writes {@code G.m()} and {@code <G extends A<String>}\n-     * ({@code m()} is an inherited member).\n-     *\n-     * Note, if there's an explicit qualifier, both {@code asEnclosingSuper} and\n-     * {@code asOuterSuper} are equivalent.\n+     * Return the base type of t or any of its outer types (by following the types enclosing type)\n+     * that start with the given symbol.\n+     * If none exists, return null.\n@@ -2252,15 +2245,1 @@\n-        switch (t.getTag()) {\n-        case CLASS:\n-            do {\n-                Type s = asSuper(t, sym);\n-                if (s != null) return s;\n-                t = t.getEnclosingType();\n-            } while (t.hasTag(CLASS));\n-            return null;\n-        case TYPEVAR:\n-            return asSuper(t, sym);\n-        case ERROR:\n-            return t;\n-        default:\n-            return null;\n-        }\n+        return asOuter(t, sym, Type::getEnclosingType);\n@@ -2270,10 +2249,3 @@\n-     * Return the base type of t or any of its enclosing types (traversing potential\n-     * enclosing classes along the path) that start with the given symbol. If none\n-     * exists, return null.\n-     *\n-     * This is typically used when there is an implicit qualification of a type.\n-     * Example: user writes {@code B<?>} and the real type is a qualified path\n-     * {@code A<String>.B<?>}.\n-     *\n-     * Note, if there's an explicit qualifier, both {@code asEnclosingSuper} and\n-     * {@code asOuterSuper} are equivalent.\n+     * Return the base type of t or any of its outer types (by following owner's\n+     * enclosing class) that start with the given symbol.\n+     * If none exists, return null.\n@@ -2285,15 +2257,25 @@\n-        switch (t.getTag()) {\n-            case CLASS: do {\n-                Type s = asSuper(t, sym);\n-                if (s != null) return s;\n-                t = (t.tsym.owner.enclClass() != null)\n-                        ? t.tsym.owner.enclClass().type\n-                        : Type.noType;\n-            } while (t.hasTag(CLASS));\n-            return null;\n-        case TYPEVAR:\n-            return asSuper(t, sym);\n-        case ERROR:\n-            return t;\n-        default:\n-            return null;\n+        return asOuter(t, sym, type -> getOwnerEnclosingClassType(type));\n+    }\n+\n+    private static Type getOwnerEnclosingClassType(Type type) {\n+        return (type.tsym.owner.enclClass() != null)\n+                ? type.tsym.owner.enclClass().type\n+                : Type.noType;\n+    }\n+\n+    \/**\n+     * Return the (most specific) base type of t that starts with\n+     * the given symbol. If it exists, the base type is returned.\n+     * Otherwise, a traversal of outer types attempts to find such\n+     * a base type. The traversal of the next outwards type is left\n+     * abstract, via the parameter nextType. If none exists, return null.\n+     *\n+     * @param t a type\n+     * @param sym a symbol\n+     * @param nextType a unary operator that emits the next type to be examined\n+     *\/\n+    public Type asOuter(Type t, Symbol sym, UnaryOperator<Type> nextType) {\n+        while (!t.hasTag(NONE)) {\n+            Type s = asSuper(t, sym);\n+            if (s != null) return s;\n+            t = nextType.apply(t);\n@@ -2301,0 +2283,1 @@\n+        return null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":33,"deletions":50,"binary":false,"changes":83,"status":"modified"}]}