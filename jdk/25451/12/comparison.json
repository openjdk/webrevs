{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.UnaryOperator;\n@@ -45,1 +46,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -52,1 +52,0 @@\n-import com.sun.tools.javac.comp.LambdaToMethod;\n@@ -2239,2 +2238,6 @@\n-     * Return the base type of t or any of its outer types that starts\n-     * with the given symbol.  If none exists, return null.\n+     * Traverses a sequence of types starting with `t` and returns the first type\n+     * that can be seen as a supertype of one of those types.\n+     *\n+     * The sequence of types starts with `t` and the next type in the sequence\n+     * is obtained by calling `getEnclosingType()` on  the previous type in the\n+     * sequence.\n@@ -2246,17 +2249,1 @@\n-        switch (t.getTag()) {\n-        case CLASS:\n-            do {\n-                Type s = asSuper(t, sym);\n-                if (s != null) return s;\n-                t = t.getEnclosingType();\n-            } while (t.hasTag(CLASS));\n-            return null;\n-        case ARRAY:\n-            return isSubtype(t, sym.type) ? sym.type : null;\n-        case TYPEVAR:\n-            return asSuper(t, sym);\n-        case ERROR:\n-            return t;\n-        default:\n-            return null;\n-        }\n+        return asSuperClosure(t, sym, Type::getEnclosingType);\n@@ -2266,2 +2253,6 @@\n-     * Return the base type of t or any of its enclosing types that\n-     * starts with the given symbol.  If none exists, return null.\n+     * Traverses a sequence of types starting with `t` and returns the first type\n+     * that can be seen as a supertype of one of those types.\n+     *\n+     * The sequence of types starts with `t` and the next type in the sequence\n+     * is obtained by obtaining innermost lexically enclosing class type of the\n+     * previous type in the sequence.\n@@ -2273,19 +2264,26 @@\n-        switch (t.getTag()) {\n-        case CLASS:\n-            do {\n-                Type s = asSuper(t, sym);\n-                if (s != null) return s;\n-                Type outer = t.getEnclosingType();\n-                t = (outer.hasTag(CLASS)) ? outer :\n-                    (t.tsym.owner.enclClass() != null) ? t.tsym.owner.enclClass().type :\n-                    Type.noType;\n-            } while (t.hasTag(CLASS));\n-            return null;\n-        case ARRAY:\n-            return isSubtype(t, sym.type) ? sym.type : null;\n-        case TYPEVAR:\n-            return asSuper(t, sym);\n-        case ERROR:\n-            return t;\n-        default:\n-            return null;\n+        return asSuperClosure(t, sym, type -> getOwnerEnclosingClassType(type));\n+    }\n+    \/\/ where\n+    private static Type getOwnerEnclosingClassType(Type type) {\n+        return (type.tsym.owner.enclClass() != null)\n+                ? type.tsym.owner.enclClass().type\n+                : Type.noType;\n+    }\n+\n+    \/**\n+     * Traverses a sequence of types starting with `t` and returns the first type\n+     * that can be seen as a supertype of one of those types. The sequence of types\n+     * starts with `t` and is left abstract.\n+     *\n+     * The next type in the sequence is obtained by passing the previous type in\n+     * the sequence to the unary operator `nextType`.\n+     *\n+     * @param t a type\n+     * @param sym a symbol\n+     * @param nextType a unary operator that emits the next type to be examined\n+     *\/\n+    public Type asSuperClosure(Type t, Symbol sym, UnaryOperator<Type> nextType) {\n+        while (!t.hasTag(NONE)) {\n+            Type s = asSuper(t, sym);\n+            if (s != null) return s;\n+            t = nextType.apply(t);\n@@ -2293,0 +2291,1 @@\n+        return null;\n@@ -4517,1 +4516,1 @@\n-        List<Type> commonSupers = superClosure(to, erasure(from));\n+        List<Type> commonSupers = supertypeClosure(to, erasure(from));\n@@ -4575,1 +4574,1 @@\n-    private List<Type> superClosure(Type t, Type s) {\n+    private List<Type> supertypeClosure(Type t, Type s) {\n@@ -4581,1 +4580,1 @@\n-                cl = union(cl, superClosure(l.head, s));\n+                cl = union(cl, supertypeClosure(l.head, s));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":44,"deletions":45,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -4676,5 +4676,2 @@\n-                    else if (ownOuter.hasTag(CLASS) && site != ownOuter) {\n-                        Type normOuter = site;\n-                        if (normOuter.hasTag(CLASS)) {\n-                            normOuter = types.asEnclosingSuper(site, ownOuter.tsym);\n-                        }\n+                    else if ((ownOuter.hasTag(CLASS) || ownOuter.hasTag(TYPEVAR)) && site != ownOuter) {\n+                        Type normOuter = types.asEnclosingSuper(site, ownOuter.tsym);\n@@ -5066,2 +5063,2 @@\n-                        if (site.hasTag(CLASS))\n-                            site = types.asOuterSuper(site, clazzOuter.tsym);\n+                        if (site.hasTag(CLASS) || site.hasTag(TYPEVAR))\n+                            site = types.asEnclosingSuper(site, clazzOuter.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8357472\n+ * @summary NPE in Types.containsType for type variable used as a qualifier\n+ * @compile T8357472.java\n+ *\/\n+\n+class T8357472 {\n+    class A<T> {\n+        protected class B<V> {}\n+\n+        public static <T, M extends A<T>> void f(Object g) {\n+            @SuppressWarnings(\"unchecked\")\n+            M.B<?> mapping = (M.B<?>) g;\n+            M.B<?>[] mapping2 = new M.B[1];\n+            mapping2[0] = mapping;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8357472.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8357653\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ * @summary Inner classes of type parameters emitted as raw types in signatures\n+ * @build toolbox.ToolBox toolbox.JavapTask\n+ * @run main T8357653\n+ *\/\n+import toolbox.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Gatherers;\n+import java.util.stream.Stream;\n+\n+public class T8357653 extends TestRunner {\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new T8357653().runTests();\n+    }\n+\n+    T8357653() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testCompilation(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+            \"\"\"\n+            package test;\n+            public class Test {\n+                static abstract class Getters<X> {\n+                  abstract class Getter {\n+                      abstract X get();\n+                  }\n+                }\n+\n+                static class Usage1<T, G extends Getters<T>> {\n+                  public T test(G.Getter getter) {\n+                      return getter.get();\n+                  }\n+                }\n+\n+                static class Usage2<T, U extends Getters<T>, G extends U> {\n+                  public T test(G.Getter getter) {\n+                      return getter.get();\n+                  }\n+                }\n+\n+                static class Usage3<T, U extends T, G extends Getters<T>> {\n+                  public T test(G.Getter getter) {\n+                      return getter.get();\n+                  }\n+                }\n+\n+                class G2<K> extends Getters<K> {}\n+                static class Usage4<M, L extends G2<M>> {\n+                  M test(L.Getter getter) {\n+                      return getter.get();\n+                  }\n+                }\n+            }\n+            \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        {\n+            new JavacTask(tb)\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll();\n+        }\n+    }\n+\n+    @Test\n+    public void testCompilationArray(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package test;\n+                public class Test {\n+                    static abstract class Getters<X> {\n+                      abstract class Getter {\n+                          abstract X get();\n+                      }\n+                    }\n+\n+                    static class Usage1<T, G extends Getters<T>> {\n+                      public T test(G.Getter[] getter) {\n+                          return getter[0].get();\n+                      }\n+                    }\n+\n+                    static class Usage2<T, U extends Getters<T>, G extends U> {\n+                      public T test(G.Getter[] getter) {\n+                          return getter[0].get();\n+                      }\n+                    }\n+\n+                    static class Usage3<T, U extends T, G extends Getters<T>> {\n+                      public T test(G.Getter[] getter) {\n+                          return getter[0].get();\n+                      }\n+                    }\n+\n+                    class G2<K> extends Getters<K> {}\n+                    static class Usage4<M, L extends G2<M>> {\n+                      M test(L.Getter[] getter) {\n+                          return getter[0].get();\n+                      }\n+                    }\n+                }\n+                \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        {\n+            new JavacTask(tb)\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll();\n+        }\n+    }\n+\n+    @Test\n+    public void testErasureViaJavap(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package test;\n+                public class Test {\n+                    static abstract class Getters<X> {\n+                      abstract class Getter {\n+                          abstract X get();\n+                      }\n+                    }\n+\n+                    static class Usage1<T, G extends Getters<T>> {\n+                      public T test(G.Getter getter) {\n+                          return getter.get();\n+                      }\n+                    }\n+                }\n+                \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        {\n+            new JavacTask(tb)\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll();\n+\n+            String javapOut = new JavapTask(tb)\n+                    .options(\"-v\")\n+                    .classpath(classes.toString())\n+                    .classes(\"test.Test$Usage1\")\n+                    .run()\n+                    .getOutput(Task.OutputKind.DIRECT);\n+\n+            if (!javapOut.contains(\"Signature: #21                          \/\/ <T:Ljava\/lang\/Object;G:Ltest\/Test$Getters<TT;>;>Ljava\/lang\/Object;\"))\n+                throw new AssertionError(\"Wrongly erased generated signature:\\n\" + javapOut);\n+        }\n+    }\n+\n+    @Test\n+    public void testGenericsViaReflection(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package test;\n+                import java.lang.reflect.*;\n+                import java.util.Arrays;\n+\n+                public class Test {\n+                    public static void main(String[] args) throws Throwable {\n+                        new test.Test().test();\n+                    }\n+\n+                    public void test() throws Throwable  {\n+                        var m = getClass().getDeclaredMethod(\"getOwner\", Test.Base.Handler.class);\n+                        System.out.println(m);\n+                        System.out.println(Arrays.toString(m.getGenericParameterTypes()));\n+                        System.out.println(m.getGenericReturnType());\n+                    }\n+\n+                     <S extends Base<S>> S getOwner(S.Handler handler) {\n+                        return handler.owner();\n+                     }\n+\n+                     abstract class Base<S extends Base<S>> {\n+                        class Handler {\n+                            @SuppressWarnings(\"unchecked\")\n+                            S owner() {\n+                                return (S) Base.this;\n+                            }\n+                        }\n+                     }\n+                }\n+                \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        {\n+            new JavacTask(tb)\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll();\n+\n+            var out = new JavaTask(tb)\n+                    .classpath(classes.toString())\n+                    .className(\"test.Test\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.STDOUT);\n+\n+            var expectedOut = \"\"\"\n+                test.Test$Base test.Test.getOwner(test.Test$Base$Handler)\n+                [test.Test$Base<S>$Handler]\n+                S\n+                \"\"\";\n+\n+            containsOrdered(out, expectedOut, \"Wrongly erased generated signature:\\n\");\n+        }\n+    }\n+\n+    private static void containsOrdered(String expected, String actual, String message) {\n+        List<String> expectedLines = expected.lines().map(s -> s.strip()).toList();\n+        Stream<String> actualLines = actual.lines().map(s -> s.strip());\n+\n+        if (!actualLines.gather(Gatherers.windowSliding(expectedLines.size())).anyMatch(window -> window.equals(expectedLines)))\n+            throw new AssertionError(message + actual);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8357653.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8357653\n+ * @summary Inner classes of type parameters emitted as raw types in signatures\n+ * @compile T8357653b.java\n+ *\/\n+\n+class T8357653b {\n+    class A<T> {\n+        class B<W> {\n+            public T rett() { return null; }\n+        }\n+    }\n+\n+    class C extends A<String> {\n+        static class D {\n+            {\n+                B<?> b = null;\n+                String s = b.rett();\n+\n+                B<?>[] b2 = new B[1];\n+                String s2 = b2[0].rett();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8357653b.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}