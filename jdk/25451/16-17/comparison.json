{"files":[{"patch":"@@ -2236,33 +2236,21 @@\n-    \/\/\/ Traverses a sequence of types starting with `t` and returns the first type\n-    \/\/\/ that can be seen as a supertype of one of those types.\n-    \/\/\/\n-    \/\/\/ The sequence of types starts with `t` and the next type in the sequence\n-    \/\/\/ is obtained by calling `getEnclosingType()` on the previous type in the\n-    \/\/\/ sequence.\n-    \/\/\/\n-    \/\/\/ Example: The field `f` needs to be resolved. Its site is `Outer.Sub.I` and\n-    \/\/\/ outer type is its owner `Sup`. `asOuterSuper` will use the enclosing types\n-    \/\/\/ (examines only enclosing instances) to discover for which type `Sup` can be\n-    \/\/\/ seen as super of in the sequence `Outer.Sub.I`.\n-    \/\/\/\n-    \/\/\/ Can `Sup` be seen as super of `Outer.Sub.I`? No. Going to the next enclosing type.\n-    \/\/\/ Can `Sup` be seen as super of `Outer.Sub`? Yes! Its outer results in `Sup<String>`.\n-    \/\/\/\n-    \/\/\/ ```\n-    \/\/\/ static class Sup<F> { public F f; }\n-    \/\/\/  class Outer {\n-    \/\/\/   static class Sub extends Sup<String> {\n-    \/\/\/       class I {\n-    \/\/\/         void test() {\n-    \/\/\/             String f2 = f; \/\/ Sup<String>\n-    \/\/\/         }\n-    \/\/\/       }\n-    \/\/\/   }\n-    \/\/\/ }\n-    \/\/\/ ```\n-    \/\/\/\n-    \/\/\/ @implNote This is typically used to compute the implicit qualifier in a\n-    \/\/\/ method\/field access expression.\n-    \/\/\/\n-    \/\/\/ @param t a type\n-    \/\/\/ @param sym a symbol\n+    \/**\n+     *  This method returns the first type in a sequence (starting at `t`) that is\n+     *  a subclass of `sym`. The next type in the sequence is obtained by calling\n+     *  `getEnclosingType()` on the previous type in the sequence. Note, this is\n+     *  typically used to compute the implicit qualifier in a method\/field access\n+     *  expression. Example:\n+     *\n+     *  static class Sup<F> { public F f; }\n+     *   class Outer {\n+     *    static class Sub extends Sup<String> {\n+     *        class I {\n+     *          void test() {\n+     *              String f2 = f; \/\/ Sup<String>\n+     *          }\n+     *        }\n+     *    }\n+     *  }\n+     *\n+     *  @param t a type\n+     *  @param sym a symbol\n+     *\/\n@@ -2279,31 +2267,18 @@\n-    \/\/\/ Traverses a sequence of types starting with `t` and returns the first type\n-    \/\/\/ that can be seen as a supertype of one of those types.\n-    \/\/\/\n-    \/\/\/ The sequence of types starts with `t` and the next type in the sequence\n-    \/\/\/ is obtained by obtaining innermost lexically enclosing class type of the\n-    \/\/\/ previous type in the sequence.\n-    \/\/\/\n-    \/\/\/ Example: The type expression `B` is implicitly qualified and the\n-    \/\/\/ proper generic outer needs to be retrieved. Its site is `C.D` and its\n-    \/\/\/ outer type is `A`. `asEnclosingSuper` will use the enclosing classes to\n-    \/\/\/ discover for which type `A` can be seen as super of a type in the\n-    \/\/\/ sequence `C.D`:\n-    \/\/\/\n-    \/\/\/ Can `A` be seen as super of `D`? No. Going to the next enclosing class.\n-    \/\/\/ Can `A` be seen as super of `C`? Yes! Its outer results in `A<String>`.\n-    \/\/\/\n-    \/\/\/ ```\n-    \/\/\/ class A<T> { class B { } }\n-    \/\/\/\n-    \/\/\/ class C extends A<String> {\n-    \/\/\/   static class D {\n-    \/\/\/      B b; \/\/ qualifier is A<String>.B\n-    \/\/\/   }\n-    \/\/\/ }\n-    \/\/\/ ```\n-    \/\/\/\n-    \/\/\/ @implNote This is typically used to compute the implicit qualifier in\n-    \/\/\/ a type expression.\n-    \/\/\/\n-    \/\/\/ @param t a type\n-    \/\/\/ @param sym a symbol\n+    \/**\n+     * This method returns the first type in a sequence (starting at `t`) that is\n+     * a subclass of `sym`. The next type in the sequence is obtained by obtaining\n+     * innermost lexically enclosing class type of the previous type in the sequence.\n+     * Note, this is typically used to compute the implicit qualifier in\n+     * a type expression. Example:\n+     *\n+     * class A<T> { class B { } }\n+     *\n+     * class C extends A<String> {\n+     *   static class D {\n+     *      B b; \/\/ qualifier is A<String>.B\n+     *   }\n+     * }\n+     *\n+     * @param t a type\n+     * @param sym a symbol\n+     *\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":39,"deletions":64,"binary":false,"changes":103,"status":"modified"}]}