{"files":[{"patch":"@@ -171,0 +171,1 @@\n+        long baseKeyID;\n@@ -175,0 +176,1 @@\n+            baseKeyID = p11BaseKey.getKeyID();\n@@ -176,1 +178,7 @@\n-            if (!isExtract || !\"RAW\".equalsIgnoreCase(baseKey.getFormat())) {\n+            if (p11BaseKey != null) {\n+                throw pe;\n+            }\n+            \/\/ special handling for FIPS mode when key cannot be imported\n+            if (isExtract) {\n+                baseKeyID = convertKeyToData(baseKey, pe);\n+            } else {\n@@ -180,1 +188,1 @@\n-\n+        Session session = null;\n@@ -184,24 +192,0 @@\n-        if (salt instanceof SecretKeySpec) {\n-            saltType = CKF_HKDF_SALT_DATA;\n-            saltBytes = salt.getEncoded();\n-        } else if (salt != EMPTY_KEY) {\n-            \/\/ consolidateKeyMaterial returns a salt from the token.\n-            saltType = CKF_HKDF_SALT_KEY;\n-            p11SaltKey = (P11Key.P11SecretKey) salt;\n-            assert p11SaltKey.token == token : \"salt must be from the same \" +\n-                    \"token as service.\";\n-        }\n-\n-        long derivedKeyClass = isData ? CKO_DATA : CKO_SECRET_KEY;\n-        CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_CLASS, derivedKeyClass),\n-                new CK_ATTRIBUTE(CKA_KEY_TYPE, ki.keyType),\n-                new CK_ATTRIBUTE(CKA_VALUE_LEN, outLen)\n-        };\n-        Session session = null;\n-        long baseKeyID;\n-        if (p11BaseKey != null) {\n-            baseKeyID = p11BaseKey.getKeyID();\n-        } else {\n-            baseKeyID = convertKeyToData(baseKey.getEncoded());\n-        }\n@@ -209,0 +193,17 @@\n+            if (salt instanceof SecretKeySpec) {\n+                saltType = CKF_HKDF_SALT_DATA;\n+                saltBytes = salt.getEncoded();\n+            } else if (salt != EMPTY_KEY) {\n+                \/\/ consolidateKeyMaterial returns a salt from the token.\n+                saltType = CKF_HKDF_SALT_KEY;\n+                p11SaltKey = (P11Key.P11SecretKey) salt;\n+                assert p11SaltKey.token == token : \"salt must be from the same \" +\n+                        \"token as service.\";\n+            }\n+\n+            long derivedKeyClass = isData ? CKO_DATA : CKO_SECRET_KEY;\n+            CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_CLASS, derivedKeyClass),\n+                    new CK_ATTRIBUTE(CKA_KEY_TYPE, ki.keyType),\n+                    new CK_ATTRIBUTE(CKA_VALUE_LEN, outLen)\n+            };\n@@ -268,1 +269,8 @@\n-    private long convertKeyToData(byte[] keyBytes) {\n+    private long convertKeyToData(SecretKey key, ProviderException pe) {\n+        if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n+            throw pe;\n+        }\n+        byte[] keyBytes = key.getEncoded();\n+        if (keyBytes == null) {\n+            throw pe;\n+        }\n@@ -282,0 +290,2 @@\n+        } finally {\n+            Arrays.fill(keyBytes, (byte)0);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11HKDF.java","additions":37,"deletions":27,"binary":false,"changes":64,"status":"modified"}]}