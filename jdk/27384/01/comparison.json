{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,3 +171,18 @@\n-        P11Key p11BaseKey = convertKey(baseKey, (isExtract ? \"IKM\" : \"PRK\") +\n-                \" could not be converted to a token key for HKDF derivation.\");\n-\n+        long baseKeyID;\n+        P11Key p11BaseKey = null;\n+        try {\n+            p11BaseKey = convertKey(baseKey, (isExtract ? \"IKM\" : \"PRK\") +\n+                    \" could not be converted to a token key for HKDF derivation.\");\n+            baseKeyID = p11BaseKey.getKeyID();\n+        } catch (ProviderException pe) {\n+            if (p11BaseKey != null) {\n+                throw pe;\n+            }\n+            \/\/ special handling for FIPS mode when key cannot be imported\n+            if (isExtract) {\n+                baseKeyID = convertKeyToData(baseKey, pe);\n+            } else {\n+                throw pe;\n+            }\n+        }\n+        Session session = null;\n@@ -176,19 +192,0 @@\n-        if (salt instanceof SecretKeySpec) {\n-            saltType = CKF_HKDF_SALT_DATA;\n-            saltBytes = salt.getEncoded();\n-        } else if (salt != EMPTY_KEY) {\n-            \/\/ consolidateKeyMaterial returns a salt from the token.\n-            saltType = CKF_HKDF_SALT_KEY;\n-            p11SaltKey = (P11Key.P11SecretKey) salt;\n-            assert p11SaltKey.token == token : \"salt must be from the same \" +\n-                    \"token as service.\";\n-        }\n-\n-        long derivedKeyClass = isData ? CKO_DATA : CKO_SECRET_KEY;\n-        CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_CLASS, derivedKeyClass),\n-                new CK_ATTRIBUTE(CKA_KEY_TYPE, ki.keyType),\n-                new CK_ATTRIBUTE(CKA_VALUE_LEN, outLen)\n-        };\n-        Session session = null;\n-        long baseKeyID = p11BaseKey.getKeyID();\n@@ -196,0 +193,17 @@\n+            if (salt instanceof SecretKeySpec) {\n+                saltType = CKF_HKDF_SALT_DATA;\n+                saltBytes = salt.getEncoded();\n+            } else if (salt != EMPTY_KEY) {\n+                \/\/ consolidateKeyMaterial returns a salt from the token.\n+                saltType = CKF_HKDF_SALT_KEY;\n+                p11SaltKey = (P11Key.P11SecretKey) salt;\n+                assert p11SaltKey.token == token : \"salt must be from the same \" +\n+                        \"token as service.\";\n+            }\n+\n+            long derivedKeyClass = isData ? CKO_DATA : CKO_SECRET_KEY;\n+            CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_CLASS, derivedKeyClass),\n+                    new CK_ATTRIBUTE(CKA_KEY_TYPE, ki.keyType),\n+                    new CK_ATTRIBUTE(CKA_VALUE_LEN, outLen)\n+            };\n@@ -233,1 +247,5 @@\n-            p11BaseKey.releaseKeyID();\n+            if (p11BaseKey != null) {\n+                p11BaseKey.releaseKeyID();\n+            } else {\n+                destroyDataObject(baseKeyID);\n+            }\n@@ -238,0 +256,39 @@\n+    private void destroyDataObject(long baseKeyID) {\n+        try {\n+            Session session = token.getObjSession();\n+            try {\n+                token.p11.C_DestroyObject(session.id(), baseKeyID);\n+            } finally {\n+                token.releaseSession(session);\n+            }\n+        } catch (PKCS11Exception e) {\n+            throw new ProviderException(\"Failed to destroy IKM data object.\", e);\n+        }\n+    }\n+\n+    private long convertKeyToData(SecretKey key, ProviderException pe) {\n+        if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n+            throw pe;\n+        }\n+        byte[] keyBytes = key.getEncoded();\n+        if (keyBytes == null) {\n+            throw pe;\n+        }\n+        CK_ATTRIBUTE[] inputAttributes = new CK_ATTRIBUTE[]{\n+                new CK_ATTRIBUTE(CKA_CLASS, CKO_DATA),\n+                new CK_ATTRIBUTE(CKA_VALUE, keyBytes),\n+        };\n+        try {\n+            Session session = token.getObjSession();\n+            try {\n+                return token.p11.C_CreateObject(session.id(), inputAttributes);\n+            } finally {\n+                token.releaseSession(session);\n+            }\n+        } catch (PKCS11Exception e) {\n+            throw new ProviderException(\"Failed to create IKM data object.\", e);\n+        } finally {\n+            Arrays.fill(keyBytes, (byte)0);\n+        }\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11HKDF.java","additions":80,"deletions":23,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @bug 8029661 8325164\n- * @summary Test TLS 1.2\n+ * @bug 8029661 8325164 8368073\n+ * @summary Test TLS 1.2 and TLS 1.3\n@@ -33,1 +33,4 @@\n- * @run main\/othervm\/timeout=120 -Djdk.tls.useExtendedMasterSecret=false FipsModeTLS12\n+ * @run main\/othervm\/timeout=120 -Djdk.tls.client.protocols=TLSv1.2\n+ *      -Djdk.tls.useExtendedMasterSecret=false FipsModeTLS12\n+ * @comment SunPKCS11 does not support (TLS1.2) SunTlsExtendedMasterSecret yet\n+ * @run main\/othervm\/timeout=120 -Djdk.tls.client.protocols=TLSv1.3 FipsModeTLS12\n@@ -54,0 +57,1 @@\n+import javax.crypto.KDF;\n@@ -85,3 +89,0 @@\n-        \/\/ Re-enable TLS_RSA_* since test depends on it.\n-        SecurityUtils.removeFromDisabledTlsAlgs(\"TLS_RSA_*\");\n-\n@@ -118,5 +119,10 @@\n-            KeyGenerator.getInstance(\"SunTls12MasterSecret\",\n-                    sunPKCS11NSSProvider);\n-            KeyGenerator.getInstance(\n-                    \"SunTls12RsaPremasterSecret\", sunPKCS11NSSProvider);\n-            KeyGenerator.getInstance(\"SunTls12Prf\", sunPKCS11NSSProvider);\n+            String proto = System.getProperty(\"jdk.tls.client.protocols\");\n+            if (\"TLSv1.3\".equals(proto)) {\n+                KDF.getInstance(\"HKDF-SHA256\", sunPKCS11NSSProvider);\n+            } else {\n+                KeyGenerator.getInstance(\"SunTls12MasterSecret\",\n+                        sunPKCS11NSSProvider);\n+                KeyGenerator.getInstance(\n+                        \"SunTls12RsaPremasterSecret\", sunPKCS11NSSProvider);\n+                KeyGenerator.getInstance(\"SunTls12Prf\", sunPKCS11NSSProvider);\n+            }\n@@ -387,10 +393,0 @@\n-            \/\/ TLS_RSA_WITH_AES_128_GCM_SHA256 ciphersuite is available but\n-            \/\/ must not be chosen for the TLS connection if not supported.\n-            \/\/ See JDK-8222937.\n-            String[][] preferredSuites = new String[][]{ new String[] {\n-                    \"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n-                    \"TLS_RSA_WITH_AES_128_CBC_SHA256\"\n-            },  new String[] {\n-                    \"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n-                    \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\"\n-            }};\n@@ -400,2 +396,0 @@\n-                \/\/ All CipherSuites enabled for the client.\n-                enginesToTest[i][1].setEnabledCipherSuites(preferredSuites[i]);\n@@ -415,1 +409,1 @@\n-            SSLContext sslCtx = SSLContext.getInstance(\"TLSv1.2\", \"SunJSSE\");\n+            SSLContext sslCtx = SSLContext.getInstance(\"TLS\", \"SunJSSE\");\n@@ -421,1 +415,2 @@\n-            boolean ffdheAvailable = Arrays.stream(sslParameters.getNamedGroups())\n+            String[] namedGroups = sslParameters.getNamedGroups();\n+            boolean ffdheAvailable = Arrays.stream(namedGroups)\n@@ -427,1 +422,1 @@\n-            boolean ecdheAvailable = Arrays.stream(sslParameters.getNamedGroups())\n+            boolean ecdheAvailable = Arrays.stream(namedGroups)\n@@ -432,0 +427,3 @@\n+            \/\/ remove XDH named groups - not available in PKCS11\n+            namedGroups = Arrays.stream(namedGroups).filter(s-> !s.startsWith(\"x\")).toArray(String[]::new);\n+            sslParameters.setNamedGroups(namedGroups);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/FipsModeTLS12.java","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -10,0 +10,8 @@\n+# NSS-FIPS needs sensitive=true for key extraction.\n+# TLS 1.3 needs CKA_SIGN to sign the Finished message.\n+\n+attributes(*,CKO_SECRET_KEY,CKK_GENERIC_SECRET) = {\n+  CKA_SIGN = true\n+  CKA_SENSITIVE=true\n+}\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/nss.cfg","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}