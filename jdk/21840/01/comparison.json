{"files":[{"patch":"@@ -1,491 +0,0 @@\n-\/*\n- * Copyright (c) 1996, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/package jdk.internal.math;\n-\n-\/*\n- * A really, really simple bigint package\n- * tailored to the needs of floating base conversion.\n- *\/\n-class OldFDBigIntForTest {\n-    int nWords; \/\/ number of words used\n-    int data[]; \/\/ value: data[0] is least significant\n-\n-\n-    public OldFDBigIntForTest( int v ){\n-        nWords = 1;\n-        data = new int[1];\n-        data[0] = v;\n-    }\n-\n-    public OldFDBigIntForTest( long v ){\n-        data = new int[2];\n-        data[0] = (int)v;\n-        data[1] = (int)(v>>>32);\n-        nWords = (data[1]==0) ? 1 : 2;\n-    }\n-\n-    public OldFDBigIntForTest( OldFDBigIntForTest other ){\n-        data = new int[nWords = other.nWords];\n-        System.arraycopy( other.data, 0, data, 0, nWords );\n-    }\n-\n-    private OldFDBigIntForTest( int [] d, int n ){\n-        data = d;\n-        nWords = n;\n-    }\n-\n-    public OldFDBigIntForTest( long seed, char digit[], int nd0, int nd ){\n-        int n= (nd+8)\/9;        \/\/ estimate size needed.\n-        if ( n < 2 ) n = 2;\n-        data = new int[n];      \/\/ allocate enough space\n-        data[0] = (int)seed;    \/\/ starting value\n-        data[1] = (int)(seed>>>32);\n-        nWords = (data[1]==0) ? 1 : 2;\n-        int i = nd0;\n-        int limit = nd-5;       \/\/ slurp digits 5 at a time.\n-        int v;\n-        while ( i < limit ){\n-            int ilim = i+5;\n-            v = (int)digit[i++]-(int)'0';\n-            while( i <ilim ){\n-                v = 10*v + (int)digit[i++]-(int)'0';\n-            }\n-            multaddMe( 100000, v); \/\/ ... where 100000 is 10^5.\n-        }\n-        int factor = 1;\n-        v = 0;\n-        while ( i < nd ){\n-            v = 10*v + (int)digit[i++]-(int)'0';\n-            factor *= 10;\n-        }\n-        if ( factor != 1 ){\n-            multaddMe( factor, v );\n-        }\n-    }\n-\n-    \/*\n-     * Left shift by c bits.\n-     * Shifts this in place.\n-     *\/\n-    public void\n-    lshiftMe( int c )throws IllegalArgumentException {\n-        if ( c <= 0 ){\n-            if ( c == 0 )\n-                return; \/\/ silly.\n-            else\n-                throw new IllegalArgumentException(\"negative shift count\");\n-        }\n-        int wordcount = c>>5;\n-        int bitcount  = c & 0x1f;\n-        int anticount = 32-bitcount;\n-        int t[] = data;\n-        int s[] = data;\n-        if ( nWords+wordcount+1 > t.length ){\n-            \/\/ reallocate.\n-            t = new int[ nWords+wordcount+1 ];\n-        }\n-        int target = nWords+wordcount;\n-        int src    = nWords-1;\n-        if ( bitcount == 0 ){\n-            \/\/ special hack, since an anticount of 32 won't go!\n-            System.arraycopy( s, 0, t, wordcount, nWords );\n-            target = wordcount-1;\n-        } else {\n-            t[target--] = s[src]>>>anticount;\n-            while ( src >= 1 ){\n-                t[target--] = (s[src]<<bitcount) | (s[--src]>>>anticount);\n-            }\n-            t[target--] = s[src]<<bitcount;\n-        }\n-        while( target >= 0 ){\n-            t[target--] = 0;\n-        }\n-        data = t;\n-        nWords += wordcount + 1;\n-        \/\/ may have constructed high-order word of 0.\n-        \/\/ if so, trim it\n-        while ( nWords > 1 && data[nWords-1] == 0 )\n-            nWords--;\n-    }\n-\n-    \/*\n-     * normalize this number by shifting until\n-     * the MSB of the number is at 0x08000000.\n-     * This is in preparation for quoRemIteration, below.\n-     * The idea is that, to make division easier, we want the\n-     * divisor to be \"normalized\" -- usually this means shifting\n-     * the MSB into the high words sign bit. But because we know that\n-     * the quotient will be 0 < q < 10, we would like to arrange that\n-     * the dividend not span up into another word of precision.\n-     * (This needs to be explained more clearly!)\n-     *\/\n-    public int\n-    normalizeMe() throws IllegalArgumentException {\n-        int src;\n-        int wordcount = 0;\n-        int bitcount  = 0;\n-        int v = 0;\n-        for ( src= nWords-1 ; src >= 0 && (v=data[src]) == 0 ; src--){\n-            wordcount += 1;\n-        }\n-        if ( src < 0 ){\n-            \/\/ oops. Value is zero. Cannot normalize it!\n-            throw new IllegalArgumentException(\"zero value\");\n-        }\n-        \/*\n-         * In most cases, we assume that wordcount is zero. This only\n-         * makes sense, as we try not to maintain any high-order\n-         * words full of zeros. In fact, if there are zeros, we will\n-         * simply SHORTEN our number at this point. Watch closely...\n-         *\/\n-        nWords -= wordcount;\n-        \/*\n-         * Compute how far left we have to shift v s.t. its highest-\n-         * order bit is in the right place. Then call lshiftMe to\n-         * do the work.\n-         *\/\n-        if ( (v & 0xf0000000) != 0 ){\n-            \/\/ will have to shift up into the next word.\n-            \/\/ too bad.\n-            for( bitcount = 32 ; (v & 0xf0000000) != 0 ; bitcount-- )\n-                v >>>= 1;\n-        } else {\n-            while ( v <= 0x000fffff ){\n-                \/\/ hack: byte-at-a-time shifting\n-                v <<= 8;\n-                bitcount += 8;\n-            }\n-            while ( v <= 0x07ffffff ){\n-                v <<= 1;\n-                bitcount += 1;\n-            }\n-        }\n-        if ( bitcount != 0 )\n-            lshiftMe( bitcount );\n-        return bitcount;\n-    }\n-\n-    \/*\n-     * Multiply a OldFDBigIntForTest by an int.\n-     * Result is a new OldFDBigIntForTest.\n-     *\/\n-    public OldFDBigIntForTest\n-    mult( int iv ) {\n-        long v = iv;\n-        int r[];\n-        long p;\n-\n-        \/\/ guess adequate size of r.\n-        r = new int[ ( v * ((long)data[nWords-1]&0xffffffffL) > 0xfffffffL ) ? nWords+1 : nWords ];\n-        p = 0L;\n-        for( int i=0; i < nWords; i++ ) {\n-            p += v * ((long)data[i]&0xffffffffL);\n-            r[i] = (int)p;\n-            p >>>= 32;\n-        }\n-        if ( p == 0L){\n-            return new OldFDBigIntForTest( r, nWords );\n-        } else {\n-            r[nWords] = (int)p;\n-            return new OldFDBigIntForTest( r, nWords+1 );\n-        }\n-    }\n-\n-    \/*\n-     * Multiply a OldFDBigIntForTest by an int and add another int.\n-     * Result is computed in place.\n-     * Hope it fits!\n-     *\/\n-    public void\n-    multaddMe( int iv, int addend ) {\n-        long v = iv;\n-        long p;\n-\n-        \/\/ unroll 0th iteration, doing addition.\n-        p = v * ((long)data[0]&0xffffffffL) + ((long)addend&0xffffffffL);\n-        data[0] = (int)p;\n-        p >>>= 32;\n-        for( int i=1; i < nWords; i++ ) {\n-            p += v * ((long)data[i]&0xffffffffL);\n-            data[i] = (int)p;\n-            p >>>= 32;\n-        }\n-        if ( p != 0L){\n-            data[nWords] = (int)p; \/\/ will fail noisily if illegal!\n-            nWords++;\n-        }\n-    }\n-\n-    \/*\n-     * Multiply a OldFDBigIntForTest by another OldFDBigIntForTest.\n-     * Result is a new OldFDBigIntForTest.\n-     *\/\n-    public OldFDBigIntForTest\n-    mult( OldFDBigIntForTest other ){\n-        \/\/ crudely guess adequate size for r\n-        int r[] = new int[ nWords + other.nWords ];\n-        int i;\n-        \/\/ I think I am promised zeros...\n-\n-        for( i = 0; i < this.nWords; i++ ){\n-            long v = (long)this.data[i] & 0xffffffffL; \/\/ UNSIGNED CONVERSION\n-            long p = 0L;\n-            int j;\n-            for( j = 0; j < other.nWords; j++ ){\n-                p += ((long)r[i+j]&0xffffffffL) + v*((long)other.data[j]&0xffffffffL); \/\/ UNSIGNED CONVERSIONS ALL 'ROUND.\n-                r[i+j] = (int)p;\n-                p >>>= 32;\n-            }\n-            r[i+j] = (int)p;\n-        }\n-        \/\/ compute how much of r we actually needed for all that.\n-        for ( i = r.length-1; i> 0; i--)\n-            if ( r[i] != 0 )\n-                break;\n-        return new OldFDBigIntForTest( r, i+1 );\n-    }\n-\n-    \/*\n-     * Add one OldFDBigIntForTest to another. Return a OldFDBigIntForTest\n-     *\/\n-    public OldFDBigIntForTest\n-    add( OldFDBigIntForTest other ){\n-        int i;\n-        int a[], b[];\n-        int n, m;\n-        long c = 0L;\n-        \/\/ arrange such that a.nWords >= b.nWords;\n-        \/\/ n = a.nWords, m = b.nWords\n-        if ( this.nWords >= other.nWords ){\n-            a = this.data;\n-            n = this.nWords;\n-            b = other.data;\n-            m = other.nWords;\n-        } else {\n-            a = other.data;\n-            n = other.nWords;\n-            b = this.data;\n-            m = this.nWords;\n-        }\n-        int r[] = new int[ n ];\n-        for ( i = 0; i < n; i++ ){\n-            c += (long)a[i] & 0xffffffffL;\n-            if ( i < m ){\n-                c += (long)b[i] & 0xffffffffL;\n-            }\n-            r[i] = (int) c;\n-            c >>= 32; \/\/ signed shift.\n-        }\n-        if ( c != 0L ){\n-            \/\/ oops -- carry out -- need longer result.\n-            int s[] = new int[ r.length+1 ];\n-            System.arraycopy( r, 0, s, 0, r.length );\n-            s[i++] = (int)c;\n-            return new OldFDBigIntForTest( s, i );\n-        }\n-        return new OldFDBigIntForTest( r, i );\n-    }\n-\n-    \/*\n-     * Subtract one OldFDBigIntForTest from another. Return a OldFDBigIntForTest\n-     * Assert that the result is positive.\n-     *\/\n-    public OldFDBigIntForTest\n-    sub( OldFDBigIntForTest other ){\n-        int r[] = new int[ this.nWords ];\n-        int i;\n-        int n = this.nWords;\n-        int m = other.nWords;\n-        int nzeros = 0;\n-        long c = 0L;\n-        for ( i = 0; i < n; i++ ){\n-            c += (long)this.data[i] & 0xffffffffL;\n-            if ( i < m ){\n-                c -= (long)other.data[i] & 0xffffffffL;\n-            }\n-            if ( ( r[i] = (int) c ) == 0 )\n-                nzeros++;\n-            else\n-                nzeros = 0;\n-            c >>= 32; \/\/ signed shift\n-        }\n-        assert c == 0L : c; \/\/ borrow out of subtract\n-        assert dataInRangeIsZero(i, m, other); \/\/ negative result of subtract\n-        return new OldFDBigIntForTest( r, n-nzeros );\n-    }\n-\n-    private static boolean dataInRangeIsZero(int i, int m, OldFDBigIntForTest other) {\n-        while ( i < m )\n-            if (other.data[i++] != 0)\n-                return false;\n-        return true;\n-    }\n-\n-    \/*\n-     * Compare OldFDBigIntForTest with another OldFDBigIntForTest. Return an integer\n-     * >0: this > other\n-     *  0: this == other\n-     * <0: this < other\n-     *\/\n-    public int\n-    cmp( OldFDBigIntForTest other ){\n-        int i;\n-        if ( this.nWords > other.nWords ){\n-            \/\/ if any of my high-order words is non-zero,\n-            \/\/ then the answer is evident\n-            int j = other.nWords-1;\n-            for ( i = this.nWords-1; i > j ; i-- )\n-                if ( this.data[i] != 0 ) return 1;\n-        }else if ( this.nWords < other.nWords ){\n-            \/\/ if any of other's high-order words is non-zero,\n-            \/\/ then the answer is evident\n-            int j = this.nWords-1;\n-            for ( i = other.nWords-1; i > j ; i-- )\n-                if ( other.data[i] != 0 ) return -1;\n-        } else{\n-            i = this.nWords-1;\n-        }\n-        for ( ; i > 0 ; i-- )\n-            if ( this.data[i] != other.data[i] )\n-                break;\n-        \/\/ careful! want unsigned compare!\n-        \/\/ use brute force here.\n-        int a = this.data[i];\n-        int b = other.data[i];\n-        if ( a < 0 ){\n-            \/\/ a is really big, unsigned\n-            if ( b < 0 ){\n-                return a-b; \/\/ both big, negative\n-            } else {\n-                return 1; \/\/ b not big, answer is obvious;\n-            }\n-        } else {\n-            \/\/ a is not really big\n-            if ( b < 0 ) {\n-                \/\/ but b is really big\n-                return -1;\n-            } else {\n-                return a - b;\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Compute\n-     * q = (int)( this \/ S )\n-     * this = 10 * ( this mod S )\n-     * Return q.\n-     * This is the iteration step of digit development for output.\n-     * We assume that S has been normalized, as above, and that\n-     * \"this\" has been lshift'ed accordingly.\n-     * Also assume, of course, that the result, q, can be expressed\n-     * as an integer, 0 <= q < 10.\n-     *\/\n-    public int\n-    quoRemIteration( OldFDBigIntForTest S )throws IllegalArgumentException {\n-        \/\/ ensure that this and S have the same number of\n-        \/\/ digits. If S is properly normalized and q < 10 then\n-        \/\/ this must be so.\n-        if ( nWords != S.nWords ){\n-            throw new IllegalArgumentException(\"disparate values\");\n-        }\n-        \/\/ estimate q the obvious way. We will usually be\n-        \/\/ right. If not, then we're only off by a little and\n-        \/\/ will re-add.\n-        int n = nWords-1;\n-        long q = ((long)data[n]&0xffffffffL) \/ (long)S.data[n];\n-        long diff = 0L;\n-        for ( int i = 0; i <= n ; i++ ){\n-            diff += ((long)data[i]&0xffffffffL) -  q*((long)S.data[i]&0xffffffffL);\n-            data[i] = (int)diff;\n-            diff >>= 32; \/\/ N.B. SIGNED shift.\n-        }\n-        if ( diff != 0L ) {\n-            \/\/ damn, damn, damn. q is too big.\n-            \/\/ add S back in until this turns +. This should\n-            \/\/ not be very many times!\n-            long sum = 0L;\n-            while ( sum ==  0L ){\n-                sum = 0L;\n-                for ( int i = 0; i <= n; i++ ){\n-                    sum += ((long)data[i]&0xffffffffL) +  ((long)S.data[i]&0xffffffffL);\n-                    data[i] = (int) sum;\n-                    sum >>= 32; \/\/ Signed or unsigned, answer is 0 or 1\n-                }\n-                \/*\n-                 * Originally the following line read\n-                 * \"if ( sum !=0 && sum != -1 )\"\n-                 * but that would be wrong, because of the\n-                 * treatment of the two values as entirely unsigned,\n-                 * it would be impossible for a carry-out to be interpreted\n-                 * as -1 -- it would have to be a single-bit carry-out, or\n-                 * +1.\n-                 *\/\n-                assert sum == 0 || sum == 1 : sum; \/\/ carry out of division correction\n-                q -= 1;\n-            }\n-        }\n-        \/\/ finally, we can multiply this by 10.\n-        \/\/ it cannot overflow, right, as the high-order word has\n-        \/\/ at least 4 high-order zeros!\n-        long p = 0L;\n-        for ( int i = 0; i <= n; i++ ){\n-            p += 10*((long)data[i]&0xffffffffL);\n-            data[i] = (int)p;\n-            p >>= 32; \/\/ SIGNED shift.\n-        }\n-        assert p == 0L : p; \/\/ Carry out of *10\n-        return (int)q;\n-    }\n-\n-    public long\n-    longValue(){\n-        \/\/ if this can be represented as a long, return the value\n-        assert this.nWords > 0 : this.nWords; \/\/ longValue confused\n-\n-        if (this.nWords == 1)\n-            return ((long)data[0]&0xffffffffL);\n-\n-        assert dataInRangeIsZero(2, this.nWords, this); \/\/ value too big\n-        assert data[1] >= 0;  \/\/ value too big\n-        return ((long)(data[1]) << 32) | ((long)data[0]&0xffffffffL);\n-    }\n-\n-    public String\n-    toString() {\n-        StringBuffer r = new StringBuffer(30);\n-        r.append('[');\n-        int i = Math.min( nWords-1, data.length-1) ;\n-        if ( nWords > data.length ){\n-            r.append( \"(\"+data.length+\"<\"+nWords+\"!)\" );\n-        }\n-        for( ; i> 0 ; i-- ){\n-            r.append( Integer.toHexString( data[i] ) );\n-            r.append(' ');\n-        }\n-        r.append( Integer.toHexString( data[0] ) );\n-        r.append(']');\n-        return new String( r );\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/math\/FloatingDecimal\/OldFDBigIntForTest.java","additions":0,"deletions":491,"binary":false,"changes":491,"status":"deleted"},{"patch":"@@ -1,2434 +0,0 @@\n-\/*\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/package jdk.internal.math;\n-\n-import java.util.regex.*;\n-\n-public class OldFloatingDecimalForTest{\n-    boolean     isExceptional;\n-    boolean     isNegative;\n-    int         decExponent;\n-    char        digits[];\n-    int         nDigits;\n-    int         bigIntExp;\n-    int         bigIntNBits;\n-    boolean     mustSetRoundDir = false;\n-    boolean     fromHex = false;\n-    int         roundDir = 0; \/\/ set by doubleValue\n-\n-    \/*\n-     * The fields below provides additional information about the result of\n-     * the binary to decimal digits conversion done in dtoa() and roundup()\n-     * methods. They are changed if needed by those two methods.\n-     *\/\n-\n-    \/\/ True if the dtoa() binary to decimal conversion was exact.\n-    boolean     exactDecimalConversion = false;\n-\n-    \/\/ True if the result of the binary to decimal conversion was rounded-up\n-    \/\/ at the end of the conversion process, i.e. roundUp() method was called.\n-    boolean     decimalDigitsRoundedUp = false;\n-\n-    private     OldFloatingDecimalForTest( boolean negSign, int decExponent, char []digits, int n,  boolean e )\n-    {\n-        isNegative = negSign;\n-        isExceptional = e;\n-        this.decExponent = decExponent;\n-        this.digits = digits;\n-        this.nDigits = n;\n-    }\n-\n-    \/*\n-     * Constants of the implementation\n-     * Most are IEEE-754 related.\n-     * (There are more really boring constants at the end.)\n-     *\/\n-    static final long   signMask = 0x8000000000000000L;\n-    static final long   expMask  = 0x7ff0000000000000L;\n-    static final long   fractMask= ~(signMask|expMask);\n-    static final int    expShift = 52;\n-    static final int    expBias  = 1023;\n-    static final long   fractHOB = ( 1L<<expShift ); \/\/ assumed High-Order bit\n-    static final long   expOne   = ((long)expBias)<<expShift; \/\/ exponent of 1.0\n-    static final int    maxSmallBinExp = 62;\n-    static final int    minSmallBinExp = -( 63 \/ 3 );\n-    static final int    maxDecimalDigits = 15;\n-    static final int    maxDecimalExponent = 308;\n-    static final int    minDecimalExponent = -324;\n-    static final int    bigDecimalExponent = 324; \/\/ i.e. abs(minDecimalExponent)\n-\n-    static final long   highbyte = 0xff00000000000000L;\n-    static final long   highbit  = 0x8000000000000000L;\n-    static final long   lowbytes = ~highbyte;\n-\n-    static final int    singleSignMask =    0x80000000;\n-    static final int    singleExpMask  =    0x7f800000;\n-    static final int    singleFractMask =   ~(singleSignMask|singleExpMask);\n-    static final int    singleExpShift  =   23;\n-    static final int    singleFractHOB  =   1<<singleExpShift;\n-    static final int    singleExpBias   =   127;\n-    static final int    singleMaxDecimalDigits = 7;\n-    static final int    singleMaxDecimalExponent = 38;\n-    static final int    singleMinDecimalExponent = -45;\n-\n-    static final int    intDecimalDigits = 9;\n-\n-\n-    \/*\n-     * count number of bits from high-order 1 bit to low-order 1 bit,\n-     * inclusive.\n-     *\/\n-    private static int\n-    countBits( long v ){\n-        \/\/\n-        \/\/ the strategy is to shift until we get a non-zero sign bit\n-        \/\/ then shift until we have no bits left, counting the difference.\n-        \/\/ we do byte shifting as a hack. Hope it helps.\n-        \/\/\n-        if ( v == 0L ) return 0;\n-\n-        while ( ( v & highbyte ) == 0L ){\n-            v <<= 8;\n-        }\n-        while ( v > 0L ) { \/\/ i.e. while ((v&highbit) == 0L )\n-            v <<= 1;\n-        }\n-\n-        int n = 0;\n-        while (( v & lowbytes ) != 0L ){\n-            v <<= 8;\n-            n += 8;\n-        }\n-        while ( v != 0L ){\n-            v <<= 1;\n-            n += 1;\n-        }\n-        return n;\n-    }\n-\n-    \/*\n-     * Keep big powers of 5 handy for future reference.\n-     *\/\n-    private static OldFDBigIntForTest b5p[];\n-\n-    private static synchronized OldFDBigIntForTest\n-    big5pow( int p ){\n-        assert p >= 0 : p; \/\/ negative power of 5\n-        if ( b5p == null ){\n-            b5p = new OldFDBigIntForTest[ p+1 ];\n-        }else if (b5p.length <= p ){\n-            OldFDBigIntForTest t[] = new OldFDBigIntForTest[ p+1 ];\n-            System.arraycopy( b5p, 0, t, 0, b5p.length );\n-            b5p = t;\n-        }\n-        if ( b5p[p] != null )\n-            return b5p[p];\n-        else if ( p < small5pow.length )\n-            return b5p[p] = new OldFDBigIntForTest( small5pow[p] );\n-        else if ( p < long5pow.length )\n-            return b5p[p] = new OldFDBigIntForTest( long5pow[p] );\n-        else {\n-            \/\/ construct the value.\n-            \/\/ recursively.\n-            int q, r;\n-            \/\/ in order to compute 5^p,\n-            \/\/ compute its square root, 5^(p\/2) and square.\n-            \/\/ or, let q = p \/ 2, r = p -q, then\n-            \/\/ 5^p = 5^(q+r) = 5^q * 5^r\n-            q = p >> 1;\n-            r = p - q;\n-            OldFDBigIntForTest bigq =  b5p[q];\n-            if ( bigq == null )\n-                bigq = big5pow ( q );\n-            if ( r < small5pow.length ){\n-                return (b5p[p] = bigq.mult( small5pow[r] ) );\n-            }else{\n-                OldFDBigIntForTest bigr = b5p[ r ];\n-                if ( bigr == null )\n-                    bigr = big5pow( r );\n-                return (b5p[p] = bigq.mult( bigr ) );\n-            }\n-        }\n-    }\n-\n-    \/\/\n-    \/\/ a common operation\n-    \/\/\n-    private static OldFDBigIntForTest\n-    multPow52( OldFDBigIntForTest v, int p5, int p2 ){\n-        if ( p5 != 0 ){\n-            if ( p5 < small5pow.length ){\n-                v = v.mult( small5pow[p5] );\n-            } else {\n-                v = v.mult( big5pow( p5 ) );\n-            }\n-        }\n-        if ( p2 != 0 ){\n-            v.lshiftMe( p2 );\n-        }\n-        return v;\n-    }\n-\n-    \/\/\n-    \/\/ another common operation\n-    \/\/\n-    private static OldFDBigIntForTest\n-    constructPow52( int p5, int p2 ){\n-        OldFDBigIntForTest v = new OldFDBigIntForTest( big5pow( p5 ) );\n-        if ( p2 != 0 ){\n-            v.lshiftMe( p2 );\n-        }\n-        return v;\n-    }\n-\n-    \/*\n-     * Make a floating double into a OldFDBigIntForTest.\n-     * This could also be structured as a OldFDBigIntForTest\n-     * constructor, but we'd have to build a lot of knowledge\n-     * about floating-point representation into it, and we don't want to.\n-     *\n-     * AS A SIDE EFFECT, THIS METHOD WILL SET THE INSTANCE VARIABLES\n-     * bigIntExp and bigIntNBits\n-     *\n-     *\/\n-    private OldFDBigIntForTest\n-    doubleToBigInt( double dval ){\n-        long lbits = Double.doubleToLongBits( dval ) & ~signMask;\n-        int binexp = (int)(lbits >>> expShift);\n-        lbits &= fractMask;\n-        if ( binexp > 0 ){\n-            lbits |= fractHOB;\n-        } else {\n-            assert lbits != 0L : lbits; \/\/ doubleToBigInt(0.0)\n-            binexp +=1;\n-            while ( (lbits & fractHOB ) == 0L){\n-                lbits <<= 1;\n-                binexp -= 1;\n-            }\n-        }\n-        binexp -= expBias;\n-        int nbits = countBits( lbits );\n-        \/*\n-         * We now know where the high-order 1 bit is,\n-         * and we know how many there are.\n-         *\/\n-        int lowOrderZeros = expShift+1-nbits;\n-        lbits >>>= lowOrderZeros;\n-\n-        bigIntExp = binexp+1-nbits;\n-        bigIntNBits = nbits;\n-        return new OldFDBigIntForTest( lbits );\n-    }\n-\n-    \/*\n-     * Compute a number that is the ULP of the given value,\n-     * for purposes of addition\/subtraction. Generally easy.\n-     * More difficult if subtracting and the argument\n-     * is a normalized a power of 2, as the ULP changes at these points.\n-     *\/\n-    private static double ulp( double dval, boolean subtracting ){\n-        long lbits = Double.doubleToLongBits( dval ) & ~signMask;\n-        int binexp = (int)(lbits >>> expShift);\n-        double ulpval;\n-        if ( subtracting && ( binexp >= expShift ) && ((lbits&fractMask) == 0L) ){\n-            \/\/ for subtraction from normalized, powers of 2,\n-            \/\/ use next-smaller exponent\n-            binexp -= 1;\n-        }\n-        if ( binexp > expShift ){\n-            ulpval = Double.longBitsToDouble( ((long)(binexp-expShift))<<expShift );\n-        } else if ( binexp == 0 ){\n-            ulpval = Double.MIN_VALUE;\n-        } else {\n-            ulpval = Double.longBitsToDouble( 1L<<(binexp-1) );\n-        }\n-        if ( subtracting ) ulpval = - ulpval;\n-\n-        return ulpval;\n-    }\n-\n-    \/*\n-     * Round a double to a float.\n-     * In addition to the fraction bits of the double,\n-     * look at the class instance variable roundDir,\n-     * which should help us avoid double-rounding error.\n-     * roundDir was set in hardValueOf if the estimate was\n-     * close enough, but not exact. It tells us which direction\n-     * of rounding is preferred.\n-     *\/\n-    float\n-    stickyRound( double dval ){\n-        long lbits = Double.doubleToLongBits( dval );\n-        long binexp = lbits & expMask;\n-        if ( binexp == 0L || binexp == expMask ){\n-            \/\/ what we have here is special.\n-            \/\/ don't worry, the right thing will happen.\n-            return (float) dval;\n-        }\n-        lbits += (long)roundDir; \/\/ hack-o-matic.\n-        return (float)Double.longBitsToDouble( lbits );\n-    }\n-\n-\n-    \/*\n-     * This is the easy subcase --\n-     * all the significant bits, after scaling, are held in lvalue.\n-     * negSign and decExponent tell us what processing and scaling\n-     * has already been done. Exceptional cases have already been\n-     * stripped out.\n-     * In particular:\n-     * lvalue is a finite number (not Inf, nor NaN)\n-     * lvalue > 0L (not zero, nor negative).\n-     *\n-     * The only reason that we develop the digits here, rather than\n-     * calling on Long.toString() is that we can do it a little faster,\n-     * and besides want to treat trailing 0s specially. If Long.toString\n-     * changes, we should re-evaluate this strategy!\n-     *\/\n-    private void\n-    developLongDigits( int decExponent, long lvalue, long insignificant ){\n-        char digits[];\n-        int  ndigits;\n-        int  digitno;\n-        int  c;\n-        \/\/\n-        \/\/ Discard non-significant low-order bits, while rounding,\n-        \/\/ up to insignificant value.\n-        int i;\n-        for ( i = 0; insignificant >= 10L; i++ )\n-            insignificant \/= 10L;\n-        if ( i != 0 ){\n-            long pow10 = long5pow[i] << i; \/\/ 10^i == 5^i * 2^i;\n-            long residue = lvalue % pow10;\n-            lvalue \/= pow10;\n-            decExponent += i;\n-            if ( residue >= (pow10>>1) ){\n-                \/\/ round up based on the low-order bits we're discarding\n-                lvalue++;\n-            }\n-        }\n-        if ( lvalue <= Integer.MAX_VALUE ){\n-            assert lvalue > 0L : lvalue; \/\/ lvalue <= 0\n-            \/\/ even easier subcase!\n-            \/\/ can do int arithmetic rather than long!\n-            int  ivalue = (int)lvalue;\n-            ndigits = 10;\n-            digits = perThreadBuffer.get();\n-            digitno = ndigits-1;\n-            c = ivalue%10;\n-            ivalue \/= 10;\n-            while ( c == 0 ){\n-                decExponent++;\n-                c = ivalue%10;\n-                ivalue \/= 10;\n-            }\n-            while ( ivalue != 0){\n-                digits[digitno--] = (char)(c+'0');\n-                decExponent++;\n-                c = ivalue%10;\n-                ivalue \/= 10;\n-            }\n-            digits[digitno] = (char)(c+'0');\n-        } else {\n-            \/\/ same algorithm as above (same bugs, too )\n-            \/\/ but using long arithmetic.\n-            ndigits = 20;\n-            digits = perThreadBuffer.get();\n-            digitno = ndigits-1;\n-            c = (int)(lvalue%10L);\n-            lvalue \/= 10L;\n-            while ( c == 0 ){\n-                decExponent++;\n-                c = (int)(lvalue%10L);\n-                lvalue \/= 10L;\n-            }\n-            while ( lvalue != 0L ){\n-                digits[digitno--] = (char)(c+'0');\n-                decExponent++;\n-                c = (int)(lvalue%10L);\n-                lvalue \/= 10;\n-            }\n-            digits[digitno] = (char)(c+'0');\n-        }\n-        char result [];\n-        ndigits -= digitno;\n-        result = new char[ ndigits ];\n-        System.arraycopy( digits, digitno, result, 0, ndigits );\n-        this.digits = result;\n-        this.decExponent = decExponent+1;\n-        this.nDigits = ndigits;\n-    }\n-\n-    \/\/\n-    \/\/ add one to the least significant digit.\n-    \/\/ in the unlikely event there is a carry out,\n-    \/\/ deal with it.\n-    \/\/ assert that this will only happen where there\n-    \/\/ is only one digit, e.g. (float)1e-44 seems to do it.\n-    \/\/\n-    private void\n-    roundup(){\n-        int i;\n-        int q = digits[ i = (nDigits-1)];\n-        if ( q == '9' ){\n-            while ( q == '9' && i > 0 ){\n-                digits[i] = '0';\n-                q = digits[--i];\n-            }\n-            if ( q == '9' ){\n-                \/\/ carryout! High-order 1, rest 0s, larger exp.\n-                decExponent += 1;\n-                digits[0] = '1';\n-                return;\n-            }\n-            \/\/ else fall through.\n-        }\n-        digits[i] = (char)(q+1);\n-        decimalDigitsRoundedUp = true;\n-    }\n-\n-    public boolean digitsRoundedUp() {\n-        return decimalDigitsRoundedUp;\n-    }\n-\n-    \/*\n-     * FIRST IMPORTANT CONSTRUCTOR: DOUBLE\n-     *\/\n-    public OldFloatingDecimalForTest( double d )\n-    {\n-        long    dBits = Double.doubleToLongBits( d );\n-        long    fractBits;\n-        int     binExp;\n-        int     nSignificantBits;\n-\n-        \/\/ discover and delete sign\n-        if ( (dBits&signMask) != 0 ){\n-            isNegative = true;\n-            dBits ^= signMask;\n-        } else {\n-            isNegative = false;\n-        }\n-        \/\/ Begin to unpack\n-        \/\/ Discover obvious special cases of NaN and Infinity.\n-        binExp = (int)( (dBits&expMask) >> expShift );\n-        fractBits = dBits&fractMask;\n-        if ( binExp == (int)(expMask>>expShift) ) {\n-            isExceptional = true;\n-            if ( fractBits == 0L ){\n-                digits =  infinity;\n-            } else {\n-                digits = notANumber;\n-                isNegative = false; \/\/ NaN has no sign!\n-            }\n-            nDigits = digits.length;\n-            return;\n-        }\n-        isExceptional = false;\n-        \/\/ Finish unpacking\n-        \/\/ Normalize denormalized numbers.\n-        \/\/ Insert assumed high-order bit for normalized numbers.\n-        \/\/ Subtract exponent bias.\n-        if ( binExp == 0 ){\n-            if ( fractBits == 0L ){\n-                \/\/ not a denorm, just a 0!\n-                decExponent = 0;\n-                digits = zero;\n-                nDigits = 1;\n-                return;\n-            }\n-            while ( (fractBits&fractHOB) == 0L ){\n-                fractBits <<= 1;\n-                binExp -= 1;\n-            }\n-            nSignificantBits = expShift + binExp +1; \/\/ recall binExp is  - shift count.\n-            binExp += 1;\n-        } else {\n-            fractBits |= fractHOB;\n-            nSignificantBits = expShift+1;\n-        }\n-        binExp -= expBias;\n-        \/\/ call the routine that actually does all the hard work.\n-        dtoa( binExp, fractBits, nSignificantBits );\n-    }\n-\n-    \/*\n-     * SECOND IMPORTANT CONSTRUCTOR: SINGLE\n-     *\/\n-    public OldFloatingDecimalForTest( float f )\n-    {\n-        int     fBits = Float.floatToIntBits( f );\n-        int     fractBits;\n-        int     binExp;\n-        int     nSignificantBits;\n-\n-        \/\/ discover and delete sign\n-        if ( (fBits&singleSignMask) != 0 ){\n-            isNegative = true;\n-            fBits ^= singleSignMask;\n-        } else {\n-            isNegative = false;\n-        }\n-        \/\/ Begin to unpack\n-        \/\/ Discover obvious special cases of NaN and Infinity.\n-        binExp = (fBits&singleExpMask) >> singleExpShift;\n-        fractBits = fBits&singleFractMask;\n-        if ( binExp == (singleExpMask>>singleExpShift) ) {\n-            isExceptional = true;\n-            if ( fractBits == 0L ){\n-                digits =  infinity;\n-            } else {\n-                digits = notANumber;\n-                isNegative = false; \/\/ NaN has no sign!\n-            }\n-            nDigits = digits.length;\n-            return;\n-        }\n-        isExceptional = false;\n-        \/\/ Finish unpacking\n-        \/\/ Normalize denormalized numbers.\n-        \/\/ Insert assumed high-order bit for normalized numbers.\n-        \/\/ Subtract exponent bias.\n-        if ( binExp == 0 ){\n-            if ( fractBits == 0 ){\n-                \/\/ not a denorm, just a 0!\n-                decExponent = 0;\n-                digits = zero;\n-                nDigits = 1;\n-                return;\n-            }\n-            while ( (fractBits&singleFractHOB) == 0 ){\n-                fractBits <<= 1;\n-                binExp -= 1;\n-            }\n-            nSignificantBits = singleExpShift + binExp +1; \/\/ recall binExp is  - shift count.\n-            binExp += 1;\n-        } else {\n-            fractBits |= singleFractHOB;\n-            nSignificantBits = singleExpShift+1;\n-        }\n-        binExp -= singleExpBias;\n-        \/\/ call the routine that actually does all the hard work.\n-        dtoa( binExp, ((long)fractBits)<<(expShift-singleExpShift), nSignificantBits );\n-    }\n-\n-    private void\n-    dtoa( int binExp, long fractBits, int nSignificantBits )\n-    {\n-        int     nFractBits; \/\/ number of significant bits of fractBits;\n-        int     nTinyBits;  \/\/ number of these to the right of the point.\n-        int     decExp;\n-\n-        \/\/ Examine number. Determine if it is an easy case,\n-        \/\/ which we can do pretty trivially using float\/long conversion,\n-        \/\/ or whether we must do real work.\n-        nFractBits = countBits( fractBits );\n-        nTinyBits = Math.max( 0, nFractBits - binExp - 1 );\n-        if ( binExp <= maxSmallBinExp && binExp >= minSmallBinExp ){\n-            \/\/ Look more closely at the number to decide if,\n-            \/\/ with scaling by 10^nTinyBits, the result will fit in\n-            \/\/ a long.\n-            if ( (nTinyBits < long5pow.length) && ((nFractBits + n5bits[nTinyBits]) < 64 ) ){\n-                \/*\n-                 * We can do this:\n-                 * take the fraction bits, which are normalized.\n-                 * (a) nTinyBits == 0: Shift left or right appropriately\n-                 *     to align the binary point at the extreme right, i.e.\n-                 *     where a long int point is expected to be. The integer\n-                 *     result is easily converted to a string.\n-                 * (b) nTinyBits > 0: Shift right by expShift-nFractBits,\n-                 *     which effectively converts to long and scales by\n-                 *     2^nTinyBits. Then multiply by 5^nTinyBits to\n-                 *     complete the scaling. We know this won't overflow\n-                 *     because we just counted the number of bits necessary\n-                 *     in the result. The integer you get from this can\n-                 *     then be converted to a string pretty easily.\n-                 *\/\n-                long halfULP;\n-                if ( nTinyBits == 0 ) {\n-                    if ( binExp > nSignificantBits ){\n-                        halfULP = 1L << ( binExp-nSignificantBits-1);\n-                    } else {\n-                        halfULP = 0L;\n-                    }\n-                    if ( binExp >= expShift ){\n-                        fractBits <<= (binExp-expShift);\n-                    } else {\n-                        fractBits >>>= (expShift-binExp) ;\n-                    }\n-                    developLongDigits( 0, fractBits, halfULP );\n-                    return;\n-                }\n-                \/*\n-                 * The following causes excess digits to be printed\n-                 * out in the single-float case. Our manipulation of\n-                 * halfULP here is apparently not correct. If we\n-                 * better understand how this works, perhaps we can\n-                 * use this special case again. But for the time being,\n-                 * we do not.\n-                 * else {\n-                 *     fractBits >>>= expShift+1-nFractBits;\n-                 *     fractBits *= long5pow[ nTinyBits ];\n-                 *     halfULP = long5pow[ nTinyBits ] >> (1+nSignificantBits-nFractBits);\n-                 *     developLongDigits( -nTinyBits, fractBits, halfULP );\n-                 *     return;\n-                 * }\n-                 *\/\n-            }\n-        }\n-        \/*\n-         * This is the hard case. We are going to compute large positive\n-         * integers B and S and integer decExp, s.t.\n-         *      d = ( B \/ S ) * 10^decExp\n-         *      1 <= B \/ S < 10\n-         * Obvious choices are:\n-         *      decExp = floor( log10(d) )\n-         *      B      = d * 2^nTinyBits * 10^max( 0, -decExp )\n-         *      S      = 10^max( 0, decExp) * 2^nTinyBits\n-         * (noting that nTinyBits has already been forced to non-negative)\n-         * I am also going to compute a large positive integer\n-         *      M      = (1\/2^nSignificantBits) * 2^nTinyBits * 10^max( 0, -decExp )\n-         * i.e. M is (1\/2) of the ULP of d, scaled like B.\n-         * When we iterate through dividing B\/S and picking off the\n-         * quotient bits, we will know when to stop when the remainder\n-         * is <= M.\n-         *\n-         * We keep track of powers of 2 and powers of 5.\n-         *\/\n-\n-        \/*\n-         * Estimate decimal exponent. (If it is small-ish,\n-         * we could double-check.)\n-         *\n-         * First, scale the mantissa bits such that 1 <= d2 < 2.\n-         * We are then going to estimate\n-         *          log10(d2) ~=~  (d2-1.5)\/1.5 + log(1.5)\n-         * and so we can estimate\n-         *      log10(d) ~=~ log10(d2) + binExp * log10(2)\n-         * take the floor and call it decExp.\n-         * FIXME -- use more precise constants here. It costs no more.\n-         *\/\n-        double d2 = Double.longBitsToDouble(\n-            expOne | ( fractBits &~ fractHOB ) );\n-        decExp = (int)Math.floor(\n-            (d2-1.5D)*0.289529654D + 0.176091259 + (double)binExp * 0.301029995663981 );\n-        int B2, B5; \/\/ powers of 2 and powers of 5, respectively, in B\n-        int S2, S5; \/\/ powers of 2 and powers of 5, respectively, in S\n-        int M2, M5; \/\/ powers of 2 and powers of 5, respectively, in M\n-        int Bbits; \/\/ binary digits needed to represent B, approx.\n-        int tenSbits; \/\/ binary digits needed to represent 10*S, approx.\n-        OldFDBigIntForTest Sval, Bval, Mval;\n-\n-        B5 = Math.max( 0, -decExp );\n-        B2 = B5 + nTinyBits + binExp;\n-\n-        S5 = Math.max( 0, decExp );\n-        S2 = S5 + nTinyBits;\n-\n-        M5 = B5;\n-        M2 = B2 - nSignificantBits;\n-\n-        \/*\n-         * the long integer fractBits contains the (nFractBits) interesting\n-         * bits from the mantissa of d ( hidden 1 added if necessary) followed\n-         * by (expShift+1-nFractBits) zeros. In the interest of compactness,\n-         * I will shift out those zeros before turning fractBits into a\n-         * OldFDBigIntForTest. The resulting whole number will be\n-         *      d * 2^(nFractBits-1-binExp).\n-         *\/\n-        fractBits >>>= (expShift+1-nFractBits);\n-        B2 -= nFractBits-1;\n-        int common2factor = Math.min( B2, S2 );\n-        B2 -= common2factor;\n-        S2 -= common2factor;\n-        M2 -= common2factor;\n-\n-        \/*\n-         * HACK!! For exact powers of two, the next smallest number\n-         * is only half as far away as we think (because the meaning of\n-         * ULP changes at power-of-two bounds) for this reason, we\n-         * hack M2. Hope this works.\n-         *\/\n-        if ( nFractBits == 1 )\n-            M2 -= 1;\n-\n-        if ( M2 < 0 ){\n-            \/\/ oops.\n-            \/\/ since we cannot scale M down far enough,\n-            \/\/ we must scale the other values up.\n-            B2 -= M2;\n-            S2 -= M2;\n-            M2 =  0;\n-        }\n-        \/*\n-         * Construct, Scale, iterate.\n-         * Some day, we'll write a stopping test that takes\n-         * account of the asymmetry of the spacing of floating-point\n-         * numbers below perfect powers of 2\n-         * 26 Sept 96 is not that day.\n-         * So we use a symmetric test.\n-         *\/\n-        char digits[] = this.digits = new char[18];\n-        int  ndigit = 0;\n-        boolean low, high;\n-        long lowDigitDifference;\n-        int  q;\n-\n-        \/*\n-         * Detect the special cases where all the numbers we are about\n-         * to compute will fit in int or long integers.\n-         * In these cases, we will avoid doing OldFDBigIntForTest arithmetic.\n-         * We use the same algorithms, except that we \"normalize\"\n-         * our OldFDBigIntForTests before iterating. This is to make division easier,\n-         * as it makes our fist guess (quotient of high-order words)\n-         * more accurate!\n-         *\n-         * Some day, we'll write a stopping test that takes\n-         * account of the asymmetry of the spacing of floating-point\n-         * numbers below perfect powers of 2\n-         * 26 Sept 96 is not that day.\n-         * So we use a symmetric test.\n-         *\/\n-        Bbits = nFractBits + B2 + (( B5 < n5bits.length )? n5bits[B5] : ( B5*3 ));\n-        tenSbits = S2+1 + (( (S5+1) < n5bits.length )? n5bits[(S5+1)] : ( (S5+1)*3 ));\n-        if ( Bbits < 64 && tenSbits < 64){\n-            if ( Bbits < 32 && tenSbits < 32){\n-                \/\/ wa-hoo! They're all ints!\n-                int b = ((int)fractBits * small5pow[B5] ) << B2;\n-                int s = small5pow[S5] << S2;\n-                int m = small5pow[M5] << M2;\n-                int tens = s * 10;\n-                \/*\n-                 * Unroll the first iteration. If our decExp estimate\n-                 * was too high, our first quotient will be zero. In this\n-                 * case, we discard it and decrement decExp.\n-                 *\/\n-                ndigit = 0;\n-                q = b \/ s;\n-                b = 10 * ( b % s );\n-                m *= 10;\n-                low  = (b <  m );\n-                high = (b+m > tens );\n-                assert q < 10 : q; \/\/ excessively large digit\n-                if ( (q == 0) && ! high ){\n-                    \/\/ oops. Usually ignore leading zero.\n-                    decExp--;\n-                } else {\n-                    digits[ndigit++] = (char)('0' + q);\n-                }\n-                \/*\n-                 * HACK! Java spec sez that we always have at least\n-                 * one digit after the . in either F- or E-form output.\n-                 * Thus we will need more than one digit if we're using\n-                 * E-form\n-                 *\/\n-                if ( decExp < -3 || decExp >= 8 ){\n-                    high = low = false;\n-                }\n-                while( ! low && ! high ){\n-                    q = b \/ s;\n-                    b = 10 * ( b % s );\n-                    m *= 10;\n-                    assert q < 10 : q; \/\/ excessively large digit\n-                    if ( m > 0L ){\n-                        low  = (b <  m );\n-                        high = (b+m > tens );\n-                    } else {\n-                        \/\/ hack -- m might overflow!\n-                        \/\/ in this case, it is certainly > b,\n-                        \/\/ which won't\n-                        \/\/ and b+m > tens, too, since that has overflowed\n-                        \/\/ either!\n-                        low = true;\n-                        high = true;\n-                    }\n-                    digits[ndigit++] = (char)('0' + q);\n-                }\n-                lowDigitDifference = (b<<1) - tens;\n-                exactDecimalConversion  = (b == 0);\n-            } else {\n-                \/\/ still good! they're all longs!\n-                long b = (fractBits * long5pow[B5] ) << B2;\n-                long s = long5pow[S5] << S2;\n-                long m = long5pow[M5] << M2;\n-                long tens = s * 10L;\n-                \/*\n-                 * Unroll the first iteration. If our decExp estimate\n-                 * was too high, our first quotient will be zero. In this\n-                 * case, we discard it and decrement decExp.\n-                 *\/\n-                ndigit = 0;\n-                q = (int) ( b \/ s );\n-                b = 10L * ( b % s );\n-                m *= 10L;\n-                low  = (b <  m );\n-                high = (b+m > tens );\n-                assert q < 10 : q; \/\/ excessively large digit\n-                if ( (q == 0) && ! high ){\n-                    \/\/ oops. Usually ignore leading zero.\n-                    decExp--;\n-                } else {\n-                    digits[ndigit++] = (char)('0' + q);\n-                }\n-                \/*\n-                 * HACK! Java spec sez that we always have at least\n-                 * one digit after the . in either F- or E-form output.\n-                 * Thus we will need more than one digit if we're using\n-                 * E-form\n-                 *\/\n-                if ( decExp < -3 || decExp >= 8 ){\n-                    high = low = false;\n-                }\n-                while( ! low && ! high ){\n-                    q = (int) ( b \/ s );\n-                    b = 10 * ( b % s );\n-                    m *= 10;\n-                    assert q < 10 : q;  \/\/ excessively large digit\n-                    if ( m > 0L ){\n-                        low  = (b <  m );\n-                        high = (b+m > tens );\n-                    } else {\n-                        \/\/ hack -- m might overflow!\n-                        \/\/ in this case, it is certainly > b,\n-                        \/\/ which won't\n-                        \/\/ and b+m > tens, too, since that has overflowed\n-                        \/\/ either!\n-                        low = true;\n-                        high = true;\n-                    }\n-                    digits[ndigit++] = (char)('0' + q);\n-                }\n-                lowDigitDifference = (b<<1) - tens;\n-                exactDecimalConversion  = (b == 0);\n-            }\n-        } else {\n-            OldFDBigIntForTest ZeroVal = new OldFDBigIntForTest(0);\n-            OldFDBigIntForTest tenSval;\n-            int  shiftBias;\n-\n-            \/*\n-             * We really must do OldFDBigIntForTest arithmetic.\n-             * Fist, construct our OldFDBigIntForTest initial values.\n-             *\/\n-            Bval = multPow52( new OldFDBigIntForTest( fractBits  ), B5, B2 );\n-            Sval = constructPow52( S5, S2 );\n-            Mval = constructPow52( M5, M2 );\n-\n-\n-            \/\/ normalize so that division works better\n-            Bval.lshiftMe( shiftBias = Sval.normalizeMe() );\n-            Mval.lshiftMe( shiftBias );\n-            tenSval = Sval.mult( 10 );\n-            \/*\n-             * Unroll the first iteration. If our decExp estimate\n-             * was too high, our first quotient will be zero. In this\n-             * case, we discard it and decrement decExp.\n-             *\/\n-            ndigit = 0;\n-            q = Bval.quoRemIteration( Sval );\n-            Mval = Mval.mult( 10 );\n-            low  = (Bval.cmp( Mval ) < 0);\n-            high = (Bval.add( Mval ).cmp( tenSval ) > 0 );\n-            assert q < 10 : q; \/\/ excessively large digit\n-            if ( (q == 0) && ! high ){\n-                \/\/ oops. Usually ignore leading zero.\n-                decExp--;\n-            } else {\n-                digits[ndigit++] = (char)('0' + q);\n-            }\n-            \/*\n-             * HACK! Java spec sez that we always have at least\n-             * one digit after the . in either F- or E-form output.\n-             * Thus we will need more than one digit if we're using\n-             * E-form\n-             *\/\n-            if ( decExp < -3 || decExp >= 8 ){\n-                high = low = false;\n-            }\n-            while( ! low && ! high ){\n-                q = Bval.quoRemIteration( Sval );\n-                Mval = Mval.mult( 10 );\n-                assert q < 10 : q;  \/\/ excessively large digit\n-                low  = (Bval.cmp( Mval ) < 0);\n-                high = (Bval.add( Mval ).cmp( tenSval ) > 0 );\n-                digits[ndigit++] = (char)('0' + q);\n-            }\n-            if ( high && low ){\n-                Bval.lshiftMe(1);\n-                lowDigitDifference = Bval.cmp(tenSval);\n-            } else {\n-                lowDigitDifference = 0L; \/\/ this here only for flow analysis!\n-            }\n-            exactDecimalConversion  = (Bval.cmp( ZeroVal ) == 0);\n-        }\n-        this.decExponent = decExp+1;\n-        this.digits = digits;\n-        this.nDigits = ndigit;\n-        \/*\n-         * Last digit gets rounded based on stopping condition.\n-         *\/\n-        if ( high ){\n-            if ( low ){\n-                if ( lowDigitDifference == 0L ){\n-                    \/\/ it's a tie!\n-                    \/\/ choose based on which digits we like.\n-                    if ( (digits[nDigits-1]&1) != 0 ) roundup();\n-                } else if ( lowDigitDifference > 0 ){\n-                    roundup();\n-                }\n-            } else {\n-                roundup();\n-            }\n-        }\n-    }\n-\n-    public boolean decimalDigitsExact() {\n-        return exactDecimalConversion;\n-    }\n-\n-    public String\n-    toString(){\n-        \/\/ most brain-dead version\n-        StringBuffer result = new StringBuffer( nDigits+8 );\n-        if ( isNegative ){ result.append( '-' ); }\n-        if ( isExceptional ){\n-            result.append( digits, 0, nDigits );\n-        } else {\n-            result.append( \"0.\");\n-            result.append( digits, 0, nDigits );\n-            result.append('e');\n-            result.append( decExponent );\n-        }\n-        return new String(result);\n-    }\n-\n-    public String toJavaFormatString() {\n-        char result[] = perThreadBuffer.get();\n-        int i = getChars(result);\n-        return new String(result, 0, i);\n-    }\n-\n-    private int getChars(char[] result) {\n-        assert nDigits <= 19 : nDigits; \/\/ generous bound on size of nDigits\n-        int i = 0;\n-        if (isNegative) { result[0] = '-'; i = 1; }\n-        if (isExceptional) {\n-            System.arraycopy(digits, 0, result, i, nDigits);\n-            i += nDigits;\n-        } else {\n-            if (decExponent > 0 && decExponent < 8) {\n-                \/\/ print digits.digits.\n-                int charLength = Math.min(nDigits, decExponent);\n-                System.arraycopy(digits, 0, result, i, charLength);\n-                i += charLength;\n-                if (charLength < decExponent) {\n-                    charLength = decExponent-charLength;\n-                    System.arraycopy(zero, 0, result, i, charLength);\n-                    i += charLength;\n-                    result[i++] = '.';\n-                    result[i++] = '0';\n-                } else {\n-                    result[i++] = '.';\n-                    if (charLength < nDigits) {\n-                        int t = nDigits - charLength;\n-                        System.arraycopy(digits, charLength, result, i, t);\n-                        i += t;\n-                    } else {\n-                        result[i++] = '0';\n-                    }\n-                }\n-            } else if (decExponent <=0 && decExponent > -3) {\n-                result[i++] = '0';\n-                result[i++] = '.';\n-                if (decExponent != 0) {\n-                    System.arraycopy(zero, 0, result, i, -decExponent);\n-                    i -= decExponent;\n-                }\n-                System.arraycopy(digits, 0, result, i, nDigits);\n-                i += nDigits;\n-            } else {\n-                result[i++] = digits[0];\n-                result[i++] = '.';\n-                if (nDigits > 1) {\n-                    System.arraycopy(digits, 1, result, i, nDigits-1);\n-                    i += nDigits-1;\n-                } else {\n-                    result[i++] = '0';\n-                }\n-                result[i++] = 'E';\n-                int e;\n-                if (decExponent <= 0) {\n-                    result[i++] = '-';\n-                    e = -decExponent+1;\n-                } else {\n-                    e = decExponent-1;\n-                }\n-                \/\/ decExponent has 1, 2, or 3, digits\n-                if (e <= 9) {\n-                    result[i++] = (char)(e+'0');\n-                } else if (e <= 99) {\n-                    result[i++] = (char)(e\/10 +'0');\n-                    result[i++] = (char)(e%10 + '0');\n-                } else {\n-                    result[i++] = (char)(e\/100+'0');\n-                    e %= 100;\n-                    result[i++] = (char)(e\/10+'0');\n-                    result[i++] = (char)(e%10 + '0');\n-                }\n-            }\n-        }\n-        return i;\n-    }\n-\n-    \/\/ Per-thread buffer for string\/stringbuffer conversion\n-    private static ThreadLocal<char[]> perThreadBuffer = new ThreadLocal<char[]>() {\n-            protected synchronized char[] initialValue() {\n-                return new char[26];\n-            }\n-        };\n-\n-    public void appendTo(Appendable buf) {\n-          char result[] = perThreadBuffer.get();\n-          int i = getChars(result);\n-        if (buf instanceof StringBuilder)\n-            ((StringBuilder) buf).append(result, 0, i);\n-        else if (buf instanceof StringBuffer)\n-            ((StringBuffer) buf).append(result, 0, i);\n-        else\n-            assert false;\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    public static OldFloatingDecimalForTest\n-    readJavaFormatString( String in ) throws NumberFormatException {\n-        boolean isNegative = false;\n-        boolean signSeen   = false;\n-        int     decExp;\n-        char    c;\n-\n-    parseNumber:\n-        try{\n-            in = in.trim(); \/\/ don't fool around with white space.\n-                            \/\/ throws NullPointerException if null\n-            int l = in.length();\n-            if ( l == 0 ) throw new NumberFormatException(\"empty String\");\n-            int i = 0;\n-            switch ( c = in.charAt( i ) ){\n-            case '-':\n-                isNegative = true;\n-                \/\/FALLTHROUGH\n-            case '+':\n-                i++;\n-                signSeen = true;\n-            }\n-\n-            \/\/ Check for NaN and Infinity strings\n-            c = in.charAt(i);\n-            if(c == 'N' || c == 'I') { \/\/ possible NaN or infinity\n-                boolean potentialNaN = false;\n-                char targetChars[] = null;  \/\/ char array of \"NaN\" or \"Infinity\"\n-\n-                if(c == 'N') {\n-                    targetChars = notANumber;\n-                    potentialNaN = true;\n-                } else {\n-                    targetChars = infinity;\n-                }\n-\n-                \/\/ compare Input string to \"NaN\" or \"Infinity\"\n-                int j = 0;\n-                while(i < l && j < targetChars.length) {\n-                    if(in.charAt(i) == targetChars[j]) {\n-                        i++; j++;\n-                    }\n-                    else \/\/ something is amiss, throw exception\n-                        break parseNumber;\n-                }\n-\n-                \/\/ For the candidate string to be a NaN or infinity,\n-                \/\/ all characters in input string and target char[]\n-                \/\/ must be matched ==> j must equal targetChars.length\n-                \/\/ and i must equal l\n-                if( (j == targetChars.length) && (i == l) ) { \/\/ return NaN or infinity\n-                    return (potentialNaN ? new OldFloatingDecimalForTest(Double.NaN) \/\/ NaN has no sign\n-                            : new OldFloatingDecimalForTest(isNegative?\n-                                                  Double.NEGATIVE_INFINITY:\n-                                                  Double.POSITIVE_INFINITY)) ;\n-                }\n-                else { \/\/ something went wrong, throw exception\n-                    break parseNumber;\n-                }\n-\n-            } else if (c == '0')  { \/\/ check for hexadecimal floating-point number\n-                if (l > i+1 ) {\n-                    char ch = in.charAt(i+1);\n-                    if (ch == 'x' || ch == 'X' ) \/\/ possible hex string\n-                        return parseHexString(in);\n-                }\n-            }  \/\/ look for and process decimal floating-point string\n-\n-            char[] digits = new char[ l ];\n-            int    nDigits= 0;\n-            boolean decSeen = false;\n-            int decPt = 0;\n-            int nLeadZero = 0;\n-            int nTrailZero= 0;\n-        digitLoop:\n-            while ( i < l ){\n-                switch ( c = in.charAt( i ) ){\n-                case '0':\n-                    if ( nDigits > 0 ){\n-                        nTrailZero += 1;\n-                    } else {\n-                        nLeadZero += 1;\n-                    }\n-                    break; \/\/ out of switch.\n-                case '1':\n-                case '2':\n-                case '3':\n-                case '4':\n-                case '5':\n-                case '6':\n-                case '7':\n-                case '8':\n-                case '9':\n-                    while ( nTrailZero > 0 ){\n-                        digits[nDigits++] = '0';\n-                        nTrailZero -= 1;\n-                    }\n-                    digits[nDigits++] = c;\n-                    break; \/\/ out of switch.\n-                case '.':\n-                    if ( decSeen ){\n-                        \/\/ already saw one ., this is the 2nd.\n-                        throw new NumberFormatException(\"multiple points\");\n-                    }\n-                    decPt = i;\n-                    if ( signSeen ){\n-                        decPt -= 1;\n-                    }\n-                    decSeen = true;\n-                    break; \/\/ out of switch.\n-                default:\n-                    break digitLoop;\n-                }\n-                i++;\n-            }\n-            \/*\n-             * At this point, we've scanned all the digits and decimal\n-             * point we're going to see. Trim off leading and trailing\n-             * zeros, which will just confuse us later, and adjust\n-             * our initial decimal exponent accordingly.\n-             * To review:\n-             * we have seen i total characters.\n-             * nLeadZero of them were zeros before any other digits.\n-             * nTrailZero of them were zeros after any other digits.\n-             * if ( decSeen ), then a . was seen after decPt characters\n-             * ( including leading zeros which have been discarded )\n-             * nDigits characters were neither lead nor trailing\n-             * zeros, nor point\n-             *\/\n-            \/*\n-             * special hack: if we saw no non-zero digits, then the\n-             * answer is zero!\n-             * Unfortunately, we feel honor-bound to keep parsing!\n-             *\/\n-            if ( nDigits == 0 ){\n-                digits = zero;\n-                nDigits = 1;\n-                if ( nLeadZero == 0 ){\n-                    \/\/ we saw NO DIGITS AT ALL,\n-                    \/\/ not even a crummy 0!\n-                    \/\/ this is not allowed.\n-                    break parseNumber; \/\/ go throw exception\n-                }\n-\n-            }\n-\n-            \/* Our initial exponent is decPt, adjusted by the number of\n-             * discarded zeros. Or, if there was no decPt,\n-             * then its just nDigits adjusted by discarded trailing zeros.\n-             *\/\n-            if ( decSeen ){\n-                decExp = decPt - nLeadZero;\n-            } else {\n-                decExp = nDigits+nTrailZero;\n-            }\n-\n-            \/*\n-             * Look for 'e' or 'E' and an optionally signed integer.\n-             *\/\n-            if ( (i < l) &&  (((c = in.charAt(i) )=='e') || (c == 'E') ) ){\n-                int expSign = 1;\n-                int expVal  = 0;\n-                int reallyBig = Integer.MAX_VALUE \/ 10;\n-                boolean expOverflow = false;\n-                switch( in.charAt(++i) ){\n-                case '-':\n-                    expSign = -1;\n-                    \/\/FALLTHROUGH\n-                case '+':\n-                    i++;\n-                }\n-                int expAt = i;\n-            expLoop:\n-                while ( i < l  ){\n-                    if ( expVal >= reallyBig ){\n-                        \/\/ the next character will cause integer\n-                        \/\/ overflow.\n-                        expOverflow = true;\n-                    }\n-                    switch ( c = in.charAt(i++) ){\n-                    case '0':\n-                    case '1':\n-                    case '2':\n-                    case '3':\n-                    case '4':\n-                    case '5':\n-                    case '6':\n-                    case '7':\n-                    case '8':\n-                    case '9':\n-                        expVal = expVal*10 + ( (int)c - (int)'0' );\n-                        continue;\n-                    default:\n-                        i--;           \/\/ back up.\n-                        break expLoop; \/\/ stop parsing exponent.\n-                    }\n-                }\n-                int expLimit = bigDecimalExponent+nDigits+nTrailZero;\n-                if ( expOverflow || ( expVal > expLimit ) ){\n-                    \/\/\n-                    \/\/ The intent here is to end up with\n-                    \/\/ infinity or zero, as appropriate.\n-                    \/\/ The reason for yielding such a small decExponent,\n-                    \/\/ rather than something intuitive such as\n-                    \/\/ expSign*Integer.MAX_VALUE, is that this value\n-                    \/\/ is subject to further manipulation in\n-                    \/\/ doubleValue() and floatValue(), and I don't want\n-                    \/\/ it to be able to cause overflow there!\n-                    \/\/ (The only way we can get into trouble here is for\n-                    \/\/ really outrageous nDigits+nTrailZero, such as 2 billion. )\n-                    \/\/\n-                    decExp = expSign*expLimit;\n-                } else {\n-                    \/\/ this should not overflow, since we tested\n-                    \/\/ for expVal > (MAX+N), where N >= abs(decExp)\n-                    decExp = decExp + expSign*expVal;\n-                }\n-\n-                \/\/ if we saw something not a digit ( or end of string )\n-                \/\/ after the [Ee][+-], without seeing any digits at all\n-                \/\/ this is certainly an error. If we saw some digits,\n-                \/\/ but then some trailing garbage, that might be ok.\n-                \/\/ so we just fall through in that case.\n-                \/\/ HUMBUG\n-                if ( i == expAt )\n-                    break parseNumber; \/\/ certainly bad\n-            }\n-            \/*\n-             * We parsed everything we could.\n-             * If there are leftovers, then this is not good input!\n-             *\/\n-            if ( i < l &&\n-                ((i != l - 1) ||\n-                (in.charAt(i) != 'f' &&\n-                 in.charAt(i) != 'F' &&\n-                 in.charAt(i) != 'd' &&\n-                 in.charAt(i) != 'D'))) {\n-                break parseNumber; \/\/ go throw exception\n-            }\n-\n-            return new OldFloatingDecimalForTest( isNegative, decExp, digits, nDigits,  false );\n-        } catch ( StringIndexOutOfBoundsException e ){ }\n-        throw new NumberFormatException(\"For input string: \\\"\" + in + \"\\\"\");\n-    }\n-\n-    \/*\n-     * Take a FloatingDecimal, which we presumably just scanned in,\n-     * and find out what its value is, as a double.\n-     *\n-     * AS A SIDE EFFECT, SET roundDir TO INDICATE PREFERRED\n-     * ROUNDING DIRECTION in case the result is really destined\n-     * for a single-precision float.\n-     *\/\n-\n-    public strictfp double doubleValue(){\n-        int     kDigits = Math.min( nDigits, maxDecimalDigits+1 );\n-        long    lValue;\n-        double  dValue;\n-        double  rValue, tValue;\n-\n-        \/\/ First, check for NaN and Infinity values\n-        if(digits == infinity || digits == notANumber) {\n-            if(digits == notANumber)\n-                return Double.NaN;\n-            else\n-                return (isNegative?Double.NEGATIVE_INFINITY:Double.POSITIVE_INFINITY);\n-        }\n-        else {\n-            if (mustSetRoundDir) {\n-                roundDir = 0;\n-            }\n-            \/*\n-             * convert the lead kDigits to a long integer.\n-             *\/\n-            \/\/ (special performance hack: start to do it using int)\n-            int iValue = (int)digits[0]-(int)'0';\n-            int iDigits = Math.min( kDigits, intDecimalDigits );\n-            for ( int i=1; i < iDigits; i++ ){\n-                iValue = iValue*10 + (int)digits[i]-(int)'0';\n-            }\n-            lValue = (long)iValue;\n-            for ( int i=iDigits; i < kDigits; i++ ){\n-                lValue = lValue*10L + (long)((int)digits[i]-(int)'0');\n-            }\n-            dValue = (double)lValue;\n-            int exp = decExponent-kDigits;\n-            \/*\n-             * lValue now contains a long integer with the value of\n-             * the first kDigits digits of the number.\n-             * dValue contains the (double) of the same.\n-             *\/\n-\n-            if ( nDigits <= maxDecimalDigits ){\n-                \/*\n-                 * possibly an easy case.\n-                 * We know that the digits can be represented\n-                 * exactly. And if the exponent isn't too outrageous,\n-                 * the whole thing can be done with one operation,\n-                 * thus one rounding error.\n-                 * Note that all our constructors trim all leading and\n-                 * trailing zeros, so simple values (including zero)\n-                 * will always end up here\n-                 *\/\n-                if (exp == 0 || dValue == 0.0)\n-                    return (isNegative)? -dValue : dValue; \/\/ small floating integer\n-                else if ( exp >= 0 ){\n-                    if ( exp <= maxSmallTen ){\n-                        \/*\n-                         * Can get the answer with one operation,\n-                         * thus one roundoff.\n-                         *\/\n-                        rValue = dValue * small10pow[exp];\n-                        if ( mustSetRoundDir ){\n-                            tValue = rValue \/ small10pow[exp];\n-                            roundDir = ( tValue ==  dValue ) ? 0\n-                                :( tValue < dValue ) ? 1\n-                                : -1;\n-                        }\n-                        return (isNegative)? -rValue : rValue;\n-                    }\n-                    int slop = maxDecimalDigits - kDigits;\n-                    if ( exp <= maxSmallTen+slop ){\n-                        \/*\n-                         * We can multiply dValue by 10^(slop)\n-                         * and it is still \"small\" and exact.\n-                         * Then we can multiply by 10^(exp-slop)\n-                         * with one rounding.\n-                         *\/\n-                        dValue *= small10pow[slop];\n-                        rValue = dValue * small10pow[exp-slop];\n-\n-                        if ( mustSetRoundDir ){\n-                            tValue = rValue \/ small10pow[exp-slop];\n-                            roundDir = ( tValue ==  dValue ) ? 0\n-                                :( tValue < dValue ) ? 1\n-                                : -1;\n-                        }\n-                        return (isNegative)? -rValue : rValue;\n-                    }\n-                    \/*\n-                     * Else we have a hard case with a positive exp.\n-                     *\/\n-                } else {\n-                    if ( exp >= -maxSmallTen ){\n-                        \/*\n-                         * Can get the answer in one division.\n-                         *\/\n-                        rValue = dValue \/ small10pow[-exp];\n-                        tValue = rValue * small10pow[-exp];\n-                        if ( mustSetRoundDir ){\n-                            roundDir = ( tValue ==  dValue ) ? 0\n-                                :( tValue < dValue ) ? 1\n-                                : -1;\n-                        }\n-                        return (isNegative)? -rValue : rValue;\n-                    }\n-                    \/*\n-                     * Else we have a hard case with a negative exp.\n-                     *\/\n-                }\n-            }\n-\n-            \/*\n-             * Harder cases:\n-             * The sum of digits plus exponent is greater than\n-             * what we think we can do with one error.\n-             *\n-             * Start by approximating the right answer by,\n-             * naively, scaling by powers of 10.\n-             *\/\n-            if ( exp > 0 ){\n-                if ( decExponent > maxDecimalExponent+1 ){\n-                    \/*\n-                     * Lets face it. This is going to be\n-                     * Infinity. Cut to the chase.\n-                     *\/\n-                    return (isNegative)? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n-                }\n-                if ( (exp&15) != 0 ){\n-                    dValue *= small10pow[exp&15];\n-                }\n-                if ( (exp>>=4) != 0 ){\n-                    int j;\n-                    for( j = 0; exp > 1; j++, exp>>=1 ){\n-                        if ( (exp&1)!=0)\n-                            dValue *= big10pow[j];\n-                    }\n-                    \/*\n-                     * The reason for the weird exp > 1 condition\n-                     * in the above loop was so that the last multiply\n-                     * would get unrolled. We handle it here.\n-                     * It could overflow.\n-                     *\/\n-                    double t = dValue * big10pow[j];\n-                    if ( Double.isInfinite( t ) ){\n-                        \/*\n-                         * It did overflow.\n-                         * Look more closely at the result.\n-                         * If the exponent is just one too large,\n-                         * then use the maximum finite as our estimate\n-                         * value. Else call the result infinity\n-                         * and punt it.\n-                         * ( I presume this could happen because\n-                         * rounding forces the result here to be\n-                         * an ULP or two larger than\n-                         * Double.MAX_VALUE ).\n-                         *\/\n-                        t = dValue \/ 2.0;\n-                        t *= big10pow[j];\n-                        if ( Double.isInfinite( t ) ){\n-                            return (isNegative)? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n-                        }\n-                        t = Double.MAX_VALUE;\n-                    }\n-                    dValue = t;\n-                }\n-            } else if ( exp < 0 ){\n-                exp = -exp;\n-                if ( decExponent < minDecimalExponent-1 ){\n-                    \/*\n-                     * Lets face it. This is going to be\n-                     * zero. Cut to the chase.\n-                     *\/\n-                    return (isNegative)? -0.0 : 0.0;\n-                }\n-                if ( (exp&15) != 0 ){\n-                    dValue \/= small10pow[exp&15];\n-                }\n-                if ( (exp>>=4) != 0 ){\n-                    int j;\n-                    for( j = 0; exp > 1; j++, exp>>=1 ){\n-                        if ( (exp&1)!=0)\n-                            dValue *= tiny10pow[j];\n-                    }\n-                    \/*\n-                     * The reason for the weird exp > 1 condition\n-                     * in the above loop was so that the last multiply\n-                     * would get unrolled. We handle it here.\n-                     * It could underflow.\n-                     *\/\n-                    double t = dValue * tiny10pow[j];\n-                    if ( t == 0.0 ){\n-                        \/*\n-                         * It did underflow.\n-                         * Look more closely at the result.\n-                         * If the exponent is just one too small,\n-                         * then use the minimum finite as our estimate\n-                         * value. Else call the result 0.0\n-                         * and punt it.\n-                         * ( I presume this could happen because\n-                         * rounding forces the result here to be\n-                         * an ULP or two less than\n-                         * Double.MIN_VALUE ).\n-                         *\/\n-                        t = dValue * 2.0;\n-                        t *= tiny10pow[j];\n-                        if ( t == 0.0 ){\n-                            return (isNegative)? -0.0 : 0.0;\n-                        }\n-                        t = Double.MIN_VALUE;\n-                    }\n-                    dValue = t;\n-                }\n-            }\n-\n-            \/*\n-             * dValue is now approximately the result.\n-             * The hard part is adjusting it, by comparison\n-             * with OldFDBigIntForTest arithmetic.\n-             * Formulate the EXACT big-number result as\n-             * bigD0 * 10^exp\n-             *\/\n-            OldFDBigIntForTest bigD0 = new OldFDBigIntForTest( lValue, digits, kDigits, nDigits );\n-            exp   = decExponent - nDigits;\n-\n-            correctionLoop:\n-            while(true){\n-                \/* AS A SIDE EFFECT, THIS METHOD WILL SET THE INSTANCE VARIABLES\n-                 * bigIntExp and bigIntNBits\n-                 *\/\n-                OldFDBigIntForTest bigB = doubleToBigInt( dValue );\n-\n-                \/*\n-                 * Scale bigD, bigB appropriately for\n-                 * big-integer operations.\n-                 * Naively, we multiply by powers of ten\n-                 * and powers of two. What we actually do\n-                 * is keep track of the powers of 5 and\n-                 * powers of 2 we would use, then factor out\n-                 * common divisors before doing the work.\n-                 *\/\n-                int B2, B5; \/\/ powers of 2, 5 in bigB\n-                int     D2, D5; \/\/ powers of 2, 5 in bigD\n-                int Ulp2;   \/\/ powers of 2 in halfUlp.\n-                if ( exp >= 0 ){\n-                    B2 = B5 = 0;\n-                    D2 = D5 = exp;\n-                } else {\n-                    B2 = B5 = -exp;\n-                    D2 = D5 = 0;\n-                }\n-                if ( bigIntExp >= 0 ){\n-                    B2 += bigIntExp;\n-                } else {\n-                    D2 -= bigIntExp;\n-                }\n-                Ulp2 = B2;\n-                \/\/ shift bigB and bigD left by a number s. t.\n-                \/\/ halfUlp is still an integer.\n-                int hulpbias;\n-                if ( bigIntExp+bigIntNBits <= -expBias+1 ){\n-                    \/\/ This is going to be a denormalized number\n-                    \/\/ (if not actually zero).\n-                    \/\/ half an ULP is at 2^-(expBias+expShift+1)\n-                    hulpbias = bigIntExp+ expBias + expShift;\n-                } else {\n-                    hulpbias = expShift + 2 - bigIntNBits;\n-                }\n-                B2 += hulpbias;\n-                D2 += hulpbias;\n-                \/\/ if there are common factors of 2, we might just as well\n-                \/\/ factor them out, as they add nothing useful.\n-                int common2 = Math.min( B2, Math.min( D2, Ulp2 ) );\n-                B2 -= common2;\n-                D2 -= common2;\n-                Ulp2 -= common2;\n-                \/\/ do multiplications by powers of 5 and 2\n-                bigB = multPow52( bigB, B5, B2 );\n-                OldFDBigIntForTest bigD = multPow52( new OldFDBigIntForTest( bigD0 ), D5, D2 );\n-                \/\/\n-                \/\/ to recap:\n-                \/\/ bigB is the scaled-big-int version of our floating-point\n-                \/\/ candidate.\n-                \/\/ bigD is the scaled-big-int version of the exact value\n-                \/\/ as we understand it.\n-                \/\/ halfUlp is 1\/2 an ulp of bigB, except for special cases\n-                \/\/ of exact powers of 2\n-                \/\/\n-                \/\/ the plan is to compare bigB with bigD, and if the difference\n-                \/\/ is less than halfUlp, then we're satisfied. Otherwise,\n-                \/\/ use the ratio of difference to halfUlp to calculate a fudge\n-                \/\/ factor to add to the floating value, then go 'round again.\n-                \/\/\n-                OldFDBigIntForTest diff;\n-                int cmpResult;\n-                boolean overvalue;\n-                if ( (cmpResult = bigB.cmp( bigD ) ) > 0 ){\n-                    overvalue = true; \/\/ our candidate is too big.\n-                    diff = bigB.sub( bigD );\n-                    if ( (bigIntNBits == 1) && (bigIntExp > -expBias+1) ){\n-                        \/\/ candidate is a normalized exact power of 2 and\n-                        \/\/ is too big. We will be subtracting.\n-                        \/\/ For our purposes, ulp is the ulp of the\n-                        \/\/ next smaller range.\n-                        Ulp2 -= 1;\n-                        if ( Ulp2 < 0 ){\n-                            \/\/ rats. Cannot de-scale ulp this far.\n-                            \/\/ must scale diff in other direction.\n-                            Ulp2 = 0;\n-                            diff.lshiftMe( 1 );\n-                        }\n-                    }\n-                } else if ( cmpResult < 0 ){\n-                    overvalue = false; \/\/ our candidate is too small.\n-                    diff = bigD.sub( bigB );\n-                } else {\n-                    \/\/ the candidate is exactly right!\n-                    \/\/ this happens with surprising frequency\n-                    break correctionLoop;\n-                }\n-                OldFDBigIntForTest halfUlp = constructPow52( B5, Ulp2 );\n-                if ( (cmpResult = diff.cmp( halfUlp ) ) < 0 ){\n-                    \/\/ difference is small.\n-                    \/\/ this is close enough\n-                    if (mustSetRoundDir) {\n-                        roundDir = overvalue ? -1 : 1;\n-                    }\n-                    break correctionLoop;\n-                } else if ( cmpResult == 0 ){\n-                    \/\/ difference is exactly half an ULP\n-                    \/\/ round to some other value maybe, then finish\n-                    dValue += 0.5*ulp( dValue, overvalue );\n-                    \/\/ should check for bigIntNBits == 1 here??\n-                    if (mustSetRoundDir) {\n-                        roundDir = overvalue ? -1 : 1;\n-                    }\n-                    break correctionLoop;\n-                } else {\n-                    \/\/ difference is non-trivial.\n-                    \/\/ could scale addend by ratio of difference to\n-                    \/\/ halfUlp here, if we bothered to compute that difference.\n-                    \/\/ Most of the time ( I hope ) it is about 1 anyway.\n-                    dValue += ulp( dValue, overvalue );\n-                    if ( dValue == 0.0 || dValue == Double.POSITIVE_INFINITY )\n-                        break correctionLoop; \/\/ oops. Fell off end of range.\n-                    continue; \/\/ try again.\n-                }\n-\n-            }\n-            return (isNegative)? -dValue : dValue;\n-        }\n-    }\n-\n-    \/*\n-     * Take a FloatingDecimal, which we presumably just scanned in,\n-     * and find out what its value is, as a float.\n-     * This is distinct from doubleValue() to avoid the extremely\n-     * unlikely case of a double rounding error, wherein the conversion\n-     * to double has one rounding error, and the conversion of that double\n-     * to a float has another rounding error, IN THE WRONG DIRECTION,\n-     * ( because of the preference to a zero low-order bit ).\n-     *\/\n-\n-    public strictfp float floatValue(){\n-        int     kDigits = Math.min( nDigits, singleMaxDecimalDigits+1 );\n-        int     iValue;\n-        float   fValue;\n-\n-        \/\/ First, check for NaN and Infinity values\n-        if(digits == infinity || digits == notANumber) {\n-            if(digits == notANumber)\n-                return Float.NaN;\n-            else\n-                return (isNegative?Float.NEGATIVE_INFINITY:Float.POSITIVE_INFINITY);\n-        }\n-        else {\n-            \/*\n-             * convert the lead kDigits to an integer.\n-             *\/\n-            iValue = (int)digits[0]-(int)'0';\n-            for ( int i=1; i < kDigits; i++ ){\n-                iValue = iValue*10 + (int)digits[i]-(int)'0';\n-            }\n-            fValue = (float)iValue;\n-            int exp = decExponent-kDigits;\n-            \/*\n-             * iValue now contains an integer with the value of\n-             * the first kDigits digits of the number.\n-             * fValue contains the (float) of the same.\n-             *\/\n-\n-            if ( nDigits <= singleMaxDecimalDigits ){\n-                \/*\n-                 * possibly an easy case.\n-                 * We know that the digits can be represented\n-                 * exactly. And if the exponent isn't too outrageous,\n-                 * the whole thing can be done with one operation,\n-                 * thus one rounding error.\n-                 * Note that all our constructors trim all leading and\n-                 * trailing zeros, so simple values (including zero)\n-                 * will always end up here.\n-                 *\/\n-                if (exp == 0 || fValue == 0.0f)\n-                    return (isNegative)? -fValue : fValue; \/\/ small floating integer\n-                else if ( exp >= 0 ){\n-                    if ( exp <= singleMaxSmallTen ){\n-                        \/*\n-                         * Can get the answer with one operation,\n-                         * thus one roundoff.\n-                         *\/\n-                        fValue *= singleSmall10pow[exp];\n-                        return (isNegative)? -fValue : fValue;\n-                    }\n-                    int slop = singleMaxDecimalDigits - kDigits;\n-                    if ( exp <= singleMaxSmallTen+slop ){\n-                        \/*\n-                         * We can multiply dValue by 10^(slop)\n-                         * and it is still \"small\" and exact.\n-                         * Then we can multiply by 10^(exp-slop)\n-                         * with one rounding.\n-                         *\/\n-                        fValue *= singleSmall10pow[slop];\n-                        fValue *= singleSmall10pow[exp-slop];\n-                        return (isNegative)? -fValue : fValue;\n-                    }\n-                    \/*\n-                     * Else we have a hard case with a positive exp.\n-                     *\/\n-                } else {\n-                    if ( exp >= -singleMaxSmallTen ){\n-                        \/*\n-                         * Can get the answer in one division.\n-                         *\/\n-                        fValue \/= singleSmall10pow[-exp];\n-                        return (isNegative)? -fValue : fValue;\n-                    }\n-                    \/*\n-                     * Else we have a hard case with a negative exp.\n-                     *\/\n-                }\n-            } else if ( (decExponent >= nDigits) && (nDigits+decExponent <= maxDecimalDigits) ){\n-                \/*\n-                 * In double-precision, this is an exact floating integer.\n-                 * So we can compute to double, then shorten to float\n-                 * with one round, and get the right answer.\n-                 *\n-                 * First, finish accumulating digits.\n-                 * Then convert that integer to a double, multiply\n-                 * by the appropriate power of ten, and convert to float.\n-                 *\/\n-                long lValue = (long)iValue;\n-                for ( int i=kDigits; i < nDigits; i++ ){\n-                    lValue = lValue*10L + (long)((int)digits[i]-(int)'0');\n-                }\n-                double dValue = (double)lValue;\n-                exp = decExponent-nDigits;\n-                dValue *= small10pow[exp];\n-                fValue = (float)dValue;\n-                return (isNegative)? -fValue : fValue;\n-\n-            }\n-            \/*\n-             * Harder cases:\n-             * The sum of digits plus exponent is greater than\n-             * what we think we can do with one error.\n-             *\n-             * Start by weeding out obviously out-of-range\n-             * results, then convert to double and go to\n-             * common hard-case code.\n-             *\/\n-            if ( decExponent > singleMaxDecimalExponent+1 ){\n-                \/*\n-                 * Lets face it. This is going to be\n-                 * Infinity. Cut to the chase.\n-                 *\/\n-                return (isNegative)? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n-            } else if ( decExponent < singleMinDecimalExponent-1 ){\n-                \/*\n-                 * Lets face it. This is going to be\n-                 * zero. Cut to the chase.\n-                 *\/\n-                return (isNegative)? -0.0f : 0.0f;\n-            }\n-\n-            \/*\n-             * Here, we do 'way too much work, but throwing away\n-             * our partial results, and going and doing the whole\n-             * thing as double, then throwing away half the bits that computes\n-             * when we convert back to float.\n-             *\n-             * The alternative is to reproduce the whole multiple-precision\n-             * algorithm for float precision, or to try to parameterize it\n-             * for common usage. The former will take about 400 lines of code,\n-             * and the latter I tried without success. Thus the semi-hack\n-             * answer here.\n-             *\/\n-            mustSetRoundDir = !fromHex;\n-            double dValue = doubleValue();\n-            return stickyRound( dValue );\n-        }\n-    }\n-\n-\n-    \/*\n-     * All the positive powers of 10 that can be\n-     * represented exactly in double\/float.\n-     *\/\n-    private static final double small10pow[] = {\n-        1.0e0,\n-        1.0e1, 1.0e2, 1.0e3, 1.0e4, 1.0e5,\n-        1.0e6, 1.0e7, 1.0e8, 1.0e9, 1.0e10,\n-        1.0e11, 1.0e12, 1.0e13, 1.0e14, 1.0e15,\n-        1.0e16, 1.0e17, 1.0e18, 1.0e19, 1.0e20,\n-        1.0e21, 1.0e22\n-    };\n-\n-    private static final float singleSmall10pow[] = {\n-        1.0e0f,\n-        1.0e1f, 1.0e2f, 1.0e3f, 1.0e4f, 1.0e5f,\n-        1.0e6f, 1.0e7f, 1.0e8f, 1.0e9f, 1.0e10f\n-    };\n-\n-    private static final double big10pow[] = {\n-        1e16, 1e32, 1e64, 1e128, 1e256 };\n-    private static final double tiny10pow[] = {\n-        1e-16, 1e-32, 1e-64, 1e-128, 1e-256 };\n-\n-    private static final int maxSmallTen = small10pow.length-1;\n-    private static final int singleMaxSmallTen = singleSmall10pow.length-1;\n-\n-    private static final int small5pow[] = {\n-        1,\n-        5,\n-        5*5,\n-        5*5*5,\n-        5*5*5*5,\n-        5*5*5*5*5,\n-        5*5*5*5*5*5,\n-        5*5*5*5*5*5*5,\n-        5*5*5*5*5*5*5*5,\n-        5*5*5*5*5*5*5*5*5,\n-        5*5*5*5*5*5*5*5*5*5,\n-        5*5*5*5*5*5*5*5*5*5*5,\n-        5*5*5*5*5*5*5*5*5*5*5*5,\n-        5*5*5*5*5*5*5*5*5*5*5*5*5\n-    };\n-\n-\n-    private static final long long5pow[] = {\n-        1L,\n-        5L,\n-        5L*5,\n-        5L*5*5,\n-        5L*5*5*5,\n-        5L*5*5*5*5,\n-        5L*5*5*5*5*5,\n-        5L*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-        5L*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5*5,\n-    };\n-\n-    \/\/ approximately ceil( log2( long5pow[i] ) )\n-    private static final int n5bits[] = {\n-        0,\n-        3,\n-        5,\n-        7,\n-        10,\n-        12,\n-        14,\n-        17,\n-        19,\n-        21,\n-        24,\n-        26,\n-        28,\n-        31,\n-        33,\n-        35,\n-        38,\n-        40,\n-        42,\n-        45,\n-        47,\n-        49,\n-        52,\n-        54,\n-        56,\n-        59,\n-        61,\n-    };\n-\n-    private static final char infinity[] = { 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y' };\n-    private static final char notANumber[] = { 'N', 'a', 'N' };\n-    private static final char zero[] = { '0', '0', '0', '0', '0', '0', '0', '0' };\n-\n-\n-    \/*\n-     * Grammar is compatible with hexadecimal floating-point constants\n-     * described in section 6.4.4.2 of the C99 specification.\n-     *\/\n-    private static Pattern hexFloatPattern = null;\n-    private static synchronized Pattern getHexFloatPattern() {\n-        if (hexFloatPattern == null) {\n-           hexFloatPattern = Pattern.compile(\n-                   \/\/1           234                   56                7                   8      9\n-                    \"([-+])?0[xX](((\\\\p{XDigit}+)\\\\.?)|((\\\\p{XDigit}*)\\\\.(\\\\p{XDigit}+)))[pP]([-+])?(\\\\p{Digit}+)[fFdD]?\"\n-                    );\n-        }\n-        return hexFloatPattern;\n-    }\n-\n-    \/*\n-     * Convert string s to a suitable floating decimal; uses the\n-     * double constructor and set the roundDir variable appropriately\n-     * in case the value is later converted to a float.\n-     *\/\n-   static OldFloatingDecimalForTest parseHexString(String s) {\n-        \/\/ Verify string is a member of the hexadecimal floating-point\n-        \/\/ string language.\n-        Matcher m = getHexFloatPattern().matcher(s);\n-        boolean validInput = m.matches();\n-\n-        if (!validInput) {\n-            \/\/ Input does not match pattern\n-            throw new NumberFormatException(\"For input string: \\\"\" + s + \"\\\"\");\n-        } else { \/\/ validInput\n-            \/*\n-             * We must isolate the sign, significand, and exponent\n-             * fields.  The sign value is straightforward.  Since\n-             * floating-point numbers are stored with a normalized\n-             * representation, the significand and exponent are\n-             * interrelated.\n-             *\n-             * After extracting the sign, we normalized the\n-             * significand as a hexadecimal value, calculating an\n-             * exponent adjust for any shifts made during\n-             * normalization.  If the significand is zero, the\n-             * exponent doesn't need to be examined since the output\n-             * will be zero.\n-             *\n-             * Next the exponent in the input string is extracted.\n-             * Afterwards, the significand is normalized as a *binary*\n-             * value and the input value's normalized exponent can be\n-             * computed.  The significand bits are copied into a\n-             * double significand; if the string has more logical bits\n-             * than can fit in a double, the extra bits affect the\n-             * round and sticky bits which are used to round the final\n-             * value.\n-             *\/\n-\n-            \/\/  Extract significand sign\n-            String group1 = m.group(1);\n-            double sign = (( group1 == null ) || group1.equals(\"+\"))? 1.0 : -1.0;\n-\n-\n-            \/\/  Extract Significand magnitude\n-            \/*\n-             * Based on the form of the significand, calculate how the\n-             * binary exponent needs to be adjusted to create a\n-             * normalized *hexadecimal* floating-point number; that\n-             * is, a number where there is one nonzero hex digit to\n-             * the left of the (hexa)decimal point.  Since we are\n-             * adjusting a binary, not hexadecimal exponent, the\n-             * exponent is adjusted by a multiple of 4.\n-             *\n-             * There are a number of significand scenarios to consider;\n-             * letters are used in indicate nonzero digits:\n-             *\n-             * 1. 000xxxx       =>      x.xxx   normalized\n-             *    increase exponent by (number of x's - 1)*4\n-             *\n-             * 2. 000xxx.yyyy =>        x.xxyyyy        normalized\n-             *    increase exponent by (number of x's - 1)*4\n-             *\n-             * 3. .000yyy  =>   y.yy    normalized\n-             *    decrease exponent by (number of zeros + 1)*4\n-             *\n-             * 4. 000.00000yyy => y.yy normalized\n-             *    decrease exponent by (number of zeros to right of point + 1)*4\n-             *\n-             * If the significand is exactly zero, return a properly\n-             * signed zero.\n-             *\/\n-\n-            String significandString =null;\n-            int signifLength = 0;\n-            int exponentAdjust = 0;\n-            {\n-                int leftDigits  = 0; \/\/ number of meaningful digits to\n-                                     \/\/ left of \"decimal\" point\n-                                     \/\/ (leading zeros stripped)\n-                int rightDigits = 0; \/\/ number of digits to right of\n-                                     \/\/ \"decimal\" point; leading zeros\n-                                     \/\/ must always be accounted for\n-                \/*\n-                 * The significand is made up of either\n-                 *\n-                 * 1. group 4 entirely (integer portion only)\n-                 *\n-                 * OR\n-                 *\n-                 * 2. the fractional portion from group 7 plus any\n-                 * (optional) integer portions from group 6.\n-                 *\/\n-                String group4;\n-                if( (group4 = m.group(4)) != null) {  \/\/ Integer-only significand\n-                    \/\/ Leading zeros never matter on the integer portion\n-                    significandString = stripLeadingZeros(group4);\n-                    leftDigits = significandString.length();\n-                }\n-                else {\n-                    \/\/ Group 6 is the optional integer; leading zeros\n-                    \/\/ never matter on the integer portion\n-                    String group6 = stripLeadingZeros(m.group(6));\n-                    leftDigits = group6.length();\n-\n-                    \/\/ fraction\n-                    String group7 = m.group(7);\n-                    rightDigits = group7.length();\n-\n-                    \/\/ Turn \"integer.fraction\" into \"integer\"+\"fraction\"\n-                    significandString =\n-                        ((group6 == null)?\"\":group6) + \/\/ is the null\n-                        \/\/ check necessary?\n-                        group7;\n-                }\n-\n-                significandString = stripLeadingZeros(significandString);\n-                signifLength  = significandString.length();\n-\n-                \/*\n-                 * Adjust exponent as described above\n-                 *\/\n-                if (leftDigits >= 1) {  \/\/ Cases 1 and 2\n-                    exponentAdjust = 4*(leftDigits - 1);\n-                } else {                \/\/ Cases 3 and 4\n-                    exponentAdjust = -4*( rightDigits - signifLength + 1);\n-                }\n-\n-                \/\/ If the significand is zero, the exponent doesn't\n-                \/\/ matter; return a properly signed zero.\n-\n-                if (signifLength == 0) { \/\/ Only zeros in input\n-                    return new OldFloatingDecimalForTest(sign * 0.0);\n-                }\n-            }\n-\n-            \/\/  Extract Exponent\n-            \/*\n-             * Use an int to read in the exponent value; this should\n-             * provide more than sufficient range for non-contrived\n-             * inputs.  If reading the exponent in as an int does\n-             * overflow, examine the sign of the exponent and\n-             * significand to determine what to do.\n-             *\/\n-            String group8 = m.group(8);\n-            boolean positiveExponent = ( group8 == null ) || group8.equals(\"+\");\n-            long unsignedRawExponent;\n-            try {\n-                unsignedRawExponent = Integer.parseInt(m.group(9));\n-            }\n-            catch (NumberFormatException e) {\n-                \/\/ At this point, we know the exponent is\n-                \/\/ syntactically well-formed as a sequence of\n-                \/\/ digits.  Therefore, if an NumberFormatException\n-                \/\/ is thrown, it must be due to overflowing int's\n-                \/\/ range.  Also, at this point, we have already\n-                \/\/ checked for a zero significand.  Thus the signs\n-                \/\/ of the exponent and significand determine the\n-                \/\/ final result:\n-                \/\/\n-                \/\/                      significand\n-                \/\/                      +               -\n-                \/\/ exponent     +       +infinity       -infinity\n-                \/\/              -       +0.0            -0.0\n-                return new OldFloatingDecimalForTest(sign * (positiveExponent ?\n-                                                   Double.POSITIVE_INFINITY : 0.0));\n-            }\n-\n-            long rawExponent =\n-                (positiveExponent ? 1L : -1L) * \/\/ exponent sign\n-                unsignedRawExponent;            \/\/ exponent magnitude\n-\n-            \/\/ Calculate partially adjusted exponent\n-            long exponent = rawExponent + exponentAdjust ;\n-\n-            \/\/ Starting copying non-zero bits into proper position in\n-            \/\/ a long; copy explicit bit too; this will be masked\n-            \/\/ later for normal values.\n-\n-            boolean round = false;\n-            boolean sticky = false;\n-            int bitsCopied=0;\n-            int nextShift=0;\n-            long significand=0L;\n-            \/\/ First iteration is different, since we only copy\n-            \/\/ from the leading significand bit; one more exponent\n-            \/\/ adjust will be needed...\n-\n-            \/\/ IMPORTANT: make leadingDigit a long to avoid\n-            \/\/ surprising shift semantics!\n-            long leadingDigit = getHexDigit(significandString, 0);\n-\n-            \/*\n-             * Left shift the leading digit (53 - (bit position of\n-             * leading 1 in digit)); this sets the top bit of the\n-             * significand to 1.  The nextShift value is adjusted\n-             * to take into account the number of bit positions of\n-             * the leadingDigit actually used.  Finally, the\n-             * exponent is adjusted to normalize the significand\n-             * as a binary value, not just a hex value.\n-             *\/\n-            if (leadingDigit == 1) {\n-                significand |= leadingDigit << 52;\n-                nextShift = 52 - 4;\n-                \/* exponent += 0 *\/     }\n-            else if (leadingDigit <= 3) { \/\/ [2, 3]\n-                significand |= leadingDigit << 51;\n-                nextShift = 52 - 5;\n-                exponent += 1;\n-            }\n-            else if (leadingDigit <= 7) { \/\/ [4, 7]\n-                significand |= leadingDigit << 50;\n-                nextShift = 52 - 6;\n-                exponent += 2;\n-            }\n-            else if (leadingDigit <= 15) { \/\/ [8, f]\n-                significand |= leadingDigit << 49;\n-                nextShift = 52 - 7;\n-                exponent += 3;\n-            } else {\n-                throw new AssertionError(\"Result from digit conversion too large!\");\n-            }\n-            \/\/ The preceding if-else could be replaced by a single\n-            \/\/ code block based on the high-order bit set in\n-            \/\/ leadingDigit.  Given leadingOnePosition,\n-\n-            \/\/ significand |= leadingDigit << (SIGNIFICAND_WIDTH - leadingOnePosition);\n-            \/\/ nextShift = 52 - (3 + leadingOnePosition);\n-            \/\/ exponent += (leadingOnePosition-1);\n-\n-\n-            \/*\n-             * Now the exponent variable is equal to the normalized\n-             * binary exponent.  Code below will make representation\n-             * adjustments if the exponent is incremented after\n-             * rounding (includes overflows to infinity) or if the\n-             * result is subnormal.\n-             *\/\n-\n-            \/\/ Copy digit into significand until the significand can't\n-            \/\/ hold another full hex digit or there are no more input\n-            \/\/ hex digits.\n-            int i = 0;\n-            for(i = 1;\n-                i < signifLength && nextShift >= 0;\n-                i++) {\n-                long currentDigit = getHexDigit(significandString, i);\n-                significand |= (currentDigit << nextShift);\n-                nextShift-=4;\n-            }\n-\n-            \/\/ After the above loop, the bulk of the string is copied.\n-            \/\/ Now, we must copy any partial hex digits into the\n-            \/\/ significand AND compute the round bit and start computing\n-            \/\/ sticky bit.\n-\n-            if ( i < signifLength ) { \/\/ at least one hex input digit exists\n-                long currentDigit = getHexDigit(significandString, i);\n-\n-                \/\/ from nextShift, figure out how many bits need\n-                \/\/ to be copied, if any\n-                switch(nextShift) { \/\/ must be negative\n-                case -1:\n-                    \/\/ three bits need to be copied in; can\n-                    \/\/ set round bit\n-                    significand |= ((currentDigit & 0xEL) >> 1);\n-                    round = (currentDigit & 0x1L)  != 0L;\n-                    break;\n-\n-                case -2:\n-                    \/\/ two bits need to be copied in; can\n-                    \/\/ set round and start sticky\n-                    significand |= ((currentDigit & 0xCL) >> 2);\n-                    round = (currentDigit &0x2L)  != 0L;\n-                    sticky = (currentDigit & 0x1L) != 0;\n-                    break;\n-\n-                case -3:\n-                    \/\/ one bit needs to be copied in\n-                    significand |= ((currentDigit & 0x8L)>>3);\n-                    \/\/ Now set round and start sticky, if possible\n-                    round = (currentDigit &0x4L)  != 0L;\n-                    sticky = (currentDigit & 0x3L) != 0;\n-                    break;\n-\n-                case -4:\n-                    \/\/ all bits copied into significand; set\n-                    \/\/ round and start sticky\n-                    round = ((currentDigit & 0x8L) != 0);  \/\/ is top bit set?\n-                    \/\/ nonzeros in three low order bits?\n-                    sticky = (currentDigit & 0x7L) != 0;\n-                    break;\n-\n-                default:\n-                    throw new AssertionError(\"Unexpected shift distance remainder.\");\n-                    \/\/ break;\n-                }\n-\n-                \/\/ Round is set; sticky might be set.\n-\n-                \/\/ For the sticky bit, it suffices to check the\n-                \/\/ current digit and test for any nonzero digits in\n-                \/\/ the remaining unprocessed input.\n-                i++;\n-                while(i < signifLength && !sticky) {\n-                    currentDigit =  getHexDigit(significandString,i);\n-                    sticky = sticky || (currentDigit != 0);\n-                    i++;\n-                }\n-\n-            }\n-            \/\/ else all of string was seen, round and sticky are\n-            \/\/ correct as false.\n-\n-\n-            \/\/ Check for overflow and update exponent accordingly.\n-\n-            if (exponent > Double.MAX_EXPONENT) {         \/\/ Infinite result\n-                \/\/ overflow to properly signed infinity\n-                return new OldFloatingDecimalForTest(sign * Double.POSITIVE_INFINITY);\n-            } else {  \/\/ Finite return value\n-                if (exponent <= Double.MAX_EXPONENT && \/\/ (Usually) normal result\n-                    exponent >= Double.MIN_EXPONENT) {\n-\n-                    \/\/ The result returned in this block cannot be a\n-                    \/\/ zero or subnormal; however after the\n-                    \/\/ significand is adjusted from rounding, we could\n-                    \/\/ still overflow in infinity.\n-\n-                    \/\/ AND exponent bits into significand; if the\n-                    \/\/ significand is incremented and overflows from\n-                    \/\/ rounding, this combination will update the\n-                    \/\/ exponent correctly, even in the case of\n-                    \/\/ Double.MAX_VALUE overflowing to infinity.\n-\n-                    significand = (( (exponent +\n-                                     (long)DoubleConsts.EXP_BIAS) <<\n-                                     (DoubleConsts.SIGNIFICAND_WIDTH-1))\n-                                   & DoubleConsts.EXP_BIT_MASK) |\n-                        (DoubleConsts.SIGNIF_BIT_MASK & significand);\n-\n-                }  else  {  \/\/ Subnormal or zero\n-                    \/\/ (exponent < Double.MIN_EXPONENT)\n-\n-                    if (exponent < (DoubleConsts.MIN_SUB_EXPONENT -1 )) {\n-                        \/\/ No way to round back to nonzero value\n-                        \/\/ regardless of significand if the exponent is\n-                        \/\/ less than -1075.\n-                        return new OldFloatingDecimalForTest(sign * 0.0);\n-                    } else { \/\/  -1075 <= exponent <= MIN_EXPONENT -1 = -1023\n-                        \/*\n-                         * Find bit position to round to; recompute\n-                         * round and sticky bits, and shift\n-                         * significand right appropriately.\n-                         *\/\n-\n-                        sticky = sticky || round;\n-                        round = false;\n-\n-                        \/\/ Number of bits of significand to preserve is\n-                        \/\/ exponent - abs_min_exp +1\n-                        \/\/ check:\n-                        \/\/ -1075 +1074 + 1 = 0\n-                        \/\/ -1023 +1074 + 1 = 52\n-\n-                        int bitsDiscarded = 53 -\n-                            ((int)exponent - DoubleConsts.MIN_SUB_EXPONENT + 1);\n-                        assert bitsDiscarded >= 1 && bitsDiscarded <= 53;\n-\n-                        \/\/ What to do here:\n-                        \/\/ First, isolate the new round bit\n-                        round = (significand & (1L << (bitsDiscarded -1))) != 0L;\n-                        if (bitsDiscarded > 1) {\n-                            \/\/ create mask to update sticky bits; low\n-                            \/\/ order bitsDiscarded bits should be 1\n-                            long mask = ~((~0L) << (bitsDiscarded -1));\n-                            sticky = sticky || ((significand & mask) != 0L ) ;\n-                        }\n-\n-                        \/\/ Now, discard the bits\n-                        significand = significand >> bitsDiscarded;\n-\n-                        significand = (( ((long)(Double.MIN_EXPONENT -1) + \/\/ subnorm exp.\n-                                          (long)DoubleConsts.EXP_BIAS) <<\n-                                         (DoubleConsts.SIGNIFICAND_WIDTH-1))\n-                                       & DoubleConsts.EXP_BIT_MASK) |\n-                            (DoubleConsts.SIGNIF_BIT_MASK & significand);\n-                    }\n-                }\n-\n-                \/\/ The significand variable now contains the currently\n-                \/\/ appropriate exponent bits too.\n-\n-                \/*\n-                 * Determine if significand should be incremented;\n-                 * making this determination depends on the least\n-                 * significant bit and the round and sticky bits.\n-                 *\n-                 * Round to nearest even rounding table, adapted from\n-                 * table 4.7 in \"Computer Arithmetic\" by IsraelKoren.\n-                 * The digit to the left of the \"decimal\" point is the\n-                 * least significant bit, the digits to the right of\n-                 * the point are the round and sticky bits\n-                 *\n-                 * Number       Round(x)\n-                 * x0.00        x0.\n-                 * x0.01        x0.\n-                 * x0.10        x0.\n-                 * x0.11        x1. = x0. +1\n-                 * x1.00        x1.\n-                 * x1.01        x1.\n-                 * x1.10        x1. + 1\n-                 * x1.11        x1. + 1\n-                 *\/\n-                boolean incremented = false;\n-                boolean leastZero  = ((significand & 1L) == 0L);\n-                if( (  leastZero  && round && sticky ) ||\n-                    ((!leastZero) && round )) {\n-                    incremented = true;\n-                    significand++;\n-                }\n-\n-                OldFloatingDecimalForTest fd = new OldFloatingDecimalForTest(Math.copySign(\n-                                                              Double.longBitsToDouble(significand),\n-                                                              sign));\n-\n-                \/*\n-                 * Set roundingDir variable field of fd properly so\n-                 * that the input string can be properly rounded to a\n-                 * float value.  There are two cases to consider:\n-                 *\n-                 * 1. rounding to double discards sticky bit\n-                 * information that would change the result of a float\n-                 * rounding (near halfway case between two floats)\n-                 *\n-                 * 2. rounding to double rounds up when rounding up\n-                 * would not occur when rounding to float.\n-                 *\n-                 * For former case only needs to be considered when\n-                 * the bits rounded away when casting to float are all\n-                 * zero; otherwise, float round bit is properly set\n-                 * and sticky will already be true.\n-                 *\n-                 * The lower exponent bound for the code below is the\n-                 * minimum (normalized) subnormal exponent - 1 since a\n-                 * value with that exponent can round up to the\n-                 * minimum subnormal value and the sticky bit\n-                 * information must be preserved (i.e. case 1).\n-                 *\/\n-                if ((exponent >= FloatConsts.MIN_SUB_EXPONENT-1) &&\n-                    (exponent <= Float.MAX_EXPONENT ) ){\n-                    \/\/ Outside above exponent range, the float value\n-                    \/\/ will be zero or infinity.\n-\n-                    \/*\n-                     * If the low-order 28 bits of a rounded double\n-                     * significand are 0, the double could be a\n-                     * half-way case for a rounding to float.  If the\n-                     * double value is a half-way case, the double\n-                     * significand may have to be modified to round\n-                     * the right float value (see the stickyRound\n-                     * method).  If the rounding to double has lost\n-                     * what would be float sticky bit information, the\n-                     * double significand must be incremented.  If the\n-                     * double value's significand was itself\n-                     * incremented, the float value may end up too\n-                     * large so the increment should be undone.\n-                     *\/\n-                    if ((significand & 0xfffffffL) ==  0x0L) {\n-                        \/\/ For negative values, the sign of the\n-                        \/\/ roundDir is the same as for positive values\n-                        \/\/ since adding 1 increasing the significand's\n-                        \/\/ magnitude and subtracting 1 decreases the\n-                        \/\/ significand's magnitude.  If neither round\n-                        \/\/ nor sticky is true, the double value is\n-                        \/\/ exact and no adjustment is required for a\n-                        \/\/ proper float rounding.\n-                        if( round || sticky) {\n-                            if (leastZero) { \/\/ prerounding lsb is 0\n-                                \/\/ If round and sticky were both true,\n-                                \/\/ and the least significant\n-                                \/\/ significand bit were 0, the rounded\n-                                \/\/ significand would not have its\n-                                \/\/ low-order bits be zero.  Therefore,\n-                                \/\/ we only need to adjust the\n-                                \/\/ significand if round XOR sticky is\n-                                \/\/ true.\n-                                if (round ^ sticky) {\n-                                    fd.roundDir =  1;\n-                                }\n-                            }\n-                            else { \/\/ prerounding lsb is 1\n-                                \/\/ If the prerounding lsb is 1 and the\n-                                \/\/ resulting significand has its\n-                                \/\/ low-order bits zero, the significand\n-                                \/\/ was incremented.  Here, we undo the\n-                                \/\/ increment, which will ensure the\n-                                \/\/ right guard and sticky bits for the\n-                                \/\/ float rounding.\n-                                if (round)\n-                                    fd.roundDir =  -1;\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                fd.fromHex = true;\n-                return fd;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Return <code>s<\/code> with any leading zeros removed.\n-     *\/\n-    static String stripLeadingZeros(String s) {\n-        return  s.replaceFirst(\"^0+\", \"\");\n-    }\n-\n-    \/**\n-     * Extract a hexadecimal digit from position <code>position<\/code>\n-     * of string <code>s<\/code>.\n-     *\/\n-    static int getHexDigit(String s, int position) {\n-        int value = Character.digit(s.charAt(position), 16);\n-        if (value <= -1 || value >= 16) {\n-            throw new AssertionError(\"Unexpected failure of digit conversion of \" +\n-                                     s.charAt(position));\n-        }\n-        return value;\n-    }\n-\n-\n-}\n","filename":"test\/jdk\/jdk\/internal\/math\/FloatingDecimal\/OldFloatingDecimalForTest.java","additions":0,"deletions":2434,"binary":false,"changes":2434,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.math.BigDecimal;\n@@ -33,30 +34,0 @@\n-\/*\n-OldFloatingDecimalForTest\n-\n-public class OldFloatingDecimalForTest {\n-  public boolean digitsRoundedUp();\n-  public OldFloatingDecimalForTest(double);\n-  public OldFloatingDecimalForTest(float);\n-  public boolean decimalDigitsExact();\n-  public java.lang.String toString();\n-  public java.lang.String toJavaFormatString();\n-  public void appendTo(java.lang.Appendable);\n-  public static OldFloatingDecimalForTest readJavaFormatString(java.lang.String) throws java.lang.NumberFormatException;\n-  public strictfp double doubleValue();\n-  public strictfp float floatValue();\n-}\n-\n-jdk.internal.math.FloatingDecimal\n-\n-public class jdk.internal.math.FloatingDecimal {\n-  public jdk.internal.math.FloatingDecimal();\n-  public static java.lang.String toJavaFormatString(double);\n-  public static java.lang.String toJavaFormatString(float);\n-  public static void appendTo(double, java.lang.Appendable);\n-  public static void appendTo(float, java.lang.Appendable);\n-  public static double parseDouble(java.lang.String) throws java.lang.NumberFormatException;\n-  public static float parseFloat(java.lang.String) throws java.lang.NumberFormatException;\n-  public static jdk.internal.math.FloatingDecimal$AbstractD2ABuffer getD2ABuffer(double);\n-}\n-*\/\n-\n@@ -65,2 +36,2 @@\n- * @bug 7032154\n- * @summary unit tests of FloatingDecimal (use -Dseed=X to set PRANDOM seed)\n+ * @bug 7032154 8343453\n+ * @summary FloatingDecimal parsing methods (use -Dseed=X to set PRANDOM seed)\n@@ -68,1 +39,0 @@\n- * @library ..\n@@ -70,1 +40,0 @@\n- * @library \/java\/lang\/Math\n@@ -72,1 +41,0 @@\n- * @build DoubleConsts FloatConsts\n@@ -82,35 +50,4 @@\n-    private static int check(String test, Object expected, Object actual) {\n-        int failures = 0;\n-        if(!actual.equals(expected)) {\n-            failures++;\n-            System.err.println(\"Test \" + test +\n-                               \" expected \" + expected +\n-                               \" but obtained \" + actual);\n-        }\n-        return failures;\n-    }\n-\n-    @Test\n-    public void testAppendToDouble() {\n-        int failures = 0;\n-\n-        for(int i = 0; i < NUM_RANDOM_TESTS; i++) {\n-            double[] d = new double[] {\n-                RANDOM.nextLong(),\n-                RANDOM.nextGaussian(),\n-                RANDOM.nextDouble()*Double.MAX_VALUE\n-            };\n-            for(int j = 0; j < d.length; j++) {\n-                OldFloatingDecimalForTest ofd = new OldFloatingDecimalForTest(d[j]);\n-                StringBuilder sb = new StringBuilder();\n-                ofd.appendTo(sb);\n-                String oldString = sb.toString();\n-                sb = new StringBuilder();\n-                FloatingDecimal.appendTo(d[j], sb);\n-                String newString = sb.toString();\n-                failures += check(\"testAppendToDouble\", oldString, newString);\n-            }\n-        }\n-\n-        assertEquals(0, failures);\n-    }\n+    \/*\n+     * The tests rely on the different conversion implementations\n+     * in FloatDecimal and BigDecimal.\n+     *\/\n@@ -119,8 +56,6 @@\n-    public void testAppendToFloat() {\n-        int failures = 0;\n-\n-        for(int i = 0; i < NUM_RANDOM_TESTS; i++) {\n-            float[] f = new float[] {\n-                RANDOM.nextLong(),\n-                (float)RANDOM.nextGaussian(),\n-                RANDOM.nextFloat()*Float.MAX_VALUE\n+    public void testParseDouble() {\n+        for (int i = 0; i < NUM_RANDOM_TESTS; i++) {\n+            double[] d = {\n+                    RANDOM.nextLong(),\n+                    RANDOM.nextGaussian(),\n+                    RANDOM.nextDouble() * Double.MAX_VALUE,\n@@ -128,11 +63,3 @@\n-            for(int j = 0; j < f.length; j++) {\n-                OldFloatingDecimalForTest ofd = new OldFloatingDecimalForTest(f[j]);\n-                StringBuilder sb = new StringBuilder();\n-                ofd.appendTo(sb);\n-                String oldString = sb.toString();\n-                sb = new StringBuilder();\n-                FloatingDecimal.appendTo(f[j], sb);\n-                String newString = sb.toString();\n-                failures += check(\"testAppendToFloat\", oldString, newString);\n-            }\n-        }\n+            for (double v : d) {\n+                String dec = Double.toString(v);\n+                assertEquals(new BigDecimal(dec).doubleValue(), FloatingDecimal.parseDouble(dec));\n@@ -140,6 +67,3 @@\n-        assertEquals(0, failures);\n-    }\n-\n-    @Test\n-    public void testParseDouble() {\n-        int failures = 0;\n+                BigDecimal bd = new BigDecimal(v);\n+                String full = bd.toString();\n+                assertEquals(bd.doubleValue(), FloatingDecimal.parseDouble(full));\n@@ -147,13 +71,2 @@\n-        for(int i = 0; i < NUM_RANDOM_TESTS; i++) {\n-            double[] d = new double[] {\n-                RANDOM.nextLong(),\n-                RANDOM.nextGaussian(),\n-                RANDOM.nextDouble()*Double.MAX_VALUE\n-            };\n-            for(int j = 0; j < d.length; j++) {\n-                OldFloatingDecimalForTest ofd = new OldFloatingDecimalForTest(d[j]);\n-                String javaFormatString = ofd.toJavaFormatString();\n-                ofd = OldFloatingDecimalForTest.readJavaFormatString(javaFormatString);\n-                double oldDouble = ofd.doubleValue();\n-                double newDouble = FloatingDecimal.parseDouble(javaFormatString);\n-                failures += check(\"testParseDouble\", oldDouble, newDouble);\n+                String hex = Double.toHexString(v);\n+                assertEquals(FloatingDecimal.parseDouble(dec), FloatingDecimal.parseDouble(hex));\n@@ -162,2 +75,0 @@\n-\n-        assertEquals(0, failures);\n@@ -168,7 +79,5 @@\n-        int failures = 0;\n-\n-        for(int i = 0; i < NUM_RANDOM_TESTS; i++) {\n-            float[] f = new float[] {\n-                RANDOM.nextInt(),\n-                (float)RANDOM.nextGaussian(),\n-                RANDOM.nextFloat()*Float.MAX_VALUE\n+        for (int i = 0; i < NUM_RANDOM_TESTS; i++) {\n+            float[] f = {\n+                    RANDOM.nextLong(),\n+                    (float) RANDOM.nextGaussian(),\n+                    RANDOM.nextFloat() * Float.MAX_VALUE\n@@ -176,22 +85,3 @@\n-            for(int j = 0; j < f.length; j++) {\n-                OldFloatingDecimalForTest ofd = new OldFloatingDecimalForTest(f[j]);\n-                String javaFormatString = ofd.toJavaFormatString();\n-                ofd = OldFloatingDecimalForTest.readJavaFormatString(javaFormatString);\n-                float oldFloat = ofd.floatValue();\n-                float newFloat = FloatingDecimal.parseFloat(javaFormatString);\n-                failures += check(\"testParseFloat\", oldFloat, newFloat);\n-            }\n-        }\n-\n-        assertEquals(0, failures);\n-    }\n-\n-    @Test\n-    public void testToJavaFormatStringDoubleFixed() {\n-        int failures = 0;\n-\n-        double[] d = new double [] {\n-            -5.9522650387500933e18, \/\/ dtoa() fast path\n-            0.872989018674569,      \/\/ dtoa() fast iterative - long\n-            1.1317400099603851e308  \/\/ dtoa() slow iterative\n-        };\n+            for (float v : f) {\n+                String dec = Float.toString(v);\n+                assertEquals(new BigDecimal(dec).floatValue(), FloatingDecimal.parseFloat(dec));\n@@ -199,7 +89,3 @@\n-        for(int i = 0; i < d.length; i++) {\n-            OldFloatingDecimalForTest ofd = new OldFloatingDecimalForTest(d[i]);\n-            failures += check(\"testToJavaFormatStringDoubleFixed\", ofd.toJavaFormatString(), FloatingDecimal.toJavaFormatString(d[i]));\n-        }\n-\n-        assertEquals(0, failures);\n-    }\n+                BigDecimal bd = new BigDecimal(v);\n+                String full = bd.toString();\n+                assertEquals(bd.floatValue(), FloatingDecimal.parseFloat(full));\n@@ -207,13 +93,2 @@\n-    @Test\n-    public void testToJavaFormatStringDoubleRandom() {\n-        int failures = 0;\n-\n-        for(int i = 0; i < NUM_RANDOM_TESTS; i++) {\n-            double[] d = new double[] {\n-                RANDOM.nextLong(),\n-                RANDOM.nextGaussian(),\n-                RANDOM.nextDouble()*Double.MAX_VALUE\n-            };\n-            for(int j = 0; j < d.length; j++) {\n-                OldFloatingDecimalForTest ofd = new OldFloatingDecimalForTest(d[j]);\n-                failures += check(\"testToJavaFormatStringDoubleRandom\", ofd.toJavaFormatString(), FloatingDecimal.toJavaFormatString(d[j]));\n+                String hex = Float.toHexString(v);\n+                assertEquals(FloatingDecimal.parseFloat(dec), FloatingDecimal.parseFloat(hex));\n@@ -222,20 +97,0 @@\n-\n-        assertEquals(0, failures);\n-    }\n-\n-    @Test\n-    public void testToJavaFormatStringFloatFixed() {\n-        int failures = 0;\n-\n-        float[] f = new float[] {\n-            -9.8784166e8f, \/\/ dtoa() fast path\n-            0.70443946f,   \/\/ dtoa() fast iterative - int\n-            1.8254228e37f  \/\/ dtoa() slow iterative\n-        };\n-\n-        for(int i = 0; i < f.length; i++) {\n-            OldFloatingDecimalForTest ofd = new OldFloatingDecimalForTest(f[i]);\n-            failures += check(\"testToJavaFormatStringFloatFixed\", ofd.toJavaFormatString(), FloatingDecimal.toJavaFormatString(f[i]));\n-        }\n-\n-        assertEquals(0, failures);\n@@ -244,18 +99,0 @@\n-    @Test\n-    public void testToJavaFormatStringFloatRandom() {\n-        int failures = 0;\n-\n-        for(int i = 0; i < NUM_RANDOM_TESTS; i++) {\n-            float[] f = new float[] {\n-                RANDOM.nextInt(),\n-                (float)RANDOM.nextGaussian(),\n-                RANDOM.nextFloat()*Float.MAX_VALUE\n-            };\n-            for(int j = 0; j < f.length; j++) {\n-                OldFloatingDecimalForTest ofd = new OldFloatingDecimalForTest(f[j]);\n-                failures += check(\"testToJavaFormatStringFloatRandom\", ofd.toJavaFormatString(), FloatingDecimal.toJavaFormatString(f[j]));\n-            }\n-        }\n-\n-        assertEquals(0, failures);\n-    }\n","filename":"test\/jdk\/jdk\/internal\/math\/FloatingDecimal\/TestFloatingDecimal.java","additions":35,"deletions":198,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.math\n- *\/\n-\n-import jdk.internal.math.FloatingDecimal;\n-\n-public class ToString {\n-    private static int fail = 0;\n-\n-    private static Throwable first;\n-\n-    public static void main(String argv[]) {\n-        test(\"10.0\");\n-        test(\"1.0\");\n-        test(\"0.1\");\n-        test(\"0.01\");\n-        test(\"0.001\");\n-        test(\"1.0E-4\");\n-        if (fail != 0)\n-            throw new RuntimeException(fail + \" failure(s), first\", first);\n-    }\n-\n-    private static void test(String exp) {\n-        float c = Float.parseFloat(exp);\n-        String got = FloatingDecimal.toJavaFormatString(c);\n-        if (!got.equals(exp))\n-            fail(\"float '\" + \"': Expected '\" + exp + \"', got '\" + got + \"'\");\n-\n-        double d = Double.parseDouble(exp);\n-        got = FloatingDecimal.toJavaFormatString(d);\n-        if (!got.equals(exp))\n-            fail(\"double '\" + \"': Expected '\" + exp + \"', got '\" + got + \"'\");\n-    }\n-\n-    private static void fail(String s) {\n-        if (first == null)\n-            setFirst(s);\n-        System.err.println(\"FAILED: \" + s);\n-        fail++;\n-    }\n-\n-    private static void setFirst(String s) {\n-        try {\n-            throw new RuntimeException(s);\n-        } catch (RuntimeException x) {\n-            first = x;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/math\/ToString.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"}]}