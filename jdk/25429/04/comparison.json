{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import java.io.BufferedOutputStream;\n+import java.io.BufferedWriter;\n@@ -31,1 +31,3 @@\n-import java.io.PrintStream;\n+import java.io.OutputStreamWriter;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n@@ -39,1 +41,3 @@\n-import java.util.ArrayList;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n@@ -42,0 +46,1 @@\n+import java.util.Objects;\n@@ -46,2 +51,3 @@\n- * This class defines methods to dump threads to an output stream or file in plain\n- * text or JSON format.\n+ * This class defines static methods to support the Thread.dump_to_file diagnostic command\n+ * and the HotSpotDiagnosticMXBean.dumpThreads API. It defines methods to generate a\n+ * thread dump to a file or byte array in plain text or JSON format.\n@@ -56,2 +62,1 @@\n-     * Generate a thread dump in plain text format to a byte array or file, UTF-8 encoded.\n-     *\n+     * Generate a thread dump in plain text format to a file or byte array, UTF-8 encoded.\n@@ -62,1 +67,1 @@\n-     * @return the UTF-8 encoded thread dump or message to return to the user\n+     * @return the UTF-8 encoded thread dump or message to return to the tool user\n@@ -73,2 +78,1 @@\n-     * Generate a thread dump in JSON format to a byte array or file, UTF-8 encoded.\n-     *\n+     * Generate a thread dump in JSON format to a file or byte array, UTF-8 encoded.\n@@ -79,1 +83,1 @@\n-     * @return the UTF-8 encoded thread dump or message to return to the user\n+     * @return the UTF-8 encoded thread dump or message to return to the tool user\n@@ -91,0 +95,3 @@\n+     * This method is the implementation of the Thread.dump_to_file diagnostic command\n+     * when a file path is not specified. It returns the thread dump and\/or message to\n+     * send to the tool user.\n@@ -93,2 +100,2 @@\n-        try (var out = new BoundedByteArrayOutputStream(maxSize);\n-             PrintStream ps = new PrintStream(out, true, StandardCharsets.UTF_8)) {\n+        var out = new BoundedByteArrayOutputStream(maxSize);\n+        try (out; var writer = new TextWriter(out)) {\n@@ -96,1 +103,1 @@\n-                dumpThreadsToJson(ps);\n+                dumpThreadsToJson(writer);\n@@ -98,1 +105,1 @@\n-                dumpThreads(ps);\n+                dumpThreads(writer);\n@@ -100,1 +107,6 @@\n-            return out.toByteArray();\n+        } catch (Exception ex) {\n+            if (ex instanceof UncheckedIOException ioe) {\n+                ex = ioe.getCause();\n+            }\n+            String reply = String.format(\"Failed: %s%n\", ex);\n+            return reply.getBytes(StandardCharsets.UTF_8);\n@@ -102,0 +114,1 @@\n+        return out.toByteArray();\n@@ -106,0 +119,2 @@\n+     * This method is the implementation of the Thread.dump_to_file diagnostic command.\n+     * It returns the thread dump and\/or message to send to the tool user.\n@@ -113,7 +128,10 @@\n-        try (OutputStream out = Files.newOutputStream(path, options);\n-             BufferedOutputStream bos = new BufferedOutputStream(out);\n-             PrintStream ps = new PrintStream(bos, false, StandardCharsets.UTF_8)) {\n-            if (json) {\n-                dumpThreadsToJson(ps);\n-            } else {\n-                dumpThreads(ps);\n+        try (OutputStream out = Files.newOutputStream(path, options)) {\n+            try (var writer = new TextWriter(out)) {\n+                if (json) {\n+                    dumpThreadsToJson(writer);\n+                } else {\n+                    dumpThreads(writer);\n+                }\n+                reply = String.format(\"Created %s%n\", path);\n+            } catch (UncheckedIOException e) {\n+                reply = String.format(\"Failed: %s%n\", e.getCause());\n@@ -121,2 +139,1 @@\n-            reply = String.format(\"Created %s%n\", path);\n-        } catch (FileAlreadyExistsException e) {\n+        } catch (FileAlreadyExistsException _) {\n@@ -124,2 +141,2 @@\n-        } catch (IOException ioe) {\n-            reply = String.format(\"Failed: %s%n\", ioe);\n+        } catch (Exception ex) {\n+            reply = String.format(\"Failed: %s%n\", ex);\n@@ -131,4 +148,3 @@\n-     * Generate a thread dump in plain text format to the given output stream,\n-     * UTF-8 encoded.\n-     *\n-     * This method is invoked by HotSpotDiagnosticMXBean.dumpThreads.\n+     * Generate a thread dump in plain text format to the given output stream, UTF-8\n+     * encoded. This method is invoked by HotSpotDiagnosticMXBean.dumpThreads.\n+     * @throws IOException if an I\/O error occurs\n@@ -136,3 +152,2 @@\n-    public static void dumpThreads(OutputStream out) {\n-        BufferedOutputStream bos = new BufferedOutputStream(out);\n-        PrintStream ps = new PrintStream(bos, false, StandardCharsets.UTF_8);\n+    public static void dumpThreads(OutputStream out) throws IOException {\n+        var writer = new TextWriter(out);\n@@ -140,3 +155,5 @@\n-            dumpThreads(ps);\n-        } finally {\n-            ps.flush();  \/\/ flushes underlying stream\n+            dumpThreads(writer);\n+            writer.flush();\n+        } catch (UncheckedIOException e) {\n+            IOException ioe = e.getCause();\n+            throw ioe;\n@@ -147,1 +164,2 @@\n-     * Generate a thread dump in plain text format to the given print stream.\n+     * Generate a thread dump in plain text format to the given text stream.\n+     * @throws UncheckedIOException if an I\/O error occurs\n@@ -149,6 +167,6 @@\n-    private static void dumpThreads(PrintStream ps) {\n-        ps.println(processId());\n-        ps.println(Instant.now());\n-        ps.println(Runtime.version());\n-        ps.println();\n-        dumpThreads(ThreadContainers.root(), ps);\n+    private static void dumpThreads(TextWriter writer) {\n+        writer.println(processId());\n+        writer.println(Instant.now());\n+        writer.println(Runtime.version());\n+        writer.println();\n+        dumpThreads(ThreadContainers.root(), writer);\n@@ -157,3 +175,3 @@\n-    private static void dumpThreads(ThreadContainer container, PrintStream ps) {\n-        container.threads().forEach(t -> dumpThread(t, ps));\n-        container.children().forEach(c -> dumpThreads(c, ps));\n+    private static void dumpThreads(ThreadContainer container, TextWriter writer) {\n+        container.threads().forEach(t -> dumpThread(t, writer));\n+        container.children().forEach(c -> dumpThreads(c, writer));\n@@ -162,6 +180,38 @@\n-    private static void dumpThread(Thread thread, PrintStream ps) {\n-        String suffix = thread.isVirtual() ? \" virtual\" : \"\";\n-        ps.println(\"#\" + thread.threadId() + \" \\\"\" + thread.getName() + \"\\\"\" + suffix);\n-        for (StackTraceElement ste : thread.getStackTrace()) {\n-            ps.print(\"      \");\n-            ps.println(ste);\n+    private static void dumpThread(Thread thread, TextWriter writer) {\n+        ThreadSnapshot snapshot = ThreadSnapshot.of(thread);\n+        Instant now = Instant.now();\n+        Thread.State state = snapshot.threadState();\n+        writer.println(\"#\" + thread.threadId() + \" \\\"\" + snapshot.threadName()\n+                + \"\\\" \" + (thread.isVirtual() ? \"virtual \" : \"\") + state + \" \" + now);\n+\n+        StackTraceElement[] stackTrace = snapshot.stackTrace();\n+        int depth = 0;\n+        while (depth < stackTrace.length) {\n+            writer.print(\"    at \");\n+            writer.println(stackTrace[depth]);\n+            snapshot.ownedMonitorsAt(depth).forEach(o -> {\n+                if (o != null) {\n+                    writer.println(\"    - locked \" + decorateObject(o));\n+                } else {\n+                    writer.println(\"    - lock is eliminated\");\n+                }\n+            });\n+\n+            \/\/ if parkBlocker set, or blocked\/waiting on monitor, then print after top frame\n+            if (depth == 0) {\n+                \/\/ park blocker\n+                Object parkBlocker = snapshot.parkBlocker();\n+                if (parkBlocker != null) {\n+                    writer.println(\"    - parking to wait for \" + decorateObject(parkBlocker));\n+                }\n+\n+                \/\/ blocked on monitor enter or Object.wait\n+                if (state == Thread.State.BLOCKED && snapshot.blockedOn() instanceof Object obj) {\n+                    writer.println(\"    - waiting to lock \" + decorateObject(obj));\n+                } else if ((state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING)\n+                        && snapshot.waitingOn() instanceof Object obj) {\n+                    writer.println(\"    - waiting on \" + decorateObject(obj));\n+                }\n+            }\n+\n+            depth++;\n@@ -169,1 +219,9 @@\n-        ps.println();\n+        writer.println();\n+    }\n+\n+    \/**\n+     * Returns the identity string for the given object in a form suitable for the plain\n+     * text format thread dump.\n+     *\/\n+    private static String decorateObject(Object obj) {\n+        return \"<\" + Objects.toIdentityString(obj) + \">\";\n@@ -174,1 +232,0 @@\n-     *\n@@ -176,0 +233,1 @@\n+     * @throws IOException if an I\/O error occurs\n@@ -177,3 +235,2 @@\n-    public static void dumpThreadsToJson(OutputStream out) {\n-        BufferedOutputStream bos = new BufferedOutputStream(out);\n-        PrintStream ps = new PrintStream(bos, false, StandardCharsets.UTF_8);\n+    public static void dumpThreadsToJson(OutputStream out) throws IOException {\n+        var writer = new TextWriter(out);\n@@ -181,3 +238,5 @@\n-            dumpThreadsToJson(ps);\n-        } finally {\n-            ps.flush();  \/\/ flushes underlying stream\n+            dumpThreadsToJson(writer);\n+            writer.flush();\n+        } catch (UncheckedIOException e) {\n+            IOException ioe = e.getCause();\n+            throw ioe;\n@@ -188,1 +247,2 @@\n-     * Generate a thread dump to the given print stream in JSON format.\n+     * Generate a thread dump to the given text stream in JSON format.\n+     * @throws UncheckedIOException if an I\/O error occurs\n@@ -190,22 +250,18 @@\n-    private static void dumpThreadsToJson(PrintStream out) {\n-        out.println(\"{\");\n-        out.println(\"  \\\"threadDump\\\": {\");\n-\n-        String now = Instant.now().toString();\n-        String runtimeVersion = Runtime.version().toString();\n-        out.format(\"    \\\"processId\\\": \\\"%d\\\",%n\", processId());\n-        out.format(\"    \\\"time\\\": \\\"%s\\\",%n\", escape(now));\n-        out.format(\"    \\\"runtimeVersion\\\": \\\"%s\\\",%n\", escape(runtimeVersion));\n-\n-        out.println(\"    \\\"threadContainers\\\": [\");\n-        List<ThreadContainer> containers = allContainers();\n-        Iterator<ThreadContainer> iterator = containers.iterator();\n-        while (iterator.hasNext()) {\n-            ThreadContainer container = iterator.next();\n-            boolean more = iterator.hasNext();\n-            dumpThreadsToJson(container, out, more);\n-        }\n-        out.println(\"    ]\");   \/\/ end of threadContainers\n-\n-        out.println(\"  }\");   \/\/ end threadDump\n-        out.println(\"}\");  \/\/ end object\n+    private static void dumpThreadsToJson(TextWriter textWriter) {\n+        var jsonWriter = new JsonWriter(textWriter);\n+\n+        jsonWriter.startObject();  \/\/ top-level object\n+\n+        jsonWriter.startObject(\"threadDump\");\n+\n+        jsonWriter.writeProperty(\"processId\", processId());\n+        jsonWriter.writeProperty(\"time\", Instant.now());\n+        jsonWriter.writeProperty(\"runtimeVersion\", Runtime.version());\n+\n+        jsonWriter.startArray(\"threadContainers\");\n+        dumpThreads(ThreadContainers.root(), jsonWriter);\n+        jsonWriter.endArray();\n+\n+        jsonWriter.endObject();  \/\/ threadDump\n+\n+        jsonWriter.endObject();  \/\/ end of top-level object\n@@ -215,1 +271,2 @@\n-     * Dump the given thread container to the print stream in JSON format.\n+     * Write a thread container to the given JSON writer.\n+     * @throws UncheckedIOException if an I\/O error occurs\n@@ -217,12 +274,4 @@\n-    private static void dumpThreadsToJson(ThreadContainer container,\n-                                          PrintStream out,\n-                                          boolean more) {\n-        out.println(\"      {\");\n-        out.format(\"        \\\"container\\\": \\\"%s\\\",%n\", escape(container.toString()));\n-\n-        ThreadContainer parent = container.parent();\n-        if (parent == null) {\n-            out.format(\"        \\\"parent\\\": null,%n\");\n-        } else {\n-            out.format(\"        \\\"parent\\\": \\\"%s\\\",%n\", escape(parent.toString()));\n-        }\n+    private static void dumpThreads(ThreadContainer container, JsonWriter jsonWriter) {\n+        jsonWriter.startObject();\n+        jsonWriter.writeProperty(\"container\", container);\n+        jsonWriter.writeProperty(\"parent\", container.parent());\n@@ -231,5 +280,1 @@\n-        if (owner == null) {\n-            out.format(\"        \\\"owner\\\": null,%n\");\n-        } else {\n-            out.format(\"        \\\"owner\\\": \\\"%d\\\",%n\", owner.threadId());\n-        }\n+        jsonWriter.writeProperty(\"owner\", (owner != null) ? owner.threadId() : null);\n@@ -238,1 +283,1 @@\n-        out.println(\"        \\\"threads\\\": [\");\n+        jsonWriter.startArray(\"threads\");\n@@ -242,1 +287,1 @@\n-            dumpThreadToJson(thread, out, threads.hasNext());\n+            dumpThread(thread, jsonWriter);\n@@ -245,1 +290,1 @@\n-        out.println(\"        ],\");   \/\/ end of threads\n+        jsonWriter.endArray(); \/\/ threads\n@@ -251,1 +296,1 @@\n-        out.format(\"        \\\"threadCount\\\": \\\"%d\\\"%n\", threadCount);\n+        jsonWriter.writeProperty(\"threadCount\", threadCount);\n@@ -253,5 +298,4 @@\n-        if (more) {\n-            out.println(\"      },\");\n-        } else {\n-            out.println(\"      }\");  \/\/ last container, no trailing comma\n-        }\n+        jsonWriter.endObject();\n+\n+        \/\/ the children of the thread container follow\n+        container.children().forEach(c -> dumpThreads(c, jsonWriter));\n@@ -261,1 +305,2 @@\n-     * Dump the given thread and its stack trace to the print stream in JSON format.\n+     * Write a thread to the given JSON writer.\n+     * @throws UncheckedIOException if an I\/O error occurs\n@@ -263,17 +308,54 @@\n-    private static void dumpThreadToJson(Thread thread, PrintStream out, boolean more) {\n-        out.println(\"         {\");\n-        out.println(\"           \\\"tid\\\": \\\"\" + thread.threadId() + \"\\\",\");\n-        out.println(\"           \\\"name\\\": \\\"\" + escape(thread.getName()) + \"\\\",\");\n-        out.println(\"           \\\"stack\\\": [\");\n-\n-        int i = 0;\n-        StackTraceElement[] stackTrace = thread.getStackTrace();\n-        while (i < stackTrace.length) {\n-            out.print(\"              \\\"\");\n-            out.print(escape(stackTrace[i].toString()));\n-            out.print(\"\\\"\");\n-            i++;\n-            if (i < stackTrace.length) {\n-                out.println(\",\");\n-            } else {\n-                out.println();  \/\/ last element, no trailing comma\n+    private static void dumpThread(Thread thread, JsonWriter jsonWriter) {\n+        Instant now = Instant.now();\n+        ThreadSnapshot snapshot = ThreadSnapshot.of(thread);\n+        Thread.State state = snapshot.threadState();\n+        StackTraceElement[] stackTrace = snapshot.stackTrace();\n+\n+        jsonWriter.startObject();\n+        jsonWriter.writeProperty(\"tid\", thread.threadId());\n+        jsonWriter.writeProperty(\"time\", now);\n+        if (thread.isVirtual()) {\n+            jsonWriter.writeProperty(\"virtual\", Boolean.TRUE);\n+        }\n+        jsonWriter.writeProperty(\"name\", snapshot.threadName());\n+        jsonWriter.writeProperty(\"state\", state);\n+\n+        \/\/ park blocker\n+        Object parkBlocker = snapshot.parkBlocker();\n+        if (parkBlocker != null) {\n+            \/\/ parkBlocker is an object to allow for exclusiveOwnerThread in the future\n+            jsonWriter.startObject(\"parkBlocker\");\n+            jsonWriter.writeProperty(\"object\", Objects.toIdentityString(parkBlocker));\n+            jsonWriter.endObject();\n+        }\n+\n+        \/\/ blocked on monitor enter or Object.wait\n+        if (state == Thread.State.BLOCKED && snapshot.blockedOn() instanceof Object obj) {\n+            jsonWriter.writeProperty(\"blockedOn\", Objects.toIdentityString(obj));\n+        } else if ((state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING)\n+                && snapshot.waitingOn() instanceof Object obj) {\n+            jsonWriter.writeProperty(\"waitingOn\", Objects.toIdentityString(obj));\n+        }\n+\n+        \/\/ stack trace\n+        jsonWriter.startArray(\"stack\");\n+        Arrays.stream(stackTrace).forEach(jsonWriter::writeProperty);\n+        jsonWriter.endArray();\n+\n+        \/\/ monitors owned, skip if none\n+        if (snapshot.ownsMonitors()) {\n+            jsonWriter.startArray(\"monitorsOwned\");\n+            int depth = 0;\n+            while (depth < stackTrace.length) {\n+                List<Object> objs = snapshot.ownedMonitorsAt(depth).toList();\n+                if (!objs.isEmpty()) {\n+                    jsonWriter.startObject();\n+                    jsonWriter.writeProperty(\"depth\", depth);\n+                    jsonWriter.startArray(\"locks\");\n+                    snapshot.ownedMonitorsAt(depth)\n+                            .map(o -> (o != null) ? Objects.toIdentityString(o) : null)\n+                            .forEach(jsonWriter::writeProperty);\n+                    jsonWriter.endArray();\n+                    jsonWriter.endObject();\n+                }\n+                depth++;\n@@ -281,0 +363,1 @@\n+            jsonWriter.endArray();\n@@ -282,5 +365,4 @@\n-        out.println(\"           ]\");\n-        if (more) {\n-            out.println(\"         },\");\n-        } else {\n-            out.println(\"         }\");  \/\/ last thread, no trailing comma\n+\n+        \/\/ thread identifier of carrier, when mounted\n+        if (thread.isVirtual() && snapshot.carrierThread() instanceof Thread carrier) {\n+            jsonWriter.writeProperty(\"carrier\", carrier.threadId());\n@@ -288,0 +370,2 @@\n+\n+        jsonWriter.endObject();\n@@ -291,2 +375,2 @@\n-     * Returns a list of all thread containers that are \"reachable\" from\n-     * the root container.\n+     * Simple JSON writer to stream objects\/arrays to a TextWriter with formatting.\n+     * This class is not intended to be a fully featured JSON writer.\n@@ -294,5 +378,21 @@\n-    private static List<ThreadContainer> allContainers() {\n-        List<ThreadContainer> containers = new ArrayList<>();\n-        collect(ThreadContainers.root(), containers);\n-        return containers;\n-    }\n+    private static class JsonWriter {\n+        private static class Node {\n+            final boolean isArray;\n+            int propertyCount;\n+            Node(boolean isArray) {\n+                this.isArray = isArray;\n+            }\n+            boolean isArray() {\n+                return isArray;\n+            }\n+            int propertyCount() {\n+                return propertyCount;\n+            }\n+            int getAndIncrementPropertyCount() {\n+                int old = propertyCount;\n+                propertyCount++;\n+                return old;\n+            }\n+        }\n+        private final Deque<Node> stack = new ArrayDeque<>();\n+        private final TextWriter writer;\n@@ -300,4 +400,3 @@\n-    private static void collect(ThreadContainer container, List<ThreadContainer> containers) {\n-        containers.add(container);\n-        container.children().forEach(c -> collect(c, containers));\n-    }\n+        JsonWriter(TextWriter writer) {\n+            this.writer = writer;\n+        }\n@@ -305,21 +404,125 @@\n-    \/**\n-     * Escape any characters that need to be escape in the JSON output.\n-     *\/\n-    private static String escape(String value) {\n-        StringBuilder sb = new StringBuilder();\n-        for (int i = 0; i < value.length(); i++) {\n-            char c = value.charAt(i);\n-            switch (c) {\n-                case '\"'  -> sb.append(\"\\\\\\\"\");\n-                case '\\\\' -> sb.append(\"\\\\\\\\\");\n-                case '\/'  -> sb.append(\"\\\\\/\");\n-                case '\\b' -> sb.append(\"\\\\b\");\n-                case '\\f' -> sb.append(\"\\\\f\");\n-                case '\\n' -> sb.append(\"\\\\n\");\n-                case '\\r' -> sb.append(\"\\\\r\");\n-                case '\\t' -> sb.append(\"\\\\t\");\n-                default -> {\n-                    if (c <= 0x1f) {\n-                        sb.append(String.format(\"\\\\u%04x\", c));\n-                    } else {\n-                        sb.append(c);\n+        private void indent() {\n+            int indent = stack.size() * 2;\n+            writer.print(\" \".repeat(indent));\n+        }\n+\n+        \/**\n+         * Start of object or array.\n+         *\/\n+        private void startObject(String name, boolean isArray) {\n+            if (!stack.isEmpty()) {\n+                Node node = stack.peek();\n+                if (node.getAndIncrementPropertyCount() > 0) {\n+                    writer.println(\",\");\n+                }\n+            }\n+            indent();\n+            if (name != null) {\n+                writer.print(\"\\\"\" + name + \"\\\": \");\n+            }\n+            writer.println(isArray ? \"[\" : \"{\");\n+            stack.push(new Node(isArray));\n+        }\n+\n+        \/**\n+         * End of object or array.\n+         *\/\n+        private void endObject(boolean isArray) {\n+            Node node = stack.pop();\n+            if (node.isArray() != isArray)\n+                throw new IllegalStateException();\n+            if (node.propertyCount() > 0) {\n+                writer.println();\n+            }\n+            indent();\n+            writer.print(isArray ? \"]\" : \"}\");\n+        }\n+\n+        \/**\n+         * Write a property.\n+         * @param name the property name, null for an unnamed property\n+         * @param obj the value or null\n+         *\/\n+        void writeProperty(String name, Object obj) {\n+            Node node = stack.peek();\n+            if (node.getAndIncrementPropertyCount() > 0) {\n+                writer.println(\",\");\n+            }\n+            indent();\n+            if (name != null) {\n+                writer.print(\"\\\"\" + name + \"\\\": \");\n+            }\n+            switch (obj) {\n+                \/\/ Long may be larger than safe range of JSON integer value\n+                case Long   _  -> writer.print(\"\\\"\" + obj + \"\\\"\");\n+                case Number _  -> writer.print(obj);\n+                case Boolean _ -> writer.print(obj);\n+                case null      -> writer.print(\"null\");\n+                default        -> writer.print(\"\\\"\" + escape(obj.toString()) + \"\\\"\");\n+            }\n+        }\n+\n+        \/**\n+         * Write an unnamed property.\n+         *\/\n+        void writeProperty(Object obj) {\n+            writeProperty(null, obj);\n+        }\n+\n+        \/**\n+         * Start named object.\n+         *\/\n+        void startObject(String name) {\n+            startObject(name, false);\n+        }\n+\n+        \/**\n+         * Start unnamed object.\n+         *\/\n+        void startObject() {\n+            startObject(null);\n+        }\n+\n+        \/**\n+         * End of object.\n+         *\/\n+        void endObject() {\n+            endObject(false);\n+        }\n+\n+        \/**\n+         * Start named array.\n+         *\/\n+        void startArray(String name) {\n+            startObject(name, true);\n+        }\n+\n+        \/**\n+         * End of array.\n+         *\/\n+        void endArray() {\n+            endObject(true);\n+        }\n+\n+        \/**\n+         * Escape any characters that need to be escape in the JSON output.\n+         *\/\n+        private static String escape(String value) {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 0; i < value.length(); i++) {\n+                char c = value.charAt(i);\n+                switch (c) {\n+                    case '\"'  -> sb.append(\"\\\\\\\"\");\n+                    case '\\\\' -> sb.append(\"\\\\\\\\\");\n+                    case '\/'  -> sb.append(\"\\\\\/\");\n+                    case '\\b' -> sb.append(\"\\\\b\");\n+                    case '\\f' -> sb.append(\"\\\\f\");\n+                    case '\\n' -> sb.append(\"\\\\n\");\n+                    case '\\r' -> sb.append(\"\\\\r\");\n+                    case '\\t' -> sb.append(\"\\\\t\");\n+                    default -> {\n+                        if (c <= 0x1f) {\n+                            sb.append(String.format(\"\\\\u%04x\", c));\n+                        } else {\n+                            sb.append(c);\n+                        }\n@@ -329,0 +532,1 @@\n+            return sb.toString();\n@@ -330,1 +534,0 @@\n-        return sb.toString();\n@@ -360,0 +563,50 @@\n+    \/**\n+     * Simple Writer implementation for printing text. The print\/println methods\n+     * throw UncheckedIOException if an I\/O error occurs.\n+     *\/\n+    private static class TextWriter extends Writer {\n+        private final Writer delegate;\n+\n+        TextWriter(OutputStream out) {\n+            delegate = new BufferedWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));\n+        }\n+\n+        @Override\n+        public void write(char[] cbuf, int off, int len) throws IOException {\n+            delegate.write(cbuf, off, len);\n+        }\n+\n+        void print(Object obj) {\n+            String s = String.valueOf(obj);\n+            try {\n+                write(s, 0, s.length());\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        void println() {\n+            print(System.lineSeparator());\n+        }\n+\n+        void println(String s) {\n+            print(s);\n+            println();\n+        }\n+\n+        void println(Object obj) {\n+            print(obj);\n+            println();\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+            delegate.flush();\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            delegate.close();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadDumper.java","additions":421,"deletions":168,"binary":false,"changes":589,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+     * @throws UnsupportedOperationException if not supported by VM\n@@ -58,0 +59,3 @@\n+        if (snapshot == null) {\n+            throw new UnsupportedOperationException();\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadSnapshot.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,0 +119,7 @@\n+     * <p> When the format is specified as {@link ThreadDumpFormat#JSON JSON}, the\n+     * thread dump is generated in JavaScript Object Notation.\n+     * <a href=\"doc-files\/threadDump.schema.json\">threadDump.schema.json<\/a>\n+     * describes the thread dump format in draft\n+     * <a href=\"https:\/\/tools.ietf.org\/html\/draft-json-schema-language-02\">\n+     * JSON Schema Language version 2<\/a>.\n+     *\n@@ -154,0 +161,1 @@\n+         * @spec https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259 JavaScript Object Notation\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/HotSpotDiagnosticMXBean.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+{\n+  \"type\": \"object\",\n+  \"properties\": {\n+    \"threadDump\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"processId\": {\n+          \"type\": \"string\",\n+          \"description\": \"The native process id of the Java virtual machine.\"\n+        },\n+        \"time\": {\n+          \"type\": \"string\",\n+          \"description\": \"The time in ISO 8601 format when the thread dump was generated.\"\n+        },\n+        \"runtimeVersion\": {\n+          \"type\": \"string\",\n+          \"description\": \"The runtime version, see java.lang.Runtime.Version\"\n+        },\n+        \"threadContainers\": {\n+          \"type\": \"array\",\n+          \"description\": \"The array of thread containers (thread groupings).\",\n+          \"items\": [\n+            {\n+              \"type\": \"object\",\n+              \"properties\": {\n+                \"container\": {\n+                  \"type\": \"string\",\n+                  \"description\": \"The container name. The container name is unique.\"\n+                },\n+                \"parent\": {\n+                  \"type\": [\n+                    \"string\",\n+                    \"null\"\n+                  ],\n+                  \"description\": \"The parent container name or null for the root container.\"\n+                },\n+                \"owner\": {\n+                  \"type\": [\n+                    \"string\",\n+                    \"null\"\n+                  ],\n+                  \"description\": \"The thread identifier of the owner thread if owned.\"\n+                },\n+                \"threads\": {\n+                  \"type\": \"array\",\n+                  \"description\": \"The array of threads in the thread container.\",\n+                  \"items\": [\n+                    {\n+                      \"type\": \"object\",\n+                      \"properties\": {\n+                        \"tid\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The thread identifier.\"\n+                        },\n+                        \"time\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The time in ISO 8601 format that the thread was sampled.\"\n+                        },\n+                        \"name\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The thread name.\"\n+                        },\n+                        \"state\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The thread state (Thread::getState).\"\n+                        },\n+                        \"virtual\" : {\n+                          \"type\": \"boolean\",\n+                          \"description\": \"true for a virtual thread.\"\n+                        },\n+                        \"parkBlocker\": {\n+                          \"type\": [\n+                            \"object\"\n+                          ],\n+                          \"properties\": {\n+                            \"object\": {\n+                              \"type\": \"string\",\n+                              \"description\": \"The blocker object responsible for the thread parking.\"\n+                            }\n+                          },\n+                          \"required\": [\n+                            \"object\"\n+                          ]\n+                        },\n+                        \"blockedOn\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The object that the thread is blocked on waiting to enter\/re-enter a synchronization block\/method.\"\n+                        },\n+                        \"waitingOn\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The object that the thread is waiting to be notified (Object.wait).\"\n+                        },\n+                        \"stack\": {\n+                          \"type\": \"array\",\n+                          \"description\": \"The thread stack. The first element is the top of the stack.\",\n+                          \"items\": [\n+                            {\n+                              \"type\": \"string\",\n+                              \"description\": \"A stack trace element (java.lang.StackTraceElement).\"\n+                            }\n+                          ]\n+                        },\n+                        \"monitorsOwned\": {\n+                          \"type\": \"array\",\n+                          \"description\": \"The objects for which monitors are owned by the thread.\",\n+                          \"items\": {\n+                            \"type\": \"object\",\n+                            \"properties\": {\n+                              \"depth\": {\n+                                \"type\": \"integer\",\n+                                \"description\": \"The stack depth at which the monitors are owned.\"\n+                              },\n+                              \"locks\": {\n+                                \"type\": \"array\",\n+                                \"items\": {\n+                                  \"type\": [\n+                                    \"string\",\n+                                    null\n+                                  ],\n+                                  \"description\": \"The object for which the monitor is owned by the thread, null if eliminated\"\n+                                }\n+                              }\n+                            },\n+                            \"required\": [\n+                              \"depth\",\n+                              \"locks\"\n+                            ]\n+                          }\n+                        },\n+                        \"carrier\":  {\n+                          \"type\": \"string\",\n+                          \"description\": \"The thread identifier of the carrier thread if mounted.\"\n+                        }\n+                      },\n+                      \"required\": [\n+                        \"tid\",\n+                        \"time\",\n+                        \"name\",\n+                        \"state\",\n+                        \"stack\"\n+                      ]\n+                    }\n+                  ]\n+                },\n+                \"threadCount\": {\n+                  \"type\": \"string\",\n+                  \"description\": \"The number of threads in the thread container.\"\n+                }\n+              },\n+              \"required\": [\n+                \"container\",\n+                \"parent\",\n+                \"owner\",\n+                \"threads\"\n+              ]\n+            }\n+          ]\n+        }\n+      },\n+      \"required\": [\n+        \"processId\",\n+        \"time\",\n+        \"runtimeVersion\",\n+        \"threadContainers\"\n+      ]\n+    }\n+  },\n+  \"required\": [\n+    \"threadDump\"\n+  ]\n+}\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/doc-files\/threadDump.schema.json","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-                dumpThreads(out, format);\n+            dumpThreads(out, format);\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/HotSpotDiagnostic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @modules jdk.jcmd\n@@ -69,1 +70,2 @@\n-        jcmdThreadDumpToFile(file, \"-format=json\").shouldMatch(\"Created\");\n+        jcmdThreadDumpToFile(file, \"-format=json\")\n+                .shouldMatch(\"Created\");\n@@ -92,1 +94,2 @@\n-        jcmdThreadDumpToFile(file, \"\").shouldMatch(\"exists\");\n+        jcmdThreadDumpToFile(file, \"\")\n+                .shouldMatch(\"exists\");\n@@ -105,1 +108,17 @@\n-        jcmdThreadDumpToFile(file, \"-overwrite\");\n+        jcmdThreadDumpToFile(file, \"-overwrite\")\n+                .shouldMatch(\"Created\");\n+    }\n+\n+    \/**\n+     * Test output file cannot be created.\n+     *\/\n+    @Test\n+    void testFileCreateFails() throws IOException {\n+        Path badFile = Path.of(\".\").toAbsolutePath()\n+                .resolve(\"does-not-exist\")\n+                .resolve(\"does-not-exist\")\n+                .resolve(\"threads.bad\");\n+        jcmdThreadDumpToFile(badFile, \"-format=plain\")\n+                .shouldMatch(\"Failed\");\n+        jcmdThreadDumpToFile(badFile, \"-format=json\")\n+                .shouldMatch(\"Failed\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/ThreadDumpToFileTest.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -26,1 +26,1 @@\n- * @bug 8284161 8287008 8309406\n+ * @bug 8284161 8287008 8309406 8356870\n@@ -29,1 +29,1 @@\n- * @modules jdk.management\n+ * @modules java.base\/jdk.internal.vm jdk.management\n@@ -31,4 +31,10 @@\n- * @run junit\/othervm DumpThreads\n- * @run junit\/othervm -Djdk.trackAllThreads DumpThreads\n- * @run junit\/othervm -Djdk.trackAllThreads=true DumpThreads\n- * @run junit\/othervm -Djdk.trackAllThreads=false DumpThreads\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run junit\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *         --enable-native-access=ALL-UNNAMED DumpThreads\n+ * @run junit\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *         --enable-native-access=ALL-UNNAMED -Djdk.trackAllThreads DumpThreads\n+ * @run junit\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *        --enable-native-access=ALL-UNNAMED -Djdk.trackAllThreads=true DumpThreads\n+ * @run junit\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *        --enable-native-access=ALL-UNNAMED -Djdk.trackAllThreads=false DumpThreads\n@@ -38,0 +44,3 @@\n+import java.lang.reflect.Method;\n+import java.io.IOException;\n+import java.io.OutputStream;\n@@ -41,1 +50,0 @@\n-import java.util.Objects;\n@@ -43,0 +51,3 @@\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n@@ -48,0 +59,4 @@\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -49,0 +64,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n@@ -50,0 +67,2 @@\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n@@ -53,0 +72,3 @@\n+import jdk.test.lib.thread.VThreadPinner;\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.whitebox.WhiteBox;\n@@ -59,0 +81,1 @@\n+import static org.junit.jupiter.api.Assumptions.*;\n@@ -67,0 +90,50 @@\n+\n+        \/\/ need >=2 carriers for testing pinning\n+        VThreadRunner.ensureParallelism(2);\n+    }\n+\n+    \/**\n+     * Test thread dump in plain text format.\n+     *\/\n+    @Test\n+    void testPlainText() throws Exception {\n+        List<String> lines = dumpThreadsToPlainText();\n+\n+        \/\/ pid should be on the first line\n+        String pid = Long.toString(ProcessHandle.current().pid());\n+        assertEquals(pid, lines.get(0));\n+\n+        \/\/ timestamp should be on the second line\n+        String secondLine = lines.get(1);\n+        ZonedDateTime.parse(secondLine);\n+\n+        \/\/ runtime version should be on third line\n+        String vs = Runtime.version().toString();\n+        assertEquals(vs, lines.get(2));\n+\n+        \/\/ dump should include current thread\n+        Thread currentThread = Thread.currentThread();\n+        if (trackAllThreads || !currentThread.isVirtual()) {\n+            ThreadFields fields = findThread(currentThread.threadId(), lines);\n+            assertNotNull(fields, \"current thread not found\");\n+            assertEquals(currentThread.getName(), fields.name());\n+            assertEquals(currentThread.isVirtual(), fields.isVirtual());\n+        }\n+    }\n+\n+    \/**\n+     * Test thread dump in JSON format.\n+     *\/\n+    @Test\n+    void testJsonFormat() throws Exception {\n+        ThreadDump threadDump = dumpThreadsToJson();\n+\n+        \/\/ dump should include current thread in the root container\n+        Thread currentThread = Thread.currentThread();\n+        if (trackAllThreads || !currentThread.isVirtual()) {\n+            ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                    .findThread(currentThread.threadId())\n+                    .orElse(null);\n+            assertNotNull(ti, \"current thread not found\");\n+            assertEquals(currentThread.isVirtual(), ti.isVirtual());\n+        }\n@@ -81,2 +154,1 @@\n-     * Test thread dump in plain text format contains information about the current\n-     * thread and a virtual thread created directly with the Thread API.\n+     * Test that a thread container for an executor service is in the JSON format thread dump.\n@@ -84,7 +156,5 @@\n-    @Test\n-    void testRootContainerPlainTextFormat() throws Exception {\n-        Thread vthread = Thread.ofVirtual().start(LockSupport::park);\n-        try {\n-            testDumpThreadsPlainText(vthread, trackAllThreads);\n-        } finally {\n-            LockSupport.unpark(vthread);\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testThreadContainer(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            testThreadContainer(executor, Objects.toIdentityString(executor));\n@@ -95,2 +165,1 @@\n-     * Test thread dump in JSON format contains information about the current\n-     * thread and a virtual thread created directly with the Thread API.\n+     * Test that a thread container for the common pool is in the JSON format thread dump.\n@@ -99,2 +168,21 @@\n-    void testRootContainerJsonFormat() throws Exception {\n-        Thread vthread = Thread.ofVirtual().start(LockSupport::park);\n+    void testCommonPool() throws Exception {\n+        testThreadContainer(ForkJoinPool.commonPool(), \"ForkJoinPool.commonPool\");\n+    }\n+\n+    \/**\n+     * Test that the JSON thread dump has a thread container for the given executor.\n+     *\/\n+    private void testThreadContainer(ExecutorService executor, String name) throws Exception {\n+        var threadRef = new AtomicReference<Thread>();\n+\n+        executor.submit(() -> {\n+            threadRef.set(Thread.currentThread());\n+            LockSupport.park();\n+        });\n+\n+        \/\/ capture Thread\n+        Thread thread;\n+        while ((thread = threadRef.get()) == null) {\n+            Thread.sleep(20);\n+        }\n+\n@@ -102,1 +190,14 @@\n-            testDumpThreadsJson(null, vthread, trackAllThreads);\n+            \/\/ dump threads to file and parse as JSON object\n+            ThreadDump threadDump = dumpThreadsToJson();\n+\n+            \/\/ find the thread container corresponding to the executor\n+            var container = threadDump.findThreadContainer(name).orElse(null);\n+            assertNotNull(container, name + \" not found\");\n+            assertFalse(container.owner().isPresent());\n+            var parent = container.parent().orElse(null);\n+            assertEquals(threadDump.rootThreadContainer(), parent);\n+\n+            \/\/ find the thread in the thread container\n+            ThreadDump.ThreadInfo ti = container.findThread(thread.threadId()).orElse(null);\n+            assertNotNull(ti, \"thread not found\");\n+\n@@ -104,1 +205,1 @@\n-            LockSupport.unpark(vthread);\n+            LockSupport.unpark(thread);\n@@ -109,2 +210,1 @@\n-     * Test thread dump in plain text format includes a thread executing a task in the\n-     * given ExecutorService.\n+     * ThreadFactory implementations for tests.\n@@ -112,10 +212,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"executors\")\n-    void testExecutorServicePlainTextFormat(ExecutorService executor) throws Exception {\n-        try (executor) {\n-            Thread thread = forkParker(executor);\n-            try {\n-                testDumpThreadsPlainText(thread, true);\n-            } finally {\n-                LockSupport.unpark(thread);\n-            }\n+    static Stream<ThreadFactory> threadFactories() {\n+        Stream<ThreadFactory> s = Stream.of(Thread.ofPlatform().factory());\n+        if (trackAllThreads) {\n+            return Stream.concat(s, Stream.of(Thread.ofVirtual().factory()));\n+        } else {\n+            return s;\n@@ -126,2 +222,1 @@\n-     * Test thread dump in JSON format includes a thread executing a task in the\n-     * given ExecutorService.\n+     * Test thread dump with a thread blocked on monitor enter.\n@@ -130,10 +225,3 @@\n-    @MethodSource(\"executors\")\n-    void testExecutorServiceJsonFormat(ExecutorService executor) throws Exception {\n-        try (executor) {\n-            Thread thread = forkParker(executor);\n-            try {\n-                testDumpThreadsJson(Objects.toIdentityString(executor), thread, true);\n-            } finally {\n-                LockSupport.unpark(thread);\n-            }\n-        }\n+    @MethodSource(\"threadFactories\")\n+    void testBlockedThread(ThreadFactory factory) throws Exception {\n+        testBlockedThread(factory, false);\n@@ -143,2 +231,1 @@\n-     * Test thread dump in JSON format includes a thread executing a task in the\n-     * fork-join common pool.\n+     * Test thread dump with a thread blocked on monitor enter when pinned.\n@@ -147,3 +234,21 @@\n-    void testForkJoinPool() throws Exception {\n-        ForkJoinPool pool = ForkJoinPool.commonPool();\n-        Thread thread = forkParker(pool);\n+    void testBlockedThreadWhenPinned() throws Exception {\n+        assumeTrue(trackAllThreads, \"This test requires all threads to be tracked\");\n+        testBlockedThread(Thread.ofVirtual().factory(), true);\n+    }\n+\n+    void testBlockedThread(ThreadFactory factory, boolean pinned) throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+\n+        Thread thread = factory.newThread(() -> {\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    started.countDown();\n+                    synchronized (lock) { }  \/\/ blocks\n+                });\n+            } else {\n+                started.countDown();\n+                synchronized (lock) { }  \/\/ blocks\n+            }\n+        });\n+\n@@ -151,1 +256,30 @@\n-            testDumpThreadsJson(\"ForkJoinPool.commonPool\", thread, true);\n+            synchronized (lock) {\n+                \/\/ start thread and wait for it to block\n+                thread.start();\n+                started.await();\n+                await(thread, Thread.State.BLOCKED);\n+\n+                long tid = thread.threadId();\n+                String lockAsString = Objects.toIdentityString(lock);\n+\n+                \/\/ thread dump in plain text should include thread\n+                List<String> lines = dumpThreadsToPlainText();\n+                ThreadFields fields = findThread(tid, lines);\n+                assertNotNull(fields, \"thread not found\");\n+                assertEquals(\"BLOCKED\", fields.state());\n+                assertTrue(contains(lines, \"- waiting to lock <\" + lockAsString));\n+\n+                \/\/ thread dump in JSON format should include thread in root container\n+                ThreadDump threadDump = dumpThreadsToJson();\n+                ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                        .findThread(tid)\n+                        .orElse(null);\n+                assertNotNull(ti, \"thread not found\");\n+                assertEquals(\"BLOCKED\", ti.state());\n+                assertEquals(lockAsString, ti.blockedOn());\n+                if (pinned) {\n+                    long carrierTid = ti.carrier().orElse(-1L);\n+                    assertNotEquals(-1L, carrierTid, \"carrier not found\");\n+                    assertForkJoinWorkerThread(carrierTid);\n+                }\n+            }\n@@ -153,1 +287,1 @@\n-            LockSupport.unpark(thread);\n+            thread.join();\n@@ -158,5 +292,1 @@\n-     * Invoke HotSpotDiagnosticMXBean.dumpThreads to create a thread dump in plain text\n-     * format, then sanity check that the thread dump includes expected strings, the\n-     * current thread, and maybe the given thread.\n-     * @param thread the thread to test if included\n-     * @param expectInDump true if the thread is expected to be included\n+     * Test thread dump with a thread waiting in Object.wait.\n@@ -164,5 +294,5 @@\n-    private void testDumpThreadsPlainText(Thread thread, boolean expectInDump) throws Exception {\n-        Path file = genOutputPath(\".txt\");\n-        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n-        mbean.dumpThreads(file.toString(), ThreadDumpFormat.TEXT_PLAIN);\n-        System.err.format(\"Dumped to %s%n\", file);\n+    @ParameterizedTest\n+    @MethodSource(\"threadFactories\")\n+    void testWaitingThread(ThreadFactory factory) throws Exception {\n+        testWaitingThread(factory, false);\n+    }\n@@ -170,4 +300,8 @@\n-        \/\/ pid should be on the first line\n-        String line1 = line(file, 0);\n-        String pid = Long.toString(ProcessHandle.current().pid());\n-        assertTrue(line1.contains(pid));\n+    \/**\n+     * Test thread dump with a thread waiting in Object.wait when pinned.\n+     *\/\n+    @Test\n+    void testWaitingThreadWhenPinned() throws Exception {\n+        assumeTrue(trackAllThreads, \"This test requires all threads to be tracked\");\n+        testWaitingThread(Thread.ofVirtual().factory(), true);\n+    }\n@@ -175,3 +309,3 @@\n-        \/\/ timestamp should be on the second line\n-        String line2 = line(file, 1);\n-        ZonedDateTime.parse(line2);\n+    void testWaitingThread(ThreadFactory factory, boolean pinned) throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n@@ -179,4 +313,15 @@\n-        \/\/ runtime version should be on third line\n-        String line3 = line(file, 2);\n-        String vs = Runtime.version().toString();\n-        assertTrue(line3.contains(vs));\n+        Thread thread = factory.newThread(() -> {\n+            try {\n+                synchronized (lock) {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            started.countDown();\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        started.countDown();\n+                        lock.wait();\n+                    }\n+                }\n+            } catch (InterruptedException e) { }\n+        });\n@@ -184,2 +329,28 @@\n-        \/\/ test if thread is included in thread dump\n-        assertEquals(expectInDump, isPresent(file, thread));\n+        try {\n+            \/\/ start thread and wait for it to wait in Object.wait\n+            thread.start();\n+            started.await();\n+            await(thread, Thread.State.WAITING);\n+\n+            long tid = thread.threadId();\n+            String lockAsString = Objects.toIdentityString(lock);\n+\n+            \/\/ thread dump in plain text should include thread\n+            List<String> lines = dumpThreadsToPlainText();\n+            ThreadFields fields = findThread(tid, lines);\n+            assertNotNull(fields, \"thread not found\");\n+            assertEquals(\"WAITING\", fields.state());\n+\n+            \/\/ thread dump in JSON format should include thread in root container\n+            ThreadDump threadDump = dumpThreadsToJson();\n+            ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                    .findThread(thread.threadId())\n+                    .orElse(null);\n+            assertNotNull(ti, \"thread not found\");\n+            assertEquals(ti.isVirtual(), thread.isVirtual());\n+            assertEquals(\"WAITING\", ti.state());\n+            if (pinned) {\n+                long carrierTid = ti.carrier().orElse(-1L);\n+                assertNotEquals(-1L, carrierTid, \"carrier not found\");\n+                assertForkJoinWorkerThread(carrierTid);\n+            }\n@@ -187,4 +358,18 @@\n-        \/\/ current thread should be included if platform thread or tracking all threads\n-        Thread currentThread = Thread.currentThread();\n-        boolean currentThreadExpected = trackAllThreads || !currentThread.isVirtual();\n-        assertEquals(currentThreadExpected, isPresent(file, currentThread));\n+            \/\/ Compiled native frames have no locals. If Object.wait0 has been compiled\n+            \/\/ then we don't have the object that the thread is waiting on\n+            Method wait0 = Object.class.getDeclaredMethod(\"wait0\", long.class);\n+            boolean expectWaitingOn = !WhiteBox.getWhiteBox().isMethodCompiled(wait0);\n+            if (expectWaitingOn) {\n+                \/\/ plain text dump should have \"waiting on\" line\n+                assertTrue(contains(lines, \"- waiting on <\" + lockAsString));\n+\n+                \/\/ JSON thread dump should have waitingOn property\n+                assertEquals(lockAsString, ti.waitingOn());\n+            }\n+\n+        } finally {\n+            synchronized (lock) {\n+                lock.notifyAll();\n+            }\n+            thread.join();\n+        }\n@@ -194,6 +379,1 @@\n-     * Invoke HotSpotDiagnosticMXBean.dumpThreads to create a thread dump in JSON format.\n-     * The thread dump is parsed as a JSON object and checked to ensure that it contains\n-     * expected data, the current thread, and maybe the given thread.\n-     * @param containerName the name of the container or null for the root container\n-     * @param thread the thread to test if included\n-     * @param expect true if the thread is expected to be included\n+     * Test thread dump with a thread parked on a j.u.c. lock.\n@@ -201,7 +381,5 @@\n-    private void testDumpThreadsJson(String containerName,\n-                                     Thread thread,\n-                                     boolean expectInDump) throws Exception {\n-        Path file = genOutputPath(\".json\");\n-        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n-        mbean.dumpThreads(file.toString(), ThreadDumpFormat.JSON);\n-        System.err.format(\"Dumped to %s%n\", file);\n+    @ParameterizedTest\n+    @MethodSource(\"threadFactories\")\n+    void testParkedThread(ThreadFactory factory) throws Exception {\n+        testParkedThread(factory, false);\n+    }\n@@ -209,3 +387,8 @@\n-        \/\/ parse the JSON text\n-        String jsonText = Files.readString(file);\n-        ThreadDump threadDump = ThreadDump.parse(jsonText);\n+    \/**\n+     * Test thread dump with a thread parked on a j.u.c. lock and pinned.\n+     *\/\n+    @Test\n+    void testParkedThreadWhenPinned() throws Exception {\n+        assumeTrue(trackAllThreads, \"This test requires all threads to be tracked\");\n+        testParkedThread(Thread.ofVirtual().factory(), true);\n+    }\n@@ -213,2 +396,17 @@\n-        \/\/ test threadDump\/processId\n-        assertTrue(threadDump.processId() == ProcessHandle.current().pid());\n+    void testParkedThread(ThreadFactory factory, boolean pinned) throws Exception {\n+        var lock = new ReentrantLock();\n+        var started = new CountDownLatch(1);\n+\n+        Thread thread = factory.newThread(() -> {\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    started.countDown();\n+                    lock.lock();\n+                    lock.unlock();\n+                });\n+            } else {\n+                started.countDown();\n+                lock.lock();\n+                lock.unlock();\n+            }\n+        });\n@@ -216,2 +414,39 @@\n-        \/\/ test threadDump\/time can be parsed\n-        ZonedDateTime.parse(threadDump.time());\n+        lock.lock();\n+        try {\n+            \/\/ start thread and wait for it to park\n+            thread.start();\n+            started.await();\n+            await(thread, Thread.State.WAITING);\n+\n+            long tid = thread.threadId();\n+\n+            \/\/ thread dump in plain text should include thread\n+            List<String> lines = dumpThreadsToPlainText();\n+            ThreadFields fields = findThread(tid, lines);\n+            assertNotNull(fields, \"thread not found\");\n+            assertEquals(\"WAITING\", fields.state());\n+            assertTrue(contains(lines, \"- parking to wait for <java.util.concurrent.locks.ReentrantLock\"));\n+\n+            \/\/ thread dump in JSON format should include thread in root container\n+            ThreadDump threadDump = dumpThreadsToJson();\n+            ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                    .findThread(thread.threadId())\n+                    .orElse(null);\n+            assertNotNull(ti, \"thread not found\");\n+            assertEquals(ti.isVirtual(), thread.isVirtual());\n+\n+            \/\/ thread should be waiting on the ReentrantLock\n+            assertEquals(\"WAITING\", ti.state());\n+            String parkBlocker = ti.parkBlocker();\n+            assertNotNull(parkBlocker);\n+            assertTrue(parkBlocker.contains(\"java.util.concurrent.locks.ReentrantLock\"));\n+            if (pinned) {\n+                long carrierTid = ti.carrier().orElse(-1L);\n+                assertNotEquals(-1L, carrierTid, \"carrier not found\");\n+                assertForkJoinWorkerThread(carrierTid);\n+            }\n+        } finally {\n+            lock.unlock();\n+            thread.join();\n+        }\n+    }\n@@ -219,2 +454,8 @@\n-        \/\/ test threadDump\/runtimeVersion\n-        assertEquals(Runtime.version().toString(), threadDump.runtimeVersion());\n+    \/**\n+     * Test thread dump with a thread owning a monitor.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"threadFactories\")\n+    void testThreadOwnsMonitor(ThreadFactory factory) throws Exception {\n+        testThreadOwnsMonitor(factory, false);\n+    }\n@@ -222,4 +463,5 @@\n-        \/\/ test root container, has no parent and no owner\n-        var rootContainer = threadDump.rootThreadContainer();\n-        assertFalse(rootContainer.owner().isPresent());\n-        assertFalse(rootContainer.parent().isPresent());\n+    @Test\n+    void testThreadOwnsMonitorWhenPinned() throws Exception {\n+        assumeTrue(trackAllThreads, \"This test requires all threads to be tracked\");\n+        testThreadOwnsMonitor(Thread.ofVirtual().factory(), true);\n+    }\n@@ -227,11 +469,17 @@\n-        \/\/ test that the container contains the given thread\n-        ThreadDump.ThreadContainer container;\n-        if (containerName == null) {\n-            \/\/ root container, the thread should be found if trackAllThreads is true\n-            container = rootContainer;\n-        } else {\n-            \/\/ find the container\n-            container = threadDump.findThreadContainer(containerName).orElse(null);\n-            assertNotNull(container, containerName + \" not found\");\n-            assertFalse(container.owner().isPresent());\n-            assertTrue(container.parent().get() == rootContainer);\n+    void testThreadOwnsMonitor(ThreadFactory factory, boolean pinned) throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+\n+        Thread thread = factory.newThread(() -> {\n+            synchronized (lock) {\n+                if (pinned) {\n+                    VThreadPinner.runPinned(() -> {\n+                        started.countDown();\n+                        LockSupport.park();\n+                    });\n+                } else {\n+                    started.countDown();\n+                    LockSupport.park();\n+                }\n+            }\n+        });\n@@ -239,0 +487,33 @@\n+        try {\n+            \/\/ start thread and wait for it to park\n+            thread.start();\n+            started.await();\n+            await(thread, Thread.State.WAITING);\n+\n+            long tid = thread.threadId();\n+            String lockAsString = Objects.toIdentityString(lock);\n+\n+            \/\/ thread dump in plain text should include thread\n+            List<String> lines = dumpThreadsToPlainText();\n+            ThreadFields fields = findThread(tid, lines);\n+            assertNotNull(fields, \"thread not found\");\n+            assertEquals(\"WAITING\", fields.state());\n+            assertTrue(contains(lines, \"- locked <\" + lockAsString));\n+\n+            \/\/ thread dump in JSON format should include thread in root container\n+            ThreadDump threadDump = dumpThreadsToJson();\n+            ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                    .findThread(tid)\n+                    .orElse(null);\n+            assertNotNull(ti, \"thread not found\");\n+            assertEquals(ti.isVirtual(), thread.isVirtual());\n+\n+            \/\/ the lock should be in the ownedMonitors array\n+            Set<String> ownedMonitors = ti.ownedMonitors().values()\n+                    .stream()\n+                    .flatMap(List::stream)\n+                    .collect(Collectors.toSet());\n+            assertTrue(ownedMonitors.contains(lockAsString), lockAsString + \" not found\");\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n@@ -240,2 +521,1 @@\n-        boolean found = container.findThread(thread.threadId()).isPresent();\n-        assertEquals(expectInDump, found);\n+    }\n@@ -243,5 +523,56 @@\n-        \/\/ current thread should be in root container if platform thread or tracking all threads\n-        Thread currentThread = Thread.currentThread();\n-        boolean currentThreadExpected = trackAllThreads || !currentThread.isVirtual();\n-        found = rootContainer.findThread(currentThread.threadId()).isPresent();\n-        assertEquals(currentThreadExpected, found);\n+    \/**\n+     * Test mounted virtual thread.\n+     *\/\n+    @Test\n+    void testMountedVirtualThread() throws Exception {\n+        assumeTrue(trackAllThreads, \"This test requires all threads to be tracked\");\n+\n+        \/\/ start virtual thread that spins until done\n+        var started = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            started.set(true);\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+\n+        try {\n+            \/\/ wait for thread to start\n+            awaitTrue(started);\n+            long tid = thread.threadId();\n+\n+            \/\/ thread dump in plain text should include thread\n+            List<String> lines = dumpThreadsToPlainText();\n+            ThreadFields fields = findThread(tid, lines);\n+            assertNotNull(fields, \"thread not found\");\n+            assertTrue(fields.isVirtual());\n+\n+            \/\/ thread dump in JSON format should include thread in root container\n+            ThreadDump threadDump = dumpThreadsToJson();\n+            ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                    .findThread(tid)\n+                    .orElse(null);\n+            assertNotNull(ti, \"thread not found\");\n+            assertTrue(ti.isVirtual());\n+            long carrierTid = ti.carrier().orElse(-1L);\n+            assertNotEquals(-1L, carrierTid, \"carrier not found\");\n+            assertForkJoinWorkerThread(carrierTid);\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Asserts that the given thread identifier is a ForkJoinWorkerThread.\n+     *\/\n+    private void assertForkJoinWorkerThread(long tid) {\n+        Thread thread = Thread.getAllStackTraces()\n+                .keySet()\n+                .stream()\n+                .filter(t -> t.threadId() == tid)\n+                .findAny()\n+                .orElse(null);\n+        assertNotNull(thread, \"thread \" + tid + \" not found\");\n+        assertTrue(thread instanceof ForkJoinWorkerThread, \"not a ForkJoinWorkerThread\");\n@@ -254,1 +585,1 @@\n-    void testFileAlreadyExsists() throws Exception {\n+    void testFileAlreadyExists() throws Exception {\n@@ -263,0 +594,33 @@\n+    \/**\n+     * Test that dumpThreads throws IOException when the output file cannot be created.\n+     *\/\n+    @Test\n+    void testFileCreateFails() {\n+        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        String badFile = Path.of(\".\").toAbsolutePath()\n+                .resolve(\"does-not-exist\")\n+                .resolve(\"does-not-exist\")\n+                .resolve(\"threads.bad\")\n+                .toString();\n+        assertThrows(IOException.class,\n+                () -> mbean.dumpThreads(badFile, ThreadDumpFormat.TEXT_PLAIN));\n+        assertThrows(IOException.class,\n+                () -> mbean.dumpThreads(badFile, ThreadDumpFormat.JSON));\n+    }\n+\n+    \/**\n+     * Test that dumpThreads throws IOException if writing to output file fails.\n+     *\/\n+    @Test\n+    void testFileWriteFails() {\n+        var out = new OutputStream() {\n+            @Override\n+            public void write(int b) throws IOException {\n+                throw new IOException(\"There is not enough space on the disk\");\n+            }\n+        };\n+        \/\/ need to invoke internal API directly to test this\n+        assertThrows(IOException.class, () -> jdk.internal.vm.ThreadDumper.dumpThreads(out));\n+        assertThrows(IOException.class, () -> jdk.internal.vm.ThreadDumper.dumpThreadsToJson(out));\n+    }\n+\n@@ -267,1 +631,1 @@\n-    void testRelativePath() throws Exception {\n+    void testRelativePath() {\n@@ -279,1 +643,1 @@\n-    void testNull() throws Exception {\n+    void testNull() {\n@@ -288,2 +652,1 @@\n-     * Submits a parking task to the given executor, returns the Thread object of\n-     * the parked thread.\n+     * Represents the data for a thread found in a plain text thread dump.\n@@ -291,12 +654,12 @@\n-    private static Thread forkParker(ExecutorService executor) {\n-        class Box { static volatile Thread thread;}\n-        var latch = new CountDownLatch(1);\n-        executor.submit(() -> {\n-            Box.thread = Thread.currentThread();\n-            latch.countDown();\n-            LockSupport.park();\n-        });\n-        try {\n-            latch.await();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n+    private record ThreadFields(long tid, String name, boolean isVirtual, String state) { }\n+\n+    \/**\n+     * Find a thread in the lines of a plain text thread dump.\n+     *\/\n+    private ThreadFields findThread(long tid, List<String> lines) {\n+        String line = lines.stream()\n+                .filter(l -> l.startsWith(\"#\" + tid + \" \"))\n+                .findFirst()\n+                .orElse(null);\n+        if (line == null) {\n+            return null;\n@@ -304,1 +667,10 @@\n-        return Box.thread;\n+\n+        \/\/ #3 \"main\" RUNNABLE 2025-04-18T15:22:12.012450Z\n+        \/\/ #36 \"\" virtual WAITING 2025-04-18T15:22:12.012450Z\n+        Pattern pattern = Pattern.compile(\"#(\\\\d+)\\\\s+\\\"([^\\\"]*)\\\"\\\\s+(virtual\\\\s+)?(\\\\w+)\\\\s+(.*)\");\n+        Matcher matcher = pattern.matcher(line);\n+        assertTrue(matcher.matches());\n+        String name = matcher.group(2);\n+        boolean isVirtual = \"virtual \".equals(matcher.group(3));\n+        String state = matcher.group(4);\n+        return new ThreadFields(tid, name, isVirtual, state);\n@@ -308,1 +680,1 @@\n-     * Returns true if a Thread is present in a plain text thread dump.\n+     * Returns true if lines of a plain text thread dump contain the given text.\n@@ -310,3 +682,27 @@\n-    private static boolean isPresent(Path file, Thread thread) throws Exception {\n-        String expect = \"#\" + thread.threadId();\n-        return count(file, expect) > 0;\n+    private boolean contains(List<String> lines, String text) {\n+        return lines.stream().map(String::trim)\n+                .anyMatch(l -> l.contains(text));\n+    }\n+\n+    \/**\n+     * Dump threads to a file in plain text format, return the lines in the file.\n+     *\/\n+    private List<String> dumpThreadsToPlainText() throws Exception {\n+        Path file = genOutputPath(\".txt\");\n+        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        mbean.dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.TEXT_PLAIN);\n+        System.err.format(\"Dumped to %s%n\", file.getFileName());\n+        List<String> lines = Files.readAllLines(file);\n+        return lines;\n+    }\n+\n+    \/**\n+     * Dump threads to a file in JSON format, parse and return as JSON object.\n+     *\/\n+    private static ThreadDump dumpThreadsToJson() throws Exception {\n+        Path file = genOutputPath(\".json\");\n+        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        mbean.dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.JSON);\n+        System.err.format(\"Dumped to %s%n\", file.getFileName());\n+        String jsonText = Files.readString(file);\n+        return ThreadDump.parse(jsonText);\n@@ -326,2 +722,1 @@\n-     * Return the count of the number of files in the given file that contain\n-     * the given character sequence.\n+     * Waits for the given thread to get to a given state.\n@@ -329,3 +724,6 @@\n-    static long count(Path file, CharSequence cs) throws Exception {\n-        try (Stream<String> stream = Files.lines(file)) {\n-            return stream.filter(line -> line.contains(cs)).count();\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n@@ -336,1 +734,1 @@\n-     * Return line $n of the given file.\n+     * Waits for the boolean value to become true.\n@@ -338,3 +736,3 @@\n-    private String line(Path file, long n) throws Exception {\n-        try (Stream<String> stream = Files.lines(file)) {\n-            return stream.skip(n).findFirst().orElseThrow();\n+    private static void awaitTrue(AtomicBoolean ref) throws Exception {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java","additions":555,"deletions":157,"binary":false,"changes":712,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356870\n+ * @summary Test HotSpotDiagnosticMXBean.dumpThreads with a thread owning a monitor for\n+ *     an object that is scalar replaced\n+ * @requires !vm.debug & (vm.compMode != \"Xcomp\")\n+ * @requires (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @modules jdk.management\n+ * @library \/test\/lib\n+ * @run main\/othervm DumpThreadsWithEliminatedLock plain platform\n+ * @run main\/othervm DumpThreadsWithEliminatedLock plain virtual\n+ * @run main\/othervm DumpThreadsWithEliminatedLock json platform\n+ * @run main\/othervm DumpThreadsWithEliminatedLock json virtual\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import jdk.test.lib.threaddump.ThreadDump;\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+public class DumpThreadsWithEliminatedLock {\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean plain = switch (args[0]) {\n+            case \"plain\" -> true;\n+            case \"json\"  -> false;\n+            default      -> throw new RuntimeException(\"Unknown dump format\");\n+        };\n+\n+        ThreadFactory factory = switch (args[1]) {\n+            case \"platform\" -> Thread.ofPlatform().factory();\n+            case \"virtual\"  -> Thread.ofVirtual().factory();\n+            default         -> throw new RuntimeException(\"Unknown thread kind\");\n+        };\n+\n+        \/\/ need at least two carriers for JTREG_TEST_THREAD_FACTORY=Virtual\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n+\n+        \/\/ A thread that spins creating and adding to a StringBuffer. StringBuffer is\n+        \/\/ synchronized, assume object will be scalar replaced and the lock eliminated.\n+        var done = new AtomicBoolean();\n+        var ref = new AtomicReference<String>();\n+        Thread thread = factory.newThread(() -> {\n+            while (!done.get()) {\n+                StringBuffer sb = new StringBuffer();\n+                sb.append(System.currentTimeMillis());\n+                String s = sb.toString();\n+                ref.set(s);\n+            }\n+        });\n+        try {\n+            thread.start();\n+            if (plain) {\n+                testPlainFormat();\n+            } else {\n+                testJsonFormat(thread.threadId());\n+            }\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to generate a thread dump in plain text\n+     * format until \"lock is eliminated\" is found in the output.\n+     *\/\n+    private static void testPlainFormat() {\n+        try {\n+            Path file = genOutputPath(\".txt\");\n+            boolean found = false;\n+            int attempts = 0;\n+            while (!found) {\n+                attempts++;\n+                Files.deleteIfExists(file);\n+                ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n+                        .dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.TEXT_PLAIN);\n+                try (Stream<String> stream = Files.lines(file)) {\n+                    found = stream.map(String::trim)\n+                            .anyMatch(l -> l.contains(\"- lock is eliminated\"));\n+                }\n+                System.out.format(\"%s Attempt %d, found: %b%n\", Instant.now(), attempts, found);\n+            }\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to generate a thread dump in JSON format\n+     * until the monitorsOwned.locks array for the given thread has a null lock.\n+     *\/\n+    private static void testJsonFormat(long tid) {\n+        try {\n+            Path file = genOutputPath(\".json\");\n+            boolean found = false;\n+            int attempts = 0;\n+            while (!found) {\n+                attempts++;\n+                Files.deleteIfExists(file);\n+                ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n+                        .dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.JSON);\n+\n+                \/\/ parse thread dump as JSON and find thread\n+                String jsonText = Files.readString(file);\n+                ThreadDump threadDump = ThreadDump.parse(jsonText);\n+                ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                        .findThread(tid)\n+                        .orElse(null);\n+                if (ti == null) {\n+                    throw new RuntimeException(\"Thread \" + tid + \" not found in thread dump\");\n+                }\n+\n+                \/\/ look for null element in ownedMonitors\/locks array\n+                found = ti.ownedMonitors()\n+                        .values()\n+                        .stream()\n+                        .flatMap(List::stream)\n+                        .anyMatch(o -> o == null);\n+                System.out.format(\"%s Attempt %d, found: %b%n\", Instant.now(), attempts, found);\n+            }\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Generate a file path with the given suffix to use as an output file.\n+     *\/\n+    private static Path genOutputPath(String suffix) throws IOException {\n+        Path dir = Path.of(\".\").toAbsolutePath();\n+        Path file = Files.createTempFile(dir, \"dump\", suffix);\n+        Files.delete(file);\n+        return file;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreadsWithEliminatedLock.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.LinkedHashMap;\n@@ -65,0 +66,1 @@\n+ *            \"state\": \"RUNNABLE\",\n@@ -116,4 +118,11 @@\n-    private final long processId;\n-    private final String time;\n-    private final String runtimeVersion;\n-    private ThreadContainer rootThreadContainer;\n+    private final ThreadContainer rootThreadContainer;\n+    private final Map<String, ThreadContainer> nameToThreadContainer;\n+    private final JSONValue threadDumpObj;\n+\n+    private ThreadDump(ThreadContainer rootThreadContainer,\n+                       Map<String, ThreadContainer> nameToThreadContainer,\n+                       JSONValue threadDumpObj) {\n+        this.rootThreadContainer = rootThreadContainer;\n+        this.nameToThreadContainer = nameToThreadContainer;\n+        this.threadDumpObj = threadDumpObj;\n+    }\n@@ -126,3 +135,1 @@\n-        private long owner;\n-        private ThreadContainer parent;\n-        private Set<ThreadInfo> threads;\n+        private final ThreadContainer parent;\n@@ -130,0 +137,1 @@\n+        private final JSONValue containerObj;\n@@ -131,1 +139,1 @@\n-        ThreadContainer(String name) {\n+        ThreadContainer(String name, ThreadContainer parent, JSONValue containerObj) {\n@@ -133,0 +141,17 @@\n+            this.parent = parent;\n+            this.containerObj = containerObj;\n+        }\n+\n+        \/**\n+         * Add a child thread container.\n+         *\/\n+        void addChild(ThreadContainer container) {\n+            children.add(container);\n+        }\n+\n+        \/**\n+         * Returns the value of a property of this thread container, as a string.\n+         *\/\n+        private String getStringProperty(String propertyName) {\n+            JSONValue value = containerObj.get(propertyName);\n+            return (value != null) ? value.asString() : null;\n@@ -146,1 +171,4 @@\n-           return (owner != 0) ? OptionalLong.of(owner) : OptionalLong.empty();\n+            String owner = getStringProperty(\"owner\");\n+            return (owner != null)\n+                    ? OptionalLong.of(Long.parseLong(owner))\n+                    : OptionalLong.empty();\n@@ -167,1 +195,6 @@\n-            return threads.stream();\n+            JSONValue.JSONArray threadsObj = containerObj.get(\"threads\").asArray();\n+            Set<ThreadInfo> threadInfos = new HashSet<>();\n+            for (JSONValue threadObj : threadsObj) {\n+                threadInfos.add(new ThreadInfo(threadObj));\n+            }\n+            return threadInfos.stream();\n@@ -179,15 +212,0 @@\n-        \/**\n-         * Helper method to recursively find a container with the given name.\n-         *\/\n-        ThreadContainer findThreadContainer(String name) {\n-            if (name().equals(name))\n-                return this;\n-            if (name().startsWith(name + \"\/\"))\n-                return this;\n-            return children()\n-                    .map(c -> c.findThreadContainer(name))\n-                    .filter(c -> c != null)\n-                    .findAny()\n-                    .orElse(null);\n-        }\n-\n@@ -219,2 +237,1 @@\n-        private final String name;\n-        private final List<String> stack;\n+        private final JSONValue threadObj;\n@@ -222,4 +239,22 @@\n-        ThreadInfo(long tid, String name, List<String> stack) {\n-            this.tid = tid;\n-            this.name = name;\n-            this.stack = stack;\n+        ThreadInfo(JSONValue threadObj) {\n+            this.tid = Long.parseLong(threadObj.get(\"tid\").asString());\n+            this.threadObj = threadObj;\n+        }\n+\n+        \/**\n+         * Returns the value of a property of this thread object, as a string.\n+         *\/\n+        private String getStringProperty(String propertyName) {\n+            JSONValue value = threadObj.get(propertyName);\n+            return (value != null) ? value.asString() : null;\n+        }\n+\n+        \/**\n+         * Returns the value of a property of an object in this thread object, as a string.\n+         *\/\n+        private String getStringProperty(String objectName, String propertyName) {\n+            if (threadObj.get(objectName) instanceof JSONValue.JSONObject obj\n+                    && obj.get(propertyName) instanceof JSONValue value) {\n+                return value.asString();\n+            }\n+            return null;\n@@ -239,1 +274,37 @@\n-            return name;\n+            return getStringProperty(\"name\");\n+        }\n+\n+        \/**\n+         * Returns the thread state.\n+         *\/\n+        public String state() {\n+            return getStringProperty(\"state\");\n+        }\n+\n+        \/**\n+         * Returns true if virtual thread.\n+         *\/\n+        public boolean isVirtual() {\n+            String s = getStringProperty(\"virtual\");\n+            return (s != null) ? Boolean.parseBoolean(s) : false;\n+        }\n+\n+        \/**\n+         * Returns the thread's parkBlocker.\n+         *\/\n+        public String parkBlocker() {\n+            return getStringProperty(\"parkBlocker\", \"object\");\n+        }\n+\n+        \/**\n+         * Returns the object that the thread is blocked entering its monitor.\n+         *\/\n+        public String blockedOn() {\n+            return getStringProperty(\"blockedOn\");\n+        }\n+\n+        \/**\n+         * Return the object that is the therad is waiting on with Object.wait.\n+         *\/\n+        public String waitingOn() {\n+            return getStringProperty(\"waitingOn\");\n@@ -246,0 +317,5 @@\n+            JSONValue.JSONArray stackObj = threadObj.get(\"stack\").asArray();\n+            List<String> stack = new ArrayList<>();\n+            for (JSONValue steObject : stackObj) {\n+                stack.add(steObject.asString());\n+            }\n@@ -249,0 +325,29 @@\n+        \/**\n+         * Return a map of monitors owned.\n+         *\/\n+        public Map<Integer, List<String>> ownedMonitors() {\n+            Map<Integer, List<String>> ownedMonitors = new HashMap<>();\n+            JSONValue monitorsOwnedObj = threadObj.get(\"monitorsOwned\");\n+            if (monitorsOwnedObj != null) {\n+                for (JSONValue obj : monitorsOwnedObj.asArray()) {\n+                    int depth = Integer.parseInt(obj.get(\"depth\").asString());\n+                    for (JSONValue lock : obj.get(\"locks\").asArray()) {\n+                        ownedMonitors.computeIfAbsent(depth, _ -> new ArrayList<>())\n+                                .add(lock.asString());\n+                    }\n+                }\n+            }\n+            return ownedMonitors;\n+        }\n+\n+        \/**\n+         * If the thread is a mounted virtual thread, return the thread identifier of\n+         * its carrier.\n+         *\/\n+        public OptionalLong carrier() {\n+            String s = getStringProperty(\"carrier\");\n+            return (s != null)\n+                    ? OptionalLong.of(Long.parseLong(s))\n+                    : OptionalLong.empty();\n+        }\n+\n@@ -267,0 +372,1 @@\n+            String name = name();\n@@ -268,2 +374,2 @@\n-                sb.append(\",\");\n-                sb.append(name);\n+                sb.append(\",\")\n+                  .append(name);\n@@ -276,1 +382,1 @@\n-     * Parses the given JSON text as a thread dump.\n+     * Returns the value of a property of this thread dump, as a string.\n@@ -278,46 +384,3 @@\n-    private ThreadDump(String json) {\n-        JSONValue threadDumpObj = JSONValue.parse(json).get(\"threadDump\");\n-\n-        \/\/ maps container name to ThreadContainer\n-        Map<String, ThreadContainer> map = new HashMap<>();\n-\n-        \/\/ threadContainers array\n-        JSONValue threadContainersObj = threadDumpObj.get(\"threadContainers\");\n-        for (JSONValue containerObj : threadContainersObj.asArray()) {\n-            String name = containerObj.get(\"container\").asString();\n-            String parentName = containerObj.get(\"parent\").asString();\n-            String owner = containerObj.get(\"owner\").asString();\n-            JSONValue.JSONArray threadsObj = containerObj.get(\"threads\").asArray();\n-\n-            \/\/ threads array\n-            Set<ThreadInfo> threadInfos = new HashSet<>();\n-            for (JSONValue threadObj : threadsObj) {\n-                long tid = Long.parseLong(threadObj.get(\"tid\").asString());\n-                String threadName = threadObj.get(\"name\").asString();\n-                JSONValue.JSONArray stackObj = threadObj.get(\"stack\").asArray();\n-                List<String> stack = new ArrayList<>();\n-                for (JSONValue steObject : stackObj) {\n-                    stack.add(steObject.asString());\n-                }\n-                threadInfos.add(new ThreadInfo(tid, threadName, stack));\n-            }\n-\n-            \/\/ add to map if not already encountered\n-            var container = map.computeIfAbsent(name, k -> new ThreadContainer(name));\n-            if (owner != null)\n-                container.owner = Long.parseLong(owner);\n-            container.threads = threadInfos;\n-\n-            if (parentName == null) {\n-                rootThreadContainer = container;\n-            } else {\n-                \/\/ add parent to map if not already encountered and add to its set of children\n-                var parent = map.computeIfAbsent(parentName, k -> new ThreadContainer(parentName));\n-                container.parent = parent;\n-                parent.children.add(container);\n-            }\n-        }\n-\n-        this.processId = Long.parseLong(threadDumpObj.get(\"processId\").asString());\n-        this.time = threadDumpObj.get(\"time\").asString();\n-        this.runtimeVersion = threadDumpObj.get(\"runtimeVersion\").asString();\n+    private String getStringProperty(String propertyName) {\n+        JSONValue value = threadDumpObj.get(propertyName);\n+        return (value != null) ? value.asString() : null;\n@@ -330,1 +393,1 @@\n-        return processId;\n+        return Long.parseLong(getStringProperty(\"processId\"));\n@@ -337,1 +400,1 @@\n-        return time;\n+        return getStringProperty(\"time\");\n@@ -344,1 +407,1 @@\n-        return runtimeVersion;\n+        return getStringProperty(\"runtimeVersion\");\n@@ -358,2 +421,11 @@\n-        ThreadContainer container = rootThreadContainer.findThreadContainer(name);\n-        return Optional.ofNullable(container);\n+        ThreadContainer container = nameToThreadContainer.get(name);\n+        if (container == null) {\n+            \/\/ may be name\/identity format\n+            container = nameToThreadContainer.entrySet()\n+                    .stream()\n+                    .filter(e -> e.getKey().startsWith(name + \"\/\"))\n+                    .map(e -> e.getValue())\n+                    .findAny()\n+                    .orElse(null);\n+        }\n+        return Optional.of(container);\n@@ -367,1 +439,31 @@\n-        return new ThreadDump(json);\n+        JSONValue threadDumpObj = JSONValue.parse(json).get(\"threadDump\");\n+\n+        \/\/ threadContainers array, preserve insertion order (parents are added before children)\n+        Map<String, JSONValue> containerObjs = new LinkedHashMap<>();\n+        JSONValue threadContainersObj = threadDumpObj.get(\"threadContainers\");\n+        for (JSONValue containerObj : threadContainersObj.asArray()) {\n+            String name = containerObj.get(\"container\").asString();\n+            containerObjs.put(name, containerObj);\n+        }\n+\n+        \/\/ find root and create tree of thread containers\n+        ThreadContainer root = null;\n+        Map<String, ThreadContainer> map = new HashMap<>();\n+        for (String name : containerObjs.keySet()) {\n+            JSONValue containerObj = containerObjs.get(name);\n+            String parentName = containerObj.get(\"parent\").asString();\n+            if (parentName == null) {\n+                root = new ThreadContainer(name, null, containerObj);\n+                map.put(name, root);\n+            } else {\n+                var parent = map.get(parentName);\n+                if (parent == null) {\n+                    throw new RuntimeException(\"Thread container \" + name + \" found before \" + parentName);\n+                }\n+                var container = new ThreadContainer(name, parent, containerObj);\n+                parent.addChild(container);\n+                map.put(name, container);\n+            }\n+        }\n+\n+        return new ThreadDump(root, map, threadDumpObj);\n@@ -369,1 +471,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/lib\/jdk\/test\/lib\/threaddump\/ThreadDump.java","additions":191,"deletions":89,"binary":false,"changes":280,"status":"modified"}]}