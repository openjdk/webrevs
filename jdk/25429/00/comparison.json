{"files":[{"patch":"@@ -69,0 +69,1 @@\n+#include \"prims\/jvmtiThreadState.hpp\" \/\/ for JvmtiVTMSTransitionDisabler\n@@ -86,0 +87,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1875,1 +1877,1 @@\n-  return java_thread->obj_field(_park_blocker_offset);\n+  return java_thread->obj_field_acquire(_park_blocker_offset);\n@@ -1878,0 +1880,237 @@\n+class GetThreadSnapshotClosure : public HandshakeClosure {\n+public:\n+  struct OwnedLock {\n+    \/\/ should be synced with ordinals of jdk.internal.vm.ThreadSnapshot.OwnedLockType enum\n+    enum Type {\n+      NOTHING = -1,\n+      LOCKED = 0,\n+      ELIMINATED = 1,\n+    };\n+\n+    int _depth;\n+    Type _type;\n+    OopHandle _obj;\n+\n+    OwnedLock(int depth, Type type, OopHandle obj): _depth(depth), _type(type), _obj(obj) {}\n+    OwnedLock(): _depth(0), _type(NOTHING), _obj(nullptr) {}\n+  };\n+\n+  struct Blocker {\n+    \/\/ should be synced with ordinals of jdk.internal.vm.ThreadSnapshot.BlockerLockType enum\n+    enum Type {\n+      NOTHING = -1,\n+      PARK_BLOCKER = 0,\n+      WAITING_TO_LOCK = 1,\n+      WAITING_ON = 2,\n+    };\n+\n+    Type _type;\n+    OopHandle _obj;\n+\n+    Blocker(Type type, OopHandle obj): _type(type), _obj(obj) {}\n+    Blocker(): _type(NOTHING), _obj(nullptr) {}\n+\n+    bool is_empty() const {\n+      return _type == NOTHING;\n+    }\n+  };\n+\n+  Handle _java_thread;\n+  JavaThread* _thread;\n+  int _depth;\n+  bool _retry_handshake;\n+  GrowableArray<Method*>* _methods;\n+  GrowableArray<int>* _bcis;\n+  JavaThreadStatus _thread_status;\n+  OopHandle _name;\n+  GrowableArray<OwnedLock>* _locks;\n+  Blocker _blocker;\n+  OopHandle _blocker_owner;\n+\n+  GetThreadSnapshotClosure(JavaThread* calling_thread, Handle java_thread, JavaThread* thread) :\n+      HandshakeClosure(\"GetThreadSnapshotClosure\"),\n+      _java_thread(java_thread), _thread(thread),\n+      _depth(0), _retry_handshake(false),\n+      _methods(nullptr), _bcis(nullptr),\n+      _thread_status(), _name(nullptr),\n+      _locks(nullptr), _blocker(), _blocker_owner(nullptr) { }\n+  virtual ~GetThreadSnapshotClosure() {\n+    delete _methods;\n+    delete _bcis;\n+    _name.release(Universe::vm_global());\n+    if (_locks != nullptr) {\n+      for (int i = 0; i < _locks->length(); i++) {\n+        _locks->at(i)._obj.release(Universe::vm_global());\n+      }\n+      delete _locks;\n+    }\n+    _blocker._obj.release(Universe::vm_global());\n+    _blocker_owner.release(Universe::vm_global());\n+  }\n+\n+  bool read_reset_retry() {\n+    bool ret = _retry_handshake;\n+    \/\/ If we re-execute the handshake this method need to return false\n+    \/\/ when the handshake cannot be performed. (E.g. thread terminating)\n+    _retry_handshake = false;\n+    return ret;\n+  }\n+\n+private:\n+  void detect_locks(javaVFrame* jvf, int depth) {\n+    Thread* current = Thread::current();\n+\n+    if (depth == 0 && _blocker.is_empty()) {\n+      \/\/ If this is the first frame and it is java.lang.Object.wait(...)\n+      \/\/ then print out the receiver.\n+      if (jvf->method()->name() == vmSymbols::wait_name() &&\n+          jvf->method()->method_holder()->name() == vmSymbols::java_lang_Object()) {\n+        OopHandle lock_object;\n+        StackValueCollection* locs = jvf->locals();\n+        if (!locs->is_empty()) {\n+          StackValue* sv = locs->at(0);\n+          if (sv->type() == T_OBJECT) {\n+            Handle o = locs->at(0)->get_obj();\n+            lock_object = OopHandle(Universe::vm_global(), o());\n+          }\n+        }\n+\n+        _blocker = Blocker(Blocker::WAITING_ON, lock_object);\n+      }\n+    }\n+\n+    GrowableArray<MonitorInfo*>* mons = jvf->monitors();\n+    if (!mons->is_empty()) {\n+      for (int index = (mons->length() - 1); index >= 0; index--) {\n+        MonitorInfo* monitor = mons->at(index);\n+        if (monitor->eliminated() && jvf->is_compiled_frame()) { \/\/ Eliminated in compiled code\n+          if (monitor->owner_is_scalar_replaced()) {\n+            Klass* k = java_lang_Class::as_Klass(monitor->owner_klass());\n+            _locks->push(OwnedLock(depth, OwnedLock::ELIMINATED, OopHandle(Universe::vm_global(), k->klass_holder())));\n+          } else {\n+            Handle owner(current, monitor->owner());\n+            if (owner.not_null()) {\n+              Klass* k = owner->klass();\n+              _locks->push(OwnedLock(depth, OwnedLock::ELIMINATED, OopHandle(Universe::vm_global(), k->klass_holder())));\n+            }\n+          }\n+          continue;\n+        }\n+        if (monitor->owner() != nullptr) {\n+          \/\/ the monitor is associated with an object, i.e., it is locked\n+\n+          if (depth == 0 && _blocker.is_empty()) {\n+            ObjectMonitor* pending_moninor = java_lang_VirtualThread::is_instance(_java_thread())\n+                           ? java_lang_VirtualThread::current_pending_monitor(_java_thread())\n+                           : jvf->thread()->current_pending_monitor();\n+\n+            markWord mark = monitor->owner()->mark();\n+            \/\/ The first stage of async deflation does not affect any field\n+            \/\/ used by this comparison so the ObjectMonitor* is usable here.\n+            if (mark.has_monitor()) {\n+              ObjectMonitor* mon = ObjectSynchronizer::read_monitor(current, monitor->owner(), mark);\n+              if (\/\/ if the monitor is null we must be in the process of locking\n+                  mon == nullptr ||\n+                  \/\/ we have marked ourself as pending on this monitor\n+                  mon == pending_moninor ||\n+                  \/\/ we are not the owner of this monitor\n+                  (_thread != nullptr && !mon->is_entered(_thread))) {\n+                _blocker = Blocker(Blocker::WAITING_TO_LOCK, OopHandle(Universe::vm_global(), monitor->owner()));\n+                continue; \/\/ go to next monitor\n+              }\n+            }\n+          }\n+          _locks->push(OwnedLock(depth, OwnedLock::LOCKED, OopHandle(Universe::vm_global(), monitor->owner())));\n+        }\n+      }\n+    }\n+  }\n+\n+public:\n+  void do_thread(Thread* th) override {\n+    Thread* current = Thread::current();\n+    if (!current->is_Java_thread()) {\n+      _retry_handshake = true;\n+      return;\n+    }\n+\n+    bool is_virtual = java_lang_VirtualThread::is_instance(_java_thread());\n+    if (_thread != nullptr) {\n+      if (is_virtual) {\n+        \/\/ mounted vthread, use carrier thread state\n+        oop carrier_thread = java_lang_VirtualThread::carrier_thread(_java_thread());\n+        _thread_status = java_lang_Thread::get_thread_status(carrier_thread);\n+      } else {\n+        _thread_status = java_lang_Thread::get_thread_status(_java_thread());\n+      }\n+    } else {\n+      \/\/ unmounted vthread\n+      int vt_state = java_lang_VirtualThread::state(_java_thread());\n+      _thread_status = java_lang_VirtualThread::map_state_to_thread_status(vt_state);\n+    }\n+    _name = OopHandle(Universe::vm_global(), java_lang_Thread::name(_java_thread()));\n+\n+    if (_thread != nullptr && !_thread->has_last_Java_frame()) {\n+      \/\/ stack trace is empty\n+      return;\n+    }\n+\n+    bool walk_cont = false;\n+\n+    if (is_virtual) {\n+      if (_thread != nullptr) {\n+        \/\/ if (thread->vthread() != _java_thread()) \/\/ We might be inside a System.executeOnCarrierThread\n+        const ContinuationEntry* ce = _thread->vthread_continuation();\n+        if (ce == nullptr || ce->cont_oop(_thread) != java_lang_VirtualThread::continuation(_java_thread())) {\n+          \/\/ TODO: handle\n+        }\n+      }\n+    } else {\n+      walk_cont = (_thread->vthread_continuation() != nullptr);\n+    }\n+\n+    oop park_blocker = java_lang_Thread::park_blocker(_java_thread());\n+    if (park_blocker != nullptr) {\n+      _blocker = Blocker(Blocker::PARK_BLOCKER, OopHandle(Universe::vm_global(), park_blocker));\n+      if (park_blocker->is_a(vmClasses::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {\n+        oop blocker_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(park_blocker);\n+        _blocker_owner = OopHandle(Universe::vm_global(), blocker_owner);\n+      }\n+    }\n+\n+    ResourceMark rm(current);\n+    HandleMark hm(current);\n+\n+    const int max_depth = MaxJavaStackTraceDepth;\n+    const bool skip_hidden = !ShowHiddenFrames;\n+\n+    \/\/ Pick minimum length that will cover most cases\n+    int init_length = 64;\n+    _methods = new (mtInternal) GrowableArray<Method*>(init_length, mtInternal);\n+    _bcis = new (mtInternal) GrowableArray<int>(init_length, mtInternal);\n+    _locks = new (mtInternal) GrowableArray<OwnedLock>(init_length, mtInternal);\n+    int total_count = 0;\n+\n+    vframeStream vfst(_thread != nullptr\n+        ? vframeStream(_thread, false, true, walk_cont)\n+        : vframeStream(java_lang_VirtualThread::continuation(_java_thread())));\n+\n+    for (;\n+        !vfst.at_end() && (max_depth == 0 || max_depth != total_count);\n+        vfst.next()) {\n+\n+      detect_locks(vfst.asJavaVFrame(), total_count);\n+\n+      if (skip_hidden && (vfst.method()->is_hidden() ||\n+        vfst.method()->is_continuation_enter_intrinsic())) {\n+        continue;\n+      }\n+      _methods->push(vfst.method());\n+      _bcis->push(vfst.bci());\n+      total_count++;\n+    }\n+\n+    _depth = total_count;\n+  }\n+};\n+\n@@ -2002,0 +2241,221 @@\n+class jdk_internal_vm_ThreadLock: AllStatic {\n+  static bool _inited;\n+  static int _depth_offset;\n+  static int _typeOrdinal_offset;\n+  static int _obj_offset;\n+\n+  static void compute_offsets(InstanceKlass * klass, TRAPS) {\n+    JavaClasses::compute_offset(_depth_offset, klass, \"depth\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_typeOrdinal_offset, klass, \"typeOrdinal\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_obj_offset, klass, \"obj\", vmSymbols::object_signature(), false);\n+  }\n+public:\n+  static void init(InstanceKlass* klass, TRAPS) {\n+    if (!_inited) {\n+      compute_offsets(klass, CHECK);\n+      _inited = true;\n+    }\n+  }\n+\n+  static Handle create(InstanceKlass* klass, int depth, int type_ordinal, OopHandle obj, TRAPS) {\n+    init(klass, CHECK_NH);\n+    Handle result = klass->allocate_instance_handle(CHECK_NH);\n+    result->int_field_put(_depth_offset, depth);\n+    result->int_field_put(_typeOrdinal_offset, type_ordinal);\n+    result->obj_field_put(_obj_offset, obj.resolve());\n+    return result;\n+  }\n+};\n+\n+bool jdk_internal_vm_ThreadLock::_inited = false;\n+int jdk_internal_vm_ThreadLock::_depth_offset;\n+int jdk_internal_vm_ThreadLock::_typeOrdinal_offset;\n+int jdk_internal_vm_ThreadLock::_obj_offset;\n+\n+class jdk_internal_vm_ThreadSnapshot: AllStatic {\n+  static bool _inited;\n+  static int _name_offset;\n+  static int _threadStatus_offset;\n+  static int _carrierThread_offset;\n+  static int _stackTrace_offset;\n+  static int _locks_offset;\n+  static int _blockerTypeOrdinal_offset;\n+  static int _blockerObject_offset;\n+  static int _blockerOwner_offset;\n+\n+  static void compute_offsets(InstanceKlass* klass, TRAPS) {\n+    JavaClasses::compute_offset(_name_offset, klass, \"name\", vmSymbols::string_signature(), false);\n+    JavaClasses::compute_offset(_threadStatus_offset, klass, \"threadStatus\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_carrierThread_offset, klass, \"carrierThread\", vmSymbols::thread_signature(), false);\n+    JavaClasses::compute_offset(_stackTrace_offset, klass, \"stackTrace\", vmSymbols::java_lang_StackTraceElement_array(), false);\n+    JavaClasses::compute_offset(_locks_offset, klass, \"locks\", vmSymbols::jdk_internal_vm_ThreadLock_array(), false);\n+    JavaClasses::compute_offset(_blockerTypeOrdinal_offset, klass, \"blockerTypeOrdinal\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_blockerObject_offset, klass, \"blockerObject\", vmSymbols::object_signature(), false);\n+    JavaClasses::compute_offset(_blockerOwner_offset, klass, \"blockerOwner\", vmSymbols::object_signature(), false);\n+  }\n+public:\n+  static void init(InstanceKlass* klass, TRAPS) {\n+    if (!_inited) {\n+      compute_offsets(klass, CHECK);\n+      _inited = true;\n+    }\n+  }\n+\n+  static Handle allocate(InstanceKlass* klass, TRAPS) {\n+    init(klass, CHECK_NH);\n+    return klass->allocate_instance_handle(CHECK_NH);\n+  }\n+\n+  static void set_name(oop snapshot, oop name) {\n+    snapshot->obj_field_put(_name_offset, name);\n+  }\n+  static void set_thread_status(oop snapshot, int status) {\n+    snapshot->int_field_put(_threadStatus_offset, status);\n+  }\n+  static void set_carrier_thread(oop snapshot, oop carrier_thread) {\n+    snapshot->obj_field_put(_carrierThread_offset, carrier_thread);\n+  }\n+  static void set_stack_trace(oop snapshot, oop trace) {\n+    snapshot->obj_field_put(_stackTrace_offset, trace);\n+  }\n+  static void set_locks(oop snapshot, oop locks) {\n+    snapshot->obj_field_put(_locks_offset, locks);\n+  }\n+  static void set_blocker(oop snapshot, int type_ordinal, oop lock) {\n+    snapshot->int_field_put(_blockerTypeOrdinal_offset, type_ordinal);\n+    snapshot->obj_field_put(_blockerObject_offset, lock);\n+  }\n+  static void set_blocker_owner(oop snapshot, oop owner) {\n+    snapshot->obj_field_put(_blockerOwner_offset, owner);\n+  }\n+};\n+\n+bool jdk_internal_vm_ThreadSnapshot::_inited = false;\n+int jdk_internal_vm_ThreadSnapshot::_name_offset;\n+int jdk_internal_vm_ThreadSnapshot::_threadStatus_offset;\n+int jdk_internal_vm_ThreadSnapshot::_carrierThread_offset;\n+int jdk_internal_vm_ThreadSnapshot::_stackTrace_offset;\n+int jdk_internal_vm_ThreadSnapshot::_locks_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerTypeOrdinal_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerObject_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerOwner_offset;\n+\n+oop java_lang_Thread::get_thread_snapshot(jobject jthread, TRAPS) {\n+  ThreadsListHandle tlh(THREAD);\n+\n+  ResourceMark rm(THREAD);\n+  HandleMark   hm(THREAD);\n+  Handle java_thread(THREAD, JNIHandles::resolve(jthread));\n+\n+  \/\/ wrapper to auto delete JvmtiVTMSTransitionDisabler\n+  class TransitionDisabler {\n+    JvmtiVTMSTransitionDisabler* _transition_disabler;\n+  public:\n+    TransitionDisabler() : _transition_disabler(nullptr) {}\n+    ~TransitionDisabler() {\n+      reset();\n+    }\n+    void init(jobject jthread) {\n+      _transition_disabler = new (mtInternal) JvmtiVTMSTransitionDisabler(jthread);\n+    }\n+    void reset() {\n+      if (_transition_disabler != nullptr) {\n+        delete _transition_disabler;\n+        _transition_disabler = nullptr;\n+      }\n+    }\n+  } transition_disabler;\n+\n+  JavaThread* thread = nullptr;\n+  bool is_virtual = java_lang_VirtualThread::is_instance(java_thread());\n+  Handle carrier_thread;\n+  if (is_virtual) {\n+    \/\/ 1st need to disable mount\/unmount transitions\n+    transition_disabler.init(jthread);\n+\n+    carrier_thread = Handle(THREAD, java_lang_VirtualThread::carrier_thread(java_thread()));\n+    if (carrier_thread != nullptr) {\n+      thread = java_lang_Thread::thread(carrier_thread());\n+    }\n+  } else {\n+    thread = java_lang_Thread::thread(java_thread());\n+  }\n+\n+  \/\/ Handshake with target\n+  GetThreadSnapshotClosure cl(THREAD, java_thread, thread);\n+  if (thread == nullptr) {\n+    \/\/ unmounted vthread, execute on the current thread\n+    cl.do_thread(nullptr);\n+  } else {\n+    do {\n+      Handshake::execute(&cl, &tlh, thread);\n+    } while (cl.read_reset_retry());\n+  }\n+\n+  \/\/ all info is collected, can enable transitions.\n+  transition_disabler.reset();\n+\n+  \/\/ StackTrace\n+  InstanceKlass* ste_klass = vmClasses::StackTraceElement_klass();\n+  assert(ste_klass != nullptr, \"must be loaded in 1.4+\");\n+  if (ste_klass->should_be_initialized()) {\n+    ste_klass->initialize(CHECK_NULL);\n+  }\n+\n+  objArrayHandle trace = oopFactory::new_objArray_handle(ste_klass, cl._depth, CHECK_NULL);\n+\n+  for (int i = 0; i < cl._depth; i++) {\n+    methodHandle method(THREAD, cl._methods->at(i));\n+    oop element = java_lang_StackTraceElement::create(method, cl._bcis->at(i), CHECK_NULL);\n+    trace->obj_at_put(i, element);\n+  }\n+\n+  \/\/ Locks\n+  Symbol* lock_sym = vmSymbols::jdk_internal_vm_ThreadLock();\n+  Klass* lock_k = SystemDictionary::resolve_or_fail(lock_sym, true, CHECK_NULL);\n+  InstanceKlass* lock_klass = InstanceKlass::cast(lock_k);\n+\n+  objArrayHandle locks;\n+  if (cl._locks != nullptr && cl._locks->length() > 0) {\n+    locks = oopFactory::new_objArray_handle(lock_klass, cl._locks->length(), CHECK_NULL);\n+    for (int n = 0; n < cl._locks->length(); n++) {\n+      GetThreadSnapshotClosure::OwnedLock* lock_info = cl._locks->adr_at(n);\n+\n+      Handle lock = jdk_internal_vm_ThreadLock::create(lock_klass,\n+        lock_info->_depth, lock_info->_type, lock_info->_obj, CHECK_NULL);\n+      locks->obj_at_put(n, lock());\n+    }\n+  }\n+\n+  \/\/ call static StackTraceElement[] StackTraceElement.of(StackTraceElement[] stackTrace)\n+  \/\/ to properly initialize STE.\n+  {\n+    JavaValue result(T_OBJECT);\n+    JavaCalls::call_static(&result,\n+                           ste_klass,\n+                           vmSymbols::java_lang_StackTraceElement_of_name(),\n+                           vmSymbols::java_lang_StackTraceElement_of_signature(),\n+                           trace,\n+                           CHECK_NULL);\n+    \/\/ the method return the same trace object\n+  }\n+\n+  Symbol* snapshot_klass_name = vmSymbols::jdk_internal_vm_ThreadSnapshot();\n+  Klass* snapshot_klass = SystemDictionary::resolve_or_fail(snapshot_klass_name, true, CHECK_NULL);\n+  if (snapshot_klass->should_be_initialized()) {\n+    snapshot_klass->initialize(CHECK_NULL);\n+  }\n+\n+  Handle snapshot = jdk_internal_vm_ThreadSnapshot::allocate(InstanceKlass::cast(snapshot_klass), CHECK_NULL);\n+  jdk_internal_vm_ThreadSnapshot::set_name(snapshot(), cl._name.resolve());\n+  jdk_internal_vm_ThreadSnapshot::set_thread_status(snapshot(), (int)cl._thread_status);\n+  jdk_internal_vm_ThreadSnapshot::set_carrier_thread(snapshot(), carrier_thread());\n+  jdk_internal_vm_ThreadSnapshot::set_stack_trace(snapshot(), trace());\n+  jdk_internal_vm_ThreadSnapshot::set_locks(snapshot(), locks());\n+  if (!cl._blocker.is_empty()) {\n+    jdk_internal_vm_ThreadSnapshot::set_blocker(snapshot(), cl._blocker._type, cl._blocker._obj.resolve());\n+    jdk_internal_vm_ThreadSnapshot::set_blocker_owner(snapshot(), cl._blocker_owner.resolve());\n+  }\n+  return snapshot();\n+}\n+\n@@ -5059,1 +5519,1 @@\n-  return obj->obj_field(_owner_offset);\n+  return obj->obj_field_acquire(_owner_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":462,"deletions":2,"binary":false,"changes":464,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+  static oop get_thread_snapshot(jobject jthread, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -745,0 +745,6 @@\n+  template(jdk_internal_vm_ThreadSnapshot,         \"jdk\/internal\/vm\/ThreadSnapshot\")                              \\\n+  template(jdk_internal_vm_ThreadLock,             \"jdk\/internal\/vm\/ThreadSnapshot$ThreadLock\")                   \\\n+  template(jdk_internal_vm_ThreadLock_signature,   \"Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                 \\\n+  template(jdk_internal_vm_ThreadLock_array,       \"[Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                \\\n+  template(java_lang_StackTraceElement_of_name,    \"of\")                                                          \\\n+  template(java_lang_StackTraceElement_of_signature, \"([Ljava\/lang\/StackTraceElement;)[Ljava\/lang\/StackTraceElement;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -304,0 +304,3 @@\n+JNIEXPORT jobject JNICALL\n+JVM_CreateThreadSnapshot(JNIEnv* env, jobject thread);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2964,0 +2964,5 @@\n+JVM_ENTRY(jobject, JVM_CreateThreadSnapshot(JNIEnv* env, jobject jthread))\n+  oop snapshot = java_lang_Thread::get_thread_snapshot(jthread, THREAD);\n+  return JNIHandles::make_local(THREAD, snapshot);\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-class JvmtiVTMSTransitionDisabler {\n+class JvmtiVTMSTransitionDisabler : public AnyObj {\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import java.io.BufferedOutputStream;\n+import java.io.BufferedWriter;\n@@ -31,1 +31,3 @@\n-import java.io.PrintStream;\n+import java.io.OutputStreamWriter;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n@@ -39,1 +41,3 @@\n-import java.util.ArrayList;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n@@ -42,0 +46,2 @@\n+import java.util.Objects;\n+import java.util.concurrent.locks.AbstractOwnableSynchronizer;\n@@ -46,2 +52,3 @@\n- * This class defines methods to dump threads to an output stream or file in plain\n- * text or JSON format.\n+ * This class defines static methods to support the Thread.dump_to_file diagnostic command\n+ * and the HotSpotDiagnosticMXBean.dumpThreads API. It defines methods to generate a\n+ * thread dump to a file or byte array in plain text or JSON format.\n@@ -56,2 +63,1 @@\n-     * Generate a thread dump in plain text format to a byte array or file, UTF-8 encoded.\n-     *\n+     * Generate a thread dump in plain text format to a file or byte array, UTF-8 encoded.\n@@ -62,1 +68,1 @@\n-     * @return the UTF-8 encoded thread dump or message to return to the user\n+     * @return the UTF-8 encoded thread dump or message to return to the tool user\n@@ -73,2 +79,1 @@\n-     * Generate a thread dump in JSON format to a byte array or file, UTF-8 encoded.\n-     *\n+     * Generate a thread dump in JSON format to a file or byte array, UTF-8 encoded.\n@@ -79,1 +84,1 @@\n-     * @return the UTF-8 encoded thread dump or message to return to the user\n+     * @return the UTF-8 encoded thread dump or message to return to the tool user\n@@ -91,0 +96,3 @@\n+     * This method is the implementation of the Thread.dump_to_file diagnostic command\n+     * when a file path is not specified. It returns the thread and\/or message to send\n+     * to the tool user.\n@@ -93,2 +101,2 @@\n-        try (var out = new BoundedByteArrayOutputStream(maxSize);\n-             PrintStream ps = new PrintStream(out, true, StandardCharsets.UTF_8)) {\n+        var out = new BoundedByteArrayOutputStream(maxSize);\n+        try (out; var writer = new TextWriter(out)) {\n@@ -96,1 +104,1 @@\n-                dumpThreadsToJson(ps);\n+                dumpThreadsToJson(writer);\n@@ -98,1 +106,1 @@\n-                dumpThreads(ps);\n+                dumpThreads(writer);\n@@ -100,1 +108,6 @@\n-            return out.toByteArray();\n+        } catch (Exception ex) {\n+            if (ex instanceof UncheckedIOException ioe) {\n+                ex = ioe.getCause();\n+            }\n+            String reply = String.format(\"Failed: %s%n\", ex);\n+            return reply.getBytes(StandardCharsets.UTF_8);\n@@ -102,0 +115,1 @@\n+        return out.toByteArray();\n@@ -106,0 +120,2 @@\n+     * This method is the implementation of the Thread.dump_to_file diagnostic command.\n+     * It returns the thread and\/or message to send to the tool user.\n@@ -113,7 +129,10 @@\n-        try (OutputStream out = Files.newOutputStream(path, options);\n-             BufferedOutputStream bos = new BufferedOutputStream(out);\n-             PrintStream ps = new PrintStream(bos, false, StandardCharsets.UTF_8)) {\n-            if (json) {\n-                dumpThreadsToJson(ps);\n-            } else {\n-                dumpThreads(ps);\n+        try (OutputStream out = Files.newOutputStream(path, options)) {\n+            try (var writer = new TextWriter(out)) {\n+                if (json) {\n+                    dumpThreadsToJson(writer);\n+                } else {\n+                    dumpThreads(writer);\n+                }\n+                reply = String.format(\"Created %s%n\", path);\n+            } catch (UncheckedIOException e) {\n+                reply = String.format(\"Failed: %s%n\", e.getCause());\n@@ -121,2 +140,1 @@\n-            reply = String.format(\"Created %s%n\", path);\n-        } catch (FileAlreadyExistsException e) {\n+        } catch (FileAlreadyExistsException _) {\n@@ -124,2 +142,2 @@\n-        } catch (IOException ioe) {\n-            reply = String.format(\"Failed: %s%n\", ioe);\n+        } catch (Exception ex) {\n+            reply = String.format(\"Failed: %s%n\", ex);\n@@ -131,4 +149,3 @@\n-     * Generate a thread dump in plain text format to the given output stream,\n-     * UTF-8 encoded.\n-     *\n-     * This method is invoked by HotSpotDiagnosticMXBean.dumpThreads.\n+     * Generate a thread dump in plain text format to the given output stream, UTF-8\n+     * encoded. This method is invoked by HotSpotDiagnosticMXBean.dumpThreads.\n+     * @throws IOException if an I\/O error occurs\n@@ -136,3 +153,2 @@\n-    public static void dumpThreads(OutputStream out) {\n-        BufferedOutputStream bos = new BufferedOutputStream(out);\n-        PrintStream ps = new PrintStream(bos, false, StandardCharsets.UTF_8);\n+    public static void dumpThreads(OutputStream out) throws IOException {\n+        var writer = new TextWriter(out);\n@@ -140,3 +156,5 @@\n-            dumpThreads(ps);\n-        } finally {\n-            ps.flush();  \/\/ flushes underlying stream\n+            dumpThreads(writer);\n+            writer.flush();\n+        } catch (UncheckedIOException e) {\n+            IOException ioe = e.getCause();\n+            throw ioe;\n@@ -147,1 +165,2 @@\n-     * Generate a thread dump in plain text format to the given print stream.\n+     * Generate a thread dump in plain text format to the given text stream.\n+     * @throws UncheckedIOException if an I\/O error occurs\n@@ -149,6 +168,6 @@\n-    private static void dumpThreads(PrintStream ps) {\n-        ps.println(processId());\n-        ps.println(Instant.now());\n-        ps.println(Runtime.version());\n-        ps.println();\n-        dumpThreads(ThreadContainers.root(), ps);\n+    private static void dumpThreads(TextWriter writer) {\n+        writer.println(processId());\n+        writer.println(Instant.now());\n+        writer.println(Runtime.version());\n+        writer.println();\n+        dumpThreads(ThreadContainers.root(), writer);\n@@ -157,3 +176,3 @@\n-    private static void dumpThreads(ThreadContainer container, PrintStream ps) {\n-        container.threads().forEach(t -> dumpThread(t, ps));\n-        container.children().forEach(c -> dumpThreads(c, ps));\n+    private static void dumpThreads(ThreadContainer container, TextWriter writer) {\n+        container.threads().forEach(t -> dumpThread(t, writer));\n+        container.children().forEach(c -> dumpThreads(c, writer));\n@@ -162,6 +181,39 @@\n-    private static void dumpThread(Thread thread, PrintStream ps) {\n-        String suffix = thread.isVirtual() ? \" virtual\" : \"\";\n-        ps.println(\"#\" + thread.threadId() + \" \\\"\" + thread.getName() + \"\\\"\" + suffix);\n-        for (StackTraceElement ste : thread.getStackTrace()) {\n-            ps.print(\"      \");\n-            ps.println(ste);\n+    private static void dumpThread(Thread thread, TextWriter writer) {\n+        ThreadSnapshot snapshot = ThreadSnapshot.of(thread);\n+        Instant now = Instant.now();\n+        Thread.State state = snapshot.threadState();\n+        writer.println(\"#\" + thread.threadId() + \" \\\"\" + snapshot.threadName()\n+                +  \"\\\" \" + (thread.isVirtual() ? \"virtual \" : \"\") + state + \" \" + now);\n+\n+        \/\/ park blocker\n+        Object parkBlocker = snapshot.parkBlocker();\n+        if (parkBlocker != null) {\n+            writer.print(\"      \/\/ parked on \" + Objects.toIdentityString(parkBlocker));\n+            if (parkBlocker instanceof AbstractOwnableSynchronizer\n+                    && snapshot.exclusiveOwnerThread() instanceof Thread owner) {\n+                writer.print(\", owned by #\" + owner.threadId());\n+            }\n+            writer.println();\n+        }\n+\n+        \/\/ blocked on monitor enter or Object.wait\n+        if (state == Thread.State.BLOCKED && snapshot.blockedOn() instanceof Object obj) {\n+            writer.println(\"      \/\/ blocked on \" + Objects.toIdentityString(obj));\n+        } else if ((state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING)\n+                && snapshot.waitingOn() instanceof Object obj) {\n+            writer.println(\"      \/\/ waiting on \" + Objects.toIdentityString(obj));\n+        }\n+\n+        StackTraceElement[] stackTrace = snapshot.stackTrace();\n+        int depth = 0;\n+        while (depth < stackTrace.length) {\n+            snapshot.ownedMonitorsAt(depth).forEach(o -> {\n+                if (o != null) {\n+                    writer.println(\"      \/\/ locked \" + Objects.toIdentityString(o));\n+                } else {\n+                    writer.println(\"      \/\/ lock is eliminated\");\n+                }\n+            });\n+            writer.print(\"      \");\n+            writer.println(stackTrace[depth]);\n+            depth++;\n@@ -169,1 +221,1 @@\n-        ps.println();\n+        writer.println();\n@@ -174,1 +226,0 @@\n-     *\n@@ -176,0 +227,1 @@\n+     * @throws IOException if an I\/O error occurs\n@@ -177,3 +229,2 @@\n-    public static void dumpThreadsToJson(OutputStream out) {\n-        BufferedOutputStream bos = new BufferedOutputStream(out);\n-        PrintStream ps = new PrintStream(bos, false, StandardCharsets.UTF_8);\n+    public static void dumpThreadsToJson(OutputStream out) throws IOException {\n+        var writer = new TextWriter(out);\n@@ -181,3 +232,5 @@\n-            dumpThreadsToJson(ps);\n-        } finally {\n-            ps.flush();  \/\/ flushes underlying stream\n+            dumpThreadsToJson(writer);\n+            writer.flush();\n+        } catch (UncheckedIOException e) {\n+            IOException ioe = e.getCause();\n+            throw ioe;\n@@ -188,1 +241,2 @@\n-     * Generate a thread dump to the given print stream in JSON format.\n+     * Generate a thread dump to the given text stream in JSON format.\n+     * @throws UncheckedIOException if an I\/O error occurs\n@@ -190,22 +244,18 @@\n-    private static void dumpThreadsToJson(PrintStream out) {\n-        out.println(\"{\");\n-        out.println(\"  \\\"threadDump\\\": {\");\n-\n-        String now = Instant.now().toString();\n-        String runtimeVersion = Runtime.version().toString();\n-        out.format(\"    \\\"processId\\\": \\\"%d\\\",%n\", processId());\n-        out.format(\"    \\\"time\\\": \\\"%s\\\",%n\", escape(now));\n-        out.format(\"    \\\"runtimeVersion\\\": \\\"%s\\\",%n\", escape(runtimeVersion));\n-\n-        out.println(\"    \\\"threadContainers\\\": [\");\n-        List<ThreadContainer> containers = allContainers();\n-        Iterator<ThreadContainer> iterator = containers.iterator();\n-        while (iterator.hasNext()) {\n-            ThreadContainer container = iterator.next();\n-            boolean more = iterator.hasNext();\n-            dumpThreadsToJson(container, out, more);\n-        }\n-        out.println(\"    ]\");   \/\/ end of threadContainers\n-\n-        out.println(\"  }\");   \/\/ end threadDump\n-        out.println(\"}\");  \/\/ end object\n+    private static void dumpThreadsToJson(TextWriter textWriter) {\n+        var jsonWriter = new JsonWriter(textWriter);\n+\n+        jsonWriter.startObject();  \/\/ top-level object\n+\n+        jsonWriter.startObject(\"threadDump\");\n+\n+        jsonWriter.writeProperty(\"processId\", processId());\n+        jsonWriter.writeProperty(\"time\", Instant.now());\n+        jsonWriter.writeProperty(\"runtimeVersion\", Runtime.version());\n+\n+        jsonWriter.startArray(\"threadContainers\");\n+        dumpThreads(ThreadContainers.root(), jsonWriter);\n+        jsonWriter.endArray();\n+\n+        jsonWriter.endObject();  \/\/ threadDump\n+\n+        jsonWriter.endObject();  \/\/ end of top-level object\n@@ -215,1 +265,2 @@\n-     * Dump the given thread container to the print stream in JSON format.\n+     * Write a thread container to the given JSON writer.\n+     * @throws UncheckedIOException if an I\/O error occurs\n@@ -217,12 +268,4 @@\n-    private static void dumpThreadsToJson(ThreadContainer container,\n-                                          PrintStream out,\n-                                          boolean more) {\n-        out.println(\"      {\");\n-        out.format(\"        \\\"container\\\": \\\"%s\\\",%n\", escape(container.toString()));\n-\n-        ThreadContainer parent = container.parent();\n-        if (parent == null) {\n-            out.format(\"        \\\"parent\\\": null,%n\");\n-        } else {\n-            out.format(\"        \\\"parent\\\": \\\"%s\\\",%n\", escape(parent.toString()));\n-        }\n+    private static void dumpThreads(ThreadContainer container, JsonWriter jsonWriter) {\n+        jsonWriter.startObject();\n+        jsonWriter.writeProperty(\"container\", container);\n+        jsonWriter.writeProperty(\"parent\", container.parent());\n@@ -231,5 +274,1 @@\n-        if (owner == null) {\n-            out.format(\"        \\\"owner\\\": null,%n\");\n-        } else {\n-            out.format(\"        \\\"owner\\\": \\\"%d\\\",%n\", owner.threadId());\n-        }\n+        jsonWriter.writeProperty(\"owner\", (owner != null) ? owner.threadId() : null);\n@@ -238,1 +277,1 @@\n-        out.println(\"        \\\"threads\\\": [\");\n+        jsonWriter.startArray(\"threads\");\n@@ -242,1 +281,1 @@\n-            dumpThreadToJson(thread, out, threads.hasNext());\n+            dumpThread(thread, jsonWriter);\n@@ -245,1 +284,1 @@\n-        out.println(\"        ],\");   \/\/ end of threads\n+        jsonWriter.endArray(); \/\/ threads\n@@ -251,1 +290,1 @@\n-        out.format(\"        \\\"threadCount\\\": \\\"%d\\\"%n\", threadCount);\n+        jsonWriter.writeProperty(\"threadCount\", threadCount);\n@@ -253,5 +292,4 @@\n-        if (more) {\n-            out.println(\"      },\");\n-        } else {\n-            out.println(\"      }\");  \/\/ last container, no trailing comma\n-        }\n+        jsonWriter.endObject();\n+\n+        \/\/ the children of the thread container follow\n+        container.children().forEach(c -> dumpThreads(c, jsonWriter));\n@@ -261,1 +299,2 @@\n-     * Dump the given thread and its stack trace to the print stream in JSON format.\n+     * Write a thread to the given JSON writer.\n+     * @throws UncheckedIOException if an I\/O error occurs\n@@ -263,17 +302,23 @@\n-    private static void dumpThreadToJson(Thread thread, PrintStream out, boolean more) {\n-        out.println(\"         {\");\n-        out.println(\"           \\\"tid\\\": \\\"\" + thread.threadId() + \"\\\",\");\n-        out.println(\"           \\\"name\\\": \\\"\" + escape(thread.getName()) + \"\\\",\");\n-        out.println(\"           \\\"stack\\\": [\");\n-\n-        int i = 0;\n-        StackTraceElement[] stackTrace = thread.getStackTrace();\n-        while (i < stackTrace.length) {\n-            out.print(\"              \\\"\");\n-            out.print(escape(stackTrace[i].toString()));\n-            out.print(\"\\\"\");\n-            i++;\n-            if (i < stackTrace.length) {\n-                out.println(\",\");\n-            } else {\n-                out.println();  \/\/ last element, no trailing comma\n+    private static void dumpThread(Thread thread, JsonWriter jsonWriter) {\n+        Instant now = Instant.now();\n+        ThreadSnapshot snapshot = ThreadSnapshot.of(thread);\n+        Thread.State state = snapshot.threadState();\n+        StackTraceElement[] stackTrace = snapshot.stackTrace();\n+\n+        jsonWriter.startObject();\n+        jsonWriter.writeProperty(\"tid\", thread.threadId());\n+        jsonWriter.writeProperty(\"time\", now);\n+        if (thread.isVirtual()) {\n+            jsonWriter.writeProperty(\"virtual\", Boolean.TRUE);\n+        }\n+        jsonWriter.writeProperty(\"name\", snapshot.threadName());\n+        jsonWriter.writeProperty(\"state\", state);\n+\n+        \/\/ park blocker\n+        Object parkBlocker = snapshot.parkBlocker();\n+        if (parkBlocker != null) {\n+            jsonWriter.startObject(\"parkBlocker\");\n+            jsonWriter.writeProperty(\"object\", Objects.toIdentityString(parkBlocker));\n+            if (parkBlocker instanceof AbstractOwnableSynchronizer\n+                    && snapshot.exclusiveOwnerThread() instanceof Thread owner) {\n+                jsonWriter.writeProperty(\"exclusiveOwnerThreadId\", owner.threadId());\n@@ -281,0 +326,1 @@\n+            jsonWriter.endObject();\n@@ -282,5 +328,7 @@\n-        out.println(\"           ]\");\n-        if (more) {\n-            out.println(\"         },\");\n-        } else {\n-            out.println(\"         }\");  \/\/ last thread, no trailing comma\n+\n+        \/\/ blocked on monitor enter or Object.wait\n+        if (state == Thread.State.BLOCKED && snapshot.blockedOn() instanceof Object obj) {\n+            jsonWriter.writeProperty(\"blockedOn\", Objects.toIdentityString(obj));\n+        } else if ((state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING)\n+                && snapshot.waitingOn() instanceof Object obj) {\n+            jsonWriter.writeProperty(\"waitingOn\", Objects.toIdentityString(obj));\n@@ -288,1 +336,0 @@\n-    }\n@@ -290,9 +337,4 @@\n-    \/**\n-     * Returns a list of all thread containers that are \"reachable\" from\n-     * the root container.\n-     *\/\n-    private static List<ThreadContainer> allContainers() {\n-        List<ThreadContainer> containers = new ArrayList<>();\n-        collect(ThreadContainers.root(), containers);\n-        return containers;\n-    }\n+        \/\/ stack trace\n+        jsonWriter.startArray(\"stack\");\n+        Arrays.stream(stackTrace).forEach(jsonWriter::writeProperty);\n+        jsonWriter.endArray();\n@@ -300,3 +342,27 @@\n-    private static void collect(ThreadContainer container, List<ThreadContainer> containers) {\n-        containers.add(container);\n-        container.children().forEach(c -> collect(c, containers));\n+        \/\/ monitors owned, skip if none\n+        if (snapshot.ownsMonitors()) {\n+            jsonWriter.startArray(\"monitorsOwned\");\n+            int depth = 0;\n+            while (depth < stackTrace.length) {\n+                List<Object> objs = snapshot.ownedMonitorsAt(depth).toList();\n+                if (!objs.isEmpty()) {\n+                    jsonWriter.startObject();\n+                    jsonWriter.writeProperty(\"depth\", depth);\n+                    jsonWriter.startArray(\"locks\");\n+                    snapshot.ownedMonitorsAt(depth)\n+                            .map(o -> (o != null) ? Objects.toIdentityString(o) : null)\n+                            .forEach(jsonWriter::writeProperty);\n+                    jsonWriter.endArray();\n+                    jsonWriter.endObject();\n+                }\n+                depth++;\n+            }\n+            jsonWriter.endArray();\n+        }\n+\n+        \/\/ thread identifier of carrier, when mounted\n+        if (thread.isVirtual() && snapshot.carrierThread() instanceof Thread carrier) {\n+            jsonWriter.writeProperty(\"carrier\", carrier.threadId());\n+        }\n+\n+        jsonWriter.endObject();\n@@ -306,1 +372,2 @@\n-     * Escape any characters that need to be escape in the JSON output.\n+     * Simple JSON writer to stream objects\/arrays to a TextWriter with formatting.\n+     * This class is not intended to be a fully featured JSON writer.\n@@ -308,18 +375,151 @@\n-    private static String escape(String value) {\n-        StringBuilder sb = new StringBuilder();\n-        for (int i = 0; i < value.length(); i++) {\n-            char c = value.charAt(i);\n-            switch (c) {\n-                case '\"'  -> sb.append(\"\\\\\\\"\");\n-                case '\\\\' -> sb.append(\"\\\\\\\\\");\n-                case '\/'  -> sb.append(\"\\\\\/\");\n-                case '\\b' -> sb.append(\"\\\\b\");\n-                case '\\f' -> sb.append(\"\\\\f\");\n-                case '\\n' -> sb.append(\"\\\\n\");\n-                case '\\r' -> sb.append(\"\\\\r\");\n-                case '\\t' -> sb.append(\"\\\\t\");\n-                default -> {\n-                    if (c <= 0x1f) {\n-                        sb.append(String.format(\"\\\\u%04x\", c));\n-                    } else {\n-                        sb.append(c);\n+    private static class JsonWriter {\n+        private static class Node {\n+            final boolean isArray;\n+            int propertyCount;\n+            Node(boolean isArray) {\n+                this.isArray = isArray;\n+            }\n+            boolean isArray() {\n+                return isArray;\n+            }\n+            int propertyCount() {\n+                return propertyCount;\n+            }\n+            int getAndIncrementPropertyCount() {\n+                int old = propertyCount;\n+                propertyCount++;\n+                return old;\n+            }\n+        }\n+        private final Deque<Node> stack = new ArrayDeque<>();\n+        private final TextWriter writer;\n+\n+        JsonWriter(TextWriter writer) {\n+            this.writer = writer;\n+        }\n+\n+        private void indent() {\n+            int indent = stack.size() * 2;\n+            writer.print(\" \".repeat(indent));\n+        }\n+\n+        \/**\n+         * Start of object or array.\n+         *\/\n+        private void startObject(String name, boolean isArray) {\n+            if (!stack.isEmpty()) {\n+                Node node = stack.peek();\n+                if (node.getAndIncrementPropertyCount() > 0) {\n+                    writer.println(\",\");\n+                }\n+            }\n+            indent();\n+            if (name != null) {\n+                writer.print(\"\\\"\" + name + \"\\\": \");\n+            }\n+            writer.println(isArray ? \"[\" : \"{\");\n+            stack.push(new Node(isArray));\n+        }\n+\n+        \/**\n+         * End of object or array.\n+         *\/\n+        private void endObject(boolean isArray) {\n+            Node node = stack.pop();\n+            if (node.isArray() != isArray)\n+                throw new IllegalStateException();\n+            if (node.propertyCount() > 0) {\n+                writer.println();\n+            }\n+            indent();\n+            writer.print(isArray ? \"]\" : \"}\");\n+        }\n+\n+        \/**\n+         * Write a property.\n+         * @param name the property name, null for an unnamed property\n+         * @param obj the value or null\n+         *\/\n+        void writeProperty(String name, Object obj) {\n+            Node node = stack.peek();\n+            if (node.getAndIncrementPropertyCount() > 0) {\n+                writer.println(\",\");\n+            }\n+            indent();\n+            if (name != null) {\n+                writer.print(\"\\\"\" + name + \"\\\": \");\n+            }\n+            switch (obj) {\n+                \/\/ Long may be larger than safe range of JSON integer value\n+                case Long   _  -> writer.print(\"\\\"\" + obj + \"\\\"\");\n+                case Number _  -> writer.print(obj);\n+                case Boolean _ -> writer.print(obj);\n+                case null      -> writer.print(\"null\");\n+                default        -> writer.print(\"\\\"\" + escape(obj.toString()) + \"\\\"\");\n+            }\n+        }\n+\n+        \/**\n+         * Write an unnamed property.\n+         *\/\n+        void writeProperty(Object obj) {\n+            writeProperty(null, obj);\n+        }\n+\n+        \/**\n+         * Start named object.\n+         *\/\n+        void startObject(String name) {\n+            startObject(name, false);\n+        }\n+\n+        \/**\n+         * Start unnamed object.\n+         *\/\n+        void startObject() {\n+            startObject(null);\n+        }\n+\n+        \/**\n+         * End of object.\n+         *\/\n+        void endObject() {\n+            endObject(false);\n+        }\n+\n+        \/**\n+         * Start named array.\n+         *\/\n+        void startArray(String name) {\n+            startObject(name, true);\n+        }\n+\n+        \/**\n+         * End of array.\n+         *\/\n+        void endArray() {\n+            endObject(true);\n+        }\n+\n+        \/**\n+         * Escape any characters that need to be escape in the JSON output.\n+         *\/\n+        private static String escape(String value) {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 0; i < value.length(); i++) {\n+                char c = value.charAt(i);\n+                switch (c) {\n+                    case '\"'  -> sb.append(\"\\\\\\\"\");\n+                    case '\\\\' -> sb.append(\"\\\\\\\\\");\n+                    case '\/'  -> sb.append(\"\\\\\/\");\n+                    case '\\b' -> sb.append(\"\\\\b\");\n+                    case '\\f' -> sb.append(\"\\\\f\");\n+                    case '\\n' -> sb.append(\"\\\\n\");\n+                    case '\\r' -> sb.append(\"\\\\r\");\n+                    case '\\t' -> sb.append(\"\\\\t\");\n+                    default -> {\n+                        if (c <= 0x1f) {\n+                            sb.append(String.format(\"\\\\u%04x\", c));\n+                        } else {\n+                            sb.append(c);\n+                        }\n@@ -329,0 +529,1 @@\n+            return sb.toString();\n@@ -330,1 +531,0 @@\n-        return sb.toString();\n@@ -360,0 +560,50 @@\n+    \/**\n+     * Simple Writer implementation for printing text. The print\/println methods\n+     * throw UncheckedIOException if an I\/O error occurs.\n+     *\/\n+    private static class TextWriter extends Writer {\n+        private final Writer delegate;\n+\n+        TextWriter(OutputStream out) {\n+            delegate = new BufferedWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));\n+        }\n+\n+        @Override\n+        public void write(char[] cbuf, int off, int len) throws IOException {\n+            delegate.write(cbuf, off, len);\n+        }\n+\n+        void print(Object obj) {\n+            String s = String.valueOf(obj);\n+            try {\n+                write(s, 0, s.length());\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        void println() {\n+            print(System.lineSeparator());\n+        }\n+\n+        void println(String s) {\n+            print(s);\n+            println();\n+        }\n+\n+        void println(Object obj) {\n+            print(obj);\n+            println();\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+            delegate.flush();\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            delegate.close();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadDumper.java","additions":418,"deletions":168,"binary":false,"changes":586,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Represents a snapshot of information about a Thread.\n+ *\/\n+class ThreadSnapshot {\n+    private static final StackTraceElement[] EMPTY_STACK = new StackTraceElement[0];\n+    private static final ThreadLock[] EMPTY_LOCKS = new ThreadLock[0];\n+\n+    \/\/ filled by VM\n+    private String name;\n+    private int threadStatus;\n+    private Thread carrierThread;\n+    private StackTraceElement[] stackTrace;\n+    \/\/ owned monitors\n+    private ThreadLock[] locks;\n+    \/\/ an object the thread is blocked\/waiting on, converted to ThreadBlocker by ThreadSnapshot.of()\n+    private int blockerTypeOrdinal;\n+    private Object blockerObject;\n+    \/\/ blocker owner (if known)\n+    private Object blockerOwner;\n+\n+    \/\/ set by ThreadSnapshot.of()\n+    private ThreadBlocker blocker;\n+\n+    \/**\n+     * Take a snapshot of a Thread to get all information about the thread.\n+     *\/\n+    static ThreadSnapshot of(Thread thread) {\n+        ThreadSnapshot snapshot = create(thread);\n+        if (snapshot.stackTrace == null) {\n+            snapshot.stackTrace = EMPTY_STACK;\n+        }\n+        if (snapshot.locks != null) {\n+            Arrays.stream(snapshot.locks).forEach(ThreadLock::finishInit);\n+        } else {\n+            snapshot.locks = EMPTY_LOCKS;\n+        }\n+        if (snapshot.blockerObject != null) {\n+            snapshot.blocker = new ThreadBlocker(snapshot.blockerTypeOrdinal, snapshot.blockerObject);\n+            snapshot.blockerObject = null; \/\/ release\n+        }\n+        return snapshot;\n+    }\n+\n+    \/**\n+     * Returns the thread name.\n+     *\/\n+    String threadName() {\n+        return name;\n+    }\n+\n+    \/**\n+     * Returns the thread state.\n+     *\/\n+    Thread.State threadState() {\n+        return jdk.internal.misc.VM.toThreadState(threadStatus);\n+    }\n+\n+    \/**\n+     * Returns the thread stack trace.\n+     *\/\n+    StackTraceElement[] stackTrace() {\n+        return stackTrace;\n+    }\n+\n+    \/**\n+     * Returns the thread's parkBlocker.\n+     *\/\n+    Object parkBlocker() {\n+        return getBlocker(BlockerLockType.PARK_BLOCKER);\n+    }\n+\n+    \/**\n+     * Returns the owner of exclusive mode synchronizer when the parkBlocker is an AQS.\n+     *\/\n+    Object exclusiveOwnerThread() {\n+        return parkBlocker() != null ? blockerOwner : null;\n+    }\n+\n+    \/**\n+     * Returns the object that the thread is blocked on.\n+     * @throws IllegalStateException if not in the blocked state\n+     *\/\n+    Object blockedOn() {\n+        if (threadState() != Thread.State.BLOCKED) {\n+            throw new IllegalStateException();\n+        }\n+        return getBlocker(BlockerLockType.WAITING_TO_LOCK);\n+    }\n+\n+    \/**\n+     * Returns the object that the thread is waiting on.\n+     * @throws IllegalStateException if not in the waiting state\n+     *\/\n+    Object waitingOn() {\n+        if (threadState() != Thread.State.WAITING\n+                && threadState() != Thread.State.TIMED_WAITING) {\n+            throw new IllegalStateException();\n+        }\n+        return getBlocker(BlockerLockType.WAITING_ON);\n+    }\n+\n+    private Object getBlocker(BlockerLockType type) {\n+        return (blocker != null && blocker.type == type) ? blocker.obj : null;\n+    }\n+\n+    \/**\n+     * Returns true if the thread owns any object monitors.\n+     *\/\n+    boolean ownsMonitors() {\n+        return locks.length > 0;\n+    }\n+\n+    \/**\n+     * Returns the objects that the thread locked at the given depth. The stream\n+     * will contain a null element for a monitor that has been eliminated.\n+     *\/\n+    Stream<Object> ownedMonitorsAt(int depth) {\n+        return Arrays.stream(locks)\n+                .filter(lock -> lock.depth() == depth)\n+                .map(lock -> (lock.type == OwnedLockType.LOCKED)\n+                        ? lock.lockObject()\n+                        : \/*eliminated*\/ null);\n+    }\n+\n+    \/**\n+     * If the thread is a mounted virtual thread then return its carrier.\n+     *\/\n+    Thread carrierThread() {\n+        return carrierThread;\n+    }\n+\n+    \/**\n+     * Represents information about a locking operation.\n+     *\/\n+    private enum OwnedLockType {\n+        LOCKED,\n+        \/\/ Lock object is a class of the eliminated monitor\n+        ELIMINATED,\n+    }\n+\n+    private enum BlockerLockType {\n+        \/\/ Park blocker\n+        PARK_BLOCKER,\n+        WAITING_TO_LOCK,\n+        \/\/ Object.wait()\n+        WAITING_ON,\n+    }\n+\n+    \/**\n+     * Represents a locking operation of a thread at a specific stack depth.\n+     *\/\n+    private class ThreadLock {\n+        private static final OwnedLockType[] lockTypeValues = OwnedLockType.values(); \/\/ cache\n+\n+        \/\/ set by the VM\n+        private int depth;\n+        private int typeOrdinal;\n+        private Object obj;\n+\n+        \/\/ set by ThreadLock.of()\n+        private OwnedLockType type;\n+\n+        void finishInit() {\n+            type = lockTypeValues[typeOrdinal];\n+        }\n+\n+        int depth() {\n+            return depth;\n+        }\n+\n+        OwnedLockType type() {\n+            return type;\n+        }\n+\n+        Object lockObject() {\n+            if (type == OwnedLockType.ELIMINATED) {\n+                \/\/ we have no lock object, lock contains lock class\n+                return null;\n+            }\n+            return obj;\n+        }\n+    }\n+\n+    private record ThreadBlocker(BlockerLockType type, Object obj) {\n+        private static final BlockerLockType[] lockTypeValues = BlockerLockType.values(); \/\/ cache\n+\n+        ThreadBlocker(int typeOrdinal, Object obj) {\n+            this(lockTypeValues[typeOrdinal], obj);\n+        }\n+    }\n+\n+    private static native ThreadSnapshot create(Thread thread);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadSnapshot.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_vm_ThreadSnapshot.h\"\n+\n+\n+JNIEXPORT jobject JNICALL\n+Java_jdk_internal_vm_ThreadSnapshot_create(JNIEnv *env, jclass cls, jobject thread)\n+{\n+  return JVM_CreateThreadSnapshot(env, thread);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/ThreadSnapshot.c","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,0 +119,7 @@\n+     * <p> When the format is specified as {@link ThreadDumpFormat#JSON JSON}, the\n+     * thread dump is generated in JavaScript Object Notation.\n+     * <a href=\"doc-files\/threadDump.schema.json\">threadDump.schema.json<\/a>\n+     * describes the thread dump format in draft\n+     * <a href=\"https:\/\/tools.ietf.org\/html\/draft-json-schema-language-02\">\n+     * JSON Schema Language version 2<\/a>.\n+     *\n@@ -154,0 +161,1 @@\n+         * @spec https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259 JavaScript Object Notation\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/HotSpotDiagnosticMXBean.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+{\n+  \"type\": \"object\",\n+  \"properties\": {\n+    \"threadDump\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"processId\": {\n+          \"type\": \"string\",\n+          \"description\": \"The native process id of the Java virtual machine.\"\n+        },\n+        \"time\": {\n+          \"type\": \"string\",\n+          \"description\": \"The time in ISO 8601 format when the thread dump was generated.\"\n+        },\n+        \"runtimeVersion\": {\n+          \"type\": \"string\",\n+          \"description\": \"The runtime version, see java.lang.Runtime.Version\"\n+        },\n+        \"threadContainers\": {\n+          \"type\": \"array\",\n+          \"description\": \"The array of thread containers (thread groupings).\",\n+          \"items\": [\n+            {\n+              \"type\": \"object\",\n+              \"properties\": {\n+                \"container\": {\n+                  \"type\": \"string\",\n+                  \"description\": \"The container name. The container name is unique.\"\n+                },\n+                \"parent\": {\n+                  \"type\": [\n+                    \"string\",\n+                    \"null\"\n+                  ],\n+                  \"description\": \"The parent container name or null for the root container.\"\n+                },\n+                \"owner\": {\n+                  \"type\": [\n+                    \"string\",\n+                    \"null\"\n+                  ],\n+                  \"description\": \"The thread identifier of the owner thread if owned.\"\n+                },\n+                \"threads\": {\n+                  \"type\": \"array\",\n+                  \"description\": \"The array of threads in the thread container.\",\n+                  \"items\": [\n+                    {\n+                      \"type\": \"object\",\n+                      \"properties\": {\n+                        \"tid\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The thread identifier.\"\n+                        },\n+                        \"time\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The time in ISO 8601 format that the thread was sampled.\"\n+                        },\n+                        \"name\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The thread name.\"\n+                        },\n+                        \"state\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The thread state (Thread::getState).\"\n+                        },\n+                        \"virtual\" : {\n+                          \"type\": \"boolean\",\n+                          \"description\": \"true for a virtual thread.\"\n+                        },\n+                        \"parkBlocker\": {\n+                          \"type\": [\n+                            \"object\"\n+                          ],\n+                          \"properties\": {\n+                            \"object\": {\n+                              \"type\": \"string\",\n+                              \"description\": \"The blocker object responsible for the thread parking.\"\n+                            },\n+                            \"exclusiveOwnerThreadId\": {\n+                              \"type\": \"string\",\n+                              \"description\": \"The thread identifier of the owner when the blocker object has an owner.\"\n+                            }\n+                          },\n+                          \"required\": [\n+                            \"object\"\n+                          ]\n+                        },\n+                        \"blockedOn\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The object that the thread is blocked on waiting to enter\/re-enter a synchronization block\/method.\"\n+                        },\n+                        \"waitingOn\": {\n+                          \"type\": \"string\",\n+                          \"description\": \"The object that the thread is waiting to be notified (Object.wait).\"\n+                        },\n+                        \"stack\": {\n+                          \"type\": \"array\",\n+                          \"description\": \"The thread stack. The first element is the top of the stack.\",\n+                          \"items\": [\n+                            {\n+                              \"type\": \"string\",\n+                              \"description\": \"A stack trace element (java.lang.StackTraceElement).\"\n+                            }\n+                          ]\n+                        },\n+                        \"monitorsOwned\": {\n+                          \"type\": \"array\",\n+                          \"description\": \"The objects for which monitors are owned by the thread.\",\n+                          \"items\": {\n+                            \"type\": \"object\",\n+                            \"properties\": {\n+                              \"depth\": {\n+                                \"type\": \"integer\",\n+                                \"description\": \"The stack depth at which the monitors are owned.\"\n+                              },\n+                              \"locks\": {\n+                                \"type\": \"array\",\n+                                \"items\": {\n+                                  \"type\": [\n+                                    \"string\",\n+                                    null\n+                                  ],\n+                                  \"description\": \"The object for which the monitor is owned by the thread, null if eliminated\"\n+                                }\n+                              }\n+                            },\n+                            \"required\": [\n+                              \"depth\",\n+                              \"locks\"\n+                            ]\n+                          }\n+                        },\n+                        \"carrier\":  {\n+                          \"type\": \"string\",\n+                          \"description\": \"The thread identifier of the carrier thread if mounted.\"\n+                        }\n+                      },\n+                      \"required\": [\n+                        \"tid\",\n+                        \"time\",\n+                        \"name\",\n+                        \"state\",\n+                        \"stack\"\n+                      ]\n+                    }\n+                  ]\n+                },\n+                \"threadCount\": {\n+                  \"type\": \"string\",\n+                  \"description\": \"The number of threads in the thread container.\"\n+                }\n+              },\n+              \"required\": [\n+                \"container\",\n+                \"parent\",\n+                \"owner\",\n+                \"threads\"\n+              ]\n+            }\n+          ]\n+        }\n+      },\n+      \"required\": [\n+        \"processId\",\n+        \"time\",\n+        \"runtimeVersion\",\n+        \"threadContainers\"\n+      ]\n+    }\n+  },\n+  \"required\": [\n+    \"threadDump\"\n+  ]\n+}\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/doc-files\/threadDump.schema.json","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-                dumpThreads(out, format);\n+            dumpThreads(out, format);\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/HotSpotDiagnostic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @modules jdk.jcmd\n@@ -69,1 +70,2 @@\n-        jcmdThreadDumpToFile(file, \"-format=json\").shouldMatch(\"Created\");\n+        jcmdThreadDumpToFile(file, \"-format=json\")\n+                .shouldMatch(\"Created\");\n@@ -92,1 +94,2 @@\n-        jcmdThreadDumpToFile(file, \"\").shouldMatch(\"exists\");\n+        jcmdThreadDumpToFile(file, \"\")\n+                .shouldMatch(\"exists\");\n@@ -105,1 +108,17 @@\n-        jcmdThreadDumpToFile(file, \"-overwrite\");\n+        jcmdThreadDumpToFile(file, \"-overwrite\")\n+                .shouldMatch(\"Created\");\n+    }\n+\n+    \/**\n+     * Test output file cannot be created.\n+     *\/\n+    @Test\n+    void testFileCreateFails() throws IOException {\n+        Path badFile = Path.of(\".\").toAbsolutePath()\n+                .resolve(\"does-not-exist\")\n+                .resolve(\"does-not-exist\")\n+                .resolve(\"threads.bad\");\n+        jcmdThreadDumpToFile(badFile, \"-format=plain\")\n+                .shouldMatch(\"Failed\");\n+        jcmdThreadDumpToFile(badFile, \"-format=json\")\n+                .shouldMatch(\"Failed\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/ThreadDumpToFileTest.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -26,1 +26,1 @@\n- * @bug 8284161 8287008 8309406\n+ * @bug 8284161 8287008 8309406 8356870\n@@ -29,1 +29,1 @@\n- * @modules jdk.management\n+ * @modules java.base\/jdk.internal.vm jdk.management\n@@ -31,4 +31,10 @@\n- * @run junit\/othervm DumpThreads\n- * @run junit\/othervm -Djdk.trackAllThreads DumpThreads\n- * @run junit\/othervm -Djdk.trackAllThreads=true DumpThreads\n- * @run junit\/othervm -Djdk.trackAllThreads=false DumpThreads\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run junit\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *         --enable-native-access=ALL-UNNAMED DumpThreads\n+ * @run junit\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *         --enable-native-access=ALL-UNNAMED -Djdk.trackAllThreads DumpThreads\n+ * @run junit\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *        --enable-native-access=ALL-UNNAMED -Djdk.trackAllThreads=true DumpThreads\n+ * @run junit\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *        --enable-native-access=ALL-UNNAMED -Djdk.trackAllThreads=false DumpThreads\n@@ -38,0 +44,3 @@\n+import java.lang.reflect.Method;\n+import java.io.IOException;\n+import java.io.OutputStream;\n@@ -41,1 +50,0 @@\n-import java.util.Objects;\n@@ -43,0 +51,3 @@\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n@@ -48,0 +59,4 @@\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -49,0 +64,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n@@ -50,0 +67,2 @@\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n@@ -53,0 +72,3 @@\n+import jdk.test.lib.thread.VThreadPinner;\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.whitebox.WhiteBox;\n@@ -59,0 +81,1 @@\n+import static org.junit.jupiter.api.Assumptions.*;\n@@ -67,0 +90,50 @@\n+\n+        \/\/ need >=2 carriers for testing pinning\n+        VThreadRunner.ensureParallelism(2);\n+    }\n+\n+    \/**\n+     * Test thread dump in plain text format.\n+     *\/\n+    @Test\n+    void testPlainText() throws Exception {\n+        List<String> lines = dumpThreadsToPlainText();\n+\n+        \/\/ pid should be on the first line\n+        String pid = Long.toString(ProcessHandle.current().pid());\n+        assertEquals(pid, lines.get(0));\n+\n+        \/\/ timestamp should be on the second line\n+        String secondLine = lines.get(1);\n+        ZonedDateTime.parse(secondLine);\n+\n+        \/\/ runtime version should be on third line\n+        String vs = Runtime.version().toString();\n+        assertEquals(vs, lines.get(2));\n+\n+        \/\/ dump should include current thread\n+        Thread currentThread = Thread.currentThread();\n+        if (trackAllThreads || !currentThread.isVirtual()) {\n+            ThreadFields fields = findThread(currentThread.threadId(), lines);\n+            assertNotNull(fields, \"current thread not found\");\n+            assertEquals(currentThread.getName(), fields.name());\n+            assertEquals(currentThread.isVirtual(), fields.isVirtual());\n+        }\n+    }\n+\n+    \/**\n+     * Test thread dump in JSON format.\n+     *\/\n+    @Test\n+    void testJsonFormat() throws Exception {\n+        ThreadDump threadDump = dumpThreadsToJson();\n+\n+        \/\/ dump should include current thread in the root container\n+        Thread currentThread = Thread.currentThread();\n+        if (trackAllThreads || !currentThread.isVirtual()) {\n+            ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                    .findThread(currentThread.threadId())\n+                    .orElse(null);\n+            assertNotNull(ti, \"current thread not found\");\n+            assertEquals(currentThread.isVirtual(), ti.isVirtual());\n+        }\n@@ -81,2 +154,1 @@\n-     * Test thread dump in plain text format contains information about the current\n-     * thread and a virtual thread created directly with the Thread API.\n+     * Test that a thread container for an executor service is in the JSON format thread dump.\n@@ -84,7 +156,5 @@\n-    @Test\n-    void testRootContainerPlainTextFormat() throws Exception {\n-        Thread vthread = Thread.ofVirtual().start(LockSupport::park);\n-        try {\n-            testDumpThreadsPlainText(vthread, trackAllThreads);\n-        } finally {\n-            LockSupport.unpark(vthread);\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testThreadContainer(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            testThreadContainer(executor, Objects.toIdentityString(executor));\n@@ -95,2 +165,1 @@\n-     * Test thread dump in JSON format contains information about the current\n-     * thread and a virtual thread created directly with the Thread API.\n+     * Test that a thread container for the common pool is in the JSON format thread dump.\n@@ -99,2 +168,21 @@\n-    void testRootContainerJsonFormat() throws Exception {\n-        Thread vthread = Thread.ofVirtual().start(LockSupport::park);\n+    void testCommonPool() throws Exception {\n+        testThreadContainer(ForkJoinPool.commonPool(), \"ForkJoinPool.commonPool\");\n+    }\n+\n+    \/**\n+     * Test that the JSON thread dump has a thread container for the given executor.\n+     *\/\n+    private void testThreadContainer(ExecutorService executor, String name) throws Exception {\n+        var threadRef = new AtomicReference<Thread>();\n+\n+        executor.submit(() -> {\n+            threadRef.set(Thread.currentThread());\n+            LockSupport.park();\n+        });\n+\n+        \/\/ capture Thread\n+        Thread thread;\n+        while ((thread = threadRef.get()) == null) {\n+            Thread.sleep(20);\n+        }\n+\n@@ -102,1 +190,14 @@\n-            testDumpThreadsJson(null, vthread, trackAllThreads);\n+            \/\/ dump threads to file and parse as JSON object\n+            ThreadDump threadDump = dumpThreadsToJson();\n+\n+            \/\/ find the thread container corresponding to the executor\n+            var container = threadDump.findThreadContainer(name).orElse(null);\n+            assertNotNull(container, name + \" not found\");\n+            assertFalse(container.owner().isPresent());\n+            var parent = container.parent().orElse(null);\n+            assertEquals(threadDump.rootThreadContainer(), parent);\n+\n+            \/\/ find the thread in the thread container\n+            ThreadDump.ThreadInfo ti = container.findThread(thread.threadId()).orElse(null);\n+            assertNotNull(ti, \"thread not found\");\n+\n@@ -104,1 +205,1 @@\n-            LockSupport.unpark(vthread);\n+            LockSupport.unpark(thread);\n@@ -109,2 +210,1 @@\n-     * Test thread dump in plain text format includes a thread executing a task in the\n-     * given ExecutorService.\n+     * ThreadFactory implementations for tests.\n@@ -112,10 +212,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"executors\")\n-    void testExecutorServicePlainTextFormat(ExecutorService executor) throws Exception {\n-        try (executor) {\n-            Thread thread = forkParker(executor);\n-            try {\n-                testDumpThreadsPlainText(thread, true);\n-            } finally {\n-                LockSupport.unpark(thread);\n-            }\n+    static Stream<ThreadFactory> threadFactories() {\n+        Stream<ThreadFactory> s = Stream.of(Thread.ofPlatform().factory());\n+        if (trackAllThreads) {\n+            return Stream.concat(s, Stream.of(Thread.ofVirtual().factory()));\n+        } else {\n+            return s;\n@@ -126,2 +222,1 @@\n-     * Test thread dump in JSON format includes a thread executing a task in the\n-     * given ExecutorService.\n+     * Test thread dump with a thread blocked on monitor enter.\n@@ -130,10 +225,3 @@\n-    @MethodSource(\"executors\")\n-    void testExecutorServiceJsonFormat(ExecutorService executor) throws Exception {\n-        try (executor) {\n-            Thread thread = forkParker(executor);\n-            try {\n-                testDumpThreadsJson(Objects.toIdentityString(executor), thread, true);\n-            } finally {\n-                LockSupport.unpark(thread);\n-            }\n-        }\n+    @MethodSource(\"threadFactories\")\n+    void testBlockedThread(ThreadFactory factory) throws Exception {\n+        testBlockedThread(factory, false);\n@@ -143,2 +231,1 @@\n-     * Test thread dump in JSON format includes a thread executing a task in the\n-     * fork-join common pool.\n+     * Test thread dump with a thread blocked on monitor enter when pinned.\n@@ -147,3 +234,21 @@\n-    void testForkJoinPool() throws Exception {\n-        ForkJoinPool pool = ForkJoinPool.commonPool();\n-        Thread thread = forkParker(pool);\n+    void testBlockedThreadWhenPinned() throws Exception {\n+        assumeTrue(trackAllThreads, \"This test requires all threads to be tracked\");\n+        testBlockedThread(Thread.ofVirtual().factory(), true);\n+    }\n+\n+    void testBlockedThread(ThreadFactory factory, boolean pinned) throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+\n+        Thread thread = factory.newThread(() -> {\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    started.countDown();\n+                    synchronized (lock) { }  \/\/ blocks\n+                });\n+            } else {\n+                started.countDown();\n+                synchronized (lock) { }  \/\/ blocks\n+            }\n+        });\n+\n@@ -151,1 +256,28 @@\n-            testDumpThreadsJson(\"ForkJoinPool.commonPool\", thread, true);\n+            synchronized (lock) {\n+                \/\/ start thread and wait for it to block\n+                thread.start();\n+                started.await();\n+                await(thread, Thread.State.BLOCKED);\n+\n+                long tid = thread.threadId();\n+                String lockAsString = Objects.toIdentityString(lock);\n+\n+                \/\/ thread dump in plain text should include thread\n+                List<String> lines = dumpThreadsToPlainText();\n+                ThreadFields fields = findThread(tid, lines);\n+                assertNotNull(fields, \"thread not found\");\n+                assertEquals(\"BLOCKED\", fields.state());\n+                assertTrue(contains(lines, \"\/\/ blocked on \" + lockAsString));\n+\n+                \/\/ thread dump in JSON format should include thread in root container\n+                ThreadDump threadDump = dumpThreadsToJson();\n+                ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                        .findThread(tid)\n+                        .orElse(null);\n+                assertNotNull(ti, \"thread not found\");\n+                assertEquals(\"BLOCKED\", ti.state());\n+                assertEquals(lockAsString, ti.blockedOn());\n+                if (pinned) {\n+                    assertTrue(ti.carrier().isPresent(), \"carrier not found\");\n+                }\n+            }\n@@ -153,1 +285,1 @@\n-            LockSupport.unpark(thread);\n+            thread.join();\n@@ -158,5 +290,1 @@\n-     * Invoke HotSpotDiagnosticMXBean.dumpThreads to create a thread dump in plain text\n-     * format, then sanity check that the thread dump includes expected strings, the\n-     * current thread, and maybe the given thread.\n-     * @param thread the thread to test if included\n-     * @param expectInDump true if the thread is expected to be included\n+     * Test thread dump with a thread waiting in Object.wait.\n@@ -164,5 +292,5 @@\n-    private void testDumpThreadsPlainText(Thread thread, boolean expectInDump) throws Exception {\n-        Path file = genOutputPath(\".txt\");\n-        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n-        mbean.dumpThreads(file.toString(), ThreadDumpFormat.TEXT_PLAIN);\n-        System.err.format(\"Dumped to %s%n\", file);\n+    @ParameterizedTest\n+    @MethodSource(\"threadFactories\")\n+    void testWaitingThread(ThreadFactory factory) throws Exception {\n+        testWaitingThread(factory, false);\n+    }\n@@ -170,4 +298,8 @@\n-        \/\/ pid should be on the first line\n-        String line1 = line(file, 0);\n-        String pid = Long.toString(ProcessHandle.current().pid());\n-        assertTrue(line1.contains(pid));\n+    \/**\n+     * Test thread dump with a thread waiting in Object.wait when pinned.\n+     *\/\n+    @Test\n+    void testWaitingThreadWhenPinned() throws Exception {\n+        assumeTrue(trackAllThreads, \"This test requires all threads to be tracked\");\n+        testWaitingThread(Thread.ofVirtual().factory(), true);\n+    }\n@@ -175,3 +307,3 @@\n-        \/\/ timestamp should be on the second line\n-        String line2 = line(file, 1);\n-        ZonedDateTime.parse(line2);\n+    void testWaitingThread(ThreadFactory factory, boolean pinned) throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n@@ -179,4 +311,15 @@\n-        \/\/ runtime version should be on third line\n-        String line3 = line(file, 2);\n-        String vs = Runtime.version().toString();\n-        assertTrue(line3.contains(vs));\n+        Thread thread = factory.newThread(() -> {\n+            try {\n+                synchronized (lock) {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            started.countDown();\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        started.countDown();\n+                        lock.wait();\n+                    }\n+                }\n+            } catch (InterruptedException e) { }\n+        });\n@@ -184,2 +327,26 @@\n-        \/\/ test if thread is included in thread dump\n-        assertEquals(expectInDump, isPresent(file, thread));\n+        try {\n+            \/\/ start thread and wait for it to wait in Object.wait\n+            thread.start();\n+            started.await();\n+            await(thread, Thread.State.WAITING);\n+\n+            long tid = thread.threadId();\n+            String lockAsString = Objects.toIdentityString(lock);\n+\n+            \/\/ thread dump in plain text should include thread\n+            List<String> lines = dumpThreadsToPlainText();\n+            ThreadFields fields = findThread(tid, lines);\n+            assertNotNull(fields, \"thread not found\");\n+            assertEquals(\"WAITING\", fields.state());\n+\n+            \/\/ thread dump in JSON format should include thread in root container\n+            ThreadDump threadDump = dumpThreadsToJson();\n+            ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                    .findThread(thread.threadId())\n+                    .orElse(null);\n+            assertNotNull(ti, \"thread not found\");\n+            assertEquals(ti.isVirtual(), thread.isVirtual());\n+            assertEquals(\"WAITING\", ti.state());\n+            if (pinned) {\n+                assertTrue(ti.carrier().isPresent(), \"carrier not found\");\n+            }\n@@ -187,4 +354,18 @@\n-        \/\/ current thread should be included if platform thread or tracking all threads\n-        Thread currentThread = Thread.currentThread();\n-        boolean currentThreadExpected = trackAllThreads || !currentThread.isVirtual();\n-        assertEquals(currentThreadExpected, isPresent(file, currentThread));\n+            \/\/ Compiled native frames have no locals. If Object.wait0 has been compiled\n+            \/\/ then we don't have the object that the thread is waiting on\n+            Method wait0 = Object.class.getDeclaredMethod(\"wait0\", long.class);\n+            boolean expectWaitingOn = !WhiteBox.getWhiteBox().isMethodCompiled(wait0);\n+            if (expectWaitingOn) {\n+                \/\/ plain text dump should have \"waiting on\" line\n+                assertTrue(contains(lines, \"\/\/ waiting on \" + lockAsString));\n+\n+                \/\/ JSON thread dump should have waitingOn property\n+                assertEquals(lockAsString, ti.waitingOn());\n+            }\n+\n+        } finally {\n+            synchronized (lock) {\n+                lock.notifyAll();\n+            }\n+            thread.join();\n+        }\n@@ -194,6 +375,1 @@\n-     * Invoke HotSpotDiagnosticMXBean.dumpThreads to create a thread dump in JSON format.\n-     * The thread dump is parsed as a JSON object and checked to ensure that it contains\n-     * expected data, the current thread, and maybe the given thread.\n-     * @param containerName the name of the container or null for the root container\n-     * @param thread the thread to test if included\n-     * @param expect true if the thread is expected to be included\n+     * Test thread dump with a thread parked on a j.u.c. lock.\n@@ -201,7 +377,5 @@\n-    private void testDumpThreadsJson(String containerName,\n-                                     Thread thread,\n-                                     boolean expectInDump) throws Exception {\n-        Path file = genOutputPath(\".json\");\n-        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n-        mbean.dumpThreads(file.toString(), ThreadDumpFormat.JSON);\n-        System.err.format(\"Dumped to %s%n\", file);\n+    @ParameterizedTest\n+    @MethodSource(\"threadFactories\")\n+    void testParkedThread(ThreadFactory factory) throws Exception {\n+        testParkedThread(factory, false);\n+    }\n@@ -209,3 +383,8 @@\n-        \/\/ parse the JSON text\n-        String jsonText = Files.readString(file);\n-        ThreadDump threadDump = ThreadDump.parse(jsonText);\n+    \/**\n+     * Test thread dump with a thread parked on a j.u.c. lock and pinned.\n+     *\/\n+    @Test\n+    void testParkedThreadWhenPinned() throws Exception {\n+        assumeTrue(trackAllThreads, \"This test requires all threads to be tracked\");\n+        testParkedThread(Thread.ofVirtual().factory(), true);\n+    }\n@@ -213,2 +392,17 @@\n-        \/\/ test threadDump\/processId\n-        assertTrue(threadDump.processId() == ProcessHandle.current().pid());\n+    void testParkedThread(ThreadFactory factory, boolean pinned) throws Exception {\n+        var lock = new ReentrantLock();\n+        var started = new CountDownLatch(1);\n+\n+        Thread thread = factory.newThread(() -> {\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    started.countDown();\n+                    lock.lock();\n+                    lock.unlock();\n+                });\n+            } else {\n+                started.countDown();\n+                lock.lock();\n+                lock.unlock();\n+            }\n+        });\n@@ -216,2 +410,39 @@\n-        \/\/ test threadDump\/time can be parsed\n-        ZonedDateTime.parse(threadDump.time());\n+        lock.lock();\n+        try {\n+            \/\/ start thread and wait for it to park\n+            thread.start();\n+            started.await();\n+            await(thread, Thread.State.WAITING);\n+\n+            long tid = thread.threadId();\n+\n+            \/\/ thread dump in plain text should include thread\n+            List<String> lines = dumpThreadsToPlainText();\n+            ThreadFields fields = findThread(tid, lines);\n+            assertNotNull(fields, \"thread not found\");\n+            assertEquals(\"WAITING\", fields.state());\n+            assertTrue(contains(lines, \"\/\/ parked on java.util.concurrent.locks.ReentrantLock\"));\n+\n+            \/\/ thread dump in JSON format should include thread in root container\n+            ThreadDump threadDump = dumpThreadsToJson();\n+            ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                    .findThread(thread.threadId())\n+                    .orElse(null);\n+            assertNotNull(ti, \"thread not found\");\n+            assertEquals(ti.isVirtual(), thread.isVirtual());\n+\n+            \/\/ thread should be waiting on the ReentrantLock, owned by the main thread.\n+            assertEquals(\"WAITING\", ti.state());\n+            String parkBlocker = ti.parkBlocker();\n+            assertNotNull(parkBlocker);\n+            assertTrue(parkBlocker.contains(\"java.util.concurrent.locks.ReentrantLock\"));\n+            long ownerTid = ti.exclusiveOwnerThreadId().orElse(-1L);\n+            assertEquals(Thread.currentThread().threadId(), ownerTid);\n+            if (pinned) {\n+                assertTrue(ti.carrier().isPresent(), \"carrier not found\");\n+            }\n+        } finally {\n+            lock.unlock();\n+            thread.join();\n+        }\n+    }\n@@ -219,2 +450,8 @@\n-        \/\/ test threadDump\/runtimeVersion\n-        assertEquals(Runtime.version().toString(), threadDump.runtimeVersion());\n+    \/**\n+     * Test thread dump with a thread owning a monitor.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"threadFactories\")\n+    void testThreadOwnsMonitor(ThreadFactory factory) throws Exception {\n+        testThreadOwnsMonitor(factory, false);\n+    }\n@@ -222,4 +459,5 @@\n-        \/\/ test root container, has no parent and no owner\n-        var rootContainer = threadDump.rootThreadContainer();\n-        assertFalse(rootContainer.owner().isPresent());\n-        assertFalse(rootContainer.parent().isPresent());\n+    @Test\n+    void testThreadOwnsMonitorWhenPinned() throws Exception {\n+        assumeTrue(trackAllThreads, \"This test requires all threads to be tracked\");\n+        testThreadOwnsMonitor(Thread.ofVirtual().factory(), true);\n+    }\n@@ -227,11 +465,17 @@\n-        \/\/ test that the container contains the given thread\n-        ThreadDump.ThreadContainer container;\n-        if (containerName == null) {\n-            \/\/ root container, the thread should be found if trackAllThreads is true\n-            container = rootContainer;\n-        } else {\n-            \/\/ find the container\n-            container = threadDump.findThreadContainer(containerName).orElse(null);\n-            assertNotNull(container, containerName + \" not found\");\n-            assertFalse(container.owner().isPresent());\n-            assertTrue(container.parent().get() == rootContainer);\n+    void testThreadOwnsMonitor(ThreadFactory factory, boolean pinned) throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+\n+        Thread thread = factory.newThread(() -> {\n+            synchronized (lock) {\n+                if (pinned) {\n+                    VThreadPinner.runPinned(() -> {\n+                        started.countDown();\n+                        LockSupport.park();\n+                    });\n+                } else {\n+                    started.countDown();\n+                    LockSupport.park();\n+                }\n+            }\n+        });\n@@ -239,0 +483,33 @@\n+        try {\n+            \/\/ start thread and wait for it to park\n+            thread.start();\n+            started.await();\n+            await(thread, Thread.State.WAITING);\n+\n+            long tid = thread.threadId();\n+            String lockAsString = Objects.toIdentityString(lock);\n+\n+            \/\/ thread dump in plain text should include thread\n+            List<String> lines = dumpThreadsToPlainText();\n+            ThreadFields fields = findThread(tid, lines);\n+            assertNotNull(fields, \"thread not found\");\n+            assertEquals(\"WAITING\", fields.state());\n+            assertTrue(contains(lines, \"\/\/ locked \" + lockAsString));\n+\n+            \/\/ thread dump in JSON format should include thread in root container\n+            ThreadDump threadDump = dumpThreadsToJson();\n+            ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                    .findThread(tid)\n+                    .orElse(null);\n+            assertNotNull(ti, \"thread not found\");\n+            assertEquals(ti.isVirtual(), thread.isVirtual());\n+\n+            \/\/ the lock should be in the ownedMonitors array\n+            Set<String> ownedMonitors = ti.ownedMonitors().values()\n+                    .stream()\n+                    .flatMap(List::stream)\n+                    .collect(Collectors.toSet());\n+            assertTrue(ownedMonitors.contains(lockAsString), lockAsString + \" not found\");\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n@@ -240,2 +517,1 @@\n-        boolean found = container.findThread(thread.threadId()).isPresent();\n-        assertEquals(expectInDump, found);\n+    }\n@@ -243,5 +519,54 @@\n-        \/\/ current thread should be in root container if platform thread or tracking all threads\n-        Thread currentThread = Thread.currentThread();\n-        boolean currentThreadExpected = trackAllThreads || !currentThread.isVirtual();\n-        found = rootContainer.findThread(currentThread.threadId()).isPresent();\n-        assertEquals(currentThreadExpected, found);\n+    \/**\n+     * Test mounted virtual thread.\n+     *\/\n+    @Test\n+    void testMountedVirtualThread() throws Exception {\n+        assumeTrue(trackAllThreads, \"This test requires all threads to be tracked\");\n+\n+        \/\/ start virtual thread that spins until done\n+        var started = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            started.set(true);\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+\n+        try {\n+            \/\/ wait for thread to start\n+            awaitTrue(started);\n+            long tid = thread.threadId();\n+\n+            \/\/ thread dump in plain text should include thread\n+            List<String> lines = dumpThreadsToPlainText();\n+            ThreadFields fields = findThread(tid, lines);\n+            assertNotNull(fields, \"thread not found\");\n+            assertTrue(fields.isVirtual());\n+\n+            \/\/ thread dump in JSON format should include thread in root container\n+            ThreadDump threadDump = dumpThreadsToJson();\n+            ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                    .findThread(tid)\n+                    .orElse(null);\n+            assertNotNull(ti, \"thread not found\");\n+            assertTrue(ti.isVirtual());\n+            assertTrue(ti.carrier().isPresent(), \"carrier not found\");\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Asserts that the given thread identifier is a ForkJoinWorkerThread.\n+     *\/\n+    void assertCarrier(long tid) {\n+        Thread thread = Thread.getAllStackTraces()\n+                .keySet()\n+                .stream()\n+                .filter(t -> t.threadId() == tid)\n+                .findAny()\n+                .orElse(null);\n+        assertNotNull(thread, \"thread \" + tid + \" not found\");\n+        assertTrue(thread instanceof ForkJoinWorkerThread, \"not a ForkJoinWorkerThread\");\n@@ -254,1 +579,1 @@\n-    void testFileAlreadyExsists() throws Exception {\n+    void testFileAlreadyExists() throws Exception {\n@@ -263,0 +588,33 @@\n+    \/**\n+     * Test that dumpThreads throws IOException when the output file cannot be created.\n+     *\/\n+    @Test\n+    void testFileCreateFails() {\n+        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        String badFile = Path.of(\".\").toAbsolutePath()\n+                .resolve(\"does-not-exist\")\n+                .resolve(\"does-not-exist\")\n+                .resolve(\"threads.bad\")\n+                .toString();\n+        assertThrows(IOException.class,\n+                () -> mbean.dumpThreads(badFile, ThreadDumpFormat.TEXT_PLAIN));\n+        assertThrows(IOException.class,\n+                () -> mbean.dumpThreads(badFile, ThreadDumpFormat.JSON));\n+    }\n+\n+    \/**\n+     * Test that dumpThreads throws IOException if writing to output file fails.\n+     *\/\n+    @Test\n+    void testFileWriteFails() {\n+        var out = new OutputStream() {\n+            @Override\n+            public void write(int b) throws IOException {\n+                throw new IOException(\"There is not enough space on the disk\");\n+            }\n+        };\n+        \/\/ need to invoke internal API directly to test this\n+        assertThrows(IOException.class, () -> jdk.internal.vm.ThreadDumper.dumpThreads(out));\n+        assertThrows(IOException.class, () -> jdk.internal.vm.ThreadDumper.dumpThreadsToJson(out));\n+    }\n+\n@@ -267,1 +625,1 @@\n-    void testRelativePath() throws Exception {\n+    void testRelativePath() {\n@@ -279,1 +637,1 @@\n-    void testNull() throws Exception {\n+    void testNull() {\n@@ -288,2 +646,1 @@\n-     * Submits a parking task to the given executor, returns the Thread object of\n-     * the parked thread.\n+     * Represents the data for a thread found in a plain text thread dump.\n@@ -291,12 +648,12 @@\n-    private static Thread forkParker(ExecutorService executor) {\n-        class Box { static volatile Thread thread;}\n-        var latch = new CountDownLatch(1);\n-        executor.submit(() -> {\n-            Box.thread = Thread.currentThread();\n-            latch.countDown();\n-            LockSupport.park();\n-        });\n-        try {\n-            latch.await();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n+    private record ThreadFields(long tid, String name, boolean isVirtual, String state) { }\n+\n+    \/**\n+     * Find a thread in the lines of a plain text thread dump.\n+     *\/\n+    private ThreadFields findThread(long tid, List<String> lines) {\n+        String line = lines.stream()\n+                .filter(l -> l.startsWith(\"#\" + tid + \" \"))\n+                .findFirst()\n+                .orElse(null);\n+        if (line == null) {\n+            return null;\n@@ -304,1 +661,10 @@\n-        return Box.thread;\n+\n+        \/\/ #3 \"main\" RUNNABLE 2025-04-18T15:22:12.012450Z\n+        \/\/ #36 \"\" virtual WAITING 2025-04-18T15:22:12.012450Z\n+        Pattern pattern = Pattern.compile(\"#(\\\\d+)\\\\s+\\\"([^\\\"]*)\\\"\\\\s+(virtual\\\\s+)?(\\\\w+)\\\\s+(.*)\");\n+        Matcher matcher = pattern.matcher(line);\n+        assertTrue(matcher.matches());\n+        String name = matcher.group(2);\n+        boolean isVirtual = \"virtual \".equals(matcher.group(3));\n+        String state = matcher.group(4);\n+        return new ThreadFields(tid, name, isVirtual, state);\n@@ -308,1 +674,1 @@\n-     * Returns true if a Thread is present in a plain text thread dump.\n+     * Returns true if lines of a plain text thread dump contain the given text.\n@@ -310,3 +676,27 @@\n-    private static boolean isPresent(Path file, Thread thread) throws Exception {\n-        String expect = \"#\" + thread.threadId();\n-        return count(file, expect) > 0;\n+    private boolean contains(List<String> lines, String text) {\n+        return lines.stream().map(String::trim)\n+                .anyMatch(l -> l.contains(text));\n+    }\n+\n+    \/**\n+     * Dump threads to a file in plain text format, return the lines in the file.\n+     *\/\n+    private List<String> dumpThreadsToPlainText() throws Exception {\n+        Path file = genOutputPath(\".txt\");\n+        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        mbean.dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.TEXT_PLAIN);\n+        System.err.format(\"Dumped to %s%n\", file.getFileName());\n+        List<String> lines = Files.readAllLines(file);\n+        return lines;\n+    }\n+\n+    \/**\n+     * Dump threads to a file in JSON format, parse and return as JSON object.\n+     *\/\n+    private static ThreadDump dumpThreadsToJson() throws Exception {\n+        Path file = genOutputPath(\".json\");\n+        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        mbean.dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.JSON);\n+        System.err.format(\"Dumped to %s%n\", file.getFileName());\n+        String jsonText = Files.readString(file);\n+        return ThreadDump.parse(jsonText);\n@@ -326,2 +716,1 @@\n-     * Return the count of the number of files in the given file that contain\n-     * the given character sequence.\n+     * Waits for the given thread to get to a given state.\n@@ -329,3 +718,6 @@\n-    static long count(Path file, CharSequence cs) throws Exception {\n-        try (Stream<String> stream = Files.lines(file)) {\n-            return stream.filter(line -> line.contains(cs)).count();\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n@@ -336,1 +728,1 @@\n-     * Return line $n of the given file.\n+     * Waits for the boolean value to become true.\n@@ -338,3 +730,3 @@\n-    private String line(Path file, long n) throws Exception {\n-        try (Stream<String> stream = Files.lines(file)) {\n-            return stream.skip(n).findFirst().orElseThrow();\n+    private static void awaitTrue(AtomicBoolean ref) throws Exception {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java","additions":549,"deletions":157,"binary":false,"changes":706,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356870\n+ * @summary Test HotSpotDiagnosticMXBean.dumpThreads with a thread owning a monitor for\n+ *     an object that is scalar replaced\n+ * @requires !vm.debug & (vm.compMode != \"Xcomp\")\n+ * @requires (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @modules jdk.management\n+ * @library \/test\/lib\n+ * @run main\/othervm DumpThreadsWithEliminatedLock plain platform\n+ * @run main\/othervm DumpThreadsWithEliminatedLock plain virtual\n+ * @run main\/othervm DumpThreadsWithEliminatedLock json platform\n+ * @run main\/othervm DumpThreadsWithEliminatedLock json virtual\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import jdk.test.lib.threaddump.ThreadDump;\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+public class DumpThreadsWithEliminatedLock {\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean plain = switch (args[0]) {\n+            case \"plain\" -> true;\n+            case \"json\"  -> false;\n+            default      -> throw new RuntimeException(\"Unknown dump format\");\n+        };\n+\n+        ThreadFactory factory = switch (args[1]) {\n+            case \"platform\" -> Thread.ofPlatform().factory();\n+            case \"virtual\"  -> Thread.ofVirtual().factory();\n+            default         -> throw new RuntimeException(\"Unknown thread kind\");\n+        };\n+\n+        \/\/ need at least two carriers for JTREG_TEST_THREAD_FACTORY=Virtual\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n+\n+        \/\/ A thread that spins creating and adding to a StringBuffer. StringBuffer is\n+        \/\/ synchronized, assume object will be scalar replaced and the lock eliminated.\n+        var done = new AtomicBoolean();\n+        var ref = new AtomicReference<String>();\n+        Thread thread = factory.newThread(() -> {\n+            while (!done.get()) {\n+                StringBuffer sb = new StringBuffer();\n+                sb.append(System.currentTimeMillis());\n+                String s = sb.toString();\n+                ref.set(s);\n+            }\n+        });\n+        try {\n+            thread.start();\n+            if (plain) {\n+                testPlainFormat();\n+            } else {\n+                testJsonFormat(thread.threadId());\n+            }\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to generate a thread dump in plain text\n+     * format until \"lock is eliminated\" is found in the output.\n+     *\/\n+    private static void testPlainFormat() {\n+        try {\n+            Path file = genOutputPath(\".txt\");\n+            boolean found = false;\n+            int attempts = 0;\n+            while (!found) {\n+                attempts++;\n+                Files.deleteIfExists(file);\n+                ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n+                        .dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.TEXT_PLAIN);\n+                try (Stream<String> stream = Files.lines(file)) {\n+                    found = stream.map(String::trim)\n+                            .anyMatch(l -> l.contains(\"\/\/ lock is eliminated\"));\n+                }\n+                System.out.format(\"%s Attempt %d, found: %b%n\", Instant.now(), attempts, found);\n+            }\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to generate a thread dump in JSON format\n+     * until the monitorsOwned.locks array for the given thread has a null lock.\n+     *\/\n+    private static void testJsonFormat(long tid) {\n+        try {\n+            Path file = genOutputPath(\".json\");\n+            boolean found = false;\n+            int attempts = 0;\n+            while (!found) {\n+                attempts++;\n+                Files.deleteIfExists(file);\n+                ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n+                        .dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.JSON);\n+\n+                \/\/ parse thread dump as JSON and find thread\n+                String jsonText = Files.readString(file);\n+                ThreadDump threadDump = ThreadDump.parse(jsonText);\n+                ThreadDump.ThreadInfo ti = threadDump.rootThreadContainer()\n+                        .findThread(tid)\n+                        .orElse(null);\n+                if (ti == null) {\n+                    throw new RuntimeException(\"Thread \" + tid + \" not found in thread dump\");\n+                }\n+\n+                \/\/ look for null element in ownedMonitors\/locks array\n+                found = ti.ownedMonitors()\n+                        .values()\n+                        .stream()\n+                        .flatMap(List::stream)\n+                        .anyMatch(o -> o == null);\n+                System.out.format(\"%s Attempt %d, found: %b%n\", Instant.now(), attempts, found);\n+            }\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Generate a file path with the given suffix to use as an output file.\n+     *\/\n+    private static Path genOutputPath(String suffix) throws IOException {\n+        Path dir = Path.of(\".\").toAbsolutePath();\n+        Path file = Files.createTempFile(dir, \"dump\", suffix);\n+        Files.delete(file);\n+        return file;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreadsWithEliminatedLock.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.LinkedHashMap;\n@@ -65,0 +66,1 @@\n+ *            \"state\": \"RUNNABLE\",\n@@ -116,4 +118,11 @@\n-    private final long processId;\n-    private final String time;\n-    private final String runtimeVersion;\n-    private ThreadContainer rootThreadContainer;\n+    private final ThreadContainer rootThreadContainer;\n+    private final Map<String, ThreadContainer> nameToThreadContainer;\n+    private final JSONValue threadDumpObj;\n+\n+    private ThreadDump(ThreadContainer rootThreadContainer,\n+                       Map<String, ThreadContainer> nameToThreadContainer,\n+                       JSONValue threadDumpObj) {\n+        this.rootThreadContainer = rootThreadContainer;\n+        this.nameToThreadContainer = nameToThreadContainer;\n+        this.threadDumpObj = threadDumpObj;\n+    }\n@@ -126,3 +135,1 @@\n-        private long owner;\n-        private ThreadContainer parent;\n-        private Set<ThreadInfo> threads;\n+        private final ThreadContainer parent;\n@@ -130,0 +137,1 @@\n+        private final JSONValue containerObj;\n@@ -131,1 +139,1 @@\n-        ThreadContainer(String name) {\n+        ThreadContainer(String name, ThreadContainer parent, JSONValue containerObj) {\n@@ -133,0 +141,17 @@\n+            this.parent = parent;\n+            this.containerObj = containerObj;\n+        }\n+\n+        \/**\n+         * Add a child thread container.\n+         *\/\n+        void addChild(ThreadContainer container) {\n+            children.add(container);\n+        }\n+\n+        \/**\n+         * Returns the value of a property of this thread container, as a string.\n+         *\/\n+        private String getStringProperty(String propertyName) {\n+            JSONValue value = containerObj.get(propertyName);\n+            return (value != null) ? value.asString() : null;\n@@ -146,1 +171,4 @@\n-           return (owner != 0) ? OptionalLong.of(owner) : OptionalLong.empty();\n+            String owner = getStringProperty(\"owner\");\n+            return (owner != null)\n+                    ? OptionalLong.of(Long.parseLong(owner))\n+                    : OptionalLong.empty();\n@@ -167,1 +195,6 @@\n-            return threads.stream();\n+            JSONValue.JSONArray threadsObj = containerObj.get(\"threads\").asArray();\n+            Set<ThreadInfo> threadInfos = new HashSet<>();\n+            for (JSONValue threadObj : threadsObj) {\n+                threadInfos.add(new ThreadInfo(threadObj));\n+            }\n+            return threadInfos.stream();\n@@ -179,15 +212,0 @@\n-        \/**\n-         * Helper method to recursively find a container with the given name.\n-         *\/\n-        ThreadContainer findThreadContainer(String name) {\n-            if (name().equals(name))\n-                return this;\n-            if (name().startsWith(name + \"\/\"))\n-                return this;\n-            return children()\n-                    .map(c -> c.findThreadContainer(name))\n-                    .filter(c -> c != null)\n-                    .findAny()\n-                    .orElse(null);\n-        }\n-\n@@ -219,2 +237,1 @@\n-        private final String name;\n-        private final List<String> stack;\n+        private final JSONValue threadObj;\n@@ -222,4 +239,22 @@\n-        ThreadInfo(long tid, String name, List<String> stack) {\n-            this.tid = tid;\n-            this.name = name;\n-            this.stack = stack;\n+        ThreadInfo(JSONValue threadObj) {\n+            this.tid = Long.parseLong(threadObj.get(\"tid\").asString());\n+            this.threadObj = threadObj;\n+        }\n+\n+        \/**\n+         * Returns the value of a property of this thread object, as a string.\n+         *\/\n+        private String getStringProperty(String propertyName) {\n+            JSONValue value = threadObj.get(propertyName);\n+            return (value != null) ? value.asString() : null;\n+        }\n+\n+        \/**\n+         * Returns the value of a property of an object in this thread object, as a string.\n+         *\/\n+        private String getStringProperty(String objectName, String propertyName) {\n+            if (threadObj.get(objectName) instanceof JSONValue.JSONObject obj\n+                    && obj.get(propertyName) instanceof JSONValue value) {\n+                return value.asString();\n+            }\n+            return null;\n@@ -239,1 +274,47 @@\n-            return name;\n+            return getStringProperty(\"name\");\n+        }\n+\n+        \/**\n+         * Returns the thread state.\n+         *\/\n+        public String state() {\n+            return getStringProperty(\"state\");\n+        }\n+\n+        \/**\n+         * Returns true if virtual thread.\n+         *\/\n+        public boolean isVirtual() {\n+            String s = getStringProperty(\"virtual\");\n+            return (s != null) ? Boolean.parseBoolean(s) : false;\n+        }\n+\n+        \/**\n+         * Returns the thread's parkBlocker.\n+         *\/\n+        public String parkBlocker() {\n+            return getStringProperty(\"parkBlocker\", \"object\");\n+        }\n+\n+        \/**\n+         * Returns the thread ID of the owner thread if the parkBlocker is an AQS.\n+         *\/\n+        public OptionalLong exclusiveOwnerThreadId() {\n+            String s = getStringProperty(\"parkBlocker\", \"exclusiveOwnerThreadId\");\n+            return (s != null)\n+                    ? OptionalLong.of(Long.parseLong(s))\n+                    : OptionalLong.empty();\n+        }\n+\n+        \/**\n+         * Returns the object that the thread is blocked entering its monitor.\n+         *\/\n+        public String blockedOn() {\n+            return getStringProperty(\"blockedOn\");\n+        }\n+\n+        \/**\n+         * Return the object that is the therad is waiting on with Object.wait.\n+         *\/\n+        public String waitingOn() {\n+            return getStringProperty(\"waitingOn\");\n@@ -246,0 +327,5 @@\n+            JSONValue.JSONArray stackObj = threadObj.get(\"stack\").asArray();\n+            List<String> stack = new ArrayList<>();\n+            for (JSONValue steObject : stackObj) {\n+                stack.add(steObject.asString());\n+            }\n@@ -249,0 +335,29 @@\n+        \/**\n+         * Return a map of monitors owned.\n+         *\/\n+        public Map<Integer, List<String>> ownedMonitors() {\n+            Map<Integer, List<String>> ownedMonitors = new HashMap<>();\n+            JSONValue monitorsOwnedObj = threadObj.get(\"monitorsOwned\");\n+            if (monitorsOwnedObj != null) {\n+                for (JSONValue obj : monitorsOwnedObj.asArray()) {\n+                    int depth = Integer.parseInt(obj.get(\"depth\").asString());\n+                    for (JSONValue lock : obj.get(\"locks\").asArray()) {\n+                        ownedMonitors.computeIfAbsent(depth, _ -> new ArrayList<>())\n+                                .add(lock.asString());\n+                    }\n+                }\n+            }\n+            return ownedMonitors;\n+        }\n+\n+        \/**\n+         * If the thread is a mounted virtual thread, return the thread identifier of\n+         * its carrier.\n+         *\/\n+        public OptionalLong carrier() {\n+            String s = getStringProperty(\"carrier\");\n+            return (s != null)\n+                    ? OptionalLong.of(Long.parseLong(s))\n+                    : OptionalLong.empty();\n+        }\n+\n@@ -267,0 +382,1 @@\n+            String name = name();\n@@ -276,1 +392,1 @@\n-     * Parses the given JSON text as a thread dump.\n+     * Returns the value of a property of this thread dump, as a string.\n@@ -278,46 +394,3 @@\n-    private ThreadDump(String json) {\n-        JSONValue threadDumpObj = JSONValue.parse(json).get(\"threadDump\");\n-\n-        \/\/ maps container name to ThreadContainer\n-        Map<String, ThreadContainer> map = new HashMap<>();\n-\n-        \/\/ threadContainers array\n-        JSONValue threadContainersObj = threadDumpObj.get(\"threadContainers\");\n-        for (JSONValue containerObj : threadContainersObj.asArray()) {\n-            String name = containerObj.get(\"container\").asString();\n-            String parentName = containerObj.get(\"parent\").asString();\n-            String owner = containerObj.get(\"owner\").asString();\n-            JSONValue.JSONArray threadsObj = containerObj.get(\"threads\").asArray();\n-\n-            \/\/ threads array\n-            Set<ThreadInfo> threadInfos = new HashSet<>();\n-            for (JSONValue threadObj : threadsObj) {\n-                long tid = Long.parseLong(threadObj.get(\"tid\").asString());\n-                String threadName = threadObj.get(\"name\").asString();\n-                JSONValue.JSONArray stackObj = threadObj.get(\"stack\").asArray();\n-                List<String> stack = new ArrayList<>();\n-                for (JSONValue steObject : stackObj) {\n-                    stack.add(steObject.asString());\n-                }\n-                threadInfos.add(new ThreadInfo(tid, threadName, stack));\n-            }\n-\n-            \/\/ add to map if not already encountered\n-            var container = map.computeIfAbsent(name, k -> new ThreadContainer(name));\n-            if (owner != null)\n-                container.owner = Long.parseLong(owner);\n-            container.threads = threadInfos;\n-\n-            if (parentName == null) {\n-                rootThreadContainer = container;\n-            } else {\n-                \/\/ add parent to map if not already encountered and add to its set of children\n-                var parent = map.computeIfAbsent(parentName, k -> new ThreadContainer(parentName));\n-                container.parent = parent;\n-                parent.children.add(container);\n-            }\n-        }\n-\n-        this.processId = Long.parseLong(threadDumpObj.get(\"processId\").asString());\n-        this.time = threadDumpObj.get(\"time\").asString();\n-        this.runtimeVersion = threadDumpObj.get(\"runtimeVersion\").asString();\n+    private String getStringProperty(String propertyName) {\n+        JSONValue value = threadDumpObj.get(propertyName);\n+        return (value != null) ? value.asString() : null;\n@@ -330,1 +403,1 @@\n-        return processId;\n+        return Long.parseLong(getStringProperty(\"processId\"));\n@@ -337,1 +410,1 @@\n-        return time;\n+        return getStringProperty(\"time\");\n@@ -344,1 +417,1 @@\n-        return runtimeVersion;\n+        return getStringProperty(\"runtimeVersion\");\n@@ -358,2 +431,11 @@\n-        ThreadContainer container = rootThreadContainer.findThreadContainer(name);\n-        return Optional.ofNullable(container);\n+        ThreadContainer container = nameToThreadContainer.get(name);\n+        if (container == null) {\n+            \/\/ may be name\/identity format\n+            container = nameToThreadContainer.entrySet()\n+                    .stream()\n+                    .filter(e -> e.getKey().startsWith(name + \"\/\"))\n+                    .map(e -> e.getValue())\n+                    .findAny()\n+                    .orElse(null);\n+        }\n+        return Optional.of(container);\n@@ -367,1 +449,31 @@\n-        return new ThreadDump(json);\n+        JSONValue threadDumpObj = JSONValue.parse(json).get(\"threadDump\");\n+\n+        \/\/ threadContainers array, preserve insertion order (parents are added before children)\n+        Map<String, JSONValue> containerObjs = new LinkedHashMap<>();\n+        JSONValue threadContainersObj = threadDumpObj.get(\"threadContainers\");\n+        for (JSONValue containerObj : threadContainersObj.asArray()) {\n+            String name = containerObj.get(\"container\").asString();\n+            containerObjs.put(name, containerObj);\n+        }\n+\n+        \/\/ find root and create tree of thread containers\n+        ThreadContainer root = null;\n+        Map<String, ThreadContainer> map = new HashMap<>();\n+        for (String name : containerObjs.keySet()) {\n+            JSONValue containerObj = containerObjs.get(name);\n+            String parentName = containerObj.get(\"parent\").asString();\n+            if (parentName == null) {\n+                root = new ThreadContainer(name, null, containerObj);\n+                map.put(name, root);\n+            } else {\n+                var parent = map.get(parentName);\n+                if (parent == null) {\n+                    throw new RuntimeException(\"Thread container \" + name + \" found before \" + parentName);\n+                }\n+                var container = new ThreadContainer(name, parent, containerObj);\n+                parent.addChild(container);\n+                map.put(name, container);\n+            }\n+        }\n+\n+        return new ThreadDump(root, map, threadDumpObj);\n@@ -369,1 +481,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/lib\/jdk\/test\/lib\/threaddump\/ThreadDump.java","additions":199,"deletions":87,"binary":false,"changes":286,"status":"modified"}]}