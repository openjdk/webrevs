{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -28,0 +29,7 @@\n+STATIC_ASSERT(std::is_trivially_copyable_v<ResolvedFieldEntry> == true);\n+#ifdef _LP64\n+STATIC_ASSERT(sizeof(ResolvedFieldEntry) == 24);\n+#else\n+STATIC_ASSERT(sizeof(ResolvedFieldEntry) == 16);\n+#endif\n+\n@@ -49,1 +57,1 @@\n-  memset(this, 0, sizeof(*this));\n+  memset((void *) this, 0, sizeof(*this));\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+\/\/ Verify no compiler paddings are present, check STATIC_ASSERTs in the .cpp file.\n+\n@@ -57,11 +59,3 @@\n-\n-  void copy_from(const ResolvedFieldEntry& other) {\n-    _field_holder = other._field_holder;\n-    _field_offset = other._field_offset;\n-    _field_index = other._field_index;\n-    _cpool_index = other._cpool_index;\n-    _tos_state = other._tos_state;\n-    _flags = other._flags;\n-    _get_code = other._get_code;\n-    _put_code = other._put_code;\n-  }\n+#ifdef _LP64\n+  u4 _padding;\n+#endif\n@@ -78,1 +72,2 @@\n-    _put_code(0) {}\n+    _put_code(0),\n+    _padding(0) {}\n@@ -83,37 +78,0 @@\n-  \/\/ Notes on copy constructor, copy assignment operator, and copy_from().\n-  \/\/ These are necessary for generating deterministic CDS archives.\n-  \/\/\n-  \/\/ We have some unused padding on 64-bit platforms (4 bytes at the tail end).\n-  \/\/\n-  \/\/ When ResolvedFieldEntries in a ConstantPoolCache are allocated from the metaspace,\n-  \/\/ their entire content (including the padding) is filled with zeros. They are\n-  \/\/ then initialized with initialize_resolved_entries_array() in cpCache.cpp from a\n-  \/\/ GrowableArray.\n-  \/\/\n-  \/\/ The GrowableArray is initialized in rewriter.cpp, using ResolvedFieldEntries that\n-  \/\/ are originally allocated from the C++ stack. Functions like GrowableArray::expand_to()\n-  \/\/ will also allocate ResolvedFieldEntries from the stack. These may have random bits\n-  \/\/ in the padding as the C++ compiler is allowed to leave the padding in uninitialized\n-  \/\/ states.\n-  \/\/\n-  \/\/ If we use the default copy constructor and\/or default copy assignment operator,\n-  \/\/ the random padding will be copied into the GrowableArray, from there\n-  \/\/ to the ConstantPoolCache, and eventually to the CDS archive. As a result, the\n-  \/\/ CDS archive will contain random bits, causing failures in\n-  \/\/ test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java (usually on Windows).\n-  \/\/\n-  \/\/ By using copy_from(), we can prevent the random padding from being copied,\n-  \/\/ ensuring that the ResolvedFieldEntries in a ConstantPoolCache (and thus the\n-  \/\/ CDS archive) will have all zeros in the padding.\n-\n-  \/\/ Copy constructor\n-  ResolvedFieldEntry(const ResolvedFieldEntry& other) {\n-    copy_from(other);\n-  }\n-\n-  \/\/ Copy assignment operator\n-  ResolvedFieldEntry& operator=(const ResolvedFieldEntry& other) {\n-    copy_from(other);\n-    return *this;\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":7,"deletions":49,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -29,0 +30,15 @@\n+STATIC_ASSERT(std::is_trivially_copyable_v<ResolvedMethodEntry> == true);\n+#ifdef _LP64\n+# ifdef ASSERT\n+STATIC_ASSERT(sizeof(ResolvedMethodEntry) == 32);\n+# else\n+STATIC_ASSERT(sizeof(ResolvedMethodEntry) == 24);\n+# endif\n+#else\n+# ifdef ASSERT\n+STATIC_ASSERT(sizeof(ResolvedMethodEntry) == 20);\n+# else\n+STATIC_ASSERT(sizeof(ResolvedMethodEntry) == 16);\n+# endif\n+#endif\n+\n@@ -43,1 +59,1 @@\n-    memset(this, 0, sizeof(*this));\n+    memset((void *) this, 0, sizeof(*this));\n@@ -48,1 +64,1 @@\n-    memset(this, 0, sizeof(*this));\n+    memset((void *) this, 0, sizeof(*this));\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+\/\/ Verify no compiler paddings are present, check STATIC_ASSERTs in the .cpp file.\n+\n@@ -73,0 +75,1 @@\n+    \/\/ The padding field is unused here, as the parent constructor zeroes the union.\n@@ -83,0 +86,7 @@\n+# ifdef _LP64\n+  u2 _padding1;\n+  u4 _padding2;\n+# else\n+  u1 _padding1;\n+  u1 _padding2;\n+# endif\n@@ -85,17 +95,0 @@\n-  \/\/ See comments in resolvedFieldEntry.hpp about copy_from and padding.\n-  \/\/ We have unused padding on debug builds.\n-  void copy_from(const ResolvedMethodEntry& other) {\n-    _method = other._method;\n-    _entry_specific = other._entry_specific;\n-    _cpool_index = other._cpool_index;\n-    _number_of_parameters = other._number_of_parameters;\n-    _tos_state = other._tos_state;\n-    _flags = other._flags;\n-    _bytecode1 = other._bytecode1;\n-    _bytecode2 = other._bytecode2;\n-#ifdef ASSERT\n-    _has_interface_klass = other._has_interface_klass;\n-    _has_table_index = other._has_table_index;\n-#endif\n-  }\n-\n@@ -106,0 +99,1 @@\n+      _entry_specific{nullptr},\n@@ -111,5 +105,8 @@\n-      _bytecode2(0) {\n-        _entry_specific._interface_klass = nullptr;\n-        DEBUG_ONLY(_has_interface_klass = false;)\n-        DEBUG_ONLY(_has_table_index = false;)\n-      }\n+      _bytecode2(0)\n+#ifdef ASSERT\n+      , _has_interface_klass(false),\n+      _has_table_index(false),\n+      _padding1(0),\n+      _padding2(0)\n+#endif\n+      {}\n@@ -119,9 +116,0 @@\n-    ResolvedMethodEntry(const ResolvedMethodEntry& other) {\n-      copy_from(other);\n-    }\n-\n-    ResolvedMethodEntry& operator=(const ResolvedMethodEntry& other) {\n-      copy_from(other);\n-      return *this;\n-    }\n-\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":19,"deletions":31,"binary":false,"changes":50,"status":"modified"}]}