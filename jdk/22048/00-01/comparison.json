{"files":[{"patch":"@@ -241,1 +241,5 @@\n-        buf = new byte[size];\n+        if (getClass() == BufferedInputStream.class) {\n+            buf = EMPTY;\n+        } else {\n+            buf = new byte[size];\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -89,0 +89,5 @@\n+        if (getClass() == BufferedOutputStream.class) {\n+            this.buf = new byte[initialSize];    \/\/ resizable\n+        } else {\n+            this.buf = new byte[maxSize];\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedOutputStream.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -692,14 +691,0 @@\n-        Object lock = s.lock();\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                lockedPrintStackTrace(s);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else synchronized (lock) {\n-            lockedPrintStackTrace(s);\n-        }\n-    }\n-\n-    private void lockedPrintStackTrace(PrintStreamOrWriter s) {\n@@ -711,5 +696,6 @@\n-        \/\/ Print our stack trace\n-        s.println(this);\n-        StackTraceElement[] trace = getOurStackTrace();\n-        for (StackTraceElement traceElement : trace)\n-            s.println(\"\\tat \" + traceElement);\n+        synchronized(s.lock()) {\n+            \/\/ Print our stack trace\n+            s.println(this);\n+            StackTraceElement[] trace = getOurStackTrace();\n+            for (StackTraceElement traceElement : trace)\n+                s.println(\"\\tat \" + traceElement);\n@@ -717,3 +703,3 @@\n-        \/\/ Print suppressed exceptions, if any\n-        for (Throwable se : getSuppressed())\n-            se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, \"\\t\", dejaVu);\n+            \/\/ Print suppressed exceptions, if any\n+            for (Throwable se : getSuppressed())\n+                se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, \"\\t\", dejaVu);\n@@ -721,4 +707,5 @@\n-        \/\/ Print cause, if any\n-        Throwable ourCause = getCause();\n-        if (ourCause != null)\n-            ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, \"\", dejaVu);\n+            \/\/ Print cause, if any\n+            Throwable ourCause = getCause();\n+            if (ourCause != null)\n+                ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, \"\", dejaVu);\n+        }\n@@ -736,1 +723,1 @@\n-        assert s.isLockedByCurrentThread();\n+        assert Thread.holdsLock(s.lock());\n@@ -788,9 +775,0 @@\n-        boolean isLockedByCurrentThread() {\n-            Object lock = lock();\n-            if (lock instanceof InternalLock locker) {\n-                return locker.isHeldByCurrentThread();\n-            } else {\n-                return Thread.holdsLock(lock);\n-            }\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Throwable.java","additions":16,"deletions":38,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.misc;\n-\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-\/**\n- * A reentrant mutual exclusion lock for internal use. The lock does not\n- * implement {@link java.util.concurrent.locks.Lock} or extend {@link\n- * java.util.concurrent.locks.ReentrantLock} so that it can be distinguished\n- * from lock objects accessible to subclasses of {@link java.io.Reader} and\n- * {@link java.io.Writer} (it is possible to create a Reader that uses a\n- * lock object of type ReentrantLock for example).\n- *\/\n-public class InternalLock {\n-    private static final boolean CAN_USE_INTERNAL_LOCK;\n-    static {\n-        String s = System.getProperty(\"jdk.io.useMonitors\");\n-        if (s != null && s.equals(\"false\")) {\n-            CAN_USE_INTERNAL_LOCK = true;\n-        } else {\n-            CAN_USE_INTERNAL_LOCK = false;\n-        }\n-    }\n-\n-    private final ReentrantLock lock;\n-\n-    private InternalLock() {\n-        this.lock = new ReentrantLock();\n-    }\n-\n-    \/**\n-     * Returns a new InternalLock or null.\n-     *\/\n-    public static InternalLock newLockOrNull() {\n-        return (CAN_USE_INTERNAL_LOCK) ? new InternalLock() : null;\n-    }\n-\n-    \/**\n-     * Returns a new InternalLock or the given object.\n-     *\/\n-    public static Object newLockOr(Object obj) {\n-        return (CAN_USE_INTERNAL_LOCK) ? new InternalLock() : obj;\n-    }\n-\n-    public boolean tryLock() {\n-        return lock.tryLock();\n-    }\n-\n-    public void lock() {\n-        lock.lock();\n-    }\n-\n-    public void unlock() {\n-        lock.unlock();\n-    }\n-\n-    public boolean isHeldByCurrentThread() {\n-        return lock.isHeldByCurrentThread();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/InternalLock.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,0 @@\n-import jdk.internal.misc.InternalLock;\n-\n@@ -124,0 +122,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n@@ -125,11 +124,5 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return lockedRead0();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                return lockedRead0();\n+        synchronized (lock) {\n+            \/\/ Return the leftover char, if there is one\n+            if (haveLeftoverChar) {\n+                haveLeftoverChar = false;\n+                return leftoverChar;\n@@ -137,10 +130,0 @@\n-        }\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    private int lockedRead0() throws IOException {\n-        \/\/ Return the leftover char, if there is one\n-        if (haveLeftoverChar) {\n-            haveLeftoverChar = false;\n-            return leftoverChar;\n-        }\n@@ -148,15 +131,16 @@\n-        \/\/ Convert more bytes\n-        char[] cb = new char[2];\n-        int n = read(cb, 0, 2);\n-        switch (n) {\n-        case -1:\n-            return -1;\n-        case 2:\n-            leftoverChar = cb[1];\n-            haveLeftoverChar = true;\n-            \/\/ FALL THROUGH\n-        case 1:\n-            return cb[0];\n-        default:\n-            assert false : n;\n-            return -1;\n+            \/\/ Convert more bytes\n+            char[] cb = new char[2];\n+            int n = read(cb, 0, 2);\n+            switch (n) {\n+            case -1:\n+                return -1;\n+            case 2:\n+                leftoverChar = cb[1];\n+                haveLeftoverChar = true;\n+                \/\/ FALL THROUGH\n+            case 1:\n+                return cb[0];\n+            default:\n+                assert false : n;\n+                return -1;\n+            }\n@@ -167,7 +151,8 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return lockedRead(cbuf, offset, length);\n-            } finally {\n-                locker.unlock();\n+        synchronized (lock) {\n+            int off = offset;\n+            int len = length;\n+\n+            ensureOpen();\n+            if ((off < 0) || (off > cbuf.length) || (len < 0) ||\n+                ((off + len) > cbuf.length) || ((off + len) < 0)) {\n+                throw new IndexOutOfBoundsException();\n@@ -175,3 +160,14 @@\n-        } else {\n-            synchronized (lock) {\n-                return lockedRead(cbuf, offset, length);\n+            if (len == 0)\n+                return 0;\n+\n+            int n = 0;\n+\n+            if (haveLeftoverChar) {\n+                \/\/ Copy the leftover char into the buffer\n+                cbuf[off] = leftoverChar;\n+                off++; len--;\n+                haveLeftoverChar = false;\n+                n = 1;\n+                if ((len == 0) || !implReady())\n+                    \/\/ Return now if this is all we can produce w\/o blocking\n+                    return n;\n@@ -179,2 +175,0 @@\n-        }\n-    }\n@@ -182,3 +176,8 @@\n-    private int lockedRead(char[] cbuf, int offset, int length) throws IOException {\n-        int off = offset;\n-        int len = length;\n+            if (len == 1) {\n+                \/\/ Treat single-character array reads just like read()\n+                int c = read0();\n+                if (c == -1)\n+                    return (n == 0) ? -1 : n;\n+                cbuf[off] = (char)c;\n+                return n + 1;\n+            }\n@@ -186,20 +185,2 @@\n-        ensureOpen();\n-        if ((off < 0) || (off > cbuf.length) || (len < 0) ||\n-            ((off + len) > cbuf.length) || ((off + len) < 0)) {\n-            throw new IndexOutOfBoundsException();\n-        }\n-        if (len == 0)\n-            return 0;\n-\n-        int n = 0;\n-\n-        if (haveLeftoverChar) {\n-            \/\/ Copy the leftover char into the buffer\n-            cbuf[off] = leftoverChar;\n-            off++; len--;\n-            haveLeftoverChar = false;\n-            n = 1;\n-            if ((len == 0) || !implReady())\n-                \/\/ Return now if this is all we can produce w\/o blocking\n-                return n;\n-        }\n+            \/\/ Read remaining characters\n+            int nr = implRead(cbuf, off, off + len);\n@@ -207,7 +188,4 @@\n-        if (len == 1) {\n-            \/\/ Treat single-character array reads just like read()\n-            int c = read0();\n-            if (c == -1)\n-                return (n == 0) ? -1 : n;\n-            cbuf[off] = (char)c;\n-            return n + 1;\n+            \/\/ At this point, n is either 1 if a leftover character was read,\n+            \/\/ or 0 if no leftover character was read. If n is 1 and nr is -1,\n+            \/\/ indicating EOF, then we don't return their sum as this loses data.\n+            return (nr < 0) ? (n == 1 ? 1 : nr) : (n + nr);\n@@ -215,8 +193,0 @@\n-\n-        \/\/ Read remaining characters\n-        int nr = implRead(cbuf, off, off + len);\n-\n-        \/\/ At this point, n is either 1 if a leftover character was read,\n-        \/\/ or 0 if no leftover character was read. If n is 1 and nr is -1,\n-        \/\/ indicating EOF, then we don't return their sum as this loses data.\n-        return (nr < 0) ? (n == 1 ? 1 : nr) : (n + nr);\n@@ -226,12 +196,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return lockedReady();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                return lockedReady();\n-            }\n+        synchronized (lock) {\n+            ensureOpen();\n+            return haveLeftoverChar || implReady();\n@@ -241,5 +202,0 @@\n-    private boolean lockedReady() throws IOException {\n-        ensureOpen();\n-        return haveLeftoverChar || implReady();\n-    }\n-\n@@ -247,3 +203,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n+            if (closed)\n+                return;\n@@ -251,1 +207,1 @@\n-                lockedClose();\n+                implClose();\n@@ -253,5 +209,1 @@\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedClose();\n+                closed = true;\n@@ -262,10 +214,0 @@\n-    private void lockedClose() throws IOException {\n-        if (closed)\n-            return;\n-        try {\n-            implClose();\n-        } finally {\n-            closed = true;\n-        }\n-    }\n-\n@@ -277,12 +219,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                lockedFillZeroToPosition();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedFillZeroToPosition();\n-            }\n+        synchronized (lock) {\n+            Arrays.fill(bb.array(), bb.arrayOffset(),\n+                        bb.arrayOffset() + bb.position(), (byte)0);\n@@ -292,4 +225,0 @@\n-    private void lockedFillZeroToPosition() {\n-        Arrays.fill(bb.array(), bb.arrayOffset(), bb.arrayOffset() + bb.position(), (byte)0);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamDecoder.java","additions":70,"deletions":141,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -100,12 +99,5 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                lockedFlushBuffer();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedFlushBuffer();\n-            }\n+        synchronized (lock) {\n+            if (isOpen())\n+                implFlushBuffer();\n+            else\n+                throw new IOException(\"Stream closed\");\n@@ -115,7 +107,0 @@\n-    private void lockedFlushBuffer() throws IOException {\n-        if (isOpen())\n-            implFlushBuffer();\n-        else\n-            throw new IOException(\"Stream closed\");\n-    }\n-\n@@ -129,18 +114,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                lockedWrite(cbuf, off, len);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedWrite(cbuf, off, len);\n-            }\n-        }\n-    }\n-\n-    private void lockedWrite(char[] cbuf, int off, int len) throws IOException {\n-        ensureOpen();\n-        if ((off < 0) || (off > cbuf.length) || (len < 0) ||\n+        synchronized (lock) {\n+            ensureOpen();\n+            if ((off < 0) || (off > cbuf.length) || (len < 0) ||\n@@ -148,3 +118,5 @@\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n-            return;\n+                throw new IndexOutOfBoundsException();\n+            } else if (len == 0) {\n+                return;\n+            }\n+            implWrite(cbuf, off, len);\n@@ -152,1 +124,0 @@\n-        implWrite(cbuf, off, len);\n@@ -167,12 +138,3 @@\n-            Object lock = this.lock;\n-            if (lock instanceof InternalLock locker) {\n-                locker.lock();\n-                try {\n-                    lockedWrite(cb);\n-                } finally {\n-                    locker.unlock();\n-                }\n-            } else {\n-                synchronized (lock) {\n-                    lockedWrite(cb);\n-                }\n+            synchronized (lock) {\n+                ensureOpen();\n+                implWrite(cb);\n@@ -185,5 +147,0 @@\n-    private void lockedWrite(CharBuffer cb) throws IOException {\n-        ensureOpen();\n-        implWrite(cb);\n-    }\n-\n@@ -191,12 +148,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                lockedFlush();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedFlush();\n-            }\n+        synchronized (lock) {\n+            ensureOpen();\n+            implFlush();\n@@ -206,5 +154,0 @@\n-    private void lockedFlush() throws IOException {\n-        ensureOpen();\n-        implFlush();\n-    }\n-\n@@ -212,3 +155,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n+            if (closed)\n+                return;\n@@ -216,1 +159,1 @@\n-                lockedClose();\n+                implClose();\n@@ -218,5 +161,1 @@\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedClose();\n+                closed = true;\n@@ -227,10 +166,0 @@\n-    private void lockedClose() throws IOException {\n-        if (closed)\n-            return;\n-        try {\n-            implClose();\n-        } finally {\n-            closed = true;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamEncoder.java","additions":25,"deletions":96,"binary":false,"changes":121,"status":"modified"}]}