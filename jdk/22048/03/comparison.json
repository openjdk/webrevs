{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -77,3 +76,0 @@\n-    \/\/ initialized to null when BufferedInputStream is sub-classed\n-    private final InternalLock lock;\n-\n@@ -246,2 +242,1 @@\n-            \/\/ use internal lock and lazily create buffer when not subclassed\n-            lock = InternalLock.newLockOrNull();\n+            \/\/ lazily create buffer when not subclassed\n@@ -250,2 +245,0 @@\n-            \/\/ use monitors and eagerly create buffer when subclassed\n-            lock = null;\n@@ -259,1 +252,1 @@\n-     * Assumes that it is being called by a locked method.\n+     * Assumes that it is being called by a synchronized method.\n@@ -313,16 +306,1 @@\n-    public int read() throws IOException {\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                return implRead();\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                return implRead();\n-            }\n-        }\n-    }\n-\n-    private int implRead() throws IOException {\n+    public synchronized int read() throws IOException {\n@@ -400,16 +378,1 @@\n-    public int read(byte[] b, int off, int len) throws IOException {\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                return implRead(b, off, len);\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                return implRead(b, off, len);\n-            }\n-        }\n-    }\n-\n-    private int implRead(byte[] b, int off, int len) throws IOException {\n+    public synchronized int read(byte[] b, int off, int len) throws IOException {\n@@ -447,16 +410,1 @@\n-    public long skip(long n) throws IOException {\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                return implSkip(n);\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                return implSkip(n);\n-            }\n-        }\n-    }\n-\n-    private long implSkip(long n) throws IOException {\n+    public synchronized long skip(long n) throws IOException {\n@@ -503,16 +451,1 @@\n-    public int available() throws IOException {\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                return implAvailable();\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                return implAvailable();\n-            }\n-        }\n-    }\n-\n-    private int implAvailable() throws IOException {\n+    public synchronized int available() throws IOException {\n@@ -534,16 +467,1 @@\n-    public void mark(int readlimit) {\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                implMark(readlimit);\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                implMark(readlimit);\n-            }\n-        }\n-    }\n-\n-    private void implMark(int readlimit) {\n+    public synchronized void mark(int readlimit) {\n@@ -570,16 +488,1 @@\n-    public void reset() throws IOException {\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                implReset();\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                implReset();\n-            }\n-        }\n-    }\n-\n-    private void implReset() throws IOException {\n+    public synchronized void reset() throws IOException {\n@@ -631,1 +534,1 @@\n-    public long transferTo(OutputStream out) throws IOException {\n+    public synchronized long transferTo(OutputStream out) throws IOException {\n@@ -633,15 +536,0 @@\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                return implTransferTo(out);\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                return implTransferTo(out);\n-            }\n-        }\n-    }\n-\n-    private long implTransferTo(OutputStream out) throws IOException {\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":9,"deletions":121,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -50,3 +49,0 @@\n-    \/\/ initialized to null when BufferedOutputStream is sub-classed\n-    private final InternalLock lock;\n-\n@@ -93,3 +89,2 @@\n-            \/\/ use InternalLock and resizable buffer when not sub-classed\n-            this.lock = InternalLock.newLockOrNull();\n-            this.buf = new byte[initialSize];    \/\/ resizable\n+            \/\/ resizable if initialSize < maxSize\n+            this.buf = new byte[initialSize];\n@@ -97,2 +92,0 @@\n-            \/\/ use monitors and no resizing when sub-classed\n-            this.lock = null;\n@@ -139,2 +132,0 @@\n-     *\n-     * This method should only be called while holding the lock.\n@@ -160,16 +151,1 @@\n-    public void write(int b) throws IOException {\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                implWrite(b);\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                implWrite(b);\n-            }\n-        }\n-    }\n-\n-    private void implWrite(int b) throws IOException {\n+    public synchronized void write(int b) throws IOException {\n@@ -201,16 +177,1 @@\n-    public void write(byte[] b, int off, int len) throws IOException {\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                implWrite(b, off, len);\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                implWrite(b, off, len);\n-            }\n-        }\n-    }\n-\n-    private void implWrite(byte[] b, int off, int len) throws IOException {\n+    public synchronized void write(byte[] b, int off, int len) throws IOException {\n@@ -241,16 +202,1 @@\n-    public void flush() throws IOException {\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                implFlush();\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                implFlush();\n-            }\n-        }\n-    }\n-\n-    private void implFlush() throws IOException {\n+    public synchronized void flush() throws IOException {\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedOutputStream.java","additions":5,"deletions":59,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -184,28 +183,7 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return implRead();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                return implRead();\n-            }\n-        }\n-    }\n-\n-    private int implRead() throws IOException {\n-        ensureOpen();\n-        for (;;) {\n-            if (nextChar >= nChars) {\n-                fill();\n-                if (nextChar >= nChars)\n-                    return -1;\n-            }\n-            if (skipLF) {\n-                skipLF = false;\n-                if (cb[nextChar] == '\\n') {\n-                    nextChar++;\n-                    continue;\n+        synchronized (lock) {\n+            ensureOpen();\n+            for (;;) {\n+                if (nextChar >= nChars) {\n+                    fill();\n+                    if (nextChar >= nChars)\n+                        return -1;\n@@ -213,0 +191,8 @@\n+                if (skipLF) {\n+                    skipLF = false;\n+                    if (cb[nextChar] == '\\n') {\n+                        nextChar++;\n+                        continue;\n+                    }\n+                }\n+                return cb[nextChar++];\n@@ -214,1 +200,0 @@\n-            return cb[nextChar++];\n@@ -299,11 +284,5 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return implRead(cbuf, off, len);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                return implRead(cbuf, off, len);\n+        synchronized (lock) {\n+            ensureOpen();\n+            Objects.checkFromIndexSize(off, len, cbuf.length);\n+            if (len == 0) {\n+                return 0;\n@@ -311,9 +290,0 @@\n-        }\n-    }\n-\n-    private int implRead(char[] cbuf, int off, int len) throws IOException {\n-        ensureOpen();\n-        Objects.checkFromIndexSize(off, len, cbuf.length);\n-        if (len == 0) {\n-            return 0;\n-        }\n@@ -321,6 +291,8 @@\n-        int n = read1(cbuf, off, len);\n-        if (n <= 0) return n;\n-        while ((n < len) && in.ready()) {\n-            int n1 = read1(cbuf, off + n, len - n);\n-            if (n1 <= 0) break;\n-            n += n1;\n+            int n = read1(cbuf, off, len);\n+            if (n <= 0) return n;\n+            while ((n < len) && in.ready()) {\n+                int n1 = read1(cbuf, off + n, len - n);\n+                if (n1 <= 0) break;\n+                n += n1;\n+            }\n+            return n;\n@@ -328,1 +300,0 @@\n-        return n;\n@@ -350,14 +321,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return implReadLine(ignoreLF, term);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                return implReadLine(ignoreLF, term);\n-            }\n-        }\n-    }\n+        synchronized (lock) {\n+            StringBuilder s = null;\n+            int startChar;\n@@ -365,3 +325,3 @@\n-    private String implReadLine(boolean ignoreLF, boolean[] term) throws IOException {\n-        StringBuilder s = null;\n-        int startChar;\n+            ensureOpen();\n+            boolean omitLF = ignoreLF || skipLF;\n+            if (term != null) term[0] = false;\n@@ -369,3 +329,2 @@\n-        ensureOpen();\n-        boolean omitLF = ignoreLF || skipLF;\n-        if (term != null) term[0] = false;\n+            bufferLoop:\n+            for (;;) {\n@@ -373,28 +332,7 @@\n-      bufferLoop:\n-        for (;;) {\n-\n-            if (nextChar >= nChars)\n-                fill();\n-            if (nextChar >= nChars) { \/* EOF *\/\n-                if (s != null && s.length() > 0)\n-                    return s.toString();\n-                else\n-                    return null;\n-            }\n-            boolean eol = false;\n-            char c = 0;\n-            int i;\n-\n-            \/* Skip a leftover '\\n', if necessary *\/\n-            if (omitLF && (cb[nextChar] == '\\n'))\n-                nextChar++;\n-            skipLF = false;\n-            omitLF = false;\n-\n-          charLoop:\n-            for (i = nextChar; i < nChars; i++) {\n-                c = cb[i];\n-                if ((c == '\\n') || (c == '\\r')) {\n-                    if (term != null) term[0] = true;\n-                    eol = true;\n-                    break charLoop;\n+                if (nextChar >= nChars)\n+                    fill();\n+                if (nextChar >= nChars) { \/* EOF *\/\n+                    if (s != null && s.length() > 0)\n+                        return s.toString();\n+                    else\n+                        return null;\n@@ -402,1 +340,3 @@\n-            }\n+                boolean eol = false;\n+                char c = 0;\n+                int i;\n@@ -404,10 +344,14 @@\n-            startChar = nextChar;\n-            nextChar = i;\n-\n-            if (eol) {\n-                String str;\n-                if (s == null) {\n-                    str = new String(cb, startChar, i - startChar);\n-                } else {\n-                    s.append(cb, startChar, i - startChar);\n-                    str = s.toString();\n+                \/* Skip a leftover '\\n', if necessary *\/\n+                if (omitLF && (cb[nextChar] == '\\n'))\n+                    nextChar++;\n+                skipLF = false;\n+                omitLF = false;\n+\n+                charLoop:\n+                for (i = nextChar; i < nChars; i++) {\n+                    c = cb[i];\n+                    if ((c == '\\n') || (c == '\\r')) {\n+                        if (term != null) term[0] = true;\n+                        eol = true;\n+                        break charLoop;\n+                    }\n@@ -415,3 +359,17 @@\n-                nextChar++;\n-                if (c == '\\r') {\n-                    skipLF = true;\n+\n+                startChar = nextChar;\n+                nextChar = i;\n+\n+                if (eol) {\n+                    String str;\n+                    if (s == null) {\n+                        str = new String(cb, startChar, i - startChar);\n+                    } else {\n+                        s.append(cb, startChar, i - startChar);\n+                        str = s.toString();\n+                    }\n+                    nextChar++;\n+                    if (c == '\\r') {\n+                        skipLF = true;\n+                    }\n+                    return str;\n@@ -419,2 +377,0 @@\n-                return str;\n-            }\n@@ -422,3 +378,4 @@\n-            if (s == null)\n-                s = new StringBuilder(DEFAULT_EXPECTED_LINE_LENGTH);\n-            s.append(cb, startChar, i - startChar);\n+                if (s == null)\n+                    s = new StringBuilder(DEFAULT_EXPECTED_LINE_LENGTH);\n+                s.append(cb, startChar, i - startChar);\n+            }\n@@ -453,27 +410,23 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return implSkip(n);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                return implSkip(n);\n-            }\n-        }\n-    }\n-\n-    private long implSkip(long n) throws IOException {\n-        ensureOpen();\n-        long r = n;\n-        while (r > 0) {\n-            if (nextChar >= nChars)\n-                fill();\n-            if (nextChar >= nChars) \/* EOF *\/\n-                break;\n-            if (skipLF) {\n-                skipLF = false;\n-                if (cb[nextChar] == '\\n') {\n-                    nextChar++;\n+        synchronized (lock) {\n+            ensureOpen();\n+            long r = n;\n+            while (r > 0) {\n+                if (nextChar >= nChars)\n+                    fill();\n+                if (nextChar >= nChars) \/* EOF *\/\n+                    break;\n+                if (skipLF) {\n+                    skipLF = false;\n+                    if (cb[nextChar] == '\\n') {\n+                        nextChar++;\n+                    }\n+                }\n+                long d = nChars - nextChar;\n+                if (r <= d) {\n+                    nextChar += (int)r;\n+                    r = 0;\n+                    break;\n+                }\n+                else {\n+                    r -= d;\n+                    nextChar = nChars;\n@@ -482,10 +435,1 @@\n-            long d = nChars - nextChar;\n-            if (r <= d) {\n-                nextChar += (int)r;\n-                r = 0;\n-                break;\n-            }\n-            else {\n-                r -= d;\n-                nextChar = nChars;\n-            }\n+            return n - r;\n@@ -493,1 +437,0 @@\n-        return n - r;\n@@ -504,17 +447,2 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return implReady();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                return implReady();\n-            }\n-        }\n-    }\n-\n-    private boolean implReady() throws IOException {\n-        ensureOpen();\n+        synchronized (lock) {\n+            ensureOpen();\n@@ -522,7 +450,3 @@\n-        \/*\n-         * If newline needs to be skipped and the next char to be read\n-         * is a newline character, then just skip it right away.\n-         *\/\n-        if (skipLF) {\n-            \/* Note that in.ready() will return true if and only if the next\n-             * read on the stream will not block.\n+            \/*\n+             * If newline needs to be skipped and the next char to be read\n+             * is a newline character, then just skip it right away.\n@@ -530,7 +454,12 @@\n-            if (nextChar >= nChars && in.ready()) {\n-                fill();\n-            }\n-            if (nextChar < nChars) {\n-                if (cb[nextChar] == '\\n')\n-                    nextChar++;\n-                skipLF = false;\n+            if (skipLF) {\n+                \/* Note that in.ready() will return true if and only if the next\n+                 * read on the stream will not block.\n+                 *\/\n+                if (nextChar >= nChars && in.ready()) {\n+                    fill();\n+                }\n+                if (nextChar < nChars) {\n+                    if (cb[nextChar] == '\\n')\n+                        nextChar++;\n+                    skipLF = false;\n+                }\n@@ -538,0 +467,1 @@\n+            return (nextChar < nChars) || in.ready();\n@@ -539,1 +469,0 @@\n-        return (nextChar < nChars) || in.ready();\n@@ -569,12 +498,5 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                implMark(readAheadLimit);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implMark(readAheadLimit);\n-            }\n+        synchronized (lock) {\n+            ensureOpen();\n+            this.readAheadLimit = readAheadLimit;\n+            markedChar = nextChar;\n+            markedSkipLF = skipLF;\n@@ -584,7 +506,0 @@\n-    private void implMark(int readAheadLimit) throws IOException {\n-        ensureOpen();\n-        this.readAheadLimit = readAheadLimit;\n-        markedChar = nextChar;\n-        markedSkipLF = skipLF;\n-    }\n-\n@@ -598,12 +513,8 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                implReset();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implReset();\n-            }\n+        synchronized (lock) {\n+            ensureOpen();\n+            if (markedChar < 0)\n+                throw new IOException((markedChar == INVALIDATED)\n+                                      ? \"Mark invalid\"\n+                                      : \"Stream not marked\");\n+            nextChar = markedChar;\n+            skipLF = markedSkipLF;\n@@ -613,10 +524,0 @@\n-    private void implReset() throws IOException {\n-        ensureOpen();\n-        if (markedChar < 0)\n-            throw new IOException((markedChar == INVALIDATED)\n-                                  ? \"Mark invalid\"\n-                                  : \"Stream not marked\");\n-        nextChar = markedChar;\n-        skipLF = markedSkipLF;\n-    }\n-\n@@ -624,3 +525,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n+            if (in == null)\n+                return;\n@@ -628,1 +529,1 @@\n-                implClose();\n+                in.close();\n@@ -630,1 +531,2 @@\n-                locker.unlock();\n+                in = null;\n+                cb = null;\n@@ -632,15 +534,0 @@\n-        } else {\n-            synchronized (lock) {\n-                implClose();\n-            }\n-        }\n-    }\n-\n-    private void implClose() throws IOException {\n-        if (in == null)\n-            return;\n-        try {\n-            in.close();\n-        } finally {\n-            in = null;\n-            cb = null;\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedReader.java","additions":142,"deletions":255,"binary":false,"changes":397,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -165,12 +164,6 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                implFlushBuffer();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implFlushBuffer();\n-            }\n+        synchronized (lock) {\n+            ensureOpen();\n+            if (nextChar == 0)\n+                return;\n+            out.write(cb, 0, nextChar);\n+            nextChar = 0;\n@@ -180,8 +173,0 @@\n-    private void implFlushBuffer() throws IOException {\n-        ensureOpen();\n-        if (nextChar == 0)\n-            return;\n-        out.write(cb, 0, nextChar);\n-        nextChar = 0;\n-    }\n-\n@@ -194,12 +179,6 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                implWrite(c);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implWrite(c);\n-            }\n+        synchronized (lock) {\n+            ensureOpen();\n+            growIfNeeded(1);\n+            if (nextChar >= nChars)\n+                flushBuffer();\n+            cb[nextChar++] = (char) c;\n@@ -209,8 +188,0 @@\n-    private void implWrite(int c) throws IOException {\n-        ensureOpen();\n-        growIfNeeded(1);\n-        if (nextChar >= nChars)\n-            flushBuffer();\n-        cb[nextChar++] = (char) c;\n-    }\n-\n@@ -248,11 +219,5 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                implWrite(cbuf, off, len);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implWrite(cbuf, off, len);\n+        synchronized (lock) {\n+            ensureOpen();\n+            Objects.checkFromIndexSize(off, len, cbuf.length);\n+            if (len == 0) {\n+                return;\n@@ -260,2 +225,0 @@\n-        }\n-    }\n@@ -263,24 +226,4 @@\n-    private void implWrite(char[] cbuf, int off, int len) throws IOException {\n-        ensureOpen();\n-        Objects.checkFromIndexSize(off, len, cbuf.length);\n-        if (len == 0) {\n-            return;\n-        }\n-\n-        if (len >= maxChars) {\n-            \/* If the request length exceeds the max size of the output buffer,\n-               flush the buffer and then write the data directly.  In this\n-               way buffered streams will cascade harmlessly. *\/\n-            flushBuffer();\n-            out.write(cbuf, off, len);\n-            return;\n-        }\n-\n-        growIfNeeded(len);\n-        int b = off, t = off + len;\n-        while (b < t) {\n-            int d = min(nChars - nextChar, t - b);\n-            System.arraycopy(cbuf, b, cb, nextChar, d);\n-            b += d;\n-            nextChar += d;\n-            if (nextChar >= nChars) {\n+            if (len >= maxChars) {\n+                \/* If the request length exceeds the max size of the output buffer,\n+                   flush the buffer and then write the data directly.  In this\n+                   way buffered streams will cascade harmlessly. *\/\n@@ -288,0 +231,14 @@\n+                out.write(cbuf, off, len);\n+                return;\n+            }\n+\n+            growIfNeeded(len);\n+            int b = off, t = off + len;\n+            while (b < t) {\n+                int d = min(nChars - nextChar, t - b);\n+                System.arraycopy(cbuf, b, cb, nextChar, d);\n+                b += d;\n+                nextChar += d;\n+                if (nextChar >= nChars) {\n+                    flushBuffer();\n+                }\n@@ -315,11 +272,11 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                implWrite(s, off, len);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implWrite(s, off, len);\n+        synchronized (lock) {\n+            ensureOpen();\n+            growIfNeeded(len);\n+            int b = off, t = off + len;\n+            while (b < t) {\n+                int d = min(nChars - nextChar, t - b);\n+                s.getChars(b, b + d, cb, nextChar);\n+                b += d;\n+                nextChar += d;\n+                if (nextChar >= nChars)\n+                    flushBuffer();\n@@ -330,14 +287,0 @@\n-    private void implWrite(String s, int off, int len) throws IOException {\n-        ensureOpen();\n-        growIfNeeded(len);\n-        int b = off, t = off + len;\n-        while (b < t) {\n-            int d = min(nChars - nextChar, t - b);\n-            s.getChars(b, b + d, cb, nextChar);\n-            b += d;\n-            nextChar += d;\n-            if (nextChar >= nChars)\n-                flushBuffer();\n-        }\n-    }\n-\n@@ -361,12 +304,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                implFlush();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implFlush();\n-            }\n+        synchronized (lock) {\n+            flushBuffer();\n+            out.flush();\n@@ -376,5 +310,1 @@\n-    private void implFlush() throws IOException {\n-        flushBuffer();\n-        out.flush();\n-    }\n-\n+    @SuppressWarnings(\"try\")\n@@ -382,7 +312,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                implClose();\n-            } finally {\n-                locker.unlock();\n+        synchronized (lock) {\n+            if (out == null) {\n+                return;\n@@ -390,3 +316,5 @@\n-        } else {\n-            synchronized (lock) {\n-                implClose();\n+            try (Writer w = out) {\n+                flushBuffer();\n+            } finally {\n+                out = null;\n+                cb = null;\n@@ -396,13 +324,0 @@\n-\n-    @SuppressWarnings(\"try\")\n-    private void implClose() throws IOException {\n-        if (out == null) {\n-            return;\n-        }\n-        try (Writer w = out) {\n-            flushBuffer();\n-        } finally {\n-            out = null;\n-            cb = null;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedWriter.java","additions":58,"deletions":143,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -65,14 +64,0 @@\n-    \/**\n-     * Return the lock object for the given reader's stream decoder.\n-     * If the reader type is trusted then an internal lock can be used. If the\n-     * reader type is not trusted then the reader object is the lock.\n-     *\/\n-    private static Object lockFor(InputStreamReader reader) {\n-        Class<?> clazz = reader.getClass();\n-        if (clazz == InputStreamReader.class || clazz == FileReader.class) {\n-            return InternalLock.newLockOr(reader);\n-        } else {\n-            return reader;\n-        }\n-    }\n-\n@@ -91,1 +76,1 @@\n-        sd = StreamDecoder.forInputStreamReader(in, lockFor(this), cs);\n+        sd = StreamDecoder.forInputStreamReader(in, this, cs);\n@@ -113,1 +98,1 @@\n-        sd = StreamDecoder.forInputStreamReader(in, lockFor(this), charsetName);\n+        sd = StreamDecoder.forInputStreamReader(in, this, charsetName);\n@@ -129,1 +114,1 @@\n-        sd = StreamDecoder.forInputStreamReader(in, lockFor(this), cs);\n+        sd = StreamDecoder.forInputStreamReader(in, this, cs);\n@@ -145,1 +130,1 @@\n-        sd = StreamDecoder.forInputStreamReader(in, lockFor(this), dec);\n+        sd = StreamDecoder.forInputStreamReader(in, this, dec);\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStreamReader.java","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -78,14 +77,0 @@\n-    \/**\n-     * Return the lock object for the given writer's stream encoder.\n-     * If the writer type is trusted then an internal lock can be used. If the\n-     * writer type is not trusted then the writer object is the lock.\n-     *\/\n-    private static Object lockFor(OutputStreamWriter writer) {\n-        Class<?> clazz = writer.getClass();\n-        if (clazz == OutputStreamWriter.class || clazz == FileWriter.class) {\n-            return InternalLock.newLockOr(writer);\n-        } else {\n-            return writer;\n-        }\n-    }\n-\n@@ -111,1 +96,1 @@\n-        se = StreamEncoder.forOutputStreamWriter(out, lockFor(this), charsetName);\n+        se = StreamEncoder.forOutputStreamWriter(out, this, charsetName);\n@@ -125,1 +110,1 @@\n-        se = StreamEncoder.forOutputStreamWriter(out, lockFor(this),\n+        se = StreamEncoder.forOutputStreamWriter(out, this,\n@@ -145,1 +130,1 @@\n-        se = StreamEncoder.forOutputStreamWriter(out, lockFor(this), cs);\n+        se = StreamEncoder.forOutputStreamWriter(out, this, cs);\n@@ -164,1 +149,1 @@\n-        se = StreamEncoder.forOutputStreamWriter(out, lockFor(this), enc);\n+        se = StreamEncoder.forOutputStreamWriter(out, this, enc);\n","filename":"src\/java.base\/share\/classes\/java\/io\/OutputStreamWriter.java","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-import jdk.internal.access.JavaIOPrintStreamAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.misc.InternalLock;\n@@ -70,3 +67,0 @@\n-    \/\/ initialized to null when PrintStream is sub-classed\n-    private final InternalLock lock;\n-\n@@ -120,7 +114,0 @@\n-\n-        \/\/ use monitors when PrintStream is sub-classed\n-        if (getClass() == PrintStream.class) {\n-            lock = InternalLock.newLockOrNull();\n-        } else {\n-            lock = null;\n-        }\n@@ -223,7 +210,0 @@\n-\n-        \/\/ use monitors when PrintStream is sub-classed\n-        if (getClass() == PrintStream.class) {\n-            lock = InternalLock.newLockOrNull();\n-        } else {\n-            lock = null;\n-        }\n@@ -451,2 +431,1 @@\n-        if (lock != null) {\n-            lock.lock();\n+        synchronized (this) {\n@@ -454,3 +433,2 @@\n-                implFlush();\n-            } finally {\n-                lock.unlock();\n+                ensureOpen();\n+                out.flush();\n@@ -458,3 +436,2 @@\n-        } else {\n-            synchronized (this) {\n-                implFlush();\n+            catch (IOException x) {\n+                trouble = true;\n@@ -465,10 +442,0 @@\n-    private void implFlush() {\n-        try {\n-            ensureOpen();\n-            out.flush();\n-        }\n-        catch (IOException x) {\n-            trouble = true;\n-        }\n-    }\n-\n@@ -485,23 +452,13 @@\n-        if (lock != null) {\n-            lock.lock();\n-            try {\n-                implClose();\n-            } finally {\n-                lock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                implClose();\n-            }\n-        }\n-    }\n-\n-    private void implClose() {\n-        if (!closing) {\n-            closing = true;\n-            try {\n-                textOut.close();\n-                out.close();\n-            }\n-            catch (IOException x) {\n-                trouble = true;\n+        synchronized (this) {\n+            if (!closing) {\n+                closing = true;\n+                try {\n+                    textOut.close();\n+                    out.close();\n+                }\n+                catch (IOException x) {\n+                    trouble = true;\n+                }\n+                textOut = null;\n+                charOut = null;\n+                out = null;\n@@ -509,3 +466,0 @@\n-            textOut = null;\n-            charOut = null;\n-            out = null;\n@@ -578,11 +532,5 @@\n-            if (lock != null) {\n-                lock.lock();\n-                try {\n-                    implWrite(b);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                synchronized (this) {\n-                    implWrite(b);\n-                }\n+            synchronized (this) {\n+                ensureOpen();\n+                out.write(b);\n+                if ((b == '\\n') && autoFlush)\n+                    out.flush();\n@@ -599,7 +547,0 @@\n-    private void implWrite(int b) throws IOException {\n-        ensureOpen();\n-        out.write(b);\n-        if ((b == '\\n') && autoFlush)\n-            out.flush();\n-    }\n-\n@@ -624,11 +565,5 @@\n-            if (lock != null) {\n-                lock.lock();\n-                try {\n-                    implWrite(buf, off, len);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                synchronized (this) {\n-                    implWrite(buf, off, len);\n-                }\n+            synchronized (this) {\n+                ensureOpen();\n+                out.write(buf, off, len);\n+                if (autoFlush)\n+                    out.flush();\n@@ -645,8 +580,0 @@\n-    private void implWrite(byte[] buf, int off, int len) throws IOException {\n-        ensureOpen();\n-        out.write(buf, off, len);\n-        if (autoFlush)\n-            out.flush();\n-    }\n-\n-\n@@ -717,10 +644,11 @@\n-            if (lock != null) {\n-                lock.lock();\n-                try {\n-                    implWrite(buf);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                synchronized (this) {\n-                    implWrite(buf);\n+            synchronized (this) {\n+                ensureOpen();\n+                textOut.write(buf);\n+                textOut.flushBuffer();\n+                charOut.flushBuffer();\n+                if (autoFlush) {\n+                    for (int i = 0; i < buf.length; i++)\n+                        if (buf[i] == '\\n') {\n+                            out.flush();\n+                            break;\n+                        }\n@@ -736,14 +664,0 @@\n-    private void implWrite(char[] buf) throws IOException {\n-        ensureOpen();\n-        textOut.write(buf);\n-        textOut.flushBuffer();\n-        charOut.flushBuffer();\n-        if (autoFlush) {\n-            for (int i = 0; i < buf.length; i++)\n-                if (buf[i] == '\\n') {\n-                    out.flush();\n-                    break;\n-                }\n-        }\n-    }\n-\n@@ -756,11 +670,8 @@\n-            if (lock != null) {\n-                lock.lock();\n-                try {\n-                    implWriteln(buf);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                synchronized (this) {\n-                    implWriteln(buf);\n-                }\n+            synchronized (this) {\n+                ensureOpen();\n+                textOut.write(buf);\n+                textOut.newLine();\n+                textOut.flushBuffer();\n+                charOut.flushBuffer();\n+                if (autoFlush)\n+                    out.flush();\n@@ -777,10 +688,0 @@\n-    private void implWriteln(char[] buf) throws IOException {\n-        ensureOpen();\n-        textOut.write(buf);\n-        textOut.newLine();\n-        textOut.flushBuffer();\n-        charOut.flushBuffer();\n-        if (autoFlush)\n-            out.flush();\n-    }\n-\n@@ -789,11 +690,7 @@\n-            if (lock != null) {\n-                lock.lock();\n-                try {\n-                    implWrite(s);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                synchronized (this) {\n-                    implWrite(s);\n-                }\n+            synchronized (this) {\n+                ensureOpen();\n+                textOut.write(s);\n+                textOut.flushBuffer();\n+                charOut.flushBuffer();\n+                if (autoFlush && (s.indexOf('\\n') >= 0))\n+                    out.flush();\n@@ -810,9 +707,0 @@\n-    private void implWrite(String s) throws IOException {\n-        ensureOpen();\n-        textOut.write(s);\n-        textOut.flushBuffer();\n-        charOut.flushBuffer();\n-        if (autoFlush && (s.indexOf('\\n') >= 0))\n-            out.flush();\n-    }\n-\n@@ -825,11 +713,8 @@\n-            if (lock != null) {\n-                lock.lock();\n-                try {\n-                    implWriteln(s);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                synchronized (this) {\n-                    implWriteln(s);\n-                }\n+            synchronized (this) {\n+                ensureOpen();\n+                textOut.write(s);\n+                textOut.newLine();\n+                textOut.flushBuffer();\n+                charOut.flushBuffer();\n+                if (autoFlush)\n+                    out.flush();\n@@ -846,10 +731,0 @@\n-    private void implWriteln(String s) throws IOException {\n-        ensureOpen();\n-        textOut.write(s);\n-        textOut.newLine();\n-        textOut.flushBuffer();\n-        charOut.flushBuffer();\n-        if (autoFlush)\n-            out.flush();\n-    }\n-\n@@ -858,11 +733,7 @@\n-            if (lock != null) {\n-                lock.lock();\n-                try {\n-                    implNewLine();\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                synchronized (this) {\n-                    implNewLine();\n-                }\n+            synchronized (this) {\n+                ensureOpen();\n+                textOut.newLine();\n+                textOut.flushBuffer();\n+                charOut.flushBuffer();\n+                if (autoFlush)\n+                    out.flush();\n@@ -879,9 +750,0 @@\n-    private void implNewLine() throws IOException {\n-        ensureOpen();\n-        textOut.newLine();\n-        textOut.flushBuffer();\n-        charOut.flushBuffer();\n-        if (autoFlush)\n-            out.flush();\n-    }\n-\n@@ -1345,11 +1207,5 @@\n-            if (lock != null) {\n-                lock.lock();\n-                try {\n-                    implFormat(format, args);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                synchronized (this) {\n-                    implFormat(format, args);\n-                }\n+            synchronized (this) {\n+                ensureOpen();\n+                if ((formatter == null) || (formatter.locale() != Locale.getDefault(Locale.Category.FORMAT)))\n+                    formatter = new Formatter((Appendable) this);\n+                formatter.format(Locale.getDefault(Locale.Category.FORMAT), format, args);\n@@ -1365,7 +1221,0 @@\n-    private void implFormat(String format, Object ... args) throws IOException {\n-        ensureOpen();\n-        if ((formatter == null) || (formatter.locale() != Locale.getDefault(Locale.Category.FORMAT)))\n-            formatter = new Formatter((Appendable) this);\n-        formatter.format(Locale.getDefault(Locale.Category.FORMAT), format, args);\n-    }\n-\n@@ -1414,11 +1263,5 @@\n-            if (lock != null) {\n-                lock.lock();\n-                try {\n-                    implFormat(l, format, args);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                synchronized (this) {\n-                    implFormat(l, format, args);\n-                }\n+            synchronized (this) {\n+                ensureOpen();\n+                if ((formatter == null) || (formatter.locale() != l))\n+                    formatter = new Formatter(this, l);\n+                formatter.format(l, format, args);\n@@ -1434,7 +1277,0 @@\n-    private void implFormat(Locale l, String format, Object ... args) throws IOException {\n-        ensureOpen();\n-        if ((formatter == null) || (formatter.locale() != l))\n-            formatter = new Formatter(this, l);\n-        formatter.format(l, format, args);\n-    }\n-\n@@ -1542,9 +1378,0 @@\n-\n-    static {\n-        SharedSecrets.setJavaIOCPrintStreamAccess(new JavaIOPrintStreamAccess() {\n-            public Object lock(PrintStream ps) {\n-                Object lock = ps.lock;\n-                return (lock != null) ? lock : ps;\n-            }\n-        });\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintStream.java","additions":79,"deletions":252,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-import jdk.internal.access.JavaIOPrintWriterAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.misc.InternalLock;\n@@ -408,3 +405,1 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n@@ -412,7 +407,4 @@\n-                implFlush();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implFlush();\n+                ensureOpen();\n+                out.flush();\n+            } catch (IOException x) {\n+                trouble = true;\n@@ -423,9 +415,0 @@\n-    private void implFlush() {\n-        try {\n-            ensureOpen();\n-            out.flush();\n-        } catch (IOException x) {\n-            trouble = true;\n-        }\n-    }\n-\n@@ -439,3 +422,1 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n@@ -443,7 +424,6 @@\n-                implClose();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implClose();\n+                if (out != null) {\n+                    out.close();\n+                    out = null;\n+                }\n+            } catch (IOException x) {\n+                trouble = true;\n@@ -454,11 +434,0 @@\n-    private void implClose() {\n-        try {\n-            if (out != null) {\n-                out.close();\n-                out = null;\n-            }\n-        } catch (IOException x) {\n-            trouble = true;\n-        }\n-    }\n-\n@@ -518,3 +487,1 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n@@ -522,7 +489,6 @@\n-                implWrite(c);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implWrite(c);\n+                ensureOpen();\n+                out.write(c);\n+            } catch (InterruptedIOException x) {\n+                Thread.currentThread().interrupt();\n+            } catch (IOException x) {\n+                trouble = true;\n@@ -533,11 +499,0 @@\n-    private void implWrite(int c) {\n-        try {\n-            ensureOpen();\n-            out.write(c);\n-        } catch (InterruptedIOException x) {\n-            Thread.currentThread().interrupt();\n-        } catch (IOException x) {\n-            trouble = true;\n-        }\n-    }\n-\n@@ -556,3 +511,1 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n@@ -560,3 +513,6 @@\n-                implWrite(buf, off, len);\n-            } finally {\n-                locker.unlock();\n+                ensureOpen();\n+                out.write(buf, off, len);\n+            } catch (InterruptedIOException x) {\n+                Thread.currentThread().interrupt();\n+            } catch (IOException x) {\n+                trouble = true;\n@@ -564,15 +520,0 @@\n-        } else {\n-            synchronized (lock) {\n-                implWrite(buf, off, len);\n-            }\n-        }\n-    }\n-\n-    private void implWrite(char[] buf, int off, int len) {\n-        try {\n-            ensureOpen();\n-            out.write(buf, off, len);\n-        } catch (InterruptedIOException x) {\n-            Thread.currentThread().interrupt();\n-        } catch (IOException x) {\n-            trouble = true;\n@@ -603,3 +544,1 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n@@ -607,3 +546,6 @@\n-                implWrite(s, off, len);\n-            } finally {\n-                locker.unlock();\n+                ensureOpen();\n+                out.write(s, off, len);\n+            } catch (InterruptedIOException x) {\n+                Thread.currentThread().interrupt();\n+            } catch (IOException x) {\n+                trouble = true;\n@@ -611,15 +553,0 @@\n-        } else {\n-            synchronized (lock) {\n-                implWrite(s, off, len);\n-            }\n-        }\n-    }\n-\n-    private void implWrite(String s, int off, int len) {\n-        try {\n-            ensureOpen();\n-            out.write(s, off, len);\n-        } catch (InterruptedIOException x) {\n-            Thread.currentThread().interrupt();\n-        } catch (IOException x) {\n-            trouble = true;\n@@ -639,3 +566,1 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n@@ -643,7 +568,8 @@\n-                implNewLine();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implNewLine();\n+                ensureOpen();\n+                out.write(System.lineSeparator());\n+                if (autoFlush)\n+                    out.flush();\n+            } catch (InterruptedIOException x) {\n+                Thread.currentThread().interrupt();\n+            } catch (IOException x) {\n+                trouble = true;\n@@ -654,13 +580,0 @@\n-    private void implNewLine() {\n-        try {\n-            ensureOpen();\n-            out.write(System.lineSeparator());\n-            if (autoFlush)\n-                out.flush();\n-        } catch (InterruptedIOException x) {\n-            Thread.currentThread().interrupt();\n-        } catch (IOException x) {\n-            trouble = true;\n-        }\n-    }\n-\n@@ -819,14 +732,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                print(x);\n-                println();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                print(x);\n-                println();\n-            }\n+        synchronized (lock) {\n+            print(x);\n+            println();\n@@ -844,14 +746,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                print(x);\n-                println();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                print(x);\n-                println();\n-            }\n+        synchronized (lock) {\n+            print(x);\n+            println();\n@@ -869,14 +760,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                print(x);\n-                println();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                print(x);\n-                println();\n-            }\n+        synchronized (lock) {\n+            print(x);\n+            println();\n@@ -894,14 +774,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                print(x);\n-                println();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                print(x);\n-                println();\n-            }\n+        synchronized (lock) {\n+            print(x);\n+            println();\n@@ -919,14 +788,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                print(x);\n-                println();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                print(x);\n-                println();\n-            }\n+        synchronized (lock) {\n+            print(x);\n+            println();\n@@ -944,14 +802,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                print(x);\n-                println();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                print(x);\n-                println();\n-            }\n+        synchronized (lock) {\n+            print(x);\n+            println();\n@@ -969,14 +816,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                print(x);\n-                println();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                print(x);\n-                println();\n-            }\n+        synchronized (lock) {\n+            print(x);\n+            println();\n@@ -994,14 +830,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                print(x);\n-                println();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                print(x);\n-                println();\n-            }\n+        synchronized (lock) {\n+            print(x);\n+            println();\n@@ -1022,14 +847,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                print(s);\n-                println();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                print(s);\n-                println();\n-            }\n+        synchronized (lock) {\n+            print(s);\n+            println();\n@@ -1181,3 +995,1 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n@@ -1185,7 +997,11 @@\n-                implFormat(format, args);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implFormat(format, args);\n+                ensureOpen();\n+                if ((formatter == null)\n+                    || (formatter.locale() != Locale.getDefault()))\n+                    formatter = new Formatter(this);\n+                formatter.format(Locale.getDefault(), format, args);\n+                if (autoFlush)\n+                    out.flush();\n+            } catch (InterruptedIOException x) {\n+                Thread.currentThread().interrupt();\n+            } catch (IOException x) {\n+                trouble = true;\n@@ -1197,16 +1013,0 @@\n-    private void implFormat(String format, Object ... args) {\n-        try {\n-            ensureOpen();\n-            if ((formatter == null)\n-                || (formatter.locale() != Locale.getDefault()))\n-                formatter = new Formatter(this);\n-            formatter.format(Locale.getDefault(), format, args);\n-            if (autoFlush)\n-                out.flush();\n-        } catch (InterruptedIOException x) {\n-            Thread.currentThread().interrupt();\n-        } catch (IOException x) {\n-            trouble = true;\n-        }\n-    }\n-\n@@ -1255,3 +1055,1 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n@@ -1259,7 +1057,10 @@\n-                implFormat(l, format, args);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implFormat(l, format, args);\n+                ensureOpen();\n+                if ((formatter == null) || (formatter.locale() != l))\n+                    formatter = new Formatter(this, l);\n+                formatter.format(l, format, args);\n+                if (autoFlush)\n+                    out.flush();\n+            } catch (InterruptedIOException x) {\n+                Thread.currentThread().interrupt();\n+            } catch (IOException x) {\n+                trouble = true;\n@@ -1271,15 +1072,0 @@\n-    private void implFormat(Locale l, String format, Object ... args) {\n-        try {\n-            ensureOpen();\n-            if ((formatter == null) || (formatter.locale() != l))\n-                formatter = new Formatter(this, l);\n-            formatter.format(l, format, args);\n-            if (autoFlush)\n-                out.flush();\n-        } catch (InterruptedIOException x) {\n-            Thread.currentThread().interrupt();\n-        } catch (IOException x) {\n-            trouble = true;\n-        }\n-    }\n-\n@@ -1377,8 +1163,0 @@\n-\n-    static {\n-        SharedSecrets.setJavaIOCPrintWriterAccess(new JavaIOPrintWriterAccess() {\n-            public Object lock(PrintWriter pw) {\n-                return pw.lock;\n-            }\n-        });\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintWriter.java","additions":92,"deletions":314,"binary":false,"changes":406,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -57,4 +56,0 @@\n-\n-    \/\/ initialized to null when PushbackInputStream is sub-classed\n-    private final InternalLock closeLock;\n-\n@@ -104,7 +99,0 @@\n-\n-        \/\/ use monitors when PushbackInputStream is sub-classed\n-        if (getClass() == PushbackInputStream.class) {\n-            closeLock = InternalLock.newLockOrNull();\n-        } else {\n-            closeLock = null;\n-        }\n@@ -389,21 +377,6 @@\n-    public void close() throws IOException {\n-        if (closeLock != null) {\n-            closeLock.lock();\n-            try {\n-                implClose();\n-            } finally {\n-                closeLock.unlock();\n-            }\n-        } else {\n-            synchronized (this) {\n-                implClose();\n-            }\n-        }\n-    }\n-\n-    private void implClose() throws IOException {\n-        if (in != null) {\n-            in.close();\n-            in = null;\n-            buf = null;\n-        }\n+    public synchronized void close() throws IOException {\n+        if (in == null)\n+            return;\n+        in.close();\n+        in = null;\n+        buf = null;\n","filename":"src\/java.base\/share\/classes\/java\/io\/PushbackInputStream.java","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -286,15 +285,0 @@\n-    \/**\n-     * For use by BufferedReader to create a character-stream reader that uses an\n-     * internal lock when BufferedReader is not extended and the given reader is\n-     * trusted, otherwise critical sections will synchronize on the given reader.\n-     *\/\n-    Reader(Reader in) {\n-        Class<?> clazz = in.getClass();\n-        if (getClass() == BufferedReader.class &&\n-                (clazz == InputStreamReader.class || clazz == FileReader.class)) {\n-            this.lock = InternalLock.newLockOr(in);\n-        } else {\n-            this.lock = in;\n-        }\n-    }\n-\n@@ -432,7 +416,10 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return implSkip(n);\n-            } finally {\n-                locker.unlock();\n+        synchronized (lock) {\n+            int nn = (int) Math.min(n, maxSkipBufferSize);\n+            if ((skipBuffer == null) || (skipBuffer.length < nn))\n+                skipBuffer = new char[nn];\n+            long r = n;\n+            while (r > 0) {\n+                int nc = read(skipBuffer, 0, (int)Math.min(r, nn));\n+                if (nc == -1)\n+                    break;\n+                r -= nc;\n@@ -440,17 +427,1 @@\n-        } else {\n-            synchronized (lock) {\n-                return implSkip(n);\n-            }\n-        }\n-    }\n-\n-    private long implSkip(long n) throws IOException {\n-        int nn = (int) Math.min(n, maxSkipBufferSize);\n-        if ((skipBuffer == null) || (skipBuffer.length < nn))\n-            skipBuffer = new char[nn];\n-        long r = n;\n-        while (r > 0) {\n-            int nc = read(skipBuffer, 0, (int)Math.min(r, nn));\n-            if (nc == -1)\n-                break;\n-            r -= nc;\n+            return n - r;\n@@ -458,1 +429,0 @@\n-        return n - r;\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":11,"deletions":41,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -165,15 +164,0 @@\n-    \/**\n-     * For use by BufferedWriter to create a character-stream writer that uses an\n-     * internal lock when BufferedWriter is not extended and the given writer is\n-     * trusted, otherwise critical sections will synchronize on the given writer.\n-     *\/\n-    Writer(Writer writer) {\n-        Class<?> clazz = writer.getClass();\n-        if (getClass() == BufferedWriter.class &&\n-                (clazz == OutputStreamWriter.class || clazz == FileWriter.class)) {\n-            this.lock = InternalLock.newLockOr(writer);\n-        } else {\n-            this.lock = writer;\n-        }\n-    }\n-\n@@ -209,11 +193,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                implWrite(c);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implWrite(c);\n+        synchronized (lock) {\n+            if (writeBuffer == null){\n+                writeBuffer = new char[WRITE_BUFFER_SIZE];\n@@ -221,0 +197,2 @@\n+            writeBuffer[0] = (char) c;\n+            write(writeBuffer, 0, 1);\n@@ -224,8 +202,0 @@\n-    private void implWrite(int c) throws IOException {\n-        if (writeBuffer == null){\n-            writeBuffer = new char[WRITE_BUFFER_SIZE];\n-        }\n-        writeBuffer[0] = (char) c;\n-        write(writeBuffer, 0, 1);\n-    }\n-\n@@ -308,20 +278,9 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                implWrite(str, off, len);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                implWrite(str, off, len);\n-            }\n-        }\n-    }\n-\n-    private void implWrite(String str, int off, int len) throws IOException {\n-        char cbuf[];\n-        if (len <= WRITE_BUFFER_SIZE) {\n-            if (writeBuffer == null) {\n-                writeBuffer = new char[WRITE_BUFFER_SIZE];\n+        synchronized (lock) {\n+            char cbuf[];\n+            if (len <= WRITE_BUFFER_SIZE) {\n+                if (writeBuffer == null) {\n+                    writeBuffer = new char[WRITE_BUFFER_SIZE];\n+                }\n+                cbuf = writeBuffer;\n+            } else {    \/\/ Don't permanently allocate very large buffers.\n+                cbuf = new char[len];\n@@ -329,3 +288,2 @@\n-            cbuf = writeBuffer;\n-        } else {    \/\/ Don't permanently allocate very large buffers.\n-            cbuf = new char[len];\n+            str.getChars(off, (off + len), cbuf, 0);\n+            write(cbuf, 0, len);\n@@ -333,2 +291,0 @@\n-        str.getChars(off, (off + len), cbuf, 0);\n-        write(cbuf, 0, len);\n","filename":"src\/java.base\/share\/classes\/java\/io\/Writer.java","additions":16,"deletions":60,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.access.SharedSecrets;\n@@ -32,1 +31,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -692,14 +690,0 @@\n-        Object lock = s.lock();\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                lockedPrintStackTrace(s);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else synchronized (lock) {\n-            lockedPrintStackTrace(s);\n-        }\n-    }\n-\n-    private void lockedPrintStackTrace(PrintStreamOrWriter s) {\n@@ -711,5 +695,6 @@\n-        \/\/ Print our stack trace\n-        s.println(this);\n-        StackTraceElement[] trace = getOurStackTrace();\n-        for (StackTraceElement traceElement : trace)\n-            s.println(\"\\tat \" + traceElement);\n+        synchronized(s.lock()) {\n+            \/\/ Print our stack trace\n+            s.println(this);\n+            StackTraceElement[] trace = getOurStackTrace();\n+            for (StackTraceElement traceElement : trace)\n+                s.println(\"\\tat \" + traceElement);\n@@ -717,3 +702,3 @@\n-        \/\/ Print suppressed exceptions, if any\n-        for (Throwable se : getSuppressed())\n-            se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, \"\\t\", dejaVu);\n+            \/\/ Print suppressed exceptions, if any\n+            for (Throwable se : getSuppressed())\n+                se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, \"\\t\", dejaVu);\n@@ -721,4 +706,5 @@\n-        \/\/ Print cause, if any\n-        Throwable ourCause = getCause();\n-        if (ourCause != null)\n-            ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, \"\", dejaVu);\n+            \/\/ Print cause, if any\n+            Throwable ourCause = getCause();\n+            if (ourCause != null)\n+                ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, \"\", dejaVu);\n+        }\n@@ -736,1 +722,1 @@\n-        assert s.isLockedByCurrentThread();\n+        assert Thread.holdsLock(s.lock());\n@@ -788,9 +774,0 @@\n-        boolean isLockedByCurrentThread() {\n-            Object lock = lock();\n-            if (lock instanceof InternalLock locker) {\n-                return locker.isHeldByCurrentThread();\n-            } else {\n-                return Thread.holdsLock(lock);\n-            }\n-        }\n-\n@@ -809,1 +786,1 @@\n-            return SharedSecrets.getJavaIOPrintStreamAccess().lock(printStream);\n+            return printStream;\n@@ -825,1 +802,1 @@\n-            return SharedSecrets.getJavaIOPrintWriterAccess().lock(printWriter);\n+            return printWriter;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Throwable.java","additions":18,"deletions":41,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.access;\n-\n-import java.io.PrintStream;\n-\n-public interface JavaIOPrintStreamAccess {\n-    Object lock(PrintStream ps);\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOPrintStreamAccess.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.access;\n-\n-import java.io.PrintWriter;\n-\n-public interface JavaIOPrintWriterAccess {\n-    Object lock(PrintWriter pw);\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOPrintWriterAccess.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -74,2 +74,0 @@\n-    private static JavaIOPrintStreamAccess javaIOPrintStreamAccess;\n-    private static JavaIOPrintWriterAccess javaIOPrintWriterAccess;\n@@ -291,26 +289,0 @@\n-    public static void setJavaIOCPrintWriterAccess(JavaIOPrintWriterAccess a) {\n-        javaIOPrintWriterAccess = a;\n-    }\n-\n-    public static JavaIOPrintWriterAccess getJavaIOPrintWriterAccess() {\n-        var access = javaIOPrintWriterAccess;\n-        if (access == null) {\n-            ensureClassInitialized(PrintWriter.class);\n-            access = javaIOPrintWriterAccess;\n-        }\n-        return access;\n-    }\n-\n-    public static void setJavaIOCPrintStreamAccess(JavaIOPrintStreamAccess a) {\n-        javaIOPrintStreamAccess = a;\n-    }\n-\n-    public static JavaIOPrintStreamAccess getJavaIOPrintStreamAccess() {\n-        var access = javaIOPrintStreamAccess;\n-        if (access == null) {\n-            ensureClassInitialized(PrintStream.class);\n-            access = javaIOPrintStreamAccess;\n-        }\n-        return access;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.misc;\n-\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-\/**\n- * A reentrant mutual exclusion lock for internal use. The lock does not\n- * implement {@link java.util.concurrent.locks.Lock} or extend {@link\n- * java.util.concurrent.locks.ReentrantLock} so that it can be distinguished\n- * from lock objects accessible to subclasses of {@link java.io.Reader} and\n- * {@link java.io.Writer} (it is possible to create a Reader that uses a\n- * lock object of type ReentrantLock for example).\n- *\/\n-public class InternalLock {\n-    private static final boolean CAN_USE_INTERNAL_LOCK;\n-    static {\n-        String s = System.getProperty(\"jdk.io.useMonitors\");\n-        if (s != null && s.equals(\"false\")) {\n-            CAN_USE_INTERNAL_LOCK = true;\n-        } else {\n-            CAN_USE_INTERNAL_LOCK = false;\n-        }\n-    }\n-\n-    private final ReentrantLock lock;\n-\n-    private InternalLock() {\n-        this.lock = new ReentrantLock();\n-    }\n-\n-    \/**\n-     * Returns a new InternalLock or null.\n-     *\/\n-    public static InternalLock newLockOrNull() {\n-        return (CAN_USE_INTERNAL_LOCK) ? new InternalLock() : null;\n-    }\n-\n-    \/**\n-     * Returns a new InternalLock or the given object.\n-     *\/\n-    public static Object newLockOr(Object obj) {\n-        return (CAN_USE_INTERNAL_LOCK) ? new InternalLock() : obj;\n-    }\n-\n-    public boolean tryLock() {\n-        return lock.tryLock();\n-    }\n-\n-    public void lock() {\n-        lock.lock();\n-    }\n-\n-    public void unlock() {\n-        lock.unlock();\n-    }\n-\n-    public boolean isHeldByCurrentThread() {\n-        return lock.isHeldByCurrentThread();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/InternalLock.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,0 @@\n-import jdk.internal.misc.InternalLock;\n-\n@@ -124,0 +122,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n@@ -125,11 +124,5 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return lockedRead0();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                return lockedRead0();\n+        synchronized (lock) {\n+            \/\/ Return the leftover char, if there is one\n+            if (haveLeftoverChar) {\n+                haveLeftoverChar = false;\n+                return leftoverChar;\n@@ -137,10 +130,0 @@\n-        }\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    private int lockedRead0() throws IOException {\n-        \/\/ Return the leftover char, if there is one\n-        if (haveLeftoverChar) {\n-            haveLeftoverChar = false;\n-            return leftoverChar;\n-        }\n@@ -148,15 +131,16 @@\n-        \/\/ Convert more bytes\n-        char[] cb = new char[2];\n-        int n = read(cb, 0, 2);\n-        switch (n) {\n-        case -1:\n-            return -1;\n-        case 2:\n-            leftoverChar = cb[1];\n-            haveLeftoverChar = true;\n-            \/\/ FALL THROUGH\n-        case 1:\n-            return cb[0];\n-        default:\n-            assert false : n;\n-            return -1;\n+            \/\/ Convert more bytes\n+            char[] cb = new char[2];\n+            int n = read(cb, 0, 2);\n+            switch (n) {\n+            case -1:\n+                return -1;\n+            case 2:\n+                leftoverChar = cb[1];\n+                haveLeftoverChar = true;\n+                \/\/ FALL THROUGH\n+            case 1:\n+                return cb[0];\n+            default:\n+                assert false : n;\n+                return -1;\n+            }\n@@ -167,7 +151,8 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return lockedRead(cbuf, offset, length);\n-            } finally {\n-                locker.unlock();\n+        synchronized (lock) {\n+            int off = offset;\n+            int len = length;\n+\n+            ensureOpen();\n+            if ((off < 0) || (off > cbuf.length) || (len < 0) ||\n+                ((off + len) > cbuf.length) || ((off + len) < 0)) {\n+                throw new IndexOutOfBoundsException();\n@@ -175,3 +160,14 @@\n-        } else {\n-            synchronized (lock) {\n-                return lockedRead(cbuf, offset, length);\n+            if (len == 0)\n+                return 0;\n+\n+            int n = 0;\n+\n+            if (haveLeftoverChar) {\n+                \/\/ Copy the leftover char into the buffer\n+                cbuf[off] = leftoverChar;\n+                off++; len--;\n+                haveLeftoverChar = false;\n+                n = 1;\n+                if ((len == 0) || !implReady())\n+                    \/\/ Return now if this is all we can produce w\/o blocking\n+                    return n;\n@@ -179,2 +175,0 @@\n-        }\n-    }\n@@ -182,3 +176,8 @@\n-    private int lockedRead(char[] cbuf, int offset, int length) throws IOException {\n-        int off = offset;\n-        int len = length;\n+            if (len == 1) {\n+                \/\/ Treat single-character array reads just like read()\n+                int c = read0();\n+                if (c == -1)\n+                    return (n == 0) ? -1 : n;\n+                cbuf[off] = (char)c;\n+                return n + 1;\n+            }\n@@ -186,20 +185,2 @@\n-        ensureOpen();\n-        if ((off < 0) || (off > cbuf.length) || (len < 0) ||\n-            ((off + len) > cbuf.length) || ((off + len) < 0)) {\n-            throw new IndexOutOfBoundsException();\n-        }\n-        if (len == 0)\n-            return 0;\n-\n-        int n = 0;\n-\n-        if (haveLeftoverChar) {\n-            \/\/ Copy the leftover char into the buffer\n-            cbuf[off] = leftoverChar;\n-            off++; len--;\n-            haveLeftoverChar = false;\n-            n = 1;\n-            if ((len == 0) || !implReady())\n-                \/\/ Return now if this is all we can produce w\/o blocking\n-                return n;\n-        }\n+            \/\/ Read remaining characters\n+            int nr = implRead(cbuf, off, off + len);\n@@ -207,7 +188,4 @@\n-        if (len == 1) {\n-            \/\/ Treat single-character array reads just like read()\n-            int c = read0();\n-            if (c == -1)\n-                return (n == 0) ? -1 : n;\n-            cbuf[off] = (char)c;\n-            return n + 1;\n+            \/\/ At this point, n is either 1 if a leftover character was read,\n+            \/\/ or 0 if no leftover character was read. If n is 1 and nr is -1,\n+            \/\/ indicating EOF, then we don't return their sum as this loses data.\n+            return (nr < 0) ? (n == 1 ? 1 : nr) : (n + nr);\n@@ -215,8 +193,0 @@\n-\n-        \/\/ Read remaining characters\n-        int nr = implRead(cbuf, off, off + len);\n-\n-        \/\/ At this point, n is either 1 if a leftover character was read,\n-        \/\/ or 0 if no leftover character was read. If n is 1 and nr is -1,\n-        \/\/ indicating EOF, then we don't return their sum as this loses data.\n-        return (nr < 0) ? (n == 1 ? 1 : nr) : (n + nr);\n@@ -226,12 +196,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                return lockedReady();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                return lockedReady();\n-            }\n+        synchronized (lock) {\n+            ensureOpen();\n+            return haveLeftoverChar || implReady();\n@@ -241,5 +202,0 @@\n-    private boolean lockedReady() throws IOException {\n-        ensureOpen();\n-        return haveLeftoverChar || implReady();\n-    }\n-\n@@ -247,3 +203,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n+            if (closed)\n+                return;\n@@ -251,1 +207,1 @@\n-                lockedClose();\n+                implClose();\n@@ -253,5 +209,1 @@\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedClose();\n+                closed = true;\n@@ -262,10 +214,0 @@\n-    private void lockedClose() throws IOException {\n-        if (closed)\n-            return;\n-        try {\n-            implClose();\n-        } finally {\n-            closed = true;\n-        }\n-    }\n-\n@@ -277,12 +219,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                lockedFillZeroToPosition();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedFillZeroToPosition();\n-            }\n+        synchronized (lock) {\n+            Arrays.fill(bb.array(), bb.arrayOffset(),\n+                        bb.arrayOffset() + bb.position(), (byte)0);\n@@ -292,4 +225,0 @@\n-    private void lockedFillZeroToPosition() {\n-        Arrays.fill(bb.array(), bb.arrayOffset(), bb.arrayOffset() + bb.position(), (byte)0);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamDecoder.java","additions":70,"deletions":141,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import jdk.internal.misc.InternalLock;\n@@ -100,12 +99,5 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                lockedFlushBuffer();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedFlushBuffer();\n-            }\n+        synchronized (lock) {\n+            if (isOpen())\n+                implFlushBuffer();\n+            else\n+                throw new IOException(\"Stream closed\");\n@@ -115,7 +107,0 @@\n-    private void lockedFlushBuffer() throws IOException {\n-        if (isOpen())\n-            implFlushBuffer();\n-        else\n-            throw new IOException(\"Stream closed\");\n-    }\n-\n@@ -129,18 +114,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                lockedWrite(cbuf, off, len);\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedWrite(cbuf, off, len);\n-            }\n-        }\n-    }\n-\n-    private void lockedWrite(char[] cbuf, int off, int len) throws IOException {\n-        ensureOpen();\n-        if ((off < 0) || (off > cbuf.length) || (len < 0) ||\n+        synchronized (lock) {\n+            ensureOpen();\n+            if ((off < 0) || (off > cbuf.length) || (len < 0) ||\n@@ -148,3 +118,5 @@\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n-            return;\n+                throw new IndexOutOfBoundsException();\n+            } else if (len == 0) {\n+                return;\n+            }\n+            implWrite(cbuf, off, len);\n@@ -152,1 +124,0 @@\n-        implWrite(cbuf, off, len);\n@@ -167,12 +138,3 @@\n-            Object lock = this.lock;\n-            if (lock instanceof InternalLock locker) {\n-                locker.lock();\n-                try {\n-                    lockedWrite(cb);\n-                } finally {\n-                    locker.unlock();\n-                }\n-            } else {\n-                synchronized (lock) {\n-                    lockedWrite(cb);\n-                }\n+            synchronized (lock) {\n+                ensureOpen();\n+                implWrite(cb);\n@@ -185,5 +147,0 @@\n-    private void lockedWrite(CharBuffer cb) throws IOException {\n-        ensureOpen();\n-        implWrite(cb);\n-    }\n-\n@@ -191,12 +148,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n-            try {\n-                lockedFlush();\n-            } finally {\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedFlush();\n-            }\n+        synchronized (lock) {\n+            ensureOpen();\n+            implFlush();\n@@ -206,5 +154,0 @@\n-    private void lockedFlush() throws IOException {\n-        ensureOpen();\n-        implFlush();\n-    }\n-\n@@ -212,3 +155,3 @@\n-        Object lock = this.lock;\n-        if (lock instanceof InternalLock locker) {\n-            locker.lock();\n+        synchronized (lock) {\n+            if (closed)\n+                return;\n@@ -216,1 +159,1 @@\n-                lockedClose();\n+                implClose();\n@@ -218,5 +161,1 @@\n-                locker.unlock();\n-            }\n-        } else {\n-            synchronized (lock) {\n-                lockedClose();\n+                closed = true;\n@@ -227,10 +166,0 @@\n-    private void lockedClose() throws IOException {\n-        if (closed)\n-            return;\n-        try {\n-            implClose();\n-        } finally {\n-            closed = true;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamEncoder.java","additions":25,"deletions":96,"binary":false,"changes":121,"status":"modified"}]}