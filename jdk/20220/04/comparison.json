{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.time.Duration;\n@@ -478,0 +479,29 @@\n+    \/**\n+     * Causes the current thread to wait, if necessary, until the\n+     * process represented by this {@code Process} object has\n+     * terminated, or the specified waiting duration elapses.\n+     *\n+     * <p>If the process has already terminated then this method returns\n+     * immediately with the value {@code true}.  If the process has not\n+     * terminated and the duration is not positive, then\n+     * this method returns immediately with the value {@code false}.\n+     *\n+     * <p>The default implementation of this method polls the {@code exitValue}\n+     * to check if the process has terminated. Concrete implementations of this\n+     * class are strongly encouraged to override this method with a more\n+     * efficient implementation.\n+     *\n+     * @param duration the maximum duration to wait; if not positive,\n+     *                this method returns immediately.\n+     * @return {@code true} if the process has exited and {@code false} if\n+     *         the waiting duration elapsed before the process has exited.\n+     * @throws InterruptedException if the current thread is interrupted\n+     *         while waiting.\n+     * @throws NullPointerException if duration is null\n+     * @since 24\n+     *\/\n+    public boolean waitFor(Duration duration) throws InterruptedException {\n+        Objects.requireNonNull(duration, \"duration\");\n+        return waitFor(TimeUnit.NANOSECONDS.convert(duration), TimeUnit.NANOSECONDS);\n+    }\n+\n@@ -580,2 +610,2 @@\n-     * {@code waitFor(long, TimeUnit)}, which is specified to poll\n-     * {@code exitValue()}.\n+     * {@code waitFor(long, TimeUnit)} and {@code waitFor(Duration)},\n+     * which are specified to poll {@code exitValue()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336479\n+ * @summary Tests for Process.waitFor(Duration)\n+ * @library \/test\/lib\n+ * @run junit WaitForDuration\n+ *\/\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.stream.Stream;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class WaitForDuration {\n+    static Stream<Arguments> durations() {\n+        return Stream.of(\n+            Arguments.of(Duration.ZERO, 3_600_000, false),\n+            Arguments.of(Duration.ofSeconds(-100), 3_600_000, false),\n+            Arguments.of(Duration.ofSeconds(100), 0, true),\n+            Arguments.of(Duration.ofSeconds(Long.MAX_VALUE), 0, true), \/\/ nano overflow\n+            Arguments.of(Duration.ofSeconds(Long.MIN_VALUE), 3_600_000, false) \/\/ nano underflow\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"durations\")\n+    void testEdgeDurations(Duration d, int sleepMillis, boolean expected)\n+            throws IOException, InterruptedException {\n+        var pb = ProcessTools.createTestJavaProcessBuilder(\n+            WaitForDuration.class.getSimpleName(), Integer.toString(sleepMillis));\n+        assertEquals(expected, pb.start().waitFor(d));\n+    }\n+\n+    @Test\n+    void testNullDuration() throws IOException, InterruptedException {\n+        var pb = ProcessTools.createTestJavaProcessBuilder(\n+            WaitForDuration.class.getSimpleName(), \"0\");\n+        assertThrows(NullPointerException.class, () -> pb.start().waitFor(null));\n+    }\n+\n+    public static void main(String... args) throws InterruptedException {\n+        Thread.sleep(Integer.parseInt(args[0]));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Process\/WaitForDuration.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -45,0 +45,1 @@\n+import java.time.Duration;\n@@ -964,0 +965,9 @@\n+            }\n+            return rslt;\n+        }\n+\n+        @Override\n+        public boolean waitFor(Duration duration) throws InterruptedException {\n+            boolean rslt = p.waitFor(duration);\n+            if (rslt) {\n+                waitForStreams();\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}