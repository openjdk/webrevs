{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.time.Duration;\n@@ -459,3 +460,3 @@\n-        throws InterruptedException\n-    {\n-        long remainingNanos = unit.toNanos(timeout); \/\/ throw NPE before other conditions\n+        throws InterruptedException {\n+        Objects.requireNonNull(unit, \"unit\"); \/\/ throw NPE before other conditions\n+\n@@ -467,0 +468,40 @@\n+        return waitForNanos(unit.toNanos(timeout));\n+    }\n+\n+    \/**\n+     * Causes the current thread to wait, if necessary, until the\n+     * process represented by this {@code Process} object has\n+     * terminated, or the specified waiting duration elapses.\n+     *\n+     * <p>If the process has already terminated then this method returns\n+     * immediately with the value {@code true}.  If the process has not\n+     * terminated and the duration is not positive, then\n+     * this method returns immediately with the value {@code false}.\n+     *\n+     * <p>The default implementation of this method polls the {@code exitValue}\n+     * to check if the process has terminated. Concrete implementations of this\n+     * class are strongly encouraged to override this method with a more\n+     * efficient implementation.\n+     *\n+     * @param duration the maximum duration to wait; if not positive,\n+     *                this method returns immediately.\n+     * @return {@code true} if the process has exited and {@code false} if\n+     *         the waiting duration elapsed before the process has exited.\n+     * @throws InterruptedException if the current thread is interrupted\n+     *         while waiting.\n+     * @throws NullPointerException if duration is null\n+     * @since 24\n+     *\/\n+    public boolean waitFor(Duration duration)\n+            throws InterruptedException {\n+        Objects.requireNonNull(duration, \"duration\"); \/\/ throw NPE before other conditions\n+\n+        if (hasExited())\n+            return true;\n+        if (duration.isZero() || duration.isNegative())\n+            return false;\n+\n+        return waitForNanos(TimeUnit.NANOSECONDS.convert(duration));\n+    }\n+\n+    private boolean waitForNanos(long remainingNanos) throws InterruptedException {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":44,"deletions":3,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336479\n+ * @summary Tests for Process.waitFor(Duration)\n+ * @run junit WaitForDuration\n+ *\/\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class WaitForDuration {\n+    static Stream<Arguments> durations() {\n+        return Stream.of(\n+            Arguments.of(Duration.ZERO, false),\n+            Arguments.of(Duration.ofSeconds(-100), false),\n+            Arguments.of(Duration.ofSeconds(100), true),\n+            Arguments.of(Duration.ofSeconds(Long.MAX_VALUE), true), \/\/ nano overflow\n+            Arguments.of(Duration.ofSeconds(Long.MIN_VALUE), false) \/\/ nano underflow\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"durations\")\n+    void testEdgeDurations(Duration d, boolean expected)\n+            throws IOException, InterruptedException {\n+        assertEquals(expected,\n+            new ProcessBuilder(\"sleep\", \"3\").start().waitFor(d));\n+    }\n+\n+    @Test\n+    void testNullDuration() throws IOException, InterruptedException {\n+        assertThrows(NullPointerException.class, () ->\n+            new ProcessBuilder(\"sleep\", \"3\").start().waitFor(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Process\/WaitForDuration.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"}]}