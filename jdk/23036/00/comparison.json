{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -321,2 +321,6 @@\n-        protected void done() {\n-            executor.taskComplete(thread);\n+        public void run() {\n+            try {\n+                super.run();\n+            } finally {\n+                executor.taskComplete(thread);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadPerTaskExecutor.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8284161 8347039\n@@ -160,0 +161,1 @@\n+                assertFalse(future.isDone());\n@@ -283,1 +285,1 @@\n-     * Test awaitTermination when not shutdown.\n+     * Test awaitTermination with no tasks running.\n@@ -289,1 +291,1 @@\n-        executor.close();\n+        executor.shutdown();\n@@ -299,2 +301,33 @@\n-        Phaser barrier = new Phaser(2);\n-        Future<?> future = executor.submit(barrier::arriveAndAwaitAdvance);\n+        var started = new CountDownLatch(1);\n+        var stop = new CountDownLatch(1);\n+        Future<?> future = executor.submit(() -> {\n+            started.countDown();\n+            stop.await();\n+            return null;\n+        });\n+        started.await();\n+        try {\n+            executor.shutdown();\n+            assertFalse(executor.awaitTermination(1, TimeUnit.SECONDS));\n+            assertFalse(future.isDone());\n+        } finally {\n+            stop.countDown();\n+        }\n+        assertTrue(executor.awaitTermination(1, TimeUnit.MINUTES));\n+        assertTrue(future.isDone());\n+    }\n+\n+    \/**\n+     * Test awaitTermination with cancelled task still running.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testAwaitTermination3(ExecutorService executor) throws Exception {\n+        var started = new CountDownLatch(1);\n+        var stop = new CountDownLatch(1);\n+        Future<?> future = executor.submit(() -> {\n+            started.countDown();\n+            stop.await();\n+            return null;\n+        });\n+        started.await();\n@@ -302,0 +335,1 @@\n+            future.cancel(false);\n@@ -303,3 +337,1 @@\n-            assertFalse(executor.awaitTermination(100, TimeUnit.MILLISECONDS));\n-            barrier.arriveAndAwaitAdvance();\n-            assertTrue(executor.awaitTermination(10, TimeUnit.SECONDS));\n+            assertFalse(executor.awaitTermination(1, TimeUnit.SECONDS));\n@@ -307,1 +339,1 @@\n-            future.cancel(true);\n+            stop.countDown();\n@@ -309,0 +341,16 @@\n+        assertTrue(executor.awaitTermination(1, TimeUnit.MINUTES));\n+    }\n+\n+    \/**\n+     * Test awaitTermination with cancelled task that may not have started execution.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testAwaitTermination4(ExecutorService executor) throws Exception {\n+        Future<?> future = executor.submit(() -> {\n+            Thread.sleep(Duration.ofMillis(50));\n+            return null;\n+        });\n+        future.cancel(false);\n+        executor.shutdown();\n+        assertTrue(executor.awaitTermination(1, TimeUnit.MINUTES));\n","filename":"test\/jdk\/java\/util\/concurrent\/ThreadPerTaskExecutor\/ThreadPerTaskExecutorTest.java","additions":57,"deletions":9,"binary":false,"changes":66,"status":"modified"}]}