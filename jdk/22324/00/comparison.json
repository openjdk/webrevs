{"files":[{"patch":"@@ -40,6 +40,0 @@\n-import java.security.AccessController;\n-import java.security.AccessControlContext;\n-import java.security.Permission;\n-import java.security.Permissions;\n-import java.security.PrivilegedAction;\n-import java.security.ProtectionDomain;\n@@ -814,3 +808,1 @@\n-     * some System property parsing and security processing that takes\n-     * far longer than the actual construction when SecurityManagers\n-     * are used or properties are set. The common pool is\n+     * some System property parsing properties are set. The common pool is\n@@ -842,7 +834,6 @@\n-     * InnocuousForkJoinWorkerThread when there is a SecurityManager\n-     * present. These workers have no permissions set, do not belong\n-     * to any user-defined ThreadGroup, and clear all ThreadLocals and\n-     * reset the ContextClassLoader before (re)activating to execute\n-     * top-level task.  The associated mechanics may be JVM-dependent\n-     * and must access particular Thread class fields to achieve this\n-     * effect.\n+     * InnocuousForkJoinWorkerThread for the commonPool.  These\n+     * workers do not belong to any user-defined ThreadGroup, and\n+     * clear all ThreadLocals and reset the ContextClassLoader before\n+     * (re)activating to execute top-level tasks.  The associated\n+     * mechanics may be JVM-dependent and must access particular\n+     * Thread class fields to achieve this effect.\n@@ -1100,15 +1091,0 @@\n-    \/**\n-     * If there is a security manager, makes sure caller has\n-     * permission to modify threads.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private static void checkPermission() {\n-        SecurityManager security; RuntimePermission perm;\n-        if ((security = System.getSecurityManager()) != null) {\n-            if ((perm = modifyThreadPermission) == null)\n-                modifyThreadPermission = perm = \/\/ races OK\n-                    new RuntimePermission(\"modifyThread\");\n-            security.checkPermission(perm);\n-        }\n-    }\n-\n@@ -1150,58 +1126,3 @@\n-            boolean isCommon = (pool.workerNamePrefix == null);\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null && isCommon)\n-                return newCommonWithACC(pool);\n-            else\n-                return newRegularWithACC(pool);\n-        }\n-\n-        \/*\n-         * Create and use static AccessControlContexts only if there\n-         * is a SecurityManager. (These can be removed if\/when\n-         * SecurityManagers are removed from platform.) The ACCs are\n-         * immutable and equivalent even when racily initialized, so\n-         * they don't require locking, although with the chance of\n-         * needlessly duplicate construction.\n-         *\/\n-        @SuppressWarnings(\"removal\")\n-        static volatile AccessControlContext regularACC, commonACC;\n-\n-        @SuppressWarnings(\"removal\")\n-        static ForkJoinWorkerThread newRegularWithACC(ForkJoinPool pool) {\n-            AccessControlContext acc = regularACC;\n-            if (acc == null) {\n-                Permissions ps = new Permissions();\n-                ps.add(new RuntimePermission(\"getClassLoader\"));\n-                ps.add(new RuntimePermission(\"setContextClassLoader\"));\n-                regularACC = acc =\n-                    new AccessControlContext(new ProtectionDomain[] {\n-                            new ProtectionDomain(null, ps) });\n-            }\n-            return AccessController.doPrivileged(\n-                new PrivilegedAction<>() {\n-                    public ForkJoinWorkerThread run() {\n-                        return new ForkJoinWorkerThread(null, pool, true, false);\n-                    }}, acc);\n-        }\n-\n-        @SuppressWarnings(\"removal\")\n-        static ForkJoinWorkerThread newCommonWithACC(ForkJoinPool pool) {\n-            AccessControlContext acc = commonACC;\n-            if (acc == null) {\n-                Permissions ps = new Permissions();\n-                ps.add(new RuntimePermission(\"getClassLoader\"));\n-                ps.add(new RuntimePermission(\"setContextClassLoader\"));\n-                ps.add(new RuntimePermission(\"modifyThread\"));\n-                ps.add(new RuntimePermission(\"enableContextClassLoaderOverride\"));\n-                ps.add(new RuntimePermission(\"modifyThreadGroup\"));\n-                commonACC = acc =\n-                    new AccessControlContext(new ProtectionDomain[] {\n-                            new ProtectionDomain(null, ps) });\n-            }\n-            return AccessController.doPrivileged(\n-                new PrivilegedAction<>() {\n-                    public ForkJoinWorkerThread run() {\n-                        return new ForkJoinWorkerThread.\n-                            InnocuousForkJoinWorkerThread(pool);\n-                    }}, acc);\n+            return ((pool.workerNamePrefix == null) ? \/\/ is commonPool\n+                    new ForkJoinWorkerThread.InnocuousForkJoinWorkerThread(pool) :\n+                    new ForkJoinWorkerThread(null, pool, true, false));\n@@ -3027,1 +2948,0 @@\n-        checkPermission();\n@@ -3315,1 +3235,0 @@\n-        checkPermission();\n@@ -3713,1 +3632,0 @@\n-        checkPermission();\n@@ -3733,1 +3651,0 @@\n-        checkPermission();\n@@ -3840,1 +3757,0 @@\n-            checkPermission();\n@@ -4078,6 +3994,1 @@\n-        @SuppressWarnings(\"removal\")\n-        ForkJoinPool p = common = (System.getSecurityManager() == null) ?\n-            new ForkJoinPool((byte)0) :\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                    public ForkJoinPool run() {\n-                        return new ForkJoinPool((byte)0); }});\n+        common = new ForkJoinPool((byte)0);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":11,"deletions":100,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -38,4 +38,0 @@\n-import java.security.AccessController;\n-import java.security.AccessControlContext;\n-import java.security.PrivilegedAction;\n-import java.security.ProtectionDomain;\n@@ -87,1 +83,1 @@\n-        if (useSystemClassLoader)\n+        if (useSystemClassLoader & !clearThreadLocals) \/\/ else done by Thread ctor\n@@ -231,1 +227,1 @@\n-     * Clears ThreadLocals, and if necessary resets ContextClassLoader\n+     * Clears ThreadLocals\n@@ -233,1 +229,1 @@\n-     final void resetThreadLocals() {\n+    final void resetThreadLocals() {\n@@ -238,3 +234,1 @@\n-         if ((this instanceof InnocuousForkJoinWorkerThread) &&\n-             ((InnocuousForkJoinWorkerThread)this).needCCLReset())\n-             super.setContextClassLoader(ClassLoader.getSystemClassLoader());\n+         onThreadLocalReset();\n@@ -243,0 +237,6 @@\n+    \/**\n+     * Peforms any associated cleanup on resetThreadLocals\n+     *\/\n+    void onThreadLocalReset() {\n+    }\n+\n@@ -251,4 +251,4 @@\n-     * A worker thread that has no permissions, is not a member of any\n-     * user-defined ThreadGroup, uses the system class loader as\n-     * thread context class loader, and clears all ThreadLocals after\n-     * running each top-level task.\n+     * A worker thread that is not a member of any user-defined\n+     * ThreadGroup, uses the system class loader as thread context\n+     * class loader, and clears all ThreadLocals after running each\n+     * top-level task.\n@@ -267,2 +267,1 @@\n-        @Override \/\/ paranoically\n-        @SuppressWarnings(\"removal\")\n+        @Override \/\/ to record changes\n@@ -270,5 +269,4 @@\n-            if (System.getSecurityManager() != null &&\n-                cl != null && ClassLoader.getSystemClassLoader() != cl)\n-                throw new SecurityException(\"setContextClassLoader\");\n-            resetCCL = true;\n-            super.setContextClassLoader(cl);\n+            if (ClassLoader.getSystemClassLoader() != cl) {\n+                resetCCL = true;\n+                super.setContextClassLoader(cl);\n+            }\n@@ -277,3 +275,3 @@\n-        final boolean needCCLReset() { \/\/ get and clear\n-            boolean needReset;\n-            if (needReset = resetCCL)\n+        @Override \/\/ to re-establish CCL if necessary\n+        final void onThreadLocalReset() {\n+            if (resetCCL) {\n@@ -281,1 +279,2 @@\n-            return needReset;\n+                super.setContextClassLoader(ClassLoader.getSystemClassLoader());\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"}]}