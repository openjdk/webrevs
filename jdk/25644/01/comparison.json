{"files":[{"patch":"@@ -172,7 +172,1 @@\n-\n-        return Double.parseDouble(getStringBuilder()\n-                .append('.')\n-                .append(digits, 0, count)\n-                .append('E')\n-                .append(decimalAt)\n-                .toString());\n+        return FloatingDecimal.parseDoubleDigits(decimalAt, digits, count);\n@@ -193,1 +187,1 @@\n-        \/\/ We have to check for this, because this is the one NEGATIVE value\n+        \/\/ Parse as unsigned to handle Long.MIN_VALUE, which is the one NEGATIVE value\n@@ -196,2 +190,13 @@\n-        if (isLongMIN_VALUE()) {\n-            return Long.MIN_VALUE;\n+        long v = Long.parseUnsignedLong(new String(digits, 0, count));\n+        if (v < 0) {\n+            if (v == Long.MIN_VALUE) {\n+                return Long.MIN_VALUE;\n+            }\n+            throw new NumberFormatException(\"Unexpected negative value\");\n+        }\n+        try {\n+            long pow10 = Math.powExact(10L, Math.max(0, decimalAt - count));\n+            return Math.multiplyExact(v, pow10);\n+        } catch (ArithmeticException e) {\n+            NumberFormatException nfe = new NumberFormatException(\"Value does not fit into a long\");\n+            throw nfe;\n@@ -199,5 +204,0 @@\n-\n-        StringBuilder temp = getStringBuilder();\n-        temp.append(digits, 0, count);\n-        temp.append(\"0\".repeat(Math.max(0, decimalAt - count)));\n-        return Long.parseLong(temp.toString());\n@@ -213,5 +213,1 @@\n-            if (decimalAt == 0) {\n-                return BigDecimal.ZERO;\n-            } else {\n-                return new BigDecimal(\"0E\" + decimalAt);\n-            }\n+            return BigDecimal.valueOf(0, -decimalAt);\n@@ -729,3 +725,3 @@\n-            \/\/ data and tempBuilder do not need to be copied because they do\n-            \/\/ not carry significant information. They will be recreated on demand.\n-            \/\/ Setting them to null is needed to avoid sharing across clones.\n+            \/\/ Data does not need to be copied because it does\n+            \/\/ not carry significant information. It will be recreated on demand.\n+            \/\/ Setting it to null is needed to avoid sharing across clones.\n@@ -733,1 +729,0 @@\n-            other.tempBuilder = null;\n@@ -741,17 +736,1 @@\n-    \/**\n-     * Returns true if this DigitList represents Long.MIN_VALUE;\n-     * false, otherwise.  This is required so that getLong() works.\n-     *\/\n-    private boolean isLongMIN_VALUE() {\n-        if (decimalAt != count || count != MAX_COUNT) {\n-            return false;\n-        }\n-\n-        for (int i = 0; i < count; ++i) {\n-            if (digits[i] != LONG_MIN_REP[i]) return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    private static final int parseInt(char[] str, int offset, int strLen) {\n+    private static int parseInt(char[] str, int offset, int strLen) {\n@@ -790,11 +769,0 @@\n-    private StringBuilder tempBuilder;\n-\n-    private StringBuilder getStringBuilder() {\n-        if (tempBuilder == null) {\n-            tempBuilder = new StringBuilder(MAX_COUNT);\n-        } else {\n-            tempBuilder.setLength(0);\n-        }\n-        return tempBuilder;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":20,"deletions":52,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,0 +125,13 @@\n+    \/**\n+     * Converts a sequence of digits ('0'-'9') as well as an exponent to a positive\n+     * double value\n+     *\n+     * @param decExp The decimal exponent of the value to generate\n+     * @param digits The digits of the significand.\n+     * @param length Number of digits to use\n+     * @return The double-precision value of the conversion\n+     *\/\n+    public static double parseDoubleDigits(int decExp, char[] digits, int length) throws NumberFormatException {\n+        return readDoubleDigits(decExp, digits, length).doubleValue();\n+    }\n+\n@@ -1827,0 +1840,11 @@\n+    static ASCIIToBinaryConverter readDoubleDigits(int decExp, char[] digits, int length) {\n+        if (decExp < MIN_DECIMAL_EXPONENT) {\n+            return buildZero(BINARY_64_IX, 1);\n+        }\n+        byte[] buf = new byte[length];\n+        for (int i = 0; i < length; i++) {\n+            buf[i] = (byte) digits[i];\n+        }\n+        return new ASCIIToBinaryBuffer(false, decExp, buf, length);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -98,5 +98,0 @@\n-                Object tempBuilder = valFromDigitList(original, \"tempBuilder\");\n-                if (tempBuilder != null) {\n-                    assertNotSame(data, valFromDigitList(dfClone, \"data\"));\n-                }\n-\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/CloneTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.text;\n+\n+import java.text.NumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class DecimalFormatParseBench {\n+\n+    public String[] valuesLong;\n+    public String[] valuesDouble;\n+\n+    @Setup\n+    public void setup() {\n+        valuesLong = new String[]{\n+                \"123\", \"149\", \"180\", \"170000000000000000\", \"0\", \"-149\", \"-15000\", \"99999123\", \"1494\", \"1495\", \"1030\", \"25996\", \"-25996\"\n+        };\n+\n+        valuesDouble = new String[]{\n+                \"1.23\", \"1.49\", \"1.80\", \"17000000000000000.1\", \"0.01\", \"-1.49\", \"-1.50\", \"9999.9123\", \"1.494\", \"1.495\", \"1.03\", \"25.996\", \"-25.996\"\n+        };\n+    }\n+\n+    private NumberFormat dnf = new DecimalFormat();\n+\n+    @Benchmark\n+    @OperationsPerInvocation(13)\n+    public void testParseLongs(final Blackhole blackhole) throws ParseException {\n+        for (String value : valuesLong) {\n+            blackhole.consume(this.dnf.parse(value));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(13)\n+    public void testParseDoubles(final Blackhole blackhole) throws ParseException {\n+        for (String value : valuesDouble) {\n+            blackhole.consume(this.dnf.parse(value));\n+        }\n+    }\n+    public static void main(String... args) throws Exception {\n+        Options opts = new OptionsBuilder().include(DefFormatterBench.class.getSimpleName()).shouldDoGC(true).build();\n+        new Runner(opts).run();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/DecimalFormatParseBench.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}