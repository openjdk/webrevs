{"files":[{"patch":"@@ -60,0 +60,2 @@\n+    private static final byte[] EMPTY = new byte[0];\n+\n@@ -70,2 +72,0 @@\n-    private static final byte[] EMPTY = new byte[0];\n-\n@@ -75,0 +75,3 @@\n+    \/\/ initial buffer size (DEFAULT_BUFFER_SIZE or size specified to constructor)\n+    private final int initialSize;\n+\n@@ -159,2 +162,0 @@\n-    private final int size;\n-\n@@ -173,3 +174,3 @@\n-     * Return the buffer if already allocated, or allocate one, or throw {@link IOException} if this stream is closed.\n-     * If a caller simply wants to ensure whether this BufferedInputStream is open\n-     * they should call {@link #getInIfOpen()} instead.\n+     * Returns the internal buffer, optionally allocating it if empty.\n+     * @param allocateIfEmpty true to allocate if empty\n+     * @throws IOException if the stream is closed (buf is null)\n@@ -177,17 +178,7 @@\n-    private byte[] getBufIfOpen() throws IOException {\n-        byte[] allocated = null;\n-        do {\n-            byte[] buffer = buf;\n-            if (buffer == null) {\n-                throw new IOException(\"Stream closed\");\n-            }\n-            if (buffer == EMPTY) {\n-                if (allocated == null) {\n-                    allocated = new byte[size];\n-                }\n-                \/\/ defend against asynchronous close\n-                if (U.compareAndSetReference(this, BUF_OFFSET, EMPTY, allocated)) {\n-                    return allocated;\n-                } else{\n-                    continue;\n-                }\n+    private byte[] getBufIfOpen(boolean allocateIfEmpty) throws IOException {\n+        byte[] buffer = buf;\n+        if (allocateIfEmpty && buffer == EMPTY) {\n+            buffer = new byte[initialSize];\n+            if (!U.compareAndSetReference(this, BUF_OFFSET, EMPTY, buffer)) {\n+                \/\/ re-read buf\n+                buffer = buf;\n@@ -195,2 +186,22 @@\n-            return buffer;\n-        } while (true);\n+        }\n+        if (buffer == null) {\n+            throw new IOException(\"Stream closed\");\n+        }\n+        return buffer;\n+    }\n+\n+    \/**\n+     * Returns the internal buffer, allocating it if empty.\n+     * @throws IOException if the stream is closed (buf is null)\n+     *\/\n+    private byte[] getBufIfOpen() throws IOException {\n+        return getBufIfOpen(true);\n+    }\n+\n+    \/**\n+     * Throws IOException if the stream is closed (buf is null).\n+     *\/\n+    private void ensureOpen() throws IOException {\n+        if (buf == null) {\n+            throw new IOException(\"Stream closed\");\n+        }\n@@ -228,3 +239,1 @@\n-        this.size = size;\n-        \/\/ keep using monitors and initializing buf when BufferedInputStream is sub-classed\n-        \/\/ for compatibility\n+        initialSize = size;\n@@ -232,0 +241,1 @@\n+            \/\/ use internal lock and lazily create buffer when not subclassed\n@@ -235,0 +245,1 @@\n+            \/\/ use monitors and eagerly create buffer when subclassed\n@@ -332,0 +343,1 @@\n+            int size = Math.max(getBufIfOpen(false).length, initialSize);\n@@ -399,1 +411,1 @@\n-        getInIfOpen(); \/\/ Check for closed stream\n+        ensureOpen();\n@@ -446,1 +458,1 @@\n-        InputStream input = getInIfOpen();\/\/ Check for closed stream\n+        ensureOpen();\n@@ -455,1 +467,1 @@\n-                return input.skip(n);\n+                return getInIfOpen().skip(n);\n@@ -569,1 +581,1 @@\n-        getInIfOpen(); \/\/ Cause exception if closed\n+        ensureOpen();\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":45,"deletions":33,"binary":false,"changes":78,"status":"modified"}]}