{"files":[{"patch":"@@ -70,0 +70,2 @@\n+    private static final byte[] EMPTY = new byte[0];\n+\n@@ -157,0 +159,2 @@\n+    private final int size;\n+\n@@ -169,2 +173,3 @@\n-     * Check to make sure that buffer has not been nulled out due to\n-     * close; if not return it;\n+     * Return the buffer if already allocated, or allocate one, or throw {@link IOException} if this stream is closed.\n+     * If a caller simply wants to ensure whether this BufferedInputStream is open\n+     * they should call {@link #getInIfOpen()} instead.\n@@ -176,0 +181,3 @@\n+        if (buffer == EMPTY) {\n+            buf = buffer = new byte[size];\n+        }\n@@ -208,3 +216,3 @@\n-        buf = new byte[size];\n-\n-        \/\/ use monitors when BufferedInputStream is sub-classed\n+        this.size = size;\n+        \/\/ keep using monitors and initializing buf when BufferedInputStream is sub-classed\n+        \/\/ for compatibility\n@@ -213,0 +221,1 @@\n+            buf = EMPTY;\n@@ -215,0 +224,1 @@\n+            buf = new byte[size];\n@@ -310,1 +320,1 @@\n-            if (len >= getBufIfOpen().length && markpos == -1) {\n+            if (len >= size && markpos == -1) {\n@@ -377,1 +387,1 @@\n-        getBufIfOpen(); \/\/ Check for closed stream\n+        getInIfOpen(); \/\/ Check for closed stream\n@@ -424,1 +434,1 @@\n-        getBufIfOpen(); \/\/ Check for closed stream\n+        InputStream input = getInIfOpen();\/\/ Check for closed stream\n@@ -433,1 +443,1 @@\n-                return getInIfOpen().skip(n);\n+                return input.skip(n);\n@@ -547,1 +557,1 @@\n-        getBufIfOpen(); \/\/ Cause exception if closed\n+        getInIfOpen(); \/\/ Cause exception if closed\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"}]}