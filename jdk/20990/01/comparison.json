{"files":[{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Type.UnknownType;\n@@ -411,3 +410,0 @@\n-        \/\/ Create the unknown type\n-        unknownType = new UnknownType();\n-\n@@ -478,2 +474,2 @@\n-        unknownSymbol.members_field = new Scope.ErrorScope(unknownSymbol);\n-        unknownSymbol.type = unknownType;\n+        \/\/ Create the unknown type\n+        unknownType = new ErrorType(unknownSymbol, Type.noType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2411,24 +2411,0 @@\n-    public static class UnknownType extends Type {\n-\n-        public UnknownType() {\n-            \/\/ Unknown is a synthesized internal type, so it cannot be\n-            \/\/ annotated.\n-            super(null, List.nil());\n-        }\n-\n-        @Override\n-        public TypeTag getTag() {\n-            return UNKNOWN;\n-        }\n-\n-        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-        public <R, P> R accept(TypeVisitor<R, P> v, P p) {\n-            return v.visitUnknown(this, p);\n-        }\n-\n-        @Override\n-        public boolean isPartial() {\n-            return true;\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -124,4 +124,0 @@\n-    \/** The tag of an unknown type\n-     *\/\n-    UNKNOWN,\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeTag.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1219,1 +1219,1 @@\n-                if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {\n+                if (t == s || t.qtype == s || s.hasTag(ERROR)) {\n@@ -1469,1 +1469,1 @@\n-                if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {\n+                if (t == s || t.qtype == s || s.hasTag(ERROR)) {\n@@ -2425,1 +2425,1 @@\n-                             NONE, ERROR, UNKNOWN, UNDETVAR, UNINITIALIZED_THIS,\n+                             NONE, ERROR, UNDETVAR, UNINITIALIZED_THIS,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @bug 8262891 8268333 8268896 8269802 8269808 8270151 8269113 8277864 8290709\n+ * @bug 8262891 8268333 8268896 8269802 8269808 8270151 8269113 8277864 8290709 8339296\n@@ -120,0 +120,3 @@\n+        assertEquals(0, nestedSwitchesInArgumentPosition(1));\n+        assertEquals(1, nestedSwitchesInArgumentPosition(new R(1)));\n+        assertEquals(5, nestedSwitchesInArgumentPosition(new R(new R(\"hello\"))));\n@@ -752,0 +755,18 @@\n+    int nestedSwitchesInArgumentPosition(Object o1) {\n+        return id(switch (o1) {\n+            case R(var o2) -> switch (o2) {\n+                case R(String s) -> s;\n+                default -> \"n\";\n+            };\n+            default -> \"\";\n+        });\n+    }\n+\n+    int id(String s) {\n+        return s.length();\n+    }\n+\n+    int id(int i) {\n+        return i;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8339296\n+ * @summary Verify that the UnknownType behaves as an erroneous type\n+ * @library \/tools\/lib\/types\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ * @build TypeHarness\n+ * @run main UnknownTypeTest\n+ *\/\n+\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.code.Type.UnionClassType;\n+import com.sun.tools.javac.util.List;\n+import java.util.Objects;\n+\n+public class UnknownTypeTest extends TypeHarness {\n+\n+    private final Type error;\n+    private final Type unknown;\n+    private final Type[] testTypes;\n+    private final Operation[] testOperations;\n+\n+    UnknownTypeTest() {\n+        Symtab syms = Symtab.instance(context);\n+        error = syms.errType;\n+        unknown = syms.unknownType;\n+        testTypes = new Type[] {\n+            syms.objectType,\n+            syms.errType,\n+            syms.unknownType,\n+            new TypeVar(syms.unknownSymbol, syms.objectType, syms.objectType),\n+            types.makeIntersectionType(List.of(syms.annotationType, syms.stringType)),\n+            new UnionClassType((Type.ClassType) syms.annotationType, List.of(syms.stringType)),\n+            syms.intType,\n+            types.makeArrayType(syms.stringType)\n+        };\n+        testOperations = new Operation[] {\n+            types::containedBy,\n+            types::containsType,\n+            types::isAssignable,\n+            types::isCastable,\n+            types::isConvertible,\n+            types::isSameType,\n+            types::isSubtype,\n+            types::isSuperType,\n+            types::isUnconditionallyExact,\n+            (t1, _) -> types.isArray(t1),\n+            (t1, _) -> types.isDerivedRaw(t1),\n+            (t1, _) -> types.isReifiable(t1),\n+            (t1, _) -> types.isUnbounded(t1),\n+            (t1, _) -> types.boxedTypeOrType(t1),\n+            (t1, _) -> types.unboxedType(t1),\n+            (t1, _) -> types.unboxedTypeOrType(t1),\n+        };\n+    }\n+\n+    void test(Type[] testTypes, Operation[] testOperations) {\n+        for (int typeIndex = 0; typeIndex < testTypes.length ; typeIndex++) {\n+            for (int operationIndex = 0; operationIndex < testOperations.length ; operationIndex++) {\n+                Object expected;\n+                Object actual;\n+                expected = testOperations[operationIndex].run(error, testTypes[typeIndex]);\n+                actual = testOperations[operationIndex].run(unknown, testTypes[typeIndex]);\n+                checkEquals(\"Type index: \" + typeIndex + \", operationIndex: \" + operationIndex + \", unknown in the first position\", expected, actual);\n+                expected = testOperations[operationIndex].run(testTypes[typeIndex], error);\n+                actual = testOperations[operationIndex].run(testTypes[typeIndex], unknown);\n+                checkEquals(\"Type index: \" + typeIndex + \", operationIndex: \" + operationIndex + \", unknown in the second position\", expected, actual);\n+            }\n+        }\n+    }\n+\n+    void checkEquals(String message, Object expected, Object actual) {\n+        boolean matches;\n+\n+        if (expected instanceof Type t1 && actual instanceof Type t2) {\n+            matches = types.isSameType(t1, t2);\n+        } else {\n+            matches = Objects.equals(expected, actual);\n+        }\n+\n+        if (!matches) {\n+            throw new AssertionError(\"Unexpected outcome: \" + actual +\n+                                     \", expected: \" + expected +\n+                                     \", for test: \" + message);\n+        }\n+    }\n+\n+    void runTests() {\n+        test(testTypes, testOperations);\n+    }\n+\n+    public static void main(String[] args) {\n+        new UnknownTypeTest().runTests();\n+    }\n+\n+    interface Operation {\n+        public Object run(Type t1, Type t2);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/types\/UnknownTypeTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}