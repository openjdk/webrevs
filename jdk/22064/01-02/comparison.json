{"files":[{"patch":"@@ -1617,1 +1617,1 @@\n-  macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \\\n+  macro(_contextClassLoader_offset, k, \"contextClassLoader\", classloader_signature, false); \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -437,3 +437,0 @@\n-  template(context_name,                              \"context\")                                  \\\n-  template(contextClassLoader_name,                   \"contextClassLoader\")                       \\\n-  template(getClassContext_name,                      \"getClassContext\")                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -329,6 +329,0 @@\n-\/*\n- * java.lang.SecurityManager\n- *\/\n-JNIEXPORT jobjectArray JNICALL\n-JVM_GetClassContext(JNIEnv *env);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3058,40 +3058,0 @@\n-\/\/ java.lang.SecurityManager \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))\n-  ResourceMark rm(THREAD);\n-  JvmtiVMObjectAllocEventCollector oam;\n-  vframeStream vfst(thread);\n-\n-  if (vmClasses::reflect_CallerSensitive_klass() != nullptr) {\n-    \/\/ This must only be called from SecurityManager.getClassContext\n-    \/\/ Also this?\n-    Method* m = vfst.method();\n-    if (!(m->method_holder() == vmClasses::SecurityManager_klass() &&\n-          m->name()          == vmSymbols::getClassContext_name() &&\n-          m->signature()     == vmSymbols::void_class_array_signature())) {\n-      THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), \"JVM_GetClassContext must only be called from SecurityManager.getClassContext\");\n-    }\n-  }\n-\n-  \/\/ Collect method holders\n-  GrowableArray<Klass*>* klass_array = new GrowableArray<Klass*>();\n-  for (; !vfst.at_end(); vfst.security_next()) {\n-    Method* m = vfst.method();\n-    \/\/ Native frames are not returned\n-    if (!m->is_ignored_by_security_stack_walk() && !m->is_native()) {\n-      Klass* holder = m->method_holder();\n-      assert(holder->is_klass(), \"just checking\");\n-      klass_array->append(holder);\n-    }\n-  }\n-\n-  \/\/ Create result array of type [Ljava\/lang\/Class;\n-  objArrayOop result = oopFactory::new_objArray(vmClasses::Class_klass(), klass_array->length(), CHECK_NULL);\n-  \/\/ Fill in mirrors corresponding to method holders\n-  for (int i = 0; i < klass_array->length(); i++) {\n-    result->obj_at_put(i, klass_array->at(i)->java_mirror());\n-  }\n-\n-  return (jobjectArray) JNIHandles::make_local(THREAD, result);\n-JVM_END\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"}]}