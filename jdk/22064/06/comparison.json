{"files":[{"patch":"@@ -173,3 +173,1 @@\n-  Klass* k = SystemDictionary::find_instance_or_array_klass(current, name,\n-                                                            h_loader,\n-                                                            Handle());\n+  Klass* k = SystemDictionary::find_instance_or_array_klass(current, name, h_loader);\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-      assert(SystemDictionary::resolve_or_null(ik->name(), loader, pd, THREAD) == nullptr,\n+      assert(SystemDictionary::resolve_or_null(ik->name(), loader, THREAD) == nullptr,\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -615,2 +615,1 @@\n-  Handle protection_domain;\n-  Klass* klass = SystemDictionary::resolve_or_fail(class_name_symbol, class_loader, protection_domain, true, CHECK);\n+  Klass* klass = SystemDictionary::resolve_or_fail(class_name_symbol, class_loader, true, CHECK);\n@@ -784,2 +783,1 @@\n-  Handle protection_domain;\n-  return SystemDictionary::find_instance_klass(current, class_name_symbol, class_loader, protection_domain);\n+  return SystemDictionary::find_instance_klass(current, class_name_symbol, class_loader);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2439,1 +2439,1 @@\n-  InstanceKlass* k = SystemDictionary::find_instance_klass(current, klass_name, Handle(), Handle());\n+  InstanceKlass* k = SystemDictionary::find_instance_klass(current, klass_name, Handle());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -465,1 +465,0 @@\n-  Handle domain;\n@@ -468,1 +467,0 @@\n-    domain = Handle(current, accessing_klass->protection_domain());\n@@ -472,1 +470,1 @@\n-                         SystemDictionary::find_instance_or_array_klass(current, sym, loader, domain) :\n+                         SystemDictionary::find_instance_or_array_klass(current, sym, loader) :\n@@ -1614,2 +1612,1 @@\n-  \/\/ The very first entry is the InstanceKlass of the root method of the current compilation in order to get the right\n-  \/\/ protection domain to load subsequent classes during replay compilation.\n+  \/\/ The very first entry is the InstanceKlass of the root method of the current compilation.\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -117,2 +117,0 @@\n-  Handle  _protection_domain;\n-  bool    _protection_domain_initialized;\n@@ -147,2 +145,0 @@\n-    _protection_domain = Handle();\n-    _protection_domain_initialized = false;\n@@ -561,1 +557,1 @@\n-        k = SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);\n+        k = SystemDictionary::resolve_or_fail(klass_name, _loader, true, THREAD);\n@@ -582,1 +578,1 @@\n-    return SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);\n+    return SystemDictionary::resolve_or_fail(klass_name, _loader, true, THREAD);\n@@ -899,12 +895,0 @@\n-    if (_version >= 1) {\n-      if (!_protection_domain_initialized && k != nullptr) {\n-        assert(_protection_domain() == nullptr, \"must be uninitialized\");\n-        \/\/ The first entry is the holder class of the method for which a replay compilation is requested.\n-        \/\/ Use the same protection domain to load all subsequent classes in order to resolve all classes\n-        \/\/ in signatures of inlinees. This ensures that inlining can be done as stated in the replay file.\n-        _protection_domain = Handle(_thread, k->protection_domain());\n-      }\n-\n-      _protection_domain_initialized = true;\n-    }\n-\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -825,1 +825,0 @@\n-                                                         _protection_domain,\n@@ -5694,1 +5693,0 @@\n-                                                               _protection_domain,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,4 +29,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/protectionDomainCache.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n@@ -38,9 +34,1 @@\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/method.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"oops\/oopHandle.inline.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/javaCalls.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n@@ -48,1 +36,1 @@\n-#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ostream.hpp\"\n@@ -72,1 +60,1 @@\n-  return value->instance_klass()->name()->identity_hash();\n+  return value->name()->identity_hash();\n@@ -80,1 +68,0 @@\n-  delete value; \/\/ Call DictionaryEntry destructor\n@@ -84,16 +71,0 @@\n-DictionaryEntry::DictionaryEntry(InstanceKlass* klass) : _instance_klass(klass) {\n-  release_set_package_access_cache(nullptr);\n-}\n-\n-DictionaryEntry::~DictionaryEntry() {\n-  \/\/ avoid recursion when deleting linked list\n-  \/\/ package_access_cache is accessed during a safepoint.\n-  \/\/ This doesn't require a lock because nothing is reading this\n-  \/\/ entry anymore.  The ClassLoader is dead.\n-  while (package_access_cache_acquire() != nullptr) {\n-    ProtectionDomainEntry* to_delete = package_access_cache_acquire();\n-    release_set_package_access_cache(to_delete->next_acquire());\n-    delete to_delete;\n-  }\n-}\n-\n@@ -111,76 +82,0 @@\n-bool DictionaryEntry::has_package_access_been_granted(Handle protection_domain) {\n-  return protection_domain() == nullptr || !java_lang_System::allow_security_manager()\n-        ? true\n-        : is_in_package_access_cache(protection_domain());\n-}\n-\n-\/\/ Reading the package_access_cache on each DictionaryEntry is lock free and cannot safepoint.\n-\/\/ Adding and deleting entries is under the SystemDictionary_lock\n-\/\/ Deleting unloaded entries on ClassLoaderData for dictionaries that are not unloaded\n-\/\/ is a three step process:\n-\/\/     moving the entries to a separate list, handshake to wait for\n-\/\/     readers to complete (see NSV here), and then actually deleting the entries.\n-\/\/ Deleting entries is done by the ServiceThread when triggered by class unloading.\n-\n-bool DictionaryEntry::is_in_package_access_cache(oop protection_domain) const {\n-  assert(Thread::current()->is_Java_thread() || SafepointSynchronize::is_at_safepoint(),\n-         \"can only be called by a JavaThread or at safepoint\");\n-  \/\/ This cannot safepoint while reading the protection domain set.\n-  NoSafepointVerifier nsv;\n-#ifdef ASSERT\n-  if (protection_domain == instance_klass()->protection_domain()) {\n-    \/\/ Ensure this doesn't show up in the package_access_cache (invariant)\n-    bool in_package_access_cache = false;\n-    for (ProtectionDomainEntry* current = package_access_cache_acquire();\n-                                current != nullptr;\n-                                current = current->next_acquire()) {\n-      if (current->object_no_keepalive() == protection_domain) {\n-        in_package_access_cache = true;\n-        break;\n-      }\n-    }\n-    if (in_package_access_cache) {\n-      assert(false, \"A klass's protection domain should not show up \"\n-                    \"in its sys. dict. PD set\");\n-    }\n-  }\n-#endif \/* ASSERT *\/\n-\n-  if (protection_domain == instance_klass()->protection_domain()) {\n-    \/\/ Succeeds trivially\n-    return true;\n-  }\n-\n-  for (ProtectionDomainEntry* current = package_access_cache_acquire();\n-                              current != nullptr;\n-                              current = current->next_acquire()) {\n-    if (current->object_no_keepalive() == protection_domain) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-void DictionaryEntry::add_to_package_access_cache(ClassLoaderData* loader_data, Handle protection_domain) {\n-  assert_lock_strong(SystemDictionary_lock);\n-  if (!is_in_package_access_cache(protection_domain())) {\n-    WeakHandle obj = ProtectionDomainCacheTable::add_if_absent(protection_domain);\n-    \/\/ Additions and deletions hold the SystemDictionary_lock, readers are lock-free\n-    ProtectionDomainEntry* new_head = new ProtectionDomainEntry(obj, _package_access_cache);\n-    release_set_package_access_cache(new_head);\n-  }\n-  LogTarget(Trace, protectiondomain) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    ls.print(\"adding protection domain that can access class %s\", instance_klass()->name()->as_C_string());\n-    ls.print(\" class loader: \");\n-    loader_data->class_loader()->print_value_on(&ls);\n-    ls.print(\" protection domain: \");\n-    protection_domain->print_value_on(&ls);\n-    ls.print(\" \");\n-    print_count(&ls);\n-    ls.cr();\n-  }\n-}\n-\n@@ -189,2 +84,2 @@\n-  auto doit = [&] (DictionaryEntry** value) {\n-    InstanceKlass* k = (*value)->instance_klass();\n+  auto doit = [&] (InstanceKlass** value) {\n+    InstanceKlass* k = (*value);\n@@ -202,2 +97,2 @@\n-  auto all_doit = [&] (DictionaryEntry** value) {\n-    InstanceKlass* k = (*value)->instance_klass();\n+  auto all_doit = [&] (InstanceKlass** value) {\n+    InstanceKlass* k = (*value);\n@@ -215,3 +110,2 @@\n-  auto push = [&] (DictionaryEntry** value) {\n-    InstanceKlass** k = (*value)->instance_klass_addr();\n-    it->push(k);\n+  auto push = [&] (InstanceKlass** value) {\n+    it->push(value);\n@@ -231,3 +125,3 @@\n-  bool equals(DictionaryEntry** value) {\n-    DictionaryEntry *entry = *value;\n-    return (entry->instance_klass()->name() == _name);\n+  bool equals(InstanceKlass** value) {\n+    InstanceKlass* entry = *value;\n+    return (entry->name() == _name);\n@@ -235,1 +129,1 @@\n-  bool is_dead(DictionaryEntry** value) {\n+  bool is_dead(InstanceKlass** value) {\n@@ -242,1 +136,1 @@\n-                           InstanceKlass* obj) {\n+                           InstanceKlass* klass) {\n@@ -244,2 +138,2 @@\n-  assert(obj != nullptr, \"adding nullptr obj\");\n-  assert(obj->name() == class_name, \"sanity check on name\");\n+  assert(klass != nullptr, \"adding nullptr obj\");\n+  assert(klass->name() == class_name, \"sanity check on name\");\n@@ -247,1 +141,0 @@\n-  DictionaryEntry* entry = new DictionaryEntry(obj);\n@@ -250,1 +143,1 @@\n-  bool created = _table->insert(current, lookup, entry, &needs_rehashing, &clean_hint);\n+  bool created = _table->insert(current, lookup, klass, &needs_rehashing, &clean_hint);\n@@ -280,2 +173,1 @@\n-DictionaryEntry* Dictionary::get_entry(Thread* current,\n-                                       Symbol* class_name) {\n+InstanceKlass* Dictionary::find_class(Thread* current, Symbol* class_name) {\n@@ -283,2 +175,2 @@\n-  DictionaryEntry* result = nullptr;\n-  auto get = [&] (DictionaryEntry** value) {\n+  InstanceKlass* result = nullptr;\n+  auto get = [&] (InstanceKlass** value) {\n@@ -294,131 +186,0 @@\n-\/\/ If SecurityManager is allowed, return the class ONLY IF the protection_domain has been\n-\/\/ granted access to this class by a previous call to Dictionary::check_package_access()\n-InstanceKlass* Dictionary::find(Thread* current, Symbol* name,\n-                                Handle protection_domain) {\n-  NoSafepointVerifier nsv;\n-\n-  DictionaryEntry* entry = get_entry(current, name);\n-  if (entry != nullptr && entry->has_package_access_been_granted(protection_domain)) {\n-    return entry->instance_klass();\n-  } else {\n-    return nullptr;\n-  }\n-}\n-\n-InstanceKlass* Dictionary::find_class(Thread* current,\n-                                      Symbol* name) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  DictionaryEntry* entry = get_entry(current, name);\n-  return (entry != nullptr) ? entry->instance_klass() : nullptr;\n-}\n-\n-void Dictionary::add_to_package_access_cache(JavaThread* current,\n-                                             InstanceKlass* klass,\n-                                             Handle protection_domain) {\n-  assert(java_lang_System::allow_security_manager(), \"only needed if security manager allowed\");\n-  Symbol*  klass_name = klass->name();\n-  DictionaryEntry* entry = get_entry(current, klass_name);\n-\n-  assert(entry != nullptr,\"entry must be present, we just created it\");\n-  assert(protection_domain() != nullptr,\n-         \"real protection domain should be present\");\n-\n-  entry->add_to_package_access_cache(loader_data(), protection_domain);\n-\n-#ifdef ASSERT\n-  assert(loader_data() != ClassLoaderData::the_null_class_loader_data(), \"doesn't make sense\");\n-#endif\n-\n-  assert(entry->is_in_package_access_cache(protection_domain()),\n-         \"now protection domain should be present\");\n-}\n-\n-inline bool Dictionary::is_in_package_access_cache(JavaThread* current,\n-                                            Symbol* name,\n-                                            Handle protection_domain) {\n-  DictionaryEntry* entry = get_entry(current, name);\n-  return entry->has_package_access_been_granted(protection_domain);\n-}\n-\n-void Dictionary::check_package_access(InstanceKlass* klass,\n-                                      Handle class_loader,\n-                                      Handle protection_domain,\n-                                      TRAPS) {\n-\n-  assert(class_loader() != nullptr, \"Should not call this\");\n-  assert(protection_domain() != nullptr, \"Should not call this\");\n-}\n-\n-\/\/ During class loading we may have cached a protection domain that has\n-\/\/ since been unreferenced, so this entry should be cleared.\n-void Dictionary::remove_from_package_access_cache(GrowableArray<ProtectionDomainEntry*>* delete_list) {\n-  assert(Thread::current()->is_Java_thread(), \"only called by JavaThread\");\n-  assert_lock_strong(SystemDictionary_lock);\n-  assert(!loader_data()->has_class_mirror_holder(), \"cld should have a ClassLoader holder not a Class holder\");\n-\n-  if (loader_data()->is_the_null_class_loader_data()) {\n-    \/\/ Classes in the boot loader are not loaded with protection domains\n-    return;\n-  }\n-\n-  auto clean_entries = [&] (DictionaryEntry** value) {\n-      DictionaryEntry* probe = *value;\n-      Klass* e = probe->instance_klass();\n-\n-      ProtectionDomainEntry* current = probe->package_access_cache_acquire();\n-      ProtectionDomainEntry* prev = nullptr;\n-      while (current != nullptr) {\n-        if (current->object_no_keepalive() == nullptr) {\n-          LogTarget(Debug, protectiondomain) lt;\n-          if (lt.is_enabled()) {\n-            ResourceMark rm;\n-            \/\/ Print out trace information\n-            LogStream ls(lt);\n-            ls.print_cr(\"PD in set is not alive:\");\n-            ls.print(\"class loader: \"); _loader_data->class_loader()->print_value_on(&ls);\n-            ls.print(\" loading: \"); probe->instance_klass()->print_value_on(&ls);\n-            ls.cr();\n-          }\n-          if (probe->package_access_cache_acquire() == current) {\n-            probe->release_set_package_access_cache(current->next_acquire());\n-          } else {\n-            assert(prev != nullptr, \"should be set by alive entry\");\n-            prev->release_set_next(current->next_acquire());\n-          }\n-          \/\/ Mark current for deletion but in the meantime it can still be\n-          \/\/ traversed.\n-          delete_list->push(current);\n-          current = current->next_acquire();\n-        } else {\n-          prev = current;\n-          current = current->next_acquire();\n-        }\n-      }\n-      return true;\n-  };\n-\n-  _table->do_scan(Thread::current(), clean_entries);\n-}\n-\n-void DictionaryEntry::verify_package_access_cache() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must only be called as safepoint\");\n-  for (ProtectionDomainEntry* current = package_access_cache_acquire(); \/\/ accessed at a safepoint\n-                              current != nullptr;\n-                              current = current->next_acquire()) {\n-    guarantee(oopDesc::is_oop_or_null(current->object_no_keepalive()), \"Invalid oop\");\n-  }\n-}\n-\n-void DictionaryEntry::print_count(outputStream *st) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  int count = 0;\n-  for (ProtectionDomainEntry* current = package_access_cache_acquire();\n-                              current != nullptr;\n-                              current = current->next_acquire()) {\n-    count++;\n-  }\n-  st->print(\"pd set count = #%d\", count);\n-}\n-\n-\/\/ ----------------------------------------------------------------------------\n-\n@@ -438,3 +199,2 @@\n-  auto printer = [&] (DictionaryEntry** entry) {\n-    DictionaryEntry* probe = *entry;\n-    Klass* e = probe->instance_klass();\n+  auto printer = [&] (InstanceKlass** entry) {\n+    InstanceKlass* e = *entry;\n@@ -451,1 +211,0 @@\n-      probe->print_count(st);\n@@ -465,8 +224,0 @@\n-void DictionaryEntry::verify() {\n-  Klass* e = instance_klass();\n-  guarantee(e->is_instance_klass(),\n-                          \"Verify of dictionary failed\");\n-  e->verify();\n-  verify_package_access_cache();\n-}\n-\n@@ -483,1 +234,1 @@\n-  auto verifier = [&] (DictionaryEntry** val) {\n+  auto verifier = [&] (InstanceKlass** val) {\n@@ -493,1 +244,1 @@\n-  auto sz = [&] (DictionaryEntry** val) {\n+  auto sz = [&] (InstanceKlass** val) {\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":24,"deletions":273,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oop.hpp\"\n-#include \"oops\/oopHandle.hpp\"\n@@ -32,1 +29,0 @@\n-#include \"utilities\/ostream.hpp\"\n@@ -34,3 +30,3 @@\n-class DictionaryEntry;\n-class ProtectionDomainEntry;\n-template <typename T> class GrowableArray;\n+class ClassLoaderData;\n+class InstanceKlass;\n+class outputStream;\n@@ -41,2 +37,0 @@\n-class DictionaryEntry;\n-\n@@ -48,1 +42,1 @@\n-    using Value = DictionaryEntry*;\n+    using Value = InstanceKlass*;\n@@ -60,1 +54,0 @@\n-  DictionaryEntry* get_entry(Thread* current, Symbol* name);\n@@ -76,11 +69,0 @@\n-  void remove_from_package_access_cache(GrowableArray<ProtectionDomainEntry*>* delete_list);\n-\n-  InstanceKlass* find(Thread* current, Symbol* name, Handle protection_domain);\n-\n-  \/\/ May make Java upcalls to ClassLoader.checkPackageAccess() when a SecurityManager\n-  \/\/ is installed.\n-  void check_package_access(InstanceKlass* klass,\n-                            Handle class_loader,\n-                            Handle protection_domain,\n-                            TRAPS);\n-\n@@ -92,36 +74,0 @@\n-\n- private:\n-  bool is_in_package_access_cache(JavaThread* current, Symbol* name,\n-                                  Handle protection_domain);\n-  void add_to_package_access_cache(JavaThread* current, InstanceKlass* klass,\n-                                   Handle protection_domain);\n-};\n-\n-class DictionaryEntry : public CHeapObj<mtClass> {\n- private:\n-  InstanceKlass* _instance_klass;\n-\n-  \/\/ A cache of the ProtectionDomains that have been granted\n-  \/\/ access to the package of _instance_klass by Java up-calls to\n-  \/\/ ClassLoader.checkPackageAccess(). See Dictionary::check_package_access().\n-  \/\/\n-  \/\/ We use a cache to avoid repeat Java up-calls that can be expensive.\n-  ProtectionDomainEntry* volatile _package_access_cache;\n-\n- public:\n-  DictionaryEntry(InstanceKlass* instance_klass);\n-  ~DictionaryEntry();\n-\n-  bool is_in_package_access_cache(oop protection_domain) const;\n-  void add_to_package_access_cache(ClassLoaderData* loader_data, Handle protection_domain);\n-  inline bool has_package_access_been_granted(Handle protection_domain);\n-  void verify_package_access_cache();\n-\n-  InstanceKlass* instance_klass() const { return _instance_klass; }\n-  InstanceKlass** instance_klass_addr() { return &_instance_klass; }\n-\n-  ProtectionDomainEntry* package_access_cache_acquire() const            { return Atomic::load_acquire(&_package_access_cache); }\n-  void release_set_package_access_cache(ProtectionDomainEntry* entry)    { Atomic::release_store(&_package_access_cache, entry); }\n-\n-  void print_count(outputStream *st);\n-  void verify();\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":4,"deletions":58,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1649,1 +1649,1 @@\n-  macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \\\n+  macro(_contextClassLoader_offset, k, \"contextClassLoader\", classloader_signature, false); \\\n@@ -4724,41 +4724,0 @@\n-\/\/ Support for java_security_AccessControlContext\n-\n-int java_security_AccessControlContext::_context_offset;\n-int java_security_AccessControlContext::_privilegedContext_offset;\n-int java_security_AccessControlContext::_isPrivileged_offset;\n-int java_security_AccessControlContext::_isAuthorized_offset;\n-\n-#define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \\\n-  macro(_context_offset,           k, \"context\",      protectiondomain_signature, false); \\\n-  macro(_privilegedContext_offset, k, \"privilegedContext\", accesscontrolcontext_signature, false); \\\n-  macro(_isPrivileged_offset,      k, \"isPrivileged\", bool_signature, false); \\\n-  macro(_isAuthorized_offset,      k, \"isAuthorized\", bool_signature, false)\n-\n-void java_security_AccessControlContext::compute_offsets() {\n-  assert(_isPrivileged_offset == 0, \"offsets should be initialized only once\");\n-  InstanceKlass* k = vmClasses::AccessControlContext_klass();\n-  ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {\n-  ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {\n-  assert(_isPrivileged_offset != 0, \"offsets should have been initialized\");\n-  assert(_isAuthorized_offset != 0, \"offsets should have been initialized\");\n-  \/\/ Ensure klass is initialized\n-  vmClasses::AccessControlContext_klass()->initialize(CHECK_NULL);\n-  \/\/ Allocate result\n-  oop result = vmClasses::AccessControlContext_klass()->allocate_instance(CHECK_NULL);\n-  \/\/ Fill in values\n-  result->obj_field_put(_context_offset, context());\n-  result->obj_field_put(_privilegedContext_offset, privileged_context());\n-  result->bool_field_put(_isPrivileged_offset, isPrivileged);\n-  result->bool_field_put(_isAuthorized_offset, true);\n-  return result;\n-}\n-\n-\n@@ -4901,11 +4860,0 @@\n-\/\/ This field tells us that a security manager can never be installed so we\n-\/\/ can completely skip populating the ProtectionDomainCacheTable.\n-bool java_lang_System::allow_security_manager() {\n-  return false;\n-}\n-\n-\/\/ This field tells us that a security manager is installed.\n-bool java_lang_System::has_security_manager() {\n-  return false;\n-}\n-\n@@ -5426,1 +5374,0 @@\n-  f(java_security_AccessControlContext) \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":54,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1483,21 +1483,0 @@\n-\/\/ Interface to java.security.AccessControlContext objects\n-\n-class java_security_AccessControlContext: AllStatic {\n- private:\n-  \/\/ Note that for this class the layout changed between JDK1.2 and JDK1.3,\n-  \/\/ so we compute the offsets at startup rather than hard-wiring them.\n-  static int _context_offset;\n-  static int _privilegedContext_offset;\n-  static int _isPrivileged_offset;\n-  static int _isAuthorized_offset;\n-\n-  static void compute_offsets();\n- public:\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-  static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);\n-\n-  \/\/ Debugging\/initialization\n-  friend class JavaClasses;\n-};\n-\n-\n@@ -1560,3 +1539,0 @@\n-  static int _static_security_offset;\n-  static int _static_allow_security_offset;\n-  static int _static_never_offset;\n@@ -1568,2 +1544,0 @@\n-  static bool allow_security_manager();\n-  static bool has_security_manager();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"classfile\/dictionary.hpp\"\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/protectionDomainCache.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"oops\/weakHandle.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n-\n-unsigned int ProtectionDomainCacheTable::compute_hash(const WeakHandle& protection_domain) {\n-  \/\/ The protection domain in the hash computation is passed from a Handle so cannot resolve to null.\n-  assert(protection_domain.peek() != nullptr, \"Must be live\");\n-  return (unsigned int)(protection_domain.resolve()->identity_hash());\n-}\n-\n-bool ProtectionDomainCacheTable::equals(const WeakHandle& protection_domain1, const WeakHandle& protection_domain2) {\n-  return protection_domain1.peek() == protection_domain2.peek();\n-}\n-\n-\/\/ WeakHandle is both the key and the value.  We need it as the key to compare the oops that each point to\n-\/\/ for equality.  We need it as the value to return the one that already exists to link in the DictionaryEntry.\n-using InternalProtectionDomainCacheTable = ResourceHashtable<WeakHandle, WeakHandle, 1009, AnyObj::C_HEAP, mtClass,\n-                  ProtectionDomainCacheTable::compute_hash,\n-                  ProtectionDomainCacheTable::equals>;\n-static InternalProtectionDomainCacheTable* _pd_cache_table;\n-\n-bool ProtectionDomainCacheTable::_dead_entries = false;\n-int  ProtectionDomainCacheTable::_total_oops_removed = 0;\n-\n-void ProtectionDomainCacheTable::initialize(){\n-  _pd_cache_table = new (mtClass) InternalProtectionDomainCacheTable();\n-}\n-void ProtectionDomainCacheTable::trigger_cleanup() {\n-  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n-  _dead_entries = true;\n-  Service_lock->notify_all();\n-}\n-\n-class CleanProtectionDomainEntries : public CLDClosure {\n-  GrowableArray<ProtectionDomainEntry*>* _delete_list;\n- public:\n-  CleanProtectionDomainEntries(GrowableArray<ProtectionDomainEntry*>* delete_list) :\n-                               _delete_list(delete_list) {}\n-\n-  void do_cld(ClassLoaderData* data) {\n-    Dictionary* dictionary = data->dictionary();\n-    if (dictionary != nullptr) {\n-      dictionary->remove_from_package_access_cache(_delete_list);\n-    }\n-  }\n-};\n-\n-static GrowableArray<ProtectionDomainEntry*>* _delete_list = nullptr;\n-\n-class HandshakeForPD : public HandshakeClosure {\n- public:\n-  HandshakeForPD() : HandshakeClosure(\"HandshakeForPD\") {}\n-\n-  void do_thread(Thread* thread) {\n-    log_trace(protectiondomain)(\"HandshakeForPD::do_thread: thread=\"\n-                                INTPTR_FORMAT, p2i(thread));\n-  }\n-};\n-\n-static void purge_deleted_entries() {\n-  \/\/ If there are any deleted entries, Handshake-all then they'll be\n-  \/\/ safe to remove since traversing the package_access_cache list does not stop for\n-  \/\/ safepoints and only JavaThreads will read the package_access_cache.\n-  \/\/ This is actually quite rare because the protection domain is generally associated\n-  \/\/ with the caller class and class loader, which if still alive will keep this\n-  \/\/ protection domain entry alive.\n-  if (_delete_list->length() >= 10) {\n-    HandshakeForPD hs_pd;\n-    Handshake::execute(&hs_pd);\n-\n-    for (int i = _delete_list->length() - 1; i >= 0; i--) {\n-      ProtectionDomainEntry* entry = _delete_list->at(i);\n-      _delete_list->remove_at(i);\n-      delete entry;\n-    }\n-    assert(_delete_list->length() == 0, \"should be cleared\");\n-  }\n-}\n-\n-void ProtectionDomainCacheTable::unlink() {\n-  \/\/ DictionaryEntry::_package_access_cache should be null also, so nothing to do.\n-  assert(java_lang_System::allow_security_manager(), \"should not be called otherwise\");\n-\n-  \/\/ Create a list for holding deleted entries\n-  if (_delete_list == nullptr) {\n-    _delete_list = new (mtClass)\n-                       GrowableArray<ProtectionDomainEntry*>(20, mtClass);\n-  }\n-\n-  {\n-    \/\/ First clean cached pd lists in loaded CLDs\n-    \/\/ It's unlikely, but some loaded classes in a dictionary might\n-    \/\/ point to a protection_domain that has been unloaded.\n-    \/\/ DictionaryEntry::_package_access_cache points at entries in the ProtectionDomainCacheTable.\n-    MutexLocker ml(ClassLoaderDataGraph_lock);\n-    MutexLocker mldict(SystemDictionary_lock);  \/\/ need both.\n-    CleanProtectionDomainEntries clean(_delete_list);\n-    ClassLoaderDataGraph::loaded_cld_do(&clean);\n-  }\n-\n-  \/\/ Purge any deleted entries outside of the SystemDictionary_lock.\n-  purge_deleted_entries();\n-\n-  \/\/ Reacquire the lock to remove entries from the hashtable.\n-  MutexLocker ml(SystemDictionary_lock);\n-\n-  struct Deleter {\n-    int _oops_removed;\n-    Deleter() : _oops_removed(0) {}\n-\n-    bool do_entry(WeakHandle& key, WeakHandle& value) {\n-      oop pd = value.peek();\n-      if (value.peek() == nullptr) {\n-        _oops_removed++;\n-        LogTarget(Debug, protectiondomain, table) lt;\n-        if (lt.is_enabled()) {\n-          LogStream ls(lt);\n-          ls.print_cr(\"protection domain unlinked %d\", _oops_removed);\n-        }\n-        value.release(Universe::vm_weak());\n-        return true;\n-      } else {\n-        return false;\n-      }\n-    }\n-  };\n-\n-  Deleter deleter;\n-  _pd_cache_table->unlink(&deleter);\n-\n-  _total_oops_removed += deleter._oops_removed;\n-  _dead_entries = false;\n-}\n-\n-void ProtectionDomainCacheTable::print_on(outputStream* st) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  auto printer = [&] (WeakHandle& key, WeakHandle& value) {\n-      st->print_cr(\"  protection_domain: \" PTR_FORMAT, p2i(value.peek()));\n-  };\n-  st->print_cr(\"Protection domain cache table (table_size=%d, protection domains=%d)\",\n-                _pd_cache_table->table_size(), _pd_cache_table->number_of_entries());\n-  _pd_cache_table->iterate_all(printer);\n-}\n-\n-void ProtectionDomainCacheTable::verify() {\n-  auto verifier = [&] (WeakHandle& key, WeakHandle& value) {\n-    guarantee(value.peek() == nullptr || oopDesc::is_oop(value.peek()), \"must be an oop\");\n-  };\n-  _pd_cache_table->iterate_all(verifier);\n-}\n-\n-\/\/ The object_no_keepalive() call peeks at the phantomly reachable oop without\n-\/\/ keeping it alive.  This is used for traversing DictionaryEntry::_package_access_cache.\n-oop ProtectionDomainEntry::object_no_keepalive() {\n-  return _object.peek();\n-}\n-\n-WeakHandle ProtectionDomainCacheTable::add_if_absent(Handle protection_domain) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  WeakHandle w(Universe::vm_weak(), protection_domain);\n-  bool created;\n-  WeakHandle* wk = _pd_cache_table->put_if_absent(w, w, &created);\n-  if (!created) {\n-    \/\/ delete the one created since we already had it in the table\n-    w.release(Universe::vm_weak());\n-  } else {\n-    LogTarget(Debug, protectiondomain, table) lt;\n-    if (lt.is_enabled()) {\n-      LogStream ls(lt);\n-      ls.print(\"protection domain added \");\n-      protection_domain->print_value_on(&ls);\n-      ls.cr();\n-    }\n-  }\n-  \/\/ Keep entry alive\n-  (void)wk->resolve();\n-  return *wk;\n-}\n-\n-void ProtectionDomainCacheTable::print_table_statistics(outputStream* st) {\n-  auto size = [&] (WeakHandle& key, WeakHandle& value) {\n-    \/\/ The only storage is in OopStorage for an oop\n-    return sizeof(oop);\n-  };\n-  TableStatistics ts = _pd_cache_table->statistics_calculate(size);\n-  ts.print(st, \"ProtectionDomainCacheTable\");\n-}\n-\n-int ProtectionDomainCacheTable::number_of_entries() {\n-  return _pd_cache_table->number_of_entries();\n-}\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.cpp","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_CLASSFILE_PROTECTIONDOMAINCACHE_HPP\n-#define SHARE_CLASSFILE_PROTECTIONDOMAINCACHE_HPP\n-\n-#include \"oops\/oop.hpp\"\n-#include \"oops\/weakHandle.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-\n-\/\/ The ProtectionDomainCacheTable maps all java.security.ProtectionDomain objects that are\n-\/\/ registered by DictionaryEntry::add_to_package_access_cache() to a unique WeakHandle.\n-\/\/ The amount of different protection domains used is typically magnitudes smaller\n-\/\/ than the number of system dictionary entries (loaded classes).\n-class ProtectionDomainCacheTable : public AllStatic {\n-\n-  static bool _dead_entries;\n-  static int _total_oops_removed;\n-\n-public:\n-  static void initialize();\n-  static unsigned int compute_hash(const WeakHandle& protection_domain);\n-  static bool equals(const WeakHandle& protection_domain1, const WeakHandle& protection_domain2);\n-\n-  static WeakHandle add_if_absent(Handle protection_domain);\n-  static void unlink();\n-\n-  static void print_on(outputStream* st);\n-  static void verify();\n-\n-  static bool has_work() { return _dead_entries; }\n-  static void trigger_cleanup();\n-\n-  static int removed_entries_count() { return _total_oops_removed; };\n-  static int number_of_entries();\n-  static void print_table_statistics(outputStream* st);\n-};\n-\n-\n-\/\/ This describes the linked list protection domain for each DictionaryEntry in its package_access_cache.\n-class ProtectionDomainEntry :public CHeapObj<mtClass> {\n-  WeakHandle _object;\n-  ProtectionDomainEntry* volatile _next;\n- public:\n-\n-  ProtectionDomainEntry(WeakHandle obj,\n-                        ProtectionDomainEntry* head) : _object(obj), _next(head) {}\n-\n-  ProtectionDomainEntry* next_acquire() { return Atomic::load_acquire(&_next); }\n-  void release_set_next(ProtectionDomainEntry* entry) { Atomic::release_store(&_next, entry); }\n-  oop object_no_keepalive();\n-};\n-#endif \/\/ SHARE_CLASSFILE_PROTECTIONDOMAINCACHE_HPP\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.hpp","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"classfile\/protectionDomainCache.hpp\"\n@@ -334,1 +333,1 @@\n-Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain,\n+Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader,\n@@ -336,1 +335,1 @@\n-  Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);\n+  Klass* klass = resolve_or_null(class_name, class_loader, THREAD);\n@@ -346,1 +345,1 @@\n-Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {\n+Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, TRAPS) {\n@@ -348,1 +347,1 @@\n-    return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);\n+    return resolve_array_class_or_null(class_name, class_loader, THREAD);\n@@ -356,1 +355,1 @@\n-      return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);\n+      return resolve_instance_class_or_null(name, class_loader, THREAD);\n@@ -358,1 +357,1 @@\n-      return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);\n+      return resolve_instance_class_or_null(class_name, class_loader, THREAD);\n@@ -367,1 +366,0 @@\n-                                                     Handle protection_domain,\n@@ -379,1 +377,0 @@\n-                                                         protection_domain,\n@@ -425,1 +422,0 @@\n-                                                                    Handle protection_domain,\n@@ -490,1 +486,0 @@\n-                                                     protection_domain,\n@@ -517,1 +512,1 @@\n-                                       Handle protection_domain, TRAPS) {\n+                                       TRAPS) {\n@@ -525,1 +520,0 @@\n-                                                                       protection_domain,\n@@ -591,1 +585,0 @@\n-                                                                Handle protection_domain,\n@@ -605,6 +598,2 @@\n-  \/\/ Do lookup to see if class already exists and the protection domain\n-  \/\/ has the right access.\n-  \/\/ This call uses find which checks protection domain already matches\n-  \/\/ All subsequent calls use find_class, and set loaded_class so that\n-  \/\/ before we return a result, we call out to java to check for valid protection domain.\n-  InstanceKlass* probe = dictionary->find(THREAD, name, protection_domain);\n+  \/\/ Do lookup to see if class already exists.\n+  InstanceKlass* probe = dictionary->find_class(THREAD, name);\n@@ -656,1 +645,0 @@\n-                               protection_domain,\n@@ -741,6 +729,0 @@\n-  if (protection_domain() != nullptr) {\n-    \/\/ A SecurityManager (if installed) may prevent this protection_domain from accessing loaded_class\n-    \/\/ by throwing a SecurityException.\n-    dictionary->check_package_access(loaded_class, class_loader, protection_domain, CHECK_NULL);\n-  }\n-\n@@ -764,2 +746,1 @@\n-                                                     Handle class_loader,\n-                                                     Handle protection_domain) {\n+                                                     Handle class_loader) {\n@@ -775,1 +756,1 @@\n-  return dictionary->find(current, class_name, protection_domain);\n+  return dictionary->find_class(current, class_name);\n@@ -782,2 +763,1 @@\n-                                                      Handle class_loader,\n-                                                      Handle protection_domain) {\n+                                                      Handle class_loader) {\n@@ -797,1 +777,1 @@\n-      k = SystemDictionary::find_instance_klass(current, ss.as_symbol(), class_loader, protection_domain);\n+      k = SystemDictionary::find_instance_klass(current, ss.as_symbol(), class_loader);\n@@ -803,1 +783,1 @@\n-    k = find_instance_klass(current, class_name, class_loader, protection_domain);\n+    k = find_instance_klass(current, class_name, class_loader);\n@@ -1047,2 +1027,1 @@\n-                                                     Handle class_loader,  Handle protection_domain,\n-                                                     bool is_superclass, TRAPS) {\n+                                                     Handle class_loader, bool is_superclass, TRAPS) {\n@@ -1058,1 +1037,1 @@\n-    InstanceKlass* check = find_instance_klass(THREAD, name, class_loader, protection_domain);\n+    InstanceKlass* check = find_instance_klass(THREAD, name, class_loader);\n@@ -1065,1 +1044,1 @@\n-                                                    class_loader, protection_domain, is_superclass, CHECK_false);\n+                                                    class_loader, is_superclass, CHECK_false);\n@@ -1075,2 +1054,1 @@\n-bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,\n-                                                      Handle protection_domain, TRAPS) {\n+bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader, TRAPS) {\n@@ -1086,1 +1064,1 @@\n-                                                     class_loader, protection_domain, true,\n+                                                     class_loader, true,\n@@ -1096,1 +1074,1 @@\n-    bool check_interface = check_shared_class_super_type(ik, interfaces->at(index), class_loader, protection_domain, false,\n+    bool check_interface = check_shared_class_super_type(ik, interfaces->at(index), class_loader, false,\n@@ -1114,1 +1092,1 @@\n-  Klass *s = resolve_or_fail(cn, class_loader, protection_domain, true, CHECK_NULL);\n+  Klass *s = resolve_or_fail(cn, class_loader, true, CHECK_NULL);\n@@ -1154,1 +1132,1 @@\n-  bool check = check_shared_class_super_types(ik, class_loader, protection_domain, CHECK_NULL);\n+  bool check = check_shared_class_super_types(ik, class_loader, CHECK_NULL);\n@@ -1582,11 +1560,0 @@\n-    if (java_lang_System::allow_security_manager()) {\n-      \/\/ Oops referenced by the protection domain cache table may get unreachable independently\n-      \/\/ of the class loader (eg. cached protection domain oops). So we need to\n-      \/\/ explicitly unlink them here.\n-      \/\/ All protection domain oops are linked to the caller class, so if nothing\n-      \/\/ unloads, this is not needed.\n-      ProtectionDomainCacheTable::trigger_cleanup();\n-    } else {\n-      assert(ProtectionDomainCacheTable::number_of_entries() == 0, \"should be empty\");\n-    }\n-\n@@ -1630,1 +1597,0 @@\n-  ProtectionDomainCacheTable::initialize();\n@@ -1747,4 +1713,1 @@\n-  \/\/ Force the protection domain to be null.  (This removes protection checks.)\n-  Handle no_protection_domain;\n-  Klass* klass = find_instance_or_array_klass(current, class_name, class_loader,\n-                                              no_protection_domain);\n+  Klass* klass = find_instance_or_array_klass(current, class_name, class_loader);\n@@ -2198,2 +2161,0 @@\n-                                                   Handle class_loader,\n-                                                   Handle protection_domain,\n@@ -2202,2 +2163,2 @@\n-  assert(accessing_klass == nullptr || (class_loader.is_null() && protection_domain.is_null()),\n-         \"one or the other, or perhaps neither\");\n+\n+  Handle class_loader;\n@@ -2210,1 +2171,0 @@\n-    protection_domain = Handle(THREAD, accessing_klass->protection_domain());\n@@ -2212,1 +2172,1 @@\n-  ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);\n+  ResolvingSignatureStream ss(signature, class_loader, false);\n@@ -2253,1 +2213,1 @@\n-  Handle class_loader, protection_domain;\n+  Handle class_loader;\n@@ -2256,1 +2216,0 @@\n-    protection_domain = Handle(THREAD, accessing_klass->protection_domain());\n@@ -2268,2 +2227,1 @@\n-      mirror = ss.as_java_mirror(Handle(), Handle(),\n-                                 SignatureStream::ReturnNull, CHECK_(empty));\n+      mirror = ss.as_java_mirror(Handle(), SignatureStream::ReturnNull, CHECK_(empty));\n@@ -2277,2 +2235,1 @@\n-      mirror = ss.as_java_mirror(class_loader, protection_domain,\n-                                 SignatureStream::NCDFError, CHECK_(empty));\n+      mirror = ss.as_java_mirror(class_loader, SignatureStream::NCDFError, CHECK_(empty));\n@@ -2331,1 +2288,1 @@\n-    Handle class_loader, protection_domain;\n+    Handle class_loader;\n@@ -2334,1 +2291,0 @@\n-      protection_domain = Handle(THREAD, accessing_klass->protection_domain());\n@@ -2336,1 +2292,1 @@\n-    oop mirror = ss.as_java_mirror(class_loader, protection_domain, SignatureStream::NCDFError, CHECK_(empty));\n+    oop mirror = ss.as_java_mirror(class_loader, SignatureStream::NCDFError, CHECK_(empty));\n@@ -2474,3 +2430,0 @@\n-\n-  ProtectionDomainCacheTable::print_on(st);\n-  st->cr();\n@@ -2490,3 +2443,0 @@\n-\n-  \/\/ Verify protection domain table\n-  ProtectionDomainCacheTable::verify();\n@@ -2503,1 +2453,0 @@\n-    ProtectionDomainCacheTable::print_table_statistics(st);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":31,"deletions":82,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\/\/   class loader -> ClassLoaderData -> [class, protection domain set]\n+\/\/   class loader -> ClassLoaderData -> Loaded and initiated loaded classes\n@@ -41,1 +41,1 @@\n-\/\/ The underlying data structure is an open hash table (Dictionary) per\n+\/\/ The underlying data structure is a concurrent hash table (Dictionary) per\n@@ -52,3 +52,1 @@\n-\/\/ of the class loader and the placeholder is removed. Note that the protection\n-\/\/ domain field of the dictionary entry has not yet been filled in when\n-\/\/ the \"real\" dictionary entry is created.\n+\/\/ of the class loader and the placeholder is removed.\n@@ -94,1 +92,1 @@\n-  static Klass* resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS);\n+  static Klass* resolve_or_fail(Symbol* class_name, Handle class_loader, bool throw_error, TRAPS);\n@@ -97,1 +95,1 @@\n-    return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);\n+    return resolve_or_fail(class_name, Handle(), throw_error, THREAD);\n@@ -102,1 +100,1 @@\n-  static Klass* resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);\n+  static Klass* resolve_or_null(Symbol* class_name, Handle class_loader, TRAPS);\n@@ -105,1 +103,1 @@\n-    return resolve_or_null(class_name, Handle(), Handle(), THREAD);\n+    return resolve_or_null(class_name, Handle(), THREAD);\n@@ -111,1 +109,0 @@\n-                                                           Handle protection_domain,\n@@ -120,3 +117,2 @@\n-                                              Handle protection_domain, bool is_superclass, TRAPS) {\n-    return resolve_with_circularity_detection(class_name, super_name, class_loader, protection_domain,\n-                                              is_superclass, THREAD);\n+                                              bool is_superclass, TRAPS) {\n+    return resolve_with_circularity_detection(class_name, super_name, class_loader, is_superclass, THREAD);\n@@ -155,1 +151,1 @@\n-                                            Handle class_loader, Handle protection_domain);\n+                                            Handle class_loader);\n@@ -161,2 +157,1 @@\n-                                             Handle class_loader,\n-                                             Handle protection_domain);\n+                                             Handle class_loader);\n@@ -249,1 +244,0 @@\n-  \/\/ Either the accessing_klass or the CL\/PD can be non-null, but not both.\n@@ -252,2 +246,0 @@\n-                                             Handle class_loader,\n-                                             Handle protection_domain,\n@@ -256,8 +248,0 @@\n-  static Handle    find_java_mirror_for_type(Symbol* signature,\n-                                             Klass* accessing_klass,\n-                                             SignatureStream::FailureMode failure_mode,\n-                                             TRAPS) {\n-    \/\/ callee will fill in CL\/PD from AK, if they are needed\n-    return find_java_mirror_for_type(signature, accessing_klass, Handle(), Handle(),\n-                                     failure_mode, THREAD);\n-  }\n@@ -312,1 +296,1 @@\n-                                                       Handle protection_domain, TRAPS);\n+                                                       TRAPS);\n@@ -315,1 +299,1 @@\n-                                            Handle protection_domain, TRAPS);\n+                                            TRAPS);\n@@ -337,1 +321,1 @@\n-                                            Handle class_loader,  Handle protection_domain,\n+                                            Handle class_loader,\n@@ -339,2 +323,1 @@\n-  static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,\n-                                               Handle protection_domain, TRAPS);\n+  static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":15,"deletions":32,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,1 @@\n-      name, Handle(THREAD, klass->class_loader()),\n-      Handle(THREAD, klass->protection_domain()), true, CHECK_false);\n+      name, Handle(THREAD, klass->class_loader()), true, CHECK_false);\n@@ -82,2 +81,1 @@\n-        from_name, Handle(THREAD, klass->class_loader()),\n-        Handle(THREAD, klass->protection_domain()), true, CHECK_false);\n+        from_name, Handle(THREAD, klass->class_loader()), true, CHECK_false);\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2095,1 +2095,1 @@\n-  \/\/ Get current loader and protection domain first.\n+  \/\/ Get current loader first.\n@@ -2097,1 +2097,0 @@\n-  oop protection_domain = current_class()->protection_domain();\n@@ -2102,2 +2101,1 @@\n-    name, Handle(THREAD, loader), Handle(THREAD, protection_domain),\n-    true, THREAD);\n+    name, Handle(THREAD, loader), true, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-  do_klass(SecurityManager_klass,                       java_lang_SecurityManager                             ) \\\n@@ -65,2 +64,0 @@\n-  do_klass(AccessControlContext_klass,                  java_security_AccessControlContext                    ) \\\n-  do_klass(AccessController_klass,                      java_security_AccessController                        ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-  template(java_lang_SecurityManager,                 \"java\/lang\/SecurityManager\")                \\\n@@ -124,3 +123,0 @@\n-  template(java_security_AccessControlContext,        \"java\/security\/AccessControlContext\")       \\\n-  template(java_security_AccessController,            \"java\/security\/AccessController\")           \\\n-  template(executePrivileged_name,                    \"executePrivileged\")                        \\\n@@ -443,3 +439,0 @@\n-  template(context_name,                              \"context\")                                  \\\n-  template(contextClassLoader_name,                   \"contextClassLoader\")                       \\\n-  template(getClassContext_name,                      \"getClassContext\")                          \\\n@@ -493,1 +486,0 @@\n-  template(security_manager_signature,                \"Ljava\/lang\/SecurityManager;\")              \\\n@@ -607,3 +599,0 @@\n-  template(protectiondomain_signature,                \"[Ljava\/security\/ProtectionDomain;\")                        \\\n-  template(accesscontrolcontext_signature,            \"Ljava\/security\/AccessControlContext;\")                     \\\n-  template(class_protectiondomain_signature,          \"(Ljava\/lang\/Class;Ljava\/security\/ProtectionDomain;)V\")     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -329,6 +329,0 @@\n-\/*\n- * java.lang.SecurityManager\n- *\/\n-JNIEXPORT jobjectArray JNICALL\n-JVM_GetClassContext(JNIEnv *env);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -499,1 +499,0 @@\n-                                            Handle(),\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -616,1 +616,0 @@\n-  Handle protection_domain;\n@@ -619,1 +618,0 @@\n-    protection_domain = Handle(THREAD, accessing_klass->protection_domain());\n@@ -632,1 +630,1 @@\n-    resolved_klass = SystemDictionary::resolve_or_fail(class_name, class_loader, protection_domain, true, CHECK_NULL);\n+    resolved_klass = SystemDictionary::resolve_or_fail(class_name, class_loader, true, CHECK_NULL);\n@@ -639,2 +637,1 @@\n-                                                             class_loader,\n-                                                             protection_domain);\n+                                                             class_loader);\n@@ -647,2 +644,1 @@\n-                                                               class_loader,\n-                                                               protection_domain);\n+                                                               class_loader);\n@@ -657,2 +653,1 @@\n-                                                             class_loader,\n-                                                             protection_domain);\n+                                                             class_loader);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -944,3 +944,2 @@\n-    Handle h_loader = Handle();\n-    Handle h_protection_domain = Handle();\n-    Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);\n+    Handle h_loader;\n+    Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader );\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1681,1 +1681,0 @@\n-  Handle domain;\n@@ -1684,1 +1683,0 @@\n-    domain = Handle(THREAD, accessing_klass->protection_domain());\n@@ -1688,1 +1686,1 @@\n-                         SystemDictionary::find_instance_or_array_klass(THREAD, sym, loader, domain) :\n+                         SystemDictionary::find_instance_or_array_klass(THREAD, sym, loader) :\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-  \/\/ Used by SecurityManager. This DCMD requires ManagementPermission = control.\n","filename":"src\/hotspot\/share\/logging\/logDiagnosticCommand.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -164,1 +164,0 @@\n-  LOG_TAG(protectiondomain) \/* \"Trace protection domain verification\" *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -683,1 +683,0 @@\n-  Handle protection_domain (THREAD, this_cp->pool_holder()->protection_domain());\n@@ -689,1 +688,1 @@\n-    k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);\n+    k = SystemDictionary::resolve_or_fail(name, loader, true, THREAD);\n@@ -759,2 +758,0 @@\n-    oop protection_domain = this_cp->pool_holder()->protection_domain();\n-    Handle h_prot (current, protection_domain);\n@@ -762,1 +759,1 @@\n-    Klass* k = SystemDictionary::find_instance_klass(current, name, h_loader, h_prot);\n+    Klass* k = SystemDictionary::find_instance_klass(current, name, h_loader);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -930,2 +930,1 @@\n-    Handle prot  (thread, method_holder()->protection_domain());\n-    return SystemDictionary::find_instance_klass(thread, klass_name, loader, prot) != nullptr;\n+    return SystemDictionary::find_instance_klass(thread, klass_name, loader) != nullptr;\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -324,2 +324,0 @@\n-  \/\/%note jni_3\n-  Handle protection_domain;\n@@ -347,1 +345,0 @@\n-        protection_domain = Handle(THREAD, fromClass->protection_domain());\n@@ -354,2 +351,1 @@\n-  result = find_class_from_class_loader(env, class_name, true, loader,\n-                                        protection_domain, true, thread);\n+  result = find_class_from_class_loader(env, class_name, true, loader, true, thread);\n@@ -540,2 +536,1 @@\n-  Handle protection_domain (THREAD, k->protection_domain());\n-  THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);\n+  THROW_MSG_LOADER_(name, (char *)message, class_loader, JNI_OK);\n@@ -2932,1 +2927,0 @@\n-  Handle protection_domain; \/\/ null protection domain\n@@ -2935,1 +2929,1 @@\n-  jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);\n+  jclass result =  find_class_from_class_loader(env, sym, true, loader, true, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-static void trace_class_resolution_impl(Klass* to_class, TRAPS) {\n+extern void trace_class_resolution(Klass* to_class) {\n@@ -160,1 +160,1 @@\n-  JavaThread* jthread = THREAD;\n+  JavaThread* jthread = JavaThread::current();\n@@ -164,6 +164,1 @@\n-    \/\/ scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames\n-    TempNewSymbol access_controller = SymbolTable::new_symbol(\"java\/security\/AccessController\");\n-    Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);\n-    TempNewSymbol privileged_action = SymbolTable::new_symbol(\"java\/security\/PrivilegedAction\");\n-    Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);\n-\n+    \/\/ Scan up the stack skipping ClassLoader frames.\n@@ -174,3 +169,1 @@\n-      if (!vfst.method()->method_holder()->is_subclass_of(vmClasses::ClassLoader_klass())&&\n-          !vfst.method()->method_holder()->is_subclass_of(access_controller_klass) &&\n-          !vfst.method()->method_holder()->is_subclass_of(privileged_action_klass)) {\n+      if (!vfst.method()->method_holder()->is_subclass_of(vmClasses::ClassLoader_klass())) {\n@@ -235,8 +228,0 @@\n-void trace_class_resolution(Klass* to_class) {\n-  EXCEPTION_MARK;\n-  trace_class_resolution_impl(to_class, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n-}\n-\n@@ -836,10 +821,0 @@\n-  oop protection_domain = nullptr;\n-  \/\/ If loader is null, shouldn't call ClassLoader.checkPackageAccess; otherwise get\n-  \/\/ NPE. Put it in another way, the bootstrap class loader has all permission and\n-  \/\/ thus no checkPackageAccess equivalence in the VM class loader.\n-  \/\/ The caller is also passed as null by the java code if there is no security\n-  \/\/ manager to avoid the performance cost of getting the calling class.\n-  if (from_class != nullptr && loader_oop != nullptr) {\n-    protection_domain = java_lang_Class::as_Klass(from_class)->protection_domain();\n-  }\n-\n@@ -847,1 +822,1 @@\n-  Handle h_prot(THREAD, protection_domain);\n+\n@@ -849,1 +824,1 @@\n-                                               h_prot, false, THREAD);\n+                                               false, THREAD);\n@@ -868,1 +843,0 @@\n-  oop protection_domain = nullptr;\n@@ -871,1 +845,0 @@\n-    protection_domain = from_class->protection_domain();\n@@ -874,3 +847,1 @@\n-  Handle h_prot  (THREAD, protection_domain);\n-  jclass result = find_class_from_class_loader(env, h_name, init, h_loader,\n-                                               h_prot, true, thread);\n+  jclass result = find_class_from_class_loader(env, h_name, init, h_loader, true, thread);\n@@ -1124,3 +1095,1 @@\n-  Klass* k = SystemDictionary::find_instance_or_array_klass(THREAD, klass_name,\n-                                                            h_loader,\n-                                                            Handle());\n+  Klass* k = SystemDictionary::find_instance_or_array_klass(THREAD, klass_name, h_loader);\n@@ -3072,39 +3041,0 @@\n-\/\/ java.lang.SecurityManager \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))\n-  ResourceMark rm(THREAD);\n-  JvmtiVMObjectAllocEventCollector oam;\n-  vframeStream vfst(thread);\n-\n-  if (vmClasses::reflect_CallerSensitive_klass() != nullptr) {\n-    \/\/ This must only be called from SecurityManager.getClassContext\n-    Method* m = vfst.method();\n-    if (!(m->method_holder() == vmClasses::SecurityManager_klass() &&\n-          m->name()          == vmSymbols::getClassContext_name() &&\n-          m->signature()     == vmSymbols::void_class_array_signature())) {\n-      THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), \"JVM_GetClassContext must only be called from SecurityManager.getClassContext\");\n-    }\n-  }\n-\n-  \/\/ Collect method holders\n-  GrowableArray<Klass*>* klass_array = new GrowableArray<Klass*>();\n-  for (; !vfst.at_end(); vfst.security_next()) {\n-    Method* m = vfst.method();\n-    \/\/ Native frames are not returned\n-    if (!m->is_ignored_by_security_stack_walk() && !m->is_native()) {\n-      Klass* holder = m->method_holder();\n-      assert(holder->is_klass(), \"just checking\");\n-      klass_array->append(holder);\n-    }\n-  }\n-\n-  \/\/ Create result array of type [Ljava\/lang\/Class;\n-  objArrayOop result = oopFactory::new_objArray(vmClasses::Class_klass(), klass_array->length(), CHECK_NULL);\n-  \/\/ Fill in mirrors corresponding to method holders\n-  for (int i = 0; i < klass_array->length(); i++) {\n-    result->obj_at_put(i, klass_array->at(i)->java_mirror());\n-  }\n-\n-  return (jobjectArray) JNIHandles::make_local(THREAD, result);\n-JVM_END\n-\n@@ -3424,9 +3354,2 @@\n-                                    Handle loader, Handle protection_domain,\n-                                    jboolean throwError, TRAPS) {\n-  \/\/ Security Note:\n-  \/\/   The Java level wrapper will perform the necessary security check allowing\n-  \/\/   us to pass the null as the initiating class loader.  The VM is responsible for\n-  \/\/   the checkPackageAccess relative to the initiating class loader via the\n-  \/\/   protection_domain. The protection_domain is passed as null by the java code\n-  \/\/   if there is no security manager in 3-arg Class.forName().\n-  Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);\n+                                    Handle loader, jboolean throwError, TRAPS) {\n+  Klass* klass = SystemDictionary::resolve_or_fail(name, loader, throwError != 0, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":10,"deletions":87,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init, Handle loader, Handle protection_domain, jboolean throwError, TRAPS);\n+jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init, Handle loader, jboolean throwError, TRAPS);\n","filename":"src\/hotspot\/share\/prims\/jvm_misc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"classfile\/protectionDomainCache.hpp\"\n@@ -2539,4 +2538,0 @@\n-WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))\n-  return (jint) ProtectionDomainCacheTable::removed_entries_count();\n-WB_END\n-\n@@ -2969,1 +2964,0 @@\n-  {CC\"protectionDomainRemovedCount\",   CC\"()I\",       (void*)&WB_ProtectionDomainRemovedCount },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1068,1 +1068,1 @@\n-    InstanceKlass* ik = SystemDictionary::find_instance_klass(thread, klass_name, Handle(), Handle());\n+    InstanceKlass* ik = SystemDictionary::find_instance_klass(thread, klass_name, Handle());\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/protectionDomainCache.hpp\"\n@@ -31,2 +30,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/vmClasses.hpp\"\n@@ -43,3 +40,0 @@\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/javaCalls.hpp\"\n-#include \"runtime\/jniHandles.hpp\"\n@@ -50,2 +44,0 @@\n-#include \"services\/diagnosticArgument.hpp\"\n-#include \"services\/diagnosticFramework.hpp\"\n@@ -91,1 +83,0 @@\n-    bool protection_domain_table_work = false;\n@@ -121,1 +112,0 @@\n-              (protection_domain_table_work = ProtectionDomainCacheTable::has_work()) |\n@@ -166,4 +156,0 @@\n-    if (protection_domain_table_work) {\n-      ProtectionDomainCacheTable::unlink();\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -504,2 +504,1 @@\n-Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,\n-                                 FailureMode failure_mode, TRAPS) {\n+Klass* SignatureStream::as_klass(Handle class_loader, FailureMode failure_mode, TRAPS) {\n@@ -514,1 +513,1 @@\n-    k = SystemDictionary::resolve_or_null(name, class_loader, protection_domain, CHECK_NULL);\n+    k = SystemDictionary::resolve_or_null(name, class_loader, CHECK_NULL);\n@@ -518,1 +517,1 @@\n-    k = SystemDictionary::find_instance_klass(THREAD, name, class_loader, protection_domain);\n+    k = SystemDictionary::find_instance_klass(THREAD, name, class_loader);\n@@ -528,1 +527,1 @@\n-    k = SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, CHECK_NULL);\n+    k = SystemDictionary::resolve_or_fail(name, class_loader, throw_error, CHECK_NULL);\n@@ -534,2 +533,1 @@\n-oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,\n-                                    FailureMode failure_mode, TRAPS) {\n+oop SignatureStream::as_java_mirror(Handle class_loader, FailureMode failure_mode, TRAPS) {\n@@ -539,1 +537,1 @@\n-  Klass* klass = as_klass(class_loader, protection_domain, failure_mode, CHECK_NULL);\n+  Klass* klass = as_klass(class_loader, failure_mode, CHECK_NULL);\n@@ -554,1 +552,0 @@\n-                                                   Handle protection_domain,\n@@ -556,2 +553,1 @@\n-  : SignatureStream(signature, is_method),\n-    _class_loader(class_loader), _protection_domain(protection_domain)\n+  : SignatureStream(signature, is_method), _class_loader(class_loader)\n@@ -579,1 +575,0 @@\n-  _protection_domain = Handle(current, _load_origin->protection_domain());\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -565,2 +565,2 @@\n-  Klass* as_klass(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);\n-  oop as_java_mirror(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);\n+  Klass* as_klass(Handle class_loader, FailureMode failure_mode, TRAPS);\n+  oop as_java_mirror(Handle class_loader, FailureMode failure_mode, TRAPS);\n@@ -576,1 +576,0 @@\n-  Handle       _protection_domain;  \/\/ cached when needed\n@@ -592,1 +591,1 @@\n-  ResolvingSignatureStream(Symbol* signature, Handle class_loader, Handle protection_domain, bool is_method = true);\n+  ResolvingSignatureStream(Symbol* signature, Handle class_loader, bool is_method = true);\n@@ -597,2 +596,1 @@\n-    return SignatureStream::as_klass(_class_loader, _protection_domain,\n-                                     failure_mode, THREAD);\n+    return SignatureStream::as_klass(_class_loader, failure_mode, THREAD);\n@@ -604,2 +602,1 @@\n-    return SignatureStream::as_java_mirror(_class_loader, _protection_domain,\n-                                           failure_mode, THREAD);\n+    return SignatureStream::as_java_mirror(_class_loader, failure_mode, THREAD);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-                                                            Handle(), Handle());\n+                                                            Handle());\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -535,2 +535,1 @@\n-\/\/ This function is used in Class.forName, Class.newInstance, Method.Invoke,\n-\/\/ AccessController.doPrivileged.\n+\/\/ This function is used in Class.forName, Class.newInstance, and Method.Invoke.\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -698,1 +698,1 @@\n-    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);\n+    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, true, CHECK);\n@@ -771,1 +771,1 @@\n-    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);\n+    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, true, CHECK);\n@@ -788,1 +788,1 @@\n-    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);\n+    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, true, CHECK);\n@@ -809,1 +809,1 @@\n-  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, true, CHECK);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -163,1 +163,0 @@\n-                                                   Handle(),\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-                            Handle h_loader, Handle h_protection_domain) {\n+                            Handle h_loader) {\n@@ -196,1 +196,1 @@\n-  Handle h_exception = new_exception(thread, name, message, h_cause, h_loader, h_protection_domain);\n+  Handle h_exception = new_exception(thread, name, message, h_cause, h_loader);\n@@ -201,1 +201,1 @@\n-                                  Handle h_loader, Handle h_protection_domain) {\n+                                  Handle h_loader) {\n@@ -205,1 +205,1 @@\n-  Handle h_exception = new_exception(thread, name, message, h_cause, h_loader, h_protection_domain);\n+  Handle h_exception = new_exception(thread, name, message, h_cause, h_loader);\n@@ -210,1 +210,1 @@\n-                              Handle h_loader, Handle h_protection_domain) {\n+                              Handle h_loader) {\n@@ -214,1 +214,1 @@\n-  Handle h_exception = new_exception(thread, name, h_cause, h_loader, h_protection_domain);\n+  Handle h_exception = new_exception(thread, name, h_cause, h_loader);\n@@ -232,1 +232,1 @@\n-  _throw_msg_cause(thread, file, line, name, message, h_cause, Handle(thread, nullptr), Handle(thread, nullptr));\n+  _throw_msg_cause(thread, file, line, name, message, h_cause, Handle());\n@@ -235,1 +235,1 @@\n-  _throw_msg(thread, file, line, name, message, Handle(thread, nullptr), Handle(thread, nullptr));\n+  _throw_msg(thread, file, line, name, message, Handle());\n@@ -238,1 +238,1 @@\n-  _throw_cause(thread, file, line, name, h_cause, Handle(thread, nullptr), Handle(thread, nullptr));\n+  _throw_cause(thread, file, line, name, h_cause, Handle());\n@@ -300,1 +300,1 @@\n-                                 Handle h_loader, Handle h_protection_domain) {\n+                                 Handle h_loader) {\n@@ -308,1 +308,1 @@\n-  Klass* klass = SystemDictionary::resolve_or_fail(name, h_loader, h_protection_domain, true, thread);\n+  Klass* klass = SystemDictionary::resolve_or_fail(name, h_loader, true, thread);\n@@ -332,2 +332,2 @@\n-                                 Handle h_loader, Handle h_protection_domain) {\n-  Handle h_exception = new_exception(thread, name, signature, args, h_loader, h_protection_domain);\n+                                 Handle h_loader) {\n+  Handle h_exception = new_exception(thread, name, signature, args, h_loader);\n@@ -362,1 +362,1 @@\n-                                 Handle h_loader, Handle h_protection_domain,\n+                                 Handle h_loader,\n@@ -372,1 +372,1 @@\n-  return new_exception(thread, name, signature, &args, h_loader, h_protection_domain);\n+  return new_exception(thread, name, signature, &args, h_loader);\n@@ -379,1 +379,1 @@\n-                                 Handle h_loader, Handle h_protection_domain,\n+                                 Handle h_loader,\n@@ -416,1 +416,1 @@\n-  return new_exception(thread, name, signature, &args, h_cause, h_loader, h_protection_domain);\n+  return new_exception(thread, name, signature, &args, h_cause, h_loader);\n@@ -419,2 +419,1 @@\n-\/\/ Another convenience method that creates handles for null class loaders and\n-\/\/ protection domains and null causes.\n+\/\/ Another convenience method that creates handles for null class loaders and null causes.\n@@ -431,3 +430,2 @@\n-  Handle       h_loader(thread, nullptr);\n-  Handle       h_prot(thread, nullptr);\n-  Handle       h_cause(thread, nullptr);\n+  Handle h_loader;\n+  Handle h_cause;\n@@ -435,1 +433,1 @@\n-                                   h_prot, to_utf8_safe);\n+                                   to_utf8_safe);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-                         Handle loader, Handle protection_domain);\n+                         Handle loader);\n@@ -135,1 +135,1 @@\n-                               Handle h_loader, Handle h_protection_domain);\n+                               Handle h_loader);\n@@ -139,1 +139,1 @@\n-                           Handle h_loader, Handle h_protection_domain);\n+                           Handle h_loader);\n@@ -153,1 +153,1 @@\n-                              Handle loader, Handle protection_domain);\n+                              Handle loader);\n@@ -158,1 +158,1 @@\n-                              Handle loader, Handle protection_domain);\n+                              Handle loader);\n@@ -162,1 +162,1 @@\n-                              Handle loader, Handle protection_domain,\n+                              Handle loader,\n@@ -167,1 +167,1 @@\n-                              Handle loader, Handle protection_domain,\n+                              Handle loader,\n@@ -271,2 +271,2 @@\n-#define THROW_MSG_LOADER(name, message, loader, protection_domain) \\\n-  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message, loader, protection_domain); return;  }\n+#define THROW_MSG_LOADER(name, message, loader) \\\n+  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message, loader); return;  }\n@@ -289,2 +289,2 @@\n-#define THROW_MSG_LOADER_(name, message, loader, protection_domain, result) \\\n-  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message, loader, protection_domain); return result; }\n+#define THROW_MSG_LOADER_(name, message, loader, result) \\\n+  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message, loader); return result; }\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -116,3 +116,0 @@\n-runtime\/Dictionary\/CleanProtectionDomain.java 8341916 generic-all\n-runtime\/Dictionary\/ProtectionDomainCacheTest.java 8341916 generic-all\n-runtime\/logging\/ProtectionDomainVerificationTest.java 8341916 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verifies the creation and cleaup of entries in the Protection Domain Table\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run driver CleanProtectionDomain\n- *\/\n-\n-import java.security.ProtectionDomain;\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-import jdk.internal.misc.Unsafe;\n-import static jdk.test.lib.Asserts.*;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class CleanProtectionDomain {\n-\n-  public static void main(String args[]) throws Exception {\n-    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                                  \"-Xlog:protectiondomain+table=debug\",\n-                                  \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                  \"-XX:+UnlockDiagnosticVMOptions\",\n-                                  \"-XX:+WhiteBoxAPI\",\n-                                  \"-Xbootclasspath\/a:.\",\n-                                  \"-Djava.security.manager=allow\",\n-                                  Test.class.getName());\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"protection domain added\");\n-    output.shouldContain(\"protection domain unlinked\");\n-    output.shouldHaveExitValue(0);\n-  }\n-\n-  static class Test {\n-    public static void test() throws Exception {\n-      TestClassLoader classloader = new TestClassLoader();\n-      ProtectionDomain pd = new ProtectionDomain(null, null);\n-      byte klassbuf[] = InMemoryJavaCompiler.compile(\"TestClass\", \"class TestClass { }\");\n-      Class<?> klass = classloader.defineClass(\"TestClass\", klassbuf, pd);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-      WhiteBox wb = WhiteBox.getWhiteBox();\n-      int removedCountOrig =  wb.protectionDomainRemovedCount();\n-      int removedCount;\n-\n-      test();\n-\n-      \/\/ Wait until ServiceThread cleans ProtectionDomain table.\n-      \/\/ When the TestClassLoader is unloaded by GC, at least one\n-      \/\/ ProtectionDomainCacheEntry will be eligible for removal.\n-      int cnt = 0;\n-      while (true) {\n-        if (cnt++ % 30 == 0) {\n-          System.gc();\n-        }\n-        removedCount = wb.protectionDomainRemovedCount();\n-        if (removedCountOrig != removedCount) {\n-          break;\n-        }\n-        Thread.sleep(100);\n-      }\n-    }\n-\n-    private static class TestClassLoader extends ClassLoader {\n-      public TestClassLoader() {\n-        super();\n-      }\n-\n-      public Class<?> defineClass(String name, byte[] bytes, ProtectionDomain pd) {\n-        return defineClass(name, bytes, 0, bytes.length, pd);\n-      }\n-    }\n-  }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/Dictionary\/CleanProtectionDomain.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8151486 8218266\n- * @summary Call Class.forName() on the system classloader from a class loaded\n- *          from a custom classloader, using the current class's protection domain.\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- * @build jdk.test.lib.Utils\n- *        jdk.test.lib.util.JarUtils\n- * @build ClassForName ProtectionDomainCacheTest\n- * @run driver ProtectionDomainCacheTest\n- *\/\n-\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.List;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.util.JarUtils;\n-import java.io.File;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-\/*\n- * Create .jar, load ClassForName from .jar using a URLClassLoader\n- *\/\n-public class ProtectionDomainCacheTest {\n-    static class Test {\n-        private static final long TIMEOUT = (long)(5000.0 * Utils.TIMEOUT_FACTOR);\n-        private static final String TESTCLASSES = System.getProperty(\"test.classes\", \".\");\n-        private static final String CLASSFILENAME = \"ClassForName.class\";\n-\n-        \/\/ Use a new classloader to load the ClassForName class.\n-        public static void loadAndRun(Path jarFilePath)\n-                throws Exception {\n-            ClassLoader classLoader = new URLClassLoader(\n-                    new URL[]{jarFilePath.toUri().toURL()}) {\n-                @Override public String toString() { return \"LeakedClassLoader\"; }\n-            };\n-\n-            Class<?> loadClass = Class.forName(\"ClassForName\", true, classLoader);\n-            loadClass.newInstance();\n-\n-            System.out.println(\"returning : \" + classLoader);\n-        }\n-\n-        public static void main(final String[] args) throws Exception {\n-            \/\/ Create a temporary .jar file containing ClassForName.class\n-            Path testClassesDir = Paths.get(TESTCLASSES);\n-            Path jarFilePath = Files.createTempFile(\"cfn\", \".jar\");\n-            JarUtils.createJarFile(jarFilePath, testClassesDir, CLASSFILENAME);\n-            jarFilePath.toFile().deleteOnExit();\n-\n-            \/\/ Remove the ClassForName.class file that jtreg built, to make sure\n-            \/\/ we're loading from the tmp .jar\n-            Path classFile = FileSystems.getDefault().getPath(TESTCLASSES,\n-                                                              CLASSFILENAME);\n-            Files.delete(classFile);\n-\n-            for (int i = 0; i < 20; i++) {\n-                loadAndRun(jarFilePath);\n-            }\n-\n-            \/\/ Give the GC a chance to unload protection domains\n-            for (int i = 0; i < 100; i++) {\n-                System.gc();\n-            }\n-            System.out.println(\"All Classloaders and protection domain cache entries successfully unloaded\");\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                                      \"-Djava.security.policy==\" + System.getProperty(\"test.src\") + File.separator + \"test.policy\",\n-                                      \"-Dtest.classes=\" + System.getProperty(\"test.classes\", \".\"),\n-                                      \"-XX:+UnlockDiagnosticVMOptions\",\n-                                      \"-XX:VerifySubSet=dictionary\",\n-                                      \"-XX:+VerifyAfterGC\",\n-                                      \"-Xlog:gc+verify,protectiondomain=trace\",\n-                                      \"-Djava.security.manager\",\n-                                      Test.class.getName());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"PD in set is not alive\");\n-        output.shouldContain(\"HandshakeForPD::do_thread\");\n-        output.shouldHaveExitValue(0);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/Dictionary\/ProtectionDomainCacheTest.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test ProtectionDomainVerificationTest\n- * @bug 8149064\n- * @requires vm.flagless\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @run driver ProtectionDomainVerificationTest\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class ProtectionDomainVerificationTest {\n-\n-    public static void main(String... args) throws Exception {\n-\n-        \/\/ -Xlog:protectiondomain=trace\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:protectiondomain=trace\",\n-                                                                             \"-Xmx128m\",\n-                                                                             \"-Djava.security.manager=allow\",\n-                                                                             Hello.class.getName(), \"security_manager\");\n-        new OutputAnalyzer(pb.start())\n-        .shouldHaveExitValue(0)\n-        .shouldContain(\"[protectiondomain] Checking package access\")\n-        .shouldContain(\"[protectiondomain] adding protection domain that can access class\");\n-\n-        \/\/ -Xlog:protectiondomain=debug\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:protectiondomain=debug\",\n-                                                              \"-Xmx128m\",\n-                                                              \"-Djava.security.manager=allow\",\n-                                                              Hello.class.getName(), \"security_manager\");\n-        new OutputAnalyzer(pb.start())\n-        .shouldHaveExitValue(0)\n-        .shouldContain(\"[protectiondomain] Checking package access\")\n-        .shouldNotContain(\"[protectiondomain] adding protection domain that can access class\");\n-\n-        \/\/ -Xlog:protectiondomain=debug\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:protectiondomain=trace\",\n-                                                              \"-Xmx128m\",\n-                                                              \"-Djava.security.manager=disallow\",\n-                                                              Hello.class.getName());\n-        new OutputAnalyzer(pb.start())\n-        .shouldHaveExitValue(0)\n-        .shouldNotContain(\"[protectiondomain] Checking package access\")\n-        .shouldNotContain(\"pd set count = #\");\n-    }\n-\n-    public static class Hello {\n-        public static void main(String[] args) {\n-            if (args.length == 1) {\n-              \/\/ Need a security manager to trigger logging.\n-              System.setSecurityManager(new SecurityManager());\n-            }\n-            System.out.print(\"Hello!\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ProtectionDomainVerificationTest.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,8 +70,0 @@\n-    \/\/ ProtectionDomainCacheTable statistics:\n-    \/\/ Number of buckets       :      1009 =      8072 bytes, each 8\n-    \/\/ Number of entries       :         0 =         0 bytes, each 0\n-    \/\/ Total footprint         :           =      8072 bytes\n-    \/\/ Average bucket size     :     0.000\n-    \/\/ Variance of bucket size :     0.000\n-    \/\/ Std. dev. of bucket size:     0.000\n-    \/\/ Maximum bucket size     :         0\n@@ -102,4 +94,0 @@\n-        \/\/ Would be nice to run this with \"-Djava.security.manager=allow\"\n-        \/\/ so the numbers aren't 0 (running make with VM_OPTIONS allowing\n-        \/\/ security manager does get 12 entries in this table.)\n-        output.shouldMatch(\"ProtectionDomainCacheTable statistics:\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/DictionaryStatsTest.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -779,3 +779,0 @@\n-  \/\/ Protection Domain Table\n-  public native int protectionDomainRemovedCount();\n-\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}