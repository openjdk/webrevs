{"files":[{"patch":"@@ -38,0 +38,269 @@\n+ * @apiNote\n+ *\n+ * <h2><a id=expectedEvolution>Expected visitor evolution<\/a><\/h2>\n+ *\n+ * As the Java programming language evolves, the visitor interfaces of\n+ * the language model also evolve as do the concrete visitors in this\n+ * package. A preview language feature in JDK <i>N<\/i> may have API\n+ * elements added in the set of visitors for the preview language\n+ * level. Such new elements are marked as reflective preview API. Any\n+ * existing methods whose specification is updated to support the\n+ * preview feature are <em>not<\/em> marked as preview.\n+ *\n+ * <p>The remainder of this note will show two examples of the API\n+ * changes in the model and visitors that can be added to support a\n+ * language feature. The examples will use additions to the elements\n+ * portion of the language model, but the updates to visitors for\n+ * types or annotation values would be analogous.\n+ *\n+ * Two distinct cases are:\n+ * <ul>\n+ *\n+ * <li>the preview language construct has a corresponding new modeling\n+ * interface\n+ *\n+ * <li>the preview language construct only triggers the introduction\n+ * of a new kind <em>without<\/em> a new modeling interface.\n+ *\n+ * <\/ul>\n+ *\n+ * If a preview language feature is withdrawn rather than evolving to\n+ * a permanent platform feature, the API elements associated with the\n+ * feature are expected to be removed. The examples below outline the\n+ * API changes expected when a preview feature becomes a permanent\n+ * feature.\n+ *\n+ * <h3><a id=topLevelLangConstruct>Adding visitor support for a\n+ * top-level language construct<\/a><\/h3>\n+ *\n+ * Consider a new language feature, preview feature 1, in JDK <i>N<\/i>. This\n+ * feature has a top-level element interface to model it:\n+ *\n+ * <pre>\n+ * package javax.lang.model.element;\n+ * \/**\n+ *  * Represents a preview feature 1.\n+ *  *\n+ *  * &commat;since N\n+ *  *&sol;\n+ *  public interface PreviewFeature1Element extends Element {\n+ *  \/\/ Methods to retrieve information specific to the preview feature...\n+ *  }\n+ * <\/pre>\n+ * A new element kind would also be introduced to model such a feature:\n+ *\n+ * <pre>\n+ *  \/\/  Sample diff of ElementKind.java\n+ *  +    \/**\n+ *  +     * A preview feature 1.\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +     PREVIEW_FEATURE_1,\n+ * <\/pre>\n+ *\n+ * A {@code default} method is added to {@code ElementVisitor} to accommodate the new construct:\n+ * <pre>\n+ * \/\/  Sample diff for ElementVisitor.java\n+ *  +    \/**\n+ *  +     * Visits a preview feature 1.\n+ *  +     *\n+ *  +     * &commat;implSpec The default implementation visits a {&commat;code\n+ *  +     * PreviewFeature1Element} by calling {&commat;code visitUnknown(e, p)}.\n+ *  +     *\n+ *  +     * &commat;param e  the element to visit\n+ *  +     * &commat;param p  a visitor-specified parameter\n+ *  +     * &commat;return a visitor-specified result\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    default R visitPreviewFeature1(PreviewFeature1Element e, P p) {\n+ *  +        return visitUnknown(e, p);\n+ *  +    }\n+ * <\/pre>\n+ *\n+ * Given the {@code default} method on the visitor interface, the\n+ * preview visitor classes need to override this method and take an\n+ * action appropriate for the visitor's semantics:\n+ *\n+ * <pre>\n+ * \/\/  Sample diff for AbstractElementVisitorPreview.java\n+ * \/\/  Re-abstract visitPreviewFeature1.\n+ *  +    \/**\n+ *  +     * {&commat;inheritDoc ElementVisitor}\n+ *  +     *\n+ *  +     * &commat;implSpec Visits a {&commat;code PreviewFeature1Element} in a manner\n+ *  +     * defined by a subclass.\n+ *  +     *\n+ *  +     * &commat;param e {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;param p {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;return a visitor-specified result\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    @Override\n+ *  +    public abstract R visitPreviewFeature1(PreviewFeature1Element e, P p);\n+ *\n+ * \/\/  Sample diff for ElementKindVisitorPreview.java\n+ * \/\/  Take the default action for a preview feature 1.\n+ *  +\n+ *  +    \/**\n+ *  +     * {&commat;inheritDoc ElementVisitor}\n+ *  +     *\n+ *  +     * &commat;implSpec This implementation calls {&commat;code defaultAction}.\n+ *  +     *\n+ *  +     * &commat;param e {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;param p {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;return  the result of {&commat;code defaultAction}\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    @Override\n+ *  +    public R visitPreviewFeature1(PreviewFeature1Element e, P p) {\n+ *  +        return defaultAction(e, p);\n+ *  +    }\n+ *\n+ * \/\/  Sample diff for ElementScannerPreview.java\n+ * \/\/  Scan the enclosed elements of a preview feature 1.\n+ *  +\n+ *  +    \/**\n+ *  +     * {&commat;inheritDoc ElementVisitor}\n+ *  +     *\n+ *  +     * &commat;implSpec This implementation scans the enclosed elements.\n+ *  +     *\n+ *  +     * &commat;param e {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;param p {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;return  {&commat;inheritDoc ElementScanner6}\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    @Override\n+ *  +    public R visitPreviewFeature1(PreviewFeature1Element e, P p) {\n+ *  +        return scan(e.getEnclosedElements(), p);\n+ *  +    }\n+ *\n+ * \/\/  Sample diff for SimpleElementVisitorPreview.java\n+ * \/\/  Take the default action for a preview feature 1.\n+ *  +    \/**\n+ *  +     * {&commat;inheritDoc ElementVisitor}\n+ *  +     *\n+ *  +     * &commat;implSpec Visits a {&commat;code PreviewFeature1Element} by calling\n+ *  +     * {@code defaultAction}.\n+ *  +     *\n+ *  +     * &commat;param e {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;param p {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;return  {&commat;inheritDoc ElementVisitor}\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    @Override\n+ *  +    public R visitPreviewFeature1(PreviewFeature1Element e, P p) {\n+ *  +        return defaultAction(e, p);\n+ *  +    }\n+ * <\/pre>\n+ *\n+ * When preview feature 1 exits preview in JDK (<i>N+k<\/i>), a set of\n+ * visitors for language level (<i>N+k<\/i>) would be added. The\n+ * methods operating over the feature would be moved from the preview\n+ * visitors to the new language level (<i>N+k<\/i>) visitors. Each\n+ * preview visitor would then have its direct superclass changed to\n+ * the new corresponding (<i>N+k<\/i>) visitor.\n+ *\n+ * <h3><a id=newKindLangConstruct>Adding visitor support for a\n+ * language construct that is a new kind of an existing\n+ * construct<\/a><\/h3>\n+ *\n+ * Consider a new language feature, preview feature 2, in JDK\n+ * <i>N<\/i>. This feature has a new element kind <em>without<\/em> a\n+ * new top-level element interface needed to model it. Concretely,\n+ * assume a preview feature 2 is a new kind of variable; the changes\n+ * would be analogous if the feature were a new kind of executable\n+ * instead or new kind of another existing top-level construct. In\n+ * that case, the API changes are more limited:\n+ *\n+ * <pre>\n+ *  \/\/  Sample diff for ElementKind.java\n+ *  +    \/**\n+ *  +     * A preview feature 2.\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +     PREVIEW_FEATURE_2,\n+ *  ...\n+ *  \/\/ Update existing methods as needed\n+ *       public boolean isVariable() {\n+ *           return switch(this) {\n+ *           case ENUM_CONSTANT, FIELD, PARAMETER,\n+ *                LOCAL_VARIABLE, EXCEPTION_PARAMETER, RESOURCE_VARIABLE,\n+ *  -             BINDING_VARIABLE -> true;\n+ *  +            BINDING_VARIABLE, PREVIEW_FEATURE_2 -> true;\n+ *           default -> false;\n+ *           };\n+ *       }\n+ * <\/pre>\n+ *\n+ * The kind visitors need support for the new variety of element:\n+ * <pre>\n+ * \/\/ Update visitVariable in ElementKindVisitor6:\n+ *        ...\n+ *        * &commat;implSpec This implementation dispatches to the visit method for\n+ *        * the specific {&commat;linkplain ElementKind kind} of variable, {&commat;code\n+ *        * ENUM_CONSTANT}, {&commat;code EXCEPTION_PARAMETER}, {&commat;code FIELD},\n+ *  -     * {&commat;code LOCAL_VARIABLE}, {&commat;code PARAMETER}, or {&commat;code RESOURCE_VARIABLE}.\n+ *  +     * {&commat;code LOCAL_VARIABLE}, {&commat;code PARAMETER}, or {&commat;code RESOURCE_VARIABLE},\n+ *  +     * or {&commat;code PREVIEW_FEATURE_2}.\n+ *        *\n+ *        * &commat;param e {&commat;inheritDoc ElementVisitor}\n+ *        * &commat;param p {&commat;inheritDoc ElementVisitor}\n+ *        * &commat;return  the result of the kind-specific visit method\n+ *        *&sol;\n+ *        &commat;Override\n+ *        public R visitVariable(VariableElement e, P p) {\n+ *        ...\n+ *           case BINDING_VARIABLE:\n+ *               return visitVariableAsBindingVariable(e, p);\n+ *\n+ *  +        case PREVIEW_FEATURE_2:\n+ *  +            return visitVariableAsPreviewFeature2(e, p);\n+ *  +\n+ *           default:\n+ *               throw new AssertionError(\"Bad kind \" + k + \" for VariableElement\" + e);\n+ *        ...\n+ *  +    \/**\n+ *  +     * Visits a {&commat;code PREVIEW_FEATURE_2} variable element.\n+ *  +     *\n+ *  +     * &commat;implSpec This implementation calls {&commat;code visitUnknown}.\n+ *  +     *\n+ *  +     * &commat;param e the element to visit\n+ *  +     * &commat;param p a visitor-specified parameter\n+ *  +     * &commat;return  the result of {&commat;code visitUnknown}\n+ *  +     *\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    public R visitVariableAsPreviewFeature2(VariableElement e, P p) {\n+ *  +        return visitUnknown(e, p);\n+ *  +    }\n+ * <\/pre>\n+ *\n+ * The preview element kind visitor in turn overrides {@code\n+ * visitVariableAsPreviewFeature2}:\n+ * <pre>\n+ * \/\/ Sample diff for ElementKindVisitorPreview:\n+ *  +    \/**\n+ *  +     * {&commat;inheritDoc ElementKindVisitor6}\n+ *  +     *\n+ *  +     * &commat;implSpec This implementation calls {&commat;code defaultAction}.\n+ *  +     *\n+ *  +     * &commat;param e {&commat;inheritDoc ElementKindVisitor6}\n+ *  +     * &commat;param p {&commat;inheritDoc ElementKindVisitor6}\n+ *  +     * &commat;return  the result of {&commat;code defaultAction}\n+ *  +     *\n+ *  +     * &commat;since N\n+ *  +     *&sol;\n+ *  +    @Override\n+ *  +    public R visitVariableAsPreviewFeature2(VariableElement e, P p) {\n+ *  +        return defaultAction(e, p);\n+ *  +    }\n+ * <\/pre>\n+ *\n+ * As in the case where a new interface is introduced, when preview\n+ * feature 2 exits preview in JDK (<i>N+k<\/i>), a set of visitors for\n+ * language level (<i>N+k<\/i>) would be added. The methods operating\n+ * over the new feature in the kind visitors would be moved from the\n+ * preview visitors to new language level (<i>N+k<\/i>) visitors. Each\n+ * preview visitor would then have its direct superclass changed to\n+ * the new corresponding (<i>N+k<\/i>) visitor.\n+ *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/package-info.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"modified"}]}