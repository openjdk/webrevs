{"files":[{"patch":"@@ -127,2 +127,1 @@\n-             \/\/ Condition required by legitimize_address() to avoid inserting a preceding lea:\n-             Address::offset_ok_for_immed(ref_addr.offset(), exact_log2(size)),\n+             !MacroAssembler::legitimize_address_requires_lea(ref_addr, size),\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -131,0 +131,6 @@\n+  \/\/ Whether materializing the given address for a LDR\/STR requires an\n+  \/\/ additional lea instruction.\n+  static bool legitimize_address_requires_lea(const Address &a, int size) {\n+    return !Address::offset_ok_for_immed(a.offset(), exact_log2(size));\n+  }\n+\n@@ -135,1 +141,1 @@\n-      if (! Address::offset_ok_for_immed(a.offset(), exact_log2(size))) {\n+      if (legitimize_address_requires_lea(a, size)) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -467,2 +467,3 @@\n-  \/\/ If necessary, hoist orphan node n into the end of block b.\n-  void maybe_hoist_into(Node* n, Block* b);\n+  \/\/ Ensure that n happens at b or above, i.e. at a block that dominates b.\n+  \/\/ We expect n to be an orphan node without further inputs.\n+  void ensure_node_is_at_block_or_above(Node* n, Block* b);\n@@ -471,1 +472,2 @@\n-  void move_into(Node* n, Block* b);\n+  \/\/ Move also outgoing Mach projections.\n+  void move_node_and_its_projections_to_block(Node* n, Block* b);\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,1 +79,2 @@\n-void PhaseCFG::move_into(Node* n, Block* b) {\n+void PhaseCFG::move_node_and_its_projections_to_block(Node* n, Block* b) {\n+  assert(n->bottom_type() != Type::CONTROL, \"cannot move control node\");\n@@ -91,1 +92,1 @@\n-    move_into(out, b);\n+    move_node_and_its_projections_to_block(out, b);\n@@ -95,1 +96,2 @@\n-void PhaseCFG::maybe_hoist_into(Node* n, Block* b) {\n+void PhaseCFG::ensure_node_is_at_block_or_above(Node* n, Block* b) {\n+  assert(n->bottom_type() != Type::CONTROL, \"cannot move control node\");\n@@ -98,1 +100,1 @@\n-    return;\n+    return; \/\/ n is already placed above b, do nothing.\n@@ -100,1 +102,0 @@\n-  assert(b->dominates(current), \"sanity check: temp node placement\");\n@@ -104,1 +105,2 @@\n-  move_into(n, b);\n+  assert(b->dominates(current), \"precondition: can only move n to b if b dominates n\");\n+  move_node_and_its_projections_to_block(n, b);\n@@ -357,0 +359,3 @@\n+        \/\/ MachTemp nodes have no inputs themselves and are only used to reserve\n+        \/\/ a scratch register for the implementation of the node (e.g. in\n+        \/\/ late-expanded GC barriers).\n@@ -426,1 +431,2 @@\n-        maybe_hoist_into(val->in(i), block);\n+        \/\/ Inputs of val may already be early enough, but if not move them together with val.\n+        ensure_node_is_at_block_or_above(val->in(i), block);\n@@ -428,1 +434,1 @@\n-      move_into(val, block);\n+      move_node_and_its_projections_to_block(val, block);\n@@ -438,1 +444,1 @@\n-    maybe_hoist_into(n, block);\n+    ensure_node_is_at_block_or_above(n, block);\n@@ -442,1 +448,1 @@\n-  move_into(best, block);\n+  move_node_and_its_projections_to_block(best, block);\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n- * @test id=G1\n- * @summary Test that implicit null checks are generated as expected for G1\n- *          memory accesses with barriers.\n+ * @test\n+ * @summary Test that implicit null checks are generated as expected for\n+            different GC memory accesses.\n@@ -40,11 +40,1 @@\n- * @requires vm.gc.G1\n- * @run driver compiler.gcbarriers.TestImplicitNullChecks G1\n- *\/\n-\n-\/**\n- * @test id=Z\n- * @summary Test that implicit null checks are generated as expected for ZGC\n-            memory accesses with barriers.\n- * @library \/test\/lib \/\n- * @requires vm.gc.Z\n- * @run driver compiler.gcbarriers.TestImplicitNullChecks Z\n+ * @run driver compiler.gcbarriers.TestImplicitNullChecks\n@@ -75,6 +65,0 @@\n-        if (args.length != 1) {\n-            throw new IllegalArgumentException();\n-        }\n-        if (!args[0].equals(\"G1\") && !args[0].equals(\"Z\")) {\n-            throw new IllegalArgumentException();\n-        }\n@@ -82,2 +66,1 @@\n-                                   \"-XX:-TieredCompilation\",\n-                                   \"-XX:+Use\" + args[0] + \"GC\");\n+                                   \"-XX:-TieredCompilation\");\n@@ -87,1 +70,2 @@\n-    @IR(counts = {IRNode.NULL_CHECK, \"1\"},\n+    @IR(applyIfOr = {\"UseZGC\", \"true\", \"UseG1GC\", \"true\"},\n+        counts = {IRNode.NULL_CHECK, \"1\"},\n@@ -97,0 +81,1 @@\n+        applyIfOr = {\"UseZGC\", \"true\", \"UseG1GC\", \"true\"},\n@@ -141,1 +126,2 @@\n-    @IR(failOn = IRNode.NULL_CHECK,\n+    @IR(applyIfOr = {\"UseZGC\", \"true\", \"UseG1GC\", \"true\"},\n+        failOn = IRNode.NULL_CHECK,\n@@ -162,1 +148,2 @@\n-    @IR(failOn = IRNode.NULL_CHECK,\n+    @IR(applyIfOr = {\"UseZGC\", \"true\", \"UseG1GC\", \"true\"},\n+        failOn = IRNode.NULL_CHECK,\n@@ -169,1 +156,2 @@\n-    @IR(failOn = IRNode.NULL_CHECK,\n+    @IR(applyIfOr = {\"UseZGC\", \"true\", \"UseG1GC\", \"true\"},\n+        failOn = IRNode.NULL_CHECK,\n@@ -176,1 +164,2 @@\n-    @IR(failOn = IRNode.NULL_CHECK,\n+    @IR(applyIfOr = {\"UseZGC\", \"true\", \"UseG1GC\", \"true\"},\n+        failOn = IRNode.NULL_CHECK,\n@@ -210,1 +199,1 @@\n-    @IR(applyIf = {\"UseG1GC\", \"false\"},\n+    @IR(applyIf = {\"UseZGC\", \"true\"},\n@@ -218,1 +207,1 @@\n-    @IR(applyIf = {\"UseG1GC\", \"false\"},\n+    @IR(applyIf = {\"UseZGC\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestImplicitNullChecks.java","additions":18,"deletions":29,"binary":false,"changes":47,"status":"modified"}]}