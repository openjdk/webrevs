{"files":[{"patch":"@@ -134,1 +134,2 @@\n-    return !Address::offset_ok_for_immed(a.offset(), exact_log2(size));\n+    return a.getMode() == Address::base_plus_offset &&\n+           !Address::offset_ok_for_immed(a.offset(), exact_log2(size));\n@@ -140,7 +141,5 @@\n-    if (a.getMode() == Address::base_plus_offset) {\n-      if (legitimize_address_requires_lea(a, size)) {\n-        block_comment(\"legitimize_address {\");\n-        lea(scratch, a);\n-        block_comment(\"} legitimize_address\");\n-        return Address(scratch);\n-      }\n+    if (legitimize_address_requires_lea(a, size)) {\n+      block_comment(\"legitimize_address {\");\n+      lea(scratch, a);\n+      block_comment(\"} legitimize_address\");\n+      return Address(scratch);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -80,1 +80,3 @@\n-    @IR(applyIfPlatform = {\"aarch64\", \"false\"},\n+    \/\/ On PPC64, volatile loads are preceded by membar_volatile instructions,\n+    \/\/ which also inhibits the current C2 analysis.\n+    @IR(applyIfPlatformAnd = {\"aarch64\", \"false\", \"ppc\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestImplicitNullChecks.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}