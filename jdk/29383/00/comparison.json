{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -224,0 +225,1 @@\n+      const Register t1_hash = t1;\n@@ -226,0 +228,5 @@\n+      \/\/ Save the mark, we might need it to extract the hash.\n+      mov(rscratch2, t1_mark);\n+\n+      \/\/ Look for the monitor in the om_cache.\n+\n@@ -229,1 +236,1 @@\n-      const int num_unrolled = 2;\n+      const int num_unrolled = OMCache::CAPACITY;\n@@ -231,2 +238,3 @@\n-        ldr(t1, Address(t3_t));\n-        cmp(obj, t1);\n+        ldr(t2, Address(t3_t));\n+        ldr(t1_monitor, Address(t3_t, OMCache::oop_to_monitor_difference()));\n+        cmp(obj, t2);\n@@ -237,1 +245,11 @@\n-      Label loop;\n+      \/\/ Look for the monitor in the table.\n+\n+      \/\/ Get the hash code.\n+      ubfx(t1_hash, rscratch2, markWord::hash_shift, markWord::hash_bits);\n+\n+      \/\/ Get the table and calculate the bucket's address\n+      lea(t3, ExternalAddress(ObjectMonitorTable::current_table_address()));\n+      ldr(t3, Address(t3));\n+      ldr(t2, Address(t3, ObjectMonitorTable::table_capacity_mask_offset()));\n+      ands(t1_hash, t1_hash, t2);\n+      ldr(t3, Address(t3, ObjectMonitorTable::table_buckets_offset()));\n@@ -239,2 +257,3 @@\n-      \/\/ Search for obj in cache.\n-      bind(loop);\n+      \/\/ Read the monitor from the bucket.\n+      lsl(t1_hash, t1_hash, LogBytesPerWord);\n+      ldr(t1_monitor, Address(t3, t1_hash));\n@@ -242,4 +261,3 @@\n-      \/\/ Check for match.\n-      ldr(t1, Address(t3_t));\n-      cmp(obj, t1);\n-      br(Assembler::EQ, monitor_found);\n+      \/\/ Check if the monitor in the bucket is special (empty, tombstone or removed).\n+      cmp(t1_monitor, (unsigned char)ObjectMonitorTable::SpecialPointerValues::below_is_special);\n+      br(Assembler::LT, slow_path);\n@@ -247,5 +265,6 @@\n-      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n-      increment(t3_t, in_bytes(OMCache::oop_to_oop_difference()));\n-      cbnz(t1, loop);\n-      \/\/ Cache Miss, NE set from cmp above, cbnz does not set flags\n-      b(slow_path);\n+      \/\/ Check if object matches.\n+      ldr(t3, Address(t1_monitor, ObjectMonitor::object_offset()));\n+      BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+      bs_asm->try_resolve_weak_handle_in_c2(this, t3, t2, slow_path);\n+      cmp(t3, obj);\n+      br(Assembler::NE, slow_path);\n@@ -254,1 +273,0 @@\n-      ldr(t1_monitor, Address(t3_t, OMCache::oop_to_monitor_difference()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -444,0 +444,5 @@\n+void BarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path) {\n+  \/\/ Load the oop from the weak handle.\n+  __ ldr(obj, Address(obj));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,1 @@\n+  virtual void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -449,0 +450,24 @@\n+#ifdef COMPILER2\n+void ShenandoahBarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj,\n+                                                                  Register tmp, Label& slow_path) {\n+  assert_different_registers(obj, tmp);\n+\n+  Label done;\n+\n+  \/\/ Resolve weak handle using the standard implementation.\n+  BarrierSetAssembler::try_resolve_weak_handle_in_c2(masm, obj, tmp, slow_path);\n+\n+  \/\/ Check if the reference is null, and if it is, take the fast path.\n+  __ cbz(obj, done);\n+\n+  Address gc_state(rthread, ShenandoahThreadLocalData::gc_state_offset());\n+  __ lea(tmp, gc_state);\n+  __ ldrb(tmp, Address(tmp));\n+\n+  \/\/ Check if the heap is under weak-reference\/roots processing, in\n+  \/\/ which case we need to take the slow path.\n+  __ tbnz(tmp, ShenandoahHeap::WEAK_ROOTS_BITPOS, slow_path);\n+  __ bind(done);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +90,3 @@\n+#ifdef COMPILER2\n+  virtual void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1329,0 +1329,17 @@\n+#undef __\n+#define __ masm->\n+\n+void ZBarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path) {\n+  \/\/ Resolve weak handle using the standard implementation.\n+  BarrierSetAssembler::try_resolve_weak_handle_in_c2(masm, obj, tmp, slow_path);\n+\n+  \/\/ Check if the oop is bad, in which case we need to take the slow path.\n+  __ relocate(barrier_Relocation::spec(), ZBarrierRelocationFormatMarkBadBeforeMov);\n+  __ movzw(tmp, barrier_Relocation::unpatched);\n+  __ tst(obj, tmp);\n+  __ br(Assembler::NE, slow_path);\n+\n+  \/\/ Oop is okay, so we uncolor it.\n+  __ lsr(obj, obj, ZPointerLoadShift);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,0 +194,1 @@\n+  void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,0 +278,5 @@\n+void BarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path) {\n+  \/\/ Load the oop from the weak handle.\n+  __ ld(obj, 0, obj);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,2 @@\n+  virtual void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj,\n+                                             Register tmp, Label& slow_path);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -652,0 +653,27 @@\n+#ifdef COMPILER2\n+void ShenandoahBarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler *masm, Register obj,\n+                                                                  Register tmp, Label &slow_path) {\n+  __ block_comment(\"try_resolve_weak_handle_in_c2 (shenandoahgc) {\");\n+\n+  assert_different_registers(obj, tmp);\n+\n+  Label done;\n+\n+  \/\/ Resolve weak handle using the standard implementation.\n+  BarrierSetAssembler::try_resolve_weak_handle_in_c2(masm, obj, tmp, slow_path);\n+\n+  \/\/ Check if the reference is null, and if it is, take the fast path.\n+  __ cmpdi(CR0, obj, 0);\n+  __ beq(CR0, done);\n+\n+  \/\/ Check if the heap is under weak-reference\/roots processing, in\n+  \/\/ which case we need to take the slow path.\n+  __ lbz(tmp, in_bytes(ShenandoahThreadLocalData::gc_state_offset()), R16_thread);\n+  __ andi_(tmp, tmp, ShenandoahHeap::WEAK_ROOTS);\n+  __ bne(CR0, slow_path);\n+  __ bind(done);\n+\n+  __ block_comment(\"} try_resolve_weak_handle_in_c2 (shenandoahgc)\");\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +125,3 @@\n+#ifdef COMPILER2\n+  virtual void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path);\n+#endif\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -953,0 +953,13 @@\n+void ZBarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path) {\n+  \/\/ Resolve weak handle using the standard implementation.\n+  BarrierSetAssembler::try_resolve_weak_handle_in_c2(masm, obj, tmp, slow_path);\n+\n+  \/\/ Check if the oop is bad, in which case we need to take the slow path.\n+  __ ld(tmp, in_bytes(ZThreadLocalData::mark_bad_mask_offset()), R16_thread);\n+  __ and_(tmp, obj, tmp);\n+  __ bne(CR0, slow_path);\n+\n+  \/\/ Oop is okay, so we uncolor it.\n+  __ srdi(obj, obj, ZPointerLoadShift);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,0 +111,2 @@\n+\n+  void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2759,0 +2759,3 @@\n+      const Register cache_addr = tmp3;\n+      const Register tmp3_bucket = tmp3;\n+      const Register tmp2_hash = tmp2;\n@@ -2760,1 +2763,5 @@\n-      Register cache_addr = tmp2;\n+\n+      \/\/ Save the mark, we might need it to extract the hash.\n+      mr(tmp2_hash, mark);\n+\n+      \/\/ Look for the monitor in the om_cache.\n@@ -2765,1 +2772,1 @@\n-      const int num_unrolled = 2;\n+      const int num_unrolled = OMCache::CAPACITY;\n@@ -2768,0 +2775,1 @@\n+        ld(monitor, in_bytes(OMCache::oop_to_monitor_difference()), cache_addr);\n@@ -2773,1 +2781,13 @@\n-      Label loop;\n+      \/\/ Look for the monitor in the table.\n+\n+      \/\/ Get the hash code.\n+      srdi(tmp2_hash, tmp2_hash, markWord::hash_shift);\n+\n+      \/\/ Get the table and calculate the bucket's address\n+      load_const_optimized(tmp3, ObjectMonitorTable::current_table_address(), R0);\n+      ld_ptr(tmp3, 0, tmp3);\n+      ld(tmp1, in_bytes(ObjectMonitorTable::table_capacity_mask_offset()), tmp3);\n+      andr(tmp2_hash, tmp2_hash, tmp1);\n+      ld(tmp3, in_bytes(ObjectMonitorTable::table_buckets_offset()), tmp3);\n+      sldi(tmp2_hash, tmp2_hash, LogBytesPerWord);\n+      add(tmp3_bucket, tmp3, tmp2_hash);\n@@ -2775,2 +2795,2 @@\n-      \/\/ Search for obj in cache.\n-      bind(loop);\n+      \/\/ Read the monitor from the bucket.\n+      ld_ptr(monitor, 0, tmp3_bucket);\n@@ -2778,4 +2798,3 @@\n-      \/\/ Check for match.\n-      ld(R0, 0, cache_addr);\n-      cmpd(CR0, R0, obj);\n-      beq(CR0, monitor_found);\n+      \/\/ Check if the monitor in the bucket is special (empty, tombstone or removed).\n+      cmpdi(CR0, monitor, ObjectMonitorTable::SpecialPointerValues::below_is_special);\n+      blt(CR0, slow_path);\n@@ -2783,6 +2802,6 @@\n-      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n-      addi(cache_addr, cache_addr, in_bytes(OMCache::oop_to_oop_difference()));\n-      cmpdi(CR1, R0, 0);\n-      bne(CR1, loop);\n-      \/\/ Cache Miss, CR0.NE set from cmp above\n-      b(slow_path);\n+      \/\/ Check if object matches.\n+      ld(tmp3, in_bytes(ObjectMonitor::object_offset()), monitor);\n+      BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+      bs_asm->try_resolve_weak_handle_in_c2(this, tmp3, tmp2, slow_path);\n+      cmpd(CR0, tmp3, obj);\n+      bne(CR0, slow_path);\n@@ -2791,1 +2810,0 @@\n-      ld(monitor, in_bytes(OMCache::oop_to_monitor_difference()), cache_addr);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -126,0 +127,2 @@\n+      const Register tmp2_hash = tmp2;\n+      const Register tmp3_bucket = tmp3;\n@@ -128,0 +131,5 @@\n+      \/\/ Save the mark, we might need it to extract the hash.\n+      mv(tmp2_hash, tmp1_mark);\n+\n+      \/\/ Look for the monitor in the om_cache.\n+\n@@ -131,1 +139,1 @@\n-      const int num_unrolled = 2;\n+      const int num_unrolled = OMCache::CAPACITY;\n@@ -133,2 +141,3 @@\n-        ld(tmp1, Address(tmp3_t));\n-        beq(obj, tmp1, monitor_found);\n+        ld(t0, Address(tmp3_t));\n+        ld(tmp1_monitor, Address(tmp3_t, OMCache::oop_to_monitor_difference()));\n+        beq(obj, t0, monitor_found);\n@@ -138,1 +147,13 @@\n-      Label loop;\n+      \/\/ Look for the monitor in the table.\n+\n+      \/\/ Get the hash code.\n+      srli(tmp2_hash, tmp2_hash, markWord::hash_shift);\n+\n+      \/\/ Get the table and calculate the bucket's address.\n+      la(tmp3_t, ExternalAddress(ObjectMonitorTable::current_table_address()));\n+      ld(tmp3_t, Address(tmp3_t));\n+      ld(tmp1, Address(tmp3_t, ObjectMonitorTable::table_capacity_mask_offset()));\n+      andr(tmp2_hash, tmp2_hash, tmp1);\n+      ld(tmp3_t, Address(tmp3_t, ObjectMonitorTable::table_buckets_offset()));\n+      slli(tmp2_hash, tmp2_hash, LogBytesPerWord);\n+      add(tmp3_bucket, tmp3_t, tmp2_hash);\n@@ -140,2 +161,2 @@\n-      \/\/ Search for obj in cache.\n-      bind(loop);\n+      \/\/ Read the monitor from the bucket.\n+      ld(tmp1_monitor, Address(tmp3_bucket));\n@@ -143,3 +164,3 @@\n-      \/\/ Check for match.\n-      ld(tmp1, Address(tmp3_t));\n-      beq(obj, tmp1, monitor_found);\n+      \/\/ Check if the monitor in the bucket is special (empty, tombstone or removed).\n+      li(tmp2, ObjectMonitorTable::SpecialPointerValues::below_is_special);\n+      bltu(tmp1_monitor, tmp2, slow_path);\n@@ -147,5 +168,5 @@\n-      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n-      add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n-      bnez(tmp1, loop);\n-      \/\/ Cache Miss. Take the slowpath.\n-      j(slow_path);\n+      \/\/ Check if object matches.\n+      ld(tmp3, Address(tmp1_monitor, ObjectMonitor::object_offset()));\n+      BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+      bs_asm->try_resolve_weak_handle_in_c2(this, tmp3, tmp2, slow_path);\n+      bne(tmp3, obj, slow_path);\n@@ -154,1 +175,0 @@\n-      ld(tmp1_monitor, Address(tmp3_t, OMCache::oop_to_monitor_difference()));\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":36,"deletions":16,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,0 +372,5 @@\n+void BarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path) {\n+  \/\/ Load the oop from the weak handle.\n+  __ ld(obj, Address(obj));\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,0 +113,2 @@\n+  virtual void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj,\n+                                             Register tmp, Label& slow_path);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -468,0 +469,23 @@\n+#ifdef COMPILER2\n+void ShenandoahBarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler *masm, Register obj,\n+                                                                  Register tmp, Label& slow_path) {\n+  Label done;\n+\n+  \/\/ Resolve weak handle using the standard implementation.\n+  BarrierSetAssembler::try_resolve_weak_handle_in_c2(masm, obj, tmp, slow_path);\n+\n+  \/\/ Check if the reference is null, and if it is, take the fast path.\n+  __ beqz(obj, done);\n+\n+  assert(obj != tmp, \"need tmp\");\n+  Address gc_state(xthread, ShenandoahThreadLocalData::gc_state_offset());\n+  __ lbu(tmp, gc_state);\n+\n+  \/\/ Check if the heap is under weak-reference\/roots processing, in\n+  \/\/ which case we need to take the slow path.\n+  __ test_bit(tmp, tmp, ShenandoahHeap::WEAK_ROOTS_BITPOS);\n+  __ bnez(tmp, slow_path);\n+  __ bind(done);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +95,3 @@\n-\n+#ifdef COMPILER2\n+  virtual void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path);\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -605,0 +605,19 @@\n+#ifdef COMPILER2\n+void ZBarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path) {\n+  BLOCK_COMMENT(\"ZBarrierSetAssembler::try_resolve_weak_handle_in_c2 {\");\n+\n+  \/\/ Resolve weak handle using the standard implementation.\n+  BarrierSetAssembler::try_resolve_weak_handle_in_c2(masm, obj, tmp, slow_path);\n+\n+  \/\/ Check if the oop is bad, in which case we need to take the slow path.\n+  __ ld(tmp, mark_bad_mask_from_thread(xthread));\n+  __ andr(tmp, obj, tmp);\n+  __ bnez(tmp, slow_path);\n+\n+  \/\/ Oop is okay, so we uncolor it.\n+  __ srli(obj, obj, ZPointerLoadShift);\n+\n+  BLOCK_COMMENT(\"} ZBarrierSetAssembler::try_resolve_weak_handle_in_c2\");\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,0 +173,4 @@\n+  void try_resolve_weak_handle_in_c2(MacroAssembler* masm,\n+                                     Register obj,\n+                                     Register tmp,\n+                                     Label& slow_path);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,0 +209,5 @@\n+void BarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Register tmp, Label& slow_path) {\n+  \/\/ Load the oop from the weak handle.\n+  __ z_lg(obj, Address(obj));\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,2 @@\n+  virtual void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj,\n+                                             Register tmp, Label& slow_path);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -6375,0 +6375,3 @@\n+      const Register cache_addr = tmp2;\n+      const Register tmp1_bucket = tmp1;\n+      const Register hash  = Z_R0_scratch;\n@@ -6377,0 +6380,5 @@\n+      \/\/ Save the mark, we might need it to extract the hash.\n+      z_lgr(hash, mark);\n+\n+      \/\/ Look for the monitor in the om_cache.\n+\n@@ -6378,1 +6386,1 @@\n-      z_la(tmp1, Address(Z_thread, JavaThread::om_cache_oops_offset()));\n+      z_la(cache_addr, Address(Z_thread, JavaThread::om_cache_oops_offset()));\n@@ -6382,1 +6390,2 @@\n-        z_cg(obj, Address(tmp1));\n+        z_lg(tmp1_monitor, Address(cache_addr, OMCache::oop_to_monitor_difference()));\n+        z_cg(obj, Address(cache_addr));\n@@ -6384,1 +6393,1 @@\n-        add2reg(tmp1, in_bytes(OMCache::oop_to_oop_difference()));\n+        add2reg(cache_addr, in_bytes(OMCache::oop_to_oop_difference()));\n@@ -6387,2 +6396,2 @@\n-      NearLabel loop;\n-      \/\/ Search for obj in cache\n+      \/\/ Get the hash code.\n+      z_srlg(hash, hash, markWord::hash_shift);\n@@ -6390,1 +6399,8 @@\n-      bind(loop);\n+      \/\/ Get the table and calculate the bucket's address.\n+      load_const_optimized(tmp2, ObjectMonitorTable::current_table_address());\n+      z_lg(tmp2, Address(tmp2));\n+      z_lg(tmp1, Address(tmp2, ObjectMonitorTable::table_capacity_mask_offset()));\n+      z_ngr(hash, tmp1);\n+      z_lg(tmp1, Address(tmp2, ObjectMonitorTable::table_buckets_offset()));\n+      z_sllg(hash, hash, LogBytesPerWord);\n+      z_agr(tmp1_bucket, hash);\n@@ -6392,3 +6408,2 @@\n-      \/\/ check for match.\n-      z_cg(obj, Address(tmp1));\n-      z_bre(monitor_found);\n+      \/\/ Read the monitor from the bucket.\n+      z_lg(tmp1_monitor, Address(tmp1_bucket));\n@@ -6396,4 +6411,3 @@\n-      \/\/ search until null encountered, guaranteed _null_sentinel at end.\n-      add2reg(tmp1, in_bytes(OMCache::oop_to_oop_difference()));\n-      z_cghsi(0, tmp1, 0);\n-      z_brne(loop); \/\/ if not EQ to 0, go for another loop\n+      \/\/ Check if the monitor in the bucket is special (empty, tombstone or removed).\n+      z_cghi(tmp1_monitor, ObjectMonitorTable::SpecialPointerValues::below_is_special);\n+      z_brl(slow_path);\n@@ -6401,3 +6415,6 @@\n-      \/\/ we reached to the end, cache miss\n-      z_ltgr(obj, obj); \/\/ set CC to NE\n-      z_bru(slow_path);\n+      \/\/ Check if object matches.\n+      z_lg(tmp2, Address(tmp1_monitor, ObjectMonitor::object_offset()));\n+      BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+      bs_asm->try_resolve_weak_handle_in_c2(this, tmp2, Z_R0_scratch, slow_path);\n+      z_cgr(obj, tmp2);\n+      z_brne(slow_path);\n@@ -6405,1 +6422,0 @@\n-      \/\/ cache hit\n@@ -6407,1 +6423,0 @@\n-      z_lg(tmp1_monitor, Address(tmp1, OMCache::oop_to_monitor_difference()));\n@@ -6412,2 +6427,0 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":34,"deletions":21,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -220,1 +221,0 @@\n-\n@@ -289,1 +289,1 @@\n-    jmpb(locked);\n+    jmp(locked);\n@@ -300,2 +300,1 @@\n-      \/\/ Uses ObjectMonitorTable.  Look for the monitor in the om_cache.\n-      \/\/ Fetch ObjectMonitor* from the cache or take the slow-path.\n+      const Register hash = t;\n@@ -304,0 +303,2 @@\n+      \/\/ Look for the monitor in the om_cache.\n+\n@@ -305,1 +306,1 @@\n-      lea(t, Address(thread, JavaThread::om_cache_oops_offset()));\n+      lea(rax_reg, Address(thread, JavaThread::om_cache_oops_offset()));\n@@ -307,1 +308,1 @@\n-      const int num_unrolled = 2;\n+      const int num_unrolled = OMCache::CAPACITY;\n@@ -309,1 +310,2 @@\n-        cmpptr(obj, Address(t));\n+        movptr(monitor, Address(rax_reg, OMCache::oop_to_monitor_difference()));\n+        cmpptr(obj, Address(rax_reg));\n@@ -311,1 +313,1 @@\n-        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+        increment(rax_reg, in_bytes(OMCache::oop_to_oop_difference()));\n@@ -314,1 +316,1 @@\n-      Label loop;\n+      \/\/ Look for the monitor in the table.\n@@ -316,2 +318,4 @@\n-      \/\/ Search for obj in cache.\n-      bind(loop);\n+      \/\/ Get the hash code.\n+      movptr(hash, Address(obj, oopDesc::mark_offset_in_bytes()));\n+      shrq(hash, markWord::hash_shift);\n+      andq(hash, markWord::hash_mask);\n@@ -319,3 +323,5 @@\n-      \/\/ Check for match.\n-      cmpptr(obj, Address(t));\n-      jccb(Assembler::equal, monitor_found);\n+      \/\/ Get the table and calculate the bucket's address.\n+      lea(rax_reg, ExternalAddress(ObjectMonitorTable::current_table_address()));\n+      movptr(rax_reg, Address(rax_reg));\n+      andq(hash, Address(rax_reg, ObjectMonitorTable::table_capacity_mask_offset()));\n+      movptr(rax_reg, Address(rax_reg, ObjectMonitorTable::table_buckets_offset()));\n@@ -323,5 +329,13 @@\n-      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n-      cmpptr(Address(t), 1);\n-      jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n-      increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n-      jmpb(loop);\n+      \/\/ Read the monitor from the bucket.\n+      movptr(monitor, Address(rax_reg, hash, Address::times_ptr));\n+\n+      \/\/ Check if the monitor in the bucket is special (empty, tombstone or removed)\n+      cmpptr(monitor, ObjectMonitorTable::SpecialPointerValues::below_is_special);\n+      jcc(Assembler::below, slow_path);\n+\n+      \/\/ Check if object matches.\n+      movptr(rax_reg, Address(monitor, ObjectMonitor::object_offset()));\n+      BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+      bs_asm->try_resolve_weak_handle_in_c2(this, rax_reg, slow_path);\n+      cmpptr(rax_reg, obj);\n+      jcc(Assembler::notEqual, slow_path);\n@@ -329,1 +343,0 @@\n-      \/\/ Cache hit.\n@@ -331,1 +344,0 @@\n-      movptr(monitor, Address(t, OMCache::oop_to_monitor_difference()));\n@@ -490,1 +502,1 @@\n-    jccb(Assembler::notEqual, inflated_check_lock_stack);\n+    jcc(Assembler::notEqual, inflated_check_lock_stack);\n@@ -497,1 +509,1 @@\n-    jccb(Assembler::notZero, inflated);\n+    jcc(Assembler::notZero, inflated);\n@@ -522,1 +534,1 @@\n-    jccb(Assembler::notZero, recursive);\n+    jcc(Assembler::notZero, recursive);\n@@ -533,1 +545,1 @@\n-    jccb(Assembler::zero, unlocked);    \/\/ If so we are done.\n+    jcc(Assembler::zero, unlocked);    \/\/ If so we are done.\n@@ -537,1 +549,1 @@\n-    jccb(Assembler::notZero, unlocked); \/\/ If so we are done.\n+    jcc(Assembler::notZero, unlocked); \/\/ If so we are done.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -398,0 +398,5 @@\n+void BarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Label& slowpath) {\n+  \/\/ Load the oop from the weak handle.\n+  __ movptr(obj, Address(obj));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,2 @@\n+\n+  virtual void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Label& slowpath);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -632,0 +633,21 @@\n+#ifdef COMPILER2\n+void ShenandoahBarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Label& slowpath) {\n+  Label done;\n+\n+  \/\/ Resolve weak handle using the standard implementation.\n+  BarrierSetAssembler::try_resolve_weak_handle_in_c2(masm, obj, slowpath);\n+\n+  \/\/ Check if the reference is null, and if it is, take the fast path.\n+  __ testptr(obj, obj);\n+  __ jcc(Assembler::zero, done);\n+\n+  Address gc_state(r15_thread, ShenandoahThreadLocalData::gc_state_offset());\n+\n+  \/\/ Check if the heap is under weak-reference\/roots processing, in\n+  \/\/ which case we need to take the slow path.\n+  __ testb(gc_state, ShenandoahHeap::WEAK_ROOTS);\n+  __ jccb(Assembler::notZero, slowpath);\n+  __ bind(done);\n+}\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +88,3 @@\n+#ifdef COMPILER2\n+  virtual void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Label& slowpath);\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1331,0 +1331,13 @@\n+void ZBarrierSetAssembler::try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Label& slow_path) {\n+  \/\/ Resolve weak handle using the standard implementation.\n+  BarrierSetAssembler::try_resolve_weak_handle_in_c2(masm, obj, slow_path);\n+\n+  \/\/ Check if the oop is bad, in which case we need to take the slow path.\n+  __ testptr(obj, Address(r15_thread, ZThreadLocalData::mark_bad_mask_offset()));\n+  __ jcc(Assembler::notZero, slow_path);\n+\n+  \/\/ Oop is okay, so we uncolor it.\n+  __ relocate(barrier_Relocation::spec(), ZBarrierRelocationFormatLoadGoodBeforeShl);\n+  __ shrq(obj, barrier_Relocation::unpatched);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,0 +170,2 @@\n+\n+  virtual void try_resolve_weak_handle_in_c2(MacroAssembler* masm, Register obj, Label& slow_path);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-  static constexpr int CAPACITY = 8;\n+  static constexpr int CAPACITY = 2;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,0 +221,1 @@\n+  static ByteSize object_offset()      { return byte_offset_of(ObjectMonitor, _object); }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-using ConcurrentTable = ConcurrentHashTable<ObjectMonitorTableConfig, mtObjectMonitor>;\n+ObjectMonitorTable::Table* volatile ObjectMonitorTable::_curr;\n@@ -42,4 +42,2 @@\n-static ConcurrentTable* _table = nullptr;\n-static volatile size_t _items_count = 0;\n-static size_t _table_size = 0;\n-static volatile bool _resize = false;\n+class ObjectMonitorTable::Table : public CHeapObj<mtObjectMonitor> {\n+  friend class ObjectMonitorTable;\n@@ -47,5 +45,10 @@\n-class ObjectMonitorTableConfig : public AllStatic {\n- public:\n-  using Value = ObjectMonitor*;\n-  static uintx get_hash(Value const& value, bool* is_dead) {\n-    return (uintx)value->hash();\n+  const size_t _capacity_mask;       \/\/ One less than its power-of-two capacity\n+  Table* volatile _prev;             \/\/ Set while rehashing\n+  ObjectMonitor* volatile* _buckets; \/\/ The payload\n+\n+  char _padding[DEFAULT_CACHE_LINE_SIZE];\n+\n+  volatile size_t _items_count;\n+\n+  static ObjectMonitor* tombstone() {\n+    return (ObjectMonitor*)ObjectMonitorTable::SpecialPointerValues::tombstone;\n@@ -53,7 +56,3 @@\n-  static void* allocate_node(void* context, size_t size, Value const& value) {\n-    ObjectMonitorTable::inc_items_count();\n-    return AllocateHeap(size, mtObjectMonitor);\n-  };\n-  static void free_node(void* context, void* memory, Value const& value) {\n-    ObjectMonitorTable::dec_items_count();\n-    FreeHeap(memory);\n+\n+  static ObjectMonitor* removed_entry() {\n+    return (ObjectMonitor*)ObjectMonitorTable::SpecialPointerValues::removed;\n@@ -61,1 +60,0 @@\n-};\n@@ -63,2 +61,12 @@\n-class Lookup : public StackObj {\n-  oop _obj;\n+  \/\/ Make sure we leave space for previous versions to relocate too.\n+  bool try_inc_items_count() {\n+    for (;;) {\n+      size_t population = AtomicAccess::load(&_items_count);\n+      if (should_grow(population)) {\n+        return false;\n+      }\n+      if (AtomicAccess::cmpxchg(&_items_count, population, population + 1, memory_order_relaxed) == population) {\n+        return true;\n+      }\n+    }\n+  }\n@@ -66,2 +74,3 @@\n- public:\n-  explicit Lookup(oop obj) : _obj(obj) {}\n+  double get_load_factor(size_t count) {\n+    return (double)count \/ (double)capacity();\n+  }\n@@ -69,4 +78,2 @@\n-  uintx get_hash() const {\n-    uintx hash = _obj->mark().hash();\n-    assert(hash != 0, \"should have a hash\");\n-    return hash;\n+  void inc_items_count() {\n+    AtomicAccess::inc(&_items_count, memory_order_relaxed);\n@@ -75,3 +82,2 @@\n-  bool equals(ObjectMonitor** value) {\n-    assert(*value != nullptr, \"must be\");\n-    return (*value)->object_refers_to(_obj);\n+  void dec_items_count() {\n+    AtomicAccess::dec(&_items_count, memory_order_relaxed);\n@@ -80,3 +86,10 @@\n-  bool is_dead(ObjectMonitor** value) {\n-    assert(*value != nullptr, \"must be\");\n-    return false;\n+public:\n+  Table(size_t capacity, Table* prev)\n+    : _capacity_mask(capacity - 1),\n+      _prev(prev),\n+      _buckets(NEW_C_HEAP_ARRAY(ObjectMonitor*, capacity, mtObjectMonitor)),\n+      _items_count(0)\n+  {\n+    for (size_t i = 0; i < capacity; ++i) {\n+      _buckets[i] = nullptr;\n+    }\n@@ -84,1 +97,0 @@\n-};\n@@ -86,2 +98,3 @@\n-class LookupMonitor : public StackObj {\n-  ObjectMonitor* _monitor;\n+  ~Table() {\n+    FREE_C_HEAP_ARRAY(ObjectMonitor*, _buckets);\n+  }\n@@ -89,2 +102,3 @@\n- public:\n-  explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n+  Table* prev() {\n+    return AtomicAccess::load(&_prev);\n+  }\n@@ -92,2 +106,2 @@\n-  uintx get_hash() const {\n-    return _monitor->hash();\n+  size_t capacity() {\n+    return _capacity_mask + 1;\n@@ -96,2 +110,2 @@\n-  bool equals(ObjectMonitor** value) {\n-    return (*value) == _monitor;\n+  bool should_grow(size_t population) {\n+    return get_load_factor(population) > GROW_LOAD_FACTOR;\n@@ -100,3 +114,2 @@\n-  bool is_dead(ObjectMonitor** value) {\n-    assert(*value != nullptr, \"must be\");\n-    return (*value)->object_is_dead();\n+  bool should_grow() {\n+    return should_grow(AtomicAccess::load(&_items_count));\n@@ -104,1 +117,0 @@\n-};\n@@ -106,3 +118,9 @@\n-void ObjectMonitorTable::inc_items_count() {\n-  AtomicAccess::inc(&_items_count, memory_order_relaxed);\n-}\n+  ObjectMonitor* get(oop obj, int hash) {\n+    \/\/ Acquire tombstones and relocations in case prev transitioned to null\n+    Table* prev = AtomicAccess::load_acquire(&_prev);\n+    if (prev != nullptr) {\n+      ObjectMonitor* result = prev->get(obj, hash);\n+      if (result != nullptr) {\n+        return result;\n+      }\n+    }\n@@ -110,3 +128,2 @@\n-void ObjectMonitorTable::dec_items_count() {\n-  AtomicAccess::dec(&_items_count, memory_order_relaxed);\n-}\n+    const size_t start_index = size_t(hash) & _capacity_mask;\n+    size_t index = start_index;\n@@ -114,4 +131,3 @@\n-double ObjectMonitorTable::get_load_factor() {\n-  size_t count = AtomicAccess::load(&_items_count);\n-  return (double)count \/ (double)_table_size;\n-}\n+    for (;;) {\n+      ObjectMonitor* volatile* bucket = _buckets + index;\n+      ObjectMonitor* monitor = AtomicAccess::load(bucket);\n@@ -119,3 +135,4 @@\n-size_t ObjectMonitorTable::table_size(Thread* current) {\n-  return ((size_t)1) << _table->get_size_log2(current);\n-}\n+      if (monitor == tombstone() || monitor == nullptr) {\n+        \/\/ Not found\n+        break;\n+      }\n@@ -123,12 +140,5 @@\n-size_t ObjectMonitorTable::max_log_size() {\n-  \/\/ TODO[OMTable]: Evaluate the max size.\n-  \/\/ TODO[OMTable]: Need to fix init order to use Universe::heap()->max_capacity();\n-  \/\/                Using MaxHeapSize directly this early may be wrong, and there\n-  \/\/                are definitely rounding errors (alignment).\n-  const size_t max_capacity = MaxHeapSize;\n-  const size_t min_object_size = CollectedHeap::min_dummy_object_size() * HeapWordSize;\n-  const size_t max_objects = max_capacity \/ MAX2(MinObjAlignmentInBytes, checked_cast<int>(min_object_size));\n-  const size_t log_max_objects = log2i_graceful(max_objects);\n-\n-  return MAX2(MIN2<size_t>(SIZE_BIG_LOG2, log_max_objects), min_log_size());\n-}\n+      if (monitor != removed_entry() && monitor->object_peek() == obj) {\n+        \/\/ Found matching monitor.\n+        OrderAccess::acquire();\n+        return monitor;\n+      }\n@@ -136,4 +146,6 @@\n-\/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n-size_t ObjectMonitorTable::min_log_size() {\n-  return 10;\n-}\n+      index = (index + 1) & _capacity_mask;\n+      if (index == start_index) {\n+        \/\/ Not found - wrap around.\n+        break;\n+      }\n+    }\n@@ -141,4 +153,4 @@\n-template<typename V>\n-size_t ObjectMonitorTable::clamp_log_size(V log_size) {\n-  return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n-}\n+    \/\/ Rehashing could have stareted by now, but if a monitor has been inserted in a\n+    \/\/ newer table, it was inserted after the get linearization point.\n+    return nullptr;\n+  }\n@@ -146,4 +158,9 @@\n-size_t ObjectMonitorTable::initial_log_size() {\n-  const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n-  return clamp_log_size(estimate);\n-}\n+  ObjectMonitor* get_set(oop obj, ObjectMonitor* new_monitor, int hash) {\n+    \/\/ Acquire any tombstones and relocations if prev transitioned to null.\n+    Table* prev = AtomicAccess::load_acquire(&_prev);\n+    if (prev != nullptr) {\n+      ObjectMonitor* result = prev->get_set(obj, new_monitor, hash);\n+      if (result != nullptr) {\n+        return result;\n+      }\n+    }\n@@ -151,3 +168,31 @@\n-size_t ObjectMonitorTable::grow_hint() {\n-  return ConcurrentTable::DEFAULT_GROW_HINT;\n-}\n+    const size_t start_index = size_t(hash) & _capacity_mask;\n+    size_t index = start_index;\n+\n+    for (;;) {\n+      ObjectMonitor* volatile* bucket = _buckets + index;\n+      ObjectMonitor* monitor = AtomicAccess::load(bucket);\n+\n+      if (monitor == nullptr) {\n+        \/\/ Empty slot to install the new monitor.\n+        if (try_inc_items_count()) {\n+          \/\/ Succeeding in claiming an item.\n+          ObjectMonitor* result = AtomicAccess::cmpxchg(bucket, monitor, new_monitor, memory_order_release);\n+          if (result == monitor) {\n+            \/\/ Success - already incremented.\n+            return new_monitor;\n+          }\n+\n+          \/\/ Something else was installed in place.\n+          dec_items_count();\n+          monitor = result;\n+        } else {\n+          \/\/ Out of allowance; leaving place for rehashing to succeed.\n+          \/\/ To avoid concurrent inserts succeeding, place a tombstone here.\n+          ObjectMonitor* result = AtomicAccess::cmpxchg(bucket, monitor, tombstone());\n+          if (result == monitor) {\n+            \/\/ Success; nobody will try to insert here again, except reinsert from rehashing.\n+            return nullptr;\n+          }\n+          monitor = result;\n+        }\n+      }\n@@ -155,6 +200,4 @@\n-void ObjectMonitorTable::create() {\n-  _table = new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint());\n-  _items_count = 0;\n-  _table_size = table_size(Thread::current());\n-  _resize = false;\n-}\n+      if (monitor == tombstone()) {\n+        \/\/ Can't insert into this table.\n+        return nullptr;\n+      }\n@@ -162,7 +205,11 @@\n-void ObjectMonitorTable::verify_monitor_get_result(oop obj, ObjectMonitor* monitor) {\n-#ifdef ASSERT\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    bool has_monitor = obj->mark().has_monitor();\n-    assert(has_monitor == (monitor != nullptr),\n-           \"Inconsistency between markWord and ObjectMonitorTable has_monitor: %s monitor: \" PTR_FORMAT,\n-           BOOL_TO_STR(has_monitor), p2i(monitor));\n+      if (monitor != removed_entry() && monitor->object_peek() == obj) {\n+        \/\/ Found matching monitor.\n+        return monitor;\n+      }\n+\n+      index = (index + 1) & _capacity_mask;\n+      if (index == start_index) {\n+        \/\/ No slot to install in this table.\n+        return nullptr;\n+      }\n+    }\n@@ -170,2 +217,0 @@\n-#endif\n-}\n@@ -173,11 +218,18 @@\n-ObjectMonitor* ObjectMonitorTable::monitor_get(Thread* current, oop obj) {\n-  ObjectMonitor* result = nullptr;\n-  Lookup lookup_f(obj);\n-  auto found_f = [&](ObjectMonitor** found) {\n-    assert((*found)->object_peek() == obj, \"must be\");\n-    result = *found;\n-  };\n-  _table->get(current, lookup_f, found_f);\n-  verify_monitor_get_result(obj, result);\n-  return result;\n-}\n+  void remove(oop obj, ObjectMonitor* old_monitor, int hash) {\n+    \/\/ Acquire any tombstones and relocations if prev transitioned to null.\n+    Table* prev = AtomicAccess::load_acquire(&_prev);\n+    if (prev != nullptr) {\n+      prev->remove(obj, old_monitor, hash);\n+    }\n+\n+    const size_t start_index = size_t(hash) & _capacity_mask;\n+    size_t index = start_index;\n+\n+    for (;;) {\n+      ObjectMonitor* volatile* bucket = _buckets + index;\n+      ObjectMonitor* monitor = AtomicAccess::load(bucket);\n+\n+      if (monitor == nullptr) {\n+        \/\/ Monitor does not exist in this table.\n+        return;\n+      }\n@@ -185,6 +237,11 @@\n-void ObjectMonitorTable::try_notify_grow() {\n-  if (!_table->is_max_size_reached() && !AtomicAccess::load(&_resize)) {\n-    AtomicAccess::store(&_resize, true);\n-    if (Service_lock->try_lock()) {\n-      Service_lock->notify();\n-      Service_lock->unlock();\n+      if (monitor == old_monitor) {\n+        \/\/ Found matching entry; remove it.\n+        AtomicAccess::cmpxchg(bucket, monitor, removed_entry());\n+        return;\n+      }\n+\n+      index = (index + 1) & _capacity_mask;\n+      if (index == start_index) {\n+        \/\/ Not found\n+        return;\n+      }\n@@ -193,1 +250,0 @@\n-}\n@@ -195,3 +251,2 @@\n-bool ObjectMonitorTable::should_grow() {\n-  return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n-}\n+  void reinsert(oop obj, ObjectMonitor* new_monitor) {\n+    int hash = obj->mark().hash();\n@@ -199,3 +254,37 @@\n-bool ObjectMonitorTable::should_resize() {\n-  return should_grow() || should_shrink() || AtomicAccess::load(&_resize);\n-}\n+    const size_t start_index = size_t(hash) & _capacity_mask;\n+    size_t index = start_index;\n+\n+    for (;;) {\n+      ObjectMonitor* volatile* bucket = _buckets + index;\n+      ObjectMonitor* monitor = AtomicAccess::load(bucket);\n+\n+      if (monitor == nullptr) {\n+        \/\/ Empty slot to install the new monitor.\n+        ObjectMonitor* result = AtomicAccess::cmpxchg(bucket, monitor, new_monitor, memory_order_release);\n+        if (result == monitor) {\n+          \/\/ Success - unconditionally increment.\n+          inc_items_count();\n+          return;\n+        }\n+\n+        \/\/ Another monitor was installed.\n+        monitor = result;\n+      }\n+\n+      if (monitor == tombstone()) {\n+        \/\/ A concurrent inserter did not get enough allowance in the table.\n+        \/\/ But reinsert always succeeds - we will take the spot.\n+        ObjectMonitor* result = AtomicAccess::cmpxchg(bucket, monitor, new_monitor, memory_order_release);\n+        if (result == monitor) {\n+          \/\/ Success - unconditionally increment.\n+          inc_items_count();\n+          return;\n+        }\n+\n+        \/\/ Another monitor was installed.\n+        monitor = result;\n+      }\n+\n+      assert(monitor != nullptr, \"invariant\");\n+      assert(monitor != tombstone(), \"invariant\");\n+      assert(monitor == removed_entry() || monitor->object_peek() != obj, \"invariant\");\n@@ -203,8 +292,21 @@\n-template <typename Task, typename... Args>\n-bool ObjectMonitorTable::run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n-  if (task.prepare(current)) {\n-    log_trace(monitortable)(\"Started to %s\", task_name);\n-    TraceTime timer(task_name, TRACETIME_LOG(Debug, monitortable, perf));\n-    while (task.do_task(current, args...)) {\n-      task.pause(current);\n-      {\n+      index = (index + 1) & _capacity_mask;\n+      assert(index != start_index, \"should never be full\");\n+    }\n+  }\n+\n+  void rebuild() {\n+    Table* prev = _prev;\n+    if (prev == nullptr) {\n+      \/\/ Base case for recursion - no previous version.\n+      return;\n+    }\n+\n+    \/\/ Finish rebuilding up to prev as target so we can use prev as source.\n+    prev->rebuild();\n+\n+    JavaThread* current = JavaThread::current();\n+\n+    \/\/ Relocate entries from prev after\n+    for (size_t index = 0; index <= prev->_capacity_mask; index++) {\n+      if ((index & 128) == 0) {\n+        \/\/ Poll for safepoints to improve time to safepoint\n@@ -213,1 +315,24 @@\n-      task.cont(current);\n+\n+      ObjectMonitor* volatile* bucket = prev->_buckets + index;\n+      ObjectMonitor* monitor = AtomicAccess::load(bucket);\n+\n+      if (monitor == nullptr) {\n+        \/\/ Empty slot; put a tombstone there.\n+        ObjectMonitor* result = AtomicAccess::cmpxchg(bucket, monitor, tombstone(), memory_order_relaxed);\n+        if (result == nullptr) {\n+          \/\/ Success; move to next entry.\n+          continue;\n+        }\n+\n+        \/\/ Concurrent insert; relocate.\n+        monitor = result;\n+      }\n+\n+      if (monitor != tombstone() && monitor != removed_entry()) {\n+        \/\/ A monitor\n+        oop obj = monitor->object_peek();\n+        if (!monitor->is_being_async_deflated() && obj != nullptr) {\n+          \/\/ Re-insert still live monitor.\n+          reinsert(obj, monitor);\n+        }\n+      }\n@@ -215,2 +340,3 @@\n-    task.done(current);\n-    return true;\n+\n+    \/\/ Unlink this table, releasing the tombstones and relocations.\n+    AtomicAccess::release_store(&_prev, (Table*)nullptr);\n@@ -218,1 +344,4 @@\n-  return false;\n+};\n+\n+void ObjectMonitorTable::create() {\n+  _curr = new Table(128, nullptr);\n@@ -221,6 +350,23 @@\n-bool ObjectMonitorTable::grow(JavaThread* current) {\n-  ConcurrentTable::GrowTask grow_task(_table);\n-  if (run_task(current, grow_task, \"Grow\")) {\n-    _table_size = table_size(current);\n-    log_info(monitortable)(\"Grown to size: %zu\", _table_size);\n-    return true;\n+ObjectMonitor* ObjectMonitorTable::monitor_get(Thread* current, oop obj) {\n+  const int hash = obj->mark().hash();\n+  Table* curr = AtomicAccess::load_acquire(&_curr);\n+\n+  return curr->get(obj, hash);\n+}\n+\n+\/\/ Returns a new table to try inserting into.\n+ObjectMonitorTable::Table *ObjectMonitorTable::grow_table(Table *curr) {\n+  Table *new_table = AtomicAccess::load(&_curr);\n+  if (new_table != curr) {\n+    \/\/ Table changed; no need to try further\n+    return new_table;\n+  }\n+\n+  new_table = new Table(curr->capacity() << 1, curr);\n+  Table *result =\n+      AtomicAccess::cmpxchg(&_curr, curr, new_table, memory_order_acq_rel);\n+  if (result == curr) {\n+    \/\/ Successfully started rehashing.\n+    log_info(monitorinflation)(\"Growing object monitor table\");\n+    ObjectSynchronizer::request_deflate_idle_monitors();\n+    return new_table;\n@@ -228,1 +374,5 @@\n-  return false;\n+\n+  \/\/ Somebody else started rehashing; restart in new table.\n+  delete new_table;\n+\n+  return result;\n@@ -231,8 +381,13 @@\n-bool ObjectMonitorTable::clean(JavaThread* current) {\n-  ConcurrentTable::BulkDeleteTask clean_task(_table);\n-  auto is_dead = [&](ObjectMonitor** monitor) {\n-    return (*monitor)->object_is_dead();\n-  };\n-  auto do_nothing = [&](ObjectMonitor** monitor) {};\n-  NativeHeapTrimmer::SuspendMark sm(\"ObjectMonitorTable\");\n-  return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n+ObjectMonitor* ObjectMonitorTable::monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n+  const int hash = obj->mark().hash();\n+  Table* curr = AtomicAccess::load_acquire(&_curr);\n+\n+  for (;;) {\n+    \/\/ Curr is the latest table and is reasonably loaded.\n+    ObjectMonitor* result = curr->get_set(obj, monitor, hash);\n+    if (result != nullptr) {\n+      return result;\n+      \/\/ Table rehashing started; try again in the new table\n+    }\n+    curr = grow_table(curr);\n+  }\n@@ -241,3 +396,11 @@\n-bool ObjectMonitorTable::resize(JavaThread* current) {\n-  LogTarget(Info, monitortable) lt;\n-  bool success = false;\n+void ObjectMonitorTable::remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n+  oop obj = monitor->object_peek();\n+  if (obj == nullptr) {\n+    \/\/ Defer removal until subsequent rebuilding.\n+    return;\n+  }\n+  const int hash = obj->mark().hash();\n+\n+  Table* curr = AtomicAccess::load_acquire(&_curr);\n+  curr->remove(obj, monitor, hash);\n+}\n@@ -245,6 +408,10 @@\n-  if (should_grow()) {\n-    lt.print(\"Start growing with load factor %f\", get_load_factor());\n-    success = grow(current);\n-  } else {\n-    if (!_table->is_max_size_reached() && AtomicAccess::load(&_resize)) {\n-      lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n+\/\/ Before handshake; rehash and unlink tables.\n+void ObjectMonitorTable::rebuild(GrowableArray<Table*>* delete_list) {\n+  Table* new_table;\n+  {\n+    Table* curr = AtomicAccess::load_acquire(&_curr);\n+    new_table = new Table(curr->capacity(), curr);\n+    Table* result = AtomicAccess::cmpxchg(&_curr, curr, new_table, memory_order_release);\n+    if (result != curr) {\n+      \/\/ Somebody else racingly started rehashing; try again.\n+      new_table = result;\n@@ -252,2 +419,0 @@\n-    lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n-    success = clean(current);\n@@ -256,1 +421,3 @@\n-  AtomicAccess::store(&_resize, false);\n+  for (Table* curr = new_table->prev(); curr != nullptr; curr = curr->prev()) {\n+    delete_list->append(curr);\n+  }\n@@ -258,1 +425,2 @@\n-  return success;\n+  \/\/ Rebuild with the new table as target.\n+  new_table->rebuild();\n@@ -261,13 +429,4 @@\n-ObjectMonitor* ObjectMonitorTable::monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n-  \/\/ Enter the monitor into the concurrent hashtable.\n-  ObjectMonitor* result = monitor;\n-  Lookup lookup_f(obj);\n-  auto found_f = [&](ObjectMonitor** found) {\n-    assert((*found)->object_peek() == obj, \"must be\");\n-    result = *found;\n-  };\n-  bool grow;\n-  _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n-  verify_monitor_get_result(obj, result);\n-  if (grow) {\n-    try_notify_grow();\n+\/\/ After handshake; destroy old tables\n+void ObjectMonitorTable::destroy(GrowableArray<Table*>* delete_list) {\n+  for (ObjectMonitorTable::Table* table: *delete_list) {\n+    delete table;\n@@ -275,1 +434,0 @@\n-  return result;\n@@ -278,3 +436,2 @@\n-bool ObjectMonitorTable::remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n-  LookupMonitor lookup_f(monitor);\n-  return _table->remove(current, lookup_f);\n+address ObjectMonitorTable::current_table_address() {\n+  return (address)(&_curr);\n@@ -283,8 +440,2 @@\n-bool ObjectMonitorTable::contains_monitor(Thread* current, ObjectMonitor* monitor) {\n-  LookupMonitor lookup_f(monitor);\n-  bool result = false;\n-  auto found_f = [&](ObjectMonitor** found) {\n-    result = true;\n-  };\n-  _table->get(current, lookup_f, found_f);\n-  return result;\n+ByteSize ObjectMonitorTable::table_capacity_mask_offset() {\n+  return byte_offset_of(Table, _capacity_mask);\n@@ -293,15 +444,2 @@\n-void ObjectMonitorTable::print_on(outputStream* st) {\n-  auto printer = [&] (ObjectMonitor** entry) {\n-    ObjectMonitor* om = *entry;\n-    oop obj = om->object_peek();\n-    st->print(\"monitor=\" PTR_FORMAT \", \", p2i(om));\n-    st->print(\"object=\" PTR_FORMAT, p2i(obj));\n-    assert(obj->mark().hash() == om->hash(), \"hash must match\");\n-    st->cr();\n-    return true;\n-  };\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    _table->do_safepoint_scan(printer);\n-  } else {\n-    _table->do_scan(Thread::current(), printer);\n-  }\n+ByteSize ObjectMonitorTable::table_buckets_offset() {\n+  return byte_offset_of(Table, _buckets);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitorTable.cpp","additions":343,"deletions":205,"binary":false,"changes":548,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/sizes.hpp\"\n@@ -32,0 +33,1 @@\n+template <typename T> class GrowableArray;\n@@ -39,1 +41,1 @@\n-  friend class ObjectMonitorTableConfig;\n+  static constexpr double GROW_LOAD_FACTOR = 0.125;\n@@ -41,7 +43,2 @@\n- private:\n-  static void inc_items_count();\n-  static void dec_items_count();\n-  static double get_load_factor();\n-  static size_t table_size(Thread* current);\n-  static size_t max_log_size();\n-  static size_t min_log_size();\n+public:\n+  class Table;\n@@ -49,4 +46,11 @@\n-  template <typename V>\n-  static size_t clamp_log_size(V log_size);\n-  static size_t initial_log_size();\n-  static size_t grow_hint();\n+private:\n+  static Table* volatile _curr;\n+  static Table* grow_table(Table* curr);\n+\n+public:\n+  typedef enum {\n+    empty = 0,\n+    tombstone = 1,\n+    removed = 2,\n+    below_is_special = (removed + 1)\n+  } SpecialPointerValues;\n@@ -54,1 +58,0 @@\n- public:\n@@ -56,1 +59,0 @@\n-  static void verify_monitor_get_result(oop obj, ObjectMonitor* monitor);\n@@ -58,13 +60,0 @@\n-  static void try_notify_grow();\n-  static bool should_shrink() { return false; } \/\/ Not implemented\n-\n-  static constexpr double GROW_LOAD_FACTOR = 0.75;\n-\n-  static bool should_grow();\n-  static bool should_resize();\n-\n-  template <typename Task, typename... Args>\n-  static bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args);\n-  static bool grow(JavaThread* current);\n-  static bool clean(JavaThread* current);\n-  static bool resize(JavaThread* current);\n@@ -72,3 +61,9 @@\n-  static bool remove_monitor_entry(Thread* current, ObjectMonitor* monitor);\n-  static bool contains_monitor(Thread* current, ObjectMonitor* monitor);\n-  static void print_on(outputStream* st);\n+  static void rebuild(GrowableArray<Table*>* delete_list);\n+  static void destroy(GrowableArray<Table*>* delete_list);\n+  static void remove_monitor_entry(Thread* current, ObjectMonitor* monitor);\n+  static void monitor_reinsert(Table* from, ObjectMonitor* monitor, oop obj);\n+\n+  \/\/ Compiler support\n+  static address current_table_address();\n+  static ByteSize table_capacity_mask_offset();\n+  static ByteSize table_buckets_offset();\n","filename":"src\/hotspot\/share\/runtime\/objectMonitorTable.hpp","additions":26,"deletions":31,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,0 @@\n-    bool object_monitor_table_work = false;\n@@ -115,2 +114,1 @@\n-              (oopmap_cache_work = OopMapCache::has_cleanup_work()) |\n-              (object_monitor_table_work = ObjectSynchronizer::needs_resize())\n+              (oopmap_cache_work = OopMapCache::has_cleanup_work())\n@@ -174,4 +172,0 @@\n-\n-    if (object_monitor_table_work) {\n-      ObjectSynchronizer::resize_table(jt);\n-    }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1198,1 +1198,1 @@\n-#ifdef ASSERT\n+    GrowableArray<ObjectMonitorTable::Table*> table_delete_list;\n@@ -1200,3 +1200,1 @@\n-      for (ObjectMonitor* monitor : delete_list) {\n-        assert(!ObjectSynchronizer::contains_monitor(current, monitor), \"Should have been removed\");\n-      }\n+      ObjectMonitorTable::rebuild(&table_delete_list);\n@@ -1204,1 +1202,0 @@\n-#endif\n@@ -1225,0 +1222,3 @@\n+    if (UseObjectMonitorTable) {\n+      ObjectMonitorTable::destroy(&table_delete_list);\n+    }\n@@ -1552,1 +1552,1 @@\n-bool ObjectSynchronizer::remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj) {\n+void ObjectSynchronizer::remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj) {\n@@ -1556,1 +1556,1 @@\n-  return ObjectMonitorTable::remove_monitor_entry(current, monitor);\n+  ObjectMonitorTable::remove_monitor_entry(current, monitor);\n@@ -1578,14 +1578,0 @@\n-bool ObjectSynchronizer::needs_resize() {\n-  if (!UseObjectMonitorTable) {\n-    return false;\n-  }\n-  return ObjectMonitorTable::should_resize();\n-}\n-\n-bool ObjectSynchronizer::resize_table(JavaThread* current) {\n-  if (!UseObjectMonitorTable) {\n-    return true;\n-  }\n-  return ObjectMonitorTable::resize(current);\n-}\n-\n@@ -2299,4 +2285,1 @@\n-  }\n-  bool removed = remove_monitor(current, monitor, obj);\n-  if (obj != nullptr) {\n-    assert(removed, \"Should have removed the entry if obj was alive\");\n+    remove_monitor(current, monitor, obj);\n@@ -2311,5 +2294,0 @@\n-bool ObjectSynchronizer::contains_monitor(Thread* current, ObjectMonitor* monitor) {\n-  assert(UseObjectMonitorTable, \"must be\");\n-  return ObjectMonitorTable::contains_monitor(current, monitor);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":9,"deletions":31,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"runtime\/objectMonitorTable.hpp\"\n@@ -216,1 +217,1 @@\n-  static bool remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj);\n+  static void remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}