{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -54,0 +55,54 @@\n+    final static long FIELD_OFFSET_STR_BUILDER_VALUE;\n+    final static long FIELD_OFFSET_STR_BUILDER_CODER;\n+    final static long FIELD_OFFSET_STR_BUILDER_COUNT;\n+    static {\n+        Class<?> clazz = StringBuilder.class.getSuperclass();\n+        FIELD_OFFSET_STR_BUILDER_VALUE = UNSAFE.objectFieldOffset(clazz, \"value\");\n+        FIELD_OFFSET_STR_BUILDER_CODER = UNSAFE.objectFieldOffset(clazz, \"coder\");\n+        FIELD_OFFSET_STR_BUILDER_COUNT = UNSAFE.objectFieldOffset(clazz, \"count\");\n+    }\n+\n+    private static final String STR_4 = \"null\";\n+    private static final byte[] STR_4_BYTES_LATIN1 = STR_4.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1);\n+    private static final byte[] STR_4_BYTES_UTF16 = STR_4.getBytes(\n+            ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ? StandardCharsets.UTF_16BE : StandardCharsets.UTF_16LE);\n+    private static final int STR_4_BYTES_LATIN1_INT = UNSAFE.getInt(STR_4_BYTES_LATIN1, Unsafe.ARRAY_BYTE_BASE_OFFSET);\n+    private static final long STR_4_BYTES_UTF16_LONG = UNSAFE.getLong(STR_4_BYTES_UTF16, Unsafe.ARRAY_BYTE_BASE_OFFSET);\n+    private static final byte STR_4_BYTES_LATIN1_BYTE_0 = STR_4_BYTES_LATIN1[0];\n+    private static final byte STR_4_BYTES_LATIN1_BYTE_1 = STR_4_BYTES_LATIN1[1];\n+    private static final byte STR_4_BYTES_LATIN1_BYTE_2 = STR_4_BYTES_LATIN1[2];\n+    private static final byte STR_4_BYTES_LATIN1_BYTE_3 = STR_4_BYTES_LATIN1[3];\n+\n+    private static final String STR_5 = \"false\";\n+    private static final byte[] STR_5_BYTES_LATIN1 = STR_5.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1);\n+    private static final byte[] STR_5_BYTES_UTF16 = STR_5.getBytes(\n+            ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ? StandardCharsets.UTF_16BE : StandardCharsets.UTF_16LE);\n+    private static final int STR_5_BYTES_LATIN1_INT = UNSAFE.getInt(STR_5_BYTES_LATIN1, Unsafe.ARRAY_BYTE_BASE_OFFSET);\n+    private static final byte STR_5_BYTES_LATIN1_BYTE = STR_5_BYTES_LATIN1[4];\n+    private static final long STR_5_BYTES_UTF16_LONG = UNSAFE.getLong(STR_5_BYTES_UTF16, Unsafe.ARRAY_BYTE_BASE_OFFSET);\n+    private static final short STR_5_BYTES_UTF16_SHORT = UNSAFE.getShort(STR_5_BYTES_UTF16, Unsafe.ARRAY_BYTE_BASE_OFFSET + 8);\n+    private static final byte STR_5_BYTES_LATIN1_BYTE_0 = STR_5_BYTES_LATIN1[0];\n+    private static final byte STR_5_BYTES_LATIN1_BYTE_1 = STR_5_BYTES_LATIN1[1];\n+    private static final byte STR_5_BYTES_LATIN1_BYTE_2 = STR_5_BYTES_LATIN1[2];\n+    private static final byte STR_5_BYTES_LATIN1_BYTE_3 = STR_5_BYTES_LATIN1[3];\n+    private static final byte STR_5_BYTES_LATIN1_BYTE_4 = STR_5_BYTES_LATIN1[4];\n+\n+    private static final String STR_7 = \"truefalse\";\n+    private static final byte[] STR_7_BYTES_LATIN1 = STR_7.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1);\n+    private static final byte[] STR_7_BYTES_UTF16 = STR_7.getBytes(\n+            ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ? StandardCharsets.UTF_16BE : StandardCharsets.UTF_16LE);\n+    private static final int STR_7_BYTES_LATIN1_INT = UNSAFE.getInt(STR_7_BYTES_LATIN1, Unsafe.ARRAY_BYTE_BASE_OFFSET);\n+    private static final short STR_7_BYTES_LATIN1_SHORT = UNSAFE.getShort(STR_7_BYTES_LATIN1, Unsafe.ARRAY_BYTE_BASE_OFFSET + 4);\n+    private static final byte STR_7_BYTES_LATIN1_BYTE = STR_7_BYTES_LATIN1[6];\n+    private static final long STR_7_BYTES_UTF16_LONG = UNSAFE.getLong(STR_7_BYTES_UTF16, Unsafe.ARRAY_BYTE_BASE_OFFSET);\n+    private static final int STR_7_BYTES_UTF16_INT = UNSAFE.getInt(STR_7_BYTES_UTF16, Unsafe.ARRAY_BYTE_BASE_OFFSET + 8);\n+    private static final short STR_7_BYTES_UTF16_SHORT = UNSAFE.getShort(STR_7_BYTES_UTF16, Unsafe.ARRAY_BYTE_BASE_OFFSET + 12);\n+    private static final byte STR_7_BYTES_LATIN1_BYTE_0 = STR_7_BYTES_LATIN1[0];\n+    private static final byte STR_7_BYTES_LATIN1_BYTE_1 = STR_7_BYTES_LATIN1[1];\n+    private static final byte STR_7_BYTES_LATIN1_BYTE_2 = STR_7_BYTES_LATIN1[2];\n+    private static final byte STR_7_BYTES_LATIN1_BYTE_3 = STR_7_BYTES_LATIN1[3];\n+    private static final byte STR_7_BYTES_LATIN1_BYTE_4 = STR_7_BYTES_LATIN1[4];\n+    private static final byte STR_7_BYTES_LATIN1_BYTE_5 = STR_7_BYTES_LATIN1[5];\n+    private static final byte STR_7_BYTES_LATIN1_BYTE_6 = STR_7_BYTES_LATIN1[6];\n+\n+\n@@ -57,0 +112,1 @@\n+    final byte[] bytes5 = new byte[NUMBERS * 5];\n@@ -58,0 +114,2 @@\n+    final byte[] bytes10 = new byte[NUMBERS * 10];\n+    final byte[] bytes16 = new byte[NUMBERS * 16];\n@@ -61,0 +119,4 @@\n+    final char[] chars5 = new char[NUMBERS * 5];\n+    final char[] chars10 = new char[NUMBERS * 10];\n+    final StringBuilder sb = new StringBuilder(NUMBERS * 10);\n+    final StringBuilder sb_utf16 = new StringBuilder(NUMBERS * 10).append('\\u4e2d');\n@@ -494,0 +556,730 @@\n+    \/**\n+     * Test whether a constant String of length 4 is MergeStored when calling getBytes\n+     *\/\n+    @Benchmark\n+    @SuppressWarnings(\"deprecation\")\n+    public void str4GetBytes(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            STR_4.getBytes(0, 4, bytes5, off);\n+            off += 5; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of array set 4 constant byte, used as a benchmark for comparison with other str4 Benchmarks\n+     *\/\n+    @Benchmark\n+    public void str4ArraySetConst(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            bytes5[off    ] = STR_4_BYTES_LATIN1_BYTE_0;\n+            bytes5[off + 1] = STR_4_BYTES_LATIN1_BYTE_1;\n+            bytes5[off + 2] = STR_4_BYTES_LATIN1_BYTE_2;\n+            bytes5[off + 3] = STR_4_BYTES_LATIN1_BYTE_3;\n+            off += 5; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether a constant byte[] with a length of 4 is MergeStored when arraycopy is called\n+     *\/\n+    @Benchmark\n+    public void str4Arraycopy(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            System.arraycopy(STR_4_BYTES_LATIN1, 0, bytes5, off, 4);\n+            off += 5; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of Unsafe.putInt, used as a benchmark for comparison with other str4 Benchmarks\n+     *\/\n+    @Benchmark\n+    public void str4UnsafePut(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            UNSAFE.putInt(bytes5, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, STR_4_BYTES_LATIN1_INT);\n+            off += 5; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending a constant String of length 4\n+     *\/\n+    @Benchmark\n+    public void str4StringBuilder(Blackhole BH) {\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append(STR_4);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending 4 constant characters\n+     *\/\n+    @Benchmark\n+    public void str4StringBuilderAppendChar(Blackhole BH) {\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append((char) STR_4_BYTES_LATIN1_BYTE_0);\n+            sb.append((char) STR_4_BYTES_LATIN1_BYTE_1);\n+            sb.append((char) STR_4_BYTES_LATIN1_BYTE_2);\n+            sb.append((char) STR_4_BYTES_LATIN1_BYTE_3);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    private static void str4AppendUnsafePut(StringBuilder sb, char c0, char c1, char c2, char c3) {\n+        byte[] value = (byte[]) UNSAFE.getReference(sb, FIELD_OFFSET_STR_BUILDER_VALUE);\n+        byte coder = UNSAFE.getByte(sb, FIELD_OFFSET_STR_BUILDER_CODER);\n+        int count = UNSAFE.getInt(sb, FIELD_OFFSET_STR_BUILDER_COUNT);\n+        if (count + 4 >= (value.length >> coder)) {\n+            sb.ensureCapacity(count + 4);\n+            value = (byte[]) UNSAFE.getReference(sb, FIELD_OFFSET_STR_BUILDER_VALUE);\n+        }\n+        if (coder == 0) {\n+            value[count    ] = (byte) c0;\n+            value[count + 1] = (byte) c1;\n+            value[count + 2] = (byte) c2;\n+            value[count + 3] = (byte) c3;\n+        } else {\n+            long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + ((long) count << 1);\n+            UNSAFE.putChar(value, address    , c0);\n+            UNSAFE.putChar(value, address + 2, c1);\n+            UNSAFE.putChar(value, address + 4, c2);\n+            UNSAFE.putChar(value, address + 6, c3);\n+        }\n+        UNSAFE.putInt(sb, FIELD_OFFSET_STR_BUILDER_COUNT, count + 5); \/\/ disable auto vector\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending 4 constant characters\n+     *\/\n+    @Benchmark\n+    public void str4StringBuilderUnsafePut(Blackhole BH) {\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            str4AppendUnsafePut(\n+                    sb,\n+                    (char) STR_4_BYTES_LATIN1_BYTE_0,\n+                    (char) STR_4_BYTES_LATIN1_BYTE_1,\n+                    (char) STR_4_BYTES_LATIN1_BYTE_2,\n+                    (char) STR_4_BYTES_LATIN1_BYTE_3);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether the constant String with a length of 4 calls the getChars method to mergestore\n+     *\/\n+    @Benchmark\n+    public void str4GetChars(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            STR_4.getChars(0, 4, chars5, off);\n+            off += 5; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of array set 4 constant byte, used as a benchmark for comparison with other str4 Benchmarks\n+     *\/\n+    @Benchmark\n+    public void str4Utf16ArraySetConst(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            chars5[off    ] = (char) STR_4_BYTES_LATIN1_BYTE_0;\n+            chars5[off + 1] = (char) STR_4_BYTES_LATIN1_BYTE_1;\n+            chars5[off + 2] = (char) STR_4_BYTES_LATIN1_BYTE_2;\n+            chars5[off + 3] = (char) STR_4_BYTES_LATIN1_BYTE_3;\n+            off += 5; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of putLong for comparison with other str4Utf16 benchmarks\n+     *\/\n+    @Benchmark\n+    public void str4Utf16UnsafePut(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            UNSAFE.putLong(bytes16, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, STR_4_BYTES_UTF16_LONG);\n+            off += 9; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether the byte[] arraycopy with a length of 8 is MergeStore\n+     *\/\n+    @Benchmark\n+    public void str4Utf16ArrayCopy(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            System.arraycopy(STR_4_BYTES_UTF16, 0, bytes16, off, 8);\n+            off += 9; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether the UTF16 StringBuilder appends a constant String of length 4 to MergeStore\n+     *\/\n+    @Benchmark\n+    public void str4Utf16StringBuilder(Blackhole BH) {\n+        var sb = sb_utf16;\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append(STR_4);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether the UTF16 StringBuilder is MergeStored when appending 4 constant characters\n+     *\/\n+    @Benchmark\n+    public void str4Utf16StringBuilderAppendChar(Blackhole BH) {\n+        var sb = sb_utf16;\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append((char) STR_4_BYTES_LATIN1_BYTE_0);\n+            sb.append((char) STR_4_BYTES_LATIN1_BYTE_1);\n+            sb.append((char) STR_4_BYTES_LATIN1_BYTE_2);\n+            sb.append((char) STR_4_BYTES_LATIN1_BYTE_3);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending 4 constant characters\n+     *\/\n+    @Benchmark\n+    public void str4Utf16StringBuilderUnsafePut(Blackhole BH) {\n+        StringBuilder sb = sb_utf16;\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            str4AppendUnsafePut(\n+                    sb,\n+                    (char) STR_4_BYTES_LATIN1_BYTE_0,\n+                    (char) STR_4_BYTES_LATIN1_BYTE_1,\n+                    (char) STR_4_BYTES_LATIN1_BYTE_2,\n+                    (char) STR_4_BYTES_LATIN1_BYTE_3);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether a constant String of length 5 is MergeStored when calling getBytes\n+     *\/\n+    @Benchmark\n+    @SuppressWarnings(\"deprecation\")\n+    public void str5GetBytes(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            STR_5.getBytes(0, 4, bytes8, off);\n+            off += 6; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of array set 5 constant byte, used as a benchmark for comparison with other str5 Benchmarks\n+     *\/\n+    @Benchmark\n+    public void str5ArraySetConst(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            bytes8[off    ] = STR_5_BYTES_LATIN1_BYTE_0;\n+            bytes8[off + 1] = STR_5_BYTES_LATIN1_BYTE_1;\n+            bytes8[off + 2] = STR_5_BYTES_LATIN1_BYTE_2;\n+            bytes8[off + 3] = STR_5_BYTES_LATIN1_BYTE_3;\n+            bytes8[off + 4] = STR_5_BYTES_LATIN1_BYTE_4;\n+            off += 6; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether a constant byte[] with a length of 5 is MergeStored when arraycopy is called\n+     *\/\n+    @Benchmark\n+    public void str5Arraycopy(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            System.arraycopy(STR_5_BYTES_LATIN1, 0, bytes8, off, 5);\n+            off += 6; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of Unsafe.putInt, used as a benchmark for comparison with other str5 Benchmarks\n+     *\/\n+    @Benchmark\n+    public void str5UnsafePut(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            UNSAFE.putInt(bytes5, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, STR_5_BYTES_LATIN1_INT);\n+            UNSAFE.putByte(bytes5, Unsafe.ARRAY_BYTE_BASE_OFFSET + off + 4, STR_5_BYTES_LATIN1_BYTE);\n+            off += 6; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending a constant String of length 5\n+     *\/\n+    @Benchmark\n+    public void str5StringBuilder(Blackhole BH) {\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append(STR_5);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending 5 constant characters\n+     *\/\n+    @Benchmark\n+    public void str5StringBuilderAppendChar(Blackhole BH) {\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append((char) STR_5_BYTES_LATIN1_BYTE_0);\n+            sb.append((char) STR_5_BYTES_LATIN1_BYTE_1);\n+            sb.append((char) STR_5_BYTES_LATIN1_BYTE_2);\n+            sb.append((char) STR_5_BYTES_LATIN1_BYTE_3);\n+            sb.append((char) STR_5_BYTES_LATIN1_BYTE_4);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    private static void str5AppendUnsafePut(StringBuilder sb, char c0, char c1, char c2, char c3, char c4) {\n+        byte[] value = (byte[]) UNSAFE.getReference(sb, FIELD_OFFSET_STR_BUILDER_VALUE);\n+        byte coder = UNSAFE.getByte(sb, FIELD_OFFSET_STR_BUILDER_CODER);\n+        int count = UNSAFE.getInt(sb, FIELD_OFFSET_STR_BUILDER_COUNT);\n+        if (count + 4 >= (value.length >> coder)) {\n+            sb.ensureCapacity(count + 4);\n+            value = (byte[]) UNSAFE.getReference(sb, FIELD_OFFSET_STR_BUILDER_VALUE);\n+        }\n+        if (coder == 0) {\n+            value[count    ] = (byte) c0;\n+            value[count + 1] = (byte) c1;\n+            value[count + 2] = (byte) c2;\n+            value[count + 3] = (byte) c3;\n+            value[count + 4] = (byte) c4;\n+        } else {\n+            long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + ((long) count << 1);\n+            UNSAFE.putChar(value, address    , c0);\n+            UNSAFE.putChar(value, address + 2, c1);\n+            UNSAFE.putChar(value, address + 4, c2);\n+            UNSAFE.putChar(value, address + 6, c3);\n+            UNSAFE.putChar(value, address + 8, c4);\n+        }\n+        UNSAFE.putInt(sb, FIELD_OFFSET_STR_BUILDER_COUNT, count + 6); \/\/ disable auto vector\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending 4 constant characters\n+     *\/\n+    @Benchmark\n+    public void str5StringBuilderUnsafePut(Blackhole BH) {\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            str5AppendUnsafePut(\n+                    sb,\n+                    (char) STR_5_BYTES_LATIN1_BYTE_0,\n+                    (char) STR_5_BYTES_LATIN1_BYTE_1,\n+                    (char) STR_5_BYTES_LATIN1_BYTE_2,\n+                    (char) STR_5_BYTES_LATIN1_BYTE_3,\n+                    (char) STR_5_BYTES_LATIN1_BYTE_4);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether the constant String with a length of 5 calls the getChars method to mergestore\n+     *\/\n+    @Benchmark\n+    public void str5GetChars(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            STR_5.getChars(0, 5, chars10, off);\n+            off += 6; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of putLong for comparison with other str5Utf16 benchmarks\n+     *\/\n+    @Benchmark\n+    public void str5Utf16UnsafePut(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            UNSAFE.putLong(bytes16, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, STR_5_BYTES_UTF16_LONG);\n+            UNSAFE.putShort(bytes16, Unsafe.ARRAY_BYTE_BASE_OFFSET + off + 8, STR_5_BYTES_UTF16_SHORT);\n+            off += 11; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of array set 5 constant char, used as a benchmark for comparison with other str5 Benchmarks\n+     *\/\n+    @Benchmark\n+    public void str5Utf16ArraySetConst(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            chars10[off    ] = (char) STR_5_BYTES_LATIN1_BYTE_0;\n+            chars10[off + 1] = (char) STR_5_BYTES_LATIN1_BYTE_1;\n+            chars10[off + 2] = (char) STR_5_BYTES_LATIN1_BYTE_2;\n+            chars10[off + 3] = (char) STR_5_BYTES_LATIN1_BYTE_3;\n+            chars10[off + 4] = (char) STR_5_BYTES_LATIN1_BYTE_4;\n+            off += 6; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether the byte[] arraycopy with a length of 10 is MergeStore\n+     *\/\n+    @Benchmark\n+    public void str5Utf16ArrayCopy(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            System.arraycopy(STR_5_BYTES_UTF16, 0, bytes16, off, 10);\n+            off += 11; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether the UTF16 StringBuilder appends a constant String of length 5 to MergeStore\n+     *\/\n+    @Benchmark\n+    public void str5Utf16StringBuilder(Blackhole BH) {\n+        StringBuilder sb = sb_utf16;\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append(STR_5);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether the UTF16 StringBuilder is MergeStored when appending 5 constant characters\n+     *\/\n+    @Benchmark\n+    public void str5Utf16StringBuilderAppendChar(Blackhole BH) {\n+        StringBuilder sb = sb_utf16;\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append((char) STR_5_BYTES_LATIN1_BYTE_0);\n+            sb.append((char) STR_5_BYTES_LATIN1_BYTE_1);\n+            sb.append((char) STR_5_BYTES_LATIN1_BYTE_2);\n+            sb.append((char) STR_5_BYTES_LATIN1_BYTE_3);\n+            sb.append((char) STR_5_BYTES_LATIN1_BYTE_4);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending 4 constant characters\n+     *\/\n+    @Benchmark\n+    public void str5Utf16StringBuilderUnsafePut(Blackhole BH) {\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            str5AppendUnsafePut(\n+                    sb,\n+                    (char) STR_5_BYTES_LATIN1_BYTE_0,\n+                    (char) STR_5_BYTES_LATIN1_BYTE_1,\n+                    (char) STR_5_BYTES_LATIN1_BYTE_2,\n+                    (char) STR_5_BYTES_LATIN1_BYTE_3,\n+                    (char) STR_5_BYTES_LATIN1_BYTE_4);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether a constant String of length 5 is MergeStored when calling getBytes\n+     *\/\n+    @Benchmark\n+    @SuppressWarnings(\"deprecation\")\n+    public void str7GetBytes(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            STR_7.getBytes(0, 7, bytes10, off);\n+            off += 9; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of array set 7 constant byte, used as a benchmark for comparison with other str7 Benchmarks\n+     *\/\n+    @Benchmark\n+    public void str7ArraySetConst(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            bytes10[off    ] = STR_7_BYTES_LATIN1_BYTE_0;\n+            bytes10[off + 1] = STR_7_BYTES_LATIN1_BYTE_1;\n+            bytes10[off + 2] = STR_7_BYTES_LATIN1_BYTE_2;\n+            bytes10[off + 3] = STR_7_BYTES_LATIN1_BYTE_3;\n+            bytes10[off + 4] = STR_7_BYTES_LATIN1_BYTE_4;\n+            bytes10[off + 5] = STR_7_BYTES_LATIN1_BYTE_5;\n+            bytes10[off + 6] = STR_7_BYTES_LATIN1_BYTE_6;\n+            off += 9; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether a constant byte[] with a length of 7 is MergeStored when arraycopy is called\n+     *\/\n+    @Benchmark\n+    public void str7Arraycopy(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            System.arraycopy(STR_7_BYTES_LATIN1, 0, bytes10, off, 7);\n+            off += 9; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of Unsafe.putInt, used as a benchmark for comparison with other str7 Benchmarks\n+     *\/\n+    @Benchmark\n+    public void str7UnsafePut(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            UNSAFE.putInt(bytes10, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, STR_7_BYTES_LATIN1_INT);\n+            UNSAFE.putShort(bytes10, Unsafe.ARRAY_BYTE_BASE_OFFSET + off + 4, STR_7_BYTES_LATIN1_SHORT);\n+            UNSAFE.putByte(bytes10, Unsafe.ARRAY_BYTE_BASE_OFFSET + off + 6, STR_7_BYTES_LATIN1_BYTE);\n+            off += 9; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending a constant String of length 7\n+     *\/\n+    @Benchmark\n+    public void str7StringBuilder(Blackhole BH) {\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append(STR_7);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending 7 constant characters\n+     *\/\n+    @Benchmark\n+    public void str7StringBuilderAppendChar(Blackhole BH) {\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_0);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_1);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_2);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_3);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_4);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_5);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_6);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    private static void str7AppendUnsafePut(StringBuilder sb, char c0, char c1, char c2, char c3, char c4, char c5, char c6) {\n+        byte[] value = (byte[]) UNSAFE.getReference(sb, FIELD_OFFSET_STR_BUILDER_VALUE);\n+        byte coder = UNSAFE.getByte(sb, FIELD_OFFSET_STR_BUILDER_CODER);\n+        int count = UNSAFE.getInt(sb, FIELD_OFFSET_STR_BUILDER_COUNT);\n+        if (count + 4 >= (value.length >> coder)) {\n+            sb.ensureCapacity(count + 4);\n+            value = (byte[]) UNSAFE.getReference(sb, FIELD_OFFSET_STR_BUILDER_VALUE);\n+        }\n+        if (coder == 0) {\n+            value[count    ] = (byte) c0;\n+            value[count + 1] = (byte) c1;\n+            value[count + 2] = (byte) c2;\n+            value[count + 3] = (byte) c3;\n+            value[count + 4] = (byte) c4;\n+            value[count + 5] = (byte) c5;\n+            value[count + 6] = (byte) c6;\n+        } else {\n+            long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + ((long) count << 1);\n+            UNSAFE.putChar(value, address     , c0);\n+            UNSAFE.putChar(value, address +  2, c1);\n+            UNSAFE.putChar(value, address +  4, c2);\n+            UNSAFE.putChar(value, address +  6, c3);\n+            UNSAFE.putChar(value, address +  8, c4);\n+            UNSAFE.putChar(value, address + 10, c5);\n+            UNSAFE.putChar(value, address + 12, c6);\n+        }\n+        UNSAFE.putInt(sb, FIELD_OFFSET_STR_BUILDER_COUNT, count + 8); \/\/ disable auto vector\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending 4 constant characters\n+     *\/\n+    @Benchmark\n+    public void str7StringBuilderUnsafePut(Blackhole BH) {\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            str7AppendUnsafePut(\n+                    sb,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_0,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_1,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_2,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_3,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_4,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_5,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_6);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether the constant String with a length of 7 calls the getChars method to mergestore\n+     *\/\n+    @Benchmark\n+    public void str7GetChars(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            STR_7.getChars(0, 7, chars10, off);\n+            off += 9; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of array set 7 constant char, used as a benchmark for comparison with other str7 Benchmarks\n+     *\/\n+    @Benchmark\n+    public void str7Utf16ArraySetConst(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            chars10[off    ] = (char) STR_7_BYTES_LATIN1_BYTE_0;\n+            chars10[off + 1] = (char) STR_7_BYTES_LATIN1_BYTE_1;\n+            chars10[off + 2] = (char) STR_7_BYTES_LATIN1_BYTE_2;\n+            chars10[off + 3] = (char) STR_7_BYTES_LATIN1_BYTE_3;\n+            chars10[off + 4] = (char) STR_7_BYTES_LATIN1_BYTE_4;\n+            chars10[off + 5] = (char) STR_7_BYTES_LATIN1_BYTE_5;\n+            chars10[off + 6] = (char) STR_7_BYTES_LATIN1_BYTE_6;\n+            off += 9; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test the performance of putLong for comparison with other str7Utf16 benchmarks\n+     *\/\n+    @Benchmark\n+    public void str7Utf16UnsafePut(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            UNSAFE.putLong(bytes16, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, STR_7_BYTES_UTF16_LONG);\n+            UNSAFE.putInt(bytes16, Unsafe.ARRAY_BYTE_BASE_OFFSET + off + 8, STR_7_BYTES_UTF16_INT);\n+            UNSAFE.putShort(bytes16, Unsafe.ARRAY_BYTE_BASE_OFFSET + off + 12, STR_7_BYTES_UTF16_SHORT);\n+            off += 15; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether the byte[] arraycopy with a length of 14 is MergeStore\n+     *\/\n+    @Benchmark\n+    public void str7Utf16ArrayCopy(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            System.arraycopy(STR_7_BYTES_UTF16, 0, bytes16, off, 14);\n+            off += 15; \/\/ disable auto vector\n+        }\n+        BH.consume(off);\n+    }\n+\n+    \/**\n+     * Test whether the UTF16 StringBuilder appends a constant String of length 7 to MergeStore\n+     *\/\n+    @Benchmark\n+    public void str7Utf16StringBuilder(Blackhole BH) {\n+        var sb = sb_utf16;\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append(STR_7);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether the UTF16 StringBuilder is MergeStored when appending 7 constant characters\n+     *\/\n+    @Benchmark\n+    public void str7Utf16StringBuilderAppendChar(Blackhole BH) {\n+        var sb = sb_utf16;\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_0);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_1);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_2);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_3);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_4);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_5);\n+            sb.append((char) STR_7_BYTES_LATIN1_BYTE_6);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n+    \/**\n+     * Test whether StringBuilder is MergeStored when appending 4 constant characters\n+     *\/\n+    @Benchmark\n+    public void str7Utf16StringBuilderUnsafePut(Blackhole BH) {\n+        var sb = sb_utf16;\n+        sb.setLength(0);\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            str7AppendUnsafePut(\n+                    sb,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_0,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_1,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_2,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_3,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_4,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_5,\n+                    (char) STR_7_BYTES_LATIN1_BYTE_6);\n+        }\n+        BH.consume(sb.length());\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MergeStoreBench.java","additions":792,"deletions":0,"binary":false,"changes":792,"status":"modified"}]}