{"files":[{"patch":"@@ -0,0 +1,765 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.lang.stable.StableEnumFunction;\n+import jdk.internal.lang.stable.StableFunction;\n+import jdk.internal.lang.stable.StableIntFunction;\n+import jdk.internal.lang.stable.StableSupplier;\n+import jdk.internal.lang.stable.StableValueImpl;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * A stable value is a holder of content that can be set at most once.\n+ * <p>\n+ * A {@code StableValue<T>} is typically created using the factory method\n+ * {@linkplain StableValue#of() {@code StableValue.of()}}. When created this way,\n+ * the stable value is <em>unset<\/em>, which means it holds no <em>content<\/em>.\n+ * Its content, of type {@code T}, can be <em>set<\/em> by calling\n+ * {@linkplain #trySet(Object) trySet()}, {@linkplain #setOrThrow(Object) setOrThrow()},\n+ * or {@linkplain #orElseSet(Supplier) orElseSet()}. Once set, the content\n+ * can never change and can be retrieved by calling {@linkplain #orElseThrow() orElseThrow()}\n+ * , {@linkplain #orElse(Object) orElse()}, or {@linkplain #orElseSet(Supplier) orElseSet()}.\n+ * <p>\n+ * Consider the following example where a stable value field \"{@code logger}\" is a\n+ * shallowly immutable holder of content of type {@code Logger} and that is initially\n+ * created as <em>unset<\/em>, which means it holds no content. Later in the example, the\n+ * state of the \"{@code logger}\" field is checked and if it is still <em>unset<\/em>,\n+ * the content is <em>set<\/em>:\n+ *\n+ * {@snippet lang = java:\n+ * public class Component {\n+ *\n+ *    \/\/ Creates a new unset stable value with no content\n+ *    \/\/ @link substring=\"of\" target=\"#of\" :\n+ *    private final StableValue<Logger> logger = StableValue.of();\n+ *\n+ *    private Logger getLogger() {\n+ *        if (!logger.isSet()) {\n+ *            logger.trySet(Logger.create(Component.class));\n+ *        }\n+ *        return logger.orElseThrow();\n+ *    }\n+ *\n+ *    public void process() {\n+ *        getLogger().info(\"Process started\");\n+ *        \/\/ ...\n+ *    }\n+ * }\n+ *}\n+ * <p>\n+ * If {@code getLogger()} is called from several threads, several instances of\n+ * {@code Logger} might be created. However, the content can only be set at most once\n+ * meaning one \"winner\" is picked among the many loggers.\n+ * <p>\n+ * To guarantee that, even under races, only one instance of {@code Logger} is ever\n+ * created, the {@linkplain #orElseSet(Supplier) orElseSet()} method can be used\n+ * instead, where the content is atomically and lazily computed via a\n+ * {@linkplain Supplier supplier}. In the example below, the supplier is provided in the\n+ * form of a lambda expression:\n+ *\n+ * {@snippet lang = java:\n+ * public class Component {\n+ *\n+ *    \/\/ Creates a new unset stable value with no content\n+ *    \/\/ @link substring=\"of\" target=\"#of\" :\n+ *    private final StableValue<Logger> logger = StableValue.of();\n+ *\n+ *    private Logger getLogger() {\n+ *        return logger.orElseSet( () -> Logger.create(Component.class) );\n+ *    }\n+ *\n+ *    public void process() {\n+ *        getLogger().info(\"Process started\");\n+ *        \/\/ ...\n+ *    }\n+ * }\n+ *}\n+ * <p>\n+ * The {@code getLogger()} method calls {@code logger.orElseSet()} on the stable value to\n+ * retrieve its content. If the stable value is <em>unset<\/em>, then {@code orElseSet()}\n+ * evaluates and sets the content; the content is then returned to the client. In other\n+ * words, {@code orElseSet()} guarantees that a stable value's content is <em>set<\/em>\n+ * before it is used.\n+ * <p>\n+ * Furthermore, {@code orElseSet()} guarantees that the supplier provided is\n+ * evaluated at most once, even when {@code logger.orElseSet()} is invoked concurrently.\n+ * This property is crucial as evaluation of the supplier may have side effects,\n+ * e.g., the call above to {@code Logger.create()} may result in storage resources\n+ * being prepared.\n+ *\n+ * <h2 id=\"stable-functions\">Stable Functions<\/h2>\n+ * Stable values provide the foundation for higher-level functional abstractions. A\n+ * <em>stable supplier<\/em> is a supplier that computes a value and then caches it into\n+ * a backing stable value storage for later use. A stable supplier is created via the\n+ * {@linkplain StableValue#supplier(Supplier) StableValue.supplier()} factory, by\n+ * providing an original {@linkplain Supplier} which is invoked when the stable supplier\n+ * is first accessed:\n+ *\n+ * {@snippet lang = java:\n+ * public class Component {\n+ *\n+ *     private final Supplier<Logger> logger =\n+ *             \/\/ @link substring=\"supplier\" target=\"#supplier(Supplier)\" :\n+ *             StableValue.supplier( () -> Logger.getLogger(Component.class) );\n+ *\n+ *     public void process() {\n+ *        logger.get().info(\"Process started\");\n+ *        \/\/ ...\n+ *     }\n+ * }\n+ *}\n+ * A stable supplier encapsulates access to its backing stable value storage. This means\n+ * that code inside {@code Component} can obtain the logger object directly from the\n+ * stable supplier, without having to go through an accessor method like {@code getLogger()}.\n+ * <p>\n+ * A <em>stable int function<\/em> is a function that takes an {@code int} parameter and\n+ * uses it to compute a result that is then cached by the backing stable value storage\n+ * for that parameter value. A stable {@link IntFunction} is created via the\n+ * {@linkplain StableValue#intFunction(int, IntFunction) StableValue.intFunction()}\n+ * factory. Upon creation, the input range (i.e. {@code [0, size)}) is specified together\n+ * with an original {@linkplain IntFunction} which is invoked at most once per input value.\n+ * In effect, the stable int function will act like a cache for the original\n+ * {@linkplain IntFunction}:\n+ *\n+ * {@snippet lang = java:\n+ * public final class SqrtUtil {\n+ *\n+ *      private SqrtUtil() {}\n+ *\n+ *      private static final int CACHED_SIZE = 10;\n+ *\n+ *      private static final IntFunction<Double> SQRT =\n+ *              \/\/ @link substring=\"intFunction\" target=\"#intFunction(int,IntFunction)\" :\n+ *              StableValue.intFunction(CACHED_SIZE, StrictMath::sqrt);\n+ *\n+ *      public static double sqrt(int a) {\n+ *           if (a < CACHED_SIZE) {\n+ *                return SQRT.apply(a);\n+ *           } else {\n+ *                return StrictMath.sqrt(a);\n+ *           }\n+ *      }\n+ *  }\n+ *\n+ *  public static void computeSomeValues() {\n+ *      double sqrt9 = sqrt(9);   \/\/ May eventually constant fold to 3.0 at runtime\n+ *      double sqrt81 = sqrt(81); \/\/ Will not constant fold\n+ *  }\n+ *\n+ *}\n+ * <p>\n+ * A <em>stable function<\/em> is a function that takes a parameter (of type {@code T}) and\n+ * uses it to compute a result (of type {@code R}) that is then cached by the backing\n+ * stable value storage for that parameter value. A stable function is created via the\n+ * {@linkplain StableValue#function(Set, Function) StableValue.function()} factory.\n+ * Upon creation, the input {@linkplain Set} is specified together with an original\n+ * {@linkplain Function} which is invoked at most once per input value. In effect, the\n+ * stable function will act like a cache for the original {@linkplain Function}:\n+ *\n+ * {@snippet lang = java:\n+ * class Log2Util {\n+ *\n+ *     private Log2Util() {}\n+ *\n+ *     private static final Set<Integer> CACHED_KEYS =\n+ *             Set.of(1, 2, 4, 8, 16, 32);\n+ *     private static final UnaryOperator<Integer> LOG2_ORIGINAL =\n+ *             i -> 31 - Integer.numberOfLeadingZeros(i);\n+ *\n+ *     private static final Function<Integer, Integer> LOG2_CACHED =\n+ *             \/\/ @link substring=\"function\" target=\"#function(Set,Function)\" :\n+ *             StableValue.function(CACHED_KEYS, LOG2_ORIGINAL);\n+ *\n+ *     public static double log2(int a) {\n+ *         if (CACHED_KEYS.contains(a)) {\n+ *             return LOG2_CACHED.apply(a);\n+ *         } else {\n+ *             return LOG2_ORIGINAL.apply(a);\n+ *         }\n+ *     }\n+ *\n+ * }\n+ *\n+ * public static double computeSomeValues() {\n+ *     double log16  = Log2Util.log2(16); \/\/ May eventually constant fold to 4 at runtime\n+ *     double log256 = Log2Util.log2(81); \/\/ Will not constant fold\n+ * }\n+ * }\n+ * Note: The {@code LOG2_CACHED} function is a _partial function_ that only has a small\n+ *       number of allowed inputs whereas {@code Log2Util.log2} is a _total function_ that\n+ *       allows the same input set that the original function is defined for.\n+ *\n+ * <h2 id=\"stable-collections\">Stable Collections<\/h2>\n+ * Stable values can also be used as backing storage for\n+ * {@linkplain Collection##unmodifiable unmodifiable collections}. A <em>stable list<\/em>\n+ * is an unmodifiable list, backed by an array of stable values. The stable list elements\n+ * are computed when they are first accessed, using a provided {@linkplain IntFunction}:\n+ *\n+ * {@snippet lang = java:\n+ * public final class SqrtUtil {\n+ *\n+ *      private static final int CACHED_SIZE = 10;\n+ *\n+ *      private SqrtUtil() {}\n+ *\n+ *      private static final List<Double> SQRT =\n+ *              \/\/ @link substring=\"list\" target=\"#list(int,IntFunction)\" :\n+ *              StableValue.list(CACHED_SIZE, StrictMath::sqrt);\n+ *\n+ *      public static double sqrt(int a) {\n+ *           if (a < CACHED_SIZE) {\n+ *                return SQRT.get(a);\n+ *           } else {\n+ *                return StrictMath.sqrt(a);\n+ *           }\n+ *      }\n+ *  }\n+ *\n+ *  public static void computeSomeValues() {\n+ *       double sqrt9 = SqrtUtil.sqrt(9);   \/\/ May eventually constant fold to 3.0 at runtime\n+ *       double sqrt81 = SqrtUtil.sqrt(81); \/\/ Will not constant fold\n+ *  }\n+ *\n+ * }\n+ * <p>\n+ * Similarly, a <em>stable map<\/em> is an unmodifiable map whose keys are known at\n+ * construction. The stable map values are computed when they are first accessed,\n+ * using a provided {@linkplain Function}:\n+ *\n+ * {@snippet lang = java:\n+ * class Log2Util {\n+ *\n+ *     private Log2Util() {}\n+ *\n+ *     private static final Set<Integer> CACHED_KEYS =\n+ *             Set.of(1, 2, 4, 8, 16, 32);\n+ *     private static final UnaryOperator<Integer> LOG2_ORIGINAL =\n+ *             i -> 31 - Integer.numberOfLeadingZeros(i);\n+ *\n+ *     private static final Map<Integer, INTEGER> LOG2_CACHED =\n+ *             \/\/ @link substring=\"map\" target=\"#map(Set,Function)\" :\n+ *             StableValue.map(CACHED_KEYS, LOG2_ORIGINAL);\n+ *\n+ *     public static double log2(int a) {\n+ *          if (CACHED_KEYS.contains(a)) {\n+ *              return LOG2_CACHED.get(a);\n+ *          } else {\n+ *              return LOG2_ORIGINAL.apply(a);\n+ *          }\n+ *     }\n+ *\n+ *     public static double computeSomeValues() {\n+ *         double log16 = Log2Util.log2(16);   \/\/ May eventually constant fold to 4 at runtime\n+ *         double log256 = Log2Util.log2(256); \/\/ Will not constant fold\n+ *     }\n+ *\n+ * }\n+ *}\n+ *\n+ * <h2 id=\"composition\">Composing stable values<\/h2>\n+ * A stable value can depend on other stable values, forming a dependency graph\n+ * that can be lazily computed but where access to individual elements still can be\n+ * performant. In the following example, a single {@code Foo} and a {@code Bar}\n+ * instance (that is dependent on the {@code Foo} instance) are lazily created, both of\n+ * which are held by stable values:\n+ * {@snippet lang = java:\n+ * public final class DependencyUtil {\n+ *\n+ *     private DependencyUtil() {}\n+ *\n+ *     public static class Foo {\n+ *          \/\/ ...\n+ *      }\n+ *\n+ *     public static class Bar {\n+ *         public Bar(Foo foo) {\n+ *              \/\/ ...\n+ *         }\n+ *     }\n+ *\n+ *     private static final Supplier<Foo> FOO = StableValue.supplier(Foo::new);\n+ *     private static final Supplier<Bar> BAR = StableValue.supplier(() -> new Bar(FOO.get()));\n+ *\n+ *     public static Foo foo() {\n+ *         return FOO.get();\n+ *     }\n+ *\n+ *     public static Bar bar() {\n+ *         return BAR.get();\n+ *     }\n+ *\n+ * }\n+ *}\n+ * Calling {@code bar()} will create the {@code Bar} singleton if it is not already\n+ * created. Upon such a creation, the dependent {@code Foo} will first be created if\n+ * the {@code Foo} does not already exist.\n+ * <p>\n+ * Here is another example where a more complex dependency graph is created in which\n+ * integers in the Fibonacci delta series are lazily computed:\n+ * {@snippet lang = java:\n+ * public final class Fibonacci {\n+ *\n+ *     private Fibonacci() {}\n+ *\n+ *     private static final int MAX_SIZE_INT = 46;\n+ *\n+ *     private static final IntFunction<Integer> FIB =\n+ *             StableValue.intFunction(MAX_SIZE_INT, Fibonacci::fib);\n+ *\n+ *     public static int fib(int n) {\n+ *         return n < 2\n+ *                 ? n\n+ *                 : FIB.apply(n - 1) + FIB.apply(n - 2);\n+ *     }\n+ *\n+ * }\n+ *}\n+ * Both {@code FIB} and {@code Fibonacci::fib} recurse into each other. Because the\n+ * stable int function {@code FIB} caches intermediate results, the initial\n+ * computational complexity is reduced from exponential to linear compared to a\n+ * traditional non-caching recursive fibonacci method. Once computed, the VM is free to\n+ * constant-fold expressions like {@code Fibonacci.fib(5)}.\n+ * <p>\n+ * The fibonacci example above is a dependency graph with no circular dependencies (i.e.,\n+ * it is a dependency tree):\n+ *{@snippet lang=text :\n+ *\n+ *              ___________fib(5)____________\n+ *             \/                             \\\n+ *       ____fib(4)____                  ____fib(3)____\n+ *      \/              \\                \/              \\\n+ *    fib(3)          fib(2)          fib(2)          fib(1)\n+ *   \/     \\         \/     \\         \/     \\\n+ * fib(2) fib(1)   fib(1) fib(0)   fib(1) fib(0)\n+ *}\n+ *\n+ * If there are circular dependencies in a dependency graph, a stable value will\n+ * eventually throw an {@linkplain IllegalStateException} upon referencing elements in\n+ * a circularity.\n+ *\n+ * <h2 id=\"thread-safety\">Thread Safety<\/h2>\n+ * The content of a stable value is guaranteed to be set at most once. If competing\n+ * threads are racing to set a stable value, only one update succeeds, while other updates\n+ * are blocked until the stable value becomes set.\n+ * <p>\n+ * The at-most-once write operation on a stable value that succeeds\n+ * (e.g. {@linkplain #trySet(Object) trySet()})\n+ * {@linkplain java.util.concurrent##MemoryVisibility <em>happens-before<\/em>}\n+ * any subsequent read operation (e.g. {@linkplain #orElseThrow()}) that is successful.\n+ * A successful write operation can be either:\n+ * <ul>\n+ *     <li>a {@link #trySet(Object)} that returns {@code true},<\/li>\n+ *     <li>a {@link #setOrThrow(Object)} that does not throw, or<\/li>\n+ *     <li>an {@link #orElseSet(Supplier)} that successfully runs the supplier<\/li>\n+ * <\/ul>\n+ * A successful read operation can be either:\n+ * <ul>\n+ *     <li>a {@link #orElseThrow()} that does not throw,<\/li>\n+ *     <li>a {@link #orElse(Object) orElse(other)} that does not return the {@code other} value<\/li>\n+ *     <li>an {@link #orElseSet(Supplier)} that does not {@code throw}, or<\/li>\n+ *     <li>an {@link #isSet()} that returns {@code true}<\/li>\n+ * <\/ul>\n+ * <p>\n+ * The method {@link #orElseSet(Supplier)} guarantees that the provided\n+ * {@linkplain Supplier} is invoked successfully at most once even under race.\n+ * Invocations of {@link #setOrThrow(Object)} forms a total order of zero or more\n+ * exceptional invocations followed by zero (if the content was already set) or one\n+ * successful invocation. Since stable functions and stable collections are built on top\n+ * of {@linkplain StableValue#orElseSet(Supplier) orElseSet()} they too are\n+ * thread safe and guarantee at-most-once-per-input invocation.\n+ *\n+ * <h2 id=\"performance\">Performance<\/h2>\n+ * The _content_ of a set stable value is treated as a constant by the JVM, provided that\n+ * the reference to the stable value is also constant (e.g. in cases where the\n+ * stable value itself is stored in a {@code static final} field). Stable functions and\n+ * collections are built on top of StableValue. As such, they are also treated as\n+ * constants by the JFM.\n+ * <p>\n+ * This means that, at least in some cases, access to the content of a stable value\n+ * enjoys the same constant-folding optimizations that are available when accessing\n+ * {@code static final} fields.\n+ *\n+ * @implSpec Implementing classes of {@code StableValue} are free to synchronize on\n+ *           {@code this} and consequently, care should be taken whenever\n+ *           (directly or indirectly) synchronizing on a {@code StableValue}. Failure to\n+ *           do this may lead to deadlock. Stable functions and collections on the\n+ *           other hand are guaranteed <em>not to synchronize<\/em> on {@code this}.\n+ *           Except for a {@code StableValue}'s content itself, an {@linkplain #orElse(Object) orElse(other)}\n+ *           parameter, and an {@linkplain #equals(Object) equals(obj)} parameter; all\n+ *           method parameters must be <em>non-null<\/em> or a {@link NullPointerException}\n+ *           will be thrown.\n+ *\n+ * @implNote A {@code StableValue} is mainly intended to be a non-public field in\n+ *           a class and is usually neither exposed directly via accessors nor passed as\n+ *           a method parameter.\n+ *           Stable functions and collections make all reasonable efforts to provide\n+ *           {@link Object#toString()} operations that do not trigger evaluation\n+ *           of the internal stable values when called.\n+ *           Stable collections have {@link Object#equals(Object)} operations that tries\n+ *           to minimize evaluation of the internal stable values when called.\n+ *           As objects can be set via stable values but never removed, this can be a source\n+ *           of unintended memory leaks. A stable value's content is\n+ *           {@linkplain java.lang.ref##reachability strongly reachable}. Clients are\n+ *           advised that {@linkplain java.lang.ref##reachability reachable} stable values\n+ *           will hold their set content until the stable value itself is collected.\n+ *           A {@code StableValue} that has a type parameter {@code T} that is an array\n+ *           type (of arbitrary rank) will only allow the JVM to treat the <em>array reference<\/em>\n+ *           as a stable value but <em>not its components<\/em>. Clients can instead use\n+ *           {@linkplain #list(int, IntFunction) a stable list} of arbitrary depth, which\n+ *           provides stable components. More generally, a stable value can hold other\n+ *           stable values of arbitrary depth and still provide transitive constantness.\n+ *           Stable values, functions and collections are not {@link Serializable}.\n+ *\n+ * @param <T> type of the content\n+ *\n+ * @since 25\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.STABLE_VALUES)\n+public sealed interface StableValue<T>\n+        permits StableValueImpl {\n+\n+    \/\/ Principal methods\n+\n+    \/**\n+     * Tries to set the content of this StableValue to the provided {@code content}. The\n+     * content of this StableValue can only be set once, implying this method only returns\n+     * {@code true} once.\n+     * <p>\n+     * When this method returns, the content of this StableValue is always set.\n+     *\n+     * @return {@code true} if the content of this StableValue was set to the\n+     *         provided {@code content}, {@code false} otherwise\n+     * @param content to set\n+     * @throws IllegalStateException if this method is invoked directly by a supplier\n+     *         provided to the {@link #orElseSet(Supplier)} method.\n+     *\/\n+    boolean trySet(T content);\n+\n+    \/**\n+     * {@return the content if set, otherwise, returns the provided {@code other} value}\n+     *\n+     * @param other to return if the content is not set\n+     *\/\n+    T orElse(T other);\n+\n+    \/**\n+     * {@return the content if set, otherwise, throws {@code NoSuchElementException}}\n+     *\n+     * @throws NoSuchElementException if no content is set\n+     *\/\n+    T orElseThrow();\n+\n+    \/**\n+     * {@return {@code true} if the content is set, {@code false} otherwise}\n+     *\/\n+    boolean isSet();\n+\n+    \/**\n+     * {@return the content; if unset, first attempts to compute and set the\n+     *          content using the provided {@code supplier}}\n+     * <p>\n+     * The provided {@code supplier} is guaranteed to be invoked at most once if it\n+     * completes without throwing an exception. If this method is invoked several times\n+     * with different suppliers, only one of them will be invoked provided it completes\n+     * without throwing an exception.\n+     * <p>\n+     * If the supplier throws an (unchecked) exception, the exception is rethrown, and no\n+     * content is set. The most common usage is to construct a new object serving\n+     * as a lazily computed value or memoized result, as in:\n+     *\n+     * {@snippet lang=java:\n+     * Value witness = stable.orElseSet(Value::new);\n+     * }\n+     * <p>\n+     * When this method returns successfully, the content is always set.\n+     * <p>\n+     * The provided {@code supplier} will only be invoked once even if invoked from\n+     * several threads unless the {@code supplier} throws an exception.\n+     *\n+     * @param  supplier to be used for computing the content, if not previously set\n+     * @throws IllegalStateException if the provided {@code supplier} recursively\n+     *                               attempts to set this stable value.\n+     *\/\n+    T orElseSet(Supplier<? extends T> supplier);\n+\n+    \/\/ Convenience methods\n+\n+    \/**\n+     * Sets the content of this StableValue to the provided {@code content}, or, if\n+     * already set, throws {@code IllegalStateException}.\n+     * <p>\n+     * When this method returns (or throws an exception), the content is always set.\n+     *\n+     * @param content to set\n+     * @throws IllegalStateException if the content was already set\n+     *\/\n+    void setOrThrow(T content);\n+\n+    \/\/ Object methods\n+\n+    \/**\n+     * {@return {@code true} if {@code this == obj}, {@code false} otherwise}\n+     *\n+     * @param obj to check for equality\n+     *\/\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the {@linkplain System#identityHashCode(Object) identity hash code} of\n+     *          {@code this} object}\n+     *\/\n+    int hashCode();\n+\n+    \/\/ Factories\n+\n+    \/**\n+     * {@return a new unset stable value}\n+     * <p>\n+     * An unset stable value has no content.\n+     *\n+     * @param <T> type of the content\n+     *\/\n+    static <T> StableValue<T> of() {\n+        return StableValueImpl.of();\n+    }\n+\n+    \/**\n+     * {@return a new pre-set stable value with the provided {@code content}}\n+     *\n+     * @param content to set\n+     * @param <T>     type of the content\n+     *\/\n+    static <T> StableValue<T> of(T content) {\n+        final StableValue<T> stableValue = StableValue.of();\n+        stableValue.trySet(content);\n+        return stableValue;\n+    }\n+\n+    \/**\n+     * {@return a new stable supplier}\n+     * <p>\n+     * The returned {@linkplain Supplier supplier} is a caching supplier that records\n+     * the value of the provided {@code original} supplier upon being first accessed via\n+     * the returned supplier's {@linkplain Supplier#get() get()} method.\n+     * <p>\n+     * The provided {@code original} supplier is guaranteed to be successfully invoked\n+     * at most once even in a multi-threaded environment. Competing threads invoking the\n+     * returned supplier's {@linkplain Supplier#get() get()} method when a value is\n+     * already under computation will block until a value is computed or an exception is\n+     * thrown by the computing thread.\n+     * <p>\n+     * If the provided {@code original} supplier throws an exception, it is relayed\n+     * to the initial caller and no content is recorded.\n+     * <p>\n+     * If the provided {@code original} supplier recursively calls the returned\n+     * supplier, an {@linkplain IllegalStateException} will be thrown.\n+     *\n+     * @param original supplier used to compute a cached value\n+     * @param <T>      the type of results supplied by the returned supplier\n+     *\/\n+    static <T> Supplier<T> supplier(Supplier<? extends T> original) {\n+        Objects.requireNonNull(original);\n+        return StableSupplier.of(original);\n+    }\n+\n+    \/**\n+     * {@return a new stable {@linkplain IntFunction}}\n+     * <p>\n+     * The returned function is a caching function that, for each allowed {@code int}\n+     * input, records the values of the provided {@code original}\n+     * function upon being first accessed via the returned function's\n+     * {@linkplain IntFunction#apply(int) apply()} method. If the returned function is\n+     * invoked with an input that is not allowed, an {@link IllegalArgumentException}\n+     * will be thrown.\n+     * <p>\n+     * The provided {@code original} function is guaranteed to be successfully invoked\n+     * at most once per allowed input, even in a multi-threaded environment. Competing\n+     * threads invoking the returned function's\n+     * {@linkplain IntFunction#apply(int) apply()} method when a value is already under\n+     * computation will block until a value is computed or an exception is thrown by\n+     * the computing thread.\n+     * <p>\n+     * If the provided {@code original} function throws an exception, it is relayed\n+     * to the initial caller and no content is recorded.\n+     * <p>\n+     * If the provided {@code original} function recursively calls the returned\n+     * function for the same index, an {@linkplain IllegalStateException} will\n+     * be thrown.\n+     *\n+     * @param size     the size of the allowed inputs in {@code [0, size)}\n+     * @param original IntFunction used to compute cached values\n+     * @param <R>      the type of results delivered by the returned IntFunction\n+     * @throws IllegalArgumentException if the provided {@code size} is negative.\n+     *\/\n+    static <R> IntFunction<R> intFunction(int size,\n+                                          IntFunction<? extends R> original) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        Objects.requireNonNull(original);\n+        return StableIntFunction.of(size, original);\n+    }\n+\n+    \/**\n+     * {@return a new stable {@linkplain Function}}\n+     * <p>\n+     * The returned function is a caching function that, for each allowed\n+     * input in the given set of {@code inputs}, records the values of the provided\n+     * {@code original} function upon being first accessed via the returned function's\n+     * {@linkplain Function#apply(Object) apply()} method. If the returned function is\n+     * invoked with an input that is not allowed, an {@link IllegalArgumentException}\n+     * will be thrown.\n+     * <p>\n+     * The provided {@code original} function is guaranteed to be successfully invoked\n+     * at most once per allowed input, even in a multi-threaded environment. Competing\n+     * threads invoking the returned function's {@linkplain Function#apply(Object) apply()}\n+     * method when a value is already under computation will block until a value is\n+     * computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If the provided {@code original} function throws an exception, it is relayed to\n+     * the initial caller and no content is recorded.\n+     * <p>\n+     * If the provided {@code original} function recursively calls the returned\n+     * function for the same input, an {@linkplain IllegalStateException} will\n+     * be thrown.\n+     *\n+     * @param inputs   the set of (non-null) allowed input values\n+     * @param original Function used to compute cached values\n+     * @param <T>      the type of the input to the returned Function\n+     * @param <R>      the type of results delivered by the returned Function\n+     * @throws NullPointerException if the provided set of {@code inputs} contains a\n+     *                              {@code null} element.\n+     *\/\n+    static <T, R> Function<T, R> function(Set<? extends T> inputs,\n+                                          Function<? super T, ? extends R> original) {\n+        Objects.requireNonNull(inputs);\n+        Objects.requireNonNull(original);\n+        return inputs instanceof EnumSet<?> && !inputs.isEmpty()\n+                ? StableEnumFunction.of(inputs, original)\n+                : StableFunction.of(inputs, original);\n+    }\n+\n+    \/**\n+     * {@return a new stable list with the provided {@code size}}\n+     * <p>\n+     * The returned list is an {@linkplain Collection##unmodifiable unmodifiable} list\n+     * with the provided {@code size}. The list's elements are computed via the\n+     * provided {@code mapper} when they are first accessed\n+     * (e.g. via {@linkplain List#get(int) List::get}).\n+     * <p>\n+     * The provided {@code mapper} int function is guaranteed to be successfully invoked\n+     * at most once per list index, even in a multi-threaded environment. Competing\n+     * threads accessing an element already under computation will block until an element\n+     * is computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If the provided {@code mapper} throws an exception, it is relayed to the initial\n+     * caller and no value for the element is recorded.\n+     * <p>\n+     * Any direct {@link List#subList(int, int) subList} or {@link List#reversed()} views\n+     * of the returned list are also stable.\n+     * <p>\n+     * The returned list and its {@link List#subList(int, int) subList} or\n+     * {@link List#reversed()} views implement the {@link RandomAccess} interface.\n+     * <p>\n+     * The returned list is unmodifiable and does not implement the\n+     * {@linkplain Collection##optional-operation optional operations} in the\n+     * {@linkplain List} interface.\n+     * <p>\n+     * If the provided {@code mapper} recursively calls the returned list for the\n+     * same index, an {@linkplain IllegalStateException} will be thrown.\n+     *\n+     * @param size   the size of the returned list\n+     * @param mapper to invoke whenever an element is first accessed\n+     *               (may return {@code null})\n+     * @param <E>    the type of elements in the returned list\n+     * @throws IllegalArgumentException if the provided {@code size} is negative.\n+     *\/\n+    static <E> List<E> list(int size,\n+                            IntFunction<? extends E> mapper) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        Objects.requireNonNull(mapper);\n+        return SharedSecrets.getJavaUtilCollectionAccess().stableList(size, mapper);\n+    }\n+\n+    \/**\n+     * {@return a new stable map with the provided {@code keys}}\n+     * <p>\n+     * The returned map is an {@linkplain Collection##unmodifiable unmodifiable} map whose\n+     * keys are known at construction. The map's values are computed via the provided\n+     * {@code mapper} when they are first accessed\n+     * (e.g. via {@linkplain Map#get(Object) Map::get}).\n+     * <p>\n+     * The provided {@code mapper} function is guaranteed to be successfully invoked\n+     * at most once per key, even in a multi-threaded environment. Competing\n+     * threads accessing a value already under computation will block until an element\n+     * is computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If the provided {@code mapper} throws an exception, it is relayed to the initial\n+     * caller and no value associated with the provided key is recorded.\n+     * <p>\n+     * Any direct {@link Map#values()} or {@link Map#entrySet()} views\n+     * of the returned map are also stable.\n+     * <p>\n+     * The returned map is unmodifiable and does not implement the\n+     * {@linkplain Collection##optional-operations optional operations} in the\n+     * {@linkplain Map} interface.\n+     * <p>\n+     * If the provided {@code mapper} recursively calls the returned map for\n+     * the same key, an {@linkplain IllegalStateException} will be thrown.\n+     *\n+     * @param keys   the (non-null) keys in the returned map\n+     * @param mapper to invoke whenever an associated value is first accessed\n+     *               (may return {@code null})\n+     * @param <K>    the type of keys maintained by the returned map\n+     * @param <V>    the type of mapped values in the returned map\n+     * @throws NullPointerException if the provided set of {@code inputs} contains a\n+     *                              {@code null} element.\n+     *\/\n+    static <K, V> Map<K, V> map(Set<K> keys,\n+                                Function<? super K, ? extends V> mapper) {\n+        Objects.requireNonNull(keys);\n+        Objects.requireNonNull(mapper);\n+        return SharedSecrets.getJavaUtilCollectionAccess().stableMap(keys, mapper);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StableValue.java","additions":765,"deletions":0,"binary":false,"changes":765,"status":"added"},{"patch":"@@ -61,1 +61,1 @@\n- * <p>Certain methods are specified to be\n+ * <p><a id=\"optional-operations\"><\/a>Certain methods are specified to be\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.IntFunction;\n@@ -40,0 +41,1 @@\n+import java.util.function.Supplier;\n@@ -41,0 +43,1 @@\n+\n@@ -43,0 +46,2 @@\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n@@ -44,0 +49,2 @@\n+import jdk.internal.util.NullableKeyValueHolder;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -131,0 +138,6 @@\n+                public <E> List<E> stableList(int size, IntFunction<? extends E> mapper) {\n+                    return ImmutableCollections.stableList(size, mapper);\n+                }\n+                public <K, V> Map<K, V> stableMap(Set<K> keys, Function<? super K, ? extends V> mapper) {\n+                    return new StableMap<>(keys, mapper);\n+                }\n@@ -253,0 +266,5 @@\n+    static <E> List<E> stableList(int size, IntFunction<? extends E> mapper) {\n+        \/\/ A lazy list is not Serializable so, we cannot return `List.of()` if size == 0\n+        return new StableList<>(size, mapper);\n+    }\n+\n@@ -451,1 +469,1 @@\n-            assert root instanceof List12 || root instanceof ListN;\n+            assert root instanceof List12 || root instanceof ListN || root instanceof StableList;\n@@ -502,1 +520,2 @@\n-            return root instanceof ListN && ((ListN<?>)root).allowNulls;\n+            return root instanceof ListN<?> listN && listN.allowNulls\n+                    || root instanceof StableList<E>;\n@@ -554,0 +573,9 @@\n+\n+        @Override\n+        public String toString() {\n+            if (root instanceof StableList<E> stableList) {\n+                return StableUtil.renderElements(root, \"StableList\", stableList.delegates, offset, size);\n+            } else {\n+                return super.toString();\n+            }\n+        }\n@@ -771,0 +799,83 @@\n+    @jdk.internal.ValueBased\n+    static final class StableList<E> extends AbstractImmutableList<E> {\n+\n+        @Stable\n+        private final IntFunction<? extends E> mapper;\n+        @Stable\n+        final StableValueImpl<E>[] delegates;\n+\n+        StableList(int size, IntFunction<? extends E> mapper) {\n+            this.mapper = mapper;\n+            this.delegates = StableUtil.array(size);\n+        }\n+\n+        @Override public boolean  isEmpty() { return delegates.length == 0;}\n+        @Override public int      size() { return delegates.length; }\n+        @Override public Object[] toArray() { return copyInto(new Object[size()]); }\n+\n+        @ForceInline\n+        @Override\n+        public E get(int i) {\n+            final StableValueImpl<E> delegate;\n+            try {\n+                delegate = delegates[i];\n+            } catch (ArrayIndexOutOfBoundsException aioobe) {\n+                throw new IndexOutOfBoundsException(i);\n+            }\n+            return delegate.orElseSet(new Supplier<E>() {\n+                        @Override  public E get() { return mapper.apply(i); }});\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] a) {\n+            final int size = delegates.length;\n+            if (a.length < size) {\n+                \/\/ Make a new array of a's runtime type, but my contents:\n+                T[] n = (T[])Array.newInstance(a.getClass().getComponentType(), size);\n+                return copyInto(n);\n+            }\n+            copyInto(a);\n+            if (a.length > size) {\n+                a[size] = null; \/\/ null-terminate\n+            }\n+            return a;\n+        }\n+\n+        @Override\n+        public int indexOf(Object o) {\n+            final int size = size();\n+            for (int i = 0; i < size; i++) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            for (int i = size() - 1; i >= 0; i--) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private <T> T[] copyInto(Object[] a) {\n+            final int len = delegates.length;\n+            for (int i = 0; i < len; i++) {\n+                a[i] = get(i);\n+            }\n+            return (T[]) a;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return StableUtil.renderElements(this, \"StableList\", delegates);\n+        }\n+\n+    }\n+\n@@ -1115,1 +1226,1 @@\n-    abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> implements Serializable {\n+    abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> {\n@@ -1146,1 +1257,1 @@\n-    static final class Map1<K,V> extends AbstractImmutableMap<K,V> {\n+    static final class Map1<K,V> extends AbstractImmutableMap<K,V> implements Serializable {\n@@ -1218,1 +1329,1 @@\n-    static final class MapN<K,V> extends AbstractImmutableMap<K,V> {\n+    static final class MapN<K,V> extends AbstractImmutableMap<K,V> implements Serializable {\n@@ -1408,0 +1519,130 @@\n+\n+    static final class StableMap<K, V>\n+            extends AbstractImmutableMap<K, V> {\n+\n+        @Stable\n+        private final Function<? super K, ? extends V> mapper;\n+        @Stable\n+        private final Map<K, StableValueImpl<V>> delegate;\n+\n+        StableMap(Set<K> keys, Function<? super K, ? extends V> mapper) {\n+            this.mapper = mapper;\n+            this.delegate = StableUtil.map(keys);\n+        }\n+\n+        @Override public boolean              containsKey(Object o) { return delegate.containsKey(o); }\n+        @Override public int                  size() { return delegate.size(); }\n+        @Override public Set<Map.Entry<K, V>> entrySet() { return new StableMapEntrySet(); }\n+\n+        @ForceInline\n+        @Override\n+        public V get(Object key) {\n+            return getOrDefault0(key, null);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public V getOrDefault(Object key, V defaultValue) {\n+            return getOrDefault0(key, defaultValue);\n+        }\n+\n+        @ForceInline\n+        private V getOrDefault0(Object key, V defaultValue) {\n+            final StableValueImpl<V> stable = delegate.get(key);\n+            if (stable == null) {\n+                return defaultValue;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final K k = (K) key;\n+            return stable.orElseSet(new Supplier<V>() {\n+                @Override public V get() { return mapper.apply(k); }});\n+        }\n+\n+        @jdk.internal.ValueBased\n+        final class StableMapEntrySet extends AbstractImmutableSet<Map.Entry<K, V>> {\n+\n+            @Stable\n+            private final Set<Map.Entry<K, StableValueImpl<V>>> delegateEntrySet;\n+\n+            StableMapEntrySet() {\n+                this.delegateEntrySet = delegate.entrySet();\n+            }\n+\n+            @Override public Iterator<Map.Entry<K, V>> iterator() { return new LazyMapIterator(); }\n+            @Override public int                       size() { return delegateEntrySet.size(); }\n+            @Override public int                       hashCode() { return StableMap.this.hashCode(); }\n+\n+            @Override\n+            public String toString() {\n+                return StableUtil.renderMappings(this, \"StableSet\", delegateEntrySet, false);\n+            }\n+\n+            @jdk.internal.ValueBased\n+            final class LazyMapIterator implements Iterator<Map.Entry<K, V>> {\n+\n+                @Stable\n+                private final Iterator<Map.Entry<K, StableValueImpl<V>>> delegateIterator;\n+\n+                LazyMapIterator() {\n+                    this.delegateIterator = delegateEntrySet.iterator();\n+                }\n+\n+                @Override public boolean hasNext() { return delegateIterator.hasNext(); }\n+\n+                @Override\n+                public Entry<K, V> next() {\n+                    final Map.Entry<K, StableValueImpl<V>> inner = delegateIterator.next();\n+                    final K k = inner.getKey();\n+                    return new NullableKeyValueHolder<>(k, inner.getValue().orElseSet(new Supplier<V>() {\n+                        @Override public V get() { return mapper.apply(k); }}));\n+                }\n+\n+                @Override\n+                public void forEachRemaining(Consumer<? super Map.Entry<K, V>> action) {\n+                    final Consumer<? super Map.Entry<K, StableValueImpl<V>>> innerAction =\n+                            new Consumer<>() {\n+                                @Override\n+                                public void accept(Entry<K, StableValueImpl<V>> inner) {\n+                                    final K k = inner.getKey();\n+                                    action.accept(new NullableKeyValueHolder<>(k, inner.getValue().orElseSet(new Supplier<V>() {\n+                                        @Override public V get() { return mapper.apply(k); }})));\n+                                }\n+                            };\n+                    delegateIterator.forEachRemaining(innerAction);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public Collection<V> values() {\n+            return new StableMapValues();\n+        }\n+\n+        final class StableMapValues extends AbstractCollection<V> {\n+            @Override public Iterator<V> iterator() { return new ValueIterator(); }\n+            @Override public int size() { return StableMap.this.size(); }\n+            @Override public boolean isEmpty() { return StableMap.this.isEmpty();}\n+            @Override public void clear() { StableMap.this.clear(); }\n+            @Override public boolean contains(Object v) { return StableMap.this.containsValue(v); }\n+\n+            @Override\n+            public String toString() {\n+                final StableValueImpl<V>[] values = delegate.values().toArray(new IntFunction<StableValueImpl<V>[]>() {\n+                    @Override\n+                    public StableValueImpl<V>[] apply(int len) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        var array = (StableValueImpl<V>[]) Array.newInstance(StableValueImpl.class, len);\n+                        return array;\n+                    }\n+                });\n+                return StableUtil.renderElements(StableMap.this, \"StableMap\", values);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return StableUtil.renderMappings(this, \"StableMap\", delegate.entrySet(), true);\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":246,"deletions":5,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n@@ -299,12 +302,18 @@\n-        Iterator<E> it = iterator();\n-        if (! it.hasNext())\n-            return \"[]\";\n-\n-        StringBuilder sb = new StringBuilder();\n-        sb.append('[');\n-        for (;;) {\n-            E e = it.next();\n-            sb.append(e == this ? \"(this Collection)\" : e);\n-            if (! it.hasNext())\n-                return sb.append(']').toString();\n-            sb.append(',').append(' ');\n+        if (base instanceof ImmutableCollections.StableList<E> stableList) {\n+            final StableValueImpl<E>[] reversed = ArraysSupport.reverse(\n+                    Arrays.copyOf(stableList.delegates, stableList.delegates.length));\n+            return StableUtil.renderElements(base, \"Collection\", reversed);\n+        } else {\n+            Iterator<E> it = iterator();\n+            if (!it.hasNext())\n+                return \"[]\";\n+\n+            StringBuilder sb = new StringBuilder();\n+            sb.append('[');\n+            for (; ; ) {\n+                E e = it.next();\n+                sb.append(e == this ? \"(this Collection)\" : e);\n+                if (!it.hasNext())\n+                    return sb.append(']').toString();\n+                sb.append(',').append(' ');\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderListView.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,4 @@\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n@@ -33,0 +37,2 @@\n+    <E> List<E> stableList(int size, IntFunction<? extends E> mapper);\n+    <K, V> Map<K, V> stableMap(Set<K> keys, Function<? super K, ? extends V> mapper);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilCollectionAccess.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,2 @@\n+        @JEP(number = 502, title = \"Stable Values\", status = \"Preview\")\n+        STABLE_VALUES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.util.ImmutableBitSetPredicate;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntPredicate;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Optimized implementation of a stable Function with enums as keys.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param firstOrdinal the lowest ordinal used\n+ * @param delegates    a delegate array of inputs to StableValue mappings\n+ * @param original     the original Function\n+ * @param <E>          the type of the input to the function\n+ * @param <R>          the type of the result of the function\n+ *\/\n+public record StableEnumFunction<E extends Enum<E>, R>(Class<E> enumType,\n+                                                       int firstOrdinal,\n+                                                       IntPredicate member,\n+                                                       @Stable StableValueImpl<R>[] delegates,\n+                                                       Function<? super E, ? extends R> original) implements Function<E, R> {\n+    @ForceInline\n+    @Override\n+    public R apply(E value) {\n+        if (!member.test(value.ordinal())) { \/\/ Implicit null-check of value\n+            throw new IllegalArgumentException(\"Input not allowed: \" + value);\n+        }\n+        final int index = value.ordinal() - firstOrdinal;\n+        final StableValueImpl<R> delegate;\n+        try {\n+            delegate = delegates[index];\n+        } catch (ArrayIndexOutOfBoundsException ioob) {\n+            throw new IllegalArgumentException(\"Input not allowed: \" + value, ioob);\n+        }\n+        return delegate.orElseSet(new Supplier<R>() {\n+                    @Override public R get() { return original.apply(value); }});\n+\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final E[] enumElements = enumType.getEnumConstants();\n+        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>(enumElements.length);\n+        int ordinal = firstOrdinal;\n+        for (int i = 0; i < delegates.length; i++, ordinal++) {\n+            if (member.test(ordinal)) {\n+                entries.add(new AbstractMap.SimpleImmutableEntry<>(enumElements[ordinal], delegates[i]));\n+            }\n+        }\n+        return StableUtil.renderMappings(this, \"StableFunction\", entries, true);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T, E extends Enum<E>, R> Function<T, R> of(Set<? extends T> inputs,\n+                                                              Function<? super T, ? extends R> original) {\n+        final BitSet bitSet = new BitSet(inputs.size());\n+        \/\/ The input set is not empty\n+        int min = Integer.MAX_VALUE;\n+        int max = Integer.MIN_VALUE;\n+        for (T t : inputs) {\n+            final int ordinal = ((E) t).ordinal();\n+            min = Math.min(min, ordinal);\n+            max = Math.max(max, ordinal);\n+            bitSet.set(ordinal);\n+        }\n+\n+        final int size = max - min + 1;\n+        final Class<E> enumType = (Class<E>)inputs.iterator().next().getClass();\n+        final IntPredicate member = ImmutableBitSetPredicate.of(bitSet);\n+        return (Function<T, R>) new StableEnumFunction<E, R>(enumType, min, member, StableUtil.array(size), (Function<E, R>) original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+\/\/ Note: It would be possible to just use `LazyMap::get` with some additional logic\n+\/\/ instead of this class but explicitly providing a class like this provides better\n+\/\/ debug capability, exception handling, and may provide better performance.\n+\/**\n+ * Implementation of a stable Function.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param values   a delegate map of inputs to StableValue mappings\n+ * @param original the original Function\n+ * @param <T>      the type of the input to the function\n+ * @param <R>      the type of the result of the function\n+ *\/\n+public record StableFunction<T, R>(Map<? extends T, StableValueImpl<R>> values,\n+                                   Function<? super T, ? extends R> original) implements Function<T, R> {\n+\n+    @ForceInline\n+    @Override\n+    public R apply(T value) {\n+        final StableValueImpl<R> stable = values.get(value);\n+        if (stable == null) {\n+            throw new IllegalArgumentException(\"Input not allowed: \" + value);\n+        }\n+        return stable.orElseSet(new Supplier<R>() {\n+            @Override  public R get() { return original.apply(value); }});\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return StableUtil.renderMappings(this, \"StableFunction\", values.entrySet(), true);\n+    }\n+\n+    public static <T, R> StableFunction<T, R> of(Set<? extends T> inputs,\n+                                                 Function<? super T, ? extends R> original) {\n+        return new StableFunction<>(StableUtil.map(inputs), original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFunction.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+\/\/ Note: It would be possible to just use `LazyList::get` instead of this\n+\/\/ class but explicitly providing a class like this provides better\n+\/\/ debug capability, exception handling, and may provide better performance.\n+\/**\n+ * Implementation of a stable IntFunction.\n+ * <p>\n+ * For performance reasons (~10%), we are not delegating to a StableList but are using\n+ * the more primitive functions in StableValueUtil that are shared with StableList\/StableValueImpl.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param <R> the return type\n+ *\/\n+public record StableIntFunction<R>(@Stable StableValueImpl<R>[] delegates,\n+                                   IntFunction<? extends R> original) implements IntFunction<R> {\n+\n+    @ForceInline\n+    @Override\n+    public R apply(int index) {\n+        final StableValueImpl<R> delegate;\n+        try {\n+            delegate =  delegates[index];\n+        } catch (ArrayIndexOutOfBoundsException ioob) {\n+            throw new IllegalArgumentException(\"Input not allowed: \" + index, ioob);\n+        }\n+        return delegate.orElseSet(new Supplier<R>() {\n+                    @Override public R get() { return original.apply(index); }});\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return StableUtil.renderElements(this, \"StableIntFunction\", delegates);\n+    }\n+\n+    public static <R> StableIntFunction<R> of(int size, IntFunction<? extends R> original) {\n+        return new StableIntFunction<>(StableUtil.array(size), original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableIntFunction.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Implementation of a stable supplier.\n+ * <p>\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param <T> the return type\n+ *\/\n+public record StableSupplier<T>(StableValueImpl<T> delegate,\n+                                Supplier<? extends T> original) implements Supplier<T> {\n+\n+    @ForceInline\n+    @Override\n+    public T get() {\n+        return delegate.orElseSet(original);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final Object t = delegate.wrappedContentAcquire();\n+        return t == this ? \"(this StableSupplier)\" : StableValueImpl.renderWrapped(t);\n+    }\n+\n+    public static <T> StableSupplier<T> of(Supplier<? extends T> original) {\n+        return new StableSupplier<>(StableValueImpl.of(), original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableSupplier.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+package jdk.internal.lang.stable;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class StableUtil {\n+\n+    private StableUtil() {}\n+\n+    public static <R> String renderElements(Object self,\n+                                            String selfName,\n+                                            StableValueImpl<R>[] delegates) {\n+        return renderElements(self, selfName, delegates, 0, delegates.length);\n+    }\n+\n+    public static <R> String renderElements(Object self,\n+                                            String selfName,\n+                                            StableValueImpl<R>[] delegates,\n+                                            int offset,\n+                                            int length) {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"[\");\n+        boolean first = true;\n+        for (int i = 0; i < length; i++) {\n+            if (first) { first = false; } else { sb.append(\", \"); }\n+            final Object value = delegates[i + offset].wrappedContentAcquire();\n+            if (value == self) {\n+                sb.append(\"(this \").append(selfName).append(\")\");\n+            } else {\n+                sb.append(StableValueImpl.renderWrapped(value));\n+            }\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    public static <K, V> String renderMappings(Object self,\n+                                               String selfName,\n+                                               Iterable<Map.Entry<K, StableValueImpl<V>>> delegates,\n+                                               boolean curly) {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(curly ? \"{\" : \"[\");\n+        boolean first = true;\n+        for (var e : delegates) {\n+            if (first) { first = false; } else { sb.append(\", \"); }\n+            final Object value = e.getValue().wrappedContentAcquire();\n+            sb.append(e.getKey()).append('=');\n+            if (value == self) {\n+                sb.append(\"(this \").append(selfName).append(\")\");\n+            } else {\n+                sb.append(StableValueImpl.renderWrapped(value));\n+            }\n+        }\n+        sb.append(curly ? \"}\" : \"]\");\n+        return sb.toString();\n+    }\n+\n+\n+    public static <T> StableValueImpl<T>[] array(int size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        final var stableValues = (StableValueImpl<T>[]) new StableValueImpl<?>[size];\n+        for (int i = 0; i < size; i++) {\n+            stableValues[i] = StableValueImpl.of();\n+        }\n+        return stableValues;\n+    }\n+\n+    public static <K, T> Map<K, StableValueImpl<T>> map(Set<K> keys) {\n+        Objects.requireNonNull(keys);\n+        @SuppressWarnings(\"unchecked\")\n+        final var entries = (Map.Entry<K, StableValueImpl<T>>[]) new Map.Entry<?, ?>[keys.size()];\n+        int i = 0;\n+        for (K key : keys) {\n+            entries[i++] = Map.entry(key, StableValueImpl.of());\n+        }\n+        return Map.ofEntries(entries);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * The implementation of StableValue.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param <T> type of the content\n+ *\/\n+public final class StableValueImpl<T> implements StableValue<T> {\n+\n+    static final String UNSET_LABEL = \".unset\";\n+\n+    \/\/ Unsafe allows StableValue to be used early in the boot sequence\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ Unsafe offsets for direct field access\n+    private static final long CONTENT_OFFSET =\n+            UNSAFE.objectFieldOffset(StableValueImpl.class, \"content\");\n+\n+    \/\/ Used to indicate a holder value is `null` (see field `value` below)\n+    \/\/ A wrapper method `nullSentinel()` is used for generic type conversion.\n+    private static final Object NULL_SENTINEL = new Object();\n+\n+    \/\/ Generally, fields annotated with `@Stable` are accessed by the JVM using special\n+    \/\/ memory semantics rules (see `parse.hpp` and `parse(1|2|3).cpp`).\n+    \/\/\n+    \/\/ This field is used directly and reflectively via Unsafe using explicit memory semantics.\n+    \/\/\n+    \/\/ | Value          |  Meaning      |\n+    \/\/ | -------------- |  ------------ |\n+    \/\/ | null           |  Unset        |\n+    \/\/ | NULL_SENTINEL  |  Set(null)    |\n+    \/\/ | other          |  Set(other)   |\n+    \/\/\n+    @Stable\n+    private Object content;\n+\n+    \/\/ Only allow creation via the factory `StableValueImpl::newInstance`\n+    private StableValueImpl() {}\n+\n+    @ForceInline\n+    @Override\n+    public boolean trySet(T content) {\n+        if (wrappedContentAcquire() != null) {\n+            return false;\n+        }\n+        \/\/ Prevent reentry via an orElseSet(supplier)\n+        preventReentry();\n+        \/\/ Mutual exclusion is required here as `orElseSet` might also\n+        \/\/ attempt to modify the `wrappedValue`\n+        synchronized (this) {\n+            return wrapAndSet(content);\n+        }\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setOrThrow(T content) {\n+        if (!trySet(content)) {\n+            \/\/ Neither the set content nor the provided content is reveled in the\n+            \/\/ exception message as it might be sensitive.\n+            throw new IllegalStateException(\"The content is already set\");\n+        }\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T orElseThrow() {\n+        final Object t = wrappedContentAcquire();\n+        if (t == null) {\n+            throw new NoSuchElementException(\"No content set\");\n+        }\n+        return unwrap(t);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T orElse(T other) {\n+        final Object t = wrappedContentAcquire();\n+        return (t == null) ? other : unwrap(t);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public boolean isSet() {\n+        return wrappedContentAcquire() != null;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T orElseSet(Supplier<? extends T> supplier) {\n+        Objects.requireNonNull(supplier);\n+        final Object t = wrappedContentAcquire();\n+        return (t == null) ? orElseSetSlowPath(supplier) : unwrap(t);\n+    }\n+\n+    @DontInline\n+    private T orElseSetSlowPath(Supplier<? extends T> supplier) {\n+        preventReentry();\n+        synchronized (this) {\n+            final Object t = content;  \/\/ Plain semantics suffice here\n+            if (t == null) {\n+                final T newValue = supplier.get();\n+                \/\/ The mutex is not reentrant so we know newValue should be returned\n+                wrapAndSet(newValue);\n+                return newValue;\n+            }\n+            return unwrap(t);\n+        }\n+    }\n+\n+    \/\/ The methods equals() and hashCode() should be based on identity (defaults from Object)\n+\n+    @Override\n+    public String toString() {\n+        final Object t = wrappedContentAcquire();\n+        return t == this\n+                ? \"(this StableValue)\"\n+                : renderWrapped(t);\n+    }\n+\n+    \/\/ Internal methods shared with other internal classes\n+\n+    @ForceInline\n+    public Object wrappedContentAcquire() {\n+        return UNSAFE.getReferenceAcquire(this, CONTENT_OFFSET);\n+    }\n+\n+    static String renderWrapped(Object t) {\n+        return (t == null) ? UNSET_LABEL : Objects.toString(unwrap(t));\n+    }\n+\n+    \/\/ Private methods\n+\n+    private void preventReentry() {\n+        if (Thread.holdsLock(this)) {\n+            throw new IllegalStateException(\"Recursive initialization is not supported\");\n+        }\n+    }\n+\n+    \/**\n+     * Wraps the provided {@code newValue} and tries to set the content.\n+     * <p>\n+     * This method ensures the {@link Stable} field is written to at most once.\n+     *\n+     * @param newValue to wrap and set\n+     * @return if the content was set\n+     *\/\n+    @ForceInline\n+    private boolean wrapAndSet(Object newValue) {\n+        assert Thread.holdsLock(this);\n+        \/\/ We know we hold the monitor here so plain semantic is enough\n+        if (content == null) {\n+            UNSAFE.putReferenceRelease(this, CONTENT_OFFSET, wrap(newValue));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+\n+    \/\/ Wraps `null` values into a sentinel value\n+    @ForceInline\n+    private static Object wrap(Object t) {\n+        return (t == null) ? NULL_SENTINEL : t;\n+    }\n+\n+    \/\/ Unwraps null sentinel values into `null`\n+    @SuppressWarnings(\"unchecked\")\n+    @ForceInline\n+    private static <T> T unwrap(Object t) {\n+        return t != NULL_SENTINEL ? (T) t : null;\n+    }\n+\n+    \/\/ Factory\n+\n+    public static <T> StableValueImpl<T> of() {\n+        return new StableValueImpl<>();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableFunctionTest methods\n+ * @enablePreview\n+ * @run junit StableFunctionTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableFunctionTest {\n+\n+    enum Value {\n+        \/\/ Zero is here so that we have enums with ordinals before the first one\n+        \/\/ actually used in input sets (i.e. ZERO is not in the input set)\n+        ZERO(0),\n+        ILLEGAL_BEFORE(-1),\n+        \/\/ Valid values\n+        THIRTEEN(13),\n+        ILLEGAL_BETWEEN(-2),\n+        FORTY_TWO(42),\n+        \/\/ Illegal values (not in the input set)\n+        ILLEGAL_AFTER(-3);\n+\n+        final int intValue;\n+\n+        Value(int intValue) {\n+            this.intValue = intValue;\n+        }\n+\n+        int asInt() {\n+            return intValue;\n+        }\n+\n+    }\n+\n+    private static final Function<Value, Integer> MAPPER = Value::asInt;\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void factoryInvariants(Set<Value> inputs) {\n+        assertThrows(NullPointerException.class, () -> StableValue.function(null, MAPPER));\n+        assertThrows(NullPointerException.class, () -> StableValue.function(inputs, null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void basic(Set<Value> inputs) {\n+        basic(inputs, MAPPER);\n+        toStringTest(inputs, MAPPER);\n+        basic(inputs, _ -> null);\n+        toStringTest(inputs, _ -> null);\n+    }\n+\n+    void basic(Set<Value> inputs, Function<Value, Integer> mapper) {\n+        StableTestUtil.CountingFunction<Value, Integer> cif = new StableTestUtil.CountingFunction<>(mapper);\n+        var cached = StableValue.function(inputs, cif);\n+        assertEquals(mapper.apply(Value.FORTY_TWO), cached.apply(Value.FORTY_TWO));\n+        assertEquals(1, cif.cnt());\n+        assertEquals(mapper.apply(Value.FORTY_TWO), cached.apply(Value.FORTY_TWO));\n+        assertEquals(1, cif.cnt());\n+        var x0 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_BEFORE));\n+        assertEquals(\"Input not allowed: ILLEGAL_BEFORE\", x0.getMessage());\n+        var x1 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_BETWEEN));\n+        assertEquals(\"Input not allowed: ILLEGAL_BETWEEN\", x1.getMessage());\n+        var x2 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_AFTER));\n+        assertEquals(\"Input not allowed: ILLEGAL_AFTER\", x2.getMessage());\n+    }\n+\n+    void toStringTest(Set<Value> inputs, Function<Value, Integer> mapper) {\n+        var cached = StableValue.function(inputs, mapper);\n+        cached.apply(Value.FORTY_TWO);\n+        var toString = cached.toString();\n+        assertTrue(toString.startsWith(\"{\"));\n+        \/\/ Key order is unspecified\n+        assertTrue(toString.contains(Value.THIRTEEN + \"=.unset\"));\n+        assertTrue(toString.contains(Value.FORTY_TWO + \"=\" + mapper.apply(Value.FORTY_TWO)));\n+        assertTrue(toString.endsWith(\"}\"));\n+        \/\/ One between the values\n+        assertEquals(1L, toString.chars().filter(ch -> ch == ',').count());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"emptySets\")\n+    void empty(Set<Value> inputs) {\n+        Function<Value, Integer> f0 = StableValue.function(inputs, Value::asInt);\n+        Function<Value, Integer> f1 = StableValue.function(inputs, Value::asInt);\n+        assertEquals(\"{}\", f0.toString());\n+        assertThrows(NullPointerException.class, () -> f0.apply(null));\n+        assertNotEquals(f0, f1);\n+        assertNotEquals(null, f0);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void exception(Set<Value> inputs) {\n+        StableTestUtil.CountingFunction<Value, Integer> cif = new StableTestUtil.CountingFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var cached = StableValue.function(inputs, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(Value.FORTY_TWO));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(Value.FORTY_TWO));\n+        assertEquals(2, cif.cnt());\n+        var toString = cached.toString();\n+        assertTrue(toString.startsWith(\"{\"));\n+        \/\/ Key order is unspecified\n+        assertTrue(toString.contains(Value.THIRTEEN + \"=.unset\"));\n+        assertTrue(toString.contains(Value.FORTY_TWO + \"=.unset\"));\n+        assertTrue(toString.endsWith(\"}\"));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void circular(Set<Value> inputs) {\n+        final AtomicReference<Function<?, ?>> ref = new AtomicReference<>();\n+        Function<Value, Function<?, ?>> cached = StableValue.function(inputs, _ -> ref.get());\n+        ref.set(cached);\n+        cached.apply(Value.FORTY_TWO);\n+        var toString = cached.toString();\n+        assertTrue(toString.contains(\"FORTY_TWO=(this StableFunction)\"), toString);\n+        assertDoesNotThrow(cached::hashCode);\n+        assertDoesNotThrow((() -> cached.equals(cached)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void equality(Set<Value> inputs) {\n+        Function<Value, Integer> mapper = Value::asInt;\n+        Function<Value, Integer> f0 = StableValue.function(inputs, mapper);\n+        Function<Value, Integer> f1 = StableValue.function(inputs, mapper);\n+        \/\/ No function is equal to another function\n+        assertNotEquals(f0, f1);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void hashCodeStable(Set<Value> inputs) {\n+        Function<Value, Integer> f0 = StableValue.function(inputs, Value::asInt);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        if (!inputs.isEmpty()) {\n+            f0.apply(Value.FORTY_TWO);\n+            assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        }\n+    }\n+\n+    @Test\n+    void nullKeys() {\n+        Set<Value> inputs = new HashSet<>();\n+        inputs.add(Value.FORTY_TWO);\n+        inputs.add(null);\n+        assertThrows(NullPointerException.class, () -> StableValue.function(inputs, MAPPER));\n+    }\n+\n+    @Test\n+    void usesOptimizedVersion() {\n+        Function<Value, Integer> enumFunction = StableValue.function(EnumSet.of(Value.FORTY_TWO), Value::asInt);\n+        assertEquals(\"jdk.internal.lang.stable.StableEnumFunction\", enumFunction.getClass().getName());\n+        Function<Value, Integer> emptyFunction = StableValue.function(Set.of(), Value::asInt);\n+        assertEquals(\"jdk.internal.lang.stable.StableFunction\", emptyFunction.getClass().getName());\n+    }\n+\n+    private static Stream<Set<Value>> nonEmptySets() {\n+        return Stream.of(\n+                Set.of(Value.FORTY_TWO, Value.THIRTEEN),\n+                linkedHashSet(Value.THIRTEEN, Value.FORTY_TWO),\n+                treeSet(Value.FORTY_TWO, Value.THIRTEEN),\n+                EnumSet.of(Value.FORTY_TWO, Value.THIRTEEN)\n+        );\n+    }\n+\n+    private static Stream<Set<Value>> emptySets() {\n+        return Stream.of(\n+                Set.of(),\n+                linkedHashSet(),\n+                treeSet(),\n+                EnumSet.noneOf(Value.class)\n+        );\n+    }\n+\n+    private static Stream<Set<Value>> allSets() {\n+        return Stream.concat(\n+                nonEmptySets(),\n+                emptySets()\n+        );\n+    }\n+\n+    static Set<Value> treeSet(Value... values) {\n+        return populate(new TreeSet<>(Comparator.comparingInt(Value::asInt).reversed()),values);\n+    }\n+\n+    static Set<Value> linkedHashSet(Value... values) {\n+        return populate(new LinkedHashSet<>(), values);\n+    }\n+\n+    static Set<Value> populate(Set<Value> set, Value... values) {\n+        set.addAll(Arrays.asList(values));\n+        return set;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFunctionTest.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableIntFunctionTest methods\n+ * @enablePreview\n+ * @run junit StableIntFunctionTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.IntFunction;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableIntFunctionTest {\n+\n+    private static final int SIZE = 2;\n+    private static final IntFunction<Integer> MAPPER = i -> i;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(IllegalArgumentException.class, () -> StableValue.intFunction(-1, MAPPER));\n+        assertThrows(NullPointerException.class, () -> StableValue.intFunction(SIZE, null));\n+    }\n+\n+    @Test\n+    void basic() {\n+        basic(MAPPER);\n+        basic(i -> null);\n+    }\n+\n+    void basic(IntFunction<Integer> mapper) {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(mapper);\n+        var cached = StableValue.intFunction(SIZE, cif);\n+        assertEquals(\"[.unset, .unset]\", cached.toString());\n+        assertEquals(mapper.apply(1), cached.apply(1));\n+        assertEquals(1, cif.cnt());\n+        assertEquals(mapper.apply(1), cached.apply(1));\n+        assertEquals(1, cif.cnt());\n+        assertEquals(\"[.unset, \" + mapper.apply(1) + \"]\", cached.toString());\n+        assertThrows(IllegalArgumentException.class, () -> cached.apply(SIZE));\n+        assertThrows(IllegalArgumentException.class, () -> cached.apply(-1));\n+        assertThrows(IllegalArgumentException.class, () -> cached.apply(1_000_000));\n+    }\n+\n+    @Test\n+    void exception() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var cached = StableValue.intFunction(SIZE, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(1));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(1));\n+        assertEquals(2, cif.cnt());\n+        assertEquals(\"[.unset, .unset]\", cached.toString());\n+    }\n+\n+    @Test\n+    void circular() {\n+        final AtomicReference<IntFunction<?>> ref = new AtomicReference<>();\n+        IntFunction<IntFunction<?>> cached = StableValue.intFunction(SIZE, _ -> ref.get());\n+        ref.set(cached);\n+        cached.apply(0);\n+        String toString = cached.toString();\n+        assertEquals(\"[(this StableIntFunction), .unset]\", toString);\n+        assertDoesNotThrow(cached::hashCode);\n+        assertDoesNotThrow((() -> cached.equals(cached)));\n+    }\n+\n+    @Test\n+    void equality() {\n+        IntFunction<Integer> f0 = StableValue.intFunction(8, MAPPER);\n+        IntFunction<Integer> f1 = StableValue.intFunction(8, MAPPER);\n+        \/\/ No function is equal to another function\n+        assertNotEquals(f0, f1);\n+    }\n+\n+    @Test\n+    void hashCodeStable() {\n+        IntFunction<Integer> f0 = StableValue.intFunction(8, MAPPER);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        f0.apply(4);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableIntFunctionTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,433 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for LazyList methods\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @enablePreview\n+ * @run junit StableListTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.RandomAccess;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableListTest {\n+\n+    private static final int ZERO = 0;\n+    private static final int INDEX = 7;\n+    private static final int SIZE = 31;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> StableValue.list(SIZE, null));\n+        assertThrows(IllegalArgumentException.class, () -> StableValue.list(-1, IDENTITY));\n+    }\n+\n+    @Test\n+    void isEmpty() {\n+        assertFalse(newList().isEmpty());\n+        assertTrue(newEmptyList().isEmpty());\n+    }\n+\n+    @Test\n+    void size() {\n+        assertEquals(SIZE, newList().size());\n+        assertEquals(ZERO, newEmptyList().size());\n+    }\n+\n+    @Test\n+    void get() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(IDENTITY);\n+        var lazy = StableValue.list(SIZE, cif);\n+        for (int i = 0; i < SIZE; i++) {\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(i + 1, cif.cnt());\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(i + 1, cif.cnt());\n+        }\n+    }\n+\n+    @Test\n+    void getException() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var lazy = StableValue.list(SIZE, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(INDEX));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(INDEX));\n+        assertEquals(2, cif.cnt());\n+    }\n+\n+    @Test\n+    void toArray() {\n+        assertArrayEquals(new Object[ZERO], newEmptyList().toArray());\n+        assertArrayEquals(newRegularList().toArray(), newList().toArray());\n+    }\n+\n+    @Test\n+    void toArrayWithArrayLarger() {\n+        Integer[] actual = new Integer[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            actual[INDEX] = 100 + i;\n+        }\n+        var list = StableValue.list(INDEX, IDENTITY);\n+        assertSame(actual, list.toArray(actual));\n+        Integer[] expected = IntStream.range(0, SIZE)\n+                .mapToObj(i -> i < INDEX ? i : null)\n+                .toArray(Integer[]::new);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void toArrayWithArraySmaller() {\n+        Integer[] arr = new Integer[INDEX];\n+        Integer[] actual = newList().toArray(arr);\n+        assertNotSame(arr, actual);\n+        Integer[] expected = newRegularList().toArray(new Integer[0]);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void toArrayWithGenerator() {\n+        Integer[] expected = newRegularList().toArray(Integer[]::new);\n+        Integer[] actual = newList().toArray(Integer[]::new);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void firstIndex() {\n+        var lazy = newList();\n+        for (int i = INDEX; i < SIZE; i++) {\n+            assertEquals(i, lazy.indexOf(i));\n+        }\n+        assertEquals(-1, lazy.indexOf(SIZE + 1));\n+    }\n+\n+    @Test\n+    void lastIndex() {\n+        var lazy = newList();\n+        for (int i = INDEX; i < SIZE; i++) {\n+            assertEquals(i, lazy.lastIndexOf(i));\n+        }\n+        assertEquals(-1, lazy.lastIndexOf(SIZE + 1));\n+    }\n+\n+    @Test\n+    void toStringTest() {\n+        assertEquals(\"[]\", newEmptyList().toString());\n+        var list = StableValue.list(2, IDENTITY);\n+        assertEquals(\"[.unset, .unset]\", list.toString());\n+        list.get(0);\n+        assertEquals(\"[0, .unset]\", list.toString());\n+        list.get(1);\n+        assertEquals(\"[0, 1]\", list.toString());\n+    }\n+\n+    @Test\n+    void hashCodeTest() {\n+        assertEquals(List.of().hashCode(), newEmptyList().hashCode());\n+        assertEquals(newRegularList().hashCode(), newList().hashCode());\n+    }\n+\n+    @Test\n+    void equalsTest() {\n+        assertTrue(newEmptyList().equals(List.of()));\n+        assertTrue(List.of().equals(newEmptyList()));\n+        assertTrue(newList().equals(newRegularList()));\n+        assertTrue(newRegularList().equals(newList()));\n+        assertFalse(newList().equals(\"A\"));\n+    }\n+\n+    @Test\n+    void equalsPartialEvaluationTest() {\n+        var list = StableValue.list(2, IDENTITY);\n+        assertFalse(list.equals(List.of(0)));\n+        assertEquals(\"[0, .unset]\", list.toString());\n+        assertTrue(list.equals(List.of(0, 1)));\n+        assertEquals(\"[0, 1]\", list.toString());\n+    }\n+\n+    @Test\n+    void iteratorTotal() {\n+        var iterator = newList().iterator();\n+        for (int i = 0; i < SIZE; i++) {\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertEquals(i, iterator.next());\n+        }\n+        assertFalse(iterator.hasNext());\n+        assertThrows(NoSuchElementException.class, iterator::next);\n+        AtomicInteger cnt = new AtomicInteger();\n+        iterator.forEachRemaining(_ -> cnt.incrementAndGet());\n+        assertEquals(0, cnt.get());\n+    }\n+\n+    @Test\n+    void iteratorPartial() {\n+        var iterator = newList().iterator();\n+        for (int i = 0; i < INDEX; i++) {\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertEquals(i, iterator.next());\n+        }\n+        assertTrue(iterator.hasNext());\n+        AtomicInteger cnt = new AtomicInteger();\n+        iterator.forEachRemaining(_ -> cnt.incrementAndGet());\n+        assertEquals(SIZE - INDEX, cnt.get());\n+        assertFalse(iterator.hasNext());\n+        assertThrows(NoSuchElementException.class, iterator::next);\n+    }\n+\n+    @Test\n+    void subList() {\n+        var lazy = newList();\n+        var lazySubList = lazy.subList(1, SIZE);\n+        assertInstanceOf(RandomAccess.class, lazySubList);\n+        var regularList = newRegularList();\n+        var regularSubList = regularList.subList(1, SIZE);\n+        assertEquals(regularSubList, lazySubList);\n+    }\n+\n+    @Test\n+    void subList2() {\n+        var lazy = newList();\n+        var lazySubList = lazy.subList(1, SIZE);\n+        lazySubList.get(0);\n+        var eq = newList();\n+        eq.get(1);\n+        assertEquals(eq.toString(), lazy.toString());\n+    }\n+\n+    @Test\n+    void subListToString() {\n+        subListToString0(newList());\n+        subListToString0(newList().subList(1, SIZE));\n+        subListToString0(newList().subList(1, SIZE).subList(0, SIZE - 2));\n+    }\n+\n+    void subListToString0(List<Integer> subList) {\n+        assertEquals(asString(\".unset\", subList), subList.toString());\n+\n+        var first = subList.getFirst();\n+        assertEquals(asString(first.toString(), subList), subList.toString());\n+    }\n+\n+    @Test\n+    void reversed() {\n+        var reversed = newList().reversed();\n+        assertInstanceOf(RandomAccess.class, reversed);\n+        assertEquals(SIZE - 1, reversed.getFirst());\n+        assertEquals(0, reversed.getLast());\n+\n+        var reversed2 = reversed.reversed();\n+        assertEquals(0, reversed2.getFirst());\n+        assertEquals(SIZE - 1, reversed2.getLast());\n+    }\n+\n+    @Test\n+    void reversedToString() {\n+        var reversed = newList().reversed();\n+        subListToString0(reversed);\n+    }\n+\n+    @Test\n+    void subListReversedToString() {\n+        var list = newList().subList(1, SIZE - 1).reversed();\n+        \/\/ This combination is not lazy. There has to be a limit somewhere.\n+        var regularList = newRegularList().subList(1, SIZE - 1).reversed();\n+        assertEquals(regularList.toString(), list.toString());\n+    }\n+\n+    @Test\n+    void recursiveCall() {\n+        AtomicReference<IntFunction<Integer>> ref = new AtomicReference<>();\n+        var lazy = StableValue.list(SIZE, i -> ref.get().apply(i));\n+        ref.set(lazy::get);\n+        var x = assertThrows(IllegalStateException.class, () -> lazy.get(INDEX));\n+        assertEquals(\"Recursive initialization is not supported\", x.getMessage());\n+    }\n+\n+    \/\/ Immutability\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void unsupported(Operation operation) {\n+        assertThrowsForOperation(UnsupportedOperationException.class, operation);\n+    }\n+\n+    \/\/ Method parameter invariant checking\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullAverseOperations\")\n+    void nullAverse(Operation operation) {\n+        assertThrowsForOperation(NullPointerException.class, operation);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"outOfBoundsOperations\")\n+    void outOfBounds(Operation operation) {\n+        assertThrowsForOperation(IndexOutOfBoundsException.class, operation);\n+    }\n+\n+    static <T extends Throwable> void assertThrowsForOperation(Class<T> expectedType, Operation operation) {\n+        var lazy = newList();\n+        assertThrows(expectedType, () -> operation.accept(lazy));\n+        var sub = lazy.subList(1, SIZE \/ 2);\n+        assertThrows(expectedType, () -> operation.accept(sub));\n+        var subSub = sub.subList(1, sub.size() \/ 2);\n+        assertThrows(expectedType, () -> operation.accept(subSub));\n+    }\n+\n+    \/\/ Implementing interfaces\n+\n+    @Test\n+    void serializable() {\n+        serializable(newList());\n+        serializable(newEmptyList());\n+    }\n+\n+    void serializable(List<Integer> list) {\n+        assertFalse(list instanceof Serializable);\n+        if (list.size()>INDEX) {\n+            assertFalse(newList().subList(1, INDEX) instanceof Serializable);\n+        }\n+        assertFalse(list.iterator() instanceof Serializable);\n+        assertFalse(list.reversed() instanceof Serializable);\n+        assertFalse(list.spliterator() instanceof Serializable);\n+    }\n+\n+    @Test\n+    void randomAccess() {\n+        assertInstanceOf(RandomAccess.class, newList());\n+        assertInstanceOf(RandomAccess.class, newEmptyList());\n+        assertInstanceOf(RandomAccess.class, newList().subList(1, INDEX));\n+    }\n+\n+    @Test\n+    void distinct() {\n+        StableValueImpl<Integer>[] array = StableUtil.array(SIZE);\n+        assertEquals(SIZE, array.length);\n+        \/\/ Check, every StableValue is distinct\n+        Map<StableValue<Integer>, Boolean> idMap = new IdentityHashMap<>();\n+        for (var e: array) {\n+            idMap.put(e, true);\n+        }\n+        assertEquals(SIZE, idMap.size());\n+    }\n+\n+    \/\/ Support constructs\n+\n+    record Operation(String name,\n+                     Consumer<List<Integer>> consumer) implements Consumer<List<Integer>> {\n+        @Override public void   accept(List<Integer> list) { consumer.accept(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    static Stream<Operation> nullAverseOperations() {\n+        return Stream.of(\n+                new Operation(\"forEach\",     l -> l.forEach(null)),\n+                new Operation(\"containsAll\", l -> l.containsAll(null)),\n+                new Operation(\"toArray\",     l -> l.toArray((Integer[]) null)),\n+                new Operation(\"toArray\",     l -> l.toArray((IntFunction<Integer[]>) null))\n+        );\n+    }\n+\n+    static Stream<Operation> outOfBoundsOperations() {\n+        return Stream.of(\n+                new Operation(\"get(-1)\",        l -> l.get(-1)),\n+                new Operation(\"get(size)\",      l -> l.get(l.size())),\n+                new Operation(\"sublist(-1,)\",   l -> l.subList(-1, INDEX)),\n+                new Operation(\"sublist(,size)\", l -> l.subList(0, l.size() + 1)),\n+                new Operation(\"listIter(-1)\",   l -> l.listIterator(-1)),\n+                new Operation(\"listIter(size)\", l -> l.listIterator(l.size() + 1))\n+        );\n+    }\n+\n+    static Stream<Operation> unsupportedOperations() {\n+        final Set<Integer> SET = Set.of(0, 1);\n+        return Stream.of(\n+                new Operation(\"add(0)\",            l -> l.add(0)),\n+                new Operation(\"add(0, 1)\",         l -> l.add(0, 1)),\n+                new Operation(\"addAll(col)\",       l -> l.addAll(SET)),\n+                new Operation(\"addAll(1, coll)\",   l -> l.addAll(1, SET)),\n+                new Operation(\"addFirst(0)\",       l -> l.addFirst(0)),\n+                new Operation(\"addLast(0)\",        l -> l.addLast(0)),\n+                new Operation(\"clear\",             List::clear),\n+                new Operation(\"remove(Obj)\",       l -> l.remove((Object)1)),\n+                new Operation(\"remove(1)\",         l -> l.remove(1)),\n+                new Operation(\"removeAll\",         l -> l.removeAll(SET)),\n+                new Operation(\"removeFirst\",       List::removeFirst),\n+                new Operation(\"removeLast\",        List::removeLast),\n+                new Operation(\"removeIf\",          l -> l.removeIf(i -> i % 2 == 0)),\n+                new Operation(\"replaceAll\",        l -> l.replaceAll(i -> i + 1)),\n+                new Operation(\"sort\",              l -> l.sort(Comparator.naturalOrder())),\n+                new Operation(\"iterator().remove\", l -> l.iterator().remove()),\n+                new Operation(\"listIter().remove\", l -> l.listIterator().remove()),\n+                new Operation(\"listIter().add\",    l -> l.listIterator().add(1)),\n+                new Operation(\"listIter().set\",    l -> l.listIterator().set(1))\n+        );\n+    }\n+\n+    static List<Integer> newList() {\n+        return StableValue.list(SIZE, IDENTITY);\n+    }\n+\n+    static List<Integer> newEmptyList() {\n+        return StableValue.list(ZERO, IDENTITY);\n+    }\n+\n+    static List<Integer> newRegularList() {\n+        return IntStream.range(0, SIZE).boxed().toList();\n+    }\n+\n+    static String asString(String first, List<Integer> list) {\n+        return \"[\" + first + \", \" + Stream.generate(() -> \".unset\")\n+                .limit(list.size() - 1)\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":433,"deletions":0,"binary":false,"changes":433,"status":"added"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for LazyMap methods\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @enablePreview\n+ * @run junit StableMapTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.util.AbstractMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableMapTest {\n+\n+    private static final int NOT_PRESENT = 147;\n+    private static final int KEY = 7;\n+    private static final Set<Integer> KEYS = Set.of(0, KEY, 13);\n+    private static final Set<Integer> EMPTY = Set.of();\n+    private static final Function<Integer, Integer> IDENTITY = Function.identity();\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> StableValue.map(KEYS, null));\n+        assertThrows(NullPointerException.class, () -> StableValue.map(null, IDENTITY));\n+    }\n+\n+    @Test\n+    void isEmpty() {\n+        assertFalse(newMap().isEmpty());\n+        assertTrue(newEmptyMap().isEmpty());\n+    }\n+\n+    @Test\n+    void size() {\n+        assertEquals(KEYS.size(), newMap().size());\n+        assertEquals(EMPTY.size(), newEmptyMap().size());\n+    }\n+\n+    @Test\n+    void get() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cf = new StableTestUtil.CountingFunction<>(IDENTITY);\n+        var lazy = StableValue.map(KEYS, cf);\n+        int cnt = 1;\n+        for (int i : KEYS) {\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(cnt, cf.cnt());\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(cnt++, cf.cnt());\n+        }\n+        assertNull(lazy.get(NOT_PRESENT));\n+    }\n+\n+    @Test\n+    void getException() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cf = new StableTestUtil.CountingFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var lazy = StableValue.map(KEYS, cf);\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(KEY));\n+        assertEquals(1, cf.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(KEY));\n+        assertEquals(2, cf.cnt());\n+    }\n+\n+    @Test\n+    void containsKey() {\n+        var lazy = newMap();\n+        for (int i : KEYS) {\n+            assertTrue(lazy.containsKey(i));\n+        }\n+        assertFalse(lazy.containsKey(NOT_PRESENT));\n+    }\n+\n+    @Test\n+    void containsValue() {\n+        var lazy = newMap();\n+        for (int i : KEYS) {\n+            assertTrue(lazy.containsValue(i));\n+        }\n+        assertFalse(lazy.containsValue(NOT_PRESENT));\n+    }\n+\n+    @Test\n+    void forEach() {\n+        var lazy = newMap();\n+        Set<Map.Entry<Integer, Integer>> expected = KEYS.stream()\n+                .map(i -> new AbstractMap.SimpleImmutableEntry<>(i , i))\n+                .collect(Collectors.toSet());\n+        Set<Map.Entry<Integer, Integer>> actual = new HashSet<>();\n+        lazy.forEach((k, v) -> actual.add(new AbstractMap.SimpleImmutableEntry<>(k , v)));\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void toStringTest() {\n+        assertEquals(\"{}\", newEmptyMap().toString());\n+        var map = StableValue.map(Set.of(KEY), IDENTITY);\n+        assertEquals(\"{\" + KEY + \"=.unset}\", map.toString());\n+        map.get(KEY);\n+        assertEquals(\"{\" + KEY + \"=\" + KEY + \"}\", map.toString());\n+        String actual = newMap().toString();\n+        assertTrue(actual.startsWith(\"{\"));\n+        for (int key:KEYS) {\n+            assertTrue(actual.contains(key + \"=.unset\"));\n+        }\n+        assertTrue(actual.endsWith(\"}\"));\n+    }\n+\n+    @Test\n+    void hashCodeTest() {\n+        assertEquals(Map.of().hashCode(), newEmptyMap().hashCode());\n+        assertEquals(newRegularMap().hashCode(), newMap().hashCode());\n+    }\n+\n+    @Test\n+    void equalsTest() {\n+        assertTrue(newEmptyMap().equals(Map.of()));\n+        assertTrue(Map.of().equals(newEmptyMap()));\n+        assertTrue(newMap().equals(newRegularMap()));\n+        assertTrue(newRegularMap().equals(newMap()));\n+        assertFalse(newMap().equals(\"A\"));\n+    }\n+\n+    @Test\n+    void entrySet() {\n+        var regular = newRegularMap().entrySet();\n+        var actual = newMap().entrySet();\n+        assertTrue(regular.equals(actual));\n+        assertTrue(actual.equals(regular));\n+        assertTrue(regular.equals(actual));\n+    }\n+\n+    @Test\n+    void entrySetToString() {\n+        var map = newMap();\n+        var entrySet = map.entrySet();\n+        var toString = entrySet.toString();\n+        for (var key : KEYS) {\n+            assertTrue(toString.contains(key + \"=.unset\"));\n+        }\n+        assertTrue(toString.startsWith(\"[\"));\n+        assertTrue(toString.endsWith(\"]\"));\n+\n+        map.get(KEY);\n+        for (var key : KEYS) {\n+            if (key.equals(KEY)) {\n+                continue;\n+            }\n+            assertTrue(entrySet.toString().contains(key + \"=.unset\"));\n+        }\n+        assertTrue(entrySet.toString().contains(KEY + \"=\" + KEY));\n+    }\n+\n+    @Test\n+    void values() {\n+        var map = newMap();\n+        var values = map.values();\n+        \/\/ Look at one of the elements\n+        var val = values.stream().iterator().next();\n+        var toString = map.toString();\n+        for (var key : KEYS) {\n+            if (key.equals(val)) {\n+                assertTrue(toString.contains(key + \"=\" + key));\n+            } else {\n+                assertTrue(toString.contains(key + \"=.unset\"));\n+            }\n+        }\n+\n+        \/\/ Mod ops\n+        assertThrows(UnsupportedOperationException.class, () -> values.remove(KEY));\n+        assertThrows(UnsupportedOperationException.class, () -> values.add(KEY));\n+        assertThrows(UnsupportedOperationException.class, values::clear);\n+        assertThrows(UnsupportedOperationException.class, () -> values.addAll(Set.of(1)));\n+        assertThrows(UnsupportedOperationException.class, () -> values.removeIf(i -> true));\n+        assertThrows(UnsupportedOperationException.class, () -> values.retainAll(Set.of(KEY)));\n+    }\n+\n+    @Test\n+    void valuesToString() {\n+        var map = newMap();\n+        var values = map.values();\n+        assertEquals(\"[.unset, .unset, .unset]\", values.toString());\n+        map.get(KEY);\n+        var afterGet = values.toString();\n+        assertTrue(afterGet.contains(Integer.toString(KEY)), afterGet);\n+    }\n+\n+    @Test\n+    void iteratorNext() {\n+        Set<Integer> encountered = new HashSet<>();\n+        var iterator = newMap().entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            var entry = iterator.next();\n+            assertEquals(entry.getKey(), entry.getValue());\n+            encountered.add(entry.getValue());\n+        }\n+        assertEquals(KEYS, encountered);\n+    }\n+\n+    @Test\n+    void iteratorForEachRemaining() {\n+        Set<Integer> encountered = new HashSet<>();\n+        var iterator = newMap().entrySet().iterator();\n+        var entry = iterator.next();\n+        assertEquals(entry.getKey(), entry.getValue());\n+        encountered.add(entry.getValue());\n+        iterator.forEachRemaining(e -> {\n+            assertEquals(e.getKey(), e.getValue());\n+            encountered.add(e.getValue());\n+        });\n+        assertEquals(KEYS, encountered);\n+    }\n+\n+    \/\/ Immutability\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void unsupported(Operation operation) {\n+        assertThrowsForOperation(UnsupportedOperationException.class, operation);\n+    }\n+\n+    \/\/ Method parameter invariant checking\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullAverseOperations\")\n+    void nullAverse(Operation operation) {\n+        assertThrowsForOperation(NullPointerException.class, operation);\n+    }\n+\n+    static <T extends Throwable> void assertThrowsForOperation(Class<T> expectedType, Operation operation) {\n+        var lazy = newMap();\n+        assertThrows(expectedType, () -> operation.accept(lazy));\n+    }\n+\n+    \/\/ Implementing interfaces\n+\n+    @Test\n+    void serializable() {\n+        serializable(newMap());\n+        serializable(newEmptyMap());\n+    }\n+\n+    void serializable(Map<Integer, Integer> map) {\n+        assertFalse(map instanceof Serializable);\n+        assertFalse(map.entrySet() instanceof Serializable);\n+        assertFalse(map.keySet() instanceof Serializable);\n+        assertFalse(map.values() instanceof Serializable);\n+    }\n+\n+    @Test\n+    void distinct() {\n+        Map<Integer, StableValueImpl<Integer>> map = StableUtil.map(Set.of(1, 2, 3));\n+        assertEquals(3, map.size());\n+        \/\/ Check, every StableValue is distinct\n+        Map<StableValue<Integer>, Boolean> idMap = new IdentityHashMap<>();\n+        map.forEach((k, v) -> idMap.put(v, true));\n+        assertEquals(3, idMap.size());\n+    }\n+\n+    @Test\n+    void nullResult() {\n+        var map = StableValue.map(Set.of(0), _ -> null);\n+        assertNull(map.getOrDefault(0, 1));;\n+        assertTrue(map.containsKey(0));\n+        assertNull(map.get(0));\n+    }\n+\n+    @Test\n+    void nullKeys() {\n+        Set<Integer> inputs = new HashSet<>();\n+        inputs.add(0);\n+        inputs.add(null);\n+        assertThrows(NullPointerException.class, () -> StableValue.map(inputs, IDENTITY));\n+    }\n+\n+    \/\/ Support constructs\n+\n+    record Operation(String name,\n+                     Consumer<Map<Integer, Integer>> consumer) implements Consumer<Map<Integer, Integer>> {\n+        @java.lang.Override\n+        public void   accept(Map<Integer, Integer> map) { consumer.accept(map); }\n+        @java.lang.Override\n+        public String toString() { return name; }\n+    }\n+\n+    static Stream<Operation> nullAverseOperations() {\n+        return Stream.of(\n+                new Operation(\"forEach\",     m -> m.forEach(null))\n+        );\n+    }\n+\n+    static Stream<Operation> unsupportedOperations() {\n+        return Stream.of(\n+                new Operation(\"clear\",             Map::clear),\n+                new Operation(\"compute\",           m -> m.compute(KEY, (_, _) -> 1)),\n+                new Operation(\"computeIfAbsent\",   m -> m.computeIfAbsent(KEY, _ -> 1)),\n+                new Operation(\"computeIfPresent\",  m -> m.computeIfPresent(KEY, (_, _) -> 1)),\n+                new Operation(\"merge\",             m -> m.merge(KEY, KEY, (a, _) -> a)),\n+                new Operation(\"put\",               m -> m.put(0, 0)),\n+                new Operation(\"putAll\",            m -> m.putAll(Map.of())),\n+                new Operation(\"remove1\",           m -> m.remove(KEY)),\n+                new Operation(\"remove2\",           m -> m.remove(KEY, KEY)),\n+                new Operation(\"replace2\",          m -> m.replace(KEY, 1)),\n+                new Operation(\"replace3\",          m -> m.replace(KEY, KEY, 1)),\n+                new Operation(\"replaceAll\",        m -> m.replaceAll((a, _) -> a))\n+        );\n+    }\n+\n+    static Map<Integer, Integer> newMap() {\n+        return StableValue.map(KEYS, IDENTITY);\n+    }\n+\n+    static Map<Integer, Integer> newEmptyMap() {\n+        return StableValue.map(EMPTY, IDENTITY);\n+    }\n+\n+    static Map<Integer, Integer> newRegularMap() {\n+        return KEYS.stream().collect(Collectors.toMap(IDENTITY, IDENTITY));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableMapTest.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableSupplierTest methods\n+ * @enablePreview\n+ * @run junit StableSupplierTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableSupplierTest {\n+\n+    private static final Supplier<Integer> SUPPLIER = () -> 42;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> StableValue.supplier(null));\n+    }\n+\n+    @Test\n+    void basic() {\n+        basic(SUPPLIER);\n+        basic(() -> null);\n+    }\n+\n+    void basic(Supplier<Integer> supplier) {\n+        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(supplier);\n+        var cached = StableValue.supplier(cs);\n+        assertEquals(\".unset\", cached.toString());\n+        assertEquals(supplier.get(), cached.get());\n+        assertEquals(1, cs.cnt());\n+        assertEquals(supplier.get(), cached.get());\n+        assertEquals(1, cs.cnt());\n+        assertEquals(Objects.toString(supplier.get()), cached.toString());\n+    }\n+\n+    @Test\n+    void exception() {\n+        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(() -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var cached = StableValue.supplier(cs);\n+        assertThrows(UnsupportedOperationException.class, cached::get);\n+        assertEquals(1, cs.cnt());\n+        assertThrows(UnsupportedOperationException.class, cached::get);\n+        assertEquals(2, cs.cnt());\n+        assertEquals(\".unset\", cached.toString());\n+    }\n+\n+    @Test\n+    void circular() {\n+        final AtomicReference<Supplier<?>> ref = new AtomicReference<>();\n+        Supplier<Supplier<?>> cached = StableValue.supplier(ref::get);\n+        ref.set(cached);\n+        cached.get();\n+        String toString = cached.toString();\n+        assertTrue(toString.startsWith(\"(this StableSupplier)\"));\n+        assertDoesNotThrow(cached::hashCode);\n+    }\n+\n+    @Test\n+    void equality() {\n+        Supplier<Integer> f0 = StableValue.supplier(SUPPLIER);\n+        Supplier<Integer> f1 = StableValue.supplier(SUPPLIER);\n+        \/\/ No function is equal to another function\n+        assertNotEquals(f0, f1);\n+    }\n+\n+    @Test\n+    void hashCodeStable() {\n+        Supplier<Integer> f0 = StableValue.supplier(SUPPLIER);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        f0.get();\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableSupplierTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+final class StableTestUtil {\n+\n+    private StableTestUtil() {}\n+\n+    public static final class CountingSupplier<T>\n+            extends AbstractCounting<Supplier<T>>\n+            implements Supplier<T> {\n+\n+        public CountingSupplier(Supplier<T> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public T get() {\n+            incrementCounter();\n+            return delegate.get();\n+        }\n+\n+    }\n+\n+    public static final class CountingIntFunction<R>\n+            extends AbstractCounting<IntFunction<R>>\n+            implements IntFunction<R> {\n+\n+        public CountingIntFunction(IntFunction<R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(int value) {\n+            incrementCounter();\n+            return delegate.apply(value);\n+        }\n+\n+    }\n+\n+    public static final class CountingFunction<T, R>\n+            extends AbstractCounting<Function<T, R>>\n+            implements Function<T, R> {\n+\n+        public CountingFunction(Function<T, R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(T t) {\n+            incrementCounter();\n+            return delegate.apply(t);\n+        }\n+\n+    }\n+\n+    public static final class CountingBiFunction<T, U, R>\n+            extends AbstractCounting<BiFunction<T, U, R>>\n+            implements BiFunction<T, U, R> {\n+\n+        public CountingBiFunction(BiFunction<T, U, R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(T t, U u) {\n+            incrementCounter();\n+            return delegate.apply(t, u);\n+        }\n+    }\n+\n+    abstract static class AbstractCounting<D> {\n+\n+        private final AtomicInteger cnt = new AtomicInteger();\n+        protected final D delegate;\n+\n+        protected AbstractCounting(D delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        protected final void incrementCounter() {\n+            cnt.incrementAndGet();\n+        }\n+\n+        public final int cnt() {\n+            return cnt.get();\n+        }\n+\n+        @Override\n+        public final String toString() {\n+            return cnt.toString();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableTestUtil.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableValueFactoriesTest implementations\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @enablePreview\n+ * @run junit StableValueFactoriesTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableUtil;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableValueFactoriesTest {\n+\n+    @Test\n+    void array() {\n+        assertThrows(IllegalArgumentException.class, () -> StableUtil.array(-1));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueFactoriesTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,339 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableValue implementations\n+ * @enablePreview\n+ * @run junit StableValueTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.IntStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+final class StableValueTest {\n+\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 13;\n+\n+    @Test\n+    void trySet() {\n+        trySet(VALUE);\n+        trySet(null);\n+    }\n+\n+    @Test\n+    void preSet() {\n+        StableValue<Integer> stable = StableValue.of(VALUE);\n+        assertTrue(stable.isSet());\n+        assertEquals(VALUE, stable.orElseThrow());\n+        assertEquals(VALUE, stable.orElse(VALUE2));\n+        assertEquals(VALUE, stable.orElseSet(() -> VALUE2));\n+        assertFalse(stable.trySet(VALUE2));\n+        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(VALUE2));\n+        assertEquals(\n+                \"The content is already set\",\n+                e.getMessage());\n+    }\n+\n+    void trySet(Integer initial) {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertTrue(stable.trySet(initial));\n+        assertFalse(stable.trySet(null));\n+        assertFalse(stable.trySet(VALUE));\n+        assertFalse(stable.trySet(VALUE2));\n+        assertEquals(initial, stable.orElseThrow());\n+    }\n+\n+    @Test\n+    void setOrThrowValue() {\n+        StableValue<Integer> stable = StableValue.of();\n+        stable.setOrThrow(VALUE);\n+        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(VALUE2));\n+        assertEquals(\"The content is already set\", e.getMessage());\n+    }\n+\n+    @Test\n+    void setOrThrowNull() {\n+        StableValue<Integer> stable = StableValue.of();\n+        stable.setOrThrow(null);\n+        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(null));\n+        assertEquals(\"The content is already set\", e.getMessage());\n+    }\n+\n+    @Test\n+    void orElse() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertEquals(VALUE, stable.orElse(VALUE));\n+        assertNull(stable.orElse(null));\n+        stable.trySet(VALUE);\n+        assertEquals(VALUE, stable.orElse(VALUE2));\n+    }\n+\n+    @Test\n+    void orElseThrow() {\n+        StableValue<Integer> stable = StableValue.of();\n+        var e = assertThrows(NoSuchElementException.class, stable::orElseThrow);\n+        assertEquals(\"No content set\", e.getMessage());\n+        stable.trySet(VALUE);\n+        assertEquals(VALUE, stable.orElseThrow());\n+    }\n+\n+    @Test\n+    void isSet() {\n+        isSet(VALUE);\n+        isSet(null);\n+   }\n+\n+    void isSet(Integer initial) {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertFalse(stable.isSet());\n+        stable.trySet(initial);\n+        assertTrue(stable.isSet());\n+    }\n+\n+   @Test\n+   void testOrElseSetSupplier() {\n+       StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(() -> VALUE);\n+       StableValue<Integer> stable = StableValue.of();\n+       assertThrows(NullPointerException.class, () -> stable.orElseSet(null));\n+       assertEquals(VALUE, stable.orElseSet(cs));\n+       assertEquals(1, cs.cnt());\n+       assertEquals(VALUE, stable.orElseSet(cs));\n+       assertEquals(1, cs.cnt());\n+   }\n+\n+    @Test\n+    void testHashCode() {\n+        StableValue<Integer> stableValue = StableValue.of();\n+        \/\/ Should be Object::hashCode\n+        assertEquals(System.identityHashCode(stableValue), stableValue.hashCode());\n+    }\n+\n+    @Test\n+    void testEquals() {\n+        StableValue<Integer> s0 = StableValue.of();\n+        assertNotEquals(null, s0);\n+        StableValue<Integer> s1 = StableValue.of();\n+        assertNotEquals(s0, s1); \/\/ Identity based\n+        s0.setOrThrow(42);\n+        s1.setOrThrow(42);\n+        assertNotEquals(s0, s1);\n+        assertNotEquals(\"a\", s0);\n+        StableValue<Integer> null0 = StableValue.of();\n+        StableValue<Integer> null1 = StableValue.of();\n+        null0.setOrThrow(null);\n+        null1.setOrThrow(null);\n+        assertNotEquals(null0, null1);\n+    }\n+\n+    @Test\n+    void toStringUnset() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertEquals(\".unset\", stable.toString());\n+    }\n+\n+    @Test\n+    void toStringNull() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertTrue(stable.trySet(null));\n+        assertEquals(\"null\", stable.toString());\n+    }\n+\n+    @Test\n+    void toStringNonNull() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertTrue(stable.trySet(VALUE));\n+        assertEquals(Objects.toString(VALUE), stable.toString());\n+    }\n+\n+    @Test\n+    void toStringCircular() {\n+        StableValue<StableValue<?>> stable = StableValue.of();\n+        stable.trySet(stable);\n+        String toString = assertDoesNotThrow(stable::toString);\n+        assertEquals(\"(this StableValue)\", toString);\n+        assertDoesNotThrow(stable::hashCode);\n+        assertDoesNotThrow((() -> stable.equals(stable)));\n+    }\n+\n+    @Test\n+    void recursiveCall() {\n+        StableValue<Integer> stable = StableValue.of();\n+        AtomicReference<StableValue<Integer>> ref = new AtomicReference<>(stable);\n+        assertThrows(IllegalStateException.class, () ->\n+                stable.orElseSet(() -> {\n+                    ref.get().trySet(1);\n+                    return 1;\n+                })\n+        );\n+        assertThrows(IllegalStateException.class, () ->\n+                stable.orElseSet(() -> {\n+                    ref.get().orElseSet(() -> 1);\n+                    return 1;\n+                })\n+        );\n+    }\n+\n+    @Test\n+    void intFunctionExample() {\n+        final class SqrtUtil {\n+\n+            private SqrtUtil() {}\n+\n+            private static final int CACHED_SIZE = 10;\n+\n+            private static final IntFunction<Double> SQRT =\n+                    \/\/ @link substring=\"intFunction\" target=\"#intFunction(int,IntFunction)\" :\n+                    StableValue.intFunction(CACHED_SIZE, StrictMath::sqrt);\n+\n+            public static double sqrt(int a) {\n+                if (a < CACHED_SIZE) {\n+                    return SQRT.apply(a);\n+                } else {\n+                    return StrictMath.sqrt(a);\n+                }\n+            }\n+        }\n+\n+\n+        double sqrt9 = SqrtUtil.sqrt(9);   \/\/ May eventually constant fold to 3.0 at runtime\n+        double sqrt81 = SqrtUtil.sqrt(81); \/\/ Will not constant fold\n+\n+        assertEquals(3, sqrt9);\n+        assertEquals(9, sqrt81);\n+    }\n+\n+    @Test\n+    void functionExample() {\n+\n+        class Log2Util {\n+\n+            private Log2Util() {}\n+\n+            private static final Set<Integer> CACHED_KEYS =\n+                    Set.of(1, 2, 4, 8, 16, 32);\n+            private static final UnaryOperator<Integer> LOG2_ORIGINAL =\n+                    i -> 31 - Integer.numberOfLeadingZeros(i);\n+\n+            private static final Function<Integer, Integer> LOG2_CACHED =\n+                    \/\/ @link substring=\"function\" target=\"#function(Set,Function)\" :\n+                    StableValue.function(CACHED_KEYS, LOG2_ORIGINAL);\n+\n+            public static double log2(int a) {\n+                if (CACHED_KEYS.contains(a)) {\n+                    return LOG2_CACHED.apply(a);\n+                } else {\n+                    return LOG2_ORIGINAL.apply(a);\n+                }\n+            }\n+\n+        }\n+\n+        double log16 = Log2Util.log2(16); \/\/ May eventually constant fold to 4.0 at runtime\n+        double log256 = Log2Util.log2(256); \/\/ Will not constant fold\n+\n+        assertEquals(4, log16);\n+        assertEquals(8, log256);\n+    }\n+\n+    private static final BiPredicate<StableValue<Integer>, Integer> TRY_SET = StableValue::trySet;\n+    private static final BiPredicate<StableValue<Integer>, Integer> SET_OR_THROW = (s, i) -> {\n+        try {\n+            s.setOrThrow(i);\n+            return true;\n+        } catch (IllegalStateException e) {\n+            return false;\n+        }\n+    };\n+\n+    @Test\n+    void raceTrySet() {\n+        race(TRY_SET);\n+    }\n+\n+    @Test\n+    void raceSetOrThrow() {\n+        race(SET_OR_THROW);\n+    }\n+\n+    @Test\n+    void raceMixed() {\n+        race((s, i) -> switch (i % 2) {\n+            case 0 -> TRY_SET.test(s, i);\n+            case 1 -> SET_OR_THROW.test(s, i);\n+            default -> fail(\"should not reach here\");\n+        });\n+    }\n+\n+    void race(BiPredicate<StableValue<Integer>, Integer> winnerPredicate) {\n+        int noThreads = 10;\n+        CountDownLatch starter = new CountDownLatch(1);\n+        StableValue<Integer> stable = StableValue.of();\n+        Map<Integer, Boolean> winners = new ConcurrentHashMap<>();\n+        List<Thread> threads = IntStream.range(0, noThreads).mapToObj(i -> new Thread(() -> {\n+                    try {\n+                        \/\/ Ready, set ...\n+                        starter.await();\n+                        \/\/ Here we go!\n+                        winners.put(i, winnerPredicate.test(stable, i));\n+                    } catch (Throwable t) {\n+                        fail(t);\n+                    }\n+                }))\n+                .toList();\n+        threads.forEach(Thread::start);\n+        LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n+        \/\/ Start the race\n+        starter.countDown();\n+        threads.forEach(StableValueTest::join);\n+        \/\/ There can only be one winner\n+        assertEquals(1, winners.values().stream().filter(b -> b).count());\n+    }\n+\n+    private static void join(Thread thread) {\n+        try {\n+            thread.join();\n+        } catch (InterruptedException e) {\n+            fail(e);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":339,"deletions":0,"binary":false,"changes":339,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for making sure StableValue publishes values safely\n+ * @modules java.base\/jdk.internal.misc\n+ * @enablePreview\n+ * @run junit StableValuesSafePublicationTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableValuesSafePublicationTest {\n+\n+    private static final int SIZE = 100_000;\n+    private static final int THREADS = Runtime.getRuntime().availableProcessors();\n+    private static final StableValue<Holder>[] STABLES = stables();\n+\n+    static StableValue<Holder>[] stables() {\n+        @SuppressWarnings(\"unchecked\")\n+        StableValue<Holder>[] stables = (StableValue<Holder>[]) new StableValue[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            stables[i] = StableValue.of();\n+        }\n+        return stables;\n+    }\n+\n+    static final class Holder {\n+        \/\/ These are non-final fields but should be seen\n+        \/\/ fully initialized thanks to the HB properties of StableValue.\n+        int a, b, c, d, e;\n+\n+        Holder() {\n+            a = b = c = d = e = 1;\n+        }\n+    }\n+\n+    static final class Consumer implements Runnable {\n+\n+        final int[] observations = new int[SIZE];\n+        final StableValue<Holder>[] stables = STABLES;\n+        int i = 0;\n+\n+        @Override\n+        public void run() {\n+            for (; i < SIZE; i++) {\n+                StableValue<Holder> s = stables[i];\n+                Holder h;\n+                \/\/ Wait until the StableValue has a holder value\n+                while ((h = s.orElse(null)) == null) {}\n+                int a = h.a;\n+                int b = h.b;\n+                int c = h.c;\n+                int d = h.d;\n+                int e = h.e;\n+                observations[i] = a + (b << 1) + (c << 2) + (c << 3) + (d << 4) + (e << 5);\n+            }\n+        }\n+    }\n+\n+    static final class Producer implements Runnable {\n+\n+        final StableValue<Holder>[] stables = STABLES;\n+\n+        @Override\n+        public void run() {\n+            StableValue<Holder> s;\n+            long deadlineNs = System.nanoTime();\n+            for (int i = 0; i < SIZE; i++) {\n+                s = stables[i];\n+                s.trySet(new Holder());\n+                deadlineNs += 1000;\n+                while (System.nanoTime() < deadlineNs) {\n+                    Thread.onSpinWait();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void main() {\n+        List<Consumer> consumers = IntStream.range(0, THREADS)\n+                .mapToObj(_ -> new Consumer())\n+                .toList();\n+\n+        List<Thread> consumersThreads = IntStream.range(0, THREADS)\n+                .mapToObj(i -> Thread.ofPlatform()\n+                        .name(\"Consumer Thread \" + i)\n+                        .start(consumers.get(i)))\n+                .toList();\n+\n+        Producer producer = new Producer();\n+\n+        Thread producerThread = Thread.ofPlatform()\n+                .name(\"Producer Thread\")\n+                .start(producer);\n+\n+        join(consumers, producerThread);\n+        join(consumers, consumersThreads.toArray(Thread[]::new));\n+\n+        int[] histogram = new int[64];\n+        for (Consumer consumer : consumers) {\n+            for (int i = 0; i < SIZE; i++) {\n+                histogram[consumer.observations[i]]++;\n+            }\n+        }\n+\n+        \/\/ unless a = 1, ..., e = 1, zero observations should be seen\n+        for (int i = 0; i < 63; i++) {\n+            assertEquals(0, histogram[i]);\n+        }\n+        \/\/ a = 1, ..., e = 1 : index 2^5-1 = 63\n+        \/\/ All observations should end up in this bucket\n+        assertEquals(THREADS * SIZE, histogram[63]);\n+    }\n+\n+    static void join(List<Consumer> consumers, Thread... threads) {\n+        try {\n+            for (Thread t:threads) {\n+                long deadline = System.nanoTime() + TimeUnit.MINUTES.toNanos(1);\n+                while (t.isAlive()) {\n+                    t.join(TimeUnit.SECONDS.toMillis(10));\n+                    if (t.isAlive()) {\n+                        String stack = Arrays.stream(t.getStackTrace())\n+                                .map(Objects::toString)\n+                                .collect(Collectors.joining(System.lineSeparator()));\n+                        System.err.println(t + \": \" + stack);\n+                        for (int i = 0; i < consumers.size(); i++) {\n+                            System.err.println(\"Consumer \" + i + \": \" + consumers.get(i).i);\n+                        }\n+                    }\n+                    if (System.nanoTime() > deadline) {\n+                        long nonNulls = CompletableFuture.supplyAsync(() ->\n+                                Stream.of(STABLES)\n+                                        .map(s -> s.orElse(null))\n+                                        .filter(Objects::nonNull)\n+                                        .count(), Executors.newSingleThreadExecutor()).join();\n+                        fail(\"Giving up! Set stables seen by a new thread: \" + nonNulls);\n+                    }\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            fail(ie);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValuesSafePublicationTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for TrustedFieldType implementations\n+ * @modules jdk.unsupported\/sun.misc\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @modules java.base\/jdk.internal.misc\n+ * @enablePreview\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED -Dopens=true TrustedFieldTypeTest\n+ * @run junit\/othervm -Dopens=false TrustedFieldTypeTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableValueImpl;\n+import jdk.internal.misc.Unsafe;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InaccessibleObjectException;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TrustedFieldTypeTest {\n+\n+    @Test\n+    void varHandle() throws NoSuchFieldException, IllegalAccessException {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+        StableValue<Integer> originalValue = StableValue.of();\n+        @SuppressWarnings(\"unchecked\")\n+        StableValue<Integer>[] originalArrayValue = new StableValue[10];\n+\n+        final class Holder {\n+            private final StableValue<Integer> value = originalValue;\n+        }\n+        final class ArrayHolder {\n+            private final StableValue<Integer>[] array = originalArrayValue;\n+        }\n+\n+\n+        VarHandle valueVarHandle = lookup.findVarHandle(Holder.class, \"value\", StableValue.class);\n+        Holder holder = new Holder();\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                valueVarHandle.set(holder, StableValue.of())\n+        );\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                valueVarHandle.compareAndSet(holder, originalValue, StableValue.of())\n+        );\n+\n+        VarHandle arrayVarHandle = lookup.findVarHandle(ArrayHolder.class, \"array\", StableValue[].class);\n+        ArrayHolder arrayHolder = new ArrayHolder();\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arrayVarHandle.set(arrayHolder, new StableValue[1])\n+        );\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arrayVarHandle.compareAndSet(arrayHolder, originalArrayValue, new StableValue[1])\n+        );\n+\n+    }\n+\n+    @Test\n+    void updateStableValueContentVia_j_i_m_Unsafe() {\n+        StableValue<Integer> stableValue = StableValue.of();\n+        stableValue.trySet(42);\n+        jdk.internal.misc.Unsafe unsafe = Unsafe.getUnsafe();\n+\n+        long offset = unsafe.objectFieldOffset(stableValue.getClass(), \"content\");\n+        assertTrue(offset > 0);\n+\n+        \/\/ Unfortunately, it is possible to update the underlying data via jdk.internal.misc.Unsafe\n+        Object oldData = unsafe.getAndSetReference(stableValue, offset, 13);\n+        assertEquals(42, oldData);\n+        assertEquals(13, stableValue.orElseThrow());\n+    }\n+\n+    @Test\n+    void updateStableValueContentViaSetAccessible() throws NoSuchFieldException, IllegalAccessException {\n+\n+        if (Boolean.getBoolean(\"opens\")) {\n+            \/\/ Unfortunately, add-opens allows direct access to the `value` field\n+            Field field = StableValueImpl.class.getDeclaredField(\"content\");\n+            field.setAccessible(true);\n+\n+            StableValue<Integer> stableValue = StableValue.of();\n+            stableValue.trySet(42);\n+\n+            Object oldData = field.get(stableValue);\n+            assertEquals(42, oldData);\n+\n+            field.set(stableValue, 13);\n+            assertEquals(13, stableValue.orElseThrow());\n+        } else {\n+            Field field = StableValueImpl.class.getDeclaredField(\"content\");\n+            assertThrows(InaccessibleObjectException.class, ()-> field.setAccessible(true));\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/TrustedFieldTypeTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+ * @enablePreview\n@@ -220,0 +221,2 @@\n+        testEmptyList(StableValue.list(0, i -> i));\n+        testEmptyList(StableValue.list(3, i -> i).subList(0, 0));\n@@ -222,0 +225,1 @@\n+        testListMutatorsAlwaysThrow(StableValue.list(0, i -> i));\n@@ -224,0 +228,2 @@\n+        testEmptyListMutatorsAlwaysThrow(StableValue.list(0, i -> i));\n+        testEmptyListMutatorsAlwaysThrow(StableValue.list(3, i -> i).subList(0, 0));\n@@ -245,1 +251,4 @@\n-                Stream.of(1, null, 3, 4).toList())) {\n+                Stream.of(1, null, 3, 4).toList(),\n+                StableValue.list(0, i -> i),\n+                StableValue.list(3, i -> i),\n+                StableValue.list(10, i -> i))) {\n@@ -357,0 +366,3 @@\n+        testEmptyMap(StableValue.map(Set.of(), k -> k));\n+        testMapMutatorsAlwaysThrow(StableValue.map(Set.of(), k -> k));\n+        testEmptyMapMutatorsAlwaysThrow(StableValue.map(Set.of(), k -> k));\n@@ -369,1 +381,4 @@\n-                Map.ofEntries(ea))) {\n+                Map.ofEntries(ea),\n+                StableValue.map(Set.<Integer>of(), k -> k),\n+                StableValue.map(Set.of(1), k -> k),\n+                StableValue.map(Set.of(1, 2, 3), k -> k))) {\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(100)\n+public class StableFunctionBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final Set<Integer> SET = IntStream.range(0, SIZE).boxed().collect(Collectors.toSet());\n+\n+    private static final Map<Integer, Integer> MAP = StableValue.map(SET, Function.identity());\n+    private static final Function<Integer, Integer> FUNCTION = StableValue.function(SET, Function.identity());\n+\n+    private final Map<Integer, Integer> map = StableValue.map(SET, Function.identity());\n+    private final Function<Integer, Integer> function = StableValue.function(SET, Function.identity());\n+\n+    @Benchmark\n+    public int map() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += map.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int function() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += function.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticSMap() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += MAP.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += FUNCTION.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableFunctionBenchmark.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableFunctionSingleBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final Set<Integer> SET = IntStream.range(0, SIZE).boxed().collect(Collectors.toSet());\n+\n+    private static final Map<Integer, Integer> MAP = StableValue.map(SET, Function.identity());\n+    private static final Function<Integer, Integer> FUNCTION = StableValue.function(SET, Function.identity());\n+\n+    private final Map<Integer, Integer> map = StableValue.map(SET, Function.identity());\n+    private final Function<Integer, Integer> function = StableValue.function(SET, Function.identity());\n+\n+    @Benchmark\n+    public int map() {\n+        return map.get(1);\n+    }\n+\n+    @Benchmark\n+    public int function() {\n+        return function.apply(1);\n+    }\n+\n+    @Benchmark\n+    public int staticSMap() {\n+        return MAP.get(1);\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        return FUNCTION.apply(1);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableFunctionSingleBenchmark.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(100)\n+public class StableIntFunctionBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    private static final List<Integer> LIST = StableValue.list(SIZE, IDENTITY);\n+    private static final IntFunction<Integer> INT_FUNCTION = StableValue.intFunction(SIZE, IDENTITY);\n+\n+    private final List<Integer> list = StableValue.list(SIZE, IDENTITY);\n+    private final IntFunction<Integer> intFunction = StableValue.intFunction(SIZE, IDENTITY);\n+\n+    @Benchmark\n+    public int list() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += list.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int intFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += intFunction.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticList() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += LIST.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += INT_FUNCTION.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableIntFunctionBenchmark.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableIntFunctionSingleBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    private static final List<Integer> STABLE = StableValue.list(SIZE, IDENTITY);\n+    private static final IntFunction<Integer> INT_FUNCTION = StableValue.intFunction(SIZE, IDENTITY);\n+\n+    private final List<Integer> stable = StableValue.list(SIZE, IDENTITY);\n+    private final IntFunction<Integer> intFunction = StableValue.intFunction(SIZE, IDENTITY);\n+\n+    @Benchmark\n+    public int list() {\n+        return stable.get(1);\n+    }\n+\n+    @Benchmark\n+    public int intFunction() {\n+        return intFunction.apply(1);\n+    }\n+\n+    @Benchmark\n+    public int staticList() {\n+        return STABLE.get(1);\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        return INT_FUNCTION.apply(1);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableIntFunctionSingleBenchmark.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.bench.java.lang.stable.StableValueBenchmark.Dcl;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableMethodHandleBenchmark {\n+\n+    private static final MethodHandle FINAL_MH = identityHandle();\n+    private static final StableValue<MethodHandle> STABLE_MH;\n+    private static MethodHandle mh = identityHandle();\n+    private static final Dcl<MethodHandle> DCL = new Dcl<>(StableMethodHandleBenchmark::identityHandle);\n+    private static final AtomicReference<MethodHandle> ATOMIC_REFERENCE = new AtomicReference<>(identityHandle());\n+    private static final Map<String, MethodHandle> MAP = new ConcurrentHashMap<>();\n+    private static final Map<String, MethodHandle> STABLE_MAP = StableValue.map(Set.of(\"identityHandle\"), _ -> identityHandle());\n+\n+    static {\n+        STABLE_MH = StableValue.of();\n+        STABLE_MH.setOrThrow(identityHandle());\n+        MAP.put(\"identityHandle\", identityHandle());\n+    }\n+\n+    @Benchmark\n+    public int atomic() throws Throwable {\n+        return (int) ATOMIC_REFERENCE.get().invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int dcl() throws Throwable {\n+        return (int) DCL.get().invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int finalMh() throws Throwable {\n+        return (int) FINAL_MH.invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int map() throws Throwable {\n+        return (int) MAP.get(\"identityHandle\").invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int nonFinalMh() throws Throwable {\n+        return (int) mh.invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int stableMap() throws Throwable {\n+        return (int) STABLE_MAP.get(\"identityHandle\").invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int stableMh() throws Throwable {\n+        return (int) STABLE_MH.orElseThrow().invokeExact(1);\n+    }\n+\n+    Object cp() {\n+        CodeBuilder cob = null;\n+        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n+        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA), List.of()),\n+                cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle)));\n+        return null;\n+    }\n+\n+    static MethodHandle identityHandle() {\n+        var lookup = MethodHandles.lookup();\n+        try {\n+            return lookup.findStatic(StableMethodHandleBenchmark.class, \"identity\", MethodType.methodType(int.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static int identity(int value) {\n+        return value;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableMethodHandleBenchmark.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(2)\n+public class StableSupplierBenchmark {\n+\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 23;\n+\n+    private static final StableValue<Integer> STABLE = init(StableValue.of(), VALUE);\n+    private static final StableValue<Integer> STABLE2 = init(StableValue.of(), VALUE2);\n+    private static final Supplier<Integer> SUPPLIER = StableValue.supplier(() -> VALUE);\n+    private static final Supplier<Integer> SUPPLIER2 = StableValue.supplier(() -> VALUE);\n+\n+    private final StableValue<Integer> stable = init(StableValue.of(), VALUE);\n+    private final StableValue<Integer> stable2 = init(StableValue.of(), VALUE2);\n+    private final Supplier<Integer> supplier = StableValue.supplier(() -> VALUE);\n+    private final Supplier<Integer> supplier2 = StableValue.supplier(() -> VALUE2);\n+\n+    @Benchmark\n+    public int stable() {\n+        return stable.orElseThrow() + stable2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int supplier() {\n+        return supplier.get() + supplier2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticStable() {\n+        return STABLE.orElseThrow() + STABLE2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int staticSupplier() {\n+        return SUPPLIER.get() + SUPPLIER2.get();\n+    }\n+\n+    private static StableValue<Integer> init(StableValue<Integer> m, Integer value) {\n+        m.trySet(value);\n+        return m;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableSupplierBenchmark.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(2)\n+public class StableValueBenchmark {\n+\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 23;\n+\n+    private static final StableValue<Integer> STABLE = init(StableValue.of(), VALUE);\n+    private static final StableValue<Integer> STABLE2 = init(StableValue.of(), VALUE2);\n+    private static final StableValue<Integer> DCL = init(StableValue.of(), VALUE);\n+    private static final StableValue<Integer> DCL2 = init(StableValue.of(), VALUE2);\n+    private static final AtomicReference<Integer> ATOMIC = new AtomicReference<>(VALUE);\n+    private static final AtomicReference<Integer> ATOMIC2 = new AtomicReference<>(VALUE2);\n+    private static final Holder HOLDER = new Holder(VALUE);\n+    private static final Holder HOLDER2 = new Holder(VALUE2);\n+    private static final RecordHolder RECORD_HOLDER = new RecordHolder(VALUE);\n+    private static final RecordHolder RECORD_HOLDER2 = new RecordHolder(VALUE2);\n+\n+    private final StableValue<Integer> stable = init(StableValue.of(), VALUE);\n+    private final StableValue<Integer> stable2 = init(StableValue.of(), VALUE2);\n+    private final StableValue<Integer> stableNull = StableValue.of();\n+    private final StableValue<Integer> stableNull2 = StableValue.of();\n+    private final Supplier<Integer> dcl = new Dcl<>(() -> VALUE);\n+    private final Supplier<Integer> dcl2 = new Dcl<>(() -> VALUE2);\n+    private final AtomicReference<Integer> atomic = new AtomicReference<>(VALUE);\n+    private final AtomicReference<Integer> atomic2 = new AtomicReference<>(VALUE2);\n+    private final Supplier<Integer> supplier = () -> VALUE;\n+    private final Supplier<Integer> supplier2 = () -> VALUE2;\n+\n+\n+    @Setup\n+    public void setup() {\n+        stableNull.trySet(null);\n+        stableNull2.trySet(null);\n+    }\n+\n+    @Benchmark\n+    public int atomic() {\n+        return atomic.get() + atomic2.get();\n+    }\n+\n+    @Benchmark\n+    public int dcl() {\n+        return dcl.get() + dcl2.get();\n+    }\n+\n+    @Benchmark\n+    public int stable() {\n+        return stable.orElseThrow() + stable2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int stableNull() {\n+        return (stableNull.orElseThrow() == null ? VALUE : VALUE2) + (stableNull2.orElseThrow() == null ? VALUE : VALUE2);\n+    }\n+\n+    \/\/ Reference case\n+    @Benchmark\n+    public int refSupplier() {\n+        return supplier.get() + supplier2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticAtomic() {\n+        return ATOMIC.get() + ATOMIC2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticDcl() {\n+        return DCL.orElseThrow() + DCL2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int staticHolder() {\n+        return HOLDER.get() + HOLDER2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticRecordHolder() {\n+        return RECORD_HOLDER.get() + RECORD_HOLDER2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticStable() {\n+        return STABLE.orElseThrow() + STABLE2.orElseThrow();\n+    }\n+\n+\n+    private static StableValue<Integer> init(StableValue<Integer> m, Integer value) {\n+        m.trySet(value);\n+        return m;\n+    }\n+\n+    private static final class Holder {\n+\n+        private final StableValue<Integer> delegate = StableValue.of();\n+\n+        Holder(int value) {\n+            delegate.setOrThrow(value);\n+        }\n+\n+        int get() {\n+            return delegate.orElseThrow();\n+        }\n+\n+    }\n+\n+    private record RecordHolder(StableValue<Integer> delegate) {\n+\n+        RecordHolder(int value) {\n+            this(StableValue.of());\n+            delegate.setOrThrow(value);\n+        }\n+\n+        int get() {\n+            return delegate.orElseThrow();\n+        }\n+\n+    }\n+\n+\n+    \/\/ Handles null values\n+    public static class Dcl<V> implements Supplier<V> {\n+\n+        private final Supplier<V> supplier;\n+\n+        private volatile V value;\n+        private boolean bound;\n+\n+        public Dcl(Supplier<V> supplier) {\n+            this.supplier = supplier;\n+        }\n+\n+        @Override\n+        public V get() {\n+            V v = value;\n+            if (v == null) {\n+                if (!bound) {\n+                    synchronized (this) {\n+                        v = value;\n+                        if (v == null) {\n+                            if (!bound) {\n+                                value = v = supplier.get();\n+                                bound = true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableValueBenchmark.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"}]}