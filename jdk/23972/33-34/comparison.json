{"files":[{"patch":"@@ -94,1 +94,3 @@\n- * Note that the content can only be set at most once.\n+ * If {@code getLogger()} is called from several threads, several instances of\n+ * {@code Logger} might be created. However, the content can only be set at most once\n+ * meaning one \"winner\" is picked among the many loggers.\n@@ -130,1 +132,1 @@\n- * evaluated only once, even when {@code logger.orElseSet()} is invoked concurrently.\n+ * evaluated at most once, even when {@code logger.orElseSet()} is invoked concurrently.\n@@ -162,1 +164,1 @@\n- * for that parameter value. A stable int function is created via the\n+ * for that parameter value. A stable {@link IntFunction} is created via the\n@@ -172,1 +174,1 @@\n- *      private SqrtUtil(){}\n+ *      private SqrtUtil() {}\n@@ -207,1 +209,1 @@\n- *     private SqrtUtil(){}\n+ *     private SqrtUtil() {}\n@@ -242,1 +244,1 @@\n- *     private SqrtUtil(){}\n+ *     private SqrtUtil() {}\n@@ -271,1 +273,1 @@\n- *     private SqrtUtil(){}\n+ *     private SqrtUtil() {}\n@@ -277,1 +279,1 @@\n- *             StableValue.map(Set.of(1, 2, 4, 8, 16, 32), StrictMath::sqrt);\n+ *             StableValue.map(CACHED_KEYS, StrictMath::sqrt);\n@@ -296,1 +298,1 @@\n- * A stable value can depend on other stable values, thereby creating a dependency graph\n+ * A stable value can depend on other stable values, forming a dependency graph\n@@ -304,1 +306,1 @@\n- *     private DependencyUtil(){}\n+ *     private DependencyUtil() {}\n@@ -353,1 +355,1 @@\n- * Both {@code FIB} and {@code Fibonacci::fib} recurses into each other. Because the\n+ * Both {@code FIB} and {@code Fibonacci::fib} recurse into each other. Because the\n@@ -373,1 +375,1 @@\n- * eventually throw a {@linkplain StackOverflowError} upon referencing elements in\n+ * eventually throw an {@linkplain IllegalStateException} upon referencing elements in\n@@ -426,1 +428,1 @@\n- *           will hold their set content perpetually.\n+ *           will hold their set content until the stable value itself is collected.\n@@ -593,1 +595,1 @@\n-     * {@return a new stable int function}\n+     * {@return a new stable {@linkplain IntFunction}}\n@@ -595,3 +597,3 @@\n-     * The returned {@link IntFunction int function} is a caching int function that,\n-     * for each allowed input, records the values of the provided {@code original}\n-     * int function upon being first accessed via the returned int function's\n+     * The returned function is a caching function that, for each allowed {@code int}\n+     * input, records the values of the provided {@code original}\n+     * function upon being first accessed via the returned function's\n@@ -600,1 +602,1 @@\n-     * The provided {@code original} int function is guaranteed to be successfully invoked\n+     * The provided {@code original} function is guaranteed to be successfully invoked\n@@ -602,1 +604,1 @@\n-     * threads invoking the returned int function's\n+     * threads invoking the returned function's\n@@ -607,1 +609,1 @@\n-     * If the provided {@code original} int function throws an exception, it is relayed\n+     * If the provided {@code original} function throws an exception, it is relayed\n@@ -610,1 +612,1 @@\n-     * The returned int function is not {@link Serializable}.\n+     * The returned function is not {@link Serializable}.\n@@ -612,2 +614,2 @@\n-     * If the provided {@code original} int function recursively calls the returned\n-     * int function for the same index, an {@linkplain IllegalStateException} will\n+     * If the provided {@code original} function recursively calls the returned\n+     * function for the same index, an {@linkplain IllegalStateException} will\n@@ -631,1 +633,1 @@\n-     * {@return a new stable function}\n+     * {@return a new stable {@linkplain Function}}\n@@ -633,1 +635,1 @@\n-     * The returned {@link Function function} is a caching function that, for each allowed\n+     * The returned function is a caching function that, for each allowed\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StableValue.java","additions":27,"deletions":25,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        if (!member.test(value.ordinal())) {\n+        if (!member.test(value.ordinal())) { \/\/ Implicit null-check of value\n@@ -89,1 +89,0 @@\n-        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>();\n@@ -91,0 +90,1 @@\n+        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>(enumElements.length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,2 +92,3 @@\n-            throw new IllegalStateException(\"Cannot set the content to \" + content +\n-                    \" because the content is already set: \" + orElseThrow());\n+            \/\/ Neither the set content nor the provided content is reveled in the\n+            \/\/ exception message as it might be sensitive.\n+            throw new IllegalStateException(\"The content is already set\");\n@@ -168,1 +169,1 @@\n-            throw new IllegalStateException(\"Recursing supplier detected\");\n+            throw new IllegalStateException(\"Recursive initialization is not supported\");\n@@ -172,0 +173,8 @@\n+    \/**\n+     * Wraps the provided {@code newValue} and tries to set the content.\n+     * <p>\n+     * This method ensures the {@link Stable} field is written to at most once.\n+     *\n+     * @param newValue to wrap and set\n+     * @return if the content was set\n+     *\/\n@@ -175,1 +184,0 @@\n-        \/\/ This upholds the invariant, a `@Stable` field is written to at most once\n@@ -177,2 +185,3 @@\n-        if (content != null) {\n-            return false;\n+        if (content == null) {\n+            UNSAFE.putReferenceRelease(this, CONTENT_OFFSET, wrap(newValue));\n+            return true;\n@@ -180,2 +189,1 @@\n-        UNSAFE.putReferenceRelease(this, CONTENT_OFFSET, wrap(newValue));\n-        return true;\n+        return false;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * @compile --enable-preview -source ${jdk.version} StableFunctionTest.java\n- * @run junit\/othervm --enable-preview StableFunctionTest\n+ * @enablePreview\n+ * @run junit StableFunctionTest\n@@ -86,0 +86,1 @@\n+        toStringTest(inputs, MAPPER);\n@@ -87,0 +88,1 @@\n+        toStringTest(inputs, _ -> null);\n@@ -96,7 +98,0 @@\n-        assertTrue(cached.toString().startsWith(\"{\"), cached.toString());\n-        \/\/ Key order is unspecified\n-        assertTrue(cached.toString().contains(Value.THIRTEEN + \"=.unset\"));\n-        assertTrue(cached.toString().contains(Value.FORTY_TWO + \"=\" + mapper.apply(Value.FORTY_TWO)), cached.toString());\n-        assertTrue(cached.toString().endsWith(\"}\"));\n-        \/\/ One between the values\n-        assertEquals(1L, cached.toString().chars().filter(ch -> ch == ',').count(), cached.toString());\n@@ -104,1 +99,1 @@\n-        assertTrue(x0.getMessage().contains(\"ILLEGAL\"));\n+        assertEquals(\"Input not allowed: ILLEGAL_BEFORE\", x0.getMessage());\n@@ -106,1 +101,1 @@\n-        assertTrue(x1.getMessage().contains(\"ILLEGAL\"));\n+        assertEquals(\"Input not allowed: ILLEGAL_BETWEEN\", x1.getMessage());\n@@ -108,1 +103,14 @@\n-        assertTrue(x2.getMessage().contains(\"ILLEGAL\"));\n+        assertEquals(\"Input not allowed: ILLEGAL_AFTER\", x2.getMessage());\n+    }\n+\n+    void toStringTest(Set<Value> inputs, Function<Value, Integer> mapper) {\n+        var cached = StableValue.function(inputs, mapper);\n+        cached.apply(Value.FORTY_TWO);\n+        var toString = cached.toString();\n+        assertTrue(toString.startsWith(\"{\"));\n+        \/\/ Key order is unspecified\n+        assertTrue(toString.contains(Value.THIRTEEN + \"=.unset\"));\n+        assertTrue(toString.contains(Value.FORTY_TWO + \"=\" + mapper.apply(Value.FORTY_TWO)));\n+        assertTrue(toString.endsWith(\"}\"));\n+        \/\/ One between the values\n+        assertEquals(1L, toString.chars().filter(ch -> ch == ',').count());\n@@ -116,1 +124,1 @@\n-        assertTrue(f0.toString().contains(\"{}\"));\n+        assertEquals(\"{}\", f0.toString());\n@@ -133,1 +141,2 @@\n-        assertTrue(cached.toString().startsWith(\"{\"));\n+        var toString = cached.toString();\n+        assertTrue(toString.startsWith(\"{\"));\n@@ -135,3 +144,3 @@\n-        assertTrue(cached.toString().contains(Value.THIRTEEN + \"=.unset\"));\n-        assertTrue(cached.toString().contains(Value.FORTY_TWO + \"=.unset\"), cached.toString());\n-        assertTrue(cached.toString().endsWith(\"}\"));\n+        assertTrue(toString.contains(Value.THIRTEEN + \"=.unset\"));\n+        assertTrue(toString.contains(Value.FORTY_TWO + \"=.unset\"));\n+        assertTrue(toString.endsWith(\"}\"));\n@@ -147,2 +156,2 @@\n-        String toString = cached.toString();\n-        assertTrue(toString.contains(\"(this StableFunction)\"), toString);\n+        var toString = cached.toString();\n+        assertTrue(toString.contains(\"FORTY_TWO=(this StableFunction)\"), toString);\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFunctionTest.java","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * @compile --enable-preview -source ${jdk.version} StableIntFunctionTest.java\n- * @run junit\/othervm --enable-preview StableIntFunctionTest\n+ * @enablePreview\n+ * @run junit StableIntFunctionTest\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableIntFunctionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n- * @compile --enable-preview -source ${jdk.version} StableListTest.java\n- * @run junit\/othervm --enable-preview StableListTest\n+ * @enablePreview\n+ * @run junit StableListTest\n@@ -38,0 +38,1 @@\n+import java.util.Arrays;\n@@ -112,4 +113,10 @@\n-        Integer[] arr = new Integer[SIZE];\n-        arr[INDEX] = 1;\n-        assertSame(arr, StableValue.list(INDEX, IDENTITY).toArray(arr));\n-        assertNull(arr[INDEX]);\n+        Integer[] actual = new Integer[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            actual[INDEX] = 100 + i;\n+        }\n+        var list = StableValue.list(INDEX, IDENTITY);\n+        assertSame(actual, list.toArray(actual));\n+        Integer[] expected = IntStream.range(0, SIZE)\n+                .mapToObj(i -> i < INDEX ? i : null)\n+                .toArray(Integer[]::new);\n+        assertArrayEquals(expected, actual);\n@@ -283,1 +290,2 @@\n-        assertThrows(IllegalStateException.class, () -> lazy.get(INDEX));\n+        var x = assertThrows(IllegalStateException.class, () -> lazy.get(INDEX));\n+        assertEquals(\"Recursive initialization is not supported\", x.getMessage());\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n- * @compile --enable-preview -source ${jdk.version} StableMapTest.java\n- * @run junit\/othervm --enable-preview StableMapTest\n+ * @enablePreview\n+ * @run junit StableMapTest\n@@ -174,0 +174,1 @@\n+        var toString = entrySet.toString();\n@@ -175,1 +176,1 @@\n-            assertTrue(entrySet.toString().contains(key + \"=.unset\"));\n+            assertTrue(toString.contains(key + \"=.unset\"));\n@@ -177,2 +178,2 @@\n-        assertTrue(entrySet.toString().startsWith(\"[\"));\n-        assertTrue(entrySet.toString().endsWith(\"]\"));\n+        assertTrue(toString.startsWith(\"[\"));\n+        assertTrue(toString.endsWith(\"]\"));\n@@ -196,0 +197,1 @@\n+        var toString = map.toString();\n@@ -198,1 +200,1 @@\n-                assertTrue(map.toString().contains(key + \"=\" + key));\n+                assertTrue(toString.contains(key + \"=\" + key));\n@@ -200,1 +202,1 @@\n-                assertTrue(map.toString().contains(key + \"=.unset\"));\n+                assertTrue(toString.contains(key + \"=.unset\"));\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableMapTest.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * @compile --enable-preview -source ${jdk.version} StableSupplierTest.java\n- * @run junit\/othervm --enable-preview StableSupplierTest\n+ * @enablePreview\n+ * @run junit StableSupplierTest\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableSupplierTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n- * @compile --enable-preview -source ${jdk.version} StableValueFactoriesTest.java\n- * @run junit\/othervm --enable-preview StableValueFactoriesTest\n+ * @enablePreview\n+ * @run junit StableValueFactoriesTest\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueFactoriesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * @compile --enable-preview -source ${jdk.version} StableValueTest.java\n- * @run junit\/othervm --enable-preview StableValueTest\n+ * @enablePreview\n+ * @run junit StableValueTest\n@@ -32,1 +32,0 @@\n-import java.util.BitSet;\n@@ -34,0 +33,1 @@\n+import java.util.Map;\n@@ -36,0 +36,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -41,1 +42,0 @@\n-import java.util.function.IntFunction;\n@@ -68,1 +68,1 @@\n-                \"Cannot set the content to \" + VALUE2 + \" because the content is already set: \" + VALUE,\n+                \"The content is already set\",\n@@ -86,1 +86,1 @@\n-        assertEquals(\"Cannot set the content to \" + VALUE2 + \" because the content is already set: \" + VALUE, e.getMessage());\n+        assertEquals(\"The content is already set\", e.getMessage());\n@@ -94,1 +94,1 @@\n-        assertEquals(\"Cannot set the content to null because the content is already set: null\", e.getMessage());\n+        assertEquals(\"The content is already set\", e.getMessage());\n@@ -244,1 +244,1 @@\n-        BitSet winner = new BitSet(noThreads);\n+        Map<Integer, Boolean> winners = new ConcurrentHashMap<>();\n@@ -250,1 +250,1 @@\n-                        winner.set(i, winnerPredicate.test(stable, i));\n+                        winners.put(i, winnerPredicate.test(stable, i));\n@@ -262,1 +262,1 @@\n-        assertEquals(1, winner.cardinality());\n+        assertEquals(1, winners.values().stream().filter(b -> b).count());\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n- * @compile --enable-preview -source ${jdk.version} StableValuesSafePublicationTest.java\n- * @run junit\/othervm --enable-preview StableValuesSafePublicationTest\n+ * @enablePreview\n+ * @run junit StableValuesSafePublicationTest\n@@ -63,2 +63,1 @@\n-        int a;\n-        int b;\n+        int a, b, c, d, e;\n@@ -67,2 +66,1 @@\n-            a = 1;\n-            b = 1;\n+            a = b = c = d = e = 1;\n@@ -87,1 +85,4 @@\n-                observations[i] = a + (b << 1);\n+                int c = h.c;\n+                int d = h.d;\n+                int e = h.e;\n+                observations[i] = a + (b << 1) + (c << 2) + (c << 3) + (d << 4) + (e << 5);\n@@ -132,1 +133,1 @@\n-        int[] histogram = new int[4];\n+        int[] histogram = new int[64];\n@@ -139,7 +140,5 @@\n-        \/\/ a = 0, b = 0 : index 0\n-        assertEquals(0, histogram[0]);\n-        \/\/ a = 1, b = 0 : index 1\n-        assertEquals(0, histogram[1]);\n-        \/\/ a = 0, b = 1 : index 2\n-        assertEquals(0, histogram[2]);\n-        \/\/ a = 1, b = 1 : index 3\n+        \/\/ unless a = 1, ..., e = 1, zero observations should be seen\n+        for (int i = 0; i < 63; i++) {\n+            assertEquals(0, histogram[i]);\n+        }\n+        \/\/ a = 1, ..., e = 1 : index 2^5-1 = 63\n@@ -147,1 +146,1 @@\n-        assertEquals(THREADS * SIZE, histogram[3]);\n+        assertEquals(THREADS * SIZE, histogram[63]);\n@@ -153,1 +152,1 @@\n-                long deadline = System.currentTimeMillis()+TimeUnit.MINUTES.toMillis(1);\n+                long deadline = System.nanoTime() + TimeUnit.MINUTES.toNanos(1);\n@@ -165,1 +164,1 @@\n-                    if (System.currentTimeMillis() > deadline) {\n+                    if (System.nanoTime() > deadline) {\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValuesSafePublicationTest.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n- * @compile --enable-preview -source ${jdk.version} TrustedFieldTypeTest.java\n- * @run junit\/othervm --enable-preview --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED -Dopens=true TrustedFieldTypeTest\n- * @run junit\/othervm --enable-preview -Dopens=false TrustedFieldTypeTest\n+ * @enablePreview\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED -Dopens=true TrustedFieldTypeTest\n+ * @run junit\/othervm -Dopens=false TrustedFieldTypeTest\n@@ -113,1 +113,0 @@\n-\/\/            assertThrows(IllegalAccessException.class, () -> {\n@@ -116,1 +115,0 @@\n-\/\/            });\n@@ -118,1 +116,0 @@\n-\/\/            assertThrows(IllegalAccessException.class, () -> {\n@@ -120,1 +117,0 @@\n-\/\/            });\n","filename":"test\/jdk\/java\/lang\/StableValue\/TrustedFieldTypeTest.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"}]}