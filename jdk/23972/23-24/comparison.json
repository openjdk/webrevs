{"files":[{"patch":"@@ -572,0 +572,9 @@\n+\n+        @Override\n+        public String toString() {\n+            if (root instanceof StableList<E> stableList) {\n+                return StableUtil.renderElements(root, \"StableList\", stableList.delegates, offset, size);\n+            } else {\n+                return super.toString();\n+            }\n+        }\n@@ -777,1 +786,1 @@\n-        private final StableValueImpl<E>[] delegates;\n+        final StableValueImpl<E>[] delegates;\n@@ -1563,0 +1572,26 @@\n+        @Override\n+        public Collection<V> values() {\n+            return new StableMapValues();\n+        }\n+\n+        final class StableMapValues extends AbstractCollection<V> {\n+            @Override public Iterator<V> iterator() { return new ValueIterator(); }\n+            @Override public int size() { return StableMap.this.size(); }\n+            @Override public boolean isEmpty() { return StableMap.this.isEmpty();}\n+            @Override public void clear() { StableMap.this.clear(); }\n+            @Override public boolean contains(Object v) { return StableMap.this.containsValue(v); }\n+\n+            @Override\n+            public String toString() {\n+                final StableValueImpl<V>[] values = delegate.values().toArray(new IntFunction<StableValueImpl<V>[]>() {\n+                    @Override\n+                    public StableValueImpl<V>[] apply(int len) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        var array = (StableValueImpl<V>[]) Array.newInstance(StableValueImpl.class, len);\n+                        return array;\n+                    }\n+                });\n+                return StableUtil.renderElements(StableMap.this, \"StableMap\", values);\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n@@ -299,12 +302,18 @@\n-        Iterator<E> it = iterator();\n-        if (! it.hasNext())\n-            return \"[]\";\n-\n-        StringBuilder sb = new StringBuilder();\n-        sb.append('[');\n-        for (;;) {\n-            E e = it.next();\n-            sb.append(e == this ? \"(this Collection)\" : e);\n-            if (! it.hasNext())\n-                return sb.append(']').toString();\n-            sb.append(',').append(' ');\n+        if (base instanceof ImmutableCollections.StableList<E> stableList) {\n+            final StableValueImpl<E>[] reversed = ArraysSupport.reverse(\n+                    Arrays.copyOf(stableList.delegates, stableList.delegates.length));\n+            return StableUtil.renderElements(base, \"Collection\", reversed);\n+        } else {\n+            Iterator<E> it = iterator();\n+            if (!it.hasNext())\n+                return \"[]\";\n+\n+            StringBuilder sb = new StringBuilder();\n+            sb.append('[');\n+            for (; ; ) {\n+                E e = it.next();\n+                sb.append(e == this ? \"(this Collection)\" : e);\n+                if (!it.hasNext())\n+                    return sb.append(']').toString();\n+                sb.append(',').append(' ');\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderListView.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -15,0 +15,8 @@\n+        return renderElements(self, selfName, delegates, 0, delegates.length);\n+    }\n+\n+    public static <R> String renderElements(Object self,\n+                                            String selfName,\n+                                            StableValueImpl<R>[] delegates,\n+                                            int offset,\n+                                            int length) {\n@@ -18,1 +26,1 @@\n-        for (int i = 0; i < delegates.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -20,1 +28,1 @@\n-            final Object value = delegates[i].wrappedContentAcquire();\n+            final Object value = delegates[i + offset].wrappedContentAcquire();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.stream.Collectors;\n@@ -221,0 +222,1 @@\n+        assertInstanceOf(RandomAccess.class, lazySubList);\n@@ -238,6 +240,36 @@\n-        var lazy = newList();\n-        var lazySubList = lazy.subList(1, SIZE);\n-        var regularList = newRegularList();\n-        var regularSubList = regularList.subList(1, SIZE);\n-        \/\/ There is no requirement that the lazy sub list's toString method should be lazy\n-        assertEquals(regularSubList.toString(), lazySubList.toString());\n+        subListToString0(newList());\n+        subListToString0(newList().subList(1, SIZE));\n+        subListToString0(newList().subList(1, SIZE).subList(0, SIZE - 2));\n+    }\n+\n+    void subListToString0(List<Integer> subList) {\n+        assertEquals(asString(\".unset\", subList), subList.toString());\n+\n+        var first = subList.getFirst();\n+        assertEquals(asString(first.toString(), subList), subList.toString());\n+    }\n+\n+    @Test\n+    void reversed() {\n+        var reversed = newList().reversed();\n+        assertInstanceOf(RandomAccess.class, reversed);\n+        assertEquals(SIZE - 1, reversed.getFirst());\n+        assertEquals(0, reversed.getLast());\n+\n+        var reversed2 = reversed.reversed();\n+        assertEquals(0, reversed2.getFirst());\n+        assertEquals(SIZE - 1, reversed2.getLast());\n+    }\n+\n+    @Test\n+    void reversedToString() {\n+        var reversed = newList().reversed();\n+        subListToString0(reversed);\n+    }\n+\n+    @Test\n+    void subListReversedToString() {\n+        var list = newList().subList(1, SIZE - 1).reversed();\n+        \/\/ This combination is not lazy. There has to be a limit somewhere.\n+        var regularList = newRegularList().subList(1, SIZE - 1).reversed();\n+        assertEquals(regularList.toString(), list.toString());\n@@ -387,0 +419,6 @@\n+    static String asString(String first, List<Integer> list) {\n+        return \"[\" + first + \", \" + Stream.generate(() -> \".unset\")\n+                .limit(list.size() - 1)\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":44,"deletions":6,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.RandomAccess;\n@@ -210,0 +211,10 @@\n+    @Test\n+    void valuesToString() {\n+        var map = newMap();\n+        var values = map.values();\n+        assertEquals(\"[.unset, .unset, .unset]\", values.toString());\n+        map.get(KEY);\n+        var afterGet = values.toString();\n+        assertTrue(afterGet.contains(Integer.toString(KEY)), afterGet);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableMapTest.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}