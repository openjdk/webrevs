{"files":[{"patch":"@@ -393,2 +393,3 @@\n- *     <li>a {@link #orElse(Object) orElse(other)} that does not return the {@code other} value, or<\/li>\n- *     <li>an {@link #orElseSet(Supplier)} that does not {@code throw}<\/li>\n+ *     <li>a {@link #orElse(Object) orElse(other)} that does not return the {@code other} value<\/li>\n+ *     <li>an {@link #orElseSet(Supplier)} that does not {@code throw}, or<\/li>\n+ *     <li>an {@link #isSet()} that returns {@code true}<\/li>\n@@ -404,5 +405,3 @@\n- * A stable value that is <em>set<\/em> is treated as a constant by the JVM, enabling the\n- * same performance optimizations that are available for {@code final} fields.\n- * As such, stable values can be used to replace {@code final} fields in cases where\n- * <em>at-most-once<\/em> update semantics is crucial, but where the eager initialization\n- * semantics associated with {@code final} fields is too restrictive.\n+ * The _content_ of a set stable value is treated as a constant by the JVM, provided that\n+ * the reference to the stable value is also constant (e.g. in cases where the\n+ * stable value itself is stored in a `static final` field).\n@@ -410,5 +409,3 @@\n- * In JDK 24, {@code final} instance fields in records and hidden classes (such as classes\n- * spun from method references) are trusted by the JVM, allowing them to be treated as\n- * constants. However, {@code final} instance fields in regular classes are <em>not<\/em>\n- * trusted meaning that such fields are <em>not<\/em> eligible for performance\n- * optimizations by the JVM (such as constant folding).\n+ * This means that, at least in some cases, access to the content of a stable value\n+ * enjoys the same constant-folding optimizations that are available when accessing\n+ * `static final` fields.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StableValue.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"}]}