{"files":[{"patch":"@@ -253,0 +253,4 @@\n+static bool trust_final_non_static_fields_of_type(Symbol* signature) {\n+  return signature == vmSymbols::java_lang_StableValue_signature();\n+}\n+\n@@ -285,1 +289,3 @@\n-      _is_constant = is_stable_field || trust_final_non_static_fields(_holder);\n+      _is_constant = is_stable_field ||\n+                     trust_final_non_static_fields(_holder) ||\n+                     trust_final_non_static_fields_of_type(fd->signature());\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -747,0 +747,3 @@\n+  \/* Stable Values *\/                                                                                             \\\n+  template(java_lang_StableValue_signature,        \"Ljava\/lang\/StableValue;\")                                     \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-  return is_final() && (is_static() || ik->is_hidden() || ik->is_record());\n+  return is_final() && (is_static() || ik->is_hidden() || ik->is_record() ||\n+         signature() == vmSymbols::java_lang_StableValue_signature());\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,668 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.lang.stable.StableValueImpl;\n+import jdk.internal.lang.stable.StableValueFactories;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * A stable value is a deferred holder of shallowly immutable content.\n+ * <p>\n+ * A {@linkplain StableValue {@code StableValue<T>}} can be created using the factory\n+ * method {@linkplain StableValue#of() {@code StableValue.of()}}. When created\n+ * this way, the stable value is <em>unset<\/em>, which means it holds no <em>content<\/em>.\n+ * Its content, of type {@code T}, can be <em>set<\/em> by calling\n+ * {@linkplain #trySet(Object) trySet()}, {@linkplain #setOrThrow(Object) setOrThrow()},\n+ * or {@linkplain #orElseSet(Supplier) orElseSet()}. Once set, the content\n+ * can never change and can be retrieved by calling {@linkplain #orElseThrow() orElseThrow()}\n+ * , {@linkplain #orElse(Object) orElse()}, or {@linkplain #orElseSet(Supplier) orElseSet()}.\n+ * <p>\n+ * A stable value that is <em>set<\/em> is treated as a constant by the JVM, enabling the\n+ * same performance optimizations that are available for {@code final} fields.\n+ * As such, stable values can be used to replace {@code final} fields in cases where\n+ * <em>at-most-once<\/em> update semantics is crucial, but where the eager initialization\n+ * semantics associated with {@code final} fields is too restrictive.\n+ * <p>\n+ * Consider the following example where a stable value field \"{@code logger}\" is a\n+ * shallowly immutable holder of content of type {@code Logger} and that is initially\n+ * created as <em>unset<\/em>, which means it holds no content. Later in the example, the\n+ * state of the \"{@code logger}\" field is checked and if it is still <em>unset<\/em>,\n+ * the content is <em>set<\/em>:\n+ *\n+ * {@snippet lang = java:\n+ * public class Component {\n+ *\n+ *    \/\/ Creates a new unset stable value with no content\n+ *    \/\/ @link substring=\"of\" target=\"#of\" :\n+ *    private final StableValue<Logger> logger = StableValue.of();\n+ *\n+ *    private Logger getLogger() {\n+ *        if (!logger.isSet()) {\n+ *            logger.trySet(Logger.create(Component.class));\n+ *        }\n+ *        return logger.orElseThrow();\n+ *    }\n+ *\n+ *    public void process() {\n+ *        getLogger().info(\"Process started\");\n+ *        \/\/ ...\n+ *    }\n+ * }\n+ *}\n+ * <p>\n+ * Note that the holder value can only be set at most once.\n+ * In the example above, the {@code logger} field is declared {@code final} which is\n+ * a prerequisite for being treated as a constant by the JVM.\n+ *\n+ * <p>\n+ * To guarantee that, even under races, only one instance of {@code Logger} is ever\n+ * created, the {@linkplain #orElseSet(Supplier) orElseSet()} method can be used\n+ * instead, where the content is atomically and lazily computed via a\n+ * {@linkplain Supplier supplier}. In the example below, the supplier is provided in the\n+ * form of a lambda expression:\n+ *\n+ * {@snippet lang = java:\n+ * public class Component {\n+ *\n+ *    \/\/ Creates a new unset stable value with no content\n+ *    \/\/ @link substring=\"of\" target=\"#of\" :\n+ *    private final StableValue<Logger> logger = StableValue.of();\n+ *\n+ *    private Logger getLogger() {\n+ *        return logger.orElseSet( () -> Logger.create(Component.class) );\n+ *    }\n+ *\n+ *    public void process() {\n+ *        getLogger().info(\"Process started\");\n+ *        \/\/ ...\n+ *    }\n+ * }\n+ *}\n+ * <p>\n+ * The {@code getLogger()} method calls {@code logger.orElseSet()} on the stable value to\n+ * retrieve its content. If the stable value is <em>unset<\/em>, then {@code orElseSet()}\n+ * evaluates and sets the content; the content is then returned to the client. In other\n+ * words, {@code orElseSet()} guarantees that a stable value's content is <em>set<\/em>\n+ * before it is used.\n+ * <p>\n+ * Furthermore, {@code orElseSet()} guarantees that the supplier provided is\n+ * evaluated only once, even when {@code logger.orElseSet()} is invoked concurrently.\n+ * This property is crucial as evaluation of the supplier may have side effects,\n+ * e.g., the call above to {@code Logger.create()} may result in storage resources\n+ * being prepared.\n+ *\n+ * <h2 id=\"stable-functions\">Stable Functions<\/h2>\n+ * Stable values provide the foundation for higher-level functional abstractions. A\n+ * <em>stable supplier<\/em> is a supplier that computes a value and then caches it into\n+ * a backing stable value storage for later use. A stable supplier is created via the\n+ * {@linkplain StableValue#supplier(Supplier) StableValue.supplier()} factory, by\n+ * providing an original {@linkplain Supplier} which is invoked when the stable supplier\n+ * is first accessed:\n+ *\n+ * {@snippet lang = java:\n+ * public class Component {\n+ *\n+ *     private final Supplier<Logger> logger =\n+ *             \/\/ @link substring=\"supplier\" target=\"#supplier(Supplier)\" :\n+ *             StableValue.supplier( () -> Logger.getLogger(Component.class) );\n+ *\n+ *     public void process() {\n+ *        logger.get().info(\"Process started\");\n+ *        \/\/ ...\n+ *     }\n+ * }\n+ *}\n+ * A stable supplier encapsulates access to its backing stable value storage. This means\n+ * that code inside {@code Component} can obtain the logger object directly from the\n+ * stable supplier, without having to go through an accessor method like {@code getLogger()}.\n+ * <p>\n+ * A <em>stable int function<\/em> is a function that takes an {@code int} parameter and\n+ * uses it to compute a result that is then cached by the backing stable value storage\n+ * for that parameter value. A stable int function is created via the\n+ * {@linkplain StableValue#intFunction(int, IntFunction) StableValue.intFunction()}\n+ * factory. Upon creation, the input range (i.e. [0, size)) is specified together with\n+ * an original {@linkplain IntFunction} which is invoked at most once per input value. In\n+ * effect, the stable int function will act like a cache for the original {@linkplain IntFunction}:\n+ *\n+ * {@snippet lang = java:\n+ * public final class SqrtUtil {\n+ *\n+ *      private SqrtUtil(){}\n+ *\n+ *      private static final IntFunction<Double> SQRT =\n+ *              \/\/ @link substring=\"intFunction\" target=\"#intFunction(int,IntFunction)\" :\n+ *              StableValue.intFunction(10, StrictMath::sqrt);\n+ *\n+ *      public static double sqrt9() {\n+ *          return SQRT.apply(9); \/\/ May eventually constant fold to 3.0 at runtime\n+ *      }\n+ *\n+ *  }\n+ *}\n+ * <p>\n+ * A <em>stable function<\/em> is a function that takes a parameter (of type {@code T}) and\n+ * uses it to compute a result (of type {@code R}) that is then cached by the backing\n+ * stable value storage for that parameter value. A stable function is created via the\n+ * {@linkplain StableValue#function(Set, Function) StableValue.function()} factory.\n+ * Upon creation, the input {@linkplain Set} is specified together with an original\n+ * {@linkplain Function} which is invoked at most once per input value. In effect, the\n+ * stable function will act like a cache for the original {@linkplain Function}:\n+ *\n+ * {@snippet lang = java:\n+ * public final class SqrtUtil {\n+ *\n+ *     private SqrtUtil(){}\n+ *\n+ *     private static final Function<Integer, Double> SQRT =\n+ *             \/\/ @link substring=\"function\" target=\"#function(Set,Function)\" :\n+ *             StableValue.function(Set.of(1, 2, 4, 8, 16, 32), StrictMath::sqrt);\n+ *\n+ *     public static double sqrt16() {\n+ *         return SQRT.apply(16); \/\/ May eventually constant fold to 4.0 at runtime\n+ *     }\n+ *\n+ * }\n+ *}\n+ *\n+ * <h2 id=\"stable-collections\">Stable Collections<\/h2>\n+ * Stable values can also be used as backing storage for\n+ * {@linkplain Collection##unmodifiable unmodifiable collections}. A <em>stable list<\/em>\n+ * is an unmodifiable list, backed by an array of stable values. The stable list elements\n+ * are computed when they are first accessed, using a provided {@linkplain IntFunction}:\n+ *\n+ * {@snippet lang = java:\n+ * public final class SqrtUtil {\n+ *\n+ *     private SqrtUtil(){}\n+ *\n+ *     private static final List<Double> SQRT =\n+ *             \/\/ @link substring=\"list\" target=\"#list(int,IntFunction)\" :\n+ *             StableValue.list(10, StrictMath::sqrt);\n+ *\n+ *     public static double sqrt9() {\n+ *         return SQRT.get(9); \/\/ May eventually constant fold to 3.0 at runtime\n+ *     }\n+ *\n+ * }\n+ *}\n+ * <p>\n+ * Similarly, a <em>stable map<\/em> is an unmodifiable map whose keys are known at\n+ * construction. The stable map values are computed when they are first accessed,\n+ * using a provided {@linkplain Function}:\n+ *\n+ * {@snippet lang = java:\n+ * public final class SqrtUtil {\n+ *\n+ *     private SqrtUtil(){}\n+ *\n+ *     private static final Map<Integer, Double> SQRT =\n+ *             \/\/ @link substring=\"map\" target=\"#map(Set,Function)\" :\n+ *             StableValue.map(Set.of(1, 2, 4, 8, 16, 32), StrictMath::sqrt);\n+ *\n+ *     public static double sqrt16() {\n+ *         return SQRT.get(16); \/\/ May eventually constant fold to 4.0 at runtime\n+ *     }\n+ *\n+ * }\n+ *}\n+ *\n+ * <h2 id=\"composition\">Composing stable values<\/h2>\n+ * A stable value can depend on other stable values, thereby creating a dependency graph\n+ * that can be lazily computed but where access to individual elements still can be\n+ * constant-folded. In the following example, a single {@code Foo} and a {@code Bar}\n+ * instance (that is dependent on the {@code Foo} instance) are lazily created, both of\n+ * which are held by stable values:\n+ * {@snippet lang = java:\n+ * public final class DependencyUtil {\n+ *\n+ *     private DependencyUtil(){}\n+ *\n+ *     public static class Foo {\n+ *          \/\/ ...\n+ *      }\n+ *\n+ *     public static class Bar {\n+ *         public Bar(Foo foo) {\n+ *              \/\/ ...\n+ *         }\n+ *     }\n+ *\n+ *     private static final Supplier<Foo> FOO = StableValue.supplier(Foo::new);\n+ *     private static final Supplier<Bar> BAR = StableValue.supplier(() -> new Bar(FOO.get()));\n+ *\n+ *     public static Foo foo() {\n+ *         return FOO.get();\n+ *     }\n+ *\n+ *     public static Bar bar() {\n+ *         return BAR.get();\n+ *     }\n+ *\n+ * }\n+ *}\n+ * Calling {@code bar()} will create the {@code Bar} singleton if it is not already\n+ * created. Upon such a creation, the dependent {@code Foo} will first be created if\n+ * the {@code Foo} does not already exist.\n+ * <p>\n+ * Here is another example where a more complex dependency graph is created in which\n+ * integers in the Fibonacci delta series are lazily computed:\n+ * {@snippet lang = java:\n+ * public final class Fibonacci {\n+ *\n+ *     private Fibonacci() {}\n+ *\n+ *     private static final int MAX_SIZE_INT = 46;\n+ *\n+ *     private static final IntFunction<Integer> FIB =\n+ *             StableValue.intFunction(MAX_SIZE_INT, Fibonacci::fib);\n+ *\n+ *     public static int fib(int n) {\n+ *         return n < 2\n+ *                 ? n\n+ *                 : FIB.apply(n - 1) + FIB.apply(n - 2);\n+ *     }\n+ *\n+ * }\n+ *}\n+ * Both {@code FIB} and {@code Fibonacci::fib} recurses into each other. Because the\n+ * stable int function {@code FIB} caches intermediate results, the initial\n+ * computational complexity is reduced from exponential to linear compared to a\n+ * traditional non-caching recursive fibonacci method. Once computed, the VM is free to\n+ * constant-fold expressions like {@code Fibonacci.fib(10)}.\n+ * <p>\n+ * The fibonacci example above is a dependency graph with no circular dependencies (i.e.,\n+ * it is a dependency tree). If there are circular dependencies in a dependency graph,\n+ * a stable value will eventually throw a {@linkplain StackOverflowError} upon referencing\n+ * elements in a circularity.\n+ *\n+ * <h2 id=\"thread-safety\">Thread Safety<\/h2>\n+ * The content of a stable value is guaranteed to be set at most once. If competing\n+ * threads are racing to set a stable value, only one update succeeds, while other updates\n+ * are blocked until the stable value becomes set.\n+ * <p>\n+ * The at-most-once write operation on a stable value that succeeds\n+ * (e.g. {@linkplain #trySet(Object) trySet()})\n+ * {@linkplain java.util.concurrent##MemoryVisibility <em>happens-before<\/em>}\n+ * any subsequent read operation (e.g. {@linkplain #orElseThrow()}).\n+ * <p>\n+ * The method {@linkplain StableValue#orElseSet(Supplier) orElseSet()} guarantees that\n+ * the provided {@linkplain Supplier} is invoked successfully at most once even under\n+ * race. Since stable functions and stable collections are built on top of\n+ * {@linkplain StableValue#orElseSet(Supplier) orElseSet()} they too are\n+ * thread safe and guarantee at-most-once-per-input invocation.\n+ *\n+ * @implSpec Implementing classes of {@linkplain StableValue} are free to synchronize on\n+ *           {@code this} and consequently, care should be taken whenever\n+ *           (directly or indirectly) synchronizing on a {@code StableValue}. Failure to\n+ *           do this may lead to deadlock. Stable functions and collections on the\n+ *           other hand are guaranteed <em>not to synchronize<\/em> on {@code this}.\n+ *           Except for a {@code StableValue}'s content itself, an {@linkplain #orElse(Object) orElse(other)}\n+ *           parameter, and an {@linkplain #equals(Object) equals(obj)} parameter; all\n+ *           method parameters must be <em>non-null<\/em> or a {@link NullPointerException}\n+ *           will be thrown.\n+ *\n+ * @implNote A {@linkplain StableValue} is mainly intended to be a non-public field in\n+ *           a class and is usually neither exposed directly via accessors nor passed as\n+ *           a method parameter.\n+ *           As objects can be set via stable values but never removed, this can be a source\n+ *           of unintended memory leaks. A stable value's content is\n+ *           {@linkplain java.lang.ref##reachability strongly reachable}. Clients are\n+ *           advised that {@linkplain java.lang.ref##reachability reachable} stable values\n+ *           will hold their set content perpetually.\n+ *           A {@linkplain StableValue} that has a type parameter {@code T} that is an array\n+ *           type (of arbitrary rank) will only allow the JVM to treat the <em>array reference<\/em>\n+ *           as a stable value but <em>not its components<\/em>. Clients can instead use\n+ *           {@linkplain #list(int, IntFunction) a stable list} of arbitrary depth, which\n+ *           provides stable components. More generally, a stable value can hold other\n+ *           stable values of arbitrary depth and still provide transitive constantness.\n+ *\n+ * @param <T> type of the content\n+ *\n+ * @since 25\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.STABLE_VALUES)\n+public sealed interface StableValue<T>\n+        permits StableValueImpl {\n+\n+    \/\/ Principal methods\n+\n+    \/**\n+     * {@return {@code true} if the content was set to the provided {@code value},\n+     *          {@code false} otherwise}\n+     * <p>\n+     * When this method returns, the content is always set.\n+     *\n+     * @param value to set\n+     *\/\n+    boolean trySet(T value);\n+\n+    \/**\n+     * {@return the content if set, otherwise, returns the provided {@code other} value}\n+     *\n+     * @param other to return if the content is not set\n+     *\/\n+    T orElse(T other);\n+\n+    \/**\n+     * {@return the content if set, otherwise, throws {@code NoSuchElementException}}\n+     *\n+     * @throws NoSuchElementException if no content is set\n+     *\/\n+    T orElseThrow();\n+\n+    \/**\n+     * {@return {@code true} if the content is set, {@code false} otherwise}\n+     *\/\n+    boolean isSet();\n+\n+    \/**\n+     * {@return the content; if unset, first attempts to compute and set the\n+     *          content using the provided {@code supplier}}\n+     * <p>\n+     * The provided {@code supplier} is guaranteed to be invoked at most once if it\n+     * completes without throwing an exception.\n+     * <p>\n+     * If the supplier throws an (unchecked) exception, the exception is rethrown, and no\n+     * content is set. The most common usage is to construct a new object serving\n+     * as a lazily computed value or memoized result, as in:\n+     *\n+     * {@snippet lang=java:\n+     * Value witness = stable.orElseSet(Value::new);\n+     * }\n+     * <p>\n+     * When this method returns successfully, the content is always set.\n+     *\n+     * @implSpec The implementation logic is equivalent to the following steps for this\n+     *           {@code stable}:\n+     *\n+     * {@snippet lang=java:\n+     * if (stable.isSet()) {\n+     *     return stable.orElseThrow();\n+     * } else {\n+     *     T newValue = supplier.get();\n+     *     stable.setOrThrow(newValue);\n+     *     return newValue;\n+     * }\n+     * }\n+     * Except it is thread-safe and will only return the same witness value\n+     * regardless if invoked by several threads. Also, the provided {@code supplier}\n+     * will only be invoked once even if invoked from several threads unless the\n+     * {@code supplier} throws an exception.\n+     *\n+     * @param  supplier to be used for computing the content, if not previously set\n+     * @throws IllegalStateException if the provided {@code supplier} recursively\n+     *                               attempts to set this stable value.\n+     *\/\n+    T orElseSet(Supplier<? extends T> supplier);\n+\n+    \/\/ Convenience methods\n+\n+    \/**\n+     * Sets the content to the provided {@code value}, or, if already set,\n+     * throws {@code IllegalStateException}.\n+     * <p>\n+     * When this method returns (or throws an exception), the content is always set.\n+     *\n+     * @param value to set\n+     * @throws IllegalStateException if the content was already set\n+     *\/\n+    void setOrThrow(T value);\n+\n+    \/\/ Object methods\n+\n+    \/**\n+     * {@return {@code true} if {@code this == obj}, {@code false} otherwise}\n+     *\n+     * @param obj to check for equality\n+     *\/\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the {@linkplain System#identityHashCode(Object) identity hash code} of\n+     *          {@code this} object}\n+     *\/\n+    int hashCode();\n+\n+    \/\/ Factories\n+\n+    \/**\n+     * {@return a new unset stable value}\n+     * <p>\n+     * An unset stable value has no content.\n+     * <p>\n+     * The returned stable value is not {@link Serializable}.\n+     *\n+     * @param <T> type of the content\n+     *\/\n+    static <T> StableValue<T> of() {\n+        return StableValueFactories.of();\n+    }\n+\n+    \/**\n+     * {@return a new pre-set stable value with the provided {@code content}}\n+     * <p>\n+     * The returned stable value is not {@link Serializable}.\n+     *\n+     * @param content to set\n+     * @param <T>     type of the content\n+     *\/\n+    static <T> StableValue<T> of(T content) {\n+        return StableValueFactories.of(content);\n+    }\n+\n+    \/**\n+     * {@return a new stable supplier}\n+     * <p>\n+     * The returned {@linkplain Supplier supplier} is a caching supplier that records\n+     * the value of the provided {@code original} supplier upon being first accessed via\n+     * the returned supplier's {@linkplain Supplier#get() get()} method.\n+     * <p>\n+     * The provided {@code original} supplier is guaranteed to be successfully invoked\n+     * at most once even in a multi-threaded environment. Competing threads invoking the\n+     * returned supplier's {@linkplain Supplier#get() get()} method when a value is\n+     * already under computation will block until a value is computed or an exception is\n+     * thrown by the computing thread.\n+     * <p>\n+     * If the provided {@code original} supplier throws an exception, it is relayed\n+     * to the initial caller and no content is recorded.\n+     * <p>\n+     * The returned supplier is not {@link Serializable}.\n+     * <p>\n+     * If the provided {@code original} supplier recursively calls the returned\n+     * supplier, an {@linkplain IllegalStateException} will be thrown.\n+     *\n+     * @param original supplier used to compute a cached value\n+     * @param <T>      the type of results supplied by the returned supplier\n+     *\/\n+    static <T> Supplier<T> supplier(Supplier<? extends T> original) {\n+        Objects.requireNonNull(original);\n+        return StableValueFactories.supplier(original);\n+    }\n+\n+    \/**\n+     * {@return a new stable int function}\n+     * <p>\n+     * The returned {@link IntFunction int function} is a caching int function that,\n+     * for each allowed input, records the values of the provided {@code original}\n+     * int function upon being first accessed via the returned int function's\n+     * {@linkplain IntFunction#apply(int) apply()} method.\n+     * <p>\n+     * The provided {@code original} int function is guaranteed to be successfully invoked\n+     * at most once per allowed input, even in a multi-threaded environment. Competing\n+     * threads invoking the returned int function's\n+     * {@linkplain IntFunction#apply(int) apply()} method when a value is already under\n+     * computation will block until a value is computed or an exception is thrown by\n+     * the computing thread.\n+     * <p>\n+     * If the provided {@code original} int function throws an exception, it is relayed\n+     * to the initial caller and no content is recorded.\n+     * <p>\n+     * The returned int function is not {@link Serializable}.\n+     * <p>\n+     * If the provided {@code original} int function recursively calls the returned\n+     * int function for the same index, an {@linkplain IllegalStateException} will\n+     * be thrown.\n+     *\n+     * @param size     the size of the allowed inputs in {@code [0, size)}\n+     * @param original IntFunction used to compute cached values\n+     * @param <R>      the type of results delivered by the returned IntFunction\n+     * @throws IllegalArgumentException if the provided {@code size} is negative.\n+     *\/\n+    static <R> IntFunction<R> intFunction(int size,\n+                                          IntFunction<? extends R> original) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        Objects.requireNonNull(original);\n+        return StableValueFactories.intFunction(size, original);\n+    }\n+\n+    \/**\n+     * {@return a new stable function}\n+     * <p>\n+     * The returned {@link Function function} is a caching function that, for each allowed\n+     * input in the given set of {@code inputs}, records the values of the provided\n+     * {@code original} function upon being first accessed via the returned function's\n+     * {@linkplain Function#apply(Object) apply()} method.\n+     * <p>\n+     * The provided {@code original} function is guaranteed to be successfully invoked\n+     * at most once per allowed input, even in a multi-threaded environment. Competing\n+     * threads invoking the returned function's {@linkplain Function#apply(Object) apply()}\n+     * method when a value is already under computation will block until a value is\n+     * computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If the provided {@code original} function throws an exception, it is relayed to\n+     * the initial caller and no content is recorded.\n+     * <p>\n+     * The returned function is not {@link Serializable}.\n+     * <p>\n+     * If the provided {@code original} function recursively calls the returned\n+     * function for the same input, an {@linkplain IllegalStateException} will\n+     * be thrown.\n+     *\n+     * @param inputs   the set of allowed input values\n+     * @param original Function used to compute cached values\n+     * @param <T>      the type of the input to the returned Function\n+     * @param <R>      the type of results delivered by the returned Function\n+     *\/\n+    static <T, R> Function<T, R> function(Set<? extends T> inputs,\n+                                          Function<? super T, ? extends R> original) {\n+        Objects.requireNonNull(inputs);\n+        Objects.requireNonNull(original);\n+        return StableValueFactories.function(inputs, original);\n+    }\n+\n+    \/**\n+     * {@return a new stable list with the provided {@code size}}\n+     * <p>\n+     * The returned list is an {@linkplain Collection##unmodifiable unmodifiable} list\n+     * whose size is known at construction. The list's elements are computed via the\n+     * provided {@code mapper} when they are first accessed\n+     * (e.g. via {@linkplain List#get(int) List::get}).\n+     * <p>\n+     * The provided {@code mapper} int function is guaranteed to be successfully invoked\n+     * at most once per list index, even in a multi-threaded environment. Competing\n+     * threads accessing an element already under computation will block until an element\n+     * is computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If the provided {@code mapper} throws an exception, it is relayed to the initial\n+     * caller and no value for the element is recorded.\n+     * <p>\n+     * The returned list and its {@link List#subList(int, int) subList} views implement\n+     * the {@link RandomAccess} interface.\n+     * <p>\n+     * The returned list is not {@link Serializable} and, as it is unmodifiable, does\n+     * not implement the {@linkplain Collection##optional-operation optional operations}\n+     * in the {@linkplain List} interface.\n+     * <p>\n+     * If the provided {@code mapper} recursively calls the returned list for the\n+     * same index, an {@linkplain IllegalStateException} will be thrown.\n+     *\n+     * @param size   the size of the returned list\n+     * @param mapper to invoke whenever an element is first accessed\n+     *               (may return {@code null})\n+     * @param <E>    the type of elements in the returned list\n+     * @throws IllegalArgumentException if the provided {@code size} is negative.\n+     *\/\n+    static <E> List<E> list(int size,\n+                            IntFunction<? extends E> mapper) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        Objects.requireNonNull(mapper);\n+        return StableValueFactories.list(size, mapper);\n+    }\n+\n+    \/**\n+     * {@return a new stable map with the provided {@code keys}}\n+     * <p>\n+     * The returned map is an {@linkplain Collection##unmodifiable unmodifiable} map whose\n+     * keys are known at construction. The map's values are computed via the provided\n+     * {@code mapper} when they are first accessed\n+     * (e.g. via {@linkplain Map#get(Object) Map::get}).\n+     * <p>\n+     * The provided {@code mapper} function is guaranteed to be successfully invoked\n+     * at most once per key, even in a multi-threaded environment. Competing\n+     * threads accessing a value already under computation will block until an element\n+     * is computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If the provided {@code mapper} throws an exception, it is relayed to the initial\n+     * caller and no value associated with the provided key is recorded.\n+     * <p>\n+     * The returned map is not {@link Serializable} and, as it is unmodifiable, does\n+     * not implement the {@linkplain Collection##optional-operations optional operations}\n+     * in the {@linkplain Map} interface.\n+     * <p>\n+     * If the provided {@code mapper} recursively calls the returned map for\n+     * the same key, an {@linkplain IllegalStateException} will be thrown.\n+     *\n+     * @param keys   the keys in the returned map\n+     * @param mapper to invoke whenever an associated value is first accessed\n+     *               (may return {@code null})\n+     * @param <K>    the type of keys maintained by the returned map\n+     * @param <V>    the type of mapped values in the returned map\n+     *\/\n+    static <K, V> Map<K, V> map(Set<K> keys,\n+                                Function<? super K, ? extends V> mapper) {\n+        Objects.requireNonNull(keys);\n+        Objects.requireNonNull(mapper);\n+        return StableValueFactories.map(keys, mapper);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StableValue.java","additions":668,"deletions":0,"binary":false,"changes":668,"status":"added"},{"patch":"@@ -61,1 +61,1 @@\n- * <p>Certain methods are specified to be\n+ * <p><a id=\"optional-operations\"><\/a>Certain methods are specified to be\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.Consumer;\n@@ -37,0 +38,1 @@\n+import java.util.function.IntFunction;\n@@ -38,0 +40,1 @@\n+import java.util.function.Supplier;\n@@ -39,0 +42,1 @@\n+\n@@ -41,0 +45,3 @@\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n+import jdk.internal.lang.stable.StableValueFactories;\n@@ -42,0 +49,2 @@\n+import jdk.internal.util.NullableKeyValueHolder;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -129,0 +138,6 @@\n+                public <E> List<E> stableList(int size, IntFunction<? extends E> mapper) {\n+                    return ImmutableCollections.stableList(size, mapper);\n+                }\n+                public <K, V> Map<K, V> stableMap(Set<K> keys, Function<? super K, ? extends V> mapper) {\n+                    return new StableMap<>(keys, mapper);\n+                }\n@@ -251,0 +266,5 @@\n+    static <E> List<E> stableList(int size, IntFunction<? extends E> mapper) {\n+        \/\/ A lazy list is not Serializable so, we cannot return `List.of()` if size == 0\n+        return new StableList<>(size, mapper);\n+    }\n+\n@@ -449,1 +469,1 @@\n-            assert root instanceof List12 || root instanceof ListN;\n+            assert root instanceof List12 || root instanceof ListN || root instanceof StableList;\n@@ -500,1 +520,2 @@\n-            return root instanceof ListN && ((ListN<?>)root).allowNulls;\n+            return root instanceof ListN<?> listN && listN.allowNulls\n+                    || root instanceof StableList<E>;\n@@ -751,0 +772,82 @@\n+    @jdk.internal.ValueBased\n+    static final class StableList<E> extends AbstractImmutableList<E> {\n+\n+        @Stable\n+        private final IntFunction<? extends E> mapper;\n+        @Stable\n+        private final StableValueImpl<E>[] delegates;\n+\n+        StableList(int size, IntFunction<? extends E> mapper) {\n+            this.mapper = mapper;\n+            this.delegates = StableValueFactories.array(size);\n+        }\n+\n+        @Override public boolean  isEmpty() { return delegates.length == 0;}\n+        @Override public int      size() { return delegates.length; }\n+        @Override public Object[] toArray() { return copyInto(new Object[size()]); }\n+\n+        @ForceInline\n+        @Override\n+        public E get(int i) {\n+            try {\n+                return delegates[i]\n+                        .orElseSet(new Supplier<E>() {\n+                            @Override  public E get() { return mapper.apply(i); }});\n+            } catch (ArrayIndexOutOfBoundsException aioobe) {\n+                throw new IndexOutOfBoundsException(i);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] a) {\n+            final int size = delegates.length;\n+            if (a.length < size) {\n+                \/\/ Make a new array of a's runtime type, but my contents:\n+                T[] n = (T[])Array.newInstance(a.getClass().getComponentType(), size);\n+                return copyInto(n);\n+            }\n+            copyInto(a);\n+            if (a.length > size) {\n+                a[size] = null; \/\/ null-terminate\n+            }\n+            return a;\n+        }\n+\n+        @Override\n+        public int indexOf(Object o) {\n+            final int size = size();\n+            for (int i = 0; i < size; i++) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            for (int i = size() - 1; i >= 0; i--) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private <T> T[] copyInto(Object[] a) {\n+            final int len = delegates.length;\n+            for (int i = 0; i < len; i++) {\n+                a[i] = get(i);\n+            }\n+            return (T[]) a;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return StableUtil.renderElements(this, \"StableList\", delegates);\n+        }\n+\n+    }\n+\n@@ -1075,1 +1178,1 @@\n-    abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> implements Serializable {\n+    abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> {\n@@ -1106,1 +1209,1 @@\n-    static final class Map1<K,V> extends AbstractImmutableMap<K,V> {\n+    static final class Map1<K,V> extends AbstractImmutableMap<K,V> implements Serializable {\n@@ -1173,1 +1276,1 @@\n-    static final class MapN<K,V> extends AbstractImmutableMap<K,V> {\n+    static final class MapN<K,V> extends AbstractImmutableMap<K,V> implements Serializable {\n@@ -1363,0 +1466,88 @@\n+\n+    static final class StableMap<K, V>\n+            extends AbstractImmutableMap<K, V> {\n+\n+        @Stable\n+        private final Function<? super K, ? extends V> mapper;\n+        @Stable\n+        private final Map<K, StableValueImpl<V>> delegate;\n+\n+        StableMap(Set<K> keys, Function<? super K, ? extends V> mapper) {\n+            this.mapper = mapper;\n+            this.delegate = StableValueFactories.map(keys);\n+        }\n+\n+        @Override public boolean              containsKey(Object o) { return delegate.containsKey(o); }\n+        @Override public int                  size() { return delegate.size(); }\n+        @Override public Set<Map.Entry<K, V>> entrySet() { return new StableMapEntrySet(); }\n+\n+        @ForceInline\n+        @Override\n+        public V get(Object key) {\n+            final StableValueImpl<V> stable = delegate.get(key);\n+            if (stable == null) {\n+                return null;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final K k = (K) key;\n+            return stable.orElseSet(new Supplier<V>() {\n+                @Override public V get() { return mapper.apply(k); }});\n+        }\n+\n+        @jdk.internal.ValueBased\n+        final class StableMapEntrySet extends AbstractImmutableSet<Map.Entry<K, V>> {\n+\n+            @Stable\n+            private final Set<Map.Entry<K, StableValueImpl<V>>> delegateEntrySet;\n+\n+            StableMapEntrySet() {\n+                this.delegateEntrySet = delegate.entrySet();\n+            }\n+\n+            @Override public Iterator<Map.Entry<K, V>> iterator() { return new LazyMapIterator(); }\n+            @Override public int                       size() { return delegateEntrySet.size(); }\n+            @Override public int                       hashCode() { return StableMap.this.hashCode(); }\n+\n+            @jdk.internal.ValueBased\n+            final class LazyMapIterator implements Iterator<Map.Entry<K, V>> {\n+\n+                @Stable\n+                private final Iterator<Map.Entry<K, StableValueImpl<V>>> delegateIterator;\n+\n+                LazyMapIterator() {\n+                    this.delegateIterator = delegateEntrySet.iterator();\n+                }\n+\n+                @Override public boolean hasNext() { return delegateIterator.hasNext(); }\n+\n+                @Override\n+                public Entry<K, V> next() {\n+                    final Map.Entry<K, StableValueImpl<V>> inner = delegateIterator.next();\n+                    final K k = inner.getKey();\n+                    return new NullableKeyValueHolder<>(k, inner.getValue().orElseSet(new Supplier<V>() {\n+                        @Override public V get() { return mapper.apply(k); }}));\n+                }\n+\n+                @Override\n+                public void forEachRemaining(Consumer<? super Map.Entry<K, V>> action) {\n+                    final Consumer<? super Map.Entry<K, StableValueImpl<V>>> innerAction =\n+                            new Consumer<>() {\n+                                @Override\n+                                public void accept(Entry<K, StableValueImpl<V>> inner) {\n+                                    final K k = inner.getKey();\n+                                    action.accept(new NullableKeyValueHolder<>(k, inner.getValue().orElseSet(new Supplier<V>() {\n+                                        @Override public V get() { return mapper.apply(k); }})));\n+                                }\n+                            };\n+                    delegateIterator.forEachRemaining(innerAction);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return StableUtil.renderMappings(this, \"StableMap\", delegate.entrySet());\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":196,"deletions":5,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,4 @@\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n@@ -33,0 +37,2 @@\n+    <E> List<E> stableList(int size, IntFunction<? extends E> mapper);\n+    <K, V> Map<K, V> stableMap(Set<K> keys, Function<? super K, ? extends V> mapper);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilCollectionAccess.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,2 @@\n+        @JEP(number = 502, title = \"Stable Values\", status = \"Preview\")\n+        STABLE_VALUES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.Collections;\n+import java.util.function.Function;\n+\n+\/**\n+ * An empty stable function with no allowed inputs\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param original     the original Function\n+ * @param <T>          the type of the input to the function\n+ * @param <R>          the type of the result of the function\n+ *\/\n+record EmptyStableFunction<T, R>(Function<? super T, ? extends R> original) implements Function<T, R> {\n+\n+    @ForceInline\n+    @Override\n+    public R apply(T value) {\n+        throw new IllegalArgumentException(\"Input not allowed: \" + value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return StableUtil.renderMappings(this, \"StableFunction\", Collections.emptyList());\n+    }\n+\n+    static <T, R> Function<T, R> of(Function<? super T, ? extends R> original) {\n+        return new EmptyStableFunction<>(original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/EmptyStableFunction.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.util.ImmutableBitSetPredicate;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntPredicate;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Optimized implementation of a stable Function with enums as keys.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param firstOrdinal the lowest ordinal used\n+ * @param delegates    a delegate array of inputs to StableValue mappings\n+ * @param original     the original Function\n+ * @param <E>          the type of the input to the function\n+ * @param <R>          the type of the result of the function\n+ *\/\n+record StableEnumFunction<E extends Enum<E>, R>(Class<E> enumType,\n+                                                int firstOrdinal,\n+                                                IntPredicate member,\n+                                                @Stable StableValueImpl<R>[] delegates,\n+                                                Function<? super E, ? extends R> original) implements Function<E, R> {\n+    @ForceInline\n+    @Override\n+    public R apply(E value) {\n+        if (!member.test(value.ordinal())) {\n+            throw new IllegalArgumentException(\"Input not allowed: \" + value);\n+        }\n+        final int index = value.ordinal() - firstOrdinal;\n+        try {\n+            return delegates[index]\n+                    .orElseSet(new Supplier<R>() {\n+                        @Override public R get() { return original.apply(value); }});\n+        } catch (ArrayIndexOutOfBoundsException ioob) {\n+            throw new IllegalArgumentException(\"Input not allowed: \" + value, ioob);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>();\n+        final E[] enumElements = enumType.getEnumConstants();\n+        int ordinal = firstOrdinal;\n+        for (int i = 0; i < delegates.length; i++, ordinal++) {\n+            if (member.test(ordinal)) {\n+                entries.add(new AbstractMap.SimpleImmutableEntry<>(enumElements[ordinal], delegates[i]));\n+            }\n+        }\n+        return StableUtil.renderMappings(this, \"StableFunction\", entries);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, E extends Enum<E>, R> Function<T, R> of(Set<? extends T> inputs,\n+                                                       Function<? super T, ? extends R> original) {\n+        final BitSet bitSet = new BitSet(inputs.size());\n+        \/\/ The input set is not empty\n+        int min = Integer.MAX_VALUE;\n+        int max = Integer.MIN_VALUE;\n+        for (T t : inputs) {\n+            final int ordinal = ((E) t).ordinal();\n+            min = Math.min(min, ordinal);\n+            max = Math.max(max, ordinal);\n+            bitSet.set(ordinal);\n+        }\n+\n+        final int size = max - min + 1;\n+        final Class<E> enumType = (Class<E>)inputs.iterator().next().getClass();\n+        final IntPredicate member = ImmutableBitSetPredicate.of(bitSet);\n+        return (Function<T, R>) new StableEnumFunction<E, R>(enumType, min, member, StableValueFactories.array(size), (Function<E, R>) original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+\/\/ Note: It would be possible to just use `LazyMap::get` with some additional logic\n+\/\/ instead of this class but explicitly providing a class like this provides better\n+\/\/ debug capability, exception handling, and may provide better performance.\n+\/**\n+ * Implementation of a stable Function.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param values   a delegate map of inputs to StableValue mappings\n+ * @param original the original Function\n+ * @param <T>      the type of the input to the function\n+ * @param <R>      the type of the result of the function\n+ *\/\n+record StableFunction<T, R>(Map<? extends T, StableValueImpl<R>> values,\n+                            Function<? super T, ? extends R> original) implements Function<T, R> {\n+    @ForceInline\n+    @Override\n+    public R apply(T value) {\n+        final StableValueImpl<R> stable = values.get(value);\n+        if (stable == null) {\n+            throw new IllegalArgumentException(\"Input not allowed: \" + value);\n+        }\n+        return stable.orElseSet(new Supplier<R>() {\n+            @Override  public R get() { return original.apply(value); }});\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return StableUtil.renderMappings(this, \"StableFunction\", values.entrySet());\n+    }\n+\n+    static <T, R> StableFunction<T, R> of(Set<? extends T> inputs,\n+                                          Function<? super T, ? extends R> original) {\n+        return new StableFunction<>(StableValueFactories.map(inputs), original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFunction.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+\/\/ Note: It would be possible to just use `LazyList::get` instead of this\n+\/\/ class but explicitly providing a class like this provides better\n+\/\/ debug capability, exception handling, and may provide better performance.\n+\/**\n+ * Implementation of a stable IntFunction.\n+ * <p>\n+ * For performance reasons (~10%), we are not delegating to a StableList but are using\n+ * the more primitive functions in StableValueUtil that are shared with StableList\/StableValueImpl.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param <R> the return type\n+ *\/\n+record StableIntFunction<R>(@Stable StableValueImpl<R>[] delegates,\n+                            IntFunction<? extends R> original) implements IntFunction<R> {\n+\n+    @ForceInline\n+    @Override\n+    public R apply(int index) {\n+        try {\n+            return delegates[index]\n+                    .orElseSet(new Supplier<R>() {\n+                        @Override public R get() { return original.apply(index); }});\n+        } catch (ArrayIndexOutOfBoundsException ioob) {\n+            throw new IllegalArgumentException(\"Input not allowed: \" + index, ioob);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return StableUtil.renderElements(this, \"StableIntFunction\", delegates);\n+    }\n+\n+    static <R> StableIntFunction<R> of(int size, IntFunction<? extends R> original) {\n+        return new StableIntFunction<>(StableValueFactories.array(size), original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableIntFunction.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Implementation of a stable supplier.\n+ * <p>\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param <T> the return type\n+ *\/\n+record StableSupplier<T>(StableValueImpl<T> delegate, Supplier<? extends T> original) implements Supplier<T> {\n+\n+    @ForceInline\n+    @Override\n+    public T get() {\n+        return delegate.orElseSet(original);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final Object t = delegate.wrappedContentAcquire();\n+        return t == this ? \"(this StableSupplier)\" : StableValueImpl.renderWrapped(t);\n+    }\n+\n+    static <T> StableSupplier<T> of(Supplier<? extends T> original) {\n+        return new StableSupplier<>(StableValueImpl.newInstance(), original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableSupplier.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+package jdk.internal.lang.stable;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+public final class StableUtil {\n+\n+    private StableUtil() {}\n+\n+    public static <R> String renderElements(Object self,\n+                                            String selfName,\n+                                            StableValueImpl<R>[] delegates) {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"[\");\n+        boolean first = true;\n+        for (int i = 0; i < delegates.length; i++) {\n+            if (first) { first = false; } else { sb.append(\", \"); }\n+            final Object value = delegates[i].wrappedContentAcquire();\n+            if (value == self) {\n+                sb.append(\"(this \").append(selfName).append(\")\");\n+            } else {\n+                sb.append(StableValueImpl.renderWrapped(value));\n+            }\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    public static <K, V> String renderMappings(Object self,\n+                                               String selfName,\n+                                               Iterable<Map.Entry<K, StableValueImpl<V>>> delegates) {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"{\");\n+        boolean first = true;\n+        for (var e : delegates) {\n+            if (first) { first = false; } else { sb.append(\", \"); }\n+            final Object value = e.getValue().wrappedContentAcquire();\n+            sb.append(e.getKey()).append('=');\n+            if (value == self) {\n+                sb.append(\"(this \").append(selfName).append(\")\");\n+            } else {\n+                sb.append(StableValueImpl.renderWrapped(value));\n+            }\n+        }\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+public final class StableValueFactories {\n+\n+    private StableValueFactories() {}\n+\n+    \/\/ Factories\n+\n+    public static <T> StableValueImpl<T> of() {\n+        return StableValueImpl.newInstance();\n+    }\n+\n+    public static <T> StableValueImpl<T> of(T value) {\n+        final StableValueImpl<T> stableValue = of();\n+        stableValue.trySet(value);\n+        return stableValue;\n+    }\n+\n+    public static <T> Supplier<T> supplier(Supplier<? extends T> original) {\n+        return StableSupplier.of(original);\n+    }\n+\n+    public static <R> IntFunction<R> intFunction(int size,\n+                                                 IntFunction<? extends R> original) {\n+        return StableIntFunction.of(size, original);\n+    }\n+\n+    public static <T, R> Function<T, R> function(Set<? extends T> inputs,\n+                                                 Function<? super T, ? extends R> original) {\n+        if (inputs.isEmpty()) {\n+            return EmptyStableFunction.of(original);\n+        }\n+        return inputs instanceof EnumSet<?>\n+                ? StableEnumFunction.of(inputs, original)\n+                : StableFunction.of(inputs, original);\n+    }\n+\n+    public static <E> List<E> list(int size, IntFunction<? extends E> mapper) {\n+        return SharedSecrets.getJavaUtilCollectionAccess().stableList(size, mapper);\n+    }\n+\n+    public static <K, V> Map<K, V> map(Set<K> keys, Function<? super K, ? extends V> mapper) {\n+        return SharedSecrets.getJavaUtilCollectionAccess().stableMap(keys, mapper);\n+    }\n+\n+    \/\/ Supporting methods\n+\n+    public static <T> StableValueImpl<T>[] array(int size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        final var stableValues = (StableValueImpl<T>[]) new StableValueImpl<?>[size];\n+        for (int i = 0; i < size; i++) {\n+            stableValues[i] = StableValueImpl.newInstance();\n+        }\n+        return stableValues;\n+    }\n+\n+    public static <K, T> Map<K, StableValueImpl<T>> map(Set<K> keys) {\n+        Objects.requireNonNull(keys);\n+        @SuppressWarnings(\"unchecked\")\n+        final var entries = (Map.Entry<K, StableValueImpl<T>>[]) new Map.Entry<?, ?>[keys.size()];\n+        int i = 0;\n+        for (K key : keys) {\n+            entries[i++] = Map.entry(key, StableValueImpl.newInstance());\n+        }\n+        return Map.ofEntries(entries);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueFactories.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * The implementation of StableValue.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param <T> type of the content\n+ *\/\n+public final class StableValueImpl<T> implements StableValue<T> {\n+\n+    static final String UNSET_LABEL = \".unset\";\n+\n+    \/\/ Unsafe allows StableValue to be used early in the boot sequence\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ Unsafe offsets for direct field access\n+    private static final long CONTENT_OFFSET =\n+            UNSAFE.objectFieldOffset(StableValueImpl.class, \"content\");\n+\n+    \/\/ Generally, fields annotated with `@Stable` are accessed by the JVM using special\n+    \/\/ memory semantics rules (see `parse.hpp` and `parse(1|2|3).cpp`).\n+    \/\/\n+    \/\/ This field is used directly and reflectively via Unsafe using explicit memory semantics.\n+    \/\/\n+    \/\/ | Value          |  Meaning      |\n+    \/\/ | -------------- |  ------------ |\n+    \/\/ | null           |  Unset        |\n+    \/\/ | nullSentinel() |  Set(null)    |\n+    \/\/ | other          |  Set(other)   |\n+    \/\/\n+    @Stable\n+    private Object content;\n+\n+    \/\/ Only allow creation via the factory `StableValueImpl::newInstance`\n+    private StableValueImpl() {}\n+\n+    @ForceInline\n+    @Override\n+    public boolean trySet(T value) {\n+        if (wrappedContentAcquire() != null) {\n+            return false;\n+        }\n+        \/\/ Prevent reentry via an orElseSet(supplier)\n+        preventReentry();\n+        \/\/ Mutual exclusion is required here as `orElseSet` might also\n+        \/\/ attempt to modify the `wrappedValue`\n+        synchronized (this) {\n+            return wrapAndSet(value);\n+        }\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setOrThrow(T value) {\n+        if (!trySet(value)) {\n+            throw new IllegalStateException(\"Cannot set the content to \" + value +\n+                    \" because the content is already set: \" + orElseThrow());\n+        }\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T orElseThrow() {\n+        final Object t = wrappedContentAcquire();\n+        if (t == null) {\n+            throw new NoSuchElementException(\"No content set\");\n+        }\n+        return unwrap(t);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T orElse(T other) {\n+        final Object t = wrappedContentAcquire();\n+        return (t == null) ? other : unwrap(t);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public boolean isSet() {\n+        return wrappedContentAcquire() != null;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T orElseSet(Supplier<? extends T> supplier) {\n+        Objects.requireNonNull(supplier);\n+        final Object t = wrappedContentAcquire();\n+        return (t == null) ? orElseSetSlowPath(supplier) : unwrap(t);\n+    }\n+\n+    @DontInline\n+    private T orElseSetSlowPath(Supplier<? extends T> supplier) {\n+        preventReentry();\n+        synchronized (this) {\n+            final Object t = content;  \/\/ Plain semantics suffice here\n+            if (t == null) {\n+                final T newValue = supplier.get();\n+                \/\/ The mutex is not reentrant so we know newValue should be returned\n+                wrapAndSet(newValue);\n+                return newValue;\n+            }\n+            return unwrap(t);\n+        }\n+    }\n+\n+    \/\/ The methods equals() and hashCode() should be based on identity (defaults from Object)\n+\n+    @Override\n+    public String toString() {\n+        final Object t = wrappedContentAcquire();\n+        return t == this\n+                ? \"(this StableValue)\"\n+                : renderWrapped(t);\n+    }\n+\n+    \/\/ Internal methods shared with other internal classes\n+\n+    @ForceInline\n+    public Object wrappedContentAcquire() {\n+        return UNSAFE.getReferenceAcquire(this, CONTENT_OFFSET);\n+    }\n+\n+    static String renderWrapped(Object t) {\n+        return (t == null) ? UNSET_LABEL : Objects.toString(unwrap(t));\n+    }\n+\n+    \/\/ Private methods\n+\n+    private void preventReentry() {\n+        if (Thread.holdsLock(this)) {\n+            throw new IllegalStateException(\"Recursing supplier detected\");\n+        }\n+    }\n+\n+    @ForceInline\n+    private boolean wrapAndSet(Object newValue) {\n+        assert Thread.holdsLock(this);\n+        \/\/ This upholds the invariant, a `@Stable` field is written to at most once\n+        \/\/ We know we hold the monitor here so plain semantic is enough\n+        if (content != null) {\n+            return false;\n+        }\n+        UNSAFE.putReferenceRelease(this, CONTENT_OFFSET, wrap(newValue));\n+        return true;\n+    }\n+\n+    \/\/ Used to indicate a holder value is `null` (see field `value` below)\n+    \/\/ A wrapper method `nullSentinel()` is used for generic type conversion.\n+    private static final Object NULL_SENTINEL = new Object();\n+\n+    \/\/ Wraps `null` values into a sentinel value\n+    @ForceInline\n+    private static Object wrap(Object t) {\n+        return (t == null) ? NULL_SENTINEL : t;\n+    }\n+\n+    \/\/ Unwraps null sentinel values into `null`\n+    @SuppressWarnings(\"unchecked\")\n+    @ForceInline\n+    private static <T> T unwrap(Object t) {\n+        return t != NULL_SENTINEL ? (T) t : null;\n+    }\n+\n+    \/\/ Factory\n+\n+    static <T> StableValueImpl<T> newInstance() {\n+        return new StableValueImpl<>();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -898,7 +898,1 @@\n-        Class<?> declaringClass = f.getDeclaringClass();\n-        if (declaringClass.isHidden()) {\n-            throw new UnsupportedOperationException(\"can't get field offset on a hidden class: \" + f);\n-        }\n-        if (declaringClass.isRecord()) {\n-            throw new UnsupportedOperationException(\"can't get field offset on a record class: \" + f);\n-        }\n+        ensureNotTrusted(f);\n@@ -938,7 +932,1 @@\n-        Class<?> declaringClass = f.getDeclaringClass();\n-        if (declaringClass.isHidden()) {\n-            throw new UnsupportedOperationException(\"can't get field offset on a hidden class: \" + f);\n-        }\n-        if (declaringClass.isRecord()) {\n-            throw new UnsupportedOperationException(\"can't get field offset on a record class: \" + f);\n-        }\n+        ensureNotTrusted(f);\n@@ -970,7 +958,1 @@\n-        Class<?> declaringClass = f.getDeclaringClass();\n-        if (declaringClass.isHidden()) {\n-            throw new UnsupportedOperationException(\"can't get base address on a hidden class: \" + f);\n-        }\n-        if (declaringClass.isRecord()) {\n-            throw new UnsupportedOperationException(\"can't get base address on a record class: \" + f);\n-        }\n+        ensureNotTrusted(f);\n@@ -1000,0 +982,21 @@\n+    @ForceInline\n+    private static void ensureNotTrusted(Field f) {\n+        Class<?> declaringClass = f.getDeclaringClass();\n+        if (declaringClass.isHidden()) {\n+            throw new UnsupportedOperationException(\"can't get base address on a hidden class: \" + f);\n+        }\n+        if (declaringClass.isRecord()) {\n+            throw new UnsupportedOperationException(\"can't get base address on a record class: \" + f);\n+        }\n+        Class<?> fieldType = f.getType();\n+        \/\/ Todo: Change to \"java.lang.StableValue.class.isAssignableFrom(fieldType)\" etc. after StableValue exits preview\n+        if (fieldType.getName().equals(\"java.lang.StableValue\") || (fieldType.isArray() && deepComponent(fieldType).getName().equals(\"java.lang.StableValue\"))) {\n+            throw new UnsupportedOperationException(\"can't get field offset for a field of type \" + fieldType.getName() + \": \" + f);\n+        }\n+    }\n+\n+    @ForceInline\n+    private static Class<?> deepComponent(Class<?> clazz) {\n+        return clazz.isArray() ? deepComponent(clazz.getComponentType()) : clazz;\n+    }\n+\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableFunctionTest methods\n+ * @compile --enable-preview -source ${jdk.version} StableFunctionTest.java\n+ * @run junit\/othervm --enable-preview StableFunctionTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.EnumSet;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableFunctionTest {\n+\n+    enum Value {\n+        \/\/ Zero is here so that we have enums with ordinals before the first one\n+        \/\/ actually used in input sets (i.e. ZERO is not in the input set)\n+        ZERO(0),\n+        ILLEGAL_BEFORE(-1),\n+        \/\/ Valid values\n+        THIRTEEN(13),\n+        ILLEGAL_BETWEEN(-2),\n+        FORTY_TWO(42),\n+        \/\/ Illegal values (not in the input set)\n+        ILLEGAL_AFTER(-3);\n+\n+        final int intValue;\n+\n+        Value(int intValue) {\n+            this.intValue = intValue;\n+        }\n+\n+        int asInt() {\n+            return intValue;\n+        }\n+\n+    }\n+\n+    private static final Function<Value, Integer> MAPPER = Value::asInt;\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void factoryInvariants(Set<Value> inputs) {\n+        assertThrows(NullPointerException.class, () -> StableValue.function(null, MAPPER));\n+        assertThrows(NullPointerException.class, () -> StableValue.function(inputs, null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void basic(Set<Value> inputs) {\n+        basic(inputs, MAPPER);\n+        basic(inputs, _ -> null);\n+    }\n+\n+    void basic(Set<Value> inputs, Function<Value, Integer> mapper) {\n+        StableTestUtil.CountingFunction<Value, Integer> cif = new StableTestUtil.CountingFunction<>(mapper);\n+        var cached = StableValue.function(inputs, cif);\n+        assertEquals(mapper.apply(Value.FORTY_TWO), cached.apply(Value.FORTY_TWO));\n+        assertEquals(1, cif.cnt());\n+        assertEquals(mapper.apply(Value.FORTY_TWO), cached.apply(Value.FORTY_TWO));\n+        assertEquals(1, cif.cnt());\n+        assertTrue(cached.toString().startsWith(\"{\"), cached.toString());\n+        \/\/ Key order is unspecified\n+        assertTrue(cached.toString().contains(Value.THIRTEEN + \"=.unset\"));\n+        assertTrue(cached.toString().contains(Value.FORTY_TWO + \"=\" + mapper.apply(Value.FORTY_TWO)), cached.toString());\n+        assertTrue(cached.toString().endsWith(\"}\"));\n+        \/\/ One between the values\n+        assertEquals(1L, cached.toString().chars().filter(ch -> ch == ',').count(), cached.toString());\n+        var x0 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_BEFORE));\n+        assertTrue(x0.getMessage().contains(\"ILLEGAL\"));\n+        var x1 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_BETWEEN));\n+        assertTrue(x1.getMessage().contains(\"ILLEGAL\"));\n+        var x2 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_AFTER));\n+        assertTrue(x2.getMessage().contains(\"ILLEGAL\"));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"emptySets\")\n+    void empty(Set<Value> inputs) {\n+        Function<Value, Integer> f0 = StableValue.function(inputs, Value::asInt);\n+        Function<Value, Integer> f1 = StableValue.function(inputs, Value::asInt);\n+        assertTrue(f0.toString().contains(\"{}\"));\n+        assertThrows(IllegalArgumentException.class, () -> f0.apply(null));\n+        assertNotEquals(f0, f1);\n+        assertNotEquals(null, f0);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void exception(Set<Value> inputs) {\n+        StableTestUtil.CountingFunction<Value, Integer> cif = new StableTestUtil.CountingFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var cached = StableValue.function(inputs, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(Value.FORTY_TWO));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(Value.FORTY_TWO));\n+        assertEquals(2, cif.cnt());\n+        assertTrue(cached.toString().startsWith(\"{\"));\n+        \/\/ Key order is unspecified\n+        assertTrue(cached.toString().contains(Value.THIRTEEN + \"=.unset\"));\n+        assertTrue(cached.toString().contains(Value.FORTY_TWO + \"=.unset\"), cached.toString());\n+        assertTrue(cached.toString().endsWith(\"}\"));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void circular(Set<Value> inputs) {\n+        final AtomicReference<Function<?, ?>> ref = new AtomicReference<>();\n+        Function<Value, Function<?, ?>> cached = StableValue.function(inputs, _ -> ref.get());\n+        ref.set(cached);\n+        cached.apply(Value.FORTY_TWO);\n+        String toString = cached.toString();\n+        assertTrue(toString.contains(\"(this StableFunction)\"), toString);\n+        assertDoesNotThrow(cached::hashCode);\n+        assertDoesNotThrow((() -> cached.equals(cached)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void equality(Set<Value> inputs) {\n+        Function<Value, Integer> mapper = Value::asInt;\n+        Function<Value, Integer> f0 = StableValue.function(inputs, mapper);\n+        Function<Value, Integer> f1 = StableValue.function(inputs, mapper);\n+        \/\/ No function is equal to another function\n+        assertNotEquals(f0, f1);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void hashCodeStable(Set<Value> inputs) {\n+        Function<Value, Integer> f0 = StableValue.function(inputs, Value::asInt);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        if (!inputs.isEmpty()) {\n+            f0.apply(Value.FORTY_TWO);\n+            assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        }\n+    }\n+\n+    @Test\n+    void usesOptimizedVersion() {\n+        Function<Value, Integer> enumFunction = StableValue.function(EnumSet.of(Value.FORTY_TWO), Value::asInt);\n+        assertEquals(\"jdk.internal.lang.stable.StableEnumFunction\", enumFunction.getClass().getName());\n+        Function<Value, Integer> emptyFunction = StableValue.function(Set.of(), Value::asInt);\n+        assertEquals(\"jdk.internal.lang.stable.EmptyStableFunction\", emptyFunction.getClass().getName());\n+    }\n+\n+    private static Stream<Set<Value>> nonEmptySets() {\n+        return Stream.of(\n+                Set.of(Value.FORTY_TWO, Value.THIRTEEN),\n+                linkedHashSet(Value.THIRTEEN, Value.FORTY_TWO),\n+                treeSet(Value.FORTY_TWO, Value.THIRTEEN),\n+                EnumSet.of(Value.FORTY_TWO, Value.THIRTEEN)\n+        );\n+    }\n+\n+    private static Stream<Set<Value>> emptySets() {\n+        return Stream.of(\n+                Set.of(),\n+                linkedHashSet(),\n+                treeSet(),\n+                EnumSet.noneOf(Value.class)\n+        );\n+    }\n+\n+    private static Stream<Set<Value>> allSets() {\n+        return Stream.concat(\n+                nonEmptySets(),\n+                emptySets()\n+        );\n+    }\n+\n+    static Set<Value> treeSet(Value... values) {\n+        return populate(new TreeSet<>(Comparator.comparingInt(Value::asInt).reversed()),values);\n+    }\n+\n+    static Set<Value> linkedHashSet(Value... values) {\n+        return populate(new LinkedHashSet<>(), values);\n+    }\n+\n+    static Set<Value> populate(Set<Value> set, Value... values) {\n+        set.addAll(Arrays.asList(values));\n+        return set;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFunctionTest.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableIntFunctionTest methods\n+ * @compile --enable-preview -source ${jdk.version} StableIntFunctionTest.java\n+ * @run junit\/othervm --enable-preview StableIntFunctionTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.IntFunction;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableIntFunctionTest {\n+\n+    private static final int SIZE = 2;\n+    private static final IntFunction<Integer> MAPPER = i -> i;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(IllegalArgumentException.class, () -> StableValue.intFunction(-1, MAPPER));\n+        assertThrows(NullPointerException.class, () -> StableValue.intFunction(SIZE, null));\n+    }\n+\n+    @Test\n+    void basic() {\n+        basic(MAPPER);\n+        basic(i -> null);\n+    }\n+\n+    void basic(IntFunction<Integer> mapper) {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(mapper);\n+        var cached = StableValue.intFunction(SIZE, cif);\n+        assertEquals(\"[.unset, .unset]\", cached.toString());\n+        assertEquals(mapper.apply(1), cached.apply(1));\n+        assertEquals(1, cif.cnt());\n+        assertEquals(mapper.apply(1), cached.apply(1));\n+        assertEquals(1, cif.cnt());\n+        assertEquals(\"[.unset, \" + mapper.apply(1) + \"]\", cached.toString());\n+        assertThrows(IllegalArgumentException.class, () -> cached.apply(SIZE));\n+        assertThrows(IllegalArgumentException.class, () -> cached.apply(-1));\n+        assertThrows(IllegalArgumentException.class, () -> cached.apply(1_000_000));\n+    }\n+\n+    @Test\n+    void exception() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var cached = StableValue.intFunction(SIZE, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(1));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(1));\n+        assertEquals(2, cif.cnt());\n+        assertEquals(\"[.unset, .unset]\", cached.toString());\n+    }\n+\n+    @Test\n+    void circular() {\n+        final AtomicReference<IntFunction<?>> ref = new AtomicReference<>();\n+        IntFunction<IntFunction<?>> cached = StableValue.intFunction(SIZE, _ -> ref.get());\n+        ref.set(cached);\n+        cached.apply(0);\n+        String toString = cached.toString();\n+        assertEquals(\"[(this StableIntFunction), .unset]\", toString);\n+        assertDoesNotThrow(cached::hashCode);\n+        assertDoesNotThrow((() -> cached.equals(cached)));\n+    }\n+\n+    @Test\n+    void equality() {\n+        IntFunction<Integer> f0 = StableValue.intFunction(8, MAPPER);\n+        IntFunction<Integer> f1 = StableValue.intFunction(8, MAPPER);\n+        \/\/ No function is equal to another function\n+        assertNotEquals(f0, f1);\n+    }\n+\n+    @Test\n+    void hashCodeStable() {\n+        IntFunction<Integer> f0 = StableValue.intFunction(8, MAPPER);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        f0.apply(4);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableIntFunctionTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for LazyList methods\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @compile --enable-preview -source ${jdk.version} StableListTest.java\n+ * @run junit\/othervm --enable-preview StableListTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableValueImpl;\n+import jdk.internal.lang.stable.StableValueFactories;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.RandomAccess;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableListTest {\n+\n+    private static final int ZERO = 0;\n+    private static final int INDEX = 7;\n+    private static final int SIZE = 31;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> StableValue.list(SIZE, null));\n+        assertThrows(IllegalArgumentException.class, () -> StableValue.list(-1, IDENTITY));\n+    }\n+\n+    @Test\n+    void isEmpty() {\n+        assertFalse(newList().isEmpty());\n+        assertTrue(newEmptyList().isEmpty());\n+    }\n+\n+    @Test\n+    void size() {\n+        assertEquals(SIZE, newList().size());\n+        assertEquals(ZERO, newEmptyList().size());\n+    }\n+\n+    @Test\n+    void get() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(IDENTITY);\n+        var lazy = StableValue.list(SIZE, cif);\n+        for (int i = 0; i < SIZE; i++) {\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(i + 1, cif.cnt());\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(i + 1, cif.cnt());\n+        }\n+    }\n+\n+    @Test\n+    void getException() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var lazy = StableValue.list(SIZE, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(INDEX));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(INDEX));\n+        assertEquals(2, cif.cnt());\n+    }\n+\n+    @Test\n+    void toArray() {\n+        assertArrayEquals(new Object[ZERO], newEmptyList().toArray());\n+        assertArrayEquals(newRegularList().toArray(), newList().toArray());\n+    }\n+\n+    @Test\n+    void toArrayWithArrayLarger() {\n+        Integer[] arr = new Integer[SIZE];\n+        arr[INDEX] = 1;\n+        assertSame(arr, StableValue.list(INDEX, IDENTITY).toArray(arr));\n+        assertNull(arr[INDEX]);\n+    }\n+\n+    @Test\n+    void toArrayWithArraySmaller() {\n+        Integer[] arr = new Integer[INDEX];\n+        Integer[] actual = newList().toArray(arr);\n+        assertNotSame(arr, actual);\n+        Integer[] expected = newRegularList().toArray(new Integer[0]);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void toArrayWithGenerator() {\n+        Integer[] expected = newRegularList().toArray(Integer[]::new);\n+        Integer[] actual = newList().toArray(Integer[]::new);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void firstIndex() {\n+        var lazy = newList();\n+        for (int i = INDEX; i < SIZE; i++) {\n+            assertEquals(i, lazy.indexOf(i));\n+        }\n+        assertEquals(-1, lazy.indexOf(SIZE + 1));\n+    }\n+\n+    @Test\n+    void lastIndex() {\n+        var lazy = newList();\n+        for (int i = INDEX; i < SIZE; i++) {\n+            assertEquals(i, lazy.lastIndexOf(i));\n+        }\n+        assertEquals(-1, lazy.lastIndexOf(SIZE + 1));\n+    }\n+\n+    @Test\n+    void toStringTest() {\n+        assertEquals(\"[]\", newEmptyList().toString());\n+        var list = StableValue.list(2, IDENTITY);\n+        assertEquals(\"[.unset, .unset]\", list.toString());\n+        list.get(0);\n+        assertEquals(\"[0, .unset]\", list.toString());\n+        list.get(1);\n+        assertEquals(\"[0, 1]\", list.toString());\n+    }\n+\n+    @Test\n+    void hashCodeTest() {\n+        assertEquals(List.of().hashCode(), newEmptyList().hashCode());\n+        assertEquals(newRegularList().hashCode(), newList().hashCode());\n+    }\n+\n+    @Test\n+    void equalsTest() {\n+        assertTrue(newEmptyList().equals(List.of()));\n+        assertTrue(List.of().equals(newEmptyList()));\n+        assertTrue(newList().equals(newRegularList()));\n+        assertTrue(newRegularList().equals(newList()));\n+        assertFalse(newList().equals(\"A\"));\n+    }\n+\n+    @Test\n+    void iteratorTotal() {\n+        var iterator = newList().iterator();\n+        for (int i = 0; i < SIZE; i++) {\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertEquals(i, iterator.next());\n+        }\n+        assertFalse(iterator.hasNext());\n+        assertThrows(NoSuchElementException.class, iterator::next);\n+        AtomicInteger cnt = new AtomicInteger();\n+        iterator.forEachRemaining(_ -> cnt.incrementAndGet());\n+        assertEquals(0, cnt.get());\n+    }\n+\n+    @Test\n+    void iteratorPartial() {\n+        var iterator = newList().iterator();\n+        for (int i = 0; i < INDEX; i++) {\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertEquals(i, iterator.next());\n+        }\n+        assertTrue(iterator.hasNext());\n+        AtomicInteger cnt = new AtomicInteger();\n+        iterator.forEachRemaining(_ -> cnt.incrementAndGet());\n+        assertEquals(SIZE - INDEX, cnt.get());\n+        assertFalse(iterator.hasNext());\n+        assertThrows(NoSuchElementException.class, iterator::next);\n+    }\n+\n+    @Test\n+    void subList() {\n+        var lazy = newList();\n+        var lazySubList = lazy.subList(1, SIZE);\n+        var regularList = newRegularList();\n+        var regularSubList = regularList.subList(1, SIZE);\n+        assertEquals(regularSubList, lazySubList);\n+    }\n+\n+    @Test\n+    void recursiveCall() {\n+        AtomicReference<IntFunction<Integer>> ref = new AtomicReference<>();\n+        var lazy = StableValue.list(SIZE, i -> ref.get().apply(i));\n+        ref.set(lazy::get);\n+        assertThrows(IllegalStateException.class, () -> lazy.get(INDEX));\n+    }\n+\n+    \/\/ Immutability\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void unsupported(Operation operation) {\n+        assertThrowsForOperation(UnsupportedOperationException.class, operation);\n+    }\n+\n+    \/\/ Method parameter invariant checking\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullAverseOperations\")\n+    void nullAverse(Operation operation) {\n+        assertThrowsForOperation(NullPointerException.class, operation);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"outOfBoundsOperations\")\n+    void outOfBounds(Operation operation) {\n+        assertThrowsForOperation(IndexOutOfBoundsException.class, operation);\n+    }\n+\n+    static <T extends Throwable> void assertThrowsForOperation(Class<T> expectedType, Operation operation) {\n+        var lazy = newList();\n+        assertThrows(expectedType, () -> operation.accept(lazy));\n+        var sub = lazy.subList(1, SIZE \/ 2);\n+        assertThrows(expectedType, () -> operation.accept(sub));\n+        var subSub = sub.subList(1, sub.size() \/ 2);\n+        assertThrows(expectedType, () -> operation.accept(subSub));\n+    }\n+\n+    \/\/ Implementing interfaces\n+\n+    @Test\n+    void serializable() {\n+        serializable(newList());\n+        serializable(newEmptyList());\n+    }\n+\n+    void serializable(List<Integer> list) {\n+        assertFalse(list instanceof Serializable);\n+        if (list.size()>INDEX) {\n+            assertFalse(newList().subList(1, INDEX) instanceof Serializable);\n+        }\n+        assertFalse(list.iterator() instanceof Serializable);\n+        assertFalse(list.reversed() instanceof Serializable);\n+        assertFalse(list.spliterator() instanceof Serializable);\n+    }\n+\n+    @Test\n+    void randomAccess() {\n+        assertInstanceOf(RandomAccess.class, newList());\n+        assertInstanceOf(RandomAccess.class, newEmptyList());\n+        assertInstanceOf(RandomAccess.class, newList().subList(1, INDEX));\n+    }\n+\n+    @Test\n+    void distinct() {\n+        StableValueImpl<Integer>[] array = StableValueFactories.array(SIZE);\n+        assertEquals(SIZE, array.length);\n+        \/\/ Check, every StableValue is distinct\n+        Map<StableValue<Integer>, Boolean> idMap = new IdentityHashMap<>();\n+        for (var e: array) {\n+            idMap.put(e, true);\n+        }\n+        assertEquals(SIZE, idMap.size());\n+    }\n+\n+    \/\/ Support constructs\n+\n+    record Operation(String name,\n+                     Consumer<List<Integer>> consumer) implements Consumer<List<Integer>> {\n+        @Override public void   accept(List<Integer> list) { consumer.accept(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    static Stream<Operation> nullAverseOperations() {\n+        return Stream.of(\n+                new Operation(\"forEach\",     l -> l.forEach(null)),\n+                new Operation(\"containsAll\", l -> l.containsAll(null)),\n+                new Operation(\"toArray\",     l -> l.toArray((Integer[]) null)),\n+                new Operation(\"toArray\",     l -> l.toArray((IntFunction<Integer[]>) null))\n+        );\n+    }\n+\n+    static Stream<Operation> outOfBoundsOperations() {\n+        return Stream.of(\n+                new Operation(\"get(-1)\",        l -> l.get(-1)),\n+                new Operation(\"get(size)\",      l -> l.get(l.size())),\n+                new Operation(\"sublist(-1,)\",   l -> l.subList(-1, INDEX)),\n+                new Operation(\"sublist(,size)\", l -> l.subList(0, l.size() + 1)),\n+                new Operation(\"listIter(-1)\",   l -> l.listIterator(-1)),\n+                new Operation(\"listIter(size)\", l -> l.listIterator(l.size() + 1))\n+        );\n+    }\n+\n+    static Stream<Operation> unsupportedOperations() {\n+        final Set<Integer> SET = Set.of(0, 1);\n+        return Stream.of(\n+                new Operation(\"add(0)\",            l -> l.add(0)),\n+                new Operation(\"add(0, 1)\",         l -> l.add(0, 1)),\n+                new Operation(\"addAll(col)\",       l -> l.addAll(SET)),\n+                new Operation(\"addAll(1, coll)\",   l -> l.addAll(1, SET)),\n+                new Operation(\"addFirst(0)\",       l -> l.addFirst(0)),\n+                new Operation(\"addLast(0)\",        l -> l.addLast(0)),\n+                new Operation(\"clear\",             List::clear),\n+                new Operation(\"remove(Obj)\",       l -> l.remove((Object)1)),\n+                new Operation(\"remove(1)\",         l -> l.remove(1)),\n+                new Operation(\"removeAll\",         l -> l.removeAll(SET)),\n+                new Operation(\"removeFirst\",       List::removeFirst),\n+                new Operation(\"removeLast\",        List::removeLast),\n+                new Operation(\"removeIf\",          l -> l.removeIf(i -> i % 2 == 0)),\n+                new Operation(\"replaceAll\",        l -> l.replaceAll(i -> i + 1)),\n+                new Operation(\"sort\",              l -> l.sort(Comparator.naturalOrder())),\n+                new Operation(\"iterator().remove\", l -> l.iterator().remove()),\n+                new Operation(\"listIter().remove\", l -> l.listIterator().remove()),\n+                new Operation(\"listIter().add\",    l -> l.listIterator().add(1)),\n+                new Operation(\"listIter().set\",    l -> l.listIterator().set(1))\n+        );\n+    }\n+\n+    static List<Integer> newList() {\n+        return StableValue.list(SIZE, IDENTITY);\n+    }\n+\n+    static List<Integer> newEmptyList() {\n+        return StableValue.list(ZERO, IDENTITY);\n+    }\n+\n+    static List<Integer> newRegularList() {\n+        return IntStream.range(0, SIZE).boxed().toList();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for LazyMap methods\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @compile --enable-preview -source ${jdk.version} StableMapTest.java\n+ * @run junit\/othervm --enable-preview StableMapTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableValueImpl;\n+import jdk.internal.lang.stable.StableValueFactories;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.util.AbstractMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableMapTest {\n+\n+    private static final int NOT_PRESENT = 147;\n+    private static final int KEY = 7;\n+    private static final Set<Integer> KEYS = Set.of(0, KEY, 13);\n+    private static final Set<Integer> EMPTY = Set.of();\n+    private static final Function<Integer, Integer> IDENTITY = Function.identity();\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> StableValue.map(KEYS, null));\n+        assertThrows(NullPointerException.class, () -> StableValue.map(null, IDENTITY));\n+    }\n+\n+    @Test\n+    void isEmpty() {\n+        assertFalse(newMap().isEmpty());\n+        assertTrue(newEmptyMap().isEmpty());\n+    }\n+\n+    @Test\n+    void size() {\n+        assertEquals(KEYS.size(), newMap().size());\n+        assertEquals(EMPTY.size(), newEmptyMap().size());\n+    }\n+\n+    @Test\n+    void get() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cf = new StableTestUtil.CountingFunction<>(IDENTITY);\n+        var lazy = StableValue.map(KEYS, cf);\n+        int cnt = 1;\n+        for (int i : KEYS) {\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(cnt, cf.cnt());\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(cnt++, cf.cnt());\n+        }\n+        assertNull(lazy.get(NOT_PRESENT));\n+    }\n+\n+    @Test\n+    void getException() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cf = new StableTestUtil.CountingFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var lazy = StableValue.map(KEYS, cf);\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(KEY));\n+        assertEquals(1, cf.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(KEY));\n+        assertEquals(2, cf.cnt());\n+    }\n+\n+    @Test\n+    void containsKey() {\n+        var lazy = newMap();\n+        for (int i : KEYS) {\n+            assertTrue(lazy.containsKey(i));\n+        }\n+        assertFalse(lazy.containsKey(NOT_PRESENT));\n+    }\n+\n+    @Test\n+    void containsValue() {\n+        var lazy = newMap();\n+        for (int i : KEYS) {\n+            assertTrue(lazy.containsValue(i));\n+        }\n+        assertFalse(lazy.containsValue(NOT_PRESENT));\n+    }\n+\n+    @Test\n+    void forEach() {\n+        var lazy = newMap();\n+        Set<Map.Entry<Integer, Integer>> expected = KEYS.stream()\n+                .map(i -> new AbstractMap.SimpleImmutableEntry<>(i , i))\n+                .collect(Collectors.toSet());\n+        Set<Map.Entry<Integer, Integer>> actual = new HashSet<>();\n+        lazy.forEach((k, v) -> actual.add(new AbstractMap.SimpleImmutableEntry<>(k , v)));\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void toStringTest() {\n+        assertEquals(\"{}\", newEmptyMap().toString());\n+        var map = StableValue.map(Set.of(KEY), IDENTITY);\n+        assertEquals(\"{\" + KEY + \"=.unset}\", map.toString());\n+        map.get(KEY);\n+        assertEquals(\"{\" + KEY + \"=\" + KEY + \"}\", map.toString());\n+        String actual = newMap().toString();\n+        assertTrue(actual.startsWith(\"{\"));\n+        for (int key:KEYS) {\n+            assertTrue(actual.contains(key + \"=.unset\"));\n+        }\n+        assertTrue(actual.endsWith(\"}\"));\n+    }\n+\n+    @Test\n+    void hashCodeTest() {\n+        assertEquals(Map.of().hashCode(), newEmptyMap().hashCode());\n+        assertEquals(newRegularMap().hashCode(), newMap().hashCode());\n+    }\n+\n+    @Test\n+    void equalsTest() {\n+        assertTrue(newEmptyMap().equals(Map.of()));\n+        assertTrue(Map.of().equals(newEmptyMap()));\n+        assertTrue(newMap().equals(newRegularMap()));\n+        assertTrue(newRegularMap().equals(newMap()));\n+        assertFalse(newMap().equals(\"A\"));\n+    }\n+\n+    @Test\n+    void entrySet() {\n+        var regular = newRegularMap().entrySet();\n+        var actual = newMap().entrySet();\n+        assertTrue(regular.equals(actual));\n+        assertTrue(actual.equals(regular));\n+        assertTrue(regular.equals(actual));\n+    }\n+\n+    @Test\n+    void iteratorNext() {\n+        Set<Integer> encountered = new HashSet<>();\n+        var iterator = newMap().entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            var entry = iterator.next();\n+            assertEquals(entry.getKey(), entry.getValue());\n+            encountered.add(entry.getValue());\n+        }\n+        assertEquals(KEYS, encountered);\n+    }\n+\n+    @Test\n+    void iteratorForEachRemaining() {\n+        Set<Integer> encountered = new HashSet<>();\n+        var iterator = newMap().entrySet().iterator();\n+        var entry = iterator.next();\n+        assertEquals(entry.getKey(), entry.getValue());\n+        encountered.add(entry.getValue());\n+        iterator.forEachRemaining(e -> {\n+            assertEquals(e.getKey(), e.getValue());\n+            encountered.add(e.getValue());\n+        });\n+        assertEquals(KEYS, encountered);\n+    }\n+\n+    \/\/ Immutability\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void unsupported(Operation operation) {\n+        assertThrowsForOperation(UnsupportedOperationException.class, operation);\n+    }\n+\n+    \/\/ Method parameter invariant checking\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullAverseOperations\")\n+    void nullAverse(Operation operation) {\n+        assertThrowsForOperation(NullPointerException.class, operation);\n+    }\n+\n+    static <T extends Throwable> void assertThrowsForOperation(Class<T> expectedType, Operation operation) {\n+        var lazy = newMap();\n+        assertThrows(expectedType, () -> operation.accept(lazy));\n+    }\n+\n+    \/\/ Implementing interfaces\n+\n+    @Test\n+    void serializable() {\n+        serializable(newMap());\n+        serializable(newEmptyMap());\n+    }\n+\n+    void serializable(Map<Integer, Integer> map) {\n+        assertFalse(map instanceof Serializable);\n+        assertFalse(map.entrySet() instanceof Serializable);\n+        assertFalse(map.keySet() instanceof Serializable);\n+        assertFalse(map.values() instanceof Serializable);\n+    }\n+\n+    @Test\n+    void distinct() {\n+        Map<Integer, StableValueImpl<Integer>> map = StableValueFactories.map(Set.of(1, 2, 3));\n+        assertEquals(3, map.size());\n+        \/\/ Check, every StableValue is distinct\n+        Map<StableValue<Integer>, Boolean> idMap = new IdentityHashMap<>();\n+        map.forEach((k, v) -> idMap.put(v, true));\n+        assertEquals(3, idMap.size());\n+    }\n+\n+    \/\/ Support constructs\n+\n+    record Operation(String name,\n+                     Consumer<Map<Integer, Integer>> consumer) implements Consumer<Map<Integer, Integer>> {\n+        @java.lang.Override\n+        public void   accept(Map<Integer, Integer> map) { consumer.accept(map); }\n+        @java.lang.Override\n+        public String toString() { return name; }\n+    }\n+\n+    static Stream<Operation> nullAverseOperations() {\n+        return Stream.of(\n+                new Operation(\"forEach\",     m -> m.forEach(null))\n+        );\n+    }\n+\n+    static Stream<Operation> unsupportedOperations() {\n+        return Stream.of(\n+                new Operation(\"clear\",             Map::clear),\n+                new Operation(\"compute\",           m -> m.compute(KEY, (_, _) -> 1)),\n+                new Operation(\"computeIfAbsent\",   m -> m.computeIfAbsent(KEY, _ -> 1)),\n+                new Operation(\"computeIfPresent\",  m -> m.computeIfPresent(KEY, (_, _) -> 1)),\n+                new Operation(\"merge\",             m -> m.merge(KEY, KEY, (a, _) -> a)),\n+                new Operation(\"put\",               m -> m.put(0, 0)),\n+                new Operation(\"putAll\",            m -> m.putAll(Map.of())),\n+                new Operation(\"remove1\",           m -> m.remove(KEY)),\n+                new Operation(\"remove2\",           m -> m.remove(KEY, KEY)),\n+                new Operation(\"replace2\",          m -> m.replace(KEY, 1)),\n+                new Operation(\"replace3\",          m -> m.replace(KEY, KEY, 1)),\n+                new Operation(\"replaceAll\",        m -> m.replaceAll((a, _) -> a))\n+        );\n+    }\n+\n+    static Map<Integer, Integer> newMap() {\n+        return StableValue.map(KEYS, IDENTITY);\n+    }\n+\n+    static Map<Integer, Integer> newEmptyMap() {\n+        return StableValue.map(EMPTY, IDENTITY);\n+    }\n+\n+    static Map<Integer, Integer> newRegularMap() {\n+        return KEYS.stream().collect(Collectors.toMap(IDENTITY, IDENTITY));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableMapTest.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableSupplierTest methods\n+ * @compile --enable-preview -source ${jdk.version} StableSupplierTest.java\n+ * @run junit\/othervm --enable-preview StableSupplierTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableSupplierTest {\n+\n+    private static final Supplier<Integer> SUPPLIER = () -> 42;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> StableValue.supplier(null));\n+    }\n+\n+    @Test\n+    void basic() {\n+        basic(SUPPLIER);\n+        basic(() -> null);\n+    }\n+\n+    void basic(Supplier<Integer> supplier) {\n+        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(supplier);\n+        var cached = StableValue.supplier(cs);\n+        assertEquals(\".unset\", cached.toString());\n+        assertEquals(supplier.get(), cached.get());\n+        assertEquals(1, cs.cnt());\n+        assertEquals(supplier.get(), cached.get());\n+        assertEquals(1, cs.cnt());\n+        assertEquals(Objects.toString(supplier.get()), cached.toString());\n+    }\n+\n+    @Test\n+    void exception() {\n+        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(() -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var cached = StableValue.supplier(cs);\n+        assertThrows(UnsupportedOperationException.class, cached::get);\n+        assertEquals(1, cs.cnt());\n+        assertThrows(UnsupportedOperationException.class, cached::get);\n+        assertEquals(2, cs.cnt());\n+        assertEquals(\".unset\", cached.toString());\n+    }\n+\n+    @Test\n+    void circular() {\n+        final AtomicReference<Supplier<?>> ref = new AtomicReference<>();\n+        Supplier<Supplier<?>> cached = StableValue.supplier(ref::get);\n+        ref.set(cached);\n+        cached.get();\n+        String toString = cached.toString();\n+        assertTrue(toString.startsWith(\"(this StableSupplier)\"));\n+        assertDoesNotThrow(cached::hashCode);\n+    }\n+\n+    @Test\n+    void equality() {\n+        Supplier<Integer> f0 = StableValue.supplier(SUPPLIER);\n+        Supplier<Integer> f1 = StableValue.supplier(SUPPLIER);\n+        \/\/ No function is equal to another function\n+        assertNotEquals(f0, f1);\n+    }\n+\n+    @Test\n+    void hashCodeStable() {\n+        Supplier<Integer> f0 = StableValue.supplier(SUPPLIER);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        f0.get();\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableSupplierTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+final class StableTestUtil {\n+\n+    private StableTestUtil() {}\n+\n+    public static final class CountingSupplier<T>\n+            extends AbstractCounting<Supplier<T>>\n+            implements Supplier<T> {\n+\n+        public CountingSupplier(Supplier<T> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public T get() {\n+            incrementCounter();\n+            return delegate.get();\n+        }\n+\n+    }\n+\n+    public static final class CountingIntFunction<R>\n+            extends AbstractCounting<IntFunction<R>>\n+            implements IntFunction<R> {\n+\n+        public CountingIntFunction(IntFunction<R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(int value) {\n+            incrementCounter();\n+            return delegate.apply(value);\n+        }\n+\n+    }\n+\n+    public static final class CountingFunction<T, R>\n+            extends AbstractCounting<Function<T, R>>\n+            implements Function<T, R> {\n+\n+        public CountingFunction(Function<T, R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(T t) {\n+            incrementCounter();\n+            return delegate.apply(t);\n+        }\n+\n+    }\n+\n+    public static final class CountingBiFunction<T, U, R>\n+            extends AbstractCounting<BiFunction<T, U, R>>\n+            implements BiFunction<T, U, R> {\n+\n+        public CountingBiFunction(BiFunction<T, U, R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(T t, U u) {\n+            incrementCounter();\n+            return delegate.apply(t, u);\n+        }\n+    }\n+\n+    abstract static class AbstractCounting<D> {\n+\n+        private final AtomicInteger cnt = new AtomicInteger();\n+        protected final D delegate;\n+\n+        protected AbstractCounting(D delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        protected final void incrementCounter() {\n+            cnt.incrementAndGet();\n+        }\n+\n+        public final int cnt() {\n+            return cnt.get();\n+        }\n+\n+        @Override\n+        public final String toString() {\n+            return cnt.toString();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableTestUtil.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableValueFactoriesTest implementations\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @compile --enable-preview -source ${jdk.version} StableValueFactoriesTest.java\n+ * @run junit\/othervm --enable-preview StableValueFactoriesTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableValueFactories;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableValueFactoriesTest {\n+\n+    @Test\n+    void array() {\n+        assertThrows(IllegalArgumentException.class, () -> StableValueFactories.array(-1));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueFactoriesTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableValue implementations\n+ * @compile --enable-preview -source ${jdk.version} StableValueTest.java\n+ * @run junit\/othervm --enable-preview StableValueTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.BitSet;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.function.BiPredicate;\n+import java.util.function.IntFunction;\n+import java.util.stream.IntStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+final class StableValueTest {\n+\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 13;\n+\n+    @Test\n+    void trySet() {\n+        trySet(VALUE);\n+        trySet(null);\n+    }\n+\n+    @Test\n+    void preSet() {\n+        StableValue<Integer> stable = StableValue.of(VALUE);\n+        assertTrue(stable.isSet());\n+        assertEquals(VALUE, stable.orElseThrow());\n+        assertEquals(VALUE, stable.orElse(VALUE2));\n+        assertEquals(VALUE, stable.orElseSet(() -> VALUE2));\n+        assertFalse(stable.trySet(VALUE2));\n+        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(VALUE2));\n+        assertEquals(\n+                \"Cannot set the content to \" + VALUE2 + \" because the content is already set: \" + VALUE,\n+                e.getMessage());\n+    }\n+\n+    void trySet(Integer initial) {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertTrue(stable.trySet(initial));\n+        assertFalse(stable.trySet(null));\n+        assertFalse(stable.trySet(VALUE));\n+        assertFalse(stable.trySet(VALUE2));\n+        assertEquals(initial, stable.orElseThrow());\n+    }\n+\n+    @Test\n+    void setOrThrowValue() {\n+        StableValue<Integer> stable = StableValue.of();\n+        stable.setOrThrow(VALUE);\n+        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(VALUE2));\n+        assertEquals(\"Cannot set the content to \" + VALUE2 + \" because the content is already set: \" + VALUE, e.getMessage());\n+    }\n+\n+    @Test\n+    void setOrThrowNull() {\n+        StableValue<Integer> stable = StableValue.of();\n+        stable.setOrThrow(null);\n+        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(null));\n+        assertEquals(\"Cannot set the content to null because the content is already set: null\", e.getMessage());\n+    }\n+\n+    @Test\n+    void orElse() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertEquals(VALUE, stable.orElse(VALUE));\n+        assertNull(stable.orElse(null));\n+        stable.trySet(VALUE);\n+        assertEquals(VALUE, stable.orElse(VALUE2));\n+    }\n+\n+    @Test\n+    void orElseThrow() {\n+        StableValue<Integer> stable = StableValue.of();\n+        var e = assertThrows(NoSuchElementException.class, stable::orElseThrow);\n+        assertEquals(\"No content set\", e.getMessage());\n+        stable.trySet(VALUE);\n+        assertEquals(VALUE, stable.orElseThrow());\n+    }\n+\n+    @Test\n+    void isSet() {\n+        isSet(VALUE);\n+        isSet(null);\n+   }\n+\n+    void isSet(Integer initial) {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertFalse(stable.isSet());\n+        stable.trySet(initial);\n+        assertTrue(stable.isSet());\n+    }\n+\n+   @Test\n+   void testOrElseSetSupplier() {\n+       StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(() -> VALUE);\n+       StableValue<Integer> stable = StableValue.of();\n+       assertThrows(NullPointerException.class, () -> stable.orElseSet(null));\n+       assertEquals(VALUE, stable.orElseSet(cs));\n+       assertEquals(1, cs.cnt());\n+       assertEquals(VALUE, stable.orElseSet(cs));\n+       assertEquals(1, cs.cnt());\n+   }\n+\n+    @Test\n+    void testHashCode() {\n+        StableValue<Integer> stableValue = StableValue.of();\n+        \/\/ Should be Object::hashCode\n+        assertEquals(System.identityHashCode(stableValue), stableValue.hashCode());\n+    }\n+\n+    @Test\n+    void testEquals() {\n+        StableValue<Integer> s0 = StableValue.of();\n+        assertNotEquals(null, s0);\n+        StableValue<Integer> s1 = StableValue.of();\n+        assertNotEquals(s0, s1); \/\/ Identity based\n+        s0.setOrThrow(42);\n+        s1.setOrThrow(42);\n+        assertNotEquals(s0, s1);\n+        assertNotEquals(\"a\", s0);\n+        StableValue<Integer> null0 = StableValue.of();\n+        StableValue<Integer> null1 = StableValue.of();\n+        null0.setOrThrow(null);\n+        null1.setOrThrow(null);\n+        assertNotEquals(null0, null1);\n+    }\n+\n+    @Test\n+    void toStringUnset() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertEquals(\".unset\", stable.toString());\n+    }\n+\n+    @Test\n+    void toStringNull() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertTrue(stable.trySet(null));\n+        assertEquals(\"null\", stable.toString());\n+    }\n+\n+    @Test\n+    void toStringNonNull() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertTrue(stable.trySet(VALUE));\n+        assertEquals(Objects.toString(VALUE), stable.toString());\n+    }\n+\n+    @Test\n+    void toStringCircular() {\n+        StableValue<StableValue<?>> stable = StableValue.of();\n+        stable.trySet(stable);\n+        String toString = stable.toString();\n+        assertEquals(\"(this StableValue)\", toString);\n+        assertDoesNotThrow(stable::hashCode);\n+        assertDoesNotThrow((() -> stable.equals(stable)));\n+    }\n+\n+    @Test\n+    void recursiveCall() {\n+        StableValue<Integer> stable = StableValue.of();\n+        AtomicReference<StableValue<Integer>> ref = new AtomicReference<>(stable);\n+        assertThrows(IllegalStateException.class, () ->\n+                stable.orElseSet(() -> {\n+                    ref.get().trySet(1);\n+                    return 1;\n+                })\n+        );\n+        assertThrows(IllegalStateException.class, () ->\n+                stable.orElseSet(() -> {\n+                    ref.get().orElseSet(() -> 1);\n+                    return 1;\n+                })\n+        );\n+    }\n+\n+    private static final BiPredicate<StableValue<Integer>, Integer> TRY_SET = StableValue::trySet;\n+    private static final BiPredicate<StableValue<Integer>, Integer> SET_OR_THROW = (s, i) -> {\n+        try {\n+            s.setOrThrow(i);\n+            return true;\n+        } catch (IllegalStateException e) {\n+            return false;\n+        }\n+    };\n+\n+    @Test\n+    void raceTrySet() {\n+        race(TRY_SET);\n+    }\n+\n+    @Test\n+    void raceSetOrThrow() {\n+        race(SET_OR_THROW);\n+    }\n+\n+    @Test\n+    void raceMixed() {\n+        race((s, i) -> switch (i % 2) {\n+            case 0 -> TRY_SET.test(s, i);\n+            case 1 -> SET_OR_THROW.test(s, i);\n+            default -> fail(\"should not reach here\");\n+        });\n+    }\n+\n+    void race(BiPredicate<StableValue<Integer>, Integer> winnerPredicate) {\n+        int noThreads = 10;\n+        CountDownLatch starter = new CountDownLatch(1);\n+        StableValue<Integer> stable = StableValue.of();\n+        BitSet winner = new BitSet(noThreads);\n+        List<Thread> threads = IntStream.range(0, noThreads).mapToObj(i -> new Thread(() -> {\n+                    try {\n+                        \/\/ Ready, set ...\n+                        starter.await();\n+                        \/\/ Here we go!\n+                        winner.set(i, winnerPredicate.test(stable, i));\n+                    } catch (Throwable t) {\n+                        fail(t);\n+                    }\n+                }))\n+                .toList();\n+        threads.forEach(Thread::start);\n+        LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n+        \/\/ Start the race\n+        starter.countDown();\n+        threads.forEach(StableValueTest::join);\n+        \/\/ There can only be one winner\n+        assertEquals(1, winner.cardinality());\n+    }\n+\n+    private static void join(Thread thread) {\n+        try {\n+            thread.join();\n+        } catch (InterruptedException e) {\n+            fail(e);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for making sure StableValue publishes values safely\n+ * @modules java.base\/jdk.internal.misc\n+ * @compile --enable-preview -source ${jdk.version} StableValuesSafePublicationTest.java\n+ * @run junit\/othervm --enable-preview StableValuesSafePublicationTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableValuesSafePublicationTest {\n+\n+    private static final int SIZE = 100_000;\n+    private static final int THREADS = Runtime.getRuntime().availableProcessors();\n+    private static final StableValue<Holder>[] STABLES = stables();\n+\n+    static StableValue<Holder>[] stables() {\n+        @SuppressWarnings(\"unchecked\")\n+        StableValue<Holder>[] stables = (StableValue<Holder>[]) new StableValue[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            stables[i] = StableValue.of();\n+        }\n+        return stables;\n+    }\n+\n+    static final class Holder {\n+        \/\/ These are non-final fields but should be seen\n+        \/\/ fully initialized thanks to the HB properties of StableValue.\n+        int a;\n+        int b;\n+\n+        Holder() {\n+            a = 1;\n+            b = 1;\n+        }\n+    }\n+\n+    static final class Consumer implements Runnable {\n+\n+        final int[] observations = new int[SIZE];\n+        final StableValue<Holder>[] stables = STABLES;\n+        int i = 0;\n+\n+        @Override\n+        public void run() {\n+            for (; i < SIZE; i++) {\n+                StableValue<Holder> s = stables[i];\n+                Holder h;\n+                \/\/ Wait until the StableValue has a holder value\n+                while ((h = s.orElse(null)) == null) {}\n+                int a = h.a;\n+                int b = h.b;\n+                observations[i] = a + (b << 1);\n+            }\n+        }\n+    }\n+\n+    static final class Producer implements Runnable {\n+\n+        final StableValue<Holder>[] stables = STABLES;\n+\n+        @Override\n+        public void run() {\n+            StableValue<Holder> s;\n+            long deadlineNs = System.nanoTime();\n+            for (int i = 0; i < SIZE; i++) {\n+                s = stables[i];\n+                s.trySet(new Holder());\n+                deadlineNs += 1000;\n+                while (System.nanoTime() < deadlineNs) {\n+                    Thread.onSpinWait();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void main() {\n+        List<Consumer> consumers = IntStream.range(0, THREADS)\n+                .mapToObj(_ -> new Consumer())\n+                .toList();\n+\n+        List<Thread> consumersThreads = IntStream.range(0, THREADS)\n+                .mapToObj(i -> Thread.ofPlatform()\n+                        .name(\"Consumer Thread \" + i)\n+                        .start(consumers.get(i)))\n+                .toList();\n+\n+        Producer producer = new Producer();\n+\n+        Thread producerThread = Thread.ofPlatform()\n+                .name(\"Producer Thread\")\n+                .start(producer);\n+\n+        join(consumers, producerThread);\n+        join(consumers, consumersThreads.toArray(Thread[]::new));\n+\n+        int[] histogram = new int[4];\n+        for (Consumer consumer : consumers) {\n+            for (int i = 0; i < SIZE; i++) {\n+                histogram[consumer.observations[i]]++;\n+            }\n+        }\n+\n+        \/\/ a = 0, b = 0 : index 0\n+        assertEquals(0, histogram[0]);\n+        \/\/ a = 1, b = 0 : index 1\n+        assertEquals(0, histogram[1]);\n+        \/\/ a = 0, b = 1 : index 2\n+        assertEquals(0, histogram[2]);\n+        \/\/ a = 1, b = 1 : index 3\n+        \/\/ All observations should end up in this bucket\n+        assertEquals(THREADS * SIZE, histogram[3]);\n+    }\n+\n+    static void join(List<Consumer> consumers, Thread... threads) {\n+        try {\n+            for (Thread t:threads) {\n+                long deadline = System.currentTimeMillis()+TimeUnit.MINUTES.toMillis(1);\n+                while (t.isAlive()) {\n+                    t.join(TimeUnit.SECONDS.toMillis(10));\n+                    if (t.isAlive()) {\n+                        String stack = Arrays.stream(t.getStackTrace())\n+                                .map(Objects::toString)\n+                                .collect(Collectors.joining(System.lineSeparator()));\n+                        System.err.println(t + \": \" + stack);\n+                        for (int i = 0; i < consumers.size(); i++) {\n+                            System.err.println(\"Consumer \" + i + \": \" + consumers.get(i).i);\n+                        }\n+                    }\n+                    if (System.currentTimeMillis() > deadline) {\n+                        long nonNulls = CompletableFuture.supplyAsync(() ->\n+                                Stream.of(STABLES)\n+                                        .map(s -> s.orElse(null))\n+                                        .filter(Objects::nonNull)\n+                                        .count(), Executors.newSingleThreadExecutor()).join();\n+                        fail(\"Giving up! Set stables seen by a new thread: \" + nonNulls);\n+                    }\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            fail(ie);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValuesSafePublicationTest.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for TrustedFieldType implementations\n+ * @modules jdk.unsupported\/sun.misc\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @modules java.base\/jdk.internal.misc\n+ * @compile --enable-preview -source ${jdk.version} TrustedFieldTypeTest.java\n+ * @run junit\/othervm --enable-preview --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED -Dopens=true TrustedFieldTypeTest\n+ * @run junit\/othervm --enable-preview -Dopens=false TrustedFieldTypeTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableValueImpl;\n+import jdk.internal.misc.Unsafe;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InaccessibleObjectException;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TrustedFieldTypeTest {\n+\n+    @Test\n+    void reflection() throws NoSuchFieldException, IllegalAccessException {\n+        final class Holder {\n+            private final StableValue<Integer> value = StableValue.of();\n+        }\n+        final class HolderNonFinal {\n+            private StableValue<Integer> value = StableValue.of();\n+        }\n+        final class ArrayHolder {\n+            @SuppressWarnings(\"unchecked\")\n+            private final StableValue<Integer>[] array = (StableValue<Integer>[]) new StableValue[]{};\n+        }\n+\n+        Field valueField = Holder.class.getDeclaredField(\"value\");\n+        valueField.setAccessible(true);\n+        Holder holder = new Holder();\n+        \/\/ We should be able to read the StableValue field\n+        Object read = valueField.get(holder);\n+        \/\/ We should NOT be able to write to the StableValue field\n+        assertThrows(IllegalAccessException.class, () ->\n+                valueField.set(holder, StableValue.of())\n+        );\n+\n+        Field valueNonFinal = HolderNonFinal.class.getDeclaredField(\"value\");\n+        valueNonFinal.setAccessible(true);\n+        HolderNonFinal holderNonFinal = new HolderNonFinal();\n+        \/\/ As the field is not final, both read and write should be ok (not trusted)\n+        Object readNonFinal = valueNonFinal.get(holderNonFinal);\n+        valueNonFinal.set(holderNonFinal, StableValue.of());\n+\n+        Field arrayField = ArrayHolder.class.getDeclaredField(\"array\");\n+        arrayField.setAccessible(true);\n+        ArrayHolder arrayHolder = new ArrayHolder();\n+        \/\/ We should be able to read the StableValue array\n+        read = arrayField.get(arrayHolder);\n+        \/\/ We should be able to write to the StableValue array\n+        assertDoesNotThrow(() -> arrayField.set(arrayHolder, new StableValue[1]));\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    @Test\n+    void sunMiscUnsafe() throws NoSuchFieldException, IllegalAccessException {\n+        Field unsafeField = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n+        assertTrue(unsafeField.trySetAccessible());\n+        sun.misc.Unsafe unsafe = (sun.misc.Unsafe)unsafeField.get(null);\n+\n+        final class Holder {\n+            private final StableValue<Integer> value = StableValue.of();\n+        }\n+        final class ArrayHolder {\n+            @SuppressWarnings(\"unchecked\")\n+            private final StableValue<Integer>[] array = (StableValue<Integer>[]) new StableValue[]{};\n+        }\n+\n+        Field valueField = Holder.class.getDeclaredField(\"value\");\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                unsafe.objectFieldOffset(valueField)\n+        );\n+\n+        Field arrayField = ArrayHolder.class.getDeclaredField(\"array\");\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                unsafe.objectFieldOffset(arrayField)\n+        );\n+\n+        \/\/ Test direct access\n+        StableValue<?> stableValue = StableValue.of();\n+        Class<?> clazz = stableValue.getClass();\n+        System.out.println(\"clazz = \" + clazz);\n+        assertThrows(NoSuchFieldException.class, () -> clazz.getField(\"value\"));\n+    }\n+\n+    @Test\n+    void varHandle() throws NoSuchFieldException, IllegalAccessException {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+        StableValue<Integer> originalValue = StableValue.of();\n+        @SuppressWarnings(\"unchecked\")\n+        StableValue<Integer>[] originalArrayValue = new StableValue[10];\n+\n+        final class Holder {\n+            private final StableValue<Integer> value = originalValue;\n+        }\n+        final class ArrayHolder {\n+            private final StableValue<Integer>[] array = originalArrayValue;\n+        }\n+\n+\n+        VarHandle valueVarHandle = lookup.findVarHandle(Holder.class, \"value\", StableValue.class);\n+        Holder holder = new Holder();\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                valueVarHandle.set(holder, StableValue.of())\n+        );\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                valueVarHandle.compareAndSet(holder, originalValue, StableValue.of())\n+        );\n+\n+        VarHandle arrayVarHandle = lookup.findVarHandle(ArrayHolder.class, \"array\", StableValue[].class);\n+        ArrayHolder arrayHolder = new ArrayHolder();\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arrayVarHandle.set(arrayHolder, new StableValue[1])\n+        );\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arrayVarHandle.compareAndSet(arrayHolder, originalArrayValue, new StableValue[1])\n+        );\n+\n+    }\n+\n+    @Test\n+    void updateStableValueContentVia_j_i_m_Unsafe() {\n+        StableValue<Integer> stableValue = StableValue.of();\n+        stableValue.trySet(42);\n+        jdk.internal.misc.Unsafe unsafe = Unsafe.getUnsafe();\n+\n+        long offset = unsafe.objectFieldOffset(stableValue.getClass(), \"content\");\n+        assertTrue(offset > 0);\n+\n+        \/\/ Unfortunately, it is possible to update the underlying data via jdk.internal.misc.Unsafe\n+        Object oldData = unsafe.getAndSetReference(stableValue, offset, 13);\n+        assertEquals(42, oldData);\n+        assertEquals(13, stableValue.orElseThrow());\n+    }\n+\n+    @Test\n+    void updateStableValueContentViaSetAccessible() throws NoSuchFieldException, IllegalAccessException {\n+\n+        if (Boolean.getBoolean(\"opens\")) {\n+            \/\/ Unfortunately, add-opens allows direct access to the `value` field\n+            Field field = StableValueImpl.class.getDeclaredField(\"content\");\n+            field.setAccessible(true);\n+\n+            StableValue<Integer> stableValue = StableValue.of();\n+            stableValue.trySet(42);\n+\n+\/\/            assertThrows(IllegalAccessException.class, () -> {\n+            Object oldData = field.get(stableValue);\n+            assertEquals(42, oldData);\n+\/\/            });\n+\n+\/\/            assertThrows(IllegalAccessException.class, () -> {\n+            field.set(stableValue, 13);\n+\/\/            });\n+            assertEquals(13, stableValue.orElseThrow());\n+        } else {\n+            Field field = StableValueImpl.class.getDeclaredField(\"content\");\n+            assertThrows(InaccessibleObjectException.class, ()-> field.setAccessible(true));\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/TrustedFieldTypeTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(100)\n+public class StableFunctionBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final Set<Integer> SET = IntStream.range(0, SIZE).boxed().collect(Collectors.toSet());\n+\n+    private static final Map<Integer, Integer> STABLE = StableValue.map(SET, Function.identity());\n+    private static final Function<Integer, Integer> FUNCTION = StableValue.function(SET, Function.identity());\n+\n+    private final Map<Integer, Integer> stable = StableValue.map(SET, Function.identity());\n+    private final Function<Integer, Integer> function = StableValue.function(SET, Function.identity());\n+\n+    @Benchmark\n+    public int stable() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += stable.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int function() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += function.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticStable() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += STABLE.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += FUNCTION.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableFunctionBenchmark.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(100)\n+public class StableIntFunctionBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    private static final List<Integer> STABLE = StableValue.list(SIZE, IDENTITY);\n+    private static final IntFunction<Integer> INT_FUNCTION = StableValue.intFunction(SIZE, IDENTITY);\n+\n+    private final List<Integer> stable = StableValue.list(SIZE, IDENTITY);\n+    private final IntFunction<Integer> intFunction = StableValue.intFunction(SIZE, IDENTITY);\n+\n+    @Benchmark\n+    public int stable() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += stable.get(i);\n+        }\n+        return sum;\n+    }\n+\n+\n+    @Benchmark\n+    public int intFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += intFunction.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticStable() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += STABLE.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += INT_FUNCTION.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableIntFunctionBenchmark.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(2)\n+public class StableSupplierBenchmark {\n+\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 23;\n+\n+    private static final StableValue<Integer> STABLE = init(StableValue.of(), VALUE);\n+    private static final StableValue<Integer> STABLE2 = init(StableValue.of(), VALUE2);\n+    private static final Supplier<Integer> SUPPLIER = StableValue.supplier(() -> VALUE);\n+    private static final Supplier<Integer> SUPPLIER2 = StableValue.supplier(() -> VALUE);\n+\n+    private final StableValue<Integer> stable = init(StableValue.of(), VALUE);\n+    private final StableValue<Integer> stable2 = init(StableValue.of(), VALUE2);\n+    private final Supplier<Integer> supplier = StableValue.supplier(() -> VALUE);\n+    private final Supplier<Integer> supplier2 = StableValue.supplier(() -> VALUE2);\n+\n+    @Benchmark\n+    public int stable() {\n+        return stable.orElseThrow() + stable2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int supplier() {\n+        return supplier.get() + supplier2.get();\n+    }\n+\n+\/*\n+    @Benchmark\n+    public int staticStable() {\n+        return STABLE.orElseThrow() + STABLE2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int staticSupplier() {\n+        return SUPPLIER.get() + SUPPLIER2.get();\n+    }\n+*\/\n+\n+    private static StableValue<Integer> init(StableValue<Integer> m, Integer value) {\n+        m.trySet(value);\n+        return m;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableSupplierBenchmark.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(2)\n+public class StableValueBenchmark {\n+\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 23;\n+\n+    private static final StableValue<Integer> STABLE = init(StableValue.of(), VALUE);\n+    private static final StableValue<Integer> STABLE2 = init(StableValue.of(), VALUE2);\n+    private static final StableValue<Integer> DCL = init(StableValue.of(), VALUE);\n+    private static final StableValue<Integer> DCL2 = init(StableValue.of(), VALUE2);\n+    private static final AtomicReference<Integer> ATOMIC = new AtomicReference<>(VALUE);\n+    private static final AtomicReference<Integer> ATOMIC2 = new AtomicReference<>(VALUE2);\n+    private static final Holder HOLDER = new Holder(VALUE);\n+    private static final Holder HOLDER2 = new Holder(VALUE2);\n+\n+    private final StableValue<Integer> stable = init(StableValue.of(), VALUE);\n+    private final StableValue<Integer> stable2 = init(StableValue.of(), VALUE2);\n+    private final StableValue<Integer> stableNull = StableValue.of();\n+    private final StableValue<Integer> stableNull2 = StableValue.of();\n+    private final Supplier<Integer> dcl = new Dcl<>(() -> VALUE);\n+    private final Supplier<Integer> dcl2 = new Dcl<>(() -> VALUE2);\n+    private final AtomicReference<Integer> atomic = new AtomicReference<>(VALUE);\n+    private final AtomicReference<Integer> atomic2 = new AtomicReference<>(VALUE2);\n+    private final Supplier<Integer> supplier = () -> VALUE;\n+    private final Supplier<Integer> supplier2 = () -> VALUE2;\n+\n+\n+    @Setup\n+    public void setup() {\n+        stableNull.trySet(null);\n+        stableNull2.trySet(VALUE2);\n+        \/\/ Create pollution\n+        int sum = 0;\n+        for (int i = 0; i < 500_000; i++) {\n+            final int v = i;\n+            Dcl<Integer> dclX = new Dcl<>(() -> v);\n+            sum += dclX.get();\n+            StableValue<Integer> stableX = StableValue.of();\n+            stableX.trySet(i);\n+            sum += stableX.orElseThrow();\n+        }\n+        System.out.println(\"sum = \" + sum);\n+    }\n+\n+    @Benchmark\n+    public int atomic() {\n+        return atomic.get() + atomic2.get();\n+    }\n+\n+    @Benchmark\n+    public int dcl() {\n+        return dcl.get() + dcl2.get();\n+    }\n+\n+    @Benchmark\n+    public int stable() {\n+        return stable.orElseThrow() + stable2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int stableNull() {\n+        return (stableNull.orElseThrow() == null ? VALUE : VALUE2) + (stableNull2.orElseThrow() == null ? VALUE : VALUE2);\n+    }\n+\n+    \/\/ Reference case\n+    @Benchmark\n+    public int refSupplier() {\n+        return supplier.get() + supplier2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticAtomic() {\n+        return ATOMIC.get() + ATOMIC2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticDcl() {\n+        return DCL.orElseThrow() + DCL2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int staticHolder() {\n+        return HOLDER.get() + HOLDER2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticStable() {\n+        return STABLE.orElseThrow() + STABLE2.orElseThrow();\n+    }\n+\n+\n+    private static StableValue<Integer> init(StableValue<Integer> m, Integer value) {\n+        m.trySet(value);\n+        return m;\n+    }\n+\n+    \/\/ The VM should be able to constant-fold the value given in the constructor\n+    \/\/ because StableValue fields have a special meaning.\n+    private static final class Holder {\n+\n+        private final StableValue<Integer> delegate = StableValue.of();\n+\n+        Holder(int value) {\n+            delegate.setOrThrow(value);\n+        }\n+\n+        int get() {\n+            return delegate.orElseThrow();\n+        }\n+\n+    }\n+\n+    \/\/ Handles null values\n+    private static class Dcl<V> implements Supplier<V> {\n+\n+        private final Supplier<V> supplier;\n+\n+        private volatile V value;\n+        private boolean bound;\n+\n+        public Dcl(Supplier<V> supplier) {\n+            this.supplier = supplier;\n+        }\n+\n+        @Override\n+        public V get() {\n+            V v = value;\n+            if (v == null) {\n+                if (!bound) {\n+                    synchronized (this) {\n+                        v = value;\n+                        if (v == null) {\n+                            if (!bound) {\n+                                value = v = supplier.get();\n+                                bound = true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableValueBenchmark.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"}]}