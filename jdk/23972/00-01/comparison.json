{"files":[{"patch":"@@ -436,0 +436,2 @@\n+     * @throws IllegalStateException if the provided {@code supplier} recursively\n+     *                               attempts to set this stable value.\n@@ -511,0 +513,3 @@\n+     * <p>\n+     * If the provided {@code original} supplier recursively calls the returned\n+     * supplier, an {@linkplain IllegalStateException} will be thrown.\n@@ -539,0 +544,4 @@\n+     * <p>\n+     * If the provided {@code original} int function recursively calls the returned\n+     * int function for the same index, an {@linkplain IllegalStateException} will\n+     * be thrown.\n@@ -572,0 +581,4 @@\n+     * <p>\n+     * If the provided {@code original} function recursively calls the returned\n+     * function for the same input, an {@linkplain IllegalStateException} will\n+     * be thrown.\n@@ -607,0 +620,3 @@\n+     * <p>\n+     * If the provided {@code mapper} recursively calls the returned list for the\n+     * same index, an {@linkplain IllegalStateException} will be thrown.\n@@ -642,0 +658,3 @@\n+     * <p>\n+     * If the provided {@code mapper} recursively calls the returned map for\n+     * the same key, an {@linkplain IllegalStateException} will be thrown.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StableValue.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+        \/\/ Prevent reentry via computeIfUnsetSlowPath\n+        if (Thread.holdsLock(this)) {\n+            throw new IllegalStateException(\"Recursing supplier detected\");\n+        }\n@@ -80,1 +84,1 @@\n-            return wrapAndCas(value);\n+            return wrapAndSet(value);\n@@ -125,6 +129,13 @@\n-    private synchronized T computeIfUnsetSlowPath(Supplier<? extends T> supplier) {\n-        final Object t = value;  \/\/ Plain semantics suffice here\n-        if (t == null) {\n-            final T newValue = supplier.get();\n-            \/\/ The mutex is reentrant so we need to check if the value was actually set.\n-            return wrapAndCas(newValue) ? newValue : orElseThrow();\n+    private T computeIfUnsetSlowPath(Supplier<? extends T> supplier) {\n+        \/\/ Prevent reentry\n+        if (Thread.holdsLock(this)) {\n+            throw new IllegalStateException(\"Recursing supplier detected: \" + supplier);\n+        }\n+        synchronized (this) {\n+            final Object t = value;  \/\/ Plain semantics suffice here\n+            if (t == null) {\n+                final T newValue = supplier.get();\n+                \/\/ The mutex is reentrant so we need to check if the value was actually set.\n+                return wrapAndSet(newValue) ? newValue : orElseThrow();\n+            }\n+            return unwrap(t);\n@@ -132,1 +143,0 @@\n-        return unwrap(t);\n@@ -159,1 +169,2 @@\n-    private boolean wrapAndCas(Object value) {\n+    private boolean wrapAndSet(Object newValue) {\n+        assert Thread.holdsLock(this);\n@@ -161,1 +172,6 @@\n-        return UNSAFE.compareAndSetReference(this, UNDERLYING_DATA_OFFSET, null, wrap(value));\n+        \/\/ We know we hold the monitor here so plain semantic is enough\n+        if (value != null) {\n+            return false;\n+        }\n+        UNSAFE.putReferenceRelease(this, UNDERLYING_DATA_OFFSET, wrap(newValue));\n+        return true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-        assertThrows(StackOverflowError.class, () -> lazy.get(INDEX));\n+        assertThrows(IllegalStateException.class, () -> lazy.get(INDEX));\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -39,0 +40,1 @@\n+import java.util.function.IntFunction;\n@@ -171,0 +173,18 @@\n+    @Test\n+    void recursiveCall() {\n+        StableValue<Integer> stable = StableValue.of();\n+        AtomicReference<StableValue<Integer>> ref = new AtomicReference<>(stable);\n+        assertThrows(IllegalStateException.class, () ->\n+                stable.orElseSet(() -> {\n+                    ref.get().trySet(1);\n+                    return 1;\n+                })\n+        );\n+        assertThrows(IllegalStateException.class, () ->\n+                stable.orElseSet(() -> {\n+                    ref.get().orElseSet(() -> 1);\n+                    return 1;\n+                })\n+        );\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}