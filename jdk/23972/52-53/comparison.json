{"files":[{"patch":"@@ -1540,1 +1540,1 @@\n-            return getOrDefault0(key, null);\n+            return getOrDefault(key, null);\n@@ -1546,5 +1546,0 @@\n-            return getOrDefault0(key, defaultValue);\n-        }\n-\n-        @ForceInline\n-        private V getOrDefault0(Object key, V defaultValue) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.util.concurrent.TimeUnit.*;\n+\n+@Warmup(iterations = 5, time = 5, timeUnit = SECONDS)\n+@Measurement(iterations = 5, time = 5, timeUnit = SECONDS)\n+@Fork(value = 1, jvmArgs = { \"--enable-preview\" })\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(NANOSECONDS)\n+@State(Scope.Benchmark)\n+public class VarHandleHolderBenchmark {\n+\n+    private static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+            ValueLayout.JAVA_INT.withName(\"x\"),\n+            ValueLayout.JAVA_INT.withName(\"y\")\n+    );\n+\n+    private static final long SIZEOF = LAYOUT.byteSize();\n+    private static final long OFFSET_X = LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(\"x\"));\n+    private static final long OFFSET_Y = LAYOUT.byteOffset(groupElement(\"y\"));\n+\n+    static final class MyVarHandleLookup implements Function<String, VarHandle> {\n+        @Override\n+        public VarHandle apply(String name) {\n+            return LAYOUT.arrayElementVarHandle(groupElement(name)).withInvokeExactBehavior();\n+        }\n+    }\n+\n+    private static final Function<String, VarHandle> VAR_HANDLE_FUNCTION = new MyVarHandleLookup();\n+\n+    private static final VarHandle VH_X = VAR_HANDLE_FUNCTION.apply(\"x\");\n+    private static final VarHandle VH_Y = VAR_HANDLE_FUNCTION.apply(\"y\");\n+\n+    private static final Supplier<VarHandle> SV_X = StableValue.supplier(() -> VAR_HANDLE_FUNCTION.apply(\"x\"));\n+    private static final Supplier<VarHandle> SV_Y = StableValue.supplier(() -> VAR_HANDLE_FUNCTION.apply(\"y\"));\n+\n+    private static final Map<String, VarHandle> U_MAP = Map.of(\n+            \"x\", VH_X,\n+            \"y\", VH_Y);\n+\n+    private static final Map<String, VarHandle> U_MAP_ELEMENT = Map.of(\n+            \"x\", LAYOUT.varHandle(groupElement(\"x\")),\n+            \"y\", LAYOUT.varHandle(groupElement(\"y\")));\n+\n+    private static final Map<String, VarHandle> S_MAP = StableValue.map(\n+            Set.of(\"x\", \"y\"),\n+            VAR_HANDLE_FUNCTION);\n+\n+    private static final Function<String, VarHandle> S_FUN = StableValue.function(\n+            Set.of(\"x\", \"y\"),\n+            VAR_HANDLE_FUNCTION);\n+\n+    private static final MemorySegment confined;\n+    static {\n+        var array = new int[512 * (int) SIZEOF \/ (int) ValueLayout.JAVA_INT.byteSize()];\n+        var heap = MemorySegment.ofArray(array);\n+        for(var i = 0; i < 512; i++) {\n+            heap.set(ValueLayout.JAVA_INT, i * SIZEOF + OFFSET_X, i);\n+            heap.set(ValueLayout.JAVA_INT, i * SIZEOF + OFFSET_Y, i);\n+        }\n+        confined = Arena.ofConfined().allocate(LAYOUT, 512);\n+        confined.copyFrom(heap);\n+    }\n+\n+    @Benchmark\n+    public int confinedVarHandleLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) VH_X.get(confined, 0L, (long) i);\n+            var y = (int) VH_Y.get(confined, 0L, (long) i);\n+            sum += x \/*+y*\/;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int confinedStableValueLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) SV_X.get().get(confined, 0L, (long) i);\n+            var y = (int) SV_Y.get().get(confined, 0L, (long) i);\n+            sum += x + y;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int confinedStableMapLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) S_MAP.get(\"x\").get(confined, 0L, (long) i);\n+            var y = (int) S_MAP.get(\"y\").get(confined, 0L, (long) i);\n+            sum += x + y;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int confinedStableMapElementLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) U_MAP_ELEMENT.get(\"x\").get(confined, i * 8L);\n+            var y = (int) U_MAP_ELEMENT.get(\"y\").get(confined, i * 8L);\n+            sum += x + y;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int confinedUnmodifiableMapLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) U_MAP.get(\"x\").get(confined, 0L, (long) i);\n+            var y = (int) U_MAP.get(\"y\").get(confined, 0L, (long) i);\n+            sum += x + y;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int confinedStableFunctionLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) S_FUN.apply(\"x\").get(confined, 0L, (long) i);\n+            var y = (int) S_FUN.apply(\"y\").get(confined, 0L, (long) i);\n+            sum += x + y;\n+        }\n+        return sum;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/VarHandleHolderBenchmark.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}