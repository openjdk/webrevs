{"files":[{"patch":"@@ -49,0 +49,1 @@\n+import java.time.Duration;\n@@ -54,0 +55,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -55,0 +57,1 @@\n+import java.util.stream.IntStream;\n@@ -227,1 +230,4 @@\n-\n+        \/\/ Holder for unfulfilled timeouts left for each server\n+        AtomicLong[] unfulfilledUdpTimeouts = IntStream.range(0, servers.length)\n+                .mapToObj(_ -> new AtomicLong())\n+                .toArray(AtomicLong[]::new);\n@@ -234,2 +240,2 @@\n-            for (int retry = 0; retry < retries; retry++) {\n-\n+            for (int retry = 0; retry <= retries; retry++) {\n+                boolean isLastRetry = retry == retries;\n@@ -241,0 +247,4 @@\n+                    AtomicLong unfulfilledServerTimeout = unfulfilledUdpTimeouts[i];\n+                    if (isLastRetry && unfulfilledServerTimeout.get() == 0) {\n+                        continue;\n+                    }\n@@ -249,1 +259,1 @@\n-                                                retry, xid);\n+                                retry, xid, unfulfilledServerTimeout, isLastRetry);\n@@ -263,1 +273,6 @@\n-                            int retryTimeout = (timeout * (1 << retry));\n+                            long retryTimeout = Math.clamp(\n+                                    timeout * (1L << (isLastRetry\n+                                            ? retry - 1\n+                                            : retry)),\n+                                    0L, Integer.MAX_VALUE);\n+                            ;\n@@ -307,0 +322,2 @@\n+                        } else {\n+                            caughtException.addSuppressed(ex);\n@@ -313,1 +330,4 @@\n-                        if (caughtException == null) {\n+                        if (caughtException instanceof CommunicationException ce) {\n+                            e.addSuppressed(ce);\n+                            caughtException = e;\n+                        } else if (caughtException == null) {\n@@ -333,0 +353,2 @@\n+                        } else {\n+                            caughtException.addSuppressed(e);\n@@ -343,2 +365,2 @@\n-        if (caughtException instanceof NamingException) {\n-            throw (NamingException) caughtException;\n+        if (caughtException instanceof NamingException ne) {\n+            throw ne;\n@@ -428,1 +450,3 @@\n-                                     int port, int retry, int xid)\n+                              int port, int retry, int xid,\n+                              AtomicLong unfulfilledTimeout,\n+                              boolean unfulfilledOnly)\n@@ -432,0 +456,20 @@\n+\n+\n+        \/\/ use 1L below to ensure conversion to long and avoid potential\n+        \/\/ integer overflow (timeout is an int).\n+        \/\/ no point in supporting timeout > Integer.MAX_VALUE, clamp if needed\n+        \/\/ timeout remaining after successive 'blockingReceive()'.\n+        long thisIterationTimeout = unfulfilledOnly\n+                ? 0L\n+                : Math.clamp(timeout * (1L << retry), 0L, Integer.MAX_VALUE);\n+\n+        \/\/ Compensate with server's positive unfulfilled timeout.\n+        \/\/ Calling method never supplies zero 'unfulfilledTimeout' when\n+        \/\/ 'unfulfilledOnly' is 'true', therefore 'thisIterationTimeout'\n+        \/\/ will always be a positive number, ie infinite timeout\n+        \/\/ is not possible.\n+        thisIterationTimeout += unfulfilledTimeout.get();\n+\n+        \/\/ Track left timeout for the current retry\n+        long timeoutLeft = thisIterationTimeout;\n+        long start = 0;\n@@ -440,4 +484,0 @@\n-                \/\/ use 1L below to ensure conversion to long and avoid potential\n-                \/\/ integer overflow (timeout is an int).\n-                \/\/ no point in supporting timeout > Integer.MAX_VALUE, clamp if needed\n-                long pktTimeout = Math.clamp(timeout * (1L << retry), 0L, Integer.MAX_VALUE);\n@@ -446,2 +486,0 @@\n-                \/\/ timeout remaining after successive 'blockingReceive()'\n-                long timeoutLeft = pktTimeout;\n@@ -450,1 +488,1 @@\n-                long start = System.nanoTime();\n+                start = System.nanoTime();\n@@ -464,1 +502,1 @@\n-                    gotData = blockingReceive(udpChannel, ipkt, timeoutLeft);\n+                    gotData = blockingReceive(udpChannel, target, ipkt, timeoutLeft);\n@@ -479,1 +517,1 @@\n-                    timeoutLeft = pktTimeout - elapsedMillis;\n+                    timeoutLeft = thisIterationTimeout - elapsedMillis;\n@@ -485,0 +523,3 @@\n+            long carryoverTimeout = thisIterationTimeout -\n+                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n+            unfulfilledTimeout.set(Math.max(0, carryoverTimeout));\n@@ -489,1 +530,2 @@\n-    boolean blockingReceive(DatagramChannel dc, ByteBuffer buffer, long timeout) throws IOException {\n+    boolean blockingReceive(DatagramChannel dc, InetSocketAddress target,\n+                            ByteBuffer buffer, long timeout) throws IOException {\n@@ -502,1 +544,1 @@\n-                dataReceived = senderAddress != null && buffer.position() > before;\n+                dataReceived = target.equals(senderAddress) && buffer.position() > before;\n@@ -763,1 +805,1 @@\n-    private int timeoutLeft;\n+    private long timeoutLeft;\n@@ -765,1 +807,1 @@\n-    Tcp(InetAddress server, int port, int timeout) throws IOException {\n+    Tcp(InetAddress server, int port, long timeout) throws IOException {\n@@ -768,3 +810,8 @@\n-            long start = System.currentTimeMillis();\n-            sock.connect(new InetSocketAddress(server, port), timeout);\n-            timeoutLeft = (int) (timeout - (System.currentTimeMillis() - start));\n+            long start = System.nanoTime();\n+            \/\/ It is safe to cast to int since the value is\n+            \/\/ clamped by the caller\n+            int intTimeout = (int) timeout;\n+            sock.connect(new InetSocketAddress(server, port), intTimeout);\n+            timeoutLeft = Duration.ofMillis(timeout)\n+                    .minus(Duration.ofNanos((System.nanoTime() - start)))\n+                    .toMillis();\n@@ -798,3 +845,4 @@\n-\n-        sock.setSoTimeout(timeoutLeft);\n-        long start = System.currentTimeMillis();\n+        \/\/ It is safe to cast to int since the value is clamped\n+        int intTimeout = (int) timeoutLeft;\n+        sock.setSoTimeout(intTimeout);\n+        long start = System.nanoTime();\n@@ -805,1 +853,2 @@\n-            timeoutLeft -= (int) (System.currentTimeMillis() - start);\n+            timeoutLeft -= TimeUnit.NANOSECONDS.toMillis(\n+                    System.nanoTime() - start);\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsClient.java","additions":78,"deletions":29,"binary":false,"changes":107,"status":"modified"}]}