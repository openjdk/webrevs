{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -439,1 +440,1 @@\n-                int pktTimeout = (timeout * (1 << retry));\n+                long pktTimeout = (timeout * (1L << retry));\n@@ -443,1 +444,1 @@\n-                int timeoutLeft = pktTimeout;\n+                long timeoutLeft = Math.clamp(pktTimeout, 0, Integer.MAX_VALUE);\n@@ -459,1 +460,1 @@\n-                    long start = System.currentTimeMillis();\n+                    long start = System.nanoTime();\n@@ -461,1 +462,1 @@\n-                    long end = System.currentTimeMillis();\n+                    long end = System.nanoTime();\n@@ -474,1 +475,3 @@\n-                    timeoutLeft = pktTimeout - ((int) (end - start));\n+                    long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(end - start);\n+                    \/\/ Setting the Math.clamp min to 1 ensures that the timeout is decreased\n+                    timeoutLeft = timeoutLeft - Math.clamp(elapsedMillis, 1, Integer.MAX_VALUE);\n@@ -494,2 +497,8 @@\n-                dc.receive(buffer);\n-                dataReceived = true;\n+                int before = buffer.position();\n+                var senderAddress = dc.receive(buffer);\n+                \/\/ Empty packets are ignored\n+                dataReceived = senderAddress != null && buffer.position() > before;\n+            }\n+            \/\/ Avoid contention with Selector.close() if called by a clean-up thread\n+            synchronized (keys) {\n+                keys.clear();\n@@ -497,1 +506,0 @@\n-            keys.clear();\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsClient.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.time.Instant;\n@@ -43,1 +42,1 @@\n- * @run main Timeout\n+ * @run main\/othervm Timeout\n@@ -51,0 +50,4 @@\n+    \/\/ DnsClient retries again with increased timeout if left\n+    \/\/ timeout is less than this value, and max retry attempts\n+    \/\/ is not reached\n+    private static final int DNS_CLIENT_MIN_TIMEOUT = 50;\n@@ -52,1 +55,1 @@\n-    private Instant startTime;\n+    private long startTime;\n@@ -84,1 +87,1 @@\n-            startTime = Instant.now();\n+            startTime = System.nanoTime();\n@@ -95,1 +98,1 @@\n-            Duration elapsedTime = Duration.between(startTime, Instant.now());\n+            Duration elapsedTime = Duration.ofNanos(System.nanoTime() - startTime);\n@@ -102,1 +105,2 @@\n-                    .multipliedBy((1 << RETRIES) - 1);\n+                    .multipliedBy((1 << RETRIES) - 1)\n+                    .minus(Duration.ofMillis((DNS_CLIENT_MIN_TIMEOUT - 1) * RETRIES));\n@@ -107,1 +111,2 @@\n-            \/\/ not more than 50% greater.\n+            \/\/ not more than 67% greater. Given the min DNS timeout\n+            \/\/ correction above the threshold value is equal to 61%.\n@@ -109,2 +114,4 @@\n-                    elapsedTime.multipliedBy(2)\n-                            .compareTo(expectedTime.multipliedBy(3)) <= 0) {\n+                    elapsedTime.multipliedBy(3)\n+                            .compareTo(expectedTime.multipliedBy(5)) <= 0) {\n+                \/\/ 3 * elapsedTime <= expectedTime*5\n+                \/\/ elapsedTime <= 1.67 expectedTime\n@@ -116,1 +123,1 @@\n-                            + \" ms, expected\" + expectedTime.toMillis() + \"ms\");\n+                            + \" ms, expected \" + expectedTime.toMillis() + \" ms\");\n","filename":"test\/jdk\/com\/sun\/jndi\/dns\/ConfigTests\/Timeout.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import javax.naming.CommunicationException;\n+import javax.naming.Context;\n+import javax.naming.directory.InitialDirContext;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.SocketTimeoutException;\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/*\n+ * @test\n+ * @bug 8339538\n+ * @summary Tests that DnsClient correctly calculates left timeout in\n+ *          presence of empty datagram packets.\n+ * @library ..\/lib \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ * @run main\/othervm TimeoutWithEmptyDatagrams\n+ *\/\n+\n+public class TimeoutWithEmptyDatagrams extends DNSTestBase {\n+    \/\/ initial timeout = 1\/4 sec\n+    private static final int TIMEOUT = 250;\n+    \/\/ try 5 times per server\n+    private static final int RETRIES = 5;\n+    \/\/ DnsClient retries again with increased timeout if left\n+    \/\/ timeout is less than this value, and max retry attempts\n+    \/\/ is not reached\n+    private static final int DNS_CLIENT_MIN_TIMEOUT = 50;\n+\n+    public TimeoutWithEmptyDatagrams() {\n+        setLocalServer(false);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new TimeoutWithEmptyDatagrams().run(args);\n+    }\n+\n+    \/*\n+     * Tests that we can set the initial UDP timeout interval and the\n+     * number of retries.\n+     *\/\n+    @Override\n+    public void runTest() throws Exception {\n+        \/\/ Create a DatagramSocket and bind it to the loopback address to simulate\n+        \/\/ UDP DNS server that doesn't respond\n+        try (DatagramSocket ds = new DatagramSocket(new InetSocketAddress(\n+                InetAddress.getLoopbackAddress(), 0))) {\n+            CountDownLatch gotClientAddress = new CountDownLatch(1);\n+            AtomicReference<SocketAddress> clientAddress = new AtomicReference<>();\n+            AtomicBoolean stopTestThreads = new AtomicBoolean();\n+\n+            String allQuietUrl = URIBuilder.newBuilder()\n+                    .scheme(\"dns\")\n+                    .loopback()\n+                    .port(ds.getLocalPort())\n+                    .build()\n+                    .toString();\n+\n+            \/\/ Run a virtual thread that receives client request packets and extracts\n+            \/\/ sender address from them.\n+            Thread receiverThread = Thread.ofVirtual().start(() -> {\n+                while (!stopTestThreads.get()) {\n+                    try {\n+                        DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);\n+                        ds.receive(packet);\n+                        System.err.println(\"Got packet from \" + packet.getSocketAddress());\n+                        boolean hasClientAddress = clientAddress.get() != null;\n+                        clientAddress.set(packet.getSocketAddress());\n+                        if (!hasClientAddress) {\n+                            gotClientAddress.countDown();\n+                        }\n+                    } catch (IOException e) {\n+                        if (!stopTestThreads.get()) {\n+                            throw new RuntimeException(e);\n+                        } else {\n+                            return;\n+                        }\n+                    }\n+                }\n+            });\n+\n+            \/\/ Run a virtual thread that will send an empty packets via server socket\n+            \/\/ that should wake up the selector on a client side.\n+            Thread wakeupThread = Thread.ofVirtual().start(() -> {\n+                try {\n+                    long timeout = Math.max(1, TIMEOUT \/ 4);\n+                    \/\/ wait for a first packet on a server socket\n+                    gotClientAddress.await();\n+\n+                    \/\/ Now start sending empty packets until we get a notification\n+                    \/\/ from client part to stop sending\n+                    while (!stopTestThreads.get()) {\n+                        System.err.println(\"Server timeout = \" + timeout);\n+                        TimeUnit.MILLISECONDS.sleep(timeout);\n+                        System.err.println(\"Sending wakeup packet to \" + clientAddress.get());\n+                        var wakeupPacket = new DatagramPacket(new byte[0], 0);\n+                        wakeupPacket.setSocketAddress(clientAddress.get());\n+                        ds.send(wakeupPacket);\n+                        timeout += Math.max(1, timeout \/ 2);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw new RuntimeException(\"Test machinery failure\", ioe);\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(\"Interrupted during wakeup packets sending\");\n+                } finally {\n+                    System.err.println(\"Server thread exiting\");\n+                }\n+            });\n+\n+            long startTime = 0;\n+            try {\n+                env().put(Context.PROVIDER_URL, allQuietUrl);\n+                env().put(\"com.sun.jndi.dns.timeout.initial\", String.valueOf(TIMEOUT));\n+                env().put(\"com.sun.jndi.dns.timeout.retries\", String.valueOf(RETRIES));\n+                setContext(new InitialDirContext(env()));\n+\n+                startTime = System.nanoTime();\n+                context().getAttributes(\"\");\n+\n+                \/\/ Any request should fail after timeouts have expired.\n+                throw new RuntimeException(\"Failed: getAttributes succeeded unexpectedly\");\n+            } catch (CommunicationException ce) {\n+                \/\/ We need to catch CommunicationException outside the test framework\n+                \/\/ flow because wakeupThread.join() can take some time that could\n+                \/\/ increase measured timeout\n+                long endTime = System.nanoTime();\n+                Duration elapsedTime = Duration.ofNanos(endTime - startTime);\n+                if (ce.getRootCause() instanceof SocketTimeoutException) {\n+\n+                    Duration expectedTime = Duration.ofMillis(TIMEOUT)\n+                            .multipliedBy((1 << RETRIES) - 1)\n+                            .minus(Duration.ofMillis((DNS_CLIENT_MIN_TIMEOUT - 1) * RETRIES));\n+\n+                    DNSTestUtils.debug(\"Elapsed (ms):  \" + elapsedTime.toMillis());\n+                    DNSTestUtils.debug(\"Expected (ms): \" + expectedTime.toMillis());\n+\n+                    \/\/ Check that elapsed time is as long as expected, and\n+                    \/\/ not more than 67% greater. Given the min DNS timeout\n+                    \/\/ correction above the threshold value is equal to 61%.\n+                    if (elapsedTime.compareTo(expectedTime) >= 0 &&\n+                            elapsedTime.multipliedBy(3)\n+                                    .compareTo(expectedTime.multipliedBy(5)) <= 0) {\n+                        \/\/ 3 * elapsedTime <= expectedTime*5\n+                        \/\/ elapsedTime <= 1.67 expectedTime\n+                        System.out.println(\"elapsed time is as long as expected.\");\n+\n+                    } else {\n+                        throw new RuntimeException(\n+                                \"Failed: timeout in \" + elapsedTime.toMillis() +\n+                                        \" ms, expected \" + expectedTime.toMillis() + \" ms\");\n+                    }\n+                } else {\n+                    throw ce;\n+                }\n+            } finally {\n+                stopTestThreads.set(true);\n+                wakeupThread.join();\n+                ds.close();\n+                receiverThread.join();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/dns\/ConfigTests\/TimeoutWithEmptyDatagrams.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"}]}