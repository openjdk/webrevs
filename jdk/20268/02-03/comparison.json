{"files":[{"patch":"@@ -331,2 +331,2 @@\n-     * @throws  IOException if the bind operation fails, or if the socket\n-     *                      is already bound or is closed.\n+     * @throws  IOException if the bind operation fails, the socket\n+     *                      is already bound or the socket is closed.\n@@ -360,2 +360,2 @@\n-     * @throws  IOException if the bind operation fails, or if the socket\n-     *                      is already bound or is closed.\n+     * @throws  IOException if the bind operation fails, the socket\n+     *                      is already bound or the socket is closed.\n@@ -521,1 +521,1 @@\n-     *               connection, or if the socket is not bound or is closed.\n+     *               connection, the socket is not bound or the socket is closed.\n@@ -810,1 +810,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -827,1 +827,1 @@\n-     * @throws IOException if an I\/O error occurs or if the socket is closed.\n+     * @throws IOException if an I\/O error occurs or the socket is closed.\n@@ -891,1 +891,1 @@\n-     *         or if the socket is closed.\n+     *         or the socket is closed.\n@@ -1005,1 +1005,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1033,1 +1033,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/ServerSocket.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -686,2 +686,2 @@\n-     * @throws  IOException if an error occurs during the connection, or if the socket\n-     *          is already connected or closed\n+     * @throws  IOException if an error occurs during the connection, the socket\n+     *          is already connected or the socket is closed\n@@ -721,2 +721,2 @@\n-     * @throws  IOException if an error occurs during the connection, or if the socket\n-     *          is already connected or closed\n+     * @throws  IOException if an error occurs during the connection, the socket\n+     *          is already connected or the socket is closed\n@@ -785,2 +785,2 @@\n-     * @throws  IOException if the bind operation fails, or if the socket\n-     *          is already bound or is closed.\n+     * @throws  IOException if the bind operation fails, the socket\n+     *          is already bound or the socket is closed.\n@@ -1180,1 +1180,1 @@\n-     *         output stream or if the socket is not connected or is closed.\n+     *         output stream, the socket is not connected or the socket is closed.\n@@ -1257,1 +1257,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1275,1 +1275,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1295,1 +1295,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1324,1 +1324,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1374,1 +1374,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1393,1 +1393,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1415,1 +1415,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1434,1 +1434,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1464,1 +1464,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1485,1 +1485,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1533,1 +1533,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1554,1 +1554,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1574,1 +1574,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1590,1 +1590,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1641,1 +1641,1 @@\n-     *         or if the socket is closed.\n+     *         or the socket is closed.\n@@ -1665,1 +1665,1 @@\n-     *         or type-of-service value, or if the socket is closed.\n+     *         or type-of-service value, or the socket is closed.\n@@ -1719,1 +1719,1 @@\n-     *         such as a TCP error, or if the socket is closed.\n+     *         such as a TCP error, or the socket is closed.\n@@ -1770,2 +1770,2 @@\n-     * @throws IOException if an I\/O error occurs when shutting down this socket, of if the\n-     *         socket is not connected or is closed.\n+     * @throws IOException if an I\/O error occurs when shutting down this socket, the\n+     *         socket is not connected or the socket is closed.\n@@ -1800,2 +1800,2 @@\n-     * @throws IOException if an I\/O error occurs when shutting down this socket, or if the socket\n-     *         is not connected or is closed.\n+     * @throws IOException if an I\/O error occurs when shutting down this socket, the socket\n+     *         is not connected or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.stream.Stream;\n@@ -32,3 +31,1 @@\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.api.Test;\n@@ -37,0 +34,1 @@\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -49,75 +47,0 @@\n-    @FunctionalInterface\n-    private interface ServerSocketOp {\n-        void apply(ServerSocket ss) throws IOException;\n-    }\n-\n-\n-    static Stream<Arguments> ioExceptionOperations() {\n-        return Stream.of(\n-                Arguments.of(\"accept()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.accept();\n-                }),\n-                Arguments.of(\"bind()\", (ServerSocketOp) ss -> {\n-                    ss.bind(loopbackEphemeral);\n-                }),\n-                Arguments.of(\"bind(SocketAddress, int)\", (ServerSocketOp) ss -> {\n-                    ss.bind(loopbackEphemeral, 10);\n-                }),\n-                Arguments.of(\"getOption()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.getOption(StandardSocketOptions.SO_RCVBUF);\n-                }),\n-                Arguments.of(\"getSoTimeout()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.getSoTimeout();\n-                }),\n-                Arguments.of(\"setOption()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.setOption(StandardSocketOptions.SO_RCVBUF, 1024);\n-                })\n-        );\n-    }\n-\n-    static Stream<Arguments> socketExceptionOperations() {\n-        return Stream.of(\n-                Arguments.of(\"getReceiveBufferSize()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.getReceiveBufferSize();\n-                }),\n-                Arguments.of(\"getReuseAddress()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.getReuseAddress();\n-                }),\n-                Arguments.of(\"setReceiveBufferSize()\", (ServerSocketOp) ss -> {\n-                    ss.setReceiveBufferSize(1024);\n-                }),\n-                Arguments.of(\"setReuseAddress()\", (ServerSocketOp) ss -> {\n-                    ss.setReuseAddress(false);\n-                }),\n-                Arguments.of(\"setSoTimeout()\", (ServerSocketOp) ss -> {\n-                    ss.setSoTimeout(1000);\n-                })\n-        );\n-    }\n-\n-    static Stream<Arguments> noExceptionOperations() {\n-        return Stream.of(\n-                Arguments.of(\"close()\", (ServerSocketOp) ss -> {\n-                    ss.close();\n-                }),\n-                Arguments.of(\"getInetAddress()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.getInetAddress();\n-                }),\n-                Arguments.of(\"getLocalPort()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.getLocalPort();\n-                }),\n-                Arguments.of(\"getLocalSocketAddress()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.getLocalSocketAddress();\n-                }),\n-                Arguments.of(\"isBound()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.isBound();\n-                }),\n-                Arguments.of(\"isClosed()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.isClosed();\n-                }),\n-                Arguments.of(\"supportedOptions()\", (ServerSocketOp) ss -> {\n-                    var _ = ss.supportedOptions();\n-                })\n-        );\n-    }\n-\n@@ -128,5 +51,25 @@\n-    @ParameterizedTest\n-    @MethodSource(\"ioExceptionOperations\")\n-    public void testIOExceptionThrown(final String opName, final ServerSocketOp op)\n-            throws Exception {\n-        test(IOException.class, false, opName, op);\n+    @Test\n+    public void testIOExceptionThrown() throws Exception {\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            \/\/ close and then invoke the operations on the ServerSocket\n+            ss.close();\n+            assertTrue(ss.isClosed(), \"ServerSocket isn't closed\");\n+            assertThrows(IOException.class,\n+                    ss::accept,\n+                    \"accept() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.bind(loopbackEphemeral),\n+                    \"bind() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.bind(loopbackEphemeral, 10),\n+                    \"bind(SocketAddress, int) when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.getOption(StandardSocketOptions.SO_RCVBUF),\n+                    \"getOption() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    ss::getSoTimeout,\n+                    \"getSoTimeout() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.setOption(StandardSocketOptions.SO_RCVBUF, 1024),\n+                    \"setOption() when already closed didn't throw IOException\");\n+        }\n@@ -139,5 +82,22 @@\n-    @ParameterizedTest\n-    @MethodSource(\"socketExceptionOperations\")\n-    public void testSocketExceptionThrown(final String opName, final ServerSocketOp op)\n-            throws Exception {\n-        test(SocketException.class, true, opName, op);\n+    @Test\n+    public void testSocketExceptionThrown() throws Exception {\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            \/\/ close and then invoke the operations on the ServerSocket\n+            ss.close();\n+            assertTrue(ss.isClosed(), \"ServerSocket isn't closed\");\n+            assertThrowsExactly(SocketException.class,\n+                    ss::getReceiveBufferSize,\n+                    \"getReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    ss::getReuseAddress,\n+                    \"getReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> ss.setReceiveBufferSize(1024),\n+                    \"setReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> ss.setReuseAddress(false),\n+                    \"setReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> ss.setSoTimeout(1000),\n+                    \"setSoTimeout() when already closed didn't throw SocketException\");\n+        }\n@@ -150,14 +110,2 @@\n-    @ParameterizedTest\n-    @MethodSource(\"noExceptionOperations\")\n-    public void testNoExceptionThrown(final String opName, final ServerSocketOp op)\n-            throws Exception {\n-        try (final ServerSocket ss = new ServerSocket()) {\n-            \/\/ close and then invoke the operation on the ServerSocket\n-            ss.close();\n-            op.apply(ss);\n-        }\n-    }\n-\n-    private static void test(final Class<? extends Exception> expectedExceptionType,\n-                             final boolean exactType,\n-                             final String opName, final ServerSocketOp op) throws Exception {\n+    @Test\n+    public void testNoExceptionThrown() throws Exception {\n@@ -165,1 +113,1 @@\n-            \/\/ close and then invoke the operation on the ServerSocket\n+            \/\/ close and then invoke the operations on the ServerSocket\n@@ -167,9 +115,6 @@\n-            if (exactType) {\n-                assertThrowsExactly(expectedExceptionType,\n-                        () -> op.apply(ss), opName + \" when already closed didn't throw \"\n-                                + expectedExceptionType.getName());\n-            } else {\n-                assertThrows(expectedExceptionType,\n-                        () -> op.apply(ss), opName + \" when already closed didn't throw \"\n-                                + expectedExceptionType.getName());\n-            }\n+            assertTrue(ss.isClosed(), \"ServerSocket isn't closed\");\n+            ss.getInetAddress();\n+            ss.getLocalPort();\n+            ss.getLocalSocketAddress();\n+            ss.isBound();\n+            ss.supportedOptions();\n","filename":"test\/jdk\/java\/net\/ServerSocket\/ClosedServerSocketTest.java","additions":58,"deletions":113,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.stream.Stream;\n@@ -32,3 +31,1 @@\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.api.Test;\n@@ -37,0 +34,1 @@\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -49,144 +47,0 @@\n-    @FunctionalInterface\n-    private interface SocketOp {\n-        void apply(Socket s) throws IOException;\n-    }\n-\n-\n-    static Stream<Arguments> ioExceptionOperations() {\n-        return Stream.of(\n-                Arguments.of(\"bind()\", (SocketOp) s -> {\n-                    s.bind(loopbackEphemeral);\n-                }),\n-                Arguments.of(\"connect()\", (SocketOp) s -> {\n-                    \/\/ connect() will never get to the stage of attempting\n-                    \/\/ a connection against this port\n-                    final int dummyPort = 12345;\n-                    s.connect(new InetSocketAddress(loopback, dummyPort));\n-                }),\n-                Arguments.of(\"connect(SocketAddress, int)\", (SocketOp) s -> {\n-                    \/\/ connect() will never get to the stage of attempting\n-                    \/\/ a connection against this port\n-                    final int dummyPort = 12345;\n-                    s.connect(new InetSocketAddress(loopback, dummyPort), 10);\n-                }),\n-                Arguments.of(\"getOption()\", (SocketOp) s -> {\n-                    var _ = s.getOption(StandardSocketOptions.SO_RCVBUF);\n-                }),\n-                Arguments.of(\"getOutputStream()\", (SocketOp) s -> {\n-                    var _ = s.getOutputStream();\n-                }),\n-                Arguments.of(\"shutdownInput()\", (SocketOp) s -> {\n-                    s.shutdownInput();\n-                }),\n-                Arguments.of(\"shutdownOutput()\", (SocketOp) s -> {\n-                    s.shutdownOutput();\n-                })\n-        );\n-    }\n-\n-    static Stream<Arguments> socketExceptionOperations() {\n-        return Stream.of(\n-                Arguments.of(\"getKeepAlive()\", (SocketOp) s -> {\n-                    var _ = s.getKeepAlive();\n-                }),\n-                Arguments.of(\"getOOBInline()\", (SocketOp) s -> {\n-                    var _ = s.getOOBInline();\n-                }),\n-                Arguments.of(\"getReceiveBufferSize()\", (SocketOp) s -> {\n-                    var _ = s.getReceiveBufferSize();\n-                }),\n-                Arguments.of(\"getReuseAddress()\", (SocketOp) s -> {\n-                    var _ = s.getReuseAddress();\n-                }),\n-                Arguments.of(\"getSendBufferSize()\", (SocketOp) s -> {\n-                    var _ = s.getSendBufferSize();\n-                }),\n-                Arguments.of(\"getSoLinger()\", (SocketOp) s -> {\n-                    var _ = s.getSoLinger();\n-                }),\n-                Arguments.of(\"getSoTimeout()\", (SocketOp) s -> {\n-                    var _ = s.getSoTimeout();\n-                }),\n-                Arguments.of(\"getTcpNoDelay()\", (SocketOp) s -> {\n-                    var _ = s.getTcpNoDelay();\n-                }),\n-                Arguments.of(\"getTrafficClass()\", (SocketOp) s -> {\n-                    var _ = s.getTrafficClass();\n-                }),\n-                Arguments.of(\"setKeepAlive()\", (SocketOp) s -> {\n-                    s.setKeepAlive(false);\n-                }),\n-                Arguments.of(\"setOOBInline()\", (SocketOp) s -> {\n-                    s.setOOBInline(false);\n-                }),\n-                Arguments.of(\"setOption()\", (SocketOp) s -> {\n-                    s.setOption(StandardSocketOptions.SO_RCVBUF, 1024);\n-                }),\n-                Arguments.of(\"setReceiveBufferSize()\", (SocketOp) s -> {\n-                    s.setReceiveBufferSize(1024);\n-                }),\n-                Arguments.of(\"setReuseAddress()\", (SocketOp) s -> {\n-                    s.setReuseAddress(false);\n-                }),\n-                Arguments.of(\"setSendBufferSize()\", (SocketOp) s -> {\n-                    s.setSendBufferSize(1024);\n-                }),\n-                Arguments.of(\"setSoLinger()\", (SocketOp) s -> {\n-                    s.setSoLinger(false, 0);\n-                }),\n-                Arguments.of(\"setSoTimeout()\", (SocketOp) s -> {\n-                    s.setSoTimeout(1000);\n-                }),\n-                Arguments.of(\"setTcpNoDelay()\", (SocketOp) s -> {\n-                    s.setTcpNoDelay(false);\n-                }),\n-                Arguments.of(\"setTrafficClass()\", (SocketOp) s -> {\n-                    s.setTrafficClass(123);\n-                })\n-        );\n-    }\n-\n-    static Stream<Arguments> noExceptionOperations() {\n-        return Stream.of(\n-                Arguments.of(\"close()\", (SocketOp) s -> {\n-                    s.close();\n-                }),\n-                Arguments.of(\"getInetAddress()\", (SocketOp) s -> {\n-                    var _ = s.getInetAddress();\n-                }),\n-                Arguments.of(\"getLocalAddress()\", (SocketOp) s -> {\n-                    var _ = s.getLocalAddress();\n-                }),\n-                Arguments.of(\"getLocalPort()\", (SocketOp) s -> {\n-                    var _ = s.getLocalPort();\n-                }),\n-                Arguments.of(\"getLocalSocketAddress()\", (SocketOp) s -> {\n-                    var _ = s.getLocalSocketAddress();\n-                }),\n-                Arguments.of(\"getPort()\", (SocketOp) s -> {\n-                    var _ = s.getPort();\n-                }),\n-                Arguments.of(\"getRemoteSocketAddress()\", (SocketOp) s -> {\n-                    var _ = s.getRemoteSocketAddress();\n-                }),\n-                Arguments.of(\"isBound()\", (SocketOp) s -> {\n-                    var _ = s.isBound();\n-                }),\n-                Arguments.of(\"isClosed()\", (SocketOp) s -> {\n-                    var _ = s.isClosed();\n-                }),\n-                Arguments.of(\"isConnected()\", (SocketOp) s -> {\n-                    var _ = s.isConnected();\n-                }),\n-                Arguments.of(\"isInputShutdown()\", (SocketOp) s -> {\n-                    var _ = s.isInputShutdown();\n-                }),\n-                Arguments.of(\"isOutputShutdown()\", (SocketOp) s -> {\n-                    var _ = s.isOutputShutdown();\n-                }),\n-                Arguments.of(\"supportedOptions()\", (SocketOp) s -> {\n-                    var _ = s.supportedOptions();\n-                })\n-        );\n-    }\n-\n@@ -197,5 +51,30 @@\n-    @ParameterizedTest\n-    @MethodSource(\"ioExceptionOperations\")\n-    public void testIOExceptionThrown(final String opName, final SocketOp op)\n-            throws Exception {\n-        test(IOException.class, false, opName, op);\n+    @Test\n+    public void testIOExceptionThrown() throws Exception {\n+        try (final Socket s = new Socket()) {\n+            \/\/ close and then invoke the operation on the socket\n+            s.close();\n+            assertTrue(s.isClosed(), \"socket isn't closed\");\n+            assertThrows(IOException.class, () -> s.bind(loopbackEphemeral),\n+                    \"bind() when already closed didn't throw IOException\");\n+            \/\/ connect() will never get to the stage of attempting\n+            \/\/ a connection against this port\n+            final int dummyPort = 12345;\n+            assertThrows(IOException.class,\n+                    () -> s.connect(new InetSocketAddress(loopback, dummyPort)),\n+                    \"connect() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> s.connect(new InetSocketAddress(loopback, dummyPort), 10),\n+                    \"connect(SocketAddress, int) when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> s.getOption(StandardSocketOptions.SO_RCVBUF),\n+                    \"getOption() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    s::getOutputStream,\n+                    \"getOutputStream() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    s::shutdownInput,\n+                    \"shutdownInput() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    s::shutdownOutput,\n+                    \"shutdownOutput() when already closed didn't throw IOException\");\n+        }\n@@ -208,5 +87,64 @@\n-    @ParameterizedTest\n-    @MethodSource(\"socketExceptionOperations\")\n-    public void testSocketExceptionThrown(final String opName, final SocketOp op)\n-            throws Exception {\n-        test(SocketException.class, true, opName, op);\n+    @Test\n+    public void testSocketExceptionThrown() throws Exception {\n+        try (final Socket s = new Socket()) {\n+            \/\/ close and then invoke the operations on the socket\n+            s.close();\n+            assertTrue(s.isClosed(), \"socket isn't closed\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getKeepAlive,\n+                    \"getKeepAlive() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getOOBInline,\n+                    \"getOOBInline() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getReceiveBufferSize,\n+                    \"getReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getReuseAddress,\n+                    \"getReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getSendBufferSize,\n+                    \"getSendBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getSoLinger,\n+                    \"getSoLinger() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getSoTimeout,\n+                    \"getSoTimeout() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getTcpNoDelay,\n+                    \"getTcpNoDelay() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getTrafficClass,\n+                    \"getTrafficClass() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setKeepAlive(false),\n+                    \"setKeepAlive() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setOOBInline(false),\n+                    \"setOOBInline() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setOption(StandardSocketOptions.SO_RCVBUF, 1024),\n+                    \"setOption() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setReceiveBufferSize(1024),\n+                    \"setReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setReuseAddress(false),\n+                    \"setReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setSendBufferSize(1024),\n+                    \"setSendBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setSoLinger(false, 0),\n+                    \"setSoLinger() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setSoTimeout(1000),\n+                    \"setSoTimeout() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setTcpNoDelay(false),\n+                    \"setTcpNoDelay() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setTrafficClass(123),\n+                    \"setTrafficClass() when already closed didn't throw SocketException\");\n+        }\n@@ -219,4 +157,2 @@\n-    @ParameterizedTest\n-    @MethodSource(\"noExceptionOperations\")\n-    public void testNoExceptionThrown(final String opName, final SocketOp op)\n-            throws Exception {\n+    @Test\n+    public void testNoExceptionThrown() throws Exception {\n@@ -224,11 +160,1 @@\n-            \/\/ close and then invoke the operation on the socket\n-            s.close();\n-            op.apply(s);\n-        }\n-    }\n-\n-    private static void test(final Class<? extends Exception> expectedExceptionType,\n-                             final boolean exactType,\n-                             final String opName, final SocketOp op) throws Exception {\n-        try (final Socket s = new Socket()) {\n-            \/\/ close and then invoke the operation on the socket\n+            \/\/ close and then invoke various operation on the socket and don't expect an exception\n@@ -236,9 +162,12 @@\n-            if (exactType) {\n-                assertThrowsExactly(expectedExceptionType,\n-                        () -> op.apply(s), opName + \" when already closed didn't throw \"\n-                                + expectedExceptionType.getName());\n-            } else {\n-                assertThrows(expectedExceptionType,\n-                        () -> op.apply(s), opName + \" when already closed didn't throw \"\n-                                + expectedExceptionType.getName());\n-            }\n+            assertTrue(s.isClosed(), \"socket isn't closed\");\n+            s.getInetAddress();\n+            s.getLocalAddress();\n+            s.getLocalPort();\n+            s.getLocalSocketAddress();\n+            s.getPort();\n+            s.getRemoteSocketAddress();\n+            s.isBound();\n+            s.isConnected();\n+            s.isInputShutdown();\n+            s.isOutputShutdown();\n+            s.supportedOptions();\n","filename":"test\/jdk\/java\/net\/Socket\/ClosedSocketTest.java","additions":111,"deletions":182,"binary":false,"changes":293,"status":"modified"}]}