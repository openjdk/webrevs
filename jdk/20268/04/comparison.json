{"files":[{"patch":"@@ -331,2 +331,2 @@\n-     * @throws  IOException if the bind operation fails, or if the socket\n-     *                     is already bound.\n+     * @throws  IOException if the bind operation fails, the socket\n+     *                      is already bound or the socket is closed.\n@@ -360,2 +360,2 @@\n-     * @throws  IOException if the bind operation fails, or if the socket\n-     *                     is already bound.\n+     * @throws  IOException if the bind operation fails, the socket\n+     *                      is already bound or the socket is closed.\n@@ -521,1 +521,1 @@\n-     *               connection.\n+     *               connection, the socket is not bound or the socket is closed.\n@@ -739,0 +739,3 @@\n+     * <p>Once closed, several of the methods defined by this class will throw\n+     * an exception if invoked on the closed socket.\n+     *\n@@ -809,2 +812,2 @@\n-     * @throws  SocketException if there is an error in the underlying protocol,\n-     *          such as a TCP error\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -827,1 +830,1 @@\n-     * @throws    IOException if an I\/O error occurs\n+     * @throws IOException if an I\/O error occurs or the socket is closed.\n@@ -890,2 +893,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol, such as a TCP error,\n+     *         or the socket is closed.\n@@ -1004,2 +1007,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1032,2 +1035,2 @@\n-     * @throws    SocketException if there is an error\n-     *            in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/ServerSocket.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -686,1 +686,2 @@\n-     * @throws  IOException if an error occurs during the connection\n+     * @throws  IOException if an error occurs during the connection, the socket\n+     *          is already connected or the socket is closed\n@@ -720,1 +721,2 @@\n-     * @throws  IOException if an error occurs during the connection\n+     * @throws  IOException if an error occurs during the connection, the socket\n+     *          is already connected or the socket is closed\n@@ -783,2 +785,2 @@\n-     * @throws  IOException if the bind operation fails, or if the socket\n-     *                     is already bound.\n+     * @throws  IOException if the bind operation fails, the socket\n+     *          is already bound or the socket is closed.\n@@ -1177,2 +1179,2 @@\n-     * @throws     IOException  if an I\/O error occurs when creating the\n-     *               output stream or if the socket is not connected.\n+     * @throws IOException  if an I\/O error occurs when creating the\n+     *         output stream, the socket is not connected or the socket is closed.\n@@ -1254,2 +1256,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1272,2 +1274,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1292,3 +1294,3 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n-     * @throws    IllegalArgumentException if the linger value is negative.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n+     * @throws  IllegalArgumentException if the linger value is negative.\n@@ -1321,2 +1323,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1371,2 +1373,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1390,2 +1392,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1412,2 +1414,2 @@\n-     * @throws  SocketException if there is an error in the underlying protocol,\n-     *          such as a TCP error\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1431,2 +1433,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1458,3 +1460,0 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n-     *\n@@ -1464,2 +1463,3 @@\n-     * @throws    IllegalArgumentException if the\n-     * value is 0 or is negative.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n+     * @throws  IllegalArgumentException if the value is 0 or is negative.\n@@ -1484,2 +1484,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1532,2 +1532,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1553,2 +1553,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1573,2 +1573,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1589,2 +1589,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1640,2 +1640,2 @@\n-     * @throws SocketException if there is an error setting the\n-     * traffic class or type-of-service\n+     * @throws SocketException if there is an error setting the traffic class or type-of-service,\n+     *         or the socket is closed.\n@@ -1664,2 +1664,2 @@\n-     * @throws SocketException if there is an error obtaining the\n-     * traffic class or type-of-service value.\n+     * @throws SocketException if there is an error obtaining the traffic class\n+     *         or type-of-service value, or the socket is closed.\n@@ -1718,2 +1718,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1736,2 +1736,3 @@\n-     * use (i.e. can't be reconnected or rebound). A new socket needs to be\n-     * created.\n+     * use (i.e. can't be reconnected or rebound) and several of the methods defined\n+     * by this class will throw an exception when invoked on the closed socket. A new\n+     * socket needs to be created.\n@@ -1770,2 +1771,2 @@\n-     * @throws    IOException if an I\/O error occurs when shutting down this\n-     * socket.\n+     * @throws IOException if an I\/O error occurs when shutting down this socket, the\n+     *         socket is not connected or the socket is closed.\n@@ -1800,2 +1801,2 @@\n-     * @throws    IOException if an I\/O error occurs when shutting down this\n-     * socket.\n+     * @throws IOException if an I\/O error occurs when shutting down this socket, the socket\n+     *         is not connected or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":51,"deletions":50,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.SocketException;\n+import java.net.StandardSocketOptions;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary verifies that the APIs on java.net.ServerSocket throw expected exceptions\n+ *          when invoked on a closed ServerSocket\n+ * @run junit ClosedServerSocketTest\n+ *\/\n+public class ClosedServerSocketTest {\n+\n+    private static final InetAddress loopback = InetAddress.getLoopbackAddress();\n+    private static final InetSocketAddress loopbackEphemeral = new InetSocketAddress(loopback, 0);\n+\n+    \/**\n+     * Verifies that various operations that specify to throw an IOException on a\n+     * closed ServerSocket, do indeed throw it.\n+     *\/\n+    @Test\n+    public void testIOExceptionThrown() throws Exception {\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            \/\/ close and then invoke the operations on the ServerSocket\n+            ss.close();\n+            assertTrue(ss.isClosed(), \"ServerSocket isn't closed\");\n+            assertThrows(IOException.class,\n+                    ss::accept,\n+                    \"accept() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.bind(loopbackEphemeral),\n+                    \"bind() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.bind(loopbackEphemeral, 10),\n+                    \"bind(SocketAddress, int) when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.getOption(StandardSocketOptions.SO_RCVBUF),\n+                    \"getOption() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    ss::getSoTimeout,\n+                    \"getSoTimeout() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.setOption(StandardSocketOptions.SO_RCVBUF, 1024),\n+                    \"setOption() when already closed didn't throw IOException\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that various operations that specify to throw a SocketOperation on a\n+     * closed ServerSocket, do indeed throw it.\n+     *\/\n+    @Test\n+    public void testSocketExceptionThrown() throws Exception {\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            \/\/ close and then invoke the operations on the ServerSocket\n+            ss.close();\n+            assertTrue(ss.isClosed(), \"ServerSocket isn't closed\");\n+            assertThrowsExactly(SocketException.class,\n+                    ss::getReceiveBufferSize,\n+                    \"getReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    ss::getReuseAddress,\n+                    \"getReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> ss.setReceiveBufferSize(1024),\n+                    \"setReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> ss.setReuseAddress(false),\n+                    \"setReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> ss.setSoTimeout(1000),\n+                    \"setSoTimeout() when already closed didn't throw SocketException\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that various operations that aren't expected to throw an exception on a\n+     * closed ServerSocket, complete normally.\n+     *\/\n+    @Test\n+    public void testNoExceptionThrown() throws Exception {\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            \/\/ close and then invoke the operations on the ServerSocket\n+            ss.close();\n+            assertTrue(ss.isClosed(), \"ServerSocket isn't closed\");\n+            ss.getInetAddress();\n+            ss.getLocalPort();\n+            ss.getLocalSocketAddress();\n+            ss.isBound();\n+            ss.supportedOptions();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/ServerSocket\/ClosedServerSocketTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.StandardSocketOptions;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary verifies that the APIs on java.net.Socket throw expected exceptions\n+ *          when invoked on a closed socket\n+ * @run junit ClosedSocketTest\n+ *\/\n+public class ClosedSocketTest {\n+\n+    private static final InetAddress loopback = InetAddress.getLoopbackAddress();\n+    private static final InetSocketAddress loopbackEphemeral = new InetSocketAddress(loopback, 0);\n+\n+    \/**\n+     * Verifies that various operations that specify to throw an IOException on a closed socket,\n+     * do indeed throw it.\n+     *\/\n+    @Test\n+    public void testIOExceptionThrown() throws Exception {\n+        try (final Socket s = new Socket()) {\n+            \/\/ close and then invoke the operation on the socket\n+            s.close();\n+            assertTrue(s.isClosed(), \"socket isn't closed\");\n+            assertThrows(IOException.class, () -> s.bind(loopbackEphemeral),\n+                    \"bind() when already closed didn't throw IOException\");\n+            \/\/ connect() will never get to the stage of attempting\n+            \/\/ a connection against this port\n+            final int dummyPort = 12345;\n+            assertThrows(IOException.class,\n+                    () -> s.connect(new InetSocketAddress(loopback, dummyPort)),\n+                    \"connect() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> s.connect(new InetSocketAddress(loopback, dummyPort), 10),\n+                    \"connect(SocketAddress, int) when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> s.getOption(StandardSocketOptions.SO_RCVBUF),\n+                    \"getOption() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    s::getOutputStream,\n+                    \"getOutputStream() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    s::shutdownInput,\n+                    \"shutdownInput() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    s::shutdownOutput,\n+                    \"shutdownOutput() when already closed didn't throw IOException\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that various operations that specify to throw a SocketOperation on a closed socket,\n+     * do indeed throw it.\n+     *\/\n+    @Test\n+    public void testSocketExceptionThrown() throws Exception {\n+        try (final Socket s = new Socket()) {\n+            \/\/ close and then invoke the operations on the socket\n+            s.close();\n+            assertTrue(s.isClosed(), \"socket isn't closed\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getKeepAlive,\n+                    \"getKeepAlive() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getOOBInline,\n+                    \"getOOBInline() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getReceiveBufferSize,\n+                    \"getReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getReuseAddress,\n+                    \"getReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getSendBufferSize,\n+                    \"getSendBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getSoLinger,\n+                    \"getSoLinger() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getSoTimeout,\n+                    \"getSoTimeout() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getTcpNoDelay,\n+                    \"getTcpNoDelay() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getTrafficClass,\n+                    \"getTrafficClass() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setKeepAlive(false),\n+                    \"setKeepAlive() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setOOBInline(false),\n+                    \"setOOBInline() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setOption(StandardSocketOptions.SO_RCVBUF, 1024),\n+                    \"setOption() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setReceiveBufferSize(1024),\n+                    \"setReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setReuseAddress(false),\n+                    \"setReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setSendBufferSize(1024),\n+                    \"setSendBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setSoLinger(false, 0),\n+                    \"setSoLinger() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setSoTimeout(1000),\n+                    \"setSoTimeout() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setTcpNoDelay(false),\n+                    \"setTcpNoDelay() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setTrafficClass(123),\n+                    \"setTrafficClass() when already closed didn't throw SocketException\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that various operations that aren't expected to throw an exception on a\n+     * closed socket, complete normally.\n+     *\/\n+    @Test\n+    public void testNoExceptionThrown() throws Exception {\n+        try (final Socket s = new Socket()) {\n+            \/\/ close and then invoke various operation on the socket and don't expect an exception\n+            s.close();\n+            assertTrue(s.isClosed(), \"socket isn't closed\");\n+            s.getInetAddress();\n+            s.getLocalAddress();\n+            s.getLocalPort();\n+            s.getLocalSocketAddress();\n+            s.getPort();\n+            s.getRemoteSocketAddress();\n+            s.isBound();\n+            s.isConnected();\n+            s.isInputShutdown();\n+            s.isOutputShutdown();\n+            s.supportedOptions();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ClosedSocketTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"}]}