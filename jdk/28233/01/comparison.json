{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import java.util.concurrent.Executor;\n@@ -711,1 +710,2 @@\n-                                Throwable t = c.getRecordedCause();\n+                                final Throwable terminationException = c.getTerminationException()\n+                                        .orElse(null);\n@@ -713,4 +713,3 @@\n-                                if (t != null) {\n-                                    if (!cached)\n-                                        c.close();\n-                                    ioe = new IOException(\"Can't get stream 1: \" + t, t);\n+                                if (terminationException != null) {\n+                                    ioe = new IOException(\"Can't get stream 1: \" + terminationException,\n+                                            terminationException);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.EOFException;\n@@ -237,1 +236,0 @@\n-    private EOFException STOPPED;\n@@ -240,2 +238,0 @@\n-        STOPPED = new EOFException(\"HTTP\/2 client stopped\");\n-        STOPPED.setStackTrace(new StackTraceElement[0]);\n@@ -256,1 +252,0 @@\n-        \/\/ send GOAWAY\n@@ -258,2 +253,0 @@\n-        \/\/ attempt graceful shutdown\n-        try { h2c.shutdown(STOPPED); } catch (Throwable t) {}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.Closeable;\n@@ -31,2 +32,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -39,0 +38,1 @@\n+import java.nio.channels.NetworkChannel;\n@@ -40,2 +40,0 @@\n-import java.util.ArrayList;\n-import java.net.http.HttpConnectTimeoutException;\n@@ -43,0 +41,1 @@\n+import java.util.ArrayList;\n@@ -48,0 +47,1 @@\n+import java.util.Optional;\n@@ -52,0 +52,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -59,0 +60,1 @@\n+\n@@ -133,1 +135,1 @@\n-class Http2Connection  {\n+class Http2Connection implements Closeable {\n@@ -146,0 +148,2 @@\n+    private final AtomicBoolean goAwaySent = new AtomicBoolean();\n+    private final AtomicBoolean goAwayRecvd = new AtomicBoolean();\n@@ -218,1 +222,1 @@\n-         * {@link #shutdown(Throwable) Shuts down} the connection, unless this event is\n+         * {@link #close(Http2TerminationCause) Closes} the connection, unless this event is\n@@ -231,8 +235,1 @@\n-                        debug.log(\"Not initiating idle connection shutdown\");\n-                    }\n-                    return;\n-                }\n-                if (!markIdleShutdownInitiated()) {\n-                    if (debug.on()) {\n-                        debug.log(\"Unexpected state %s, skipping idle connection shutdown\",\n-                                describeClosedState(closedState));\n+                        debug.log(\"Not initiating idle connection close\");\n@@ -242,0 +239,5 @@\n+                \/\/ the connection has been idle long enough, we now\n+                \/\/ mark a state indicating that the connection is chosen\n+                \/\/ for idle termination and should not be handed out (from the pool)\n+                \/\/ for newer requests.\n+                connTerminator.markForIdleTermination();\n@@ -245,6 +247,2 @@\n-            if (debug.on()) {\n-                debug.log(\"Initiating shutdown of HTTP connection which is idle for too long\");\n-            }\n-            HttpConnectTimeoutException hte = new HttpConnectTimeoutException(\n-                    \"HTTP connection idle, no active streams. Shutting down.\");\n-            shutdown(hte);\n+            \/\/ terminate the connection due to being idle long enough\n+            connTerminator.idleTimedOut();\n@@ -259,1 +257,1 @@\n-            \/\/ doing the shutdown\n+            \/\/ doing the close\n@@ -379,6 +377,0 @@\n-    private static final int HALF_CLOSED_LOCAL  = 1;\n-    private static final int HALF_CLOSED_REMOTE = 2;\n-    private static final int SHUTDOWN_REQUESTED = 4;\n-    \/\/ state when idle connection management initiates a shutdown of the connection, after\n-    \/\/ which the connection will go into SHUTDOWN_REQUESTED state\n-    private static final int IDLE_SHUTDOWN_INITIATED = 8;\n@@ -386,3 +378,0 @@\n-    private volatile int closedState;\n-\n-    \/\/-------------------------------------\n@@ -406,0 +395,1 @@\n+\n@@ -407,0 +397,1 @@\n+\n@@ -421,1 +412,1 @@\n-    private final AtomicReference<Throwable> cause = new AtomicReference<>();\n+    private final Terminator connTerminator = new Terminator();\n@@ -643,1 +634,0 @@\n-        boolean shouldClose = false;\n@@ -648,3 +638,0 @@\n-            if (finalStream && reserved == 0 && streams.isEmpty()) {\n-                shouldClose = true;\n-            }\n@@ -652,1 +639,1 @@\n-            shutdown(t); \/\/ in case the assert fires...\n+            close(Http2TerminationCause.forException(t)); \/\/ in case the assert fires...\n@@ -657,7 +644,3 @@\n-        \/\/ We should close the connection here if\n-        \/\/ it's not pooled. If it's not pooled it will\n-        \/\/ be marked final stream, reserved will be 0\n-        \/\/ after decrementing it by one, and there should\n-        \/\/ be no active request-response streams.\n-        if (shouldClose) {\n-            shutdown(new IOException(\"HTTP\/2 connection abandoned\"));\n+        \/\/ if the connection is eligible to be closed, we close it here\n+        if (shouldClose()) {\n+            close(Http2TerminationCause.noErrorTermination());\n@@ -665,1 +648,0 @@\n-\n@@ -668,1 +650,6 @@\n-    boolean shouldClose() {\n+    \/*\n+     * return true if the connection is marked as \"final stream\" and there\n+     * are no active streams on that connection and the connection isn't\n+     * reserved for a new stream.\n+     *\/\n+    final boolean shouldClose() {\n@@ -671,1 +658,1 @@\n-            return finalStream() && streams.isEmpty();\n+            return finalStream() && streams.isEmpty() && numReservedClientStreams == 0;\n@@ -843,15 +830,0 @@\n-    void close() {\n-        if (markHalfClosedLocal()) {\n-            \/\/ we send a GOAWAY frame only if the remote side hasn't already indicated\n-            \/\/ the intention to close the connection by previously sending a GOAWAY of its own\n-            if (connection.channel().isOpen() && !isMarked(closedState, HALF_CLOSED_REMOTE)) {\n-                Log.logTrace(\"Closing HTTP\/2 connection: to {0}\", connection.address());\n-                GoAwayFrame f = new GoAwayFrame(0,\n-                        ErrorFrame.NO_ERROR,\n-                        \"Requested by user\".getBytes(UTF_8));\n-                \/\/ TODO: set last stream. For now zero ok.\n-                sendFrame(f);\n-            }\n-        }\n-    }\n-\n@@ -859,0 +831,1 @@\n+\n@@ -907,1 +880,1 @@\n-            shutdown(e);\n+            close(Http2TerminationCause.forException(e));\n@@ -911,2 +884,24 @@\n-    Throwable getRecordedCause() {\n-        return cause.get();\n+    \/**\n+     * Returns the exception which caused the connection to be terminated. Even a normal termination\n+     * of a connection will have a {@code IOException} associated with it.\n+     * If the connection hasn't yet been terminated then this method returns an empty Optional.\n+     *\/\n+    final Optional<IOException> getTerminationException() {\n+        final Http2TerminationCause terminationCause = this.connTerminator.getTerminationCause();\n+        if (terminationCause != null) {\n+            return Optional.of(terminationCause.getCloseCause());\n+        }\n+        \/\/ there can be window of race where the termination cause isn't yet set\n+        \/\/ but the connection isn't open. that can happen when the underlying SocketChannel\n+        \/\/ is closed behind the scenes and the Http2Connection isn't aware of it and hasn't\n+        \/\/ set a termination cause for it.\n+        \/\/ so here we check if the connection isn't open and if it isn't then we call\n+        \/\/ Terminator.getTerminationCause() which has the necessary infrastructure to create\n+        \/\/ and return a termination cause for that situation.\n+        if (!isOpen()) {\n+            final Http2TerminationCause tc = this.connTerminator.getTerminationCause();\n+            assert tc != null : \"termination cause is null for a closed connection\";\n+            return Optional.of(tc.getCloseCause());\n+        }\n+        \/\/ connection isn't terminated\n+        return Optional.empty();\n@@ -915,10 +910,7 @@\n-    void shutdown(Throwable t) {\n-        int state = closedState;\n-        if (debug.on()) debug.log(() -> \"Shutting down h2c (state=\"+describeClosedState(state)+\"): \" + t);\n-        stateLock.lock();\n-        try {\n-            if (!markShutdownRequested()) return;\n-            cause.compareAndSet(null, t);\n-        } finally {\n-            stateLock.unlock();\n-        }\n+    \/**\n+     * Closes the connection normally (with a NO_ERROR termination cause), if not already closed.\n+     *\/\n+    @Override\n+    public final void close() {\n+        close(Http2TerminationCause.noErrorTermination());\n+    }\n@@ -926,19 +918,8 @@\n-        if (Log.errors()) {\n-            if (t!= null && (!(t instanceof EOFException) || isActive())) {\n-                Log.logError(t);\n-            } else if (t != null) {\n-                Log.logError(\"Shutting down connection: {0}\", t.getMessage());\n-            } else {\n-                Log.logError(\"Shutting down connection\");\n-            }\n-        }\n-        client2.removeFromPool(this);\n-        subscriber.stop(cause.get());\n-        for (Stream<?> s : streams.values()) {\n-            try {\n-                s.connectionClosing(t);\n-            } catch (Throwable e) {\n-                Log.logError(\"Failed to close stream {0}: {1}\", s.streamid, e);\n-            }\n-        }\n-        connection.close(cause.get());\n+    \/**\n+     * Closes the connection with the given termination cause, if not already closed.\n+     *\n+     * @param tc the termination cause. cannot be null.\n+     *\/\n+    final void close(final Http2TerminationCause tc) {\n+        Objects.requireNonNull(tc, \"termination cause cannot be null\");\n+        this.connTerminator.terminate(tc);\n@@ -984,1 +965,1 @@\n-                framesDecoder.close(\n+                protocolError(ErrorFrame.PROTOCOL_ERROR,\n@@ -986,1 +967,0 @@\n-                protocolError(GoAwayFrame.PROTOCOL_ERROR);\n@@ -992,1 +972,1 @@\n-                protocolError(ResetFrame.PROTOCOL_ERROR, protocolError);\n+                protocolError(ErrorFrame.PROTOCOL_ERROR, protocolError);\n@@ -1147,1 +1127,3 @@\n-        if (isMarked(closedState, SHUTDOWN_REQUESTED)) return;\n+        if (!isOpen()) {\n+            return;\n+        }\n@@ -1157,1 +1139,3 @@\n-            if (isMarked(closedState, SHUTDOWN_REQUESTED)) return;\n+            if (!isOpen()) {\n+                return;\n+            }\n@@ -1254,1 +1238,1 @@\n-            default -> protocolError(ErrorFrame.PROTOCOL_ERROR);\n+            default -> protocolError(ErrorFrame.PROTOCOL_ERROR, \"unknown frame: \" + frame);\n@@ -1258,2 +1242,6 @@\n-    boolean isOpen() {\n-        return !isMarkedForShutdown() && connection.channel().isOpen();\n+    \/**\n+     * Returns true if this connection hasn't been terminated and the underlying\n+     * {@linkplain NetworkChannel#isOpen() channel is open}. false otherwise.\n+     *\/\n+    final boolean isOpen() {\n+        return this.connTerminator.terminationCause.get() == null && connection.channel().isOpen();\n@@ -1298,0 +1286,1 @@\n+\n@@ -1349,2 +1338,1 @@\n-        if (finalStream() && streams.isEmpty()) {\n-            \/\/ should be only 1 stream, but there might be more if server push\n+        if (shouldClose()) {\n@@ -1375,3 +1363,1 @@\n-    private void handleWindowUpdate(WindowUpdateFrame f)\n-        throws IOException\n-    {\n+    private void handleWindowUpdate(WindowUpdateFrame f) {\n@@ -1386,1 +1372,1 @@\n-                protocolError(ErrorFrame.FLOW_CONTROL_ERROR);  \/\/ overflow\n+                protocolError(ErrorFrame.FLOW_CONTROL_ERROR, null);  \/\/ overflow\n@@ -1391,21 +1377,5 @@\n-    private void protocolError(int errorCode)\n-        throws IOException\n-    {\n-        protocolError(errorCode, null);\n-    }\n-\n-    private void protocolError(int errorCode, String msg)\n-        throws IOException\n-    {\n-        String protocolError = \"protocol error\" + (msg == null?\"\":(\": \" + msg));\n-        ProtocolException protocolException =\n-                new ProtocolException(protocolError);\n-        this.cause.compareAndSet(null, protocolException);\n-        if (markHalfClosedLocal()) {\n-            framesDecoder.close(protocolError);\n-            subscriber.stop(protocolException);\n-            if (debug.on()) debug.log(\"Sending GOAWAY due to \" + protocolException);\n-            GoAwayFrame frame = new GoAwayFrame(0, errorCode);\n-            sendFrame(frame);\n-        }\n-        shutdown(protocolException);\n+    private void protocolError(final int errorCode, final String msg) {\n+        final Http2TerminationCause terminationCause =\n+                Http2TerminationCause.forH2Error(errorCode, msg);\n+        framesDecoder.close(terminationCause.getLogMsg());\n+        close(terminationCause);\n@@ -1414,3 +1384,1 @@\n-    private void handleSettings(SettingsFrame frame)\n-        throws IOException\n-    {\n+    private void handleSettings(SettingsFrame frame) {\n@@ -1433,3 +1401,1 @@\n-    private void handlePing(PingFrame frame)\n-        throws IOException\n-    {\n+    private void handlePing(PingFrame frame) {\n@@ -1445,1 +1411,1 @@\n-        markHalfClosedRemote();\n+        goAwayRecvd.set(true);\n@@ -1602,4 +1568,4 @@\n-            cancelIdleShutdownEvent();\n-            \/\/ consider the reservation successful only if the connection's state hasn't moved\n-            \/\/ to \"being closed\"\n-            return isOpen();\n+            cancelIdleCloseEvent();\n+            \/\/ consider the reservation successful only if the connection is open and\n+            \/\/ hasn't been chosen for idle termination\n+            return !this.connTerminator.isMarkedForIdleTermination() && isOpen();\n@@ -1612,1 +1578,1 @@\n-     * Cancels any event that might have been scheduled to shutdown this connection. Must be called\n+     * Cancels any event that might have been scheduled to close this connection. Must be called\n@@ -1615,1 +1581,1 @@\n-    private void cancelIdleShutdownEvent() {\n+    private void cancelIdleCloseEvent() {\n@@ -1630,1 +1596,1 @@\n-            if (!isMarkedForShutdown()) {\n+            if (isOpen() && !this.connTerminator.isMarkedForIdleTermination()) {\n@@ -1636,1 +1602,2 @@\n-                cancelIdleShutdownEvent();\n+                \/\/ don't consider the connection idle anymore\n+                cancelIdleCloseEvent();\n@@ -1643,1 +1610,3 @@\n-        stream.cancel(new IOException(\"Stream \" + streamid + \" cancelled\", cause.get()));\n+        final Http2TerminationCause terminationCause = this.connTerminator.getTerminationCause();\n+        assert terminationCause != null : \"termination cause is null\";\n+        stream.cancel(new IOException(\"Stream \" + streamid + \" cancelled\", terminationCause.getCloseCause()));\n@@ -1746,5 +1715,4 @@\n-            if (isMarked(closedState, SHUTDOWN_REQUESTED)) {\n-                cause = this.cause.get();\n-                if (cause == null) {\n-                    cause = new IOException(\"Connection closed\");\n-                }\n+            if (!isOpen()) {\n+                final Http2TerminationCause terminationCause = this.connTerminator.getTerminationCause();\n+                assert terminationCause != null : \"termination cause is null\";\n+                cause = terminationCause.getCloseCause();\n@@ -1765,1 +1733,1 @@\n-            if (finalStream() && streams.isEmpty()) {\n+            if (shouldClose()) {\n@@ -1798,7 +1766,4 @@\n-            if (!isMarked(closedState, SHUTDOWN_REQUESTED)) {\n-                if (!client2.stopping()) {\n-                    Log.logError(e);\n-                    shutdown(e);\n-                } else if (debug.on()) {\n-                    debug.log(\"Failed to send %s while stopping: %s\", frame, e);\n-                }\n+            if (!client2.stopping()) {\n+                Log.logError(e);\n+            } else if (debug.on()) {\n+                debug.log(\"Failed to send %s while stopping: %s\", frame, e);\n@@ -1806,0 +1771,1 @@\n+            close(Http2TerminationCause.forException(e));\n@@ -1820,7 +1786,4 @@\n-            if (!isMarked(closedState, SHUTDOWN_REQUESTED)) {\n-                if (!client2.stopping()) {\n-                    Log.logError(e);\n-                    shutdown(e);\n-                } else if (debug.on()) {\n-                    debug.log(\"Failed to send %s while stopping: %s\", frame, e);\n-                }\n+            if (!client2.stopping()) {\n+                Log.logError(e);\n+            } else if (debug.on()) {\n+                debug.log(\"Failed to send %s while stopping: %s\", frame, e);\n@@ -1828,0 +1791,1 @@\n+            close(Http2TerminationCause.forException(e));\n@@ -1842,1 +1806,1 @@\n-            if (!isMarked(closedState, SHUTDOWN_REQUESTED)) {\n+            if (!client2.stopping()) {\n@@ -1844,1 +1808,2 @@\n-                shutdown(e);\n+            } else if (debug.on()) {\n+                debug.log(\"Failed to send %s while stopping: %s\", frame, e);\n@@ -1846,0 +1811,1 @@\n+            close(Http2TerminationCause.forException(e));\n@@ -1871,0 +1837,1 @@\n+                    assert buffer != null : \"null buffer obtained from non-empty queue\";\n@@ -1880,1 +1847,6 @@\n-                if (x != null) {\n+                \/\/ if there was any error or if the TubeSubscriber completed normally,\n+                \/\/ then close the connection\n+                if (x != null || completed) {\n+                    \/\/ although the connection terminator stops the scheduler too,\n+                    \/\/ we don't want to wait that \"long\" and instead we should immediately\n+                    \/\/ stop the scheduler so that we don't enter \"processQueue\" anymore.\n@@ -1891,1 +1863,5 @@\n-                    Http2Connection.this.shutdown(x);\n+                    \/\/ terminate the connection\n+                    final Http2TerminationCause tc = (x != null)\n+                            ? Http2TerminationCause.forException(x)\n+                            : Http2TerminationCause.noErrorTermination();\n+                    Http2Connection.this.close(tc);\n@@ -1941,5 +1917,11 @@\n-            String msg = isActive()\n-                    ? \"EOF reached while reading\"\n-                    : \"Idle connection closed by HTTP\/2 peer\";\n-            if (debug.on()) debug.log(msg);\n-            errorRef.compareAndSet(null, new EOFException(msg));\n+            if (isActive()) {\n+                final String msg = \"EOF reached while reading\";\n+                errorRef.compareAndSet(null, new EOFException(msg));\n+                if (debug.on()) {\n+                    debug.log(msg);\n+                }\n+            } else {\n+                if (debug.on()) {\n+                    debug.log(\"HTTP\/2 connection (with no active streams) closed by peer\");\n+                }\n+            }\n@@ -1958,9 +1940,5 @@\n-        void stop(Throwable error) {\n-            if (errorRef.compareAndSet(null, error)) {\n-                completed = true;\n-                scheduler.stop();\n-                queue.clear();\n-                if (subscription != null) {\n-                    subscription.cancel();\n-                }\n-                queue.clear();\n+        private void close() {\n+            scheduler.stop();\n+            queue.clear();\n+            if (subscription != null) {\n+                subscription.cancel();\n@@ -1968,0 +1946,1 @@\n+            queue.clear();\n@@ -1993,0 +1972,1 @@\n+\n@@ -2007,7 +1987,3 @@\n-                try {\n-                    connection.protocolError(ErrorFrame.FLOW_CONTROL_ERROR,\n-                            \"connection window exceeded (%s > %s)\"\n-                                    .formatted(received, windowSize));\n-                } catch (IOException io) {\n-                    connection.shutdown(io);\n-                }\n+                connection.protocolError(ErrorFrame.FLOW_CONTROL_ERROR,\n+                        \"connection window exceeded (%s > %s)\"\n+                                .formatted(received, windowSize));\n@@ -2036,16 +2012,13 @@\n-    private boolean isMarked(int state, int mask) {\n-        return (state & mask) == mask;\n-    }\n-\n-    private boolean isMarkedForShutdown() {\n-        final int closedSt = closedState;\n-        return isMarked(closedSt, IDLE_SHUTDOWN_INITIATED)\n-                || isMarked(closedSt, SHUTDOWN_REQUESTED);\n-    }\n-\n-    private boolean markShutdownRequested() {\n-        return markClosedState(SHUTDOWN_REQUESTED);\n-    }\n-\n-    private boolean markHalfClosedLocal() {\n-        return markClosedState(HALF_CLOSED_LOCAL);\n+    private void sendGoAway(final GoAwayFrame goAway) {\n+        \/\/ currently we send a GOAWAY just once irrespective of what value the\n+        \/\/ last stream id was in the GOAWAY frame\n+        if (!goAwaySent.compareAndSet(false, true)) {\n+            \/\/ already sent\n+            return;\n+        }\n+        Log.logTrace(\"{0} sending GOAWAY {1}\", connection, goAway);\n+        if (debug.on()) {\n+            debug.log(\"sending GOAWAY \" + goAway);\n+        }\n+        \/\/ this merely enqueues the frame\n+        sendFrame(goAway);\n@@ -2054,3 +2027,8 @@\n-    private boolean markHalfClosedRemote() {\n-        return markClosedState(HALF_CLOSED_REMOTE);\n-    }\n+    \/\/ Responsible for doing all the necessary work for closing a Http2Connection\n+    private final class Terminator {\n+        \/\/ the cause for closing the connection. Must only be set in the\n+        \/\/ Terminator.terminate(Http2TerminationCause) method.\n+        private final AtomicReference<Http2TerminationCause> terminationCause = new AtomicReference<>();\n+        \/\/ true if it has been decided to terminate the connection due to being idle,\n+        \/\/ false otherwise. should be accessed only when holding the stateLock\n+        private boolean chosenForIdleTermination;\n@@ -2058,3 +2036,19 @@\n-    private boolean markIdleShutdownInitiated() {\n-        return markClosedState(IDLE_SHUTDOWN_INITIATED);\n-    }\n+        private void terminate(final Http2TerminationCause terminationCause) {\n+            Objects.requireNonNull(terminationCause, \"termination cause cannot be null\");\n+            \/\/ allow to be terminated only once\n+            stateLock.lock();\n+            try {\n+                final boolean success = this.terminationCause.compareAndSet(null, terminationCause);\n+                if (!success) {\n+                    \/\/ already terminated or is being terminated by some other thread\n+                    return;\n+                }\n+                \/\/ disable the idle timeout event, since we are now going to terminate the\n+                \/\/ connection\n+                Http2Connection.this.cancelIdleCloseEvent();\n+            } finally {\n+                stateLock.unlock();\n+            }\n+            \/\/ do the actual termination\n+            doTerminate();\n+        }\n@@ -2062,9 +2056,18 @@\n-    private boolean markClosedState(int flag) {\n-        int state, desired;\n-        do {\n-            state = desired = closedState;\n-            if ((state & flag) == flag) return false;\n-            desired = state | flag;\n-        } while (!CLOSED_STATE.compareAndSet(this, state, desired));\n-        return true;\n-    }\n+        private void doTerminate() {\n+            final Http2TerminationCause tc = terminationCause.get();\n+            assert tc != null : \"missing termination cause\";\n+            \/\/ we send a GOAWAY frame only if the remote side hasn't already indicated\n+            \/\/ the intention to close the connection by previously sending a GOAWAY of its own\n+            if (!Http2Connection.this.goAwayRecvd.get()) {\n+                final int lastStream = 0; \/\/ TODO: set last stream. For now zero is ok.\n+                final String peerVisibleReason = tc.getPeerVisibleReason();\n+                final GoAwayFrame goAway;\n+                if (peerVisibleReason == null) {\n+                    goAway = new GoAwayFrame(lastStream, tc.getCloseCode());\n+                } else {\n+                    goAway = new GoAwayFrame(lastStream, tc.getCloseCode(),\n+                            peerVisibleReason.getBytes(UTF_8));\n+                }\n+                sendGoAway(goAway);\n+            }\n+            \/\/ now close the connection\n@@ -2072,8 +2075,24 @@\n-    String describeClosedState(int state) {\n-        if (state == 0) return \"active\";\n-        String desc = null;\n-        if (isMarked(state, IDLE_SHUTDOWN_INITIATED)) {\n-            desc = \"idle-shutdown-initiated\";\n-        }\n-        if (isMarked(state, SHUTDOWN_REQUESTED)) {\n-            desc = desc == null ? \"shutdown\" : desc + \"+shutdown\";\n+            if (Log.errors()) {\n+                Log.logError(\"Closing connection due to: {0}\", tc);\n+            } else {\n+                if (debug.on()) {\n+                    final String stateStr = \"Erroneous close=\" + tc.isErroneousClose() +\n+                            \", has active streams=\" + isActive() +\n+                            \", GOAWAY received=\" + goAwayRecvd.get() +\n+                            \", GOAWAY sent=\" + goAwaySent.get();\n+                    debug.log(\"Closing connection (\" + stateStr + \") due to: \" + tc);\n+                }\n+            }\n+            \/\/ close the TubeSubscriber\n+            subscriber.close();\n+            client2.removeFromPool(Http2Connection.this);\n+            \/\/ notify the HTTP\/2 streams of the connection closure\n+            for (final Stream<?> s : streams.values()) {\n+                try {\n+                    s.connectionClosing(tc.getCloseCause());\n+                } catch (Throwable e) {\n+                    Log.logError(\"Failed to close stream {0}: {1}\", s.streamid, e);\n+                }\n+            }\n+            \/\/ close the underlying connection\n+            connection.close(tc.getCloseCause());\n@@ -2081,3 +2100,5 @@\n-        if (isMarked(state, HALF_CLOSED_LOCAL | HALF_CLOSED_REMOTE)) {\n-            if (desc == null) return \"closed\";\n-            else return desc + \"+closed\";\n+\n+        private void markForIdleTermination() {\n+            assert stateLock.isHeldByCurrentThread() : Thread.currentThread()\n+                    + \" not holding stateLock\";\n+            this.chosenForIdleTermination = true;\n@@ -2085,3 +2106,5 @@\n-        if (isMarked(state, HALF_CLOSED_LOCAL)) {\n-            if (desc == null) return \"half-closed-local\";\n-            else return desc + \"+half-closed-local\";\n+\n+        private boolean isMarkedForIdleTermination() {\n+            assert stateLock.isHeldByCurrentThread() : Thread.currentThread()\n+                    + \" not holding stateLock\";\n+            return this.chosenForIdleTermination;\n@@ -2089,3 +2112,6 @@\n-        if (isMarked(state, HALF_CLOSED_REMOTE)) {\n-            if (desc == null) return \"half-closed-remote\";\n-            else return desc + \"+half-closed-remote\";\n+\n+        private void idleTimedOut() {\n+            if (debug.on()) {\n+                debug.log(\"closing connection due to being idle\");\n+            }\n+            this.terminate(Http2TerminationCause.idleTimedOut());\n@@ -2093,2 +2119,0 @@\n-        return \"0x\" + Integer.toString(state, 16);\n-    }\n@@ -2096,6 +2120,20 @@\n-    private static final VarHandle CLOSED_STATE;\n-    static {\n-        try {\n-            CLOSED_STATE = MethodHandles.lookup().findVarHandle(Http2Connection.class, \"closedState\", int.class);\n-        } catch (Exception x) {\n-            throw new ExceptionInInitializerError(x);\n+        \/**\n+         * Returns the termination cause for the connection. This method guarantees\n+         * that if the {@linkplain Http2Connection#isOpen() connection is not open}\n+         * then this returns a non-null termination cause.\n+         *\/\n+        private Http2TerminationCause getTerminationCause() {\n+            final Http2TerminationCause tc = this.terminationCause.get();\n+            if (tc != null) {\n+                return tc;\n+            }\n+            if (!connection.channel().isOpen()) {\n+                \/\/ if the underlying SocketChannel isn't open, then terminate the connection.\n+                \/\/ that way when Http2Connection.isOpen() returns false in that situation, then this\n+                \/\/ getTerminationCause() will return a termination cause.\n+                terminate(Http2TerminationCause.forException(new IOException(\"channel is not open\")));\n+                final Http2TerminationCause terminated = this.terminationCause.get();\n+                assert terminated != null : \"missing termination cause\";\n+                return terminated;\n+            }\n+            return null;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":283,"deletions":245,"binary":false,"changes":528,"status":"modified"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.net.http;\n+\n+\n+import java.io.IOException;\n+import java.net.ProtocolException;\n+import java.util.Objects;\n+\n+import jdk.internal.net.http.frame.ErrorFrame;\n+\n+\/**\n+ * Termination cause for a {@linkplain Http2Connection HTTP\/2 connection}\n+ *\/\n+public abstract sealed class Http2TerminationCause {\n+    private String logMsg;\n+    private String peerVisibleReason;\n+    private final int closeCode;\n+    private final Throwable originalCause;\n+    private final IOException reportedCause;\n+\n+    private Http2TerminationCause(final int closeCode, final Throwable closeCause) {\n+        this.closeCode = closeCode;\n+        this.originalCause = closeCause;\n+        if (closeCause != null) {\n+            this.logMsg = closeCause.toString();\n+        }\n+        this.reportedCause = toReportedCause(this.originalCause, this.logMsg);\n+    }\n+\n+    private Http2TerminationCause(final int closeCode, final String loggedAs) {\n+        this.closeCode = closeCode;\n+        this.originalCause = null;\n+        this.logMsg = loggedAs;\n+        this.reportedCause = toReportedCause(null, this.logMsg);\n+    }\n+\n+    \/**\n+     * Returns the error code (specified for HTTP\/2 ErrorFrame) that caused the\n+     * connection termination.\n+     *\/\n+    public final int getCloseCode() {\n+        return this.closeCode;\n+    }\n+\n+    \/**\n+     * Returns the IOException that is considered the cause of the connection termination.\n+     * Even a normal {@linkplain #isErroneousClose() non-erroneous} termination will have\n+     * a IOException associated with it, so this method will always return a non-null instance.\n+     *\/\n+    public final IOException getCloseCause() {\n+        return this.reportedCause;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the connection was terminated due to some exception. {@code false}\n+     * otherwise.\n+     * A normal connection termination (for example, the connection idle timing out locally)\n+     * is not considered as an erroneous termination and this method returns {@code false} for\n+     * such cases.\n+     *\/\n+    public abstract boolean isErroneousClose();\n+\n+    \/**\n+     * Returns the connection termination cause, represented as a string. Unlike the\n+     * {@linkplain #getPeerVisibleReason() peer-visible reason}, this log message will not be\n+     * sent across to the peer and it is thus allowed to include additional details that might\n+     * help debugging a connection termination.\n+     *\/\n+    public final String getLogMsg() {\n+        return logMsg;\n+    }\n+\n+    \/**\n+     * Returns the connection termination cause, represented as a string. This represents the\n+     * \"debugData\" that is sent to the peer in a\n+     * {@linkplain  jdk.internal.net.http.frame.GoAwayFrame GOAWAY frame}.\n+     *\/\n+    public final String getPeerVisibleReason() {\n+        return this.peerVisibleReason;\n+    }\n+\n+    \/**\n+     * Sets the connection termination cause, represented as a string, which will be sent\n+     * to the peer in a {@linkplain  jdk.internal.net.http.frame.GoAwayFrame GOAWAY frame}.\n+     * Unlike the {@link #getLogMsg() log message},\n+     * it is expected that this peer-visible reason will not contain anything that is not meant\n+     * to be viewed by the peer.\n+     *\/\n+    protected final void setPeerVisibleReason(final String reasonPhrase) {\n+        this.peerVisibleReason = reasonPhrase;\n+    }\n+\n+    \/**\n+     * Returns a connection termination cause that represents an\n+     * {@linkplain #isErroneousClose() erroneous} termination due to the given {@code cause}.\n+     *\n+     * @param cause the termination cause, cannot be null.\n+     *\/\n+    public static Http2TerminationCause forException(final Throwable cause) {\n+        Objects.requireNonNull(cause);\n+        if (cause instanceof ProtocolException pe) {\n+            return new ProtocolError(pe);\n+        }\n+        return new InternalError(cause);\n+    }\n+\n+    \/**\n+     * Returns a connection termination cause that represents a normal\n+     * {@linkplain #isErroneousClose() non-erroneous} termination.\n+     *\/\n+    public static Http2TerminationCause noErrorTermination() {\n+        return NoError.INSTANCE;\n+    }\n+\n+    \/**\n+     * Returns a connection termination cause that represents a normal\n+     * {@linkplain #isErroneousClose() non-erroneous} termination due to the connection\n+     * being idle.\n+     *\/\n+    public static Http2TerminationCause idleTimedOut() {\n+        return new NoError(\"HTTP\/2 connection idle timed out\", \"idle timed out\");\n+    }\n+\n+    \/**\n+     * Returns a connection termination cause that represents an\n+     * {@linkplain #isErroneousClose() erroneous} termination due to the given {@code errorCode}.\n+     * Although this method does no checks for the {@code errorCode}, it is expected to be one\n+     * of the error codes specified by the HTTP\/2 RFC for the ErrorFrame.\n+     *\n+     * @param errorCode the error code\n+     * @param loggedAs  optional log message to be associated with this termination cause\n+     *\/\n+    public static Http2TerminationCause forH2Error(final int errorCode, final String loggedAs) {\n+        if (errorCode == ErrorFrame.PROTOCOL_ERROR) {\n+            return new ProtocolError(loggedAs);\n+        } else if (errorCode == ErrorFrame.FLOW_CONTROL_ERROR) {\n+            \/\/ we treat flow control error as a protocol error currently\n+            return new ProtocolError(loggedAs, true);\n+        }\n+        return new H2StandardError(errorCode, loggedAs);\n+    }\n+\n+    private static IOException toReportedCause(final Throwable original,\n+                                               final String fallbackExceptionMsg) {\n+        if (original == null) {\n+            return fallbackExceptionMsg == null\n+                    ? new IOException(\"connection terminated\")\n+                    : new IOException(fallbackExceptionMsg);\n+        } else if (original instanceof IOException ioe) {\n+            return ioe;\n+        } else {\n+            return new IOException(original);\n+        }\n+    }\n+\n+    private static final class NoError extends Http2TerminationCause {\n+        private static final IOException NO_ERROR_MARKER =\n+                new IOException(\"HTTP\/2 connection closed normally - no error\");\n+\n+        static {\n+            \/\/ remove the stacktrace from this marker exception instance\n+            NO_ERROR_MARKER.setStackTrace(new StackTraceElement[0]);\n+        }\n+\n+        private static final NoError INSTANCE = new NoError();\n+\n+        private NoError() {\n+            super(ErrorFrame.NO_ERROR, NO_ERROR_MARKER);\n+            setPeerVisibleReason(\"no error\");\n+        }\n+\n+        private NoError(final String loggedAs, final String peerVisibleReason) {\n+            super(ErrorFrame.NO_ERROR, loggedAs);\n+            if (peerVisibleReason != null) {\n+                setPeerVisibleReason(peerVisibleReason);\n+            }\n+        }\n+\n+        @Override\n+        public boolean isErroneousClose() {\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"No error - normal termination\";\n+        }\n+    }\n+\n+    private static sealed class H2StandardError extends Http2TerminationCause {\n+        private H2StandardError(final int errCode, final String msg) {\n+            super(errCode, msg);\n+            setPeerVisibleReason(ErrorFrame.stringForCode(errCode));\n+        }\n+\n+        private H2StandardError(final int errCode, final Throwable cause) {\n+            super(errCode, cause);\n+            setPeerVisibleReason(ErrorFrame.stringForCode(errCode));\n+        }\n+\n+        @Override\n+        public boolean isErroneousClose() {\n+            return getCloseCode() != ErrorFrame.NO_ERROR;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return ErrorFrame.stringForCode(this.getCloseCode());\n+        }\n+    }\n+\n+    private static final class ProtocolError extends H2StandardError {\n+        private ProtocolError(final String msg) {\n+            this(msg, false);\n+        }\n+\n+        private ProtocolError(final String msg, final boolean flowControlError) {\n+            super(flowControlError\n+                            ? ErrorFrame.FLOW_CONTROL_ERROR\n+                            : ErrorFrame.PROTOCOL_ERROR,\n+                    new ProtocolException(msg));\n+        }\n+\n+        private ProtocolError(final ProtocolException pe) {\n+            super(ErrorFrame.PROTOCOL_ERROR, pe);\n+        }\n+\n+        @Override\n+        public boolean isErroneousClose() {\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Protocol error - \" + this.getLogMsg();\n+        }\n+    }\n+\n+    private static final class InternalError extends Http2TerminationCause {\n+        private InternalError(final Throwable cause) {\n+            super(ErrorFrame.INTERNAL_ERROR, new Exception(cause));\n+        }\n+\n+        @Override\n+        public boolean isErroneousClose() {\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Internal error - \" + this.getLogMsg();\n+        }\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2TerminationCause.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -543,3 +543,1 @@\n-    void close(Throwable cause) {\n-        close();\n-    }\n+    abstract void close(Throwable cause);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeSupplier;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8326498 8361091\n+ * @summary verify that the HttpClient does not leak connections when dealing with\n+ *          sudden rush of HTTP\/2 requests\n+ * @modules java.net.http\/jdk.internal.net.http:+open\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.net.http\/jdk.internal.net.http.quic\n+ *          java.net.http\/jdk.internal.net.http.quic.packets\n+ *          java.net.http\/jdk.internal.net.http.quic.frames\n+ *          java.net.http\/jdk.internal.net.http.quic.streams\n+ *          java.net.http\/jdk.internal.net.http.http3.streams\n+ *          java.net.http\/jdk.internal.net.http.http3.frames\n+ *          java.net.http\/jdk.internal.net.http.http3\n+ *          java.net.http\/jdk.internal.net.http.qpack\n+ *          java.net.http\/jdk.internal.net.http.qpack.readers\n+ *          java.net.http\/jdk.internal.net.http.qpack.writers\n+ *          java.logging\n+ *          java.base\/jdk.internal.net.quic\n+ *          java.base\/jdk.internal.util\n+ *          java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www\n+ *          java.base\/sun.net\n+ *\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.http2.Http2TestServer\n+ *        jdk.httpclient.test.lib.http2.Http2Handler\n+ *        jdk.httpclient.test.lib.http2.Http2TestExchange\n+ *        jdk.httpclient.test.lib.http2.Http2TestExchangeSupplier\n+ * @run junit ${test.main.class}\n+ *\/\n+class BurstyRequestsTest {\n+\n+    private static final String HANDLER_PATH = \"\/8326498\/\";\n+\n+    private static Field openConnections; \/\/ Set<> jdk.internal.net.http.HttpClientImpl#openedConnections\n+\n+    private static SSLContext sslContext;\n+    private static Http2TestServer h2server;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        openConnections = Class.forName(\"jdk.internal.net.http.HttpClientImpl\")\n+                .getDeclaredField(\"openedConnections\");\n+        openConnections.setAccessible(true);\n+\n+        sslContext = new SimpleSSLContext().get();\n+        h2server = new Http2TestServer(true, sslContext);\n+        h2server.setExchangeSupplier(new ExchangeSupplier());\n+        h2server.addHandler(new Handler(), HANDLER_PATH);\n+        h2server.start();\n+        System.err.println(\"started HTTP\/2 server \" + h2server.getAddress());\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (h2server != null) {\n+            System.err.println(\"stopping server \" + h2server.getAddress());\n+            h2server.stop();\n+        }\n+    }\n+\n+    \/*\n+     * Issues a burst of 100 HTTP\/2 requests to the same server (host\/port) and expects all of\n+     * them to complete normally.\n+     * Once these requests have completed, the test then peeks into an internal field of the\n+     * HttpClientImpl to verify that the client is holding on to at most 1 connection.\n+     *\/\n+    @Test\n+    void testOpenConnections() throws Exception {\n+        final URI reqURI = URIBuilder.newBuilder()\n+                .scheme(\"https\")\n+                .host(h2server.getAddress().getAddress())\n+                .port(h2server.getAddress().getPort())\n+                .path(HANDLER_PATH)\n+                .build();\n+        final HttpRequest req = HttpRequest.newBuilder().uri(reqURI).build();\n+\n+        final int numRequests = 20;\n+        \/\/ latch for the tasks to wait on, before issuing the requests\n+        final CountDownLatch startLatch = new CountDownLatch(numRequests);\n+        final List<Future<Void>> futures = new ArrayList<>();\n+\n+        try (final ExecutorService executor = Executors.newCachedThreadPool();\n+             final HttpClient client = HttpClient.newBuilder()\n+                     .sslContext(sslContext)\n+                     .proxy(NO_PROXY)\n+                     .version(HTTP_2)\n+                     .build()) {\n+            \/\/ our test needs to peek into the internal field of jdk.internal.net.http.HttpClientImpl,\n+            \/\/ so we skip the test if the HttpClient isn't of the expected type\n+            final Object clientImpl = reflectHttpClientImplInstance(client);\n+            assumeTrue(clientImpl != null,\n+                    \"skipping test against HttpClient of type \" + client.getClass().getName());\n+\n+            for (int i = 0; i < numRequests; i++) {\n+                final Future<Void> f = executor.submit(new RequestIssuer(startLatch, client, req));\n+                futures.add(f);\n+            }\n+            \/\/ wait for the requests to complete\n+            for (final Future<Void> f : futures) {\n+                f.get();\n+            }\n+            System.err.println(\"all \" + numRequests + \" requests completed successfully\");\n+            \/\/ the request completion happens asynchronously to the closing of the HTTP\/2 Stream\n+            \/\/ as well as the HTTP\/2 connection. we wait for at most 1 connection to be retained\n+            \/\/ by HttpClientImpl.\n+            System.err.println(\"waiting for at least \" + (numRequests - 1) + \" connections to be closed\");\n+            \/\/ now verify that the current open TCP connections is not more than 1.\n+            \/\/ we let the test timeout if we never reach that count.\n+            final Set<?> currentOpenConns = (Set<?>) openConnections.get(clientImpl);\n+            int size = currentOpenConns.size();\n+            System.err.println(\"currently \" + size + \" open connections: \" + currentOpenConns);\n+            while (size > 1) {\n+                \/\/ wait\n+                Thread.sleep(100);\n+                final int prev = size;\n+                size = currentOpenConns.size();\n+                if (prev != size) {\n+                    System.err.println(\"currently \" + size + \" open connections: \" + currentOpenConns);\n+                }\n+            }\n+            \/\/ we expect at most 1 connection will stay open\n+            assertTrue((size == 0 || size == 1),\n+                    \"unexpected number of current open connections: \" + size);\n+        }\n+    }\n+\n+    \/\/ using reflection, return the jdk.internal.net.http.HttpClientImpl instance held\n+    \/\/ by the given client\n+    private static Object reflectHttpClientImplInstance(final HttpClient client) throws Exception {\n+        if (!client.getClass().getName().equals(\"jdk.internal.net.http.HttpClientFacade\")) {\n+            return null;\n+        }\n+        final Field implField = client.getClass().getDeclaredField(\"impl\");\n+        implField.setAccessible(true);\n+        final Object clientImpl = implField.get(client);\n+        if (clientImpl == null) {\n+            return null;\n+        }\n+        if (!clientImpl.getClass().getName().equals(\"jdk.internal.net.http.HttpClientImpl\")) {\n+            return null;\n+        }\n+        return clientImpl; \/\/ the expected HttpClientImpl instance\n+    }\n+\n+    private static final class RequestIssuer implements Callable<Void> {\n+        private final CountDownLatch startLatch;\n+        private final HttpClient client;\n+        private final HttpRequest request;\n+\n+        private RequestIssuer(final CountDownLatch startLatch, final HttpClient client,\n+                              final HttpRequest request) {\n+            this.startLatch = startLatch;\n+            this.client = client;\n+            this.request = request;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            this.startLatch.countDown(); \/\/ announce our arrival\n+            this.startLatch.await(); \/\/ wait for other threads to arrive\n+            \/\/ issue the request\n+            final HttpResponse<Void> resp = this.client.send(request, BodyHandlers.discarding());\n+            if (resp.statusCode() != 200) {\n+                throw new AssertionError(\"unexpected response status code: \" + resp.statusCode());\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static final class Handler implements Http2Handler {\n+        private static final int NO_RESP_BODY = -1;\n+\n+        @Override\n+        public void handle(final Http2TestExchange exchange) throws IOException {\n+            System.err.println(\"handling request \" + exchange.getRequestURI());\n+            exchange.sendResponseHeaders(200, NO_RESP_BODY);\n+        }\n+    }\n+\n+    private static final class ExchangeSupplier implements Http2TestExchangeSupplier {\n+\n+        @Override\n+        public Http2TestExchange get(int streamid, String method, HttpHeaders reqheaders,\n+                                     HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                                     SSLSession sslSession, BodyOutputStream os,\n+                                     Http2TestServerConnection conn, boolean pushAllowed) {\n+            \/\/ don't close the connection when\/if the client sends a GOAWAY\n+            conn.closeConnOnIncomingGoAway = false;\n+            return Http2TestExchangeSupplier.ofDefault().get(streamid, method, reqheaders,\n+                    rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/BurstyRequestsTest.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -253,0 +253,2 @@\n+                                System.err.println(\"unexpected exception: \" + cause\n+                                        + \", for request \" + REQ_URI_BASE + reqQueryPart);\n@@ -258,0 +260,2 @@\n+                                System.err.println(\"unexpected exception message: \" + ioe.getMessage()\n+                                        + \", for request \" + REQ_URI_BASE + reqQueryPart);\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2GoAwayTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+    public volatile boolean closeConnOnIncomingGoAway = true;\n@@ -540,2 +541,6 @@\n-            System.err.println(server.name + \": Closing connection: \"+ f.toString());\n-            close(ErrorFrame.NO_ERROR);\n+            if (closeConnOnIncomingGoAway) {\n+                System.err.println(server.name + \": Closing connection: \"+ f.toString());\n+                close(ErrorFrame.NO_ERROR);\n+            } else {\n+                System.err.println(server.name + \": Will not close connection for incoming GOAWAY: \" + f);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -504,0 +504,5 @@\n+            this.close(null);\n+        }\n+\n+        @Override\n+        void close(final Throwable cause) {\n@@ -505,1 +510,1 @@\n-            System.out.println(\"closed: \" + this);\n+            System.out.println(\"closed: \" + this + \" cause: \" + cause);\n@@ -507,0 +512,1 @@\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/ConnectionPoolTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}