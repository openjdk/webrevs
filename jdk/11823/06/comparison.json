{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.tools.attach.AttachOperationFailedException;\n@@ -60,7 +59,2 @@\n-        int pid;\n-        try {\n-            pid = Integer.parseInt(vmid);\n-            if (pid < 1) {\n-                throw new NumberFormatException();\n-            }\n-        } catch (NumberFormatException x) {\n+        int pid = Integer.parseInt(vmid);\n+        if (pid < 1) {\n@@ -140,3 +134,0 @@\n-    \/\/ known errors\n-    private static final int ATTACH_ERROR_BADVERSION = 101;\n-\n@@ -188,14 +179,1 @@\n-        SocketInputStream sis = new SocketInputStream(s);\n-\n-        \/\/ Read the command completion status\n-        int completionStatus;\n-        try {\n-            completionStatus = readInt(sis);\n-        } catch (IOException x) {\n-            sis.close();\n-            if (ioe != null) {\n-                throw ioe;\n-            } else {\n-                throw x;\n-            }\n-        }\n+        SocketInputStreamImpl sis = new SocketInputStreamImpl(s);\n@@ -203,25 +181,2 @@\n-        if (completionStatus != 0) {\n-            \/\/ read from the stream and use that as the error message\n-            String message = readErrorMessage(sis);\n-            sis.close();\n-\n-            \/\/ In the event of a protocol mismatch then the target VM\n-            \/\/ returns a known error so that we can throw a reasonable\n-            \/\/ error.\n-            if (completionStatus == ATTACH_ERROR_BADVERSION) {\n-                throw new IOException(\"Protocol mismatch with target VM\");\n-            }\n-\n-            \/\/ Special-case the \"load\" command so that the right exception is\n-            \/\/ thrown.\n-            if (cmd.equals(\"load\")) {\n-                String msg = \"Failed to load agent library\";\n-                if (!message.isEmpty())\n-                    msg += \": \" + message;\n-                throw new AgentLoadException(msg);\n-            } else {\n-                if (message.isEmpty())\n-                    message = \"Command failed in target VM\";\n-                throw new AttachOperationFailedException(message);\n-            }\n-        }\n+        \/\/ Process the command completion status\n+        processCompletionStatus(ioe, cmd, sis);\n@@ -236,5 +191,3 @@\n-    private static class SocketInputStream extends InputStream {\n-        int s;\n-\n-        public SocketInputStream(int s) {\n-            this.s = s;\n+    private static class SocketInputStreamImpl extends SocketInputStream {\n+        public SocketInputStreamImpl(long fd) {\n+            super(fd);\n@@ -243,8 +196,3 @@\n-        public synchronized int read() throws IOException {\n-            byte b[] = new byte[1];\n-            int n = this.read(b, 0, 1);\n-            if (n == 1) {\n-                return b[0] & 0xff;\n-            } else {\n-                return -1;\n-            }\n+        @Override\n+        protected int read(long fd, byte[] bs, int off, int len) throws IOException {\n+            return VirtualMachineImpl.read((int)fd, bs, off, len);\n@@ -253,16 +201,3 @@\n-        public synchronized int read(byte[] bs, int off, int len) throws IOException {\n-            if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                ((off + len) > bs.length) || ((off + len) < 0)) {\n-                throw new IndexOutOfBoundsException();\n-            } else if (len == 0)\n-                return 0;\n-\n-            return VirtualMachineImpl.read(s, bs, off, len);\n-        }\n-\n-        public synchronized void close() throws IOException {\n-            if (s != -1) {\n-                int toClose = s;\n-                s = -1;\n-                VirtualMachineImpl.close(toClose);\n-            }\n+        @Override\n+        protected void close(long fd) throws IOException {\n+            VirtualMachineImpl.close((int)fd);\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":15,"deletions":80,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.tools.attach.AttachOperationFailedException;\n@@ -61,7 +60,2 @@\n-        int pid;\n-        try {\n-            pid = Integer.parseInt(vmid);\n-            if (pid < 1) {\n-                throw new NumberFormatException();\n-            }\n-        } catch (NumberFormatException x) {\n+        int pid = Integer.parseInt(vmid);\n+        if (pid < 1) {\n@@ -144,3 +138,0 @@\n-    \/\/ known errors\n-    private static final int ATTACH_ERROR_BADVERSION = 101;\n-\n@@ -192,26 +183,1 @@\n-        SocketInputStream sis = new SocketInputStream(s);\n-\n-        \/\/ Read the command completion status\n-        int completionStatus;\n-        try {\n-            completionStatus = readInt(sis);\n-        } catch (IOException x) {\n-            sis.close();\n-            if (ioe != null) {\n-                throw ioe;\n-            } else {\n-                throw x;\n-            }\n-        }\n-\n-        if (completionStatus != 0) {\n-            \/\/ read from the stream and use that as the error message\n-            String message = readErrorMessage(sis);\n-            sis.close();\n-\n-            \/\/ In the event of a protocol mismatch then the target VM\n-            \/\/ returns a known error so that we can throw a reasonable\n-            \/\/ error.\n-            if (completionStatus == ATTACH_ERROR_BADVERSION) {\n-                throw new IOException(\"Protocol mismatch with target VM\");\n-            }\n+        SocketInputStreamImpl sis = new SocketInputStreamImpl(s);\n@@ -219,13 +185,2 @@\n-            \/\/ Special-case the \"load\" command so that the right exception is\n-            \/\/ thrown.\n-            if (cmd.equals(\"load\")) {\n-                String msg = \"Failed to load agent library\";\n-                if (!message.isEmpty())\n-                    msg += \": \" + message;\n-                throw new AgentLoadException(msg);\n-            } else {\n-                if (message.isEmpty())\n-                    message = \"Command failed in target VM\";\n-                throw new AttachOperationFailedException(message);\n-            }\n-        }\n+        \/\/ Process the command completion status\n+        processCompletionStatus(ioe, cmd, sis);\n@@ -240,15 +195,3 @@\n-    private static class SocketInputStream extends InputStream {\n-        int s = -1;\n-\n-        public SocketInputStream(int s) {\n-            this.s = s;\n-        }\n-\n-        public synchronized int read() throws IOException {\n-            byte b[] = new byte[1];\n-            int n = this.read(b, 0, 1);\n-            if (n == 1) {\n-                return b[0] & 0xff;\n-            } else {\n-                return -1;\n-            }\n+    private static class SocketInputStreamImpl extends SocketInputStream {\n+        public SocketInputStreamImpl(long fd) {\n+            super(fd);\n@@ -257,9 +200,3 @@\n-        public synchronized int read(byte[] bs, int off, int len) throws IOException {\n-            if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                ((off + len) > bs.length) || ((off + len) < 0)) {\n-                throw new IndexOutOfBoundsException();\n-            } else if (len == 0) {\n-                return 0;\n-            }\n-\n-            return VirtualMachineImpl.read(s, bs, off, len);\n+        @Override\n+        protected int read(long fd, byte[] bs, int off, int len) throws IOException {\n+            return VirtualMachineImpl.read((int)fd, bs, off, len);\n@@ -268,6 +205,3 @@\n-        public synchronized void close() throws IOException {\n-            if (s != -1) {\n-                int toClose = s;\n-                s = -1;\n-                VirtualMachineImpl.close(toClose);\n-            }\n+        @Override\n+        protected void close(long fd) throws IOException {\n+            VirtualMachineImpl.close((int)fd);\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":15,"deletions":81,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.tools.attach.AttachOperationFailedException;\n@@ -61,7 +60,2 @@\n-        int pid;\n-        try {\n-            pid = Integer.parseInt(vmid);\n-            if (pid < 1) {\n-                throw new NumberFormatException();\n-            }\n-        } catch (NumberFormatException x) {\n+        int pid = Integer.parseInt(vmid);\n+        if (pid < 1) {\n@@ -140,3 +134,0 @@\n-    \/\/ known errors\n-    private static final int ATTACH_ERROR_BADVERSION = 101;\n-\n@@ -188,26 +179,1 @@\n-        SocketInputStream sis = new SocketInputStream(s);\n-\n-        \/\/ Read the command completion status\n-        int completionStatus;\n-        try {\n-            completionStatus = readInt(sis);\n-        } catch (IOException x) {\n-            sis.close();\n-            if (ioe != null) {\n-                throw ioe;\n-            } else {\n-                throw x;\n-            }\n-        }\n-\n-        if (completionStatus != 0) {\n-            \/\/ read from the stream and use that as the error message\n-            String message = readErrorMessage(sis);\n-            sis.close();\n-\n-            \/\/ In the event of a protocol mismatch then the target VM\n-            \/\/ returns a known error so that we can throw a reasonable\n-            \/\/ error.\n-            if (completionStatus == ATTACH_ERROR_BADVERSION) {\n-                throw new IOException(\"Protocol mismatch with target VM\");\n-            }\n+        SocketInputStreamImpl sis = new SocketInputStreamImpl(s);\n@@ -215,13 +181,2 @@\n-            \/\/ Special-case the \"load\" command so that the right exception is\n-            \/\/ thrown.\n-            if (cmd.equals(\"load\")) {\n-                String msg = \"Failed to load agent library\";\n-                if (!message.isEmpty())\n-                    msg += \": \" + message;\n-                throw new AgentLoadException(msg);\n-            } else {\n-                if (message.isEmpty())\n-                    message = \"Command failed in target VM\";\n-                throw new AttachOperationFailedException(message);\n-            }\n-        }\n+        \/\/ Process the command completion status\n+        processCompletionStatus(ioe, cmd, sis);\n@@ -236,15 +191,3 @@\n-    private static class SocketInputStream extends InputStream {\n-        int s;\n-\n-        public SocketInputStream(int s) {\n-            this.s = s;\n-        }\n-\n-        public synchronized int read() throws IOException {\n-            byte b[] = new byte[1];\n-            int n = this.read(b, 0, 1);\n-            if (n == 1) {\n-                return b[0] & 0xff;\n-            } else {\n-                return -1;\n-            }\n+    private static class SocketInputStreamImpl extends SocketInputStream {\n+        public SocketInputStreamImpl(long fd) {\n+            super(fd);\n@@ -253,9 +196,3 @@\n-        public synchronized int read(byte[] bs, int off, int len) throws IOException {\n-            if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                ((off + len) > bs.length) || ((off + len) < 0)) {\n-                throw new IndexOutOfBoundsException();\n-            } else if (len == 0) {\n-                return 0;\n-            }\n-\n-            return VirtualMachineImpl.read(s, bs, off, len);\n+        @Override\n+        protected int read(long fd, byte[] bs, int off, int len) throws IOException {\n+            return VirtualMachineImpl.read((int)fd, bs, off, len);\n@@ -264,6 +201,3 @@\n-        public synchronized void close() throws IOException {\n-            if (s != -1) {\n-                int toClose = s;\n-                s = -1;\n-                VirtualMachineImpl.close(toClose);\n-            }\n+        @Override\n+        protected void close(long fd) throws IOException {\n+            VirtualMachineImpl.close((int)fd);\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":15,"deletions":81,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.tools.attach.AttachOperationFailedException;\n@@ -73,1 +74,1 @@\n-            throw new AttachNotSupportedException(\"Invalid process identifier\");\n+            throw new AttachNotSupportedException(\"Invalid process identifier: \" + id);\n@@ -186,0 +187,2 @@\n+    \/\/ known error\n+    private static final int ATTACH_ERROR_BADVERSION = 101;\n@@ -369,0 +372,88 @@\n+    \/*\n+     * Utility method to process the completion status after command execution.\n+     * If we get IOE during previous command execution, delay throwing it until\n+     * completion status have been read.\n+     *\/\n+    void processCompletionStatus(IOException ioe, String cmd, InputStream sis) throws AgentLoadException, IOException {\n+        \/\/ Read the command completion status\n+        int completionStatus;\n+        try {\n+            completionStatus = readInt(sis);\n+        } catch (IOException x) {\n+            sis.close();\n+            if (ioe != null) {\n+                throw ioe;\n+            } else {\n+                throw x;\n+            }\n+        }\n+        if (completionStatus != 0) {\n+            \/\/ read from the stream and use that as the error message\n+            String message = readErrorMessage(sis);\n+            sis.close();\n+\n+            \/\/ In the event of a protocol mismatch then the target VM\n+            \/\/ returns a known error so that we can throw a reasonable\n+            \/\/ error.\n+            if (completionStatus == ATTACH_ERROR_BADVERSION) {\n+                throw new IOException(\"Protocol mismatch with target VM\");\n+            }\n+\n+            \/\/ Special-case the \"load\" command so that the right exception is\n+            \/\/ thrown.\n+            if (cmd.equals(\"load\")) {\n+                String msg = \"Failed to load agent library\";\n+                if (!message.isEmpty()) {\n+                    msg += \": \" + message;\n+                }\n+                throw new AgentLoadException(msg);\n+            } else {\n+                if (message.isEmpty()) {\n+                    message = \"Command failed in target VM\";\n+                }\n+                throw new AttachOperationFailedException(message);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * InputStream for the socket connection to get target VM\n+     *\/\n+    abstract static class SocketInputStream extends InputStream {\n+        private long fd;\n+\n+        public SocketInputStream(long fd) {\n+            this.fd = fd;\n+        }\n+\n+        protected abstract int read(long fd, byte[] bs, int off, int len) throws IOException;\n+        protected abstract void close(long fd) throws IOException;\n+\n+        public synchronized int read() throws IOException {\n+            byte b[] = new byte[1];\n+            int n = this.read(b, 0, 1);\n+            if (n == 1) {\n+                return b[0] & 0xff;\n+            } else {\n+                return -1;\n+            }\n+        }\n+\n+        public synchronized int read(byte[] bs, int off, int len) throws IOException {\n+            if ((off < 0) || (off > bs.length) || (len < 0) ||\n+                ((off + len) > bs.length) || ((off + len) < 0)) {\n+                throw new IndexOutOfBoundsException();\n+            } else if (len == 0) {\n+                return 0;\n+            }\n+            return read(fd, bs, off, len);\n+        }\n+\n+        public synchronized void close() throws IOException {\n+            if (fd != -1) {\n+                long toClose = fd;\n+                fd = -1;\n+                close(toClose);\n+            }\n+        }\n+    }\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotVirtualMachine.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.tools.attach.AttachOperationFailedException;\n@@ -36,0 +35,3 @@\n+\/*\n+ * Windows implementation of HotSpotVirtualMachine\n+ *\/\n@@ -48,6 +50,1 @@\n-        int pid;\n-        try {\n-            pid = Integer.parseInt(id);\n-        } catch (NumberFormatException x) {\n-            throw new AttachNotSupportedException(\"Invalid process identifier\");\n-        }\n+        int pid = Integer.parseInt(id);\n@@ -111,20 +108,4 @@\n-            PipedInputStream in = new PipedInputStream(hPipe);\n-\n-            \/\/ read completion status\n-            int status = readInt(in);\n-            if (status != 0) {\n-                \/\/ read from the stream and use that as the error message\n-                String message = readErrorMessage(in);\n-                in.close();\n-                \/\/ special case the load command so that the right exception is thrown\n-                if (cmd.equals(\"load\")) {\n-                    String msg = \"Failed to load agent library\";\n-                    if (!message.isEmpty())\n-                        msg += \": \" + message;\n-                    throw new AgentLoadException(msg);\n-                } else {\n-                    if (message.isEmpty())\n-                        message = \"Command failed in target VM\";\n-                    throw new AttachOperationFailedException(message);\n-                }\n-            }\n+            SocketInputStreamImpl in = new SocketInputStreamImpl(hPipe);\n+\n+            \/\/ Process the command completion status\n+            processCompletionStatus(null, cmd, in);\n@@ -142,16 +123,3 @@\n-    private static class PipedInputStream extends InputStream {\n-\n-        private long hPipe;\n-\n-        public PipedInputStream(long hPipe) {\n-            this.hPipe = hPipe;\n-        }\n-\n-        public synchronized int read() throws IOException {\n-            byte b[] = new byte[1];\n-            int n = this.read(b, 0, 1);\n-            if (n == 1) {\n-                return b[0] & 0xff;\n-            } else {\n-                return -1;\n-            }\n+    private static class SocketInputStreamImpl extends SocketInputStream {\n+        public SocketInputStreamImpl(long fd) {\n+            super(fd);\n@@ -160,8 +128,3 @@\n-        public synchronized int read(byte[] bs, int off, int len) throws IOException {\n-            if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                ((off + len) > bs.length) || ((off + len) < 0)) {\n-                throw new IndexOutOfBoundsException();\n-            } else if (len == 0)\n-                return 0;\n-\n-            return VirtualMachineImpl.readPipe(hPipe, bs, off, len);\n+        @Override\n+        protected int read(long fd, byte[] bs, int off, int len) throws IOException {\n+            return VirtualMachineImpl.readPipe(fd, bs, off, len);\n@@ -170,6 +133,3 @@\n-        public synchronized void close() throws IOException {\n-            if (hPipe != -1) {\n-                long toClose = hPipe;\n-                hPipe = -1;\n-                VirtualMachineImpl.closePipe(toClose);\n-           }\n+        @Override\n+        protected void close(long fd) throws IOException {\n+            VirtualMachineImpl.closePipe(fd);\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":18,"deletions":58,"binary":false,"changes":76,"status":"modified"}]}