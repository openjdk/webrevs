{"files":[{"patch":"@@ -981,1 +981,0 @@\n-  _type_verify_symmetry = true;\n@@ -984,0 +983,1 @@\n+  _type_verify = NULL;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+class VerifyMeetResult;\n@@ -1214,1 +1215,1 @@\n-  bool _type_verify_symmetry;\n+  VerifyMeetResult* _type_verify;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -789,1 +789,0 @@\n-void Type::check_symmetrical(const Type* t, const Type* mt) const {\n@@ -791,1 +790,148 @@\n-  const Type* mt2 = t->xmeet(this);\n+class VerifyMeet;\n+class VerifyMeetResult : public ArenaObj {\n+  friend class VerifyMeet;\n+  friend class Type;\n+private:\n+  class VerifyMeetResultEntry {\n+  private:\n+    const Type* _in1;\n+    const Type* _in2;\n+    const Type* _res;\n+  public:\n+    VerifyMeetResultEntry(const Type* in1, const Type* in2, const Type* res):\n+            _in1(in1), _in2(in2), _res(res) {\n+    }\n+    VerifyMeetResultEntry():\n+            _in1(NULL), _in2(NULL), _res(NULL) {\n+    }\n+\n+    bool operator==(const VerifyMeetResultEntry& rhs) const {\n+      return _in1 == rhs._in1 &&\n+             _in2 == rhs._in2 &&\n+             _res == rhs._res;\n+    }\n+\n+    bool operator!=(const VerifyMeetResultEntry& rhs) const {\n+      return !(rhs == *this);\n+    }\n+\n+    static int compare(const VerifyMeetResultEntry& v1, const VerifyMeetResultEntry& v2) {\n+      if ((intptr_t) v1._in1 < (intptr_t) v2._in1) {\n+        return -1;\n+      } else if (v1._in1 == v2._in1) {\n+        if ((intptr_t) v1._in2 < (intptr_t) v2._in2) {\n+          return -1;\n+        } else if (v1._in2 == v2._in2) {\n+          assert(v1._res == v2._res || v1._res == NULL || v2._res == NULL, \"same inputs should lead to same result\");\n+          return 0;\n+        }\n+        return 1;\n+      }\n+      return 1;\n+    }\n+    const Type* res() const { return _res; }\n+  };\n+  uint _depth;\n+  GrowableArray<VerifyMeetResultEntry> _cache;\n+\n+  \/\/ With verification code, the meet of A and B causes the computation of:\n+  \/\/ 1- meet(A, B)\n+  \/\/ 2- meet(B, A)\n+  \/\/ 3- meet(dual(meet(A, B)), dual(A))\n+  \/\/ 4- meet(dual(meet(A, B)), dual(B))\n+  \/\/ 5- meet(dual(A), dual(B))\n+  \/\/ 6- meet(dual(B), dual(A))\n+  \/\/ 7- meet(dual(meet(dual(A), dual(B))), A)\n+  \/\/ 8- meet(dual(meet(dual(A), dual(B))), B)\n+  \/\/\n+  \/\/ In addition the meet of A[] and B[] requires the computation of the meet of A and B.\n+  \/\/\n+  \/\/ The meet of A[] and B[] triggers the computation of:\n+  \/\/ 1- meet(A[], B[][)\n+  \/\/   1.1- meet(A, B)\n+  \/\/   1.2- meet(B, A)\n+  \/\/   1.3- meet(dual(meet(A, B)), dual(A))\n+  \/\/   1.4- meet(dual(meet(A, B)), dual(B))\n+  \/\/   1.5- meet(dual(A), dual(B))\n+  \/\/   1.6- meet(dual(B), dual(A))\n+  \/\/   1.7- meet(dual(meet(dual(A), dual(B))), A)\n+  \/\/   1.8- meet(dual(meet(dual(A), dual(B))), B)\n+  \/\/ 2- meet(B[], A[])\n+  \/\/   2.1- meet(B, A) = 1.2\n+  \/\/   2.2- meet(A, B) = 1.1\n+  \/\/   2.3- meet(dual(meet(B, A)), dual(B)) = 1.4\n+  \/\/   2.4- meet(dual(meet(B, A)), dual(A)) = 1.3\n+  \/\/   2.5- meet(dual(B), dual(A)) = 1.6\n+  \/\/   2.6- meet(dual(A), dual(B)) = 1.5\n+  \/\/   2.7- meet(dual(meet(dual(B), dual(A))), B) = 1.8\n+  \/\/   2.8- meet(dual(meet(dual(B), dual(A))), B) = 1.7\n+  \/\/ etc.\n+  \/\/ The number of meet operations performed grows exponentially with the number of dimensions of the arrays but the number\n+  \/\/ of different meet operations is linear in the number of dimensions. The function below caches meet results for the\n+  \/\/ duration of the meet at the root of the recursive calls.\n+  \/\/\n+  const Type* meet(const Type* t1, const Type* t2) {\n+    bool found = false;\n+    const VerifyMeetResultEntry meet(t1, t2, NULL);\n+    int pos = _cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(meet, found);\n+    const Type* res = NULL;\n+    if (found) {\n+      res = _cache.at(pos).res();\n+    } else {\n+      res = t1->xmeet(t2);\n+      _cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n+      found = false;\n+      _cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(meet, found);\n+      assert(found, \"should be in table after it's added\");\n+    }\n+    return res;\n+  }\n+\n+  void add(const Type* t1, const Type* t2, const Type* res) {\n+    _cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n+  }\n+\n+  bool empty_cache() const {\n+    return _cache.length() == 0;\n+  }\n+public:\n+  VerifyMeetResult(Compile* C) :\n+          _depth(0), _cache(C->comp_arena(), 2, 0, VerifyMeetResultEntry()) {\n+  }\n+};\n+\n+void Type::assert_type_verify_empty() const {\n+  assert(Compile::current()->_type_verify == NULL || Compile::current()->_type_verify->empty_cache(), \"cache should have been discarded\");\n+}\n+\n+class VerifyMeet {\n+private:\n+  Compile* _C;\n+public:\n+  VerifyMeet(Compile* C) : _C(C) {\n+    if (C->_type_verify == NULL) {\n+      C->_type_verify = new (C->comp_arena())VerifyMeetResult(C);\n+    }\n+    _C->_type_verify->_depth++;\n+  }\n+\n+  ~VerifyMeet() {\n+    assert(_C->_type_verify->_depth != 0, \"\");\n+    _C->_type_verify->_depth--;\n+    if (_C->_type_verify->_depth == 0) {\n+      _C->_type_verify->_cache.trunc_to(0);\n+    }\n+  }\n+\n+  const Type* meet(const Type* t1, const Type* t2) const {\n+    return _C->_type_verify->meet(t1, t2);\n+  }\n+\n+  void add(const Type* t1, const Type* t2, const Type* res) const {\n+    _C->_type_verify->add(t1, t2, res);\n+  }\n+};\n+\n+void Type::check_symmetrical(const Type* t, const Type* mt, const VerifyMeet& verify) const {\n+  Compile* C = Compile::current();\n+  const Type* mt2 = verify.meet(t, this);\n@@ -801,2 +947,2 @@\n-  const Type* t2t    = dual_join->xmeet(t->_dual);\n-  const Type* t2this = dual_join->xmeet(this->_dual);\n+  const Type* t2t    = verify.meet(dual_join,t->_dual);\n+  const Type* t2this = verify.meet(dual_join,this->_dual);\n@@ -823,1 +969,0 @@\n-#endif\n@@ -825,0 +970,1 @@\n+#endif\n@@ -839,0 +985,5 @@\n+#ifdef ASSERT\n+  Compile* C = Compile::current();\n+  VerifyMeet verify(C);\n+#endif\n+\n@@ -844,4 +995,5 @@\n-  if (isa_narrowoop() || t->isa_narrowoop()) return mt;\n-  if (isa_narrowklass() || t->isa_narrowklass()) return mt;\n-  Compile* C = Compile::current();\n-  if (!C->_type_verify_symmetry) {\n+  verify.add(this_t, t, mt);\n+  if (isa_narrowoop() || t->isa_narrowoop()) {\n+    return mt;\n+  }\n+  if (isa_narrowklass() || t->isa_narrowklass()) {\n@@ -850,15 +1002,3 @@\n-  this_t->check_symmetrical(t, mt);\n-  \/\/ In the case of an array, computing the meet above, caused the\n-  \/\/ computation of the meet of the elements which at verification\n-  \/\/ time caused the computation of the meet of the dual of the\n-  \/\/ elements. Computing the meet of the dual of the arrays here\n-  \/\/ causes the meet of the dual of the elements to be computed which\n-  \/\/ would cause the meet of the dual of the dual of the elements,\n-  \/\/ that is the meet of the elements already computed above to be\n-  \/\/ computed. Avoid redundant computations by requesting no\n-  \/\/ verification.\n-  C->_type_verify_symmetry = false;\n-  const Type *mt_dual = this_t->_dual->xmeet(t->_dual);\n-  this_t->_dual->check_symmetrical(t->_dual, mt_dual);\n-  assert(!C->_type_verify_symmetry, \"shouldn't have changed\");\n-  C->_type_verify_symmetry = true;\n+  this_t->check_symmetrical(t, mt, verify);\n+  const Type *mt_dual = verify.meet(this_t->_dual, t->_dual);\n+  this_t->_dual->check_symmetrical(t->_dual, mt_dual, verify);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":164,"deletions":24,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+class VerifyMeet;\n@@ -173,1 +174,1 @@\n-  void check_symmetrical(const Type *t, const Type *mt) const;\n+  void check_symmetrical(const Type* t, const Type* mt, const VerifyMeet& verify) const NOT_DEBUG_RETURN;\n@@ -184,0 +185,1 @@\n+    assert_type_verify_empty();\n@@ -187,0 +189,2 @@\n+  void assert_type_verify_empty() const NOT_DEBUG_RETURN;\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8297582\n+ * @summary C2: very slow compilation due to type system verification code\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation TestArrayManyDimensions\n+ *\n+ *\/\n+\n+import java.util.function.IntFunction;\n+\n+public class TestArrayManyDimensions {\n+\n+    static class A {\n+\n+    }\n+\n+    static class B extends A {\n+    }\n+\n+    public static void main(String[] args) {\n+        final IntFunction<String[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]> lambda = String[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]::new;\n+        for (int i = 0; i < 20_000; i++) {\n+            test1();\n+            lambda.apply(2);\n+            test2();\n+        }\n+    }\n+\n+    private static String[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] test1() {\n+        return new String[2][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][];\n+    }\n+\n+    private static A[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] test2() {\n+        return new B[2][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestArrayManyDimensions.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}