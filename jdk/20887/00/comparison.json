{"files":[{"patch":"@@ -60,0 +60,2 @@\n+import static jdk.internal.constant.ConstantUtils.concat;\n+import static jdk.internal.constant.ConstantUtils.validateInternalClassName;\n@@ -70,0 +72,1 @@\n+    private static final ClassDesc CD_MemberName = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MemberName;\");\n@@ -129,1 +132,2 @@\n-        this.classDesc = ClassDesc.ofInternalName(className);\n+        validateInternalClassName(name);\n+        this.classDesc = ReferenceClassDescImpl.ofValidated(concat(\"L\", className, \";\"));\n@@ -145,2 +149,2 @@\n-            Wrapper w = Wrapper.forBasicType(mt.parameterType(i - 1));\n-            index += w.stackSlots();\n+            Class<?> cl = mt.parameterType(i - 1);\n+            index += (cl == long.class || cl == double.class) ? 2 : 1;\n@@ -226,0 +230,1 @@\n+        List<ClassData> classData = this.classData;\n@@ -235,2 +240,1 @@\n-        ClassData cd = new ClassData(name, desc, arg);\n-        classData.add(cd);\n+        classData.add(new ClassData(name, desc, arg));\n@@ -295,1 +299,2 @@\n-        return switch (cd.size()) {\n+        int size = cd.size();\n+        return switch (size) {\n@@ -302,2 +307,2 @@\n-                Object[] data = new Object[classData.size()];\n-                for (int i = 0; i < classData.size(); i++) {\n+                Object[] data = new Object[size];\n+                for (int i = 0; i < size; i++) {\n@@ -319,5 +324,0 @@\n-        for (ClassData p : classData) {\n-            \/\/ add the static field\n-            clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n-        }\n-\n@@ -329,1 +329,2 @@\n-                if (classData.size() == 1) {\n+                int size = classData.size();\n+                if (size == 1) {\n@@ -331,0 +332,3 @@\n+                    \/\/ add the static field\n+                    clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n+\n@@ -338,1 +342,4 @@\n-                    for (ClassData p : classData) {\n+                    for (int i = 0; i < size; i++) {\n+                        ClassData p = classData.get(i);\n+                        \/\/ add the static field\n+                        clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n@@ -541,0 +548,5 @@\n+    \/\/ Suppress method in backtraces displayed to the user, mark this method as\n+    \/\/ a compiled LambdaForm, then either force or prohibit inlining.\n+    public static final RuntimeVisibleAnnotationsAttribute LF_DONTINLINE_ANNOTATIONS = RuntimeVisibleAnnotationsAttribute.of(HIDDEN, LF_COMPILED, DONTINLINE);\n+    public static final RuntimeVisibleAnnotationsAttribute LF_FORCEINLINE_ANNOTATIONS = RuntimeVisibleAnnotationsAttribute.of(HIDDEN, LF_COMPILED, FORCEINLINE);\n+\n@@ -561,8 +573,0 @@\n-                List<Annotation> annotations = new ArrayList<>(3);\n-\n-                \/\/ Suppress this method in backtraces displayed to the user.\n-                annotations.add(HIDDEN);\n-\n-                \/\/ Mark this method as a compiled LambdaForm\n-                annotations.add(LF_COMPILED);\n-\n@@ -570,2 +574,1 @@\n-                    \/\/ Force inlining of this invoker method.\n-                    annotations.add(FORCEINLINE);\n+                    mb.accept(LF_FORCEINLINE_ANNOTATIONS);\n@@ -573,1 +576,1 @@\n-                    annotations.add(DONTINLINE);\n+                    mb.accept(LF_DONTINLINE_ANNOTATIONS);\n@@ -575,1 +578,0 @@\n-                mb.accept(RuntimeVisibleAnnotationsAttribute.of(annotations));\n@@ -1677,2 +1679,1 @@\n-        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n-             : cls == MethodHandle.class ? CD_MethodHandle\n+        return cls == MethodHandle.class ? CD_MethodHandle\n@@ -1681,0 +1682,3 @@\n+             : cls == MemberName.class ? CD_MemberName\n+             : cls == MethodType.class ? CD_MethodType\n+             : cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":33,"deletions":29,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1558,0 +1558,1 @@\n+            Object[] arguments = this.arguments;\n@@ -1565,15 +1566,0 @@\n-        \/** Return the number of occurrences of n in the argument array.\n-         *  Return 0 if the name is not used.\n-         *\/\n-        int useCount(Name n) {\n-            int count = 0;\n-            if (arguments != null) {\n-                for (Object argument : arguments) {\n-                    if (argument == n) {\n-                        count++;\n-                    }\n-                }\n-            }\n-            return count;\n-        }\n-\n@@ -1621,0 +1607,1 @@\n+        Name[] names = this.names;\n@@ -1622,1 +1609,8 @@\n-            count += names[i++].useCount(n);\n+            Object[] arguments = names[i++].arguments;\n+            if (arguments != null) {\n+                for (Object argument : arguments) {\n+                    if (argument == n) {\n+                        count++;\n+                    }\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"}]}