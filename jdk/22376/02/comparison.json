{"files":[{"patch":"@@ -31,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -65,1 +63,0 @@\n-import sun.security.action.*;\n@@ -367,1 +364,1 @@\n-                GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv4Stack\");\n+                System.getProperty(\"java.net.preferIPv4Stack\");\n@@ -369,1 +366,1 @@\n-                GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv6Addresses\");\n+                System.getProperty(\"java.net.preferIPv6Addresses\");\n@@ -371,1 +368,1 @@\n-                GetPropertyAction.privilegedGetProperty(\"jdk.net.hosts.file\");\n+                System.getProperty(\"jdk.net.hosts.file\");\n@@ -443,9 +440,0 @@\n-    \/**\n-     * The {@code RuntimePermission(\"inetAddressResolverProvider\")} is\n-     * necessary to subclass and instantiate the {@code InetAddressResolverProvider}\n-     * class, as well as to obtain resolver from an instance of that class,\n-     * and it is also required to obtain the operating system name resolution configurations.\n-     *\/\n-    private static final RuntimePermission INET_ADDRESS_RESOLVER_PERMISSION =\n-            new RuntimePermission(\"inetAddressResolverProvider\");\n-\n@@ -455,1 +443,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -479,4 +466,0 @@\n-                } else if (System.getSecurityManager() != null) {\n-                    PrivilegedAction<InetAddressResolver> pa = InetAddress::loadResolver;\n-                    cns = AccessController.doPrivileged(\n-                            pa, null, INET_ADDRESS_RESOLVER_PERMISSION);\n@@ -740,17 +723,0 @@\n-        return getHostName(true);\n-    }\n-\n-    \/**\n-     * Returns the hostname for this address.\n-     * If the host is equal to null, then this address refers to any\n-     * of the local machine's available network addresses.\n-     * this is package private so SocketPermission can make calls into\n-     * here without a security check.\n-     *\n-     * @return  the host name for this IP address, or if the operation\n-     *    is not allowed by the security check, the textual\n-     *    representation of the IP address.\n-     *\n-     * @param check make security check if true\n-     *\/\n-    String getHostName(boolean check) {\n@@ -758,1 +724,1 @@\n-            holder().hostName = InetAddress.getHostFromNameService(this, check);\n+            holder().hostName = InetAddress.getHostFromNameService(this);\n@@ -785,1 +751,1 @@\n-                InetAddress.getHostFromNameService(this, true);\n+                InetAddress.getHostFromNameService(this);\n@@ -792,2 +758,0 @@\n-     * @param check make security check if true\n-     *\n@@ -795,2 +759,1 @@\n-     *          If either the operation is not allowed by the security check\n-     *          or the system-wide resolver wasn't able to determine the\n+     *          If the system-wide resolver wasn't able to determine the\n@@ -800,1 +763,1 @@\n-    private static String getHostFromNameService(InetAddress addr, boolean check) {\n+    private static String getHostFromNameService(InetAddress addr) {\n@@ -807,11 +770,0 @@\n-            \/* check to see if calling code is allowed to know\n-             * the hostname for this IP address, ie, connect to the host\n-             *\/\n-            if (check) {\n-                @SuppressWarnings(\"removal\")\n-                SecurityManager sec = System.getSecurityManager();\n-                if (sec != null) {\n-                    sec.checkConnect(host, -1);\n-                }\n-            }\n-\n@@ -823,1 +775,1 @@\n-            InetAddress[] arr = InetAddress.getAllByName0(host, check);\n+            InetAddress[] arr = InetAddress.getAllByName0(host);\n@@ -1616,1 +1568,1 @@\n-        return getAllByName0(host, true, true);\n+        return getAllByName0(host, true);\n@@ -1642,3 +1594,2 @@\n-    static InetAddress[] getAllByName0 (String host, boolean check)\n-        throws UnknownHostException  {\n-        return getAllByName0(host, check, true);\n+    static InetAddress[] getAllByName0(String host) throws UnknownHostException {\n+        return getAllByName0(host, true);\n@@ -1685,1 +1636,0 @@\n-     * @param check perform security check\n@@ -1692,1 +1642,0 @@\n-                                               boolean check,\n@@ -1697,12 +1646,0 @@\n-\n-        \/* make sure the connection to the host is allowed, before we\n-         * give out a hostname\n-         *\/\n-        if (check) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager security = System.getSecurityManager();\n-            if (security != null) {\n-                security.checkConnect(host, -1);\n-            }\n-        }\n-\n@@ -1825,0 +1762,5 @@\n+        \/\/ is cached data still valid?\n+        CachedLocalHost clh = cachedLocalHost;\n+        if (clh != null && (clh.expiryTime - System.nanoTime()) >= 0L) {\n+            return clh.addr;\n+        }\n@@ -1826,17 +1768,1 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        try {\n-            \/\/ is cached data still valid?\n-            CachedLocalHost clh = cachedLocalHost;\n-            if (clh != null && (clh.expiryTime - System.nanoTime()) >= 0L) {\n-                if (security != null) {\n-                    security.checkConnect(clh.host, -1);\n-                }\n-                return clh.addr;\n-            }\n-\n-            String local = impl.getLocalHostName();\n-\n-            if (security != null) {\n-                security.checkConnect(local, -1);\n-            }\n+        String local = impl.getLocalHostName();\n@@ -1844,12 +1770,11 @@\n-            InetAddress localAddr;\n-            if (local.equals(\"localhost\")) {\n-                \/\/ shortcut for \"localhost\" host name\n-                localAddr = impl.loopbackAddress();\n-            } else {\n-                \/\/ call getAllByName0 without security checks and\n-                \/\/ without using cached data\n-                try {\n-                    localAddr = getAllByName0(local, false, false)[0];\n-                } catch (UnknownHostException uhe) {\n-                    \/\/ Rethrow with a more informative error message.\n-                    UnknownHostException uhe2 =\n+        InetAddress localAddr;\n+        if (local.equals(\"localhost\")) {\n+            \/\/ shortcut for \"localhost\" host name\n+            localAddr = impl.loopbackAddress();\n+        } else {\n+            \/\/ call getAllByName0 without using cached data\n+            try {\n+                localAddr = getAllByName0(local, false)[0];\n+            } catch (UnknownHostException uhe) {\n+                \/\/ Rethrow with a more informative error message.\n+                UnknownHostException uhe2 =\n@@ -1857,4 +1782,3 @@\n-                                                 uhe.getMessage());\n-                    uhe2.initCause(uhe);\n-                    throw uhe2;\n-                }\n+                                uhe.getMessage());\n+                uhe2.initCause(uhe);\n+                throw uhe2;\n@@ -1862,4 +1786,0 @@\n-            cachedLocalHost = new CachedLocalHost(local, localAddr);\n-            return localAddr;\n-        } catch (java.lang.SecurityException e) {\n-            return impl.loopbackAddress();\n@@ -1867,0 +1787,2 @@\n+        cachedLocalHost = new CachedLocalHost(local, localAddr);\n+        return localAddr;\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":33,"deletions":111,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.security.AccessController;\n@@ -36,1 +35,0 @@\n-import java.security.PrivilegedAction;\n@@ -641,1 +639,1 @@\n-                cname = addresses[0].getHostName(false).toLowerCase(Locale.ROOT);\n+                cname = addresses[0].getHostName().toLowerCase(Locale.ROOT);\n@@ -644,1 +642,1 @@\n-                                              getHostName(false).toLowerCase(Locale.ROOT);\n+                                              getHostName().toLowerCase(Locale.ROOT);\n@@ -708,1 +706,1 @@\n-            auth = InetAddress.getAllByName0(authHost, false)[0];\n+            auth = InetAddress.getAllByName0(authHost)[0];\n@@ -739,1 +737,0 @@\n-            \/\/auth = InetAddress.getAllByName0(authHost, false)[0];\n@@ -741,1 +738,1 @@\n-            auth = InetAddress.getAllByName0(authHost, false)[0];\n+            auth = InetAddress.getAllByName0(authHost)[0];\n@@ -783,1 +780,1 @@\n-                new InetAddress[] {InetAddress.getAllByName0(host, false)[0]};\n+                new InetAddress[] {InetAddress.getAllByName0(host)[0]};\n@@ -1194,1 +1191,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1196,15 +1192,8 @@\n-        return AccessController.doPrivileged(\n-            new PrivilegedAction<>(){\n-                public Integer run() {\n-                    int val = Integer.getInteger(\n-                            \"jdk.net.ephemeralPortRange.\"+suffix, -1\n-                    );\n-                    if (val != -1) {\n-                        return val;\n-                    } else {\n-                        return suffix.equals(\"low\") ?\n-                            PortConfig.getLower() : PortConfig.getUpper();\n-                    }\n-                }\n-            }\n-        );\n+        int val = Integer.getInteger(\n+                \"jdk.net.ephemeralPortRange.\" + suffix, -1);\n+        if (val != -1) {\n+            return val;\n+        } else {\n+            return suffix.equals(\"low\") ?\n+                    PortConfig.getLower() : PortConfig.getUpper();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketPermission.java","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -282,2 +282,1 @@\n-\tis -1 (forever) if a security manager is installed, and implementation-specific\n-\twhen no security manager is installed.<\/P>\n+\tis implementation-specific.<\/P>\n","filename":"src\/java.base\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -101,9 +101,0 @@\n-    \/**\n-     * The {@code RuntimePermission(\"inetAddressResolverProvider\")} is\n-     * necessary to subclass and instantiate the {@code InetAddressResolverProvider} class,\n-     * as well as to obtain resolver from an instance of that class,\n-     * and it is also required to obtain the operating system name resolution configurations.\n-     *\/\n-    private static final RuntimePermission INET_ADDRESS_RESOLVER_PERMISSION =\n-            new RuntimePermission(\"inetAddressResolverProvider\");\n-\n@@ -119,13 +110,0 @@\n-        this(checkPermission());\n-    }\n-\n-    private InetAddressResolverProvider(Void unused) {\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static Void checkPermission() {\n-        final SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(INET_ADDRESS_RESOLVER_PERMISSION);\n-        }\n-        return null;\n","filename":"src\/java.base\/share\/classes\/java\/net\/spi\/InetAddressResolverProvider.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.security.PrivilegedAction;\n@@ -30,1 +29,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -32,1 +30,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -63,3 +60,1 @@\n-     * default value is forever (FOREVER), as we let the platform do the\n-     * caching. For security reasons, this caching is made forever when\n-     * a security manager is set.\n+     * default value is 30 seconds\n@@ -67,1 +62,1 @@\n-    private static volatile int cachePolicy = FOREVER;\n+    private static volatile int cachePolicy = DEFAULT_POSITIVE;\n@@ -88,12 +83,0 @@\n-    \/*\n-     * Whether or not the cache policy for successful lookups was set\n-     * using a property (cmd line).\n-     *\/\n-    private static boolean propertySet;\n-\n-    \/*\n-     * Whether or not the cache policy for negative lookups was set\n-     * using a property (cmd line).\n-     *\/\n-    private static boolean propertyNegativeSet;\n-\n@@ -104,0 +87,3 @@\n+        \/* If the cache policy property is not specified\n+         *  then the default positive cache value is used.\n+         *\/\n@@ -107,8 +93,0 @@\n-            propertySet = true;\n-        } else {\n-            \/* No properties defined for positive caching. If there is no\n-             * security manager then use the default positive cache value.\n-             *\/\n-            if (System.getSecurityManager() == null) {\n-                cachePolicy = DEFAULT_POSITIVE;\n-            }\n@@ -121,1 +99,0 @@\n-            propertyNegativeSet = true;\n@@ -133,27 +110,19 @@\n-                                       String cachePolicyPropFallback)\n-    {\n-        return java.security.AccessController.doPrivileged(\n-                new PrivilegedAction<Integer>() {\n-                    public Integer run() {\n-                        try {\n-                            String tmpString = Security.getProperty(\n-                                    cachePolicyProp);\n-                            if (tmpString != null) {\n-                                return Integer.valueOf(tmpString);\n-                            }\n-                        } catch (NumberFormatException ignored) {\n-                            \/\/ Ignore\n-                        }\n-\n-                        try {\n-                            String tmpString = System.getProperty(\n-                                    cachePolicyPropFallback);\n-                            if (tmpString != null) {\n-                                return Integer.decode(tmpString);\n-                            }\n-                        } catch (NumberFormatException ignored) {\n-                            \/\/ Ignore\n-                        }\n-                        return null;\n-                    }\n-                });\n+                                       String cachePolicyPropFallback) {\n+        try {\n+            String tmpString = Security.getProperty(cachePolicyProp);\n+            if (tmpString != null) {\n+                return Integer.valueOf(tmpString);\n+            }\n+        } catch (NumberFormatException ignored) {\n+            \/\/ Ignore\n+        }\n+\n+        try {\n+            String tmpString = System.getProperty(cachePolicyPropFallback);\n+            if (tmpString != null) {\n+                return Integer.decode(tmpString);\n+            }\n+        } catch (NumberFormatException ignored) {\n+            \/\/ Ignore\n+        }\n+        return null;\n@@ -173,59 +142,0 @@\n-\n-    \/**\n-     * Sets the cache policy for successful lookups if the user has not\n-     * already specified a cache policy for it using a\n-     * command-property.\n-     * @param newPolicy the value in seconds for how long the lookup\n-     * should be cached\n-     *\/\n-    public static synchronized void setIfNotSet(int newPolicy) {\n-        \/*\n-         * When setting the new value we may want to signal that the\n-         * cache should be flushed, though this doesn't seem strictly\n-         * necessary.\n-         *\/\n-        if (!propertySet) {\n-            checkValue(newPolicy, cachePolicy);\n-            cachePolicy = newPolicy;\n-        }\n-    }\n-\n-    \/**\n-     * Sets the cache policy for negative lookups if the user has not\n-     * already specified a cache policy for it using a\n-     * command-property.\n-     * @param newPolicy the value in seconds for how long the lookup\n-     * should be cached\n-     *\/\n-    public static void setNegativeIfNotSet(int newPolicy) {\n-        \/*\n-         * When setting the new value we may want to signal that the\n-         * cache should be flushed, though this doesn't seem strictly\n-         * necessary.\n-         *\/\n-        if (!propertyNegativeSet) {\n-            \/\/ Negative caching does not seem to have any security\n-            \/\/ implications.\n-            \/\/ checkValue(newPolicy, negativeCachePolicy);\n-            \/\/ but we should normalize negative policy\n-            negativeCachePolicy = newPolicy < 0 ? FOREVER : newPolicy;\n-        }\n-    }\n-\n-    private static void checkValue(int newPolicy, int oldPolicy) {\n-        \/*\n-         * If malicious code gets a hold of this method, prevent\n-         * setting the cache policy to something laxer or some\n-         * invalid negative value.\n-         *\/\n-        if (newPolicy == FOREVER)\n-            return;\n-\n-        if ((oldPolicy == FOREVER) ||\n-            (newPolicy < oldPolicy) ||\n-            (newPolicy < FOREVER)) {\n-\n-            throw new\n-                SecurityException(\"can't make InetAddress cache more lax\");\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/InetAddressCachePolicy.java","additions":25,"deletions":115,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import sun.security.action.GetPropertyAction;\n-\n@@ -38,3 +36,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedExceptionAction;\n-import java.security.PrivilegedActionException;\n@@ -399,1 +394,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -401,7 +395,0 @@\n-        PrivilegedExceptionAction<List<InetAddress>> pa = () -> NetworkInterface.networkInterfaces()\n-                .flatMap(NetworkInterface::inetAddresses)\n-                .filter(a -> (a instanceof Inet6Address)\n-                        && address.equals(a)\n-                        && ((Inet6Address) a).getScopeId() != 0)\n-                .toList();\n-        List<InetAddress> result;\n@@ -409,1 +396,7 @@\n-            result = AccessController.doPrivileged(pa);\n+            List<InetAddress> result = NetworkInterface.networkInterfaces()\n+                    .flatMap(NetworkInterface::inetAddresses)\n+                    .filter(a -> (a instanceof Inet6Address)\n+                            && address.equals(a)\n+                            && ((Inet6Address) a).getScopeId() != 0)\n+                    .toList();\n+\n@@ -415,1 +408,1 @@\n-                    \"Duplicate link local addresses: must specify scope-id\"));\n+                        \"Duplicate link local addresses: must specify scope-id\"));\n@@ -417,1 +410,1 @@\n-        } catch (PrivilegedActionException pae) {\n+        } catch (SocketException socketException) {\n@@ -930,2 +923,2 @@\n-    private static final boolean ALLOW_AMBIGUOUS_IPADDRESS_LITERALS_SP_VALUE = Boolean.valueOf(\n-            GetPropertyAction.privilegedGetProperty(ALLOW_AMBIGUOUS_IPADDRESS_LITERALS_SP, \"false\"));\n+    private static final boolean ALLOW_AMBIGUOUS_IPADDRESS_LITERALS_SP_VALUE =\n+            Boolean.getBoolean(ALLOW_AMBIGUOUS_IPADDRESS_LITERALS_SP);\n@@ -942,2 +935,1 @@\n-            var value = GetPropertyAction.privilegedGetProperty(\n-                    DELAY_URL_PARSING_SP, \"false\");\n+            var value = System.getProperty(DELAY_URL_PARSING_SP, \"false\");\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"}]}