{"files":[{"patch":"@@ -31,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -443,9 +441,0 @@\n-    \/**\n-     * The {@code RuntimePermission(\"inetAddressResolverProvider\")} is\n-     * necessary to subclass and instantiate the {@code InetAddressResolverProvider}\n-     * class, as well as to obtain resolver from an instance of that class,\n-     * and it is also required to obtain the operating system name resolution configurations.\n-     *\/\n-    private static final RuntimePermission INET_ADDRESS_RESOLVER_PERMISSION =\n-            new RuntimePermission(\"inetAddressResolverProvider\");\n-\n@@ -455,1 +444,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -479,4 +467,0 @@\n-                } else if (System.getSecurityManager() != null) {\n-                    PrivilegedAction<InetAddressResolver> pa = InetAddress::loadResolver;\n-                    cns = AccessController.doPrivileged(\n-                            pa, null, INET_ADDRESS_RESOLVER_PERMISSION);\n@@ -740,17 +724,0 @@\n-        return getHostName(true);\n-    }\n-\n-    \/**\n-     * Returns the hostname for this address.\n-     * If the host is equal to null, then this address refers to any\n-     * of the local machine's available network addresses.\n-     * this is package private so SocketPermission can make calls into\n-     * here without a security check.\n-     *\n-     * @return  the host name for this IP address, or if the operation\n-     *    is not allowed by the security check, the textual\n-     *    representation of the IP address.\n-     *\n-     * @param check make security check if true\n-     *\/\n-    String getHostName(boolean check) {\n@@ -758,1 +725,1 @@\n-            holder().hostName = InetAddress.getHostFromNameService(this, check);\n+            holder().hostName = InetAddress.getHostFromNameService(this);\n@@ -785,1 +752,1 @@\n-                InetAddress.getHostFromNameService(this, true);\n+                InetAddress.getHostFromNameService(this);\n@@ -792,2 +759,0 @@\n-     * @param check make security check if true\n-     *\n@@ -795,2 +760,1 @@\n-     *          If either the operation is not allowed by the security check\n-     *          or the system-wide resolver wasn't able to determine the\n+     *          If the system-wide resolver wasn't able to determine the\n@@ -800,1 +764,1 @@\n-    private static String getHostFromNameService(InetAddress addr, boolean check) {\n+    private static String getHostFromNameService(InetAddress addr) {\n@@ -807,11 +771,0 @@\n-            \/* check to see if calling code is allowed to know\n-             * the hostname for this IP address, ie, connect to the host\n-             *\/\n-            if (check) {\n-                @SuppressWarnings(\"removal\")\n-                SecurityManager sec = System.getSecurityManager();\n-                if (sec != null) {\n-                    sec.checkConnect(host, -1);\n-                }\n-            }\n-\n@@ -823,1 +776,1 @@\n-            InetAddress[] arr = InetAddress.getAllByName0(host, check);\n+            InetAddress[] arr = InetAddress.getAllByName0(host);\n@@ -1616,1 +1569,1 @@\n-        return getAllByName0(host, true, true);\n+        return getAllByName0(host, true);\n@@ -1642,1 +1595,1 @@\n-    static InetAddress[] getAllByName0 (String host, boolean check)\n+    static InetAddress[] getAllByName0(String host)\n@@ -1644,1 +1597,1 @@\n-        return getAllByName0(host, check, true);\n+        return getAllByName0(host, true);\n@@ -1685,1 +1638,0 @@\n-     * @param check perform security check\n@@ -1692,1 +1644,0 @@\n-                                               boolean check,\n@@ -1697,12 +1648,0 @@\n-\n-        \/* make sure the connection to the host is allowed, before we\n-         * give out a hostname\n-         *\/\n-        if (check) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager security = System.getSecurityManager();\n-            if (security != null) {\n-                security.checkConnect(host, -1);\n-            }\n-        }\n-\n@@ -1825,0 +1764,5 @@\n+        \/\/ is cached data still valid?\n+        CachedLocalHost clh = cachedLocalHost;\n+        if (clh != null && (clh.expiryTime - System.nanoTime()) >= 0L) {\n+            return clh.addr;\n+        }\n@@ -1826,17 +1770,1 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        try {\n-            \/\/ is cached data still valid?\n-            CachedLocalHost clh = cachedLocalHost;\n-            if (clh != null && (clh.expiryTime - System.nanoTime()) >= 0L) {\n-                if (security != null) {\n-                    security.checkConnect(clh.host, -1);\n-                }\n-                return clh.addr;\n-            }\n-\n-            String local = impl.getLocalHostName();\n-\n-            if (security != null) {\n-                security.checkConnect(local, -1);\n-            }\n+        String local = impl.getLocalHostName();\n@@ -1844,12 +1772,11 @@\n-            InetAddress localAddr;\n-            if (local.equals(\"localhost\")) {\n-                \/\/ shortcut for \"localhost\" host name\n-                localAddr = impl.loopbackAddress();\n-            } else {\n-                \/\/ call getAllByName0 without security checks and\n-                \/\/ without using cached data\n-                try {\n-                    localAddr = getAllByName0(local, false, false)[0];\n-                } catch (UnknownHostException uhe) {\n-                    \/\/ Rethrow with a more informative error message.\n-                    UnknownHostException uhe2 =\n+        InetAddress localAddr;\n+        if (local.equals(\"localhost\")) {\n+            \/\/ shortcut for \"localhost\" host name\n+            localAddr = impl.loopbackAddress();\n+        } else {\n+            \/\/ call getAllByName0 without using cached data\n+            try {\n+                localAddr = getAllByName0(local, false)[0];\n+            } catch (UnknownHostException uhe) {\n+                \/\/ Rethrow with a more informative error message.\n+                UnknownHostException uhe2 =\n@@ -1857,4 +1784,3 @@\n-                                                 uhe.getMessage());\n-                    uhe2.initCause(uhe);\n-                    throw uhe2;\n-                }\n+                                uhe.getMessage());\n+                uhe2.initCause(uhe);\n+                throw uhe2;\n@@ -1862,4 +1788,0 @@\n-            cachedLocalHost = new CachedLocalHost(local, localAddr);\n-            return localAddr;\n-        } catch (java.lang.SecurityException e) {\n-            return impl.loopbackAddress();\n@@ -1867,0 +1789,2 @@\n+        cachedLocalHost = new CachedLocalHost(local, localAddr);\n+        return localAddr;\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":30,"deletions":106,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.security.AccessController;\n@@ -36,1 +35,0 @@\n-import java.security.PrivilegedAction;\n@@ -641,1 +639,1 @@\n-                cname = addresses[0].getHostName(false).toLowerCase(Locale.ROOT);\n+                cname = addresses[0].getHostName().toLowerCase(Locale.ROOT);\n@@ -644,1 +642,1 @@\n-                                              getHostName(false).toLowerCase(Locale.ROOT);\n+                                              getHostName().toLowerCase(Locale.ROOT);\n@@ -708,1 +706,1 @@\n-            auth = InetAddress.getAllByName0(authHost, false)[0];\n+            auth = InetAddress.getAllByName0(authHost)[0];\n@@ -739,1 +737,0 @@\n-            \/\/auth = InetAddress.getAllByName0(authHost, false)[0];\n@@ -741,1 +738,1 @@\n-            auth = InetAddress.getAllByName0(authHost, false)[0];\n+            auth = InetAddress.getAllByName0(authHost)[0];\n@@ -783,1 +780,1 @@\n-                new InetAddress[] {InetAddress.getAllByName0(host, false)[0]};\n+                new InetAddress[] {InetAddress.getAllByName0(host)[0]};\n@@ -1194,1 +1191,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1196,15 +1192,8 @@\n-        return AccessController.doPrivileged(\n-            new PrivilegedAction<>(){\n-                public Integer run() {\n-                    int val = Integer.getInteger(\n-                            \"jdk.net.ephemeralPortRange.\"+suffix, -1\n-                    );\n-                    if (val != -1) {\n-                        return val;\n-                    } else {\n-                        return suffix.equals(\"low\") ?\n-                            PortConfig.getLower() : PortConfig.getUpper();\n-                    }\n-                }\n-            }\n-        );\n+        int val = Integer.getInteger(\n+                \"jdk.net.ephemeralPortRange.\" + suffix, -1);\n+        if (val != -1) {\n+            return val;\n+        } else {\n+            return suffix.equals(\"low\") ?\n+                    PortConfig.getLower() : PortConfig.getUpper();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketPermission.java","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -282,2 +282,1 @@\n-\tis -1 (forever) if a security manager is installed, and implementation-specific\n-\twhen no security manager is installed.<\/P>\n+\tis implementation-specific.<\/P>\n","filename":"src\/java.base\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -101,9 +101,0 @@\n-    \/**\n-     * The {@code RuntimePermission(\"inetAddressResolverProvider\")} is\n-     * necessary to subclass and instantiate the {@code InetAddressResolverProvider} class,\n-     * as well as to obtain resolver from an instance of that class,\n-     * and it is also required to obtain the operating system name resolution configurations.\n-     *\/\n-    private static final RuntimePermission INET_ADDRESS_RESOLVER_PERMISSION =\n-            new RuntimePermission(\"inetAddressResolverProvider\");\n-\n@@ -119,13 +110,0 @@\n-        this(checkPermission());\n-    }\n-\n-    private InetAddressResolverProvider(Void unused) {\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static Void checkPermission() {\n-        final SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(INET_ADDRESS_RESOLVER_PERMISSION);\n-        }\n-        return null;\n","filename":"src\/java.base\/share\/classes\/java\/net\/spi\/InetAddressResolverProvider.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.security.PrivilegedAction;\n@@ -30,1 +29,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -32,1 +30,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -63,3 +60,1 @@\n-     * default value is forever (FOREVER), as we let the platform do the\n-     * caching. For security reasons, this caching is made forever when\n-     * a security manager is set.\n+     * default value is 30 seconds\n@@ -67,1 +62,1 @@\n-    private static volatile int cachePolicy = FOREVER;\n+    private static volatile int cachePolicy = DEFAULT_POSITIVE;\n@@ -104,0 +99,3 @@\n+        \/* If the cache policy property is not specified\n+         *  then the default positive cache value is used.\n+         *\/\n@@ -108,7 +106,0 @@\n-        } else {\n-            \/* No properties defined for positive caching. If there is no\n-             * security manager then use the default positive cache value.\n-             *\/\n-            if (System.getSecurityManager() == null) {\n-                cachePolicy = DEFAULT_POSITIVE;\n-            }\n@@ -133,27 +124,22 @@\n-                                       String cachePolicyPropFallback)\n-    {\n-        return java.security.AccessController.doPrivileged(\n-                new PrivilegedAction<Integer>() {\n-                    public Integer run() {\n-                        try {\n-                            String tmpString = Security.getProperty(\n-                                    cachePolicyProp);\n-                            if (tmpString != null) {\n-                                return Integer.valueOf(tmpString);\n-                            }\n-                        } catch (NumberFormatException ignored) {\n-                            \/\/ Ignore\n-                        }\n-\n-                        try {\n-                            String tmpString = System.getProperty(\n-                                    cachePolicyPropFallback);\n-                            if (tmpString != null) {\n-                                return Integer.decode(tmpString);\n-                            }\n-                        } catch (NumberFormatException ignored) {\n-                            \/\/ Ignore\n-                        }\n-                        return null;\n-                    }\n-                });\n+                                       String cachePolicyPropFallback) {\n+\n+        try {\n+            String tmpString = Security.getProperty(\n+                    cachePolicyProp);\n+            if (tmpString != null) {\n+                return Integer.valueOf(tmpString);\n+            }\n+        } catch (NumberFormatException ignored) {\n+            \/\/ Ignore\n+        }\n+\n+        try {\n+            String tmpString = System.getProperty(\n+                    cachePolicyPropFallback);\n+            if (tmpString != null) {\n+                return Integer.decode(tmpString);\n+            }\n+        } catch (NumberFormatException ignored) {\n+            \/\/ Ignore\n+        }\n+        return null;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/InetAddressCachePolicy.java","additions":28,"deletions":42,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedExceptionAction;\n-import java.security.PrivilegedActionException;\n@@ -399,1 +396,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -401,7 +397,0 @@\n-        PrivilegedExceptionAction<List<InetAddress>> pa = () -> NetworkInterface.networkInterfaces()\n-                .flatMap(NetworkInterface::inetAddresses)\n-                .filter(a -> (a instanceof Inet6Address)\n-                        && address.equals(a)\n-                        && ((Inet6Address) a).getScopeId() != 0)\n-                .toList();\n-        List<InetAddress> result;\n@@ -409,1 +398,7 @@\n-            result = AccessController.doPrivileged(pa);\n+            List<InetAddress> result = NetworkInterface.networkInterfaces()\n+                    .flatMap(NetworkInterface::inetAddresses)\n+                    .filter(a -> (a instanceof Inet6Address)\n+                            && address.equals(a)\n+                            && ((Inet6Address) a).getScopeId() != 0)\n+                    .toList();\n+\n@@ -415,1 +410,1 @@\n-                    \"Duplicate link local addresses: must specify scope-id\"));\n+                        \"Duplicate link local addresses: must specify scope-id\"));\n@@ -417,1 +412,1 @@\n-        } catch (PrivilegedActionException pae) {\n+        } catch (SocketException socketException) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"}]}