{"files":[{"patch":"@@ -248,1 +248,12 @@\n-static PlatformMutex gInflationLocks[256];\n+static constexpr size_t inflation_lock_count() {\n+  return 256;\n+}\n+\n+\/\/ Static storage for an array of PlatformMutex. Each entry is aligned to `alignas(PlatformMutex)`\n+\/\/ by property of the storage itself being aligned to that requirement and each entry storage being\n+\/\/ `sizeof(PlatformMutex)` aligned up to `alignof(PlatformMutex)`.\n+alignas(PlatformMutex) static uint8_t _inflation_locks[inflation_lock_count()][align_up(sizeof(PlatformMutex), alignof(PlatformMutex))];\n+\n+static inline PlatformMutex* inflation_lock(size_t index) {\n+  return reinterpret_cast<PlatformMutex*>(_inflation_locks[index]);\n+}\n@@ -251,2 +262,2 @@\n-  for (size_t i = 0; i < ARRAY_SIZE(gInflationLocks); i++) {\n-    ::new(static_cast<void*>(&gInflationLocks[i])) PlatformMutex();\n+  for (size_t i = 0; i < inflation_lock_count(); i++) {\n+    ::new(static_cast<void*>(inflation_lock(i))) PlatformMutex();\n@@ -742,2 +753,2 @@\n-        static_assert(is_power_of_2(ARRAY_SIZE(gInflationLocks)), \"must be\");\n-        size_t ix = (cast_from_oop<intptr_t>(obj) >> 5) & (ARRAY_SIZE(gInflationLocks) - 1);\n+        static_assert(is_power_of_2(inflation_lock_count()), \"must be\");\n+        size_t ix = (cast_from_oop<intptr_t>(obj) >> 5) & (inflation_lock_count() - 1);\n@@ -745,2 +756,2 @@\n-        assert(ix < ARRAY_SIZE(gInflationLocks), \"invariant\");\n-        gInflationLocks[ix].lock();\n+        assert(ix < inflation_lock_count(), \"invariant\");\n+        inflation_lock(ix)->lock();\n@@ -757,1 +768,1 @@\n-        gInflationLocks[ix].unlock();\n+        inflation_lock(ix)->unlock();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"}]}