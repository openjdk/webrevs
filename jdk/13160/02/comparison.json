{"files":[{"patch":"@@ -248,2 +248,12 @@\n-static const int NINFLATIONLOCKS = 256;\n-static PlatformMutex* gInflationLocks[NINFLATIONLOCKS];\n+static constexpr size_t inflation_lock_count() {\n+  return 256;\n+}\n+\n+\/\/ Static storage for an array of PlatformMutex. Each entry is aligned to `alignas(PlatformMutex)`\n+\/\/ by property of the storage itself being aligned to that requirement and each entry storage being\n+\/\/ `sizeof(PlatformMutex)` aligned up to `alignof(PlatformMutex)`.\n+alignas(PlatformMutex) static uint8_t _inflation_locks[inflation_lock_count()][align_up(sizeof(PlatformMutex), alignof(PlatformMutex))];\n+\n+static inline PlatformMutex* inflation_lock(size_t index) {\n+  return reinterpret_cast<PlatformMutex*>(_inflation_locks[index]);\n+}\n@@ -252,2 +262,2 @@\n-  for (int i = 0; i < NINFLATIONLOCKS; i++) {\n-    gInflationLocks[i] = new PlatformMutex();\n+  for (size_t i = 0; i < inflation_lock_count(); i++) {\n+    ::new(static_cast<void*>(inflation_lock(i))) PlatformMutex();\n@@ -743,2 +753,2 @@\n-        static_assert(is_power_of_2(NINFLATIONLOCKS), \"must be\");\n-        int ix = (cast_from_oop<intptr_t>(obj) >> 5) & (NINFLATIONLOCKS-1);\n+        static_assert(is_power_of_2(inflation_lock_count()), \"must be\");\n+        size_t ix = (cast_from_oop<intptr_t>(obj) >> 5) & (inflation_lock_count() - 1);\n@@ -746,2 +756,2 @@\n-        assert(ix >= 0 && ix < NINFLATIONLOCKS, \"invariant\");\n-        gInflationLocks[ix]->lock();\n+        assert(ix < inflation_lock_count(), \"invariant\");\n+        inflation_lock(ix)->lock();\n@@ -758,1 +768,1 @@\n-        gInflationLocks[ix]->unlock();\n+        inflation_lock(ix)->unlock();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"}]}