{"files":[{"patch":"@@ -76,9 +76,0 @@\n-static bool is_maskall_type(const TypeLong* type, int vlen) {\n-  if (!type->is_con()) {\n-    return false;\n-  }\n-  long mask = (-1ULL >> (64 - vlen));\n-  long bit  = type->get_con() & mask;\n-  return bit == 0 || bit == mask;\n-}\n-\n@@ -697,0 +688,17 @@\n+  if (!arch_supports_vector(opc, num_elem, elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n+    \/\/ If the input long sets or unsets all lanes and Replicate is supported,\n+    \/\/ generate a MaskAll or Replicate instead.\n+\n+    \/\/ The \"maskAll\" API uses the corresponding integer types for floating-point data.\n+    BasicType maskall_bt = elem_bt == T_DOUBLE ? T_LONG : (elem_bt == T_FLOAT ? T_INT: elem_bt);\n+    if (!(opc == Op_VectorLongToMask &&\n+          VectorNode::is_maskall_type(bits_type, num_elem) &&\n+          arch_supports_vector(Op_Replicate, num_elem, maskall_bt, checkFlags, true \/*has_scalar_args*\/))) {\n+      log_if_needed(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d bcast_mode=%d\",\n+                      num_elem, type2name(elem_bt),\n+                      is_mask ? 1 : 0,\n+                      bcast_mode);\n+      return false; \/\/ not supported\n+    }\n+  }\n+\n@@ -699,15 +707,0 @@\n-  BasicType converted_elem_bt = elem_bt == T_DOUBLE ? T_LONG : (elem_bt == T_FLOAT ? T_INT: elem_bt);\n-  \/\/ If bits sets or unsets all lanes, convert VectorLongToMask to Replicate.\n-  if (opc == Op_VectorLongToMask &&\n-      is_maskall_type(bits_type, num_elem) &&\n-      arch_supports_vector(Op_Replicate, num_elem, converted_elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n-    opc = Op_Replicate;\n-    elem_bt = converted_elem_bt;\n-    bits = gvn().longcon((bits_type->get_con() & 1L) == 0L ? 0L : -1L);\n-  } else if (!arch_supports_vector(opc, num_elem, elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n-    log_if_needed(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d bcast_mode=%d\",\n-                    num_elem, type2name(elem_bt),\n-                    is_mask ? 1 : 0,\n-                    bcast_mode);\n-    return false; \/\/ not supported\n-  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":17,"deletions":24,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -437,0 +437,10 @@\n+bool VectorNode::is_maskall_type(const TypeLong* type, int vlen) {\n+  assert(type != nullptr, \"type must not be null\");\n+  if (!type->is_con()) {\n+    return false;\n+  }\n+  long mask = (-1ULL >> (64 - vlen));\n+  long bit  = type->get_con() & mask;\n+  return bit == 0 || bit == mask;\n+}\n+\n@@ -1506,0 +1516,40 @@\n+\/\/ Convert fromLong to maskAll if the input sets or unsets all lanes.\n+Node* convertFromLongToMaskAll(PhaseGVN* phase, const TypeLong* bits_type, bool is_mask, const TypeVect* vt) {\n+  uint vlen = vt->length();\n+  BasicType bt = vt->element_basic_type();\n+  int opc = is_mask ? Op_MaskAll : Op_Replicate;\n+  \/\/ The \"maskAll\" API uses the corresponding integer types for floating-point data.\n+  BasicType maskall_bt = (bt == T_FLOAT) ? T_INT : (bt == T_DOUBLE) ? T_LONG : bt;\n+\n+  if (VectorNode::is_maskall_type(bits_type, vlen) &&\n+      Matcher::match_rule_supported_vector(opc, vlen, maskall_bt)) {\n+    Node* con = nullptr;\n+    jlong con_value = bits_type->get_con() == 0L ? 0L : -1L;\n+    if (maskall_bt == T_LONG) {\n+      con = phase->longcon(con_value);\n+    } else {\n+      con = phase->intcon(con_value);\n+    }\n+    Node* res = VectorNode::scalar2vector(con, vlen, maskall_bt, is_mask);\n+    \/\/ Convert back to the original floating-point data type.\n+    if (is_floating_point_type(bt)) {\n+      res = new VectorMaskCastNode(phase->transform(res), vt);\n+    }\n+    return res;\n+  }\n+  return nullptr;\n+}\n+\n+Node* VectorLoadMaskNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ VectorLoadMask(VectorLongToMask(-1\/0)) => Replicate(-1\/0)\n+  if (in(1)->Opcode() == Op_VectorLongToMask) {\n+    const TypeVect* vt = bottom_type()->is_vect();\n+    Node* res = convertFromLongToMaskAll(phase, in(1)->in(1)->bottom_type()->isa_long(), false, vt);\n+    if (res != nullptr) {\n+      return res;\n+    }\n+  }\n+\n+  return VectorNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -1921,0 +1971,10 @@\n+Node* VectorMaskCastNode::Identity(PhaseGVN* phase) {\n+  Node* in1 = in(1);\n+  \/\/ VectorMaskCast (VectorMaskCast x) => x\n+  if (in1->Opcode() == Op_VectorMaskCast &&\n+      vect_type()->eq(in1->in(1)->bottom_type())) {\n+      return in1->in(1);\n+  }\n+  return this;\n+}\n+\n@@ -1922,3 +1982,4 @@\n-\/\/   toLong(maskAll(true))  => (-1ULL >> (64 - vlen))\n-\/\/   toLong(maskAll(false)) => 0\n-Node* VectorMaskToLongNode::Identity_MaskAll(PhaseGVN* phase) {\n+\/\/   VectorMaskToLong(MaskAll(l)) => (l & (-1ULL >> (64 - vlen)))\n+\/\/   VectorMaskToLong(VectorStoreMask(Replicate(l))) => (l & (-1ULL >> (64 - vlen)))\n+\/\/ l is -1 or 0.\n+Node* VectorMaskToLongNode::Ideal_MaskAll(PhaseGVN* phase) {\n@@ -1926,0 +1987,1 @@\n+  \/\/ VectorMaskToLong follows a VectorStoreMask if predicate is not supported.\n@@ -1929,4 +1991,0 @@\n-  if (in1->bottom_type()->isa_vect() == nullptr) {\n-    return nullptr;\n-  }\n-  int vlen = in1->bottom_type()->is_vect()->length();\n@@ -1934,1 +1992,2 @@\n-    return phase->longcon((-1ULL >> (64 - vlen)));\n+    int vlen = in1->bottom_type()->is_vect()->length();\n+    return new ConLNode(TypeLong::make(-1ULL >> (64 - vlen)));\n@@ -1937,1 +1996,1 @@\n-    return phase->longcon(0L);\n+    return new ConLNode(TypeLong::ZERO);\n@@ -1942,0 +2001,8 @@\n+Node* VectorMaskToLongNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* res = Ideal_MaskAll(phase);\n+  if (res != nullptr) {\n+    return res;\n+  }\n+  return VectorMaskOpNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -1946,2 +2013,1 @@\n-  Node* res = Identity_MaskAll(phase);\n-  return res == nullptr ? this : res;\n+  return this;\n@@ -1952,0 +2018,3 @@\n+  uint vlen = dst_type->length();\n+  const TypeVectMask* is_mask = dst_type->isa_vectmask();\n+\n@@ -1956,1 +2025,1 @@\n-      in(1)->in(2)->bottom_type()->is_long()->get_con() == ((1L << dst_type->length()) - 1)) {\n+      in(1)->in(2)->bottom_type()->is_long()->get_con() == ((1L << vlen) - 1)) {\n@@ -1960,1 +2029,1 @@\n-     if (dst_type->isa_vectmask() == nullptr) {\n+     if (is_mask == nullptr) {\n@@ -1967,3 +2036,3 @@\n-     if (src_type->length() == dst_type->length() &&\n-         ((src_type->isa_vectmask() == nullptr && dst_type->isa_vectmask() == nullptr) ||\n-          (src_type->isa_vectmask() && dst_type->isa_vectmask()))) {\n+     if (src_type->length() == vlen &&\n+         ((src_type->isa_vectmask() == nullptr && is_mask == nullptr) ||\n+          (src_type->isa_vectmask() && is_mask))) {\n@@ -1973,1 +2042,11 @@\n-  return nullptr;\n+\n+  \/\/ VectorLongToMask(-1\/0) => MaskAll(-1\/0)\n+  const TypeLong* bits_type = in(1)->bottom_type()->isa_long();\n+  if (bits_type && is_mask) {\n+    Node* res = convertFromLongToMaskAll(phase, bits_type, true, dst_type);\n+    if (res != nullptr) {\n+      return res;\n+    }\n+  }\n+\n+  return VectorNode::Ideal(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":96,"deletions":17,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  static bool is_maskall_type(const TypeLong* type, int vlen);\n@@ -1386,0 +1387,2 @@\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  Node* Ideal_MaskAll(PhaseGVN* phase);\n@@ -1388,1 +1391,0 @@\n-  Node* Identity_MaskAll(PhaseGVN* phase);\n@@ -1780,0 +1782,1 @@\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1799,0 +1802,1 @@\n+  Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8356760\n+* @library \/test\/lib \/\n+* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n+* @modules jdk.incubator.vector\n+*\n+* @run driver compiler.vectorapi.VectorMaskCastIdentityTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class VectorMaskCastIdentityTest {\n+    private static final boolean[] mr = new boolean[128]; \/\/ 128 is large enough\n+    private static final Random rd = Utils.getRandomInstance();\n+    static {\n+        for (int i = 0; i < mr.length; i++) {\n+            mr[i] = rd.nextBoolean();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" }, applyIfCPUFeatureOr = {\"asimd\", \"true\"})\n+    public static int testTwoCastToDifferentType() {\n+        \/\/ The types before and after the two casts are not the same, so the cast cannot be eliminated.\n+        VectorMask<Float> mFloat64 = VectorMask.fromArray(FloatVector.SPECIES_64, mr, 0);\n+        VectorMask<Double> mDouble128 = mFloat64.cast(DoubleVector.SPECIES_128);\n+        VectorMask<Integer> mInt64 = mDouble128.cast(IntVector.SPECIES_64);\n+        return mInt64.trueCount();\n+    }\n+\n+    @Run(test = \"testTwoCastToDifferentType\")\n+    public static void testTwoCastToDifferentType_runner() {\n+        int count = testTwoCastToDifferentType();\n+        VectorMask<Float> mFloat64 = VectorMask.fromArray(FloatVector.SPECIES_64, mr, 0);\n+        Asserts.assertEquals(count, mFloat64.trueCount());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+    public static int testTwoCastToDifferentType2() {\n+        \/\/ The types before and after the two casts are not the same, so the cast cannot be eliminated.\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        VectorMask<Double> mDouble256 = mInt128.cast(DoubleVector.SPECIES_256);\n+        VectorMask<Short>  mShort64 = mDouble256.cast(ShortVector.SPECIES_64);\n+        return mShort64.trueCount();\n+    }\n+\n+    @Run(test = \"testTwoCastToDifferentType2\")\n+    public static void testTwoCastToDifferentType2_runner() {\n+        int count = testTwoCastToDifferentType2();\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        Asserts.assertEquals(count, mInt128.trueCount());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static int testTwoCastToSameType() {\n+        \/\/ The types before and after the two casts are the same, so the cast will be eliminated.\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        VectorMask<Float> mFloat128 = mInt128.cast(FloatVector.SPECIES_128);\n+        VectorMask<Integer> mInt128_2 = mFloat128.cast(IntVector.SPECIES_128);\n+        return mInt128_2.trueCount();\n+    }\n+\n+    @Run(test = \"testTwoCastToSameType\")\n+    public static void testTwoCastToSameType_runner() {\n+        int count = testTwoCastToSameType();\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        Asserts.assertEquals(count, mInt128.trueCount());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static int testOneCastToDifferentType() {\n+        \/\/ The types before and after the only cast are different, the cast will not be eliminated.\n+        VectorMask<Float> mFloat128 = VectorMask.fromArray(FloatVector.SPECIES_128, mr, 0).not();\n+        VectorMask<Integer> mInt128 = mFloat128.cast(IntVector.SPECIES_128);\n+        return mInt128.trueCount();\n+    }\n+\n+    @Run(test = \"testOneCastToDifferentType\")\n+    public static void testOneCastToDifferentType_runner() {\n+        int count = testOneCastToDifferentType();\n+        VectorMask<Float> mInt128 = VectorMask.fromArray(FloatVector.SPECIES_128, mr, 0).not();\n+        Asserts.assertEquals(count, mInt128.trueCount());\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastIdentityTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -51,3 +51,2 @@\n-    static void maskFromLongKernel(VectorSpecies<?> species, long inputLong) {\n-        var vmask = VectorMask.fromLong(species, inputLong);\n-        vmask.intoArray(mr, 0);\n+    public static void maskFromLongKernel(VectorSpecies<?> species, long inputLong) {\n+        VectorMask.fromLong(species, inputLong).intoArray(mr, 0);\n@@ -57,1 +56,1 @@\n-    static void verifyMaskFromLong(VectorSpecies<?> species, long inputLong, boolean expectedValue) {\n+    public static void verifyMaskFromLong(VectorSpecies<?> species, long inputLong) {\n@@ -59,1 +58,2 @@\n-            if (mr[i] != expectedValue) {\n+            long expectedValue = (inputLong >>> i) & 1L;\n+            if (mr[i] != (expectedValue == 1L)) {\n@@ -67,1 +67,7 @@\n-    public static void testMaskFromLong(VectorSpecies<?> species) {\n+    public static void testMaskFromLong(VectorSpecies<?> species, long inputLong ) {\n+        maskFromLongKernel(species, inputLong);\n+        verifyMaskFromLong(species, inputLong);\n+    }\n+\n+    @ForceInline\n+    public static void testMaskFromLongMaskAll(VectorSpecies<?> species) {\n@@ -70,2 +76,1 @@\n-        maskFromLongKernel(species, inputLong);\n-        verifyMaskFromLong(species, inputLong, false);\n+        testMaskFromLong(species, inputLong);\n@@ -74,2 +79,1 @@\n-        maskFromLongKernel(species, inputLong);\n-        verifyMaskFromLong(species, inputLong, false);\n+        testMaskFromLong(species, inputLong);\n@@ -78,2 +82,1 @@\n-        maskFromLongKernel(species, inputLong);\n-        verifyMaskFromLong(species, inputLong, true);\n+        testMaskFromLong(species, inputLong);\n@@ -82,2 +85,1 @@\n-        maskFromLongKernel(species, inputLong);\n-        verifyMaskFromLong(species, inputLong, true);\n+        testMaskFromLong(species, inputLong);\n@@ -90,1 +92,2 @@\n-    @IR(counts = { IRNode.REPLICATE_B, \"> 0\" },\n+    @IR(counts = { IRNode.REPLICATE_B, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -95,2 +98,2 @@\n-    public static void testMaskFromLongByte() {\n-        testMaskFromLong(B_SPECIES);\n+    public static void testMaskFromLongMaskAllByte() {\n+        testMaskFromLongMaskAll(B_SPECIES);\n@@ -103,1 +106,2 @@\n-    @IR(counts = { IRNode.REPLICATE_S, \"> 0\" },\n+    @IR(counts = { IRNode.REPLICATE_S, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -108,2 +112,2 @@\n-    public static void testMaskFromLongShort() {\n-        testMaskFromLong(S_SPECIES);\n+    public static void testMaskFromLongMaskAllShort() {\n+        testMaskFromLongMaskAll(S_SPECIES);\n@@ -116,1 +120,2 @@\n-    @IR(counts = { IRNode.REPLICATE_I, \"> 0\" },\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -121,2 +126,2 @@\n-    public static void testMaskFromLongInt() {\n-        testMaskFromLong(I_SPECIES);\n+    public static void testMaskFromLongMaskAllInt() {\n+        testMaskFromLongMaskAll(I_SPECIES);\n@@ -129,1 +134,2 @@\n-    @IR(counts = { IRNode.REPLICATE_L, \"> 0\" },\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -134,2 +140,2 @@\n-    public static void testMaskFromLongLong() {\n-        testMaskFromLong(L_SPECIES);\n+    public static void testMaskFromLongMaskAllLong() {\n+        testMaskFromLongMaskAll(L_SPECIES);\n@@ -142,1 +148,2 @@\n-    @IR(counts = { IRNode.REPLICATE_I, \"> 0\" },\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -147,2 +154,2 @@\n-    public static void testMaskFromLongFloat() {\n-        testMaskFromLong(F_SPECIES);\n+    public static void testMaskFromLongMaskAllFloat() {\n+        testMaskFromLongMaskAll(F_SPECIES);\n@@ -155,1 +162,2 @@\n-    @IR(counts = { IRNode.REPLICATE_L, \"> 0\" },\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -160,0 +168,91 @@\n+    public static void testMaskFromLongMaskAllDouble() {\n+        testMaskFromLongMaskAll(D_SPECIES);\n+    }\n+\n+    \/\/ Tests for general input long values\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongByte() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(B_SPECIES, (-1L >>> (64 - B_SPECIES.length()))-1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongShort() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(S_SPECIES, (-1L >>> (64 - S_SPECIES.length()))-1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongInt() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(I_SPECIES, (-1L >>> (64 - I_SPECIES.length()))-1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongLong() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(L_SPECIES, (-1L >>> (64 - L_SPECIES.length()))-1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongFloat() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(F_SPECIES, (-1L >>> (64 - F_SPECIES.length()))-1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n@@ -161,1 +260,2 @@\n-        testMaskFromLong(D_SPECIES);\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(D_SPECIES, (-1L >>> (64 - D_SPECIES.length()))-1);\n@@ -166,2 +266,2 @@\n-        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\");\n-        testFramework.start();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskFromLongTest.java","additions":133,"deletions":33,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -48,6 +48,0 @@\n-    @ForceInline\n-    static long maskFromLongToLong(VectorSpecies<?> species, long inputLong) {\n-        var vmask = VectorMask.fromLong(species, inputLong);\n-        return vmask.toLong();\n-    }\n-\n@@ -55,1 +49,1 @@\n-    static void verifyMaskFromLongToLong(VectorSpecies<?> species, long inputLong, long got) {\n+    public static void verifyMaskToLong(VectorSpecies<?> species, long inputLong, long got) {\n@@ -61,1 +55,1 @@\n-    public static void testMaskFromLongToLong(VectorSpecies<?> species) {\n+    public static void testMaskAllToLong(VectorSpecies<?> species) {\n@@ -64,2 +58,3 @@\n-        long got = maskFromLongToLong(species, inputLong);\n-        verifyMaskFromLongToLong(species, inputLong, got);\n+        \/\/ fromLong is expected to be converted to maskAll.\n+        long got = VectorMask.fromLong(species, inputLong).toLong();\n+        verifyMaskToLong(species, inputLong, got);\n@@ -68,2 +63,2 @@\n-        got = maskFromLongToLong(species, inputLong);\n-        verifyMaskFromLongToLong(species, inputLong, got);\n+        got = VectorMask.fromLong(species, inputLong).toLong();\n+        verifyMaskToLong(species, inputLong, got);\n@@ -72,2 +67,2 @@\n-        got = maskFromLongToLong(species, inputLong);\n-        verifyMaskFromLongToLong(species, inputLong, got);\n+        got = VectorMask.fromLong(species, inputLong).toLong();\n+        verifyMaskToLong(species, inputLong, got);\n@@ -75,3 +70,3 @@\n-        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n-        got = maskFromLongToLong(species, inputLong);\n-        verifyMaskFromLongToLong(species, inputLong, got);\n+        inputLong = (-1L >>> (64 - vlen));\n+        got = VectorMask.fromLong(species, inputLong).toLong();\n+        verifyMaskToLong(species, inputLong, got);\n@@ -92,2 +87,2 @@\n-    public static void testMaskFromLongToLongByte() {\n-        testMaskFromLongToLong(B_SPECIES);\n+    public static void testMaskAllToLongByte() {\n+        testMaskAllToLong(B_SPECIES);\n@@ -108,2 +103,2 @@\n-    public static void testMaskFromLongToLongShort() {\n-        testMaskFromLongToLong(S_SPECIES);\n+    public static void testMaskAllToLongShort() {\n+        testMaskAllToLong(S_SPECIES);\n@@ -124,2 +119,2 @@\n-    public static void testMaskFromLongToLongInt() {\n-        testMaskFromLongToLong(I_SPECIES);\n+    public static void testMaskAllToLongInt() {\n+        testMaskAllToLong(I_SPECIES);\n@@ -140,2 +135,2 @@\n-    public static void testMaskFromLongToLongLong() {\n-        testMaskFromLongToLong(L_SPECIES);\n+    public static void testMaskAllToLongLong() {\n+        testMaskAllToLong(L_SPECIES);\n@@ -156,2 +151,2 @@\n-    public static void testMaskFromLongToLongFloat() {\n-        testMaskFromLongToLong(F_SPECIES);\n+    public static void testMaskAllToLongFloat() {\n+        testMaskAllToLong(F_SPECIES);\n@@ -172,2 +167,88 @@\n-    public static void testMaskFromLongToLongDouble() {\n-        testMaskFromLongToLong(D_SPECIES);\n+    public static void testMaskAllToLongDouble() {\n+        testMaskAllToLong(D_SPECIES);\n+    }\n+\n+    \/\/ General cases for (VectorMaskToLong (VectorLongToMask (x))) => x.\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongByte() {\n+        \/\/ Test the case where some but not all bits are set.\n+       long inputLong = (-1L >>> (64 - B_SPECIES.length()))-1;\n+       long got = VectorMask.fromLong(B_SPECIES, inputLong).toLong();\n+       verifyMaskToLong(B_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongShort() {\n+        \/\/ Test the case where some but not all bits are set.\n+        long inputLong = (-1L >>> (64 - S_SPECIES.length()))-1;\n+        long got = VectorMask.fromLong(S_SPECIES, inputLong).toLong();\n+        verifyMaskToLong(S_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongInt() {\n+        \/\/ Test the case where some but not all bits are set.\n+        long inputLong = (-1L >>> (64 - I_SPECIES.length()))-1;\n+        long got = VectorMask.fromLong(I_SPECIES, inputLong).toLong();\n+        verifyMaskToLong(I_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongLong() {\n+        \/\/ Test the case where some but not all bits are set.\n+        long inputLong = (-1L >>> (64 - L_SPECIES.length()))-1;\n+        long got = VectorMask.fromLong(L_SPECIES, inputLong).toLong();\n+        verifyMaskToLong(L_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongFloat() {\n+        \/\/ Test the case where some but not all bits are set.\n+        long inputLong = (-1L >>> (64 - F_SPECIES.length()))-1;\n+        long got = VectorMask.fromLong(F_SPECIES, inputLong).toLong();\n+        verifyMaskToLong(F_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongDouble() {\n+        \/\/ Test the case where some but not all bits are set.\n+        long inputLong = (-1L >>> (64 - D_SPECIES.length()))-1;\n+        long got = VectorMask.fromLong(D_SPECIES, inputLong).toLong();\n+        verifyMaskToLong(D_SPECIES, inputLong, got);\n@@ -178,2 +259,2 @@\n-        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\");\n-        testFramework.start();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskToLongTest.java","additions":112,"deletions":31,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 1, jvmArgs = {\"--add-modules=jdk.incubator.vector\"})\n+public class MaskFromLongToLongBenchmark {\n+    private static final int ITERATION = 10000;\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long microMaskFromLongToLong(VectorSpecies<?> species) {\n+        long result = 0;\n+        for (int i = 0; i < ITERATION; i++) {\n+            long mask = Math.min(-1, Math.max(-1, result));\n+            result += VectorMask.fromLong(species, mask).toLong();\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Byte64() {\n+        return microMaskFromLongToLong(ByteVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Byte128() {\n+        return microMaskFromLongToLong(ByteVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Byte256() {\n+        return microMaskFromLongToLong(ByteVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Byte512() {\n+        return microMaskFromLongToLong(ByteVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Short64() {\n+        return microMaskFromLongToLong(ShortVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Short128() {\n+        return microMaskFromLongToLong(ShortVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Short256() {\n+        return microMaskFromLongToLong(ShortVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Short512() {\n+        return microMaskFromLongToLong(ShortVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Integer64() {\n+        return microMaskFromLongToLong(IntVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Integer128() {\n+        return microMaskFromLongToLong(IntVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Integer256() {\n+        return microMaskFromLongToLong(IntVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Integer512() {\n+        return microMaskFromLongToLong(IntVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Long64() {\n+        return microMaskFromLongToLong(LongVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Long128() {\n+        return microMaskFromLongToLong(LongVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Long256() {\n+        return microMaskFromLongToLong(LongVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Long512() {\n+        return microMaskFromLongToLong(LongVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Float64() {\n+        return microMaskFromLongToLong(FloatVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Float128() {\n+        return microMaskFromLongToLong(FloatVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Float256() {\n+        return microMaskFromLongToLong(FloatVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Float512() {\n+        return microMaskFromLongToLong(FloatVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Double64() {\n+        return microMaskFromLongToLong(DoubleVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Double128() {\n+        return microMaskFromLongToLong(DoubleVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Double256() {\n+        return microMaskFromLongToLong(DoubleVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Double512() {\n+        return microMaskFromLongToLong(DoubleVector.SPECIES_512);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskFromLongToLongBenchmark.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"}]}