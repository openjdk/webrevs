{"files":[{"patch":"@@ -76,0 +76,9 @@\n+static bool is_maskall_type(const TypeLong* type, int vlen) {\n+  if (!type->is_con()) {\n+    return false;\n+  }\n+  long mask = (0xFFFFFFFFFFFFFFFFULL >> (64 - vlen));\n+  long bit  = type->get_con() & mask;\n+  return bit == 0 || bit == mask;\n+}\n+\n@@ -688,1 +697,11 @@\n-  if (!arch_supports_vector(opc, num_elem, elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n+  Node* broadcast = nullptr;\n+  Node* bits = argument(3);\n+  BasicType converted_elem_bt = elem_bt == T_DOUBLE ? T_LONG : (elem_bt == T_FLOAT ? T_INT: elem_bt);\n+  \/\/ If bits sets or unsets all lanes, convert VectorLongToMask to Replicate.\n+  if (opc == Op_VectorLongToMask &&\n+      is_maskall_type(bits_type, num_elem) &&\n+      arch_supports_vector(Op_Replicate, num_elem, converted_elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n+        opc = Op_Replicate;\n+        elem_bt = converted_elem_bt;\n+        bits = gvn().longcon(bits_type->get_con() == 0L ? 0L : -1L);\n+  } else if (!arch_supports_vector(opc, num_elem, elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n@@ -695,3 +714,0 @@\n-\n-  Node* broadcast = nullptr;\n-  Node* bits = argument(3);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1376,0 +1376,10 @@\n+    public static final String MASK_ALL = PREFIX + \"MASK_ALL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MASK_ALL, \"MaskAll\");\n+    }\n+\n+    public static final String VECTOR_LONG_TO_MASK = PREFIX + \"VECTOR_LONG_TO_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_LONG_TO_MASK, \"VectorLongToMask\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8356760\n+* @library \/test\/lib \/\n+* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n+* @modules jdk.incubator.vector\n+*\n+* @run driver compiler.vectorapi.VectorMaskFromLongTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+public class VectorMaskFromLongTest {\n+    static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    @ForceInline\n+    static void testMaskFromLong(VectorSpecies<?> species, long inputLong) {\n+        var vmask = VectorMask.fromLong(species, inputLong);\n+        long outputLong = vmask.toLong();\n+        long expectedLong = inputLong & (0xFFFFFFFFFFFFFFFFL >>> (64 - species.length()));\n+        Asserts.assertEquals(outputLong, expectedLong);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongByte() {\n+        testMaskFromLong(B_SPECIES, 0L);\n+        testMaskFromLong(B_SPECIES, (0x1L << B_SPECIES.length()));\n+        testMaskFromLong(B_SPECIES, -1L);\n+        testMaskFromLong(B_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - B_SPECIES.length())));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongShort() {\n+        testMaskFromLong(S_SPECIES, 0L);\n+        testMaskFromLong(S_SPECIES, (0x1L << S_SPECIES.length()));\n+        testMaskFromLong(S_SPECIES, -1L);\n+        testMaskFromLong(S_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - S_SPECIES.length())));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongInt() {\n+        testMaskFromLong(I_SPECIES, 0L);\n+        testMaskFromLong(I_SPECIES, (0x1L << I_SPECIES.length()));\n+        testMaskFromLong(I_SPECIES, -1L);\n+        testMaskFromLong(I_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - I_SPECIES.length())));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongLong() {\n+        testMaskFromLong(L_SPECIES, 0L);\n+        testMaskFromLong(L_SPECIES, (0x1L << L_SPECIES.length()));\n+        testMaskFromLong(L_SPECIES, -1L);\n+        testMaskFromLong(L_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - L_SPECIES.length())));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongFloat() {\n+        testMaskFromLong(F_SPECIES, 0L);\n+        testMaskFromLong(F_SPECIES, (0x1L << F_SPECIES.length()));\n+        testMaskFromLong(F_SPECIES, -1L);\n+        testMaskFromLong(F_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - F_SPECIES.length())));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongDouble() {\n+        testMaskFromLong(D_SPECIES, 0L);\n+        testMaskFromLong(D_SPECIES, (0x1L << D_SPECIES.length()));\n+        testMaskFromLong(D_SPECIES, -1L);\n+        testMaskFromLong(D_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - D_SPECIES.length())));\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\");\n+        testFramework.start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskFromLongTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"}]}