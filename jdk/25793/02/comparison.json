{"files":[{"patch":"@@ -76,0 +76,9 @@\n+static bool is_maskall_type(const TypeLong* type, int vlen) {\n+  if (!type->is_con()) {\n+    return false;\n+  }\n+  long mask = (-1ULL >> (64 - vlen));\n+  long bit  = type->get_con() & mask;\n+  return bit == 0 || bit == mask;\n+}\n+\n@@ -688,1 +697,11 @@\n-  if (!arch_supports_vector(opc, num_elem, elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n+  Node* broadcast = nullptr;\n+  Node* bits = argument(3);\n+  BasicType converted_elem_bt = elem_bt == T_DOUBLE ? T_LONG : (elem_bt == T_FLOAT ? T_INT: elem_bt);\n+  \/\/ If bits sets or unsets all lanes, convert VectorLongToMask to Replicate.\n+  if (opc == Op_VectorLongToMask &&\n+      is_maskall_type(bits_type, num_elem) &&\n+      arch_supports_vector(Op_Replicate, num_elem, converted_elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n+    opc = Op_Replicate;\n+    elem_bt = converted_elem_bt;\n+    bits = gvn().longcon((bits_type->get_con() & 1L) == 0L ? 0L : -1L);\n+  } else if (!arch_supports_vector(opc, num_elem, elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n@@ -695,3 +714,0 @@\n-\n-  Node* broadcast = nullptr;\n-  Node* bits = argument(3);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1921,0 +1921,21 @@\n+\/\/ This function does the following optimization:\n+\/\/   toLong(maskAll(true))  => (-1ULL >> (64 - vlen))\n+\/\/   toLong(maskAll(false)) => 0\n+Node* VectorMaskToLongNode::Identity_MaskAll(PhaseGVN* phase) {\n+  Node* in1 = in(1);\n+  if (in1->Opcode() == Op_VectorStoreMask) {\n+    in1 = in1->in(1);\n+  }\n+  if (in1->bottom_type()->isa_vect() == nullptr) {\n+    return nullptr;\n+  }\n+  int vlen = in1->bottom_type()->is_vect()->length();\n+  if (VectorNode::is_all_ones_vector(in1)) {\n+    return phase->longcon((-1ULL >> (64 - vlen)));\n+  }\n+  if (VectorNode::is_all_zeros_vector(in1)) {\n+    return phase->longcon(0L);\n+  }\n+  return nullptr;\n+}\n+\n@@ -1925,1 +1946,2 @@\n-  return this;\n+  Node* res = Identity_MaskAll(phase);\n+  return res == nullptr ? this : res;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1399,0 +1399,1 @@\n+  Node* Identity_MaskAll(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1392,0 +1392,15 @@\n+    public static final String MASK_ALL = PREFIX + \"MASK_ALL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MASK_ALL, \"MaskAll\");\n+    }\n+\n+    public static final String VECTOR_LONG_TO_MASK = PREFIX + \"VECTOR_LONG_TO_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_LONG_TO_MASK, \"VectorLongToMask\");\n+    }\n+\n+    public static final String VECTOR_MASK_TO_LONG = PREFIX + \"VECTOR_MASK_TO_LONG\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_TO_LONG, \"VectorMaskToLong\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8356760\n+* @library \/test\/lib \/\n+* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n+* @modules jdk.incubator.vector\n+*\n+* @run driver compiler.vectorapi.VectorMaskFromLongTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+public class VectorMaskFromLongTest {\n+    static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    static boolean[] mr = new boolean[B_SPECIES.length()];\n+\n+    @ForceInline\n+    static void maskFromLongKernel(VectorSpecies<?> species, long inputLong) {\n+        var vmask = VectorMask.fromLong(species, inputLong);\n+        vmask.intoArray(mr, 0);\n+    }\n+\n+    @DontInline\n+    static void verifyMaskFromLong(VectorSpecies<?> species, long inputLong, boolean expectedValue) {\n+        for (int i = 0; i < species.length(); i++) {\n+            if (mr[i] != expectedValue) {\n+                Asserts.fail(\"Mask bit \" + i + \" is expected to be \" + expectedValue +\n+                        \" but was \" + mr[i] + \" for long \" + inputLong);\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testMaskFromLong(VectorSpecies<?> species) {\n+        int vlen = species.length();\n+        long inputLong = 0L;\n+        maskFromLongKernel(species, inputLong);\n+        verifyMaskFromLong(species, inputLong, false);\n+\n+        inputLong = vlen >= 64 ? 0L : (0x1L << vlen);\n+        maskFromLongKernel(species, inputLong);\n+        verifyMaskFromLong(species, inputLong, false);\n+\n+        inputLong = -1L;\n+        maskFromLongKernel(species, inputLong);\n+        verifyMaskFromLong(species, inputLong, true);\n+\n+        inputLong = (-1L >>> (64 - vlen));\n+        maskFromLongKernel(species, inputLong);\n+        verifyMaskFromLong(species, inputLong, true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongByte() {\n+        testMaskFromLong(B_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongShort() {\n+        testMaskFromLong(S_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongInt() {\n+        testMaskFromLong(I_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongLong() {\n+        testMaskFromLong(L_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongFloat() {\n+        testMaskFromLong(F_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongDouble() {\n+        testMaskFromLong(D_SPECIES);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\");\n+        testFramework.start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskFromLongTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8356760\n+* @library \/test\/lib \/\n+* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n+* @modules jdk.incubator.vector\n+*\n+* @run driver compiler.vectorapi.VectorMaskToLongTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+public class VectorMaskToLongTest {\n+    static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    @ForceInline\n+    static long maskFromLongToLong(VectorSpecies<?> species, long inputLong) {\n+        var vmask = VectorMask.fromLong(species, inputLong);\n+        return vmask.toLong();\n+    }\n+\n+    @DontInline\n+    static void verifyMaskFromLongToLong(VectorSpecies<?> species, long inputLong, long got) {\n+        long expected = inputLong & (-1L >>> (64 - species.length()));\n+        Asserts.assertEquals(expected, got, \"for input long \" + inputLong);\n+    }\n+\n+    @ForceInline\n+    public static void testMaskFromLongToLong(VectorSpecies<?> species) {\n+        int vlen = species.length();\n+        long inputLong = 0L;\n+        long got = maskFromLongToLong(species, inputLong);\n+        verifyMaskFromLongToLong(species, inputLong, got);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        got = maskFromLongToLong(species, inputLong);\n+        verifyMaskFromLongToLong(species, inputLong, got);\n+\n+        inputLong = -1L;\n+        got = maskFromLongToLong(species, inputLong);\n+        verifyMaskFromLongToLong(species, inputLong, got);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        got = maskFromLongToLong(species, inputLong);\n+        verifyMaskFromLongToLong(species, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongByte() {\n+        testMaskFromLongToLong(B_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongShort() {\n+        testMaskFromLongToLong(S_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongInt() {\n+        testMaskFromLongToLong(I_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongLong() {\n+        testMaskFromLongToLong(L_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongFloat() {\n+        testMaskFromLongToLong(F_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongDouble() {\n+        testMaskFromLongToLong(D_SPECIES);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\");\n+        testFramework.start();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskToLongTest.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"}]}