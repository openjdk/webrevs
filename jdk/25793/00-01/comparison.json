{"files":[{"patch":"@@ -80,1 +80,1 @@\n-  long mask = (0xFFFFFFFFFFFFFFFFULL >> (64 - vlen));\n+  long mask = (-1ULL >> (64 - vlen));\n@@ -704,3 +704,3 @@\n-        opc = Op_Replicate;\n-        elem_bt = converted_elem_bt;\n-        bits = gvn().longcon(bits_type->get_con() == 0L ? 0L : -1L);\n+    opc = Op_Replicate;\n+    elem_bt = converted_elem_bt;\n+    bits = gvn().longcon((bits_type->get_con() & 1L) == 0L ? 0L : -1L);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1921,0 +1921,21 @@\n+\/\/ This function does the following optimization:\n+\/\/   toLong(maskAll(true))  => (-1ULL >> (64 -vlen))\n+\/\/   toLong(maskAll(false)) => 0\n+Node* VectorMaskToLongNode::Identity_MaskAll(PhaseGVN* phase) {\n+  Node* in1 = in(1);\n+  if (in1->Opcode() == Op_VectorStoreMask) {\n+    in1 = in1->in(1);\n+  }\n+  if (in1->bottom_type()->isa_vect() == nullptr) {\n+    return nullptr;\n+  }\n+  int vlen = in1->bottom_type()->is_vect()->length();\n+  if (VectorNode::is_all_ones_vector(in1)) {\n+    return phase->longcon((-1ULL >> (64 - vlen)));\n+  }\n+  if (VectorNode::is_all_zeros_vector(in1)) {\n+    return phase->longcon(0L);\n+  }\n+  return nullptr;\n+}\n+\n@@ -1925,1 +1946,2 @@\n-  return this;\n+  Node* res = Identity_MaskAll(phase);\n+  return res == nullptr ? this : res;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1399,0 +1399,1 @@\n+  Node* Identity_MaskAll(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1402,0 +1402,5 @@\n+    public static final String VECTOR_MASK_TO_LONG = PREFIX + \"VECTOR_MASK_TO_LONG\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_TO_LONG, \"VectorMaskToLong\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n@@ -46,0 +45,1 @@\n+    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n@@ -48,0 +48,2 @@\n+    static boolean[] mr = new boolean[B_SPECIES.length()];\n+\n@@ -49,1 +51,1 @@\n-    static void testMaskFromLong(VectorSpecies<?> species, long inputLong) {\n+    static void maskFromLongKernel(VectorSpecies<?> species, long inputLong) {\n@@ -51,3 +53,11 @@\n-        long outputLong = vmask.toLong();\n-        long expectedLong = inputLong & (0xFFFFFFFFFFFFFFFFL >>> (64 - species.length()));\n-        Asserts.assertEquals(outputLong, expectedLong);\n+        vmask.intoArray(mr, 0);\n+    }\n+\n+    @DontInline\n+    static void verifyMaskFromLong(VectorSpecies<?> species, long inputLong, boolean expectedValue) {\n+        for (int i = 0; i < species.length(); i++) {\n+            if (mr[i] != expectedValue) {\n+                Asserts.fail(\"Mask bit \" + i + \" is expected to be \" + expectedValue +\n+                        \" but was \" + mr[i] + \" for long \" + inputLong);\n+            }\n+        }\n@@ -57,1 +67,2 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -59,1 +70,1 @@\n-    @IR(counts = { IRNode.REPLICATE_B, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_B, \"> 0\" },\n@@ -61,1 +72,2 @@\n-    @IR(counts = { IRNode.REPLICATE_B, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_B, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -64,4 +76,16 @@\n-        testMaskFromLong(B_SPECIES, 0L);\n-        testMaskFromLong(B_SPECIES, (0x1L << B_SPECIES.length()));\n-        testMaskFromLong(B_SPECIES, -1L);\n-        testMaskFromLong(B_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - B_SPECIES.length())));\n+        int vlen = B_SPECIES.length();\n+        long inputLong = 0L;\n+        maskFromLongKernel(B_SPECIES, inputLong);\n+        verifyMaskFromLong(B_SPECIES, inputLong, false);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        maskFromLongKernel(B_SPECIES, inputLong);\n+        verifyMaskFromLong(B_SPECIES, inputLong, false);\n+\n+        inputLong = -1L;\n+        maskFromLongKernel(B_SPECIES, inputLong);\n+        verifyMaskFromLong(B_SPECIES, inputLong, true);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        maskFromLongKernel(B_SPECIES, inputLong);\n+        verifyMaskFromLong(B_SPECIES, inputLong, true);\n@@ -71,1 +95,2 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -73,1 +98,1 @@\n-    @IR(counts = { IRNode.REPLICATE_S, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_S, \"> 0\" },\n@@ -75,1 +100,2 @@\n-    @IR(counts = { IRNode.REPLICATE_S, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_S, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -78,4 +104,16 @@\n-        testMaskFromLong(S_SPECIES, 0L);\n-        testMaskFromLong(S_SPECIES, (0x1L << S_SPECIES.length()));\n-        testMaskFromLong(S_SPECIES, -1L);\n-        testMaskFromLong(S_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - S_SPECIES.length())));\n+        int vlen = S_SPECIES.length();\n+        long inputLong = 0L;\n+        maskFromLongKernel(S_SPECIES, inputLong);\n+        verifyMaskFromLong(S_SPECIES, inputLong, false);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        maskFromLongKernel(S_SPECIES, inputLong);\n+        verifyMaskFromLong(S_SPECIES, inputLong, false);\n+\n+        inputLong = -1L;\n+        maskFromLongKernel(S_SPECIES, inputLong);\n+        verifyMaskFromLong(S_SPECIES, inputLong, true);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        maskFromLongKernel(S_SPECIES, inputLong);\n+        verifyMaskFromLong(S_SPECIES, inputLong, true);\n@@ -85,1 +123,2 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -87,1 +126,1 @@\n-    @IR(counts = { IRNode.REPLICATE_I, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\" },\n@@ -89,1 +128,2 @@\n-    @IR(counts = { IRNode.REPLICATE_I, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -92,4 +132,16 @@\n-        testMaskFromLong(I_SPECIES, 0L);\n-        testMaskFromLong(I_SPECIES, (0x1L << I_SPECIES.length()));\n-        testMaskFromLong(I_SPECIES, -1L);\n-        testMaskFromLong(I_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - I_SPECIES.length())));\n+        int vlen = I_SPECIES.length();\n+        long inputLong = 0L;\n+        maskFromLongKernel(I_SPECIES, inputLong);\n+        verifyMaskFromLong(I_SPECIES, inputLong, false);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        maskFromLongKernel(I_SPECIES, inputLong);\n+        verifyMaskFromLong(I_SPECIES, inputLong, false);\n+\n+        inputLong = -1L;\n+        maskFromLongKernel(I_SPECIES, inputLong);\n+        verifyMaskFromLong(I_SPECIES, inputLong, true);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        maskFromLongKernel(I_SPECIES, inputLong);\n+        verifyMaskFromLong(I_SPECIES, inputLong, true);\n@@ -99,1 +151,2 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -101,1 +154,1 @@\n-    @IR(counts = { IRNode.REPLICATE_L, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\" },\n@@ -103,1 +156,2 @@\n-    @IR(counts = { IRNode.REPLICATE_L, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -106,4 +160,16 @@\n-        testMaskFromLong(L_SPECIES, 0L);\n-        testMaskFromLong(L_SPECIES, (0x1L << L_SPECIES.length()));\n-        testMaskFromLong(L_SPECIES, -1L);\n-        testMaskFromLong(L_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - L_SPECIES.length())));\n+        int vlen = L_SPECIES.length();\n+        long inputLong = 0L;\n+        maskFromLongKernel(L_SPECIES, inputLong);\n+        verifyMaskFromLong(L_SPECIES, inputLong, false);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        maskFromLongKernel(L_SPECIES, inputLong);\n+        verifyMaskFromLong(L_SPECIES, inputLong, false);\n+\n+        inputLong = -1L;\n+        maskFromLongKernel(L_SPECIES, inputLong);\n+        verifyMaskFromLong(L_SPECIES, inputLong, true);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        maskFromLongKernel(L_SPECIES, inputLong);\n+        verifyMaskFromLong(L_SPECIES, inputLong, true);\n@@ -113,1 +179,2 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -115,1 +182,1 @@\n-    @IR(counts = { IRNode.REPLICATE_I, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\" },\n@@ -117,1 +184,2 @@\n-    @IR(counts = { IRNode.REPLICATE_I, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -120,4 +188,16 @@\n-        testMaskFromLong(F_SPECIES, 0L);\n-        testMaskFromLong(F_SPECIES, (0x1L << F_SPECIES.length()));\n-        testMaskFromLong(F_SPECIES, -1L);\n-        testMaskFromLong(F_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - F_SPECIES.length())));\n+        int vlen = F_SPECIES.length();\n+        long inputLong = 0L;\n+        maskFromLongKernel(F_SPECIES, inputLong);\n+        verifyMaskFromLong(F_SPECIES, inputLong, false);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        maskFromLongKernel(F_SPECIES, inputLong);\n+        verifyMaskFromLong(F_SPECIES, inputLong, false);\n+\n+        inputLong = -1L;\n+        maskFromLongKernel(F_SPECIES, inputLong);\n+        verifyMaskFromLong(F_SPECIES, inputLong, true);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        maskFromLongKernel(F_SPECIES, inputLong);\n+        verifyMaskFromLong(F_SPECIES, inputLong, true);\n@@ -127,1 +207,2 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -129,1 +210,1 @@\n-    @IR(counts = { IRNode.REPLICATE_L, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\" },\n@@ -131,1 +212,2 @@\n-    @IR(counts = { IRNode.REPLICATE_L, \"> 0\", IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n@@ -134,4 +216,16 @@\n-        testMaskFromLong(D_SPECIES, 0L);\n-        testMaskFromLong(D_SPECIES, (0x1L << D_SPECIES.length()));\n-        testMaskFromLong(D_SPECIES, -1L);\n-        testMaskFromLong(D_SPECIES, (0xFFFFFFFFFFFFFFFFL >>> (64 - D_SPECIES.length())));\n+        int vlen = D_SPECIES.length();\n+        long inputLong = 0L;\n+        maskFromLongKernel(D_SPECIES, inputLong);\n+        verifyMaskFromLong(D_SPECIES, inputLong, false);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        maskFromLongKernel(D_SPECIES, inputLong);\n+        verifyMaskFromLong(D_SPECIES, inputLong, false);\n+\n+        inputLong = -1L;\n+        maskFromLongKernel(D_SPECIES, inputLong);\n+        verifyMaskFromLong(D_SPECIES, inputLong, true);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        maskFromLongKernel(D_SPECIES, inputLong);\n+        verifyMaskFromLong(D_SPECIES, inputLong, true);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskFromLongTest.java","additions":141,"deletions":47,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8356760\n+* @library \/test\/lib \/\n+* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n+* @modules jdk.incubator.vector\n+*\n+* @run driver compiler.vectorapi.VectorMaskToLongTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+public class VectorMaskToLongTest {\n+    static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    @ForceInline\n+    static long maskFromLongToLong(VectorSpecies<?> species, long inputLong) {\n+        var vmask = VectorMask.fromLong(species, inputLong);\n+        return vmask.toLong();\n+    }\n+\n+    @DontInline\n+    static void verifyMaskFromLongToLong(VectorSpecies<?> species, long inputLong, long got) {\n+        long expected = inputLong & (-1L >>> (64 - species.length()));\n+        Asserts.assertEquals(expected, got, \"for input long \" + inputLong);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongByte() {\n+        int vlen = B_SPECIES.length();\n+        long inputLong = 0L;\n+        long got = maskFromLongToLong(B_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(B_SPECIES, inputLong, got);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        got = maskFromLongToLong(B_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(B_SPECIES, inputLong, got);\n+\n+        inputLong = -1L;\n+        got = maskFromLongToLong(B_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(B_SPECIES, inputLong, got);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        got = maskFromLongToLong(B_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(B_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongShort() {\n+        int vlen = S_SPECIES.length();\n+        long inputLong = 0L;\n+        long got = maskFromLongToLong(S_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(S_SPECIES, inputLong, got);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        got = maskFromLongToLong(S_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(S_SPECIES, inputLong, got);\n+\n+        inputLong = -1L;\n+        got = maskFromLongToLong(S_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(S_SPECIES, inputLong, got);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        got = maskFromLongToLong(S_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(S_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongInt() {\n+        int vlen = I_SPECIES.length();\n+        long inputLong = 0L;\n+        long got = maskFromLongToLong(I_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(I_SPECIES, inputLong, got);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        got = maskFromLongToLong(I_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(I_SPECIES, inputLong, got);\n+\n+        inputLong = -1L;\n+        got = maskFromLongToLong(I_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(I_SPECIES, inputLong, got);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        got = maskFromLongToLong(I_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(I_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongLong() {\n+        int vlen = L_SPECIES.length();\n+        long inputLong = 0L;\n+        long got = maskFromLongToLong(L_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(L_SPECIES, inputLong, got);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        got = maskFromLongToLong(L_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(L_SPECIES, inputLong, got);\n+\n+        inputLong = -1L;\n+        got = maskFromLongToLong(L_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(L_SPECIES, inputLong, got);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        got = maskFromLongToLong(L_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(L_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongFloat() {\n+        int vlen = F_SPECIES.length();\n+        long inputLong = 0L;\n+        long got = maskFromLongToLong(F_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(F_SPECIES, inputLong, got);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        got = maskFromLongToLong(F_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(F_SPECIES, inputLong, got);\n+\n+        inputLong = -1L;\n+        got = maskFromLongToLong(F_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(F_SPECIES, inputLong, got);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        got = maskFromLongToLong(F_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(F_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongToLongDouble() {\n+        int vlen = D_SPECIES.length();\n+        long inputLong = 0L;\n+        long got = maskFromLongToLong(D_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(D_SPECIES, inputLong, got);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        got = maskFromLongToLong(D_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(D_SPECIES, inputLong, got);\n+\n+        inputLong = -1L;\n+        got = maskFromLongToLong(D_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(D_SPECIES, inputLong, got);\n+\n+        inputLong = (0xFFFFFFFFFFFFFFFFL >>> (64 - vlen));\n+        got = maskFromLongToLong(D_SPECIES, inputLong);\n+        verifyMaskFromLongToLong(D_SPECIES, inputLong, got);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\");\n+        testFramework.start();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskToLongTest.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"}]}