{"files":[{"patch":"@@ -689,5 +689,14 @@\n-    log_if_needed(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d bcast_mode=%d\",\n-                    num_elem, type2name(elem_bt),\n-                    is_mask ? 1 : 0,\n-                    bcast_mode);\n-    return false; \/\/ not supported\n+    \/\/ If the input long sets or unsets all lanes and Replicate is supported,\n+    \/\/ generate a MaskAll or Replicate instead.\n+\n+    \/\/ The \"maskAll\" API uses the corresponding integer types for floating-point data.\n+    BasicType maskall_bt = elem_bt == T_DOUBLE ? T_LONG : (elem_bt == T_FLOAT ? T_INT: elem_bt);\n+    if (!(opc == Op_VectorLongToMask &&\n+          VectorNode::is_maskall_type(bits_type, num_elem) &&\n+          arch_supports_vector(Op_Replicate, num_elem, maskall_bt, checkFlags, true \/*has_scalar_args*\/))) {\n+      log_if_needed(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d bcast_mode=%d\",\n+                      num_elem, type2name(elem_bt),\n+                      is_mask ? 1 : 0,\n+                      bcast_mode);\n+      return false; \/\/ not supported\n+    }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -437,0 +437,10 @@\n+bool VectorNode::is_maskall_type(const TypeLong* type, int vlen) {\n+  assert(type != nullptr, \"type must not be null\");\n+  if (!type->is_con()) {\n+    return false;\n+  }\n+  long mask = (-1ULL >> (64 - vlen));\n+  long bit  = type->get_con() & mask;\n+  return bit == 0 || bit == mask;\n+}\n+\n@@ -1506,0 +1516,39 @@\n+\/\/ Convert fromLong to maskAll if the input sets or unsets all lanes.\n+Node* convertFromLongToMaskAll(PhaseGVN* phase, const TypeLong* bits_type, bool is_mask, const TypeVect* vt) {\n+  uint vlen = vt->length();\n+  BasicType bt = vt->element_basic_type();\n+  \/\/ The \"maskAll\" API uses the corresponding integer types for floating-point data.\n+  BasicType maskall_bt = (bt == T_FLOAT) ? T_INT : (bt == T_DOUBLE) ? T_LONG : bt;\n+\n+  if (VectorNode::is_maskall_type(bits_type, vlen) &&\n+      Matcher::match_rule_supported_vector(Op_Replicate, vlen, maskall_bt)) {\n+    Node* con = nullptr;\n+    jlong con_value = bits_type->get_con() == 0L ? 0L : -1L;\n+    if (maskall_bt == T_LONG) {\n+      con = phase->longcon(con_value);\n+    } else {\n+      con = phase->intcon(con_value);\n+    }\n+    Node* res = VectorNode::scalar2vector(con, vlen, maskall_bt, is_mask);\n+    \/\/ Convert back to the original floating-point data type.\n+    if (is_floating_point_type(bt)) {\n+      res = new VectorMaskCastNode(phase->transform(res), vt);\n+    }\n+    return res;\n+  }\n+  return nullptr;\n+}\n+\n+Node* VectorLoadMaskNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ VectorLoadMask(VectorLongToMask(-1\/0)) => Replicate(-1\/0)\n+  if (in(1)->Opcode() == Op_VectorLongToMask) {\n+    const TypeVect* vt = bottom_type()->is_vect();\n+    Node* res = convertFromLongToMaskAll(phase, in(1)->in(1)->bottom_type()->isa_long(), false, vt);\n+    if (res != nullptr) {\n+      return res;\n+    }\n+  }\n+\n+  return VectorNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -1921,0 +1970,39 @@\n+Node* VectorMaskCastNode::Identity(PhaseGVN* phase) {\n+  Node* in1 = in(1);\n+  \/\/ VectorMaskCast (VectorMaskCast x) => x\n+  if (in1->Opcode() == Op_VectorMaskCast &&\n+      vect_type()->eq(in1->in(1)->bottom_type())) {\n+      return in1->in(1);\n+  }\n+  return this;\n+}\n+\n+\/\/ This function does the following optimization:\n+\/\/   VectorMaskToLong(MaskAll(l)) => (l & (-1ULL >> (64 - vlen)))\n+\/\/   VectorMaskToLong(VectorStoreMask(Replicate(l))) => (l & (-1ULL >> (64 - vlen)))\n+\/\/ l is -1 or 0.\n+Node* VectorMaskToLongNode::Ideal_MaskAll(PhaseGVN* phase) {\n+  Node* in1 = in(1);\n+  \/\/ VectorMaskToLong follows a VectorStoreMask if predicate is not supported.\n+  if (in1->Opcode() == Op_VectorStoreMask) {\n+    in1 = in1->in(1);\n+    assert(!in1->bottom_type()->isa_vectmask(), \"sanity\");\n+  }\n+  if (VectorNode::is_all_ones_vector(in1)) {\n+    int vlen = in1->bottom_type()->is_vect()->length();\n+    return new ConLNode(TypeLong::make(-1ULL >> (64 - vlen)));\n+  }\n+  if (VectorNode::is_all_zeros_vector(in1)) {\n+    return new ConLNode(TypeLong::ZERO);\n+  }\n+  return nullptr;\n+}\n+\n+Node* VectorMaskToLongNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* res = Ideal_MaskAll(phase);\n+  if (res != nullptr) {\n+    return res;\n+  }\n+  return VectorMaskOpNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -1930,0 +2018,3 @@\n+  uint vlen = dst_type->length();\n+  const TypeVectMask* is_mask = dst_type->isa_vectmask();\n+\n@@ -1934,1 +2025,1 @@\n-      in(1)->in(2)->bottom_type()->is_long()->get_con() == ((1L << dst_type->length()) - 1)) {\n+      in(1)->in(2)->bottom_type()->is_long()->get_con() == ((1L << vlen) - 1)) {\n@@ -1938,1 +2029,1 @@\n-     if (dst_type->isa_vectmask() == nullptr) {\n+     if (is_mask == nullptr) {\n@@ -1945,3 +2036,3 @@\n-     if (src_type->length() == dst_type->length() &&\n-         ((src_type->isa_vectmask() == nullptr && dst_type->isa_vectmask() == nullptr) ||\n-          (src_type->isa_vectmask() && dst_type->isa_vectmask()))) {\n+     if (src_type->length() == vlen &&\n+         ((src_type->isa_vectmask() == nullptr && is_mask == nullptr) ||\n+          (src_type->isa_vectmask() && is_mask))) {\n@@ -1951,1 +2042,11 @@\n-  return nullptr;\n+\n+  \/\/ VectorLongToMask(-1\/0) => MaskAll(-1\/0)\n+  const TypeLong* bits_type = in(1)->bottom_type()->isa_long();\n+  if (bits_type && is_mask) {\n+    Node* res = convertFromLongToMaskAll(phase, bits_type, true, dst_type);\n+    if (res != nullptr) {\n+      return res;\n+    }\n+  }\n+\n+  return VectorNode::Ideal(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":107,"deletions":6,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  static bool is_maskall_type(const TypeLong* type, int vlen);\n@@ -1386,0 +1387,2 @@\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  Node* Ideal_MaskAll(PhaseGVN* phase);\n@@ -1779,0 +1782,1 @@\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1798,0 +1802,1 @@\n+  Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1390,0 +1390,15 @@\n+    public static final String MASK_ALL = PREFIX + \"MASK_ALL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MASK_ALL, \"MaskAll\");\n+    }\n+\n+    public static final String VECTOR_LONG_TO_MASK = PREFIX + \"VECTOR_LONG_TO_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_LONG_TO_MASK, \"VectorLongToMask\");\n+    }\n+\n+    public static final String VECTOR_MASK_TO_LONG = PREFIX + \"VECTOR_MASK_TO_LONG\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_TO_LONG, \"VectorMaskToLong\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8356760\n+* @library \/test\/lib \/\n+* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n+* @modules jdk.incubator.vector\n+*\n+* @run driver compiler.vectorapi.VectorMaskCastIdentityTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class VectorMaskCastIdentityTest {\n+    private static final boolean[] mr = new boolean[128]; \/\/ 128 is large enough\n+    private static final Random rd = Utils.getRandomInstance();\n+    static {\n+        for (int i = 0; i < mr.length; i++) {\n+            mr[i] = rd.nextBoolean();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" }, applyIfCPUFeatureOr = {\"asimd\", \"true\"})\n+    public static int testTwoCastToDifferentType() {\n+        \/\/ The types before and after the two casts are not the same, so the cast cannot be eliminated.\n+        VectorMask<Float> mFloat64 = VectorMask.fromArray(FloatVector.SPECIES_64, mr, 0);\n+        VectorMask<Double> mDouble128 = mFloat64.cast(DoubleVector.SPECIES_128);\n+        VectorMask<Integer> mInt64 = mDouble128.cast(IntVector.SPECIES_64);\n+        return mInt64.trueCount();\n+    }\n+\n+    @Run(test = \"testTwoCastToDifferentType\")\n+    public static void testTwoCastToDifferentType_runner() {\n+        int count = testTwoCastToDifferentType();\n+        VectorMask<Float> mFloat64 = VectorMask.fromArray(FloatVector.SPECIES_64, mr, 0);\n+        Asserts.assertEquals(count, mFloat64.trueCount());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+    public static int testTwoCastToDifferentType2() {\n+        \/\/ The types before and after the two casts are not the same, so the cast cannot be eliminated.\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        VectorMask<Double> mDouble256 = mInt128.cast(DoubleVector.SPECIES_256);\n+        VectorMask<Short>  mShort64 = mDouble256.cast(ShortVector.SPECIES_64);\n+        return mShort64.trueCount();\n+    }\n+\n+    @Run(test = \"testTwoCastToDifferentType2\")\n+    public static void testTwoCastToDifferentType2_runner() {\n+        int count = testTwoCastToDifferentType2();\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        Asserts.assertEquals(count, mInt128.trueCount());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static int testTwoCastToSameType() {\n+        \/\/ The types before and after the two casts are the same, so the cast will be eliminated.\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        VectorMask<Float> mFloat128 = mInt128.cast(FloatVector.SPECIES_128);\n+        VectorMask<Integer> mInt128_2 = mFloat128.cast(IntVector.SPECIES_128);\n+        return mInt128_2.trueCount();\n+    }\n+\n+    @Run(test = \"testTwoCastToSameType\")\n+    public static void testTwoCastToSameType_runner() {\n+        int count = testTwoCastToSameType();\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        Asserts.assertEquals(count, mInt128.trueCount());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static int testOneCastToDifferentType() {\n+        \/\/ The types before and after the only cast are different, the cast will not be eliminated.\n+        VectorMask<Float> mFloat128 = VectorMask.fromArray(FloatVector.SPECIES_128, mr, 0).not();\n+        VectorMask<Integer> mInt128 = mFloat128.cast(IntVector.SPECIES_128);\n+        return mInt128.trueCount();\n+    }\n+\n+    @Run(test = \"testOneCastToDifferentType\")\n+    public static void testOneCastToDifferentType_runner() {\n+        int count = testOneCastToDifferentType();\n+        VectorMask<Float> mInt128 = VectorMask.fromArray(FloatVector.SPECIES_128, mr, 0).not();\n+        Asserts.assertEquals(count, mInt128.trueCount());\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastIdentityTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8356760\n+* @library \/test\/lib \/\n+* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n+* @modules jdk.incubator.vector\n+*\n+* @run driver compiler.vectorapi.VectorMaskFromLongTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+public class VectorMaskFromLongTest {\n+    static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    static boolean[] mr = new boolean[B_SPECIES.length()];\n+\n+    @ForceInline\n+    public static void maskFromLongKernel(VectorSpecies<?> species, long inputLong) {\n+        VectorMask.fromLong(species, inputLong).intoArray(mr, 0);\n+    }\n+\n+    @DontInline\n+    public static void verifyMaskFromLong(VectorSpecies<?> species, long inputLong) {\n+        for (int i = 0; i < species.length(); i++) {\n+            long expectedValue = (inputLong >>> i) & 1L;\n+            if (mr[i] != (expectedValue == 1L)) {\n+                Asserts.fail(\"Mask bit \" + i + \" is expected to be \" + expectedValue +\n+                        \" but was \" + mr[i] + \" for long \" + inputLong);\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testMaskFromLong(VectorSpecies<?> species, long inputLong ) {\n+        maskFromLongKernel(species, inputLong);\n+        verifyMaskFromLong(species, inputLong);\n+    }\n+\n+    @ForceInline\n+    public static void testMaskFromLongMaskAll(VectorSpecies<?> species) {\n+        int vlen = species.length();\n+        long inputLong = 0L;\n+        testMaskFromLong(species, inputLong);\n+\n+        inputLong = vlen >= 64 ? 0L : (0x1L << vlen);\n+        testMaskFromLong(species, inputLong);\n+\n+        inputLong = -1L;\n+        testMaskFromLong(species, inputLong);\n+\n+        inputLong = (-1L >>> (64 - vlen));\n+        testMaskFromLong(species, inputLong);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongMaskAllByte() {\n+        testMaskFromLongMaskAll(B_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongMaskAllShort() {\n+        testMaskFromLongMaskAll(S_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongMaskAllInt() {\n+        testMaskFromLongMaskAll(I_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongMaskAllLong() {\n+        testMaskFromLongMaskAll(L_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongMaskAllFloat() {\n+        testMaskFromLongMaskAll(F_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"> 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongMaskAllDouble() {\n+        testMaskFromLongMaskAll(D_SPECIES);\n+    }\n+\n+    \/\/ Tests for general input long values\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongByte() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(B_SPECIES, (-1L >>> (64 - B_SPECIES.length()))-1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongShort() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(S_SPECIES, (-1L >>> (64 - S_SPECIES.length()))-1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongInt() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(I_SPECIES, (-1L >>> (64 - I_SPECIES.length()))-1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongLong() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(L_SPECIES, (-1L >>> (64 - L_SPECIES.length()))-1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongFloat() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(F_SPECIES, (-1L >>> (64 - F_SPECIES.length()))-1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskFromLongDouble() {\n+        \/\/ Test the case where some but not all bits are set.\n+        testMaskFromLong(D_SPECIES, (-1L >>> (64 - D_SPECIES.length()))-1);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskFromLongTest.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8356760\n+* @library \/test\/lib \/\n+* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n+* @modules jdk.incubator.vector\n+*\n+* @run driver compiler.vectorapi.VectorMaskToLongTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+public class VectorMaskToLongTest {\n+    static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    @DontInline\n+    public static void verifyMaskToLong(VectorSpecies<?> species, long inputLong, long got) {\n+        long expected = inputLong & (-1L >>> (64 - species.length()));\n+        Asserts.assertEquals(expected, got, \"for input long \" + inputLong);\n+    }\n+\n+    @ForceInline\n+    public static void testMaskAllToLong(VectorSpecies<?> species) {\n+        int vlen = species.length();\n+        long inputLong = 0L;\n+        \/\/ fromLong is expected to be converted to maskAll.\n+        long got = VectorMask.fromLong(species, inputLong).toLong();\n+        verifyMaskToLong(species, inputLong, got);\n+\n+        inputLong = vlen >= 64 ? 0 : (0x1L << vlen);\n+        got = VectorMask.fromLong(species, inputLong).toLong();\n+        verifyMaskToLong(species, inputLong, got);\n+\n+        inputLong = -1L;\n+        got = VectorMask.fromLong(species, inputLong).toLong();\n+        verifyMaskToLong(species, inputLong, got);\n+\n+        inputLong = (-1L >>> (64 - vlen));\n+        got = VectorMask.fromLong(species, inputLong).toLong();\n+        verifyMaskToLong(species, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskAllToLongByte() {\n+        testMaskAllToLong(B_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskAllToLongShort() {\n+        testMaskAllToLong(S_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskAllToLongInt() {\n+        testMaskAllToLong(I_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskAllToLongLong() {\n+        testMaskAllToLong(L_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskAllToLongFloat() {\n+        testMaskAllToLong(F_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testMaskAllToLongDouble() {\n+        testMaskAllToLong(D_SPECIES);\n+    }\n+\n+    \/\/ General cases for (VectorMaskToLong (VectorLongToMask (x))) => x.\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongByte() {\n+        \/\/ Test the case where some but not all bits are set.\n+       long inputLong = (-1L >>> (64 - B_SPECIES.length()))-1;\n+       long got = VectorMask.fromLong(B_SPECIES, inputLong).toLong();\n+       verifyMaskToLong(B_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongShort() {\n+        \/\/ Test the case where some but not all bits are set.\n+        long inputLong = (-1L >>> (64 - S_SPECIES.length()))-1;\n+        long got = VectorMask.fromLong(S_SPECIES, inputLong).toLong();\n+        verifyMaskToLong(S_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongInt() {\n+        \/\/ Test the case where some but not all bits are set.\n+        long inputLong = (-1L >>> (64 - I_SPECIES.length()))-1;\n+        long got = VectorMask.fromLong(I_SPECIES, inputLong).toLong();\n+        verifyMaskToLong(I_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongLong() {\n+        \/\/ Test the case where some but not all bits are set.\n+        long inputLong = (-1L >>> (64 - L_SPECIES.length()))-1;\n+        long got = VectorMask.fromLong(L_SPECIES, inputLong).toLong();\n+        verifyMaskToLong(L_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongFloat() {\n+        \/\/ Test the case where some but not all bits are set.\n+        long inputLong = (-1L >>> (64 - F_SPECIES.length()))-1;\n+        long got = VectorMask.fromLong(F_SPECIES, inputLong).toLong();\n+        verifyMaskToLong(F_SPECIES, inputLong, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    public static void testFromLongToLongDouble() {\n+        \/\/ Test the case where some but not all bits are set.\n+        long inputLong = (-1L >>> (64 - D_SPECIES.length()))-1;\n+        long got = VectorMask.fromLong(D_SPECIES, inputLong).toLong();\n+        verifyMaskToLong(D_SPECIES, inputLong, got);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskToLongTest.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,3 @@\n-@Fork(jvmArgs = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 1, jvmArgs = {\"--add-modules=jdk.incubator.vector\"})\n@@ -53,0 +55,9 @@\n+    VectorMask<Float> fmask64;\n+    VectorMask<Float> fmask128;\n+    VectorMask<Float> fmask256;\n+    VectorMask<Float> fmask512;\n+\n+    VectorMask<Double> dmask128;\n+    VectorMask<Double> dmask256;\n+    VectorMask<Double> dmask512;\n+\n@@ -83,0 +94,9 @@\n+\n+        fmask64 = VectorMask.fromArray(FloatVector.SPECIES_64, mask_arr, 0);\n+        fmask128 = VectorMask.fromArray(FloatVector.SPECIES_128, mask_arr, 0);\n+        fmask256 = VectorMask.fromArray(FloatVector.SPECIES_256, mask_arr, 0);\n+        fmask512 = VectorMask.fromArray(FloatVector.SPECIES_512, mask_arr, 0);\n+\n+        dmask128 = VectorMask.fromArray(DoubleVector.SPECIES_128, mask_arr, 0);\n+        dmask256 = VectorMask.fromArray(DoubleVector.SPECIES_256, mask_arr, 0);\n+        dmask512 = VectorMask.fromArray(DoubleVector.SPECIES_512, mask_arr, 0);\n@@ -224,0 +244,108 @@\n+\n+    \/\/ Benchmarks for optimization \"VectorMaskCast (VectorMaskCast x) => x\"\n+\n+    @Benchmark\n+    public int microMaskCastCastByte64() {\n+        return bmask64.cast(ShortVector.SPECIES_128).cast(ByteVector.SPECIES_64).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastByte128() {\n+        return bmask128.cast(ShortVector.SPECIES_256).cast(ByteVector.SPECIES_128).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastByte256() {\n+        return bmask256.cast(ShortVector.SPECIES_512).cast(ByteVector.SPECIES_256).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastShort64() {\n+        return smask64.cast(IntVector.SPECIES_128).cast(ShortVector.SPECIES_64).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastShort128() {\n+        return smask128.cast(ByteVector.SPECIES_64).cast(ShortVector.SPECIES_128).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastShort256() {\n+        return smask256.cast(IntVector.SPECIES_512).cast(ShortVector.SPECIES_256).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastShort512() {\n+        return smask512.cast(ByteVector.SPECIES_256).cast(ShortVector.SPECIES_512).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastInt64() {\n+        return imask64.cast(FloatVector.SPECIES_64).cast(IntVector.SPECIES_64).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastInt128() {\n+        return imask128.cast(ShortVector.SPECIES_64).cast(IntVector.SPECIES_128).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastInt256() {\n+        return imask256.cast(LongVector.SPECIES_512).cast(IntVector.SPECIES_256).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastInt512() {\n+        return imask512.cast(ShortVector.SPECIES_256).cast(IntVector.SPECIES_512).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastLong128() {\n+        return lmask128.cast(IntVector.SPECIES_64).cast(LongVector.SPECIES_128).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastLong256() {\n+        return lmask256.cast(DoubleVector.SPECIES_256).cast(LongVector.SPECIES_256).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastLong512() {\n+        return lmask512.cast(IntVector.SPECIES_256).cast(LongVector.SPECIES_512).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastFloat64() {\n+        return fmask64.cast(DoubleVector.SPECIES_128).cast(FloatVector.SPECIES_64).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastFloat128() {\n+        return fmask128.cast(DoubleVector.SPECIES_256).cast(FloatVector.SPECIES_128).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastFloat256() {\n+        return fmask256.cast(IntVector.SPECIES_256).cast(FloatVector.SPECIES_256).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastFloat512() {\n+        return fmask512.cast(ShortVector.SPECIES_256).cast(FloatVector.SPECIES_512).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastDouble128() {\n+        return dmask128.cast(FloatVector.SPECIES_64).cast(DoubleVector.SPECIES_128).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastDouble256() {\n+        return dmask256.cast(FloatVector.SPECIES_128).cast(DoubleVector.SPECIES_256).trueCount();\n+    }\n+\n+    @Benchmark\n+    public int microMaskCastCastDouble512() {\n+        return dmask512.cast(IntVector.SPECIES_256).cast(DoubleVector.SPECIES_512).trueCount();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskCastOperationsBenchmark.java","additions":130,"deletions":2,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 1, jvmArgs = {\"--add-modules=jdk.incubator.vector\"})\n+public class MaskFromLongToLongBenchmark {\n+    private static final int ITERATION = 10000;\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long microMaskFromLongToLong(VectorSpecies<?> species) {\n+        long result = 0;\n+        for (int i = 0; i < ITERATION; i++) {\n+            long mask = Math.min(-1, Math.max(-1, result));\n+            result += VectorMask.fromLong(species, mask).toLong();\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Byte64() {\n+        return microMaskFromLongToLong(ByteVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Byte128() {\n+        return microMaskFromLongToLong(ByteVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Byte256() {\n+        return microMaskFromLongToLong(ByteVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Byte512() {\n+        return microMaskFromLongToLong(ByteVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Short64() {\n+        return microMaskFromLongToLong(ShortVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Short128() {\n+        return microMaskFromLongToLong(ShortVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Short256() {\n+        return microMaskFromLongToLong(ShortVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Short512() {\n+        return microMaskFromLongToLong(ShortVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Integer64() {\n+        return microMaskFromLongToLong(IntVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Integer128() {\n+        return microMaskFromLongToLong(IntVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Integer256() {\n+        return microMaskFromLongToLong(IntVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Integer512() {\n+        return microMaskFromLongToLong(IntVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Long64() {\n+        return microMaskFromLongToLong(LongVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Long128() {\n+        return microMaskFromLongToLong(LongVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Long256() {\n+        return microMaskFromLongToLong(LongVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Long512() {\n+        return microMaskFromLongToLong(LongVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Float64() {\n+        return microMaskFromLongToLong(FloatVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Float128() {\n+        return microMaskFromLongToLong(FloatVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Float256() {\n+        return microMaskFromLongToLong(FloatVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Float512() {\n+        return microMaskFromLongToLong(FloatVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Double64() {\n+        return microMaskFromLongToLong(DoubleVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Double128() {\n+        return microMaskFromLongToLong(DoubleVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Double256() {\n+        return microMaskFromLongToLong(DoubleVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public long microMaskFromLongToLong_Double512() {\n+        return microMaskFromLongToLong(DoubleVector.SPECIES_512);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskFromLongToLongBenchmark.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"}]}