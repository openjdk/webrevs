{"files":[{"patch":"@@ -13089,374 +13089,0 @@\n-\n-\/\/ 64bit doesn't use the x87\n-\n-void Assembler::fabs() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xE1);\n-}\n-\n-void Assembler::fadd(int i) {\n-  emit_farith(0xD8, 0xC0, i);\n-}\n-\n-void Assembler::fadd_d(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDC);\n-  emit_operand32(rax, src, 0);\n-}\n-\n-void Assembler::fadd_s(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD8);\n-  emit_operand32(rax, src, 0);\n-}\n-\n-void Assembler::fadda(int i) {\n-  emit_farith(0xDC, 0xC0, i);\n-}\n-\n-void Assembler::faddp(int i) {\n-  emit_farith(0xDE, 0xC0, i);\n-}\n-\n-void Assembler::fchs() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xE0);\n-}\n-\n-void Assembler::fcom(int i) {\n-  emit_farith(0xD8, 0xD0, i);\n-}\n-\n-void Assembler::fcomp(int i) {\n-  emit_farith(0xD8, 0xD8, i);\n-}\n-\n-void Assembler::fcomp_d(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDC);\n-  emit_operand32(rbx, src, 0);\n-}\n-\n-void Assembler::fcomp_s(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD8);\n-  emit_operand32(rbx, src, 0);\n-}\n-\n-void Assembler::fcompp() {\n-  emit_int16((unsigned char)0xDE, (unsigned char)0xD9);\n-}\n-\n-void Assembler::fcos() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xFF);\n-}\n-\n-void Assembler::fdecstp() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xF6);\n-}\n-\n-void Assembler::fdiv(int i) {\n-  emit_farith(0xD8, 0xF0, i);\n-}\n-\n-void Assembler::fdiv_d(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDC);\n-  emit_operand32(rsi, src, 0);\n-}\n-\n-void Assembler::fdiv_s(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD8);\n-  emit_operand32(rsi, src, 0);\n-}\n-\n-void Assembler::fdiva(int i) {\n-  emit_farith(0xDC, 0xF8, i);\n-}\n-\n-\/\/ Note: The Intel manual (Pentium Processor User's Manual, Vol.3, 1994)\n-\/\/       is erroneous for some of the floating-point instructions below.\n-\n-void Assembler::fdivp(int i) {\n-  emit_farith(0xDE, 0xF8, i);                    \/\/ ST(0) <- ST(0) \/ ST(1) and pop (Intel manual wrong)\n-}\n-\n-void Assembler::fdivr(int i) {\n-  emit_farith(0xD8, 0xF8, i);\n-}\n-\n-void Assembler::fdivr_d(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDC);\n-  emit_operand32(rdi, src, 0);\n-}\n-\n-void Assembler::fdivr_s(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD8);\n-  emit_operand32(rdi, src, 0);\n-}\n-\n-void Assembler::fdivra(int i) {\n-  emit_farith(0xDC, 0xF0, i);\n-}\n-\n-void Assembler::fdivrp(int i) {\n-  emit_farith(0xDE, 0xF0, i);                    \/\/ ST(0) <- ST(1) \/ ST(0) and pop (Intel manual wrong)\n-}\n-\n-void Assembler::ffree(int i) {\n-  emit_farith(0xDD, 0xC0, i);\n-}\n-\n-void Assembler::fild_d(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDF);\n-  emit_operand32(rbp, adr, 0);\n-}\n-\n-void Assembler::fild_s(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDB);\n-  emit_operand32(rax, adr, 0);\n-}\n-\n-void Assembler::fincstp() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xF7);\n-}\n-\n-void Assembler::finit() {\n-  emit_int24((unsigned char)0x9B, (unsigned char)0xDB, (unsigned char)0xE3);\n-}\n-\n-void Assembler::fist_s(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDB);\n-  emit_operand32(rdx, adr, 0);\n-}\n-\n-void Assembler::fistp_d(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDF);\n-  emit_operand32(rdi, adr, 0);\n-}\n-\n-void Assembler::fistp_s(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDB);\n-  emit_operand32(rbx, adr, 0);\n-}\n-\n-void Assembler::fld1() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xE8);\n-}\n-\n-void Assembler::fld_s(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD9);\n-  emit_operand32(rax, adr, 0);\n-}\n-\n-\n-void Assembler::fld_s(int index) {\n-  emit_farith(0xD9, 0xC0, index);\n-}\n-\n-void Assembler::fldcw(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD9);\n-  emit_operand32(rbp, src, 0);\n-}\n-\n-void Assembler::fldenv(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD9);\n-  emit_operand32(rsp, src, 0);\n-}\n-\n-void Assembler::fldlg2() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xEC);\n-}\n-\n-void Assembler::fldln2() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xED);\n-}\n-\n-void Assembler::fldz() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xEE);\n-}\n-\n-void Assembler::flog() {\n-  fldln2();\n-  fxch();\n-  fyl2x();\n-}\n-\n-void Assembler::flog10() {\n-  fldlg2();\n-  fxch();\n-  fyl2x();\n-}\n-\n-void Assembler::fmul(int i) {\n-  emit_farith(0xD8, 0xC8, i);\n-}\n-\n-void Assembler::fmul_d(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDC);\n-  emit_operand32(rcx, src, 0);\n-}\n-\n-void Assembler::fmul_s(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD8);\n-  emit_operand32(rcx, src, 0);\n-}\n-\n-void Assembler::fmula(int i) {\n-  emit_farith(0xDC, 0xC8, i);\n-}\n-\n-void Assembler::fmulp(int i) {\n-  emit_farith(0xDE, 0xC8, i);\n-}\n-\n-void Assembler::fnsave(Address dst) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDD);\n-  emit_operand32(rsi, dst, 0);\n-}\n-\n-void Assembler::fnstcw(Address src) {\n-  InstructionMark im(this);\n-  emit_int16((unsigned char)0x9B, (unsigned char)0xD9);\n-  emit_operand32(rdi, src, 0);\n-}\n-\n-void Assembler::fprem1() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xF5);\n-}\n-\n-void Assembler::frstor(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDD);\n-  emit_operand32(rsp, src, 0);\n-}\n-\n-void Assembler::fsin() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xFE);\n-}\n-\n-void Assembler::fsqrt() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xFA);\n-}\n-\n-void Assembler::fst_d(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDD);\n-  emit_operand32(rdx, adr, 0);\n-}\n-\n-void Assembler::fst_s(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD9);\n-  emit_operand32(rdx, adr, 0);\n-}\n-\n-void Assembler::fstp_s(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD9);\n-  emit_operand32(rbx, adr, 0);\n-}\n-\n-void Assembler::fsub(int i) {\n-  emit_farith(0xD8, 0xE0, i);\n-}\n-\n-void Assembler::fsub_d(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDC);\n-  emit_operand32(rsp, src, 0);\n-}\n-\n-void Assembler::fsub_s(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD8);\n-  emit_operand32(rsp, src, 0);\n-}\n-\n-void Assembler::fsuba(int i) {\n-  emit_farith(0xDC, 0xE8, i);\n-}\n-\n-void Assembler::fsubp(int i) {\n-  emit_farith(0xDE, 0xE8, i);                    \/\/ ST(0) <- ST(0) - ST(1) and pop (Intel manual wrong)\n-}\n-\n-void Assembler::fsubr(int i) {\n-  emit_farith(0xD8, 0xE8, i);\n-}\n-\n-void Assembler::fsubr_d(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDC);\n-  emit_operand32(rbp, src, 0);\n-}\n-\n-void Assembler::fsubr_s(Address src) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xD8);\n-  emit_operand32(rbp, src, 0);\n-}\n-\n-void Assembler::fsubra(int i) {\n-  emit_farith(0xDC, 0xE0, i);\n-}\n-\n-void Assembler::fsubrp(int i) {\n-  emit_farith(0xDE, 0xE0, i);                    \/\/ ST(0) <- ST(1) - ST(0) and pop (Intel manual wrong)\n-}\n-\n-void Assembler::ftan() {\n-  emit_int32((unsigned char)0xD9, (unsigned char)0xF2, (unsigned char)0xDD, (unsigned char)0xD8);\n-}\n-\n-void Assembler::ftst() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xE4);\n-}\n-\n-void Assembler::fucomi(int i) {\n-  \/\/ make sure the instruction is supported (introduced for P6, together with cmov)\n-  guarantee(VM_Version::supports_cmov(), \"illegal instruction\");\n-  emit_farith(0xDB, 0xE8, i);\n-}\n-\n-void Assembler::fucomip(int i) {\n-  \/\/ make sure the instruction is supported (introduced for P6, together with cmov)\n-  guarantee(VM_Version::supports_cmov(), \"illegal instruction\");\n-  emit_farith(0xDF, 0xE8, i);\n-}\n-\n-void Assembler::fwait() {\n-  emit_int8((unsigned char)0x9B);\n-}\n-\n-void Assembler::fxch(int i) {\n-  emit_farith(0xD9, 0xC8, i);\n-}\n-\n-void Assembler::fyl2x() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xF1);\n-}\n-\n-void Assembler::frndint() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xFC);\n-}\n-\n-void Assembler::f2xm1() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xF0);\n-}\n-\n-void Assembler::fldl2e() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xEA);\n-}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":374,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -1400,129 +1400,0 @@\n-\n-  void fabs();\n-\n-  void fadd(int i);\n-\n-  void fadd_d(Address src);\n-  void fadd_s(Address src);\n-\n-  \/\/ \"Alternate\" versions of x87 instructions place result down in FPU\n-  \/\/ stack instead of on TOS\n-\n-  void fadda(int i); \/\/ \"alternate\" fadd\n-  void faddp(int i = 1);\n-\n-  void fchs();\n-\n-  void fcom(int i);\n-\n-  void fcomp(int i = 1);\n-  void fcomp_d(Address src);\n-  void fcomp_s(Address src);\n-\n-  void fcompp();\n-\n-  void fcos();\n-\n-  void fdecstp();\n-\n-  void fdiv(int i);\n-  void fdiv_d(Address src);\n-  void fdivr_s(Address src);\n-  void fdiva(int i);  \/\/ \"alternate\" fdiv\n-  void fdivp(int i = 1);\n-\n-  void fdivr(int i);\n-  void fdivr_d(Address src);\n-  void fdiv_s(Address src);\n-\n-  void fdivra(int i); \/\/ \"alternate\" reversed fdiv\n-\n-  void fdivrp(int i = 1);\n-\n-  void ffree(int i = 0);\n-\n-  void fild_d(Address adr);\n-  void fild_s(Address adr);\n-\n-  void fincstp();\n-\n-  void finit();\n-\n-  void fist_s (Address adr);\n-  void fistp_d(Address adr);\n-  void fistp_s(Address adr);\n-\n-  void fld1();\n-\n-  void fld_s(Address adr);\n-  void fld_s(int index);\n-\n-  void fldcw(Address src);\n-\n-  void fldenv(Address src);\n-\n-  void fldlg2();\n-\n-  void fldln2();\n-\n-  void fldz();\n-\n-  void flog();\n-  void flog10();\n-\n-  void fmul(int i);\n-\n-  void fmul_d(Address src);\n-  void fmul_s(Address src);\n-\n-  void fmula(int i);  \/\/ \"alternate\" fmul\n-\n-  void fmulp(int i = 1);\n-\n-  void fnsave(Address dst);\n-\n-  void fnstcw(Address src);\n-  void fprem1();\n-\n-  void frstor(Address src);\n-\n-  void fsin();\n-\n-  void fsqrt();\n-\n-  void fst_d(Address adr);\n-  void fst_s(Address adr);\n-\n-  void fstp_s(Address adr);\n-\n-  void fsub(int i);\n-  void fsub_d(Address src);\n-  void fsub_s(Address src);\n-\n-  void fsuba(int i);  \/\/ \"alternate\" fsub\n-\n-  void fsubp(int i = 1);\n-\n-  void fsubr(int i);\n-  void fsubr_d(Address src);\n-  void fsubr_s(Address src);\n-\n-  void fsubra(int i); \/\/ \"alternate\" reversed fsub\n-\n-  void fsubrp(int i = 1);\n-\n-  void ftan();\n-\n-  void ftst();\n-\n-  void fucomi(int i = 1);\n-  void fucomip(int i = 1);\n-\n-  void fwait();\n-\n-  void fxch(int i = 1);\n-\n-  void fyl2x();\n-  void frndint();\n-  void f2xm1();\n-  void fldl2e();\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":0,"deletions":129,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-  if (breakAtEntry || VerifyFPU) {\n+  if (breakAtEntry) {\n@@ -331,1 +331,1 @@\n-    \/\/ Breakpoint and VerifyFPU have one byte first instruction.\n+    \/\/ Breakpoint has one byte first instruction.\n@@ -339,1 +339,0 @@\n-  IA32_ONLY( verify_FPU(0, \"method_entry\"); )\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -146,20 +146,0 @@\n-void MacroAssembler::jC2(Register tmp, Label& L) {\n-  \/\/ set parity bit if FPU flag C2 is set (via rax)\n-  save_rax(tmp);\n-  fwait(); fnstsw_ax();\n-  sahf();\n-  restore_rax(tmp);\n-  \/\/ branch\n-  jcc(Assembler::parity, L);\n-}\n-\n-void MacroAssembler::jnC2(Register tmp, Label& L) {\n-  \/\/ set parity bit if FPU flag C2 is set (via rax)\n-  save_rax(tmp);\n-  fwait(); fnstsw_ax();\n-  sahf();\n-  restore_rax(tmp);\n-  \/\/ branch\n-  jcc(Assembler::noParity, L);\n-}\n-\n@@ -2057,109 +2037,0 @@\n-#ifndef _LP64\n-void MacroAssembler::fcmp(Register tmp) {\n-  fcmp(tmp, 1, true, true);\n-}\n-\n-void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {\n-  assert(!pop_right || pop_left, \"usage error\");\n-  if (VM_Version::supports_cmov()) {\n-    assert(tmp == noreg, \"unneeded temp\");\n-    if (pop_left) {\n-      fucomip(index);\n-    } else {\n-      fucomi(index);\n-    }\n-    if (pop_right) {\n-      fpop();\n-    }\n-  } else {\n-    assert(tmp != noreg, \"need temp\");\n-    if (pop_left) {\n-      if (pop_right) {\n-        fcompp();\n-      } else {\n-        fcomp(index);\n-      }\n-    } else {\n-      fcom(index);\n-    }\n-    \/\/ convert FPU condition into eflags condition via rax,\n-    save_rax(tmp);\n-    fwait(); fnstsw_ax();\n-    sahf();\n-    restore_rax(tmp);\n-  }\n-  \/\/ condition codes set as follows:\n-  \/\/\n-  \/\/ CF (corresponds to C0) if x < y\n-  \/\/ PF (corresponds to C2) if unordered\n-  \/\/ ZF (corresponds to C3) if x = y\n-}\n-\n-void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {\n-  fcmp2int(dst, unordered_is_less, 1, true, true);\n-}\n-\n-void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {\n-  fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);\n-  Label L;\n-  if (unordered_is_less) {\n-    movl(dst, -1);\n-    jcc(Assembler::parity, L);\n-    jcc(Assembler::below , L);\n-    movl(dst, 0);\n-    jcc(Assembler::equal , L);\n-    increment(dst);\n-  } else { \/\/ unordered is greater\n-    movl(dst, 1);\n-    jcc(Assembler::parity, L);\n-    jcc(Assembler::above , L);\n-    movl(dst, 0);\n-    jcc(Assembler::equal , L);\n-    decrementl(dst);\n-  }\n-  bind(L);\n-}\n-\n-void MacroAssembler::fld_d(AddressLiteral src) {\n-  fld_d(as_Address(src));\n-}\n-\n-void MacroAssembler::fld_s(AddressLiteral src) {\n-  fld_s(as_Address(src));\n-}\n-\n-void MacroAssembler::fldcw(AddressLiteral src) {\n-  fldcw(as_Address(src));\n-}\n-\n-void MacroAssembler::fpop() {\n-  ffree();\n-  fincstp();\n-}\n-\n-void MacroAssembler::fremr(Register tmp) {\n-  save_rax(tmp);\n-  { Label L;\n-    bind(L);\n-    fprem();\n-    fwait(); fnstsw_ax();\n-    sahf();\n-    jcc(Assembler::parity, L);\n-  }\n-  restore_rax(tmp);\n-  \/\/ Result is in ST0.\n-  \/\/ Note: fxch & fpop to get rid of ST1\n-  \/\/ (otherwise FPU stack could overflow eventually)\n-  fxch(1);\n-  fpop();\n-}\n-\n-void MacroAssembler::empty_FPU_stack() {\n-  if (VM_Version::supports_mmx()) {\n-    emms();\n-  } else {\n-    for (int i = 8; i-- > 0; ) ffree(i);\n-  }\n-}\n-#endif \/\/ !LP64\n-\n@@ -3141,5 +3012,0 @@\n-void MacroAssembler::restore_rax(Register tmp) {\n-  if (tmp == noreg) pop(rax);\n-  else if (tmp != rax) mov(rax, tmp);\n-}\n-\n@@ -3151,5 +3017,0 @@\n-void MacroAssembler::save_rax(Register tmp) {\n-  if (tmp == noreg) push(rax);\n-  else if (tmp != rax) mov(tmp, rax);\n-}\n-\n@@ -5873,79 +5734,0 @@\n-\n-#ifndef _LP64\n-static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {\n-  static int counter = 0;\n-  FPU_State* fs = &state->_fpu_state;\n-  counter++;\n-  \/\/ For leaf calls, only verify that the top few elements remain empty.\n-  \/\/ We only need 1 empty at the top for C2 code.\n-  if( stack_depth < 0 ) {\n-    if( fs->tag_for_st(7) != 3 ) {\n-      printf(\"FPR7 not empty\\n\");\n-      state->print();\n-      assert(false, \"error\");\n-      return false;\n-    }\n-    return true;                \/\/ All other stack states do not matter\n-  }\n-\n-  assert((fs->_control_word._value & 0xffff) == StubRoutines::x86::fpu_cntrl_wrd_std(),\n-         \"bad FPU control word\");\n-\n-  \/\/ compute stack depth\n-  int i = 0;\n-  while (i < FPU_State::number_of_registers && fs->tag_for_st(i)  < 3) i++;\n-  int d = i;\n-  while (i < FPU_State::number_of_registers && fs->tag_for_st(i) == 3) i++;\n-  \/\/ verify findings\n-  if (i != FPU_State::number_of_registers) {\n-    \/\/ stack not contiguous\n-    printf(\"%s: stack not contiguous at ST%d\\n\", s, i);\n-    state->print();\n-    assert(false, \"error\");\n-    return false;\n-  }\n-  \/\/ check if computed stack depth corresponds to expected stack depth\n-  if (stack_depth < 0) {\n-    \/\/ expected stack depth is -stack_depth or less\n-    if (d > -stack_depth) {\n-      \/\/ too many elements on the stack\n-      printf(\"%s: <= %d stack elements expected but found %d\\n\", s, -stack_depth, d);\n-      state->print();\n-      assert(false, \"error\");\n-      return false;\n-    }\n-  } else {\n-    \/\/ expected stack depth is stack_depth\n-    if (d != stack_depth) {\n-      \/\/ wrong stack depth\n-      printf(\"%s: %d stack elements expected but found %d\\n\", s, stack_depth, d);\n-      state->print();\n-      assert(false, \"error\");\n-      return false;\n-    }\n-  }\n-  \/\/ everything is cool\n-  return true;\n-}\n-\n-void MacroAssembler::verify_FPU(int stack_depth, const char* s) {\n-  if (!VerifyFPU) return;\n-  push_CPU_state();\n-  push(rsp);                \/\/ pass CPU state\n-  ExternalAddress msg((address) s);\n-  \/\/ pass message string s\n-  pushptr(msg.addr(), noreg);\n-  push(stack_depth);        \/\/ pass stack depth\n-  call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));\n-  addptr(rsp, 3 * wordSize);   \/\/ discard arguments\n-  \/\/ check for error\n-  { Label L;\n-    testl(rax, rax);\n-    jcc(Assembler::notZero, L);\n-    int3();                  \/\/ break if error condition\n-    bind(L);\n-  }\n-  pop_CPU_state();\n-}\n-#endif \/\/ _LP64\n-\n@@ -5964,8 +5746,0 @@\n-\n-#ifndef _LP64\n-  \/\/ Either restore the x87 floating pointer control word after returning\n-  \/\/ from the JNI call or verify that it wasn't changed.\n-  if (CheckJNICalls) {\n-    call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));\n-  }\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":226,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -74,5 +74,0 @@\n-  \/\/ helpers for FPU flag access\n-  \/\/ tmp is a temporary register, if none is available use noreg\n-  void save_rax   (Register tmp);\n-  void restore_rax(Register tmp);\n-\n@@ -463,33 +458,0 @@\n-#ifndef _LP64\n-  \/\/ Compares the top-most stack entries on the FPU stack and sets the eflags as follows:\n-  \/\/\n-  \/\/ CF (corresponds to C0) if x < y\n-  \/\/ PF (corresponds to C2) if unordered\n-  \/\/ ZF (corresponds to C3) if x = y\n-  \/\/\n-  \/\/ The arguments are in reversed order on the stack (i.e., top of stack is first argument).\n-  \/\/ tmp is a temporary register, if none is available use noreg (only matters for non-P6 code)\n-  void fcmp(Register tmp);\n-  \/\/ Variant of the above which allows y to be further down the stack\n-  \/\/ and which only pops x and y if specified. If pop_right is\n-  \/\/ specified then pop_left must also be specified.\n-  void fcmp(Register tmp, int index, bool pop_left, bool pop_right);\n-\n-  \/\/ Floating-point comparison for Java\n-  \/\/ Compares the top-most stack entries on the FPU stack and stores the result in dst.\n-  \/\/ The arguments are in reversed order on the stack (i.e., top of stack is first argument).\n-  \/\/ (semantics as described in JVM spec.)\n-  void fcmp2int(Register dst, bool unordered_is_less);\n-  \/\/ Variant of the above which allows y to be further down the stack\n-  \/\/ and which only pops x and y if specified. If pop_right is\n-  \/\/ specified then pop_left must also be specified.\n-  void fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right);\n-\n-  \/\/ Floating-point remainder for Java (ST0 = ST0 fremr ST1, ST1 is empty afterwards)\n-  \/\/ tmp is a temporary register, if none is available use noreg\n-  void fremr(Register tmp);\n-\n-  \/\/ only if +VerifyFPU\n-  void verify_FPU(int stack_depth, const char* s = \"illegal FPU state\");\n-#endif \/\/ !LP64\n-\n@@ -510,5 +472,0 @@\n-  \/\/ branch to L if FPU flag C2 is set\/not set\n-  \/\/ tmp is a temporary register, if none is available use noreg\n-  void jC2 (Register tmp, Label& L);\n-  void jnC2(Register tmp, Label& L);\n-\n@@ -531,7 +488,0 @@\n-#ifndef _LP64\n-  \/\/ Pop ST (ffree & fincstp combined)\n-  void fpop();\n-\n-  void empty_FPU_stack();\n-#endif \/\/ !_LP64\n-\n@@ -1098,21 +1048,0 @@\n-#ifndef _LP64\n-  void fadd_s(Address        src) { Assembler::fadd_s(src); }\n-  void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }\n-\n-  void fldcw(Address        src) { Assembler::fldcw(src); }\n-  void fldcw(AddressLiteral src);\n-\n-  void fld_s(int index)          { Assembler::fld_s(index); }\n-  void fld_s(Address        src) { Assembler::fld_s(src); }\n-  void fld_s(AddressLiteral src);\n-\n-  void fld_d(Address        src) { Assembler::fld_d(src); }\n-  void fld_d(AddressLiteral src);\n-\n-  void fld_x(Address        src) { Assembler::fld_x(src); }\n-  void fld_x(AddressLiteral src) { Assembler::fld_x(as_Address(src)); }\n-\n-  void fmul_s(Address        src) { Assembler::fmul_s(src); }\n-  void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }\n-#endif \/\/ !_LP64\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":71,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -63,13 +63,0 @@\n-  NOT_LP64(                                                             \\\n-    do_stub(initial, verify_fpu_cntrl_word)                             \\\n-    do_arch_entry(x86, initial, verify_fpu_cntrl_word,                  \\\n-                  verify_fpu_cntrl_wrd_entry,                           \\\n-                  verify_fpu_cntrl_wrd_entry)                           \\\n-    do_stub(initial, d2i_wrapper)                                       \\\n-    do_arch_entry(x86, initial, d2i_wrapper, d2i_wrapper,               \\\n-                  d2i_wrapper)                                          \\\n-    do_stub(initial, d2l_wrapper)                                       \\\n-    do_arch_entry(x86, initial, d2l_wrapper, d2l_wrapper,               \\\n-                  d2l_wrapper)                                          \\\n-  )                                                                     \\\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubDeclarations_x86.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1168,3 +1168,0 @@\n-  develop(bool, VerifyFPU, false,                                           \\\n-          \"Verify FPU state (check for NaN's, etc.)\")                       \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}