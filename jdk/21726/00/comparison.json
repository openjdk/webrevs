{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+    externalCfgFile = 0;\n@@ -113,11 +114,7 @@\n-    const tstring cfgFilePath = getCfgFilePath();\n-\n-    LOG_TRACE(tstrings::any() << \"Launcher config file path: \\\"\"\n-            << cfgFilePath << \"\\\"\");\n-\n-    CfgFile::Macros macros;\n-    macros[_T(\"$APPDIR\")] = appDirPath;\n-    macros[_T(\"$BINDIR\")] = FileUtils::dirname(launcherPath);\n-    macros[_T(\"$ROOTDIR\")] = imageRoot;\n-\n-    CfgFile cfgFile = CfgFile::load(cfgFilePath).expandMacros(macros);\n+    CfgFile cfgFile;\n+    if (externalCfgFile) {\n+        cfgFile = *externalCfgFile;\n+    } else {\n+        std::unique_ptr<CfgFile> createdCfgFile(createCfgFile());\n+        cfgFile.swap(*createdCfgFile);\n+    }\n@@ -128,1 +125,1 @@\n-            PropertyName::arguments, args);\n+                PropertyName::arguments, args);\n@@ -163,0 +160,16 @@\n+CfgFile* AppLauncher::createCfgFile() const {\n+    const tstring cfgFilePath = getCfgFilePath();\n+\n+    LOG_TRACE(tstrings::any() << \"Launcher config file path: \\\"\"\n+                                << cfgFilePath << \"\\\"\");\n+\n+    CfgFile::Macros macros;\n+    macros[_T(\"$APPDIR\")] = appDirPath;\n+    macros[_T(\"$BINDIR\")] = FileUtils::dirname(launcherPath);\n+    macros[_T(\"$ROOTDIR\")] = imageRoot;\n+    std::unique_ptr<CfgFile> dummy(new CfgFile());\n+    CfgFile::load(cfgFilePath).expandMacros(macros).swap(*dummy);\n+    return dummy.release();\n+}\n+\n+\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/AppLauncher.cpp","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+class CfgFile;\n@@ -73,0 +74,5 @@\n+    AppLauncher& setCfgFile(const CfgFile* v) {\n+        externalCfgFile = v;\n+        return *this;\n+    }\n+\n@@ -79,0 +85,2 @@\n+    CfgFile* createCfgFile() const;\n+\n@@ -80,1 +88,1 @@\n-  tstring getCfgFilePath() const;\n+    tstring getCfgFilePath() const;\n@@ -92,0 +100,1 @@\n+    const CfgFile* externalCfgFile;\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/AppLauncher.h","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -237,0 +237,13 @@\n+bool CfgFile::asBoolean(Properties::const_reference property) {\n+    const auto str = asString(property);\n+    if (tstrings::equals(str, _T(\"true\"), tstrings::IGNORE_CASE)) {\n+        return true;\n+    }\n+\n+    tistringstream iss(str);\n+    int intValue = 0;\n+    iss >> intValue;\n+\n+    return intValue != 0;\n+}\n+\n@@ -279,0 +292,1 @@\n+    JP_PROPERTY(winNorestart, \"win.norestart\"); \\\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/CfgFile.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,5 @@\n+    void swap(CfgFile& other) {\n+        std::swap(data, other.data);\n+        std::swap(empty, other.empty);\n+    }\n+\n@@ -99,0 +104,2 @@\n+    static bool asBoolean(Properties::const_reference property);\n+\n@@ -129,0 +136,1 @@\n+    extern const CfgFile::PropertyName winNorestart;\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/CfgFile.h","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"CfgFile.h\"\n@@ -229,0 +230,29 @@\n+bool needRestartLauncher(AppLauncher& appLauncher, CfgFile& cfgFile) {\n+    if (appLauncher.libEnvVariableContainsAppDir()) {\n+        return false;\n+    }\n+\n+    std::unique_ptr<CfgFile>(appLauncher.createCfgFile())->swap(cfgFile);\n+\n+    const CfgFile::Properties& appOptions = cfgFile.getProperties(\n+            SectionName::Application);\n+\n+    const CfgFile::Properties::const_iterator winNorestart = appOptions.find(\n+                PropertyName::winNorestart);\n+\n+    bool result;\n+    if (winNorestart != appOptions.end()) {\n+        const bool norestart = CfgFile::asBoolean(*winNorestart);\n+        LOG_TRACE(tstrings::any() << PropertyName::winNorestart.name() << \"=\"\n+                << (norestart ? \"true\" : \"false\") << \" from config file\");\n+        result = !norestart;\n+    } else {\n+        result = true;\n+    }\n+\n+    appLauncher.setCfgFile(&cfgFile);\n+\n+    return result;\n+}\n+\n+\n@@ -251,1 +281,2 @@\n-    const bool restart = !appLauncher.libEnvVariableContainsAppDir();\n+    CfgFile dummyCfgFile;\n+    const bool restart = needRestartLauncher(appLauncher, dummyCfgFile);\n","filename":"src\/jdk.jpackage\/windows\/native\/applauncher\/WinLauncher.cpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -29,1 +30,1 @@\n-import java.util.HashMap;\n+import java.util.List;\n@@ -35,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -38,3 +40,4 @@\n-    public String getValue(String section, String key) {\n-        Objects.requireNonNull(section);\n-        Objects.requireNonNull(key);\n+    public String getValue(String sectionName, String key) {\n+        var section = getSection(sectionName);\n+        TKit.assertTrue(section != null, String.format(\n+                \"Check section [%s] is found in [%s] cfg file\", sectionName, id));\n@@ -42,5 +45,1 @@\n-        Map<String, String> entries = data.get(section);\n-        TKit.assertTrue(entries != null, String.format(\n-                \"Check section [%s] is found in [%s] cfg file\", section, id));\n-\n-        String value = entries.get(key);\n+        String value = section.getValue(key);\n@@ -49,1 +48,1 @@\n-                section, id));\n+                sectionName, id));\n@@ -54,3 +53,21 @@\n-    public String getValueUnchecked(String section, String key) {\n-        Objects.requireNonNull(section);\n-        Objects.requireNonNull(key);\n+    public String getValueUnchecked(String sectionName, String key) {\n+        var section = getSection(sectionName);\n+        if (section != null) {\n+            return section.getValue(key);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public void addValue(String sectionName, String key, String value) {\n+        var section = getSection(sectionName);\n+        if (section == null) {\n+            section = new Section(sectionName, new ArrayList<>());\n+            data.add(section);\n+        }\n+        section.data.add(Map.entry(key, value));\n+    }\n+\n+    public CfgFile() {\n+        this(new ArrayList<>(), \"*\");\n+    }\n@@ -58,2 +75,10 @@\n-        return Optional.ofNullable(data.get(section)).map(v -> v.get(key)).orElse(\n-                null);\n+    public static CfgFile combine(CfgFile base, CfgFile mods) {\n+        var cfgFile = new CfgFile(new ArrayList<>(), \"*\");\n+        for (var src : List.of(base, mods)) {\n+            for (var section : src.data) {\n+                for (var kvp : section.data) {\n+                    cfgFile.addValue(section.name, kvp.getKey(), kvp.getValue());\n+                }\n+            }\n+        }\n+        return cfgFile;\n@@ -62,1 +87,1 @@\n-    private CfgFile(Map<String, Map<String, String>> data, String id) {\n+    private CfgFile(List<Section> data, String id) {\n@@ -67,1 +92,22 @@\n-    public static CfgFile readFromFile(Path path) throws IOException {\n+    public void save(Path path) {\n+        var lines = data.stream().flatMap(section -> {\n+            return Stream.concat(\n+                    Stream.of(String.format(\"[%s]\", section.name)),\n+                    section.data.stream().map(kvp -> {\n+                        return String.format(\"%s=%s\", kvp.getKey(), kvp.getValue());\n+                    }));\n+        });\n+        TKit.createTextFile(path, lines);\n+    }\n+\n+    private Section getSection(String name) {\n+        Objects.requireNonNull(name);\n+        for (var section : data.reversed()) {\n+            if (name.equals(section.name)) {\n+                return section;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static CfgFile load(Path path) throws IOException {\n@@ -73,1 +119,1 @@\n-        Map<String, Map<String, String>> result = new HashMap<>();\n+        List<Section> sections = new ArrayList<>();\n@@ -76,1 +122,1 @@\n-        Map<String, String> currentSection = new HashMap<>();\n+        List<Map.Entry<String, String>> currentSection = new ArrayList<>();\n@@ -81,2 +127,3 @@\n-                    result.put(currentSectionName, Collections.unmodifiableMap(\n-                            new HashMap<>(currentSection)));\n+                    sections.add(new Section(currentSectionName,\n+                            Collections.unmodifiableList(new ArrayList<>(\n+                                    currentSection))));\n@@ -91,2 +138,1 @@\n-                currentSection.put(matcher.group(1), matcher.group(2));\n-                continue;\n+                currentSection.add(Map.entry(matcher.group(1), matcher.group(2)));\n@@ -97,2 +143,3 @@\n-            result.put(Optional.ofNullable(currentSectionName).orElse(\"\"),\n-                    Collections.unmodifiableMap(currentSection));\n+            sections.add(new Section(\n+                    Optional.ofNullable(currentSectionName).orElse(\"\"),\n+                    Collections.unmodifiableList(currentSection)));\n@@ -101,1 +148,13 @@\n-        return new CfgFile(Collections.unmodifiableMap(result), path.toString());\n+        return new CfgFile(sections, path.toString());\n+    }\n+\n+    private static record Section(String name, List<Map.Entry<String, String>> data) {\n+        String getValue(String key) {\n+            Objects.requireNonNull(key);\n+            for (var kvp : data.reversed()) {\n+                if (key.equals(kvp.getKey())) {\n+                    return kvp.getValue();\n+                }\n+            }\n+            return null;\n+        }\n@@ -104,1 +163,1 @@\n-    private final Map<String, Map<String, String>> data;\n+    private final List<Section> data;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CfgFile.java","additions":87,"deletions":28,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -625,1 +625,10 @@\n-        Path runtimeDir = appRuntimeDirectory();\n+        if (isFakeRuntime()) {\n+            \/\/ Fake runtime\n+            Path runtimeDir = appRuntimeDirectory();\n+            TKit.trace(String.format(\n+                    \"%s because application runtime directory [%s] is incomplete\",\n+                    msg, runtimeDir));\n+            return true;\n+        }\n+        return false;\n+    }\n@@ -627,0 +636,1 @@\n+    private boolean isFakeRuntime() {\n@@ -638,10 +648,3 @@\n-        if (!criticalRuntimeFiles.stream().anyMatch(v -> {\n-            return runtimeDir.resolve(v).toFile().exists();\n-        })) {\n-            \/\/ Fake runtime\n-            TKit.trace(String.format(\n-                    \"%s because application runtime directory [%s] is incomplete\",\n-                    msg, runtimeDir));\n-            return true;\n-        }\n-        return false;\n+        Path runtimeDir = appRuntimeDirectory();\n+        return !criticalRuntimeFiles.stream().map(runtimeDir::resolve).allMatch(\n+                Files::exists);\n@@ -712,0 +715,7 @@\n+    public JPackageCommand ignoreFakeRuntime() {\n+        if (isFakeRuntime()) {\n+            ignoreDefaultRuntime(true);\n+        }\n+        return this;\n+    }\n+\n@@ -1003,1 +1013,1 @@\n-        return ThrowingFunction.toFunction(CfgFile::readFromFile).apply(\n+        return ThrowingFunction.toFunction(CfgFile::load).apply(\n@@ -1116,1 +1126,1 @@\n-    private final static Map<String, PackageType> PACKAGE_TYPES = Functional.identity(\n+    private static final Map<String, PackageType> PACKAGE_TYPES = Functional.identity(\n@@ -1125,1 +1135,1 @@\n-    public final static Path DEFAULT_RUNTIME_IMAGE = Functional.identity(() -> {\n+    public static final Path DEFAULT_RUNTIME_IMAGE = Functional.identity(() -> {\n@@ -1138,1 +1148,1 @@\n-    private final static String UNPACKED_PATH_ARGNAME = \"jpt-unpacked-folder\";\n+    private static final String UNPACKED_PATH_ARGNAME = \"jpt-unpacked-folder\";\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    public final static class Builder {\n+    public static final class Builder {\n@@ -218,1 +218,1 @@\n-        var cfgFile = CfgFile.readFromFile(cmd.appLauncherCfgPath(launcherName));\n+        var cfgFile = CfgFile.load(cmd.appLauncherCfgPath(launcherName));\n@@ -371,1 +371,1 @@\n-    final static Set<PackageType> SUPPORTED_PACKAGES = Stream.of(LINUX, WINDOWS,\n+    static final Set<PackageType> SUPPORTED_PACKAGES = Stream.of(LINUX, WINDOWS,\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -34,0 +35,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -231,0 +234,65 @@\n+    public static void killProcess(long pid) {\n+        Executor.of(\"taskkill\", \"\/F\", \"\/PID\", Long.toString(pid)).dumpOutput(true).execute();\n+    }\n+\n+    public static Optional<Long> findAppLauncherPID(JPackageCommand cmd,\n+            String launcherName, int expectedCount) {\n+        \/\/ Get the list of PIDs and PPIDs of app launcher processes.\n+        \/\/ wmic process where (name = \"foo.exe\") get ProcessID,ParentProcessID\n+        List<String> output = Executor.of(\"wmic\", \"process\", \"where\", \"(name\",\n+                \"=\",\n+                \"\\\"\" + cmd.appLauncherPath(launcherName).getFileName().toString() + \"\\\"\",\n+                \")\", \"get\", \"ProcessID,ParentProcessID\").dumpOutput(true).\n+                saveOutput().executeAndGetOutput();\n+\n+        if (expectedCount == 0) {\n+            TKit.assertEquals(\"No Instance(s) Available.\", output.getFirst().\n+                    trim(), \"Check no app launcher processes found running\");\n+            return Optional.empty();\n+        }\n+\n+        String[] headers = Stream.of(output.getFirst().split(\"\\\\s+\", 2)).map(\n+                String::trim).map(String::toLowerCase).toArray(String[]::new);\n+        Pattern pattern;\n+        if (headers[0].equals(\"parentprocessid\") && headers[1].equals(\n+                \"processid\")) {\n+            pattern = Pattern.compile(\"^(?<ppid>\\\\d+)\\\\s+(?<pid>\\\\d+)\\\\s+$\");\n+        } else if (headers[1].equals(\"parentprocessid\") && headers[0].equals(\n+                \"processid\")) {\n+            pattern = Pattern.compile(\"^(?<pid>\\\\d+)\\\\s+(?<ppid>\\\\d+)\\\\s+$\");\n+        } else {\n+            throw new RuntimeException(\n+                    \"Unrecognizable output of \\'wmic process\\' command\");\n+        }\n+\n+        List<long[]> processes = output.stream().skip(1).map(line -> {\n+            Matcher m = pattern.matcher(line);\n+            long[] pids = null;\n+            if (m.matches()) {\n+                pids = new long[]{Long.parseLong(m.group(\"pid\")), Long.\n+                    parseLong(m.group(\"ppid\"))};\n+            }\n+            return pids;\n+        }).filter(Objects::nonNull).toList();\n+\n+        TKit.assertEquals(expectedCount, processes.size(), String.format(\n+                \"Check [%d] app launcher processes found running\", expectedCount));\n+\n+        switch (expectedCount) {\n+            case 2 -> {\n+                if (processes.get(0)[0] == processes.get(1)[1]) {\n+                    return Optional.of(processes.get(0)[0]);\n+                } else if (processes.get(1)[0] == processes.get(0)[1]) {\n+                    return Optional.of(processes.get(1)[0]);\n+                } else {\n+                    throw new RuntimeException(\"App launcher processes unrelated\");\n+                }\n+            }\n+            case 1 -> {\n+                return Optional.of(processes.get(0)[0]);\n+            }\n+            default ->\n+                throw new IllegalArgumentException();\n+        }\n+    }\n+\n@@ -461,1 +529,1 @@\n-    private final static Path PROGRAM_FILES = Path.of(Optional.ofNullable(\n+    private static final Path PROGRAM_FILES = Path.of(Optional.ofNullable(\n@@ -464,1 +532,1 @@\n-    private final static Path USER_LOCAL = Path.of(System.getProperty(\n+    private static final Path USER_LOCAL = Path.of(System.getProperty(\n@@ -468,2 +536,2 @@\n-    private final static String SYSTEM_SHELL_FOLDERS_REGKEY = \"HKLM\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n-    private final static String USER_SHELL_FOLDERS_REGKEY = \"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n+    private static final String SYSTEM_SHELL_FOLDERS_REGKEY = \"HKLM\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n+    private static final String USER_SHELL_FOLDERS_REGKEY = \"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":72,"deletions":4,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                .ignoreDefaultRuntime(true);\n+                .ignoreFakeRuntime();\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/BasicTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n@@ -31,3 +28,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n@@ -36,1 +30,0 @@\n-import jdk.jpackage.test.Executor;\n@@ -38,1 +31,2 @@\n-import jdk.jpackage.test.TKit;\n+import static jdk.jpackage.test.WindowsHelper.findAppLauncherPID;\n+import static jdk.jpackage.test.WindowsHelper.killProcess;\n@@ -60,1 +54,1 @@\n-        JPackageCommand cmd = JPackageCommand.helloAppImage();\n+        var cmd = JPackageCommand.helloAppImage().ignoreFakeRuntime();\n@@ -67,4 +61,0 @@\n-        if (!cmd.canRunLauncher(\"Not running the test\")) {\n-            return;\n-        }\n-\n@@ -81,1 +71,1 @@\n-            final long pid = findMainAppLauncherPID(cmd, 2).get();\n+            final long pid = findAppLauncherPID(cmd, null, 2).get();\n@@ -84,2 +74,1 @@\n-            Executor.of(\"taskkill\", \"\/F\", \"\/PID\", Long.toString(pid)).\n-                    dumpOutput(true).execute();\n+            killProcess(pid);\n@@ -90,60 +79,1 @@\n-            findMainAppLauncherPID(cmd, 0);\n-        }\n-    }\n-\n-    private static Optional<Long> findMainAppLauncherPID(JPackageCommand cmd,\n-            int expectedCount) {\n-        \/\/ Get the list of PIDs and PPIDs of app launcher processes.\n-        \/\/ wmic process where (name = \"foo.exe\") get ProcessID,ParentProcessID\n-        List<String> output = Executor.of(\"wmic\", \"process\", \"where\", \"(name\",\n-                \"=\",\n-                \"\\\"\" + cmd.appLauncherPath().getFileName().toString() + \"\\\"\",\n-                \")\", \"get\", \"ProcessID,ParentProcessID\").dumpOutput(true).\n-                saveOutput().executeAndGetOutput();\n-\n-        if (expectedCount == 0) {\n-            TKit.assertEquals(\"No Instance(s) Available.\", output.getFirst().\n-                    trim(), \"Check no app launcher processes found running\");\n-            return Optional.empty();\n-        }\n-\n-        String[] headers = Stream.of(output.getFirst().split(\"\\\\s+\", 2)).map(\n-                String::trim).map(String::toLowerCase).toArray(String[]::new);\n-        Pattern pattern;\n-        if (headers[0].equals(\"parentprocessid\") && headers[1].equals(\n-                \"processid\")) {\n-            pattern = Pattern.compile(\"^(?<ppid>\\\\d+)\\\\s+(?<pid>\\\\d+)\\\\s+$\");\n-        } else if (headers[1].equals(\"parentprocessid\") && headers[0].equals(\n-                \"processid\")) {\n-            pattern = Pattern.compile(\"^(?<pid>\\\\d+)\\\\s+(?<ppid>\\\\d+)\\\\s+$\");\n-        } else {\n-            throw new RuntimeException(\n-                    \"Unrecognizable output of \\'wmic process\\' command\");\n-        }\n-\n-        List<long[]> processes = output.stream().skip(1).map(line -> {\n-            Matcher m = pattern.matcher(line);\n-            long[] pids = null;\n-            if (m.matches()) {\n-                pids = new long[]{Long.parseLong(m.group(\"pid\")), Long.\n-                    parseLong(m.group(\"ppid\"))};\n-            }\n-            return pids;\n-        }).filter(Objects::nonNull).toList();\n-\n-        TKit.assertEquals(expectedCount, processes.size(), String.format(\n-                \"Check [%d] app launcher processes found running\", expectedCount));\n-\n-        switch (expectedCount) {\n-            case 2 -> {\n-                if (processes.get(0)[0] == processes.get(1)[1]) {\n-                    return Optional.of(processes.get(0)[0]);\n-                } else if (processes.get(1)[0] == processes.get(0)[1]) {\n-                    return Optional.of(processes.get(1)[0]);\n-                } else {\n-                    throw new RuntimeException(\n-                            \"App launcher processes unrelated\");\n-                }\n-            }\n-            default ->\n-                throw new IllegalArgumentException();\n+            findAppLauncherPID(cmd, null, 0);\n","filename":"test\/jdk\/tools\/jpackage\/windows\/Win8301247Test.java","additions":6,"deletions":76,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- * @build WinChildProcessTest\n@@ -49,0 +48,1 @@\n+import static jdk.jpackage.test.WindowsHelper.killProcess;\n@@ -55,1 +55,1 @@\n-    public static void test() throws Throwable {\n+    public static void test() {\n@@ -81,1 +81,1 @@\n-            TKit.assertTrue(isAlive, \"Check is child process is alive\");\n+            TKit.assertTrue(isAlive, \"Check child process is alive\");\n@@ -83,2 +83,4 @@\n-            \/\/ Kill only a specific child instance\n-            Runtime.getRuntime().exec(\"taskkill \/F \/PID \" + childPid);\n+            if (childPid != 0) {\n+                \/\/ Kill only a specific child instance\n+                killProcess(childPid);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinChildProcessTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/* @test\n+ * @bug 8340311\n+ * @summary Test that jpackage windows app launcher doesn't create child process\n+ *          if `win.norestart` property is set in the corresponding .cfg file\n+ * @library ..\/helpers\n+ * @library \/test\/lib\n+ * @requires os.family == \"windows\"\n+ * @build jdk.jpackage.test.*\n+ * @build WinNoRestartTest\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=WinNoRestartTest\n+ *\n+ *\/\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.CfgFile;\n+import jdk.jpackage.test.HelloApp;\n+import static jdk.jpackage.test.WindowsHelper.findAppLauncherPID;\n+import static jdk.jpackage.test.WindowsHelper.killProcess;\n+\n+public class WinNoRestartTest {\n+\n+    @Test\n+    public static void test() throws InterruptedException, IOException {\n+        var cmd = JPackageCommand.helloAppImage().ignoreFakeRuntime();\n+\n+        \/\/ Configure test app to launch in a way it will not exit\n+        cmd.addArguments(\"--java-options\", \"-Djpackage.test.noexit=true\");\n+        cmd.execute();\n+\n+        var origCfgFile = CfgFile.load(cmd.appLauncherCfgPath(null));\n+\n+        for (var testConfig : testConfig()) {\n+            testConfig.apply(cmd, origCfgFile);\n+        }\n+    }\n+\n+    private static record NoRerunSectionConfig(String sectionName,\n+            String firstValue, String secondValue) {\n+\n+        void apply(CfgFile cfgFile) {\n+            if (firstValue != null) {\n+                cfgFile.addValue(sectionName, \"win.norestart\", firstValue);\n+            }\n+            if (secondValue != null) {\n+                cfgFile.addValue(sectionName, \"win.norestart\", secondValue);\n+            }\n+        }\n+    }\n+\n+    private static record NoRerunConfig(NoRerunSectionConfig firstSection,\n+            NoRerunSectionConfig secondSection, boolean expectedNoRestarted) {\n+\n+        void apply(JPackageCommand cmd, CfgFile origCfgFile) throws InterruptedException {\n+            \/\/ Alter the main launcher .cfg file\n+            var cfgFile = new CfgFile();\n+            if (firstSection != null) {\n+                firstSection.apply(cfgFile);\n+            }\n+            cfgFile = CfgFile.combine(cfgFile, origCfgFile);\n+\n+            if (secondSection != null) {\n+                secondSection.apply(cfgFile);\n+            }\n+\n+            \/\/ Save updated main launcher .cfg file\n+            cfgFile.save(cmd.appLauncherCfgPath(null));\n+\n+            try ( \/\/ Launch the app in a separate thread\n+                ExecutorService exec = Executors.newSingleThreadExecutor()) {\n+                exec.execute(() -> {\n+                    HelloApp.executeLauncher(cmd);\n+                });\n+\n+                \/\/ Wait a bit to let the app start\n+                Thread.sleep(Duration.ofSeconds(10));\n+\n+                \/\/ Get PID of the main app launcher process\n+                final long pid = findAppLauncherPID(cmd, null,\n+                        expectedNoRestarted ? 1 : 2).get();\n+\n+                \/\/ Kill the main app launcher process\n+                killProcess(pid);\n+            }\n+        }\n+    }\n+\n+    private static List<NoRerunConfig> testConfig() {\n+        return List.of(\n+            \/\/ Test boolean conversion\n+            withValue(true, \"true\"),\n+            withValue(true, \"7\"),\n+            withValue(true, \"TRUE\"),\n+            withValue(false, \"false\"),\n+            withValue(false, \"\"),\n+            withValue(false, \"true2\"),\n+\n+            \/\/ Test multiple values of the property (the last should win)\n+            withValues(false, \"true\", \"\"),\n+            withValues(true, \"false\", \"true\"),\n+\n+            \/\/ Test property ignored in other sections\n+            withWrongSection(\"Foo\", \"true\"),\n+            withWrongSection(\"JavaOptions\", \"true\")\n+        );\n+    }\n+\n+    private static NoRerunConfig withValue(boolean expectedNorestart,\n+            String norestartValue) {\n+        return new NoRerunConfig(null, new NoRerunSectionConfig(\"Application\",\n+                norestartValue, null), expectedNorestart);\n+    }\n+\n+    private static NoRerunConfig withValues(boolean expectedNorestart,\n+            String firstNorestartValue, String secondNorestartValue) {\n+        return new NoRerunConfig(null, new NoRerunSectionConfig(\"Application\",\n+                firstNorestartValue, secondNorestartValue), expectedNorestart);\n+    }\n+\n+    private static NoRerunConfig withWrongSection(String sectionName,\n+            String norestartValue) {\n+        return new NoRerunConfig(new NoRerunSectionConfig(sectionName,\n+                norestartValue, null), null, false);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"}]}