{"files":[{"patch":"@@ -30,1 +30,1 @@\n-void BasicLock::print_on(outputStream* st, oop owner) {\n+void BasicLock::print_on(outputStream* st, oop owner) const {\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  inline ObjectMonitor* object_monitor_cache();\n+  inline ObjectMonitor* object_monitor_cache() const;\n@@ -69,1 +69,1 @@\n-  void print_on(outputStream* st, oop owner);\n+  void print_on(outputStream* st, oop owner) const;\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-inline ObjectMonitor* BasicLock::object_monitor_cache() {\n+inline ObjectMonitor* BasicLock::object_monitor_cache() const {\n@@ -44,6 +44,1 @@\n-  ObjectMonitor* monitor = reinterpret_cast<ObjectMonitor*>(get_metadata());\n-  if (monitor != nullptr && monitor->is_being_async_deflated()) {\n-    clear_object_monitor_cache();\n-    return nullptr;\n-  }\n-  return monitor;\n+  return reinterpret_cast<ObjectMonitor*>(get_metadata());\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1669,0 +1669,3 @@\n+            \/\/ UseObjectMonitorTable expects the BasicLock cache to be either a\n+            \/\/ valid ObjectMonitor* or nullptr. Right now it is garbage, set it\n+            \/\/ to nullptr.\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -521,2 +521,6 @@\n-        _thread->om_set_monitor_cache(_monitor);\n-        _lock->set_object_monitor_cache(_monitor);\n+        \/\/ If the monitor is already in the BasicLock cache then it is most\n+        \/\/ likely in the thread cache, do not set it again to avoid reordering.\n+        if (_monitor != _lock->object_monitor_cache()) {\n+          _thread->om_set_monitor_cache(_monitor);\n+          _lock->set_object_monitor_cache(_monitor);\n+        }\n@@ -536,0 +540,10 @@\n+\/\/ Reads first from the BasicLock cache then from the OMCache in the current thread.\n+\/\/ C2 fast-path may have put the monitor in the cache in the BasicLock.\n+inline static ObjectMonitor* read_caches(JavaThread* current, BasicLock* lock, oop object) {\n+  ObjectMonitor* monitor = lock->object_monitor_cache();\n+  if (monitor == nullptr) {\n+    monitor = current->om_get_from_monitor_cache(object);\n+  }\n+  return monitor;\n+}\n+\n@@ -617,0 +631,1 @@\n+  assert(!UseObjectMonitorTable || lock->object_monitor_cache() == nullptr, \"must be cleared\");\n@@ -624,2 +639,0 @@\n-  CacheSetter cache_setter(locking_thread, lock);\n-\n@@ -642,1 +655,1 @@\n-  cache_setter.set_monitor(monitor);\n+  assert(!UseObjectMonitorTable || lock->object_monitor_cache() == nullptr, \"unused. already cleared\");\n@@ -743,1 +756,1 @@\n-    monitor = lock->object_monitor_cache();\n+    monitor = read_caches(current, lock, object);\n@@ -745,4 +758,1 @@\n-      monitor = current->om_get_from_monitor_cache(object);\n-      if (monitor == nullptr) {\n-        monitor = get_monitor_from_table(current, object);\n-      }\n+      monitor = get_monitor_from_table(current, object);\n@@ -1021,4 +1031,1 @@\n-    monitor = lock->object_monitor_cache();\n-    if (monitor == nullptr) {\n-      monitor = current->om_get_from_monitor_cache(object);\n-    }\n+    monitor = read_caches(current, lock, object);\n@@ -1046,0 +1053,3 @@\n+    \/\/ Clear the BasicLock cache as it may contain this monitor.\n+    lock->clear_object_monitor_cache();\n+\n@@ -1206,6 +1216,1 @@\n-      \/\/ C2 fast-path may have put the monitor in the cache in the BasicLock.\n-      monitor = lock->object_monitor_cache();\n-      if (monitor == nullptr) {\n-        \/\/ Otherwise look up the monitor in the thread's OMCache.\n-        monitor = current->om_get_from_monitor_cache(obj);\n-      }\n+      monitor = read_caches(current, lock, obj);\n@@ -1222,0 +1227,5 @@\n+      \/\/ Set the monitor regardless of success.\n+      \/\/ Either we successfully lock on the monitor, or we retry with the\n+      \/\/ monitor in the slow path. If the monitor gets deflated, it will be\n+      \/\/ cleared, either by the CacheSetter if we fast lock in enter or in\n+      \/\/ inflate_and_enter when we see that the monitor is deflated.\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":30,"deletions":20,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2562,1 +2562,1 @@\n-            owner());\n+            owner_raw());\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}