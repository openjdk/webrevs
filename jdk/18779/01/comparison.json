{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -98,0 +97,12 @@\n+ * Every memory segment has a {@linkplain #maxByteAlignment() maximum byte alignment}\n+ * (see <a href=\"#segment-alignment\">Alignment<\/a>\"), expressed as a {@code long} value\n+ * that is always an even power of two.\n+ * <ul>\n+ * <li>Just as the address of a heap segment is not a physical address but an offset,\n+ * the maximum byte alignment is not directly derived from a physical address but\n+ * is rather derived from the offset and also depends on the type of the backing array.\n+ * <\/li>\n+ * <li>The maximum byte alignment of a native segment (including mapped segments) is\n+ * derived directly from the physical address of the region which backs the segment.<\/li>\n+ * <\/ul>\n+ * <p>\n@@ -397,0 +408,8 @@\n+ * In order to simplify determination of alignment, in the case of either native or heap\n+ * segment, clients can use the {@linkplain MemorySegment#maxByteAlignment()} method:\n+ * {@snippet lang=java:\n+ * boolean isAligned(MemorySegment segment, long offset, MemoryLayout layout) {\n+ *   return segment.asSlice(offset).maxByteAlignment() >= layout.byteAlignment();\n+ * }\n+ * }\n+ *\n@@ -592,0 +611,26 @@\n+    \/**\n+     * {@return the <em>maximum<\/em> byte alignment (which is equal to or higher than\n+     * the requested byte alignment during native segment allocation)}\n+     * <p>\n+     * The returned alignment is always an even power of two and is derived from:\n+     * <ul>\n+     *     <li>Heap:\n+     *     the segment offset and backing array type.<\/li>\n+     *     <li>Native:\n+     *     the {@linkplain MemorySegment#address() address()} function.<\/li>\n+     * <\/ul>\n+     * The {@linkplain MemorySegment#NULL NULL} segment returns a maximum byte alignment\n+     * of 2<sup>62<\/sup>\n+     * <p>\n+     * This method can be used to ensure, a {@code segment} is sufficiently aligned\n+     * with a {@code layout}:\n+     * {@snippet lang=java:\n+     * MemoryLayout layout = ...\n+     * MemorySegment segment = ...\n+     * if (segment.maxByteAlignment() < layout.byteAlignment) {\n+     *     \/\/ Take action (e.g. throw an Exception)\n+     * }\n+     * }\n+     *\/\n+    long maxByteAlignment();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":47,"deletions":2,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,7 @@\n+    @Override\n+    public final long maxByteAlignment() {\n+        return address() == 0\n+            ? maxAlignMask()\n+            : Math.min(maxAlignMask(), Long.lowestOneBit(address()));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -64,0 +63,5 @@\n+    public final long maxByteAlignment() {\n+        return address() == 0\n+                ? 1L << 62\n+                : Long.lowestOneBit(address());\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.io.File;\n+import java.io.IOException;\n@@ -32,0 +34,1 @@\n+import java.nio.ByteBuffer;\n@@ -33,0 +36,4 @@\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n@@ -34,0 +41,1 @@\n+import java.util.stream.Stream;\n@@ -127,0 +135,42 @@\n+    @Test(dataProvider = \"alignments\")\n+    public void testActualByteAlignment(long align) {\n+        if (align > (1L << 10)) {\n+            return;\n+        }\n+        try (Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(4, align);\n+            assertTrue(segment.maxByteAlignment() >= align);\n+            \/\/ Even power of two?\n+            assertEquals(Long.bitCount(segment.maxByteAlignment()), 1);\n+            assertEquals(segment.asSlice(1).maxByteAlignment(), 1);\n+        }\n+    }\n+\n+    public void testActualByteAlignmentMappedSegment() throws IOException {\n+        File tmp = File.createTempFile(\"tmp\", \"txt\");\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE);\n+             Arena arena = Arena.ofConfined()) {\n+            var segment =channel.map(FileChannel.MapMode.READ_WRITE, 0L, 32L, arena);\n+            assertTrue(segment.maxByteAlignment() >= Long.BYTES);\n+            \/\/ Even power of two?\n+            assertEquals(Long.bitCount(segment.maxByteAlignment()), 1);\n+            assertEquals(segment.asSlice(1).maxByteAlignment(), 1);\n+        } finally {\n+            tmp.delete();\n+        }\n+    }\n+\n+    @Test()\n+    public void testActualByteAlignmentNull() {\n+        long alignment = MemorySegment.NULL.maxByteAlignment();\n+        assertEquals(1L << 62, alignment);\n+    }\n+\n+    @Test(dataProvider = \"heapSegments\")\n+    public void testActualByteAlignmentHeap(MemorySegment segment, int bytes) {\n+        assertEquals(segment.maxByteAlignment(), bytes);\n+        \/\/ A slice at offset 1 should always have an alignment of 1\n+        var segmentSlice = segment.asSlice(1);\n+        assertEquals(segmentSlice.maxByteAlignment(), 1);\n+    }\n+\n@@ -133,0 +183,16 @@\n+\n+    @DataProvider(name = \"heapSegments\")\n+    public Object[][] heapSegments() {\n+        return Stream.of(\n+                        new Object[]{MemorySegment.ofArray(new byte[]{1}), Byte.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new short[]{1}), Short.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new char[]{1}), Character.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new int[]{1}), Integer.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new long[]{1}), Long.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new float[]{1}), Float.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new double[]{1}), Double.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(ByteBuffer.allocate(8)), Byte.BYTES}\n+        )\n+                .toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"}]}