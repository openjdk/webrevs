{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -98,0 +97,5 @@\n+ * Every memory segment has a {@linkplain #maxByteAlignment() maximum byte alignment},\n+ * expressed as a {@code long} value. The maximum alignment is always a power of two,\n+ * derived from the segment address, and the segment type, as explained in more detail\n+ * <a href=\"#segment-alignment\">below<\/a>.\n+ * <p>\n@@ -397,0 +401,8 @@\n+ * Clients can use the {@linkplain MemorySegment#maxByteAlignment()} method to check if\n+ * a memory segment supports the alignment constraint of a memory layout, as follows:\n+ * {@snippet lang=java:\n+ * MemoryLayout layout = ...\n+ * MemorySegment segment = ...\n+ * boolean isAligned = segment.maxByteAlignment() >= layout.byteAlignment();\n+ * }\n+ *\n@@ -592,0 +604,20 @@\n+    \/**\n+     * {@return the <a href=\"#segment-alignment\">maximum byte alignment<\/a>\n+     * associated with this memory segment}\n+     * <p>\n+     * The returned alignment is always a power of two and is derived from\n+     * the segment {@linkplain #address() address()} and, if it is a heap segment,\n+     * the type of the {@linkplain #heapBase() backing heap storage}.\n+     * <p>\n+     * This method can be used to ensure that a segment is sufficiently aligned\n+     * with a layout:\n+     * {@snippet lang=java:\n+     * MemoryLayout layout = ...\n+     * MemorySegment segment = ...\n+     * if (segment.maxByteAlignment() < layout.byteAlignment()) {\n+     *     \/\/ Take action (e.g. throw an Exception)\n+     * }\n+     * }\n+     *\/\n+    long maxByteAlignment();\n+\n@@ -1427,0 +1459,3 @@\n+     * <p>\n+     * The {@linkplain MemorySegment#maxByteAlignment() maximum byte alignment} for\n+     * the {@code NULL} segment is of 2<sup>62<\/sup>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,7 @@\n+    @Override\n+    public final long maxByteAlignment() {\n+        return address() == 0\n+            ? maxAlignMask()\n+            : Math.min(maxAlignMask(), Long.lowestOneBit(address()));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -64,0 +63,6 @@\n+    public final long maxByteAlignment() {\n+        return address() == 0\n+                ? 1L << 62\n+                : Long.lowestOneBit(address());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.io.File;\n+import java.io.IOException;\n@@ -32,0 +34,1 @@\n+import java.nio.ByteBuffer;\n@@ -33,0 +36,10 @@\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n@@ -34,0 +47,1 @@\n+import java.util.stream.Stream;\n@@ -127,0 +141,44 @@\n+    @Test(dataProvider = \"alignments\")\n+    public void testActualByteAlignment(long align) {\n+        if (align > (1L << 10)) {\n+            return;\n+        }\n+        try (Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(4, align);\n+            assertTrue(segment.maxByteAlignment() >= align);\n+            \/\/ Power of two?\n+            assertEquals(Long.bitCount(segment.maxByteAlignment()), 1);\n+            assertEquals(segment.asSlice(1).maxByteAlignment(), 1);\n+        }\n+    }\n+\n+    public void testActualByteAlignmentMappedSegment() throws IOException {\n+        File tmp = File.createTempFile(\"tmp\", \"txt\");\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE);\n+             Arena arena = Arena.ofConfined()) {\n+            var segment =channel.map(FileChannel.MapMode.READ_WRITE, 0L, 32L, arena);\n+            \/\/ We do not know anything about mapping alignment other than it should\n+            \/\/ be positive.\n+            assertTrue(segment.maxByteAlignment() >= Byte.BYTES);\n+            \/\/ Power of two?\n+            assertEquals(Long.bitCount(segment.maxByteAlignment()), 1);\n+            assertEquals(segment.asSlice(1).maxByteAlignment(), 1);\n+        } finally {\n+            tmp.delete();\n+        }\n+    }\n+\n+    @Test()\n+    public void testActualByteAlignmentNull() {\n+        long alignment = MemorySegment.NULL.maxByteAlignment();\n+        assertEquals(1L << 62, alignment);\n+    }\n+\n+    @Test(dataProvider = \"heapSegments\")\n+    public void testActualByteAlignmentHeap(MemorySegment segment, int bytes) {\n+        assertEquals(segment.maxByteAlignment(), bytes);\n+        \/\/ A slice at offset 1 should always have an alignment of 1\n+        var segmentSlice = segment.asSlice(1);\n+        assertEquals(segmentSlice.maxByteAlignment(), 1);\n+    }\n+\n@@ -133,0 +191,22 @@\n+\n+    @DataProvider(name = \"heapSegments\")\n+    public Object[][] heapSegments() {\n+        return Stream.of(\n+                        new Object[]{MemorySegment.ofArray(new byte[]{1}), Byte.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new short[]{1}), Short.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new char[]{1}), Character.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new int[]{1}), Integer.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new long[]{1}), Long.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new float[]{1}), Float.BYTES},\n+                        new Object[]{MemorySegment.ofArray(new double[]{1}), Double.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(ByteBuffer.allocate(8)), Byte.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(CharBuffer.allocate(8)), Character.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(ShortBuffer.allocate(8)), Short.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(IntBuffer.allocate(8)), Integer.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(LongBuffer.allocate(8)), Long.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(FloatBuffer.allocate(8)), Float.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(DoubleBuffer.allocate(8)), Double.BYTES}\n+        )\n+                .toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"}]}