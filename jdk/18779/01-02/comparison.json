{"files":[{"patch":"@@ -97,11 +97,4 @@\n- * Every memory segment has a {@linkplain #maxByteAlignment() maximum byte alignment}\n- * (see <a href=\"#segment-alignment\">Alignment<\/a>\"), expressed as a {@code long} value\n- * that is always an even power of two.\n- * <ul>\n- * <li>Just as the address of a heap segment is not a physical address but an offset,\n- * the maximum byte alignment is not directly derived from a physical address but\n- * is rather derived from the offset and also depends on the type of the backing array.\n- * <\/li>\n- * <li>The maximum byte alignment of a native segment (including mapped segments) is\n- * derived directly from the physical address of the region which backs the segment.<\/li>\n- * <\/ul>\n+ * Every memory segment has a {@linkplain #maxByteAlignment() maximum byte alignment},\n+ * expressed as a {@code long} value. The maximum alignment is always a power of two,\n+ * derived from the segment address, and the segment type, as explained in more detail\n+ * (see <a href=\"#segment-alignment\">below<\/a>).\n@@ -408,2 +401,2 @@\n- * In order to simplify determination of alignment, in the case of either native or heap\n- * segment, clients can use the {@linkplain MemorySegment#maxByteAlignment()} method:\n+ * Clients can use the {@linkplain MemorySegment#maxByteAlignment()} method to check if\n+ * a memory segment supports the alignment constraint of a memory layout, as follows:\n@@ -411,3 +404,3 @@\n- * boolean isAligned(MemorySegment segment, long offset, MemoryLayout layout) {\n- *   return segment.asSlice(offset).maxByteAlignment() >= layout.byteAlignment();\n- * }\n+ * MemoryLayout layout = ...\n+ * MemorySegment segment = ...\n+ * boolean isAligned = segment.maxByteAlignment() >= layout.byteAlignment();\n@@ -612,2 +605,2 @@\n-     * {@return the <em>maximum<\/em> byte alignment (which is equal to or higher than\n-     * the requested byte alignment during native segment allocation)}\n+     * {@return the <a href=\"#segment-alignment\">maximum byte alignment<\/a>\n+     * associated with this memory segment}\n@@ -615,1 +608,1 @@\n-     * The returned alignment is always an even power of two and is derived from:\n+     * The returned alignment is always a power of two and is derived from:\n@@ -618,1 +611,2 @@\n-     *     the segment offset and backing array type.<\/li>\n+            derived from the segment {@linkplain #address() address()}\n+            and the type of the <a href=\"#segment-alignment\">backing heap storage<\/a>.\n@@ -622,2 +616,0 @@\n-     * The {@linkplain MemorySegment#NULL NULL} segment returns a maximum byte alignment\n-     * of 2<sup>62<\/sup>\n@@ -630,1 +622,1 @@\n-     * if (segment.maxByteAlignment() < layout.byteAlignment) {\n+     * if (segment.maxByteAlignment() < layout.byteAlignment()) {\n@@ -1472,0 +1464,3 @@\n+     * <p>\n+     * The {@linkplain MemorySegment#maxByteAlignment() maximum byte alignment} for\n+     * the {@code NULL} segment is of 2<sup>62<\/sup>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":18,"deletions":23,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,6 @@\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n@@ -143,1 +149,1 @@\n-            \/\/ Even power of two?\n+            \/\/ Power of two?\n@@ -154,2 +160,4 @@\n-            assertTrue(segment.maxByteAlignment() >= Long.BYTES);\n-            \/\/ Even power of two?\n+            \/\/ We do not know anything about mapping alignment other than it should\n+            \/\/ be positive.\n+            assertTrue(segment.maxByteAlignment() >= Byte.BYTES);\n+            \/\/ Power of two?\n@@ -194,1 +202,7 @@\n-                        new Object[]{MemorySegment.ofBuffer(ByteBuffer.allocate(8)), Byte.BYTES}\n+                        new Object[]{MemorySegment.ofBuffer(ByteBuffer.allocate(8)), Byte.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(CharBuffer.allocate(8)), Character.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(ShortBuffer.allocate(8)), Short.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(IntBuffer.allocate(8)), Integer.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(LongBuffer.allocate(8)), Long.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(FloatBuffer.allocate(8)), Float.BYTES},\n+                        new Object[]{MemorySegment.ofBuffer(DoubleBuffer.allocate(8)), Double.BYTES}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"}]}