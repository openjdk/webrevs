{"files":[{"patch":"@@ -865,2 +865,0 @@\n-         * <p>\n-         * This linker option can not be combined with {@link #critical}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,4 @@\n+    public boolean usingAddressPairs() {\n+        return linkerOptions.allowsHeapAccess();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -111,3 +111,12 @@\n-                addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n-                        Binding.unboxAddress(),\n-                        Binding.vmStore(abi.capturedStateStorage(), long.class)));\n+                if (linkerOptions.allowsHeapAccess()) {\n+                    addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                            Binding.dup(),\n+                            Binding.segmentBase(),\n+                            Binding.vmStore(abi.capturedStateStorage(), Object.class),\n+                            Binding.segmentOffsetAllowHeap(),\n+                            Binding.vmStore(null, long.class)));\n+                } else {\n+                    addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                            Binding.unboxAddress(),\n+                            Binding.vmStore(abi.capturedStateStorage(), long.class)));\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,1 +87,2 @@\n-            callingSequence.needsTransition()\n+            callingSequence.needsTransition(),\n+            callingSequence.usingAddressPairs()\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,5 +66,1 @@\n-        LinkerOptions linkerOptions = new LinkerOptions(optionMap);\n-        if (linkerOptions.hasCapturedCallState() && linkerOptions.isCritical()) {\n-            throw new IllegalArgumentException(\"Incompatible linker options: captureCallState, critical\");\n-        }\n-        return linkerOptions;\n+        return new LinkerOptions(optionMap);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-                                        boolean needsTransition) {\n+                                        boolean needsTransition,\n+                                        boolean usingAddressPairs) {\n@@ -67,1 +68,1 @@\n-        checkType(methodType, needsReturnBuffer, capturedStateMask);\n+        checkMethodType(methodType, needsReturnBuffer, capturedStateMask, usingAddressPairs);\n@@ -83,3 +84,6 @@\n-    private static void checkType(MethodType methodType, boolean needsReturnBuffer, int savedValueMask) {\n-        if (methodType.parameterType(0) != long.class) {\n-            throw new AssertionError(\"Address expected as first param: \" + methodType);\n+    private static void checkMethodType(MethodType methodType, boolean needsReturnBuffer, int savedValueMask,\n+                                        boolean usingAddressPairs) {\n+        int checkIdx = 0;\n+        checkParamType(methodType, checkIdx++, long.class, \"Function address\");\n+        if (needsReturnBuffer) {\n+            checkParamType(methodType, checkIdx++, long.class, \"Return buffer address\");\n@@ -87,4 +91,13 @@\n-        int checkIdx = 1;\n-        if ((needsReturnBuffer && methodType.parameterType(checkIdx++) != long.class)\n-            || (savedValueMask != 0 && methodType.parameterType(checkIdx) != long.class)) {\n-            throw new AssertionError(\"return buffer and\/or preserved value address expected: \" + methodType);\n+        if (savedValueMask != 0) { \/\/ capturing call state\n+            if (usingAddressPairs) {\n+                checkParamType(methodType, checkIdx++, Object.class, \"Capture state heap base\");\n+                checkParamType(methodType, checkIdx, long.class, \"Capture state offset\");\n+            } else {\n+                checkParamType(methodType, checkIdx, long.class, \"Capture state address\");\n+            }\n+        }\n+    }\n+\n+    private static void checkParamType(MethodType methodType, int checkIdx, Class<?> expectedType, String name) {\n+        if (methodType.parameterType(checkIdx) != expectedType) {\n+            throw new AssertionError(name + \" expected at index \" + checkIdx + \": \" + methodType);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+            Object captureStateHeapBase = null;\n@@ -166,0 +167,5 @@\n+                if (!invData.allowsHeapAccess) {\n+                    SharedUtils.checkNative(capturedState);\n+                } else {\n+                    captureStateHeapBase = capturedState.heapBase().orElse(null);\n+                }\n@@ -200,1 +206,2 @@\n-            LibFallback.doDowncall(invData.cif, target, retSeg, argPtrs, capturedState, invData.capturedStateMask(),\n+            LibFallback.doDowncall(invData.cif, target, retSeg, argPtrs,\n+                                   captureStateHeapBase, capturedState, invData.capturedStateMask(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-                           MemorySegment capturedState, int capturedStateMask,\n+                           Object captureStateHeapBase, MemorySegment capturedState, int capturedStateMask,\n@@ -97,0 +97,1 @@\n+                       captureStateHeapBase,\n@@ -215,1 +216,1 @@\n-                                          long capturedState, int capturedStateMask,\n+                                          Object captureStateHeapBase, long capturedState, int capturedStateMask,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -115,1 +115,3 @@\n-                                                              jlong avalues, jlong jcaptured_state, jint captured_state_mask,\n+                                                              jlong avalues,\n+                                                              jarray capture_state_heap_base, jlong captured_state_offset,\n+                                                              jint captured_state_mask,\n@@ -118,0 +120,2 @@\n+  int capture_state_hb_offset = numArgs;\n+  int32_t* captured_state_addr = jlong_to_ptr(captured_state_offset);\n@@ -120,1 +124,1 @@\n-    carrays = malloc(sizeof(void*) * numArgs);\n+    carrays = malloc(sizeof(void*) * (numArgs + 1));\n@@ -133,0 +137,6 @@\n+    if (capture_state_heap_base != NULL) {\n+        jboolean isCopy;\n+        jbyte* arrayPtr = (*env)->GetPrimitiveArrayCritical(env, capture_state_heap_base, &isCopy);\n+        carrays[capture_state_hb_offset] = arrayPtr;\n+        captured_state_addr = (int32_t*) (arrayPtr + captured_state_offset);\n+    }\n@@ -137,0 +147,4 @@\n+  if (captured_state_mask != 0) {\n+    do_capture_state(captured_state_addr, captured_state_mask);\n+  }\n+\n@@ -144,0 +158,3 @@\n+    if (capture_state_heap_base != NULL) {\n+        (*env)->ReleasePrimitiveArrayCritical(env, capture_state_heap_base, carrays[capture_state_hb_offset], JNI_COMMIT);\n+    }\n@@ -146,5 +163,0 @@\n-\n-  if (captured_state_mask != 0) {\n-    int32_t* captured_state = jlong_to_ptr(jcaptured_state);\n-    do_capture_state(captured_state, captured_state_mask);\n-  }\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -195,5 +195,0 @@\n-            {\n-                    FunctionDescriptor.ofVoid(),\n-                    new Linker.Option[]{Linker.Option.critical(false), Linker.Option.captureCallState(\"errno\")},\n-                    \"Incompatible linker options: captureCallState, critical\"\n-            },\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck) {}\n+    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName,\n+                                  Consumer<Object> resultCheck, boolean critical) {}\n@@ -68,2 +69,7 @@\n-        Linker.Option stl = Linker.Option.captureCallState(testCase.threadLocalName());\n-        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), stl);\n+        List<Linker.Option> options = new ArrayList<>();\n+        options.add(Linker.Option.captureCallState(testCase.threadLocalName()));\n+        if (testCase.critical()) {\n+            options.add(Linker.Option.critical(false));\n+        }\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(),\n+                options.toArray(Linker.Option[]::new));\n@@ -89,3 +95,8 @@\n-                                          Class<?> expectedExceptionType, String expectedExceptionMessage) {\n-        Linker.Option stl = Linker.Option.captureCallState(\"errno\");\n-        MethodHandle handle = downcallHandle(\"set_errno_V\", FunctionDescriptor.ofVoid(C_INT), stl);\n+                                          Class<?> expectedExceptionType, String expectedExceptionMessage,\n+                                          Linker.Option[] extraOptions) {\n+        List<Linker.Option> options = new ArrayList<>();\n+        options.add(Linker.Option.captureCallState(\"errno\"));\n+        for (Linker.Option extra : extraOptions) {\n+            options.add(extra);\n+        }\n+        MethodHandle handle = downcallHandle(\"set_errno_V\", FunctionDescriptor.ofVoid(C_INT), options.toArray(Linker.Option[]::new));\n@@ -106,20 +117,27 @@\n-        cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {}));\n-        cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42)));\n-        cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0)));\n-\n-        cases.add(structCase(\"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L)));\n-        cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                           JAVA_LONG.withName(\"y\"), 42L)));\n-        cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                            JAVA_LONG.withName(\"y\"), 42L,\n-                                            JAVA_LONG.withName(\"z\"), 42L)));\n-        cases.add(structCase(\"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D)));\n-        cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                           JAVA_DOUBLE.withName(\"y\"), 42D)));\n-        cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                            JAVA_DOUBLE.withName(\"y\"), 42D,\n-                                            JAVA_DOUBLE.withName(\"z\"), 42D)));\n-\n-        if (IS_WINDOWS) {\n-            cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {}));\n-            cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {}));\n+        for (boolean critical : new boolean[]{ true, false }) {\n+            cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT),\n+                    \"errno\", o -> {}, critical));\n+            cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT),\n+                    \"errno\", o -> assertEquals((int) o, 42), critical));\n+            cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT),\n+                    \"errno\", o -> assertEquals((double) o, 42.0), critical));\n+\n+            cases.add(structCase(\"SL\", Map.of(JAVA_LONG.withName(\"x\"), 42L), critical));\n+            cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                    JAVA_LONG.withName(\"y\"), 42L), critical));\n+            cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                    JAVA_LONG.withName(\"y\"), 42L,\n+                    JAVA_LONG.withName(\"z\"), 42L), critical));\n+            cases.add(structCase(\"SD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D), critical));\n+            cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                    JAVA_DOUBLE.withName(\"y\"), 42D), critical));\n+            cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                    JAVA_DOUBLE.withName(\"y\"), 42D,\n+                    JAVA_DOUBLE.withName(\"z\"), 42D), critical));\n+\n+            if (IS_WINDOWS) {\n+                cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT),\n+                        \"GetLastError\", o -> {}, critical));\n+                cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT),\n+                        \"WSAGetLastError\", o -> {}, critical));\n+            }\n@@ -131,1 +149,1 @@\n-    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields) {\n+    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields, boolean critical) {\n@@ -142,1 +160,2 @@\n-        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n+        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT),\n+                \"errno\", check, critical);\n@@ -148,2 +167,2 @@\n-            {Arena.ofAuto().allocate(1), IndexOutOfBoundsException.class, \".*Out of bound access on segment.*\"},\n-            {MemorySegment.NULL, IllegalArgumentException.class, \".*Capture segment is NULL.*\"},\n+            {Arena.ofAuto().allocate(1), IndexOutOfBoundsException.class, \".*Out of bound access on segment.*\", new Linker.Option[0]},\n+            {MemorySegment.NULL, IllegalArgumentException.class, \".*Capture segment is NULL.*\", new Linker.Option[0]},\n@@ -151,1 +170,3 @@\n-                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\"},\n+                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\", new Linker.Option[0]},\n+            {MemorySegment.ofArray(new byte[(int) Linker.Option.captureStateLayout().byteSize()]), \/\/ misaligned\n+                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\", new Linker.Option[0]},\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":52,"deletions":31,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.stream.Collectors;\n@@ -54,0 +55,3 @@\n+    static final MemoryLayout CAPTURE_STATE_LAYOUT = Linker.Option.captureStateLayout();\n+    static final VarHandle ERRNO_HANDLE = CAPTURE_STATE_LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"errno\"));\n+\n@@ -90,1 +94,1 @@\n-                                String fName, FunctionDescriptor fDesc, boolean readOnly) {}\n+                                String fName, FunctionDescriptor fDesc, boolean readOnly, boolean captureErrno) {}\n@@ -94,1 +98,6 @@\n-        MethodHandle handle = downcallHandle(testCase.fName(), testCase.fDesc(), Linker.Option.critical(true));\n+        List<Linker.Option> options = new ArrayList<>();\n+        options.add(Linker.Option.critical(true));\n+        if (testCase.captureErrno()) {\n+            options.add(Linker.Option.captureCallState(\"errno\"));\n+        }\n+        MethodHandle handle = downcallHandle(testCase.fName(), testCase.fDesc(), options.toArray(Linker.Option[]::new));\n@@ -104,1 +113,4 @@\n-            Object[] args = Stream.of(tvs).map(TestValue::value).toArray();\n+            List<Object> args = Stream.of(tvs).map(TestValue::value).collect(Collectors.toCollection(ArrayList::new));\n+            MemorySegment captureSegment = testCase.captureErrno()\n+                    ? MemorySegment.ofArray(new int[((int) CAPTURE_STATE_LAYOUT.byteSize() + 3) \/ 4])\n+                    : null;\n@@ -107,1 +119,1 @@\n-            args[args.length - 1] = (int) sequence.byteSize();\n+            args.set(args.size() - 1, (int) sequence.byteSize());\n@@ -109,2 +121,2 @@\n-            args[args.length - 2] = sourceSegment.value();\n-            args[args.length - 3] = heapSegment;\n+            args.set(args.size() - 2, sourceSegment.value());\n+            args.set(args.size() - 3, heapSegment);\n@@ -112,0 +124,3 @@\n+            if (testCase.captureErrno()) {\n+                args.add(0, captureSegment);\n+            }\n@@ -113,4 +128,1 @@\n-                Object[] newArgs = new Object[args.length + 1];\n-                newArgs[0] = arena;\n-                System.arraycopy(args, 0, newArgs, 1, args.length);\n-                args = newArgs;\n+                args.add(0, arena);\n@@ -120,1 +132,0 @@\n-\n@@ -127,0 +138,5 @@\n+\n+            if (testCase.captureErrno()) {\n+                int errno = (int) ERRNO_HANDLE.get(captureSegment, 0L);\n+                assertEquals(errno, 42);\n+            }\n@@ -152,8 +168,10 @@\n-        for (HeapSegmentFactory hsf : HeapSegmentFactory.values()) {\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, false));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_int\", intDesc, false));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_return_buffer\", L2Desc, false));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_imr\", L3Desc, false));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void_stack\", stackDesc, false));\n-            \/\/ readOnly\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, true));\n+        for (boolean doCapture : new boolean[]{ true, false }) {\n+            for (HeapSegmentFactory hsf : HeapSegmentFactory.values()) {\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, false, doCapture));\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_int\", intDesc, false, doCapture));\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_return_buffer\", L2Desc, false, doCapture));\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_imr\", L3Desc, false, doCapture));\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void_stack\", stackDesc, false, doCapture));\n+                \/\/ readOnly\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, true, doCapture));\n+            }\n","filename":"test\/jdk\/java\/foreign\/critical\/TestCritical.java","additions":37,"deletions":19,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    errno = 42;\n@@ -62,0 +63,1 @@\n+    errno = 42;\n@@ -74,0 +76,1 @@\n+    errno = 42;\n@@ -87,0 +90,1 @@\n+    errno = 42;\n@@ -97,0 +101,1 @@\n+    errno = 42;\n","filename":"test\/jdk\/java\/foreign\/critical\/libCritical.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,2 +34,1 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -54,0 +53,13 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+            expectedExceptionsMessageRegExp = \".*Heap segment not allowed.*\")\n+    public void testNoHeapCaptureCallState() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"test_args\", FunctionDescriptor.ofVoid(ADDRESS),\n+                Linker.Option.captureCallState(\"errno\"));\n+        try (Arena arena = Arena.ofConfined()) {\n+            assert Linker.Option.captureStateLayout().byteAlignment() % 4 == 0;\n+            MemorySegment captureHeap = MemorySegment.ofArray(new int[(int) Linker.Option.captureStateLayout().byteSize() \/ 4]);\n+            MemorySegment segment = arena.allocateFrom(C_CHAR, new byte[]{ 0, 1, 2 });\n+            handle.invoke(captureHeap, segment); \/\/ should throw for captureHeap\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/TestPassHeapSegment.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"}]}