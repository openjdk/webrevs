{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        checkType(methodType, needsReturnBuffer, capturedStateMask, usingAddressPairs);\n+        checkMethodType(methodType, needsReturnBuffer, capturedStateMask, usingAddressPairs);\n@@ -84,4 +84,14 @@\n-    private static void checkType(MethodType methodType, boolean needsReturnBuffer, int savedValueMask,\n-                                  boolean usingAddressPairs) {\n-        if (methodType.parameterType(0) != long.class) {\n-            throw new AssertionError(\"Address expected as first param: \" + methodType);\n+    private static void checkMethodType(MethodType methodType, boolean needsReturnBuffer, int savedValueMask,\n+                                        boolean usingAddressPairs) {\n+        int checkIdx = 0;\n+        checkParamType(methodType, checkIdx++, long.class, \"Function address\");\n+        if (needsReturnBuffer) {\n+            checkParamType(methodType, checkIdx++, long.class, \"Return buffer address\");\n+        }\n+        if (savedValueMask != 0) { \/\/ capturing call state\n+            if (usingAddressPairs) {\n+                checkParamType(methodType, checkIdx++, Object.class, \"Capture state heap base\");\n+                checkParamType(methodType, checkIdx, long.class, \"Capture state offset\");\n+            } else {\n+                checkParamType(methodType, checkIdx, long.class, \"Capture state address\");\n+            }\n@@ -89,8 +99,5 @@\n-        int checkIdx = 1;\n-        if ((needsReturnBuffer && methodType.parameterType(checkIdx++) != long.class)\n-            || (savedValueMask != 0 &&\n-                (usingAddressPairs\n-                        ? methodType.parameterType(checkIdx++) != Object.class\n-                            || methodType.parameterType(checkIdx) != long.class\n-                        : methodType.parameterType(checkIdx) != long.class))) {\n-            throw new AssertionError(\"return buffer and\/or preserved value address expected: \" + methodType);\n+    }\n+\n+    private static void checkParamType(MethodType methodType, int checkIdx, Class<?> expectedType, String name) {\n+        if (methodType.parameterType(checkIdx) != expectedType) {\n+            throw new AssertionError(name + \" expected at index \" + checkIdx + \": \" + methodType);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -95,3 +95,8 @@\n-                                          Class<?> expectedExceptionType, String expectedExceptionMessage) {\n-        Linker.Option stl = Linker.Option.captureCallState(\"errno\");\n-        MethodHandle handle = downcallHandle(\"set_errno_V\", FunctionDescriptor.ofVoid(C_INT), stl);\n+                                          Class<?> expectedExceptionType, String expectedExceptionMessage,\n+                                          Linker.Option[] extraOptions) {\n+        List<Linker.Option> options = new ArrayList<>();\n+        options.add(Linker.Option.captureCallState(\"errno\"));\n+        for (Linker.Option extra : extraOptions) {\n+            options.add(extra);\n+        }\n+        MethodHandle handle = downcallHandle(\"set_errno_V\", FunctionDescriptor.ofVoid(C_INT), options.toArray(Linker.Option[]::new));\n@@ -162,2 +167,2 @@\n-            {Arena.ofAuto().allocate(1), IndexOutOfBoundsException.class, \".*Out of bound access on segment.*\"},\n-            {MemorySegment.NULL, IllegalArgumentException.class, \".*Capture segment is NULL.*\"},\n+            {Arena.ofAuto().allocate(1), IndexOutOfBoundsException.class, \".*Out of bound access on segment.*\", new Linker.Option[0]},\n+            {MemorySegment.NULL, IllegalArgumentException.class, \".*Capture segment is NULL.*\", new Linker.Option[0]},\n@@ -165,1 +170,3 @@\n-                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\"},\n+                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\", new Linker.Option[0]},\n+            {MemorySegment.ofArray(new byte[(int) Linker.Option.captureStateLayout().byteSize()]), \/\/ misaligned\n+                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\", new Linker.Option[0]},\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"}]}