{"files":[{"patch":"@@ -2814,5 +2814,1 @@\n-    \/\/ MulAddS2I takes shorts and produces ints.\n-    if (u_pk->size() * 2 != d_pk->size()) {\n-      return false;\n-    }\n-    return true;\n+    return _packset.is_muladds2i_pack_with_pack_inputs(u_pk);\n@@ -2835,0 +2831,54 @@\n+\/\/ MulAddS2I takes shorts 4 shorts and produces an int. We can reinterpret\n+\/\/ the 4 shorts as two ints: a = (a0, a1) and b = (b0, b1).\n+\/\/\n+\/\/ Inputs:                 1    2    3    4\n+\/\/ Offsets:                0    0    1    1\n+\/\/   v = MulAddS2I(a, b) = a0 * b0 + a1 * b1\n+\/\/\n+\/\/ But permutations are possible, because add and mul are commutative. For\n+\/\/ simplicity, we the first input is always either a0 or a1. These are all\n+\/\/ the possible permutations:\n+\/\/\n+\/\/   v = MulAddS2I(a, b) = a0 * b0 + a1 * b1     (case 1)\n+\/\/   v = MulAddS2I(a, b) = a0 * b0 + b1 * a1     (case 2)\n+\/\/   v = MulAddS2I(a, b) = a1 * b1 + a0 * b0     (case 3)\n+\/\/   v = MulAddS2I(a, b) = a1 * b1 + b0 * a0     (case 4)\n+\/\/\n+\/\/ To vectorize, we expect (a0, a1) to be consecutive in one input pack,\n+\/\/ and (b0, b1) in the other input pack. Thus, both a and b are strided,\n+\/\/ with stride = 2. Further, a0 and b0 have offset 0, whereas a1 and b1\n+\/\/ have offset 1.\n+bool PackSet::is_muladds2i_pack_with_pack_inputs(const Node_List* pack) const {\n+  assert(VectorNode::is_muladds2i(pack->at(0)), \"must be MulAddS2I\");\n+\n+  bool pack1_has_offset_0 = (strided_pack_input_at_index_or_null(pack, 1, 2, 0) != nullptr);\n+  Node_List* pack1 = strided_pack_input_at_index_or_null(pack, 1, 2, pack1_has_offset_0 ? 0 : 1);\n+  Node_List* pack2 = strided_pack_input_at_index_or_null(pack, 2, 2, pack1_has_offset_0 ? 0 : 1);\n+  Node_List* pack3 = strided_pack_input_at_index_or_null(pack, 3, 2, pack1_has_offset_0 ? 1 : 0);\n+  Node_List* pack4 = strided_pack_input_at_index_or_null(pack, 4, 2, pack1_has_offset_0 ? 1 : 0);\n+\n+  return pack1 != nullptr &&\n+         pack2 != nullptr &&\n+         pack3 != nullptr &&\n+         pack4 != nullptr &&\n+         ((pack1 == pack3 && pack2 == pack4) || \/\/ case 1 or 3\n+          (pack1 == pack4 && pack2 == pack3));  \/\/ case 2 or 4\n+}\n+\n+Node_List* PackSet::strided_pack_input_at_index_or_null(const Node_List* pack, const int index, const int stride, const int offset) const {\n+  Node* p0 = pack->at(0);\n+  Node* def0 = p0->in(index);\n+\n+  Node_List* pack_in = get_pack(def0);\n+  if (pack_in == nullptr || pack->size() * stride != pack_in->size()) {\n+    return nullptr; \/\/ size mismatch\n+  }\n+\n+  for (uint i = 1; i < pack->size(); i++) {\n+    if (pack->at(i)->in(index) != pack_in->at(i * stride + offset)) {\n+      return nullptr; \/\/ use-def mismatch\n+    }\n+  }\n+  return pack_in;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":55,"deletions":5,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -365,0 +365,3 @@\n+  Node_List* strided_pack_input_at_index_or_null(const Node_List* pack, const int index, const int stride, const int offset) const;\n+  bool is_muladds2i_pack_with_pack_inputs(const Node_List* pack) const;\n+\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-    static int[] ioutArr = new int[RANGE];\n@@ -53,0 +52,4 @@\n+    static final int[] GOLDEN_I;\n+    static final int[] GOLDEN_J;\n+    static final int[] GOLDEN_K;\n+    static final int[] GOLDEN_L;\n@@ -61,6 +64,10 @@\n-        GOLDEN_C = testc();\n-        GOLDEN_D = testd();\n-        GOLDEN_E = teste();\n-        GOLDEN_F = testf();\n-        GOLDEN_G = testg();\n-        GOLDEN_H = testh();\n+        GOLDEN_C = testc(new int[ITER]);\n+        GOLDEN_D = testd(new int[ITER]);\n+        GOLDEN_E = teste(new int[ITER]);\n+        GOLDEN_F = testf(new int[ITER]);\n+        GOLDEN_G = testg(new int[ITER]);\n+        GOLDEN_H = testh(new int[ITER]);\n+        GOLDEN_I = testi(new int[ITER]);\n+        GOLDEN_J = testj(new int[ITER]);\n+        GOLDEN_K = testk(new int[ITER]);\n+        GOLDEN_L = testl(new int[ITER]);\n@@ -75,1 +82,2 @@\n-    @Run(test = {\"testa\", \"testb\", \"testc\", \"testd\", \"teste\", \"testf\", \"testg\", \"testh\"})\n+    @Run(test = {\"testa\", \"testb\", \"testc\", \"testd\", \"teste\", \"testf\", \"testg\", \"testh\",\n+                 \"testi\", \"testj\", \"testk\", \"testl\"})\n@@ -80,6 +88,10 @@\n-        compare(testc(), GOLDEN_C, \"testc\");\n-        compare(testd(), GOLDEN_D, \"testd\");\n-        compare(teste(), GOLDEN_E, \"teste\");\n-        compare(testf(), GOLDEN_F, \"testf\");\n-        compare(testg(), GOLDEN_G, \"testg\");\n-        compare(testh(), GOLDEN_H, \"testh\");\n+        compare(testc(new int[ITER]), GOLDEN_C, \"testc\");\n+        compare(testd(new int[ITER]), GOLDEN_D, \"testd\");\n+        compare(teste(new int[ITER]), GOLDEN_E, \"teste\");\n+        compare(testf(new int[ITER]), GOLDEN_F, \"testf\");\n+        compare(testg(new int[ITER]), GOLDEN_G, \"testg\");\n+        compare(testh(new int[ITER]), GOLDEN_H, \"testh\");\n+        compare(testi(new int[ITER]), GOLDEN_I, \"testi\");\n+        compare(testj(new int[ITER]), GOLDEN_J, \"testj\");\n+        compare(testk(new int[ITER]), GOLDEN_K, \"testk\");\n+        compare(testl(new int[ITER]), GOLDEN_L, \"testl\");\n@@ -141,2 +153,1 @@\n-    public static int[] testc() {\n-        int[] out = new int[ITER];\n+    public static int[] testc(int[] out) {\n@@ -158,2 +169,1 @@\n-    public static int[] testd() {\n-        int[] out = ioutArr;\n+    public static int[] testd(int[] out) {\n@@ -177,2 +187,1 @@\n-    public static int[] teste() {\n-        int[] out = ioutArr;\n+    public static int[] teste(int[] out) {\n@@ -196,2 +205,1 @@\n-    public static int[] testf() {\n-        int[] out = ioutArr;\n+    public static int[] testf(int[] out) {\n@@ -215,2 +223,1 @@\n-    public static int[] testg() {\n-        int[] out = ioutArr;\n+    public static int[] testg(int[] out) {\n@@ -234,2 +241,1 @@\n-    public static int[] testh() {\n-        int[] out = ioutArr;\n+    public static int[] testh(int[] out) {\n@@ -243,0 +249,53 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_ADD_S2I, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.MUL_ADD_VS2VI, \"= 0\"})\n+    public static int[] testi(int[] out) {\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps that prevent vectorization.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1])); \/\/ ok\n+            out[i+1] += ((sArr1[2*i+2] * sArr2[2*i+3]) + (sArr1[2*i+3] * sArr2[2*i+2])); \/\/ bad\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_ADD_S2I, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.MUL_ADD_VS2VI, \"= 0\"})\n+    public static int[] testj(int[] out) {\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps that prevent vectorization.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+1]) + (sArr1[2*i+1] * sArr2[2*i+0])); \/\/ bad\n+            out[i+1] += ((sArr1[2*i+2] * sArr2[2*i+3]) + (sArr1[2*i+3] * sArr2[2*i+2])); \/\/ bad\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_ADD_S2I, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.MUL_ADD_VS2VI, \"= 0\"})\n+    public static int[] testk(int[] out) {\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps that prevent vectorization.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+1]) + (sArr1[2*i+1] * sArr2[2*i+0])); \/\/ bad\n+            out[i+1] += ((sArr1[2*i+2] * sArr2[2*i+2]) + (sArr1[2*i+3] * sArr2[2*i+3])); \/\/ ok\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_ADD_S2I, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.MUL_ADD_VS2VI, \"= 0\"})\n+    public static int[] testl(int[] out) {\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps that prevent vectorization.\n+            out[i+0] += ((sArr1[2*i+1] * sArr2[2*i+1]) + (sArr1[2*i+0] * sArr2[2*i+0])); \/\/ ok\n+            out[i+1] += ((sArr1[2*i+2] * sArr2[2*i+3]) + (sArr1[2*i+3] * sArr2[2*i+2])); \/\/ bad\n+        }\n+        return out;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":85,"deletions":26,"binary":false,"changes":111,"status":"modified"}]}