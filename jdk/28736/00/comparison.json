{"files":[{"patch":"@@ -148,1 +148,1 @@\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n@@ -191,1 +191,1 @@\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n@@ -261,1 +261,1 @@\n-    if (ik->is_hidden() && CDSConfig::is_initing_classes_at_dump_time()) {\n+    if (ik->is_hidden() && CDSConfig::is_dumping_aot_linked_classes()) {\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  if (!CDSConfig::is_initing_classes_at_dump_time()) {\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n@@ -67,1 +67,1 @@\n-  \/\/ When CDSConfig::is_initing_classes_at_dump_time is enabled,\n+  \/\/ When CDSConfig::is_dumping_aot_linked_classes is enabled,\n@@ -313,1 +313,1 @@\n-  if (AOTInitTestClass != nullptr && CDSConfig::is_initing_classes_at_dump_time()) {\n+  if (AOTInitTestClass != nullptr && CDSConfig::is_dumping_aot_linked_classes()) {\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1143,1 +1143,1 @@\n-    if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    if (CDSConfig::is_dumping_aot_linked_classes()) {\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1029,4 +1029,0 @@\n-bool CDSConfig::is_initing_classes_at_dump_time() {\n-  return is_dumping_heap() && is_dumping_aot_linked_classes();\n-}\n-\n@@ -1039,2 +1035,2 @@\n-\/\/ When we are dumping aot-linked classes and we are able to write archived heap objects, we automatically\n-\/\/ enable the archiving of MethodHandles. This will in turn enable the archiving of MethodTypes and hidden\n+\/\/ When we are dumping aot-linked classes, we automatically enable the archiving of MethodHandles.\n+\/\/ This will in turn enable the archiving of MethodTypes and hidden\n@@ -1045,1 +1041,1 @@\n-  return is_initing_classes_at_dump_time();\n+  return is_dumping_aot_linked_classes();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -190,1 +190,0 @@\n-  static bool is_initing_classes_at_dump_time()              NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-\/\/ !!! CDSConfig::is_initing_classes_at_dump_time()==true.\n+\/\/ !!! CDSConfig::is_dumping_aot_linked_classes()==true.\n@@ -66,1 +66,1 @@\n-  assert(!CDSConfig::is_initing_classes_at_dump_time(), \"only for legacy support of enums\");\n+  assert(!CDSConfig::is_dumping_aot_linked_classes(), \"only for legacy support of enums\");\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-\/\/ CDSConfig::is_initing_classes_at_dump_time()==true.\n+\/\/ CDSConfig::is_dumping_aot_linked_classes()==true.\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,0 +209,2 @@\n+          ResourceMark rm(THREAD);\n+          log_info(aot, init)(\"Initializing %s\", ik->external_name());\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -212,2 +212,8 @@\n-  return is_subgraph_root_class_of(archive_subgraph_entry_fields, ik) ||\n-         is_subgraph_root_class_of(fmg_archive_subgraph_entry_fields, ik);\n+  assert(CDSConfig::is_dumping_heap(), \"dump-time only\");\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ Legacy CDS archive support (to be deprecated)\n+    return is_subgraph_root_class_of(archive_subgraph_entry_fields, ik) ||\n+           is_subgraph_root_class_of(fmg_archive_subgraph_entry_fields, ik);\n+  } else {\n+    return false;\n+  }\n@@ -937,2 +943,8 @@\n-  archive_object_subgraphs(archive_subgraph_entry_fields,\n-                           false \/* is_full_module_graph *\/);\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    archive_object_subgraphs(archive_subgraph_entry_fields,\n+                             false \/* is_full_module_graph *\/);\n+    if (CDSConfig::is_dumping_full_module_graph()) {\n+      archive_object_subgraphs(fmg_archive_subgraph_entry_fields,\n+                               true \/* is_full_module_graph *\/);\n+    }\n+  }\n@@ -941,2 +953,0 @@\n-    archive_object_subgraphs(fmg_archive_subgraph_entry_fields,\n-                             true \/* is_full_module_graph *\/);\n@@ -1298,2 +1308,4 @@\n-  resolve_classes_for_subgraphs(current, archive_subgraph_entry_fields);\n-  resolve_classes_for_subgraphs(current, fmg_archive_subgraph_entry_fields);\n+  if (!CDSConfig::is_using_aot_linked_classes()) {\n+    resolve_classes_for_subgraphs(current, archive_subgraph_entry_fields);\n+    resolve_classes_for_subgraphs(current, fmg_archive_subgraph_entry_fields);\n+  }\n@@ -1737,1 +1749,1 @@\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n@@ -1743,1 +1755,1 @@\n-    \/\/ Without CDSConfig::is_initing_classes_at_dump_time(), we only allow archived objects to\n+    \/\/ Without CDSConfig::is_dumping_aot_linked_classes(), we only allow archived objects to\n@@ -1811,3 +1823,3 @@\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n-    \/\/ The classes of all archived enum instances have been marked as aot-init,\n-    \/\/ so there's nothing else to be done in the production run.\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ The enum klasses are archived with aot-initialized mirror.\n+    \/\/ See AOTClassInitializer::can_archive_initialized_mirror().\n@@ -1952,1 +1964,1 @@\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n@@ -2139,3 +2151,5 @@\n-  init_subgraph_entry_fields(archive_subgraph_entry_fields, CHECK);\n-  if (CDSConfig::is_dumping_full_module_graph()) {\n-    init_subgraph_entry_fields(fmg_archive_subgraph_entry_fields, CHECK);\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    init_subgraph_entry_fields(archive_subgraph_entry_fields, CHECK);\n+    if (CDSConfig::is_dumping_full_module_graph()) {\n+      init_subgraph_entry_fields(fmg_archive_subgraph_entry_fields, CHECK);\n+    }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -106,0 +107,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -9382,0 +9383,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -894,0 +896,1 @@\n+    @AOTSafeClassInitializer\n@@ -896,1 +899,1 @@\n-        static final int high;\n+        @Stable static int high;\n@@ -898,2 +901,1 @@\n-        @Stable\n-        static final Integer[] cache;\n+        @Stable static Integer[] cache;\n@@ -903,0 +905,5 @@\n+            runtimeSetup();\n+        }\n+\n+        @AOTRuntimeSetup\n+        private static void runtimeSetup() {\n@@ -918,22 +925,9 @@\n-            \/\/ Load IntegerCache.archivedCache from archive, if possible\n-            CDS.initializeFromArchive(IntegerCache.class);\n-            int size = (high - low) + 1;\n-\n-            \/\/ Use the archived cache if it exists and is large enough\n-            if (archivedCache == null || size > archivedCache.length) {\n-                Integer[] c = new Integer[size];\n-                int j = low;\n-                \/\/ If archive has Integer cache, we must use all instances from it.\n-                \/\/ Otherwise, the identity checks between archived Integers and\n-                \/\/ runtime-cached Integers would fail.\n-                int archivedSize = (archivedCache == null) ? 0 : archivedCache.length;\n-                for (int i = 0; i < archivedSize; i++) {\n-                    c[i] = archivedCache[i];\n-                    assert j == archivedCache[i];\n-                    j++;\n-                }\n-                \/\/ Fill the rest of the cache.\n-                for (int i = archivedSize; i < size; i++) {\n-                    c[i] = new Integer(j++);\n-                }\n-                archivedCache = c;\n+            Integer[] precomputed = null;\n+            if (cache != null) {\n+                \/\/ IntegerCache has been AOT-initialized.\n+                precomputed = cache;\n+            } else {\n+                \/\/ Legacy CDS archive support (to be deprecated):\n+                \/\/ Load IntegerCache.archivedCache from archive, if possible\n+                CDS.initializeFromArchive(IntegerCache.class);\n+                precomputed = archivedCache;\n@@ -941,1 +935,3 @@\n-            cache = archivedCache;\n+\n+            cache = loadOrInitializeCache(precomputed);\n+            archivedCache = cache; \/\/ Legacy CDS archive support (to be deprecated)\n@@ -946,0 +942,27 @@\n+        private static Integer[] loadOrInitializeCache(Integer[] precomputed) {\n+            int size = (high - low) + 1;\n+\n+            \/\/ Use the precomputed cache if it exists and is large enough\n+            if (precomputed != null && size <= precomputed.length) {\n+                return precomputed;\n+            }\n+\n+            Integer[] c = new Integer[size];\n+            int j = low;\n+            \/\/ If we loading a precomputed cache (from AOT cache or CDS archive),\n+            \/\/ we must use all instances from it.\n+            \/\/ Otherwise, the Integers from the AOT cache (or CDS archive) will not\n+            \/\/ have the same object identity as items in IntegerCache.cache[].\n+            int precomputedSize = (precomputed == null) ? 0 : precomputed.length;\n+            for (int i = 0; i < precomputedSize; i++) {\n+                c[i] = precomputed[i];\n+                assert j == precomputed[i];\n+                j++;\n+            }\n+            \/\/ Fill the rest of the cache.\n+            for (int i = precomputedSize; i < size; i++) {\n+                c[i] = new Integer(j++);\n+            }\n+            return c;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":49,"deletions":26,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -914,0 +915,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -394,0 +395,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -148,0 +149,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -233,0 +234,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -158,0 +159,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/Configuration.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -55,0 +58,1 @@\n+@AOTSafeClassInitializer\n@@ -62,1 +66,1 @@\n-    private static final long SALT32L;\n+    @Stable private static long SALT32L;\n@@ -68,1 +72,2 @@\n-    private static final boolean REVERSE;\n+    @Stable private static boolean REVERSE;\n+\n@@ -70,1 +75,6 @@\n-        \/\/ to generate a reasonably random and well-mixed SALT, use an arbitrary\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n+         \/\/ to generate a reasonably random and well-mixed SALT, use an arbitrary\n@@ -105,0 +115,1 @@\n+        \/\/ Legacy CDS archive support (to be deprecated)\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -63,0 +64,1 @@\n+@AOTSafeClassInitializer\n@@ -453,0 +455,1 @@\n+    @AOTSafeClassInitializer\n@@ -672,0 +675,1 @@\n+            \/\/ Legacy CDS archive support (to be deprecated)\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/Attributes.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -35,0 +36,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/ArchivedClassLoaders.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -36,0 +37,1 @@\n+@AOTSafeClassInitializer\n@@ -56,0 +58,1 @@\n+        \/\/ Legacy CDS archive support (to be deprecated)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FDBigInteger.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -32,0 +33,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ArchivedBootLayer.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -38,0 +39,1 @@\n+@AOTSafeClassInitializer\n@@ -129,0 +131,1 @@\n+        \/\/ Legacy CDS archive support (to be deprecated)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ArchivedModuleGraph.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -42,0 +44,1 @@\n+@AOTSafeClassInitializer\n@@ -66,0 +69,1 @@\n+        \/\/ Legacy CDS archive support (to be deprecated)\n@@ -94,1 +98,8 @@\n-    private static final LazyConstant<ReferencedKeySet<BaseLocale>> CACHE =\n+    @Stable private static LazyConstant<ReferencedKeySet<BaseLocale>> CACHE;\n+    static {\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n+        CACHE =\n@@ -101,0 +112,1 @@\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -525,0 +525,1 @@\n+ -runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,11 +86,0 @@\n-        \/\/----------------------------------------------------------------------\n-        printTestCase(\"All old -Xlog:cds+heap logs have been changed to -Xlog:aot+heap should alias to -Xlog:cds+heap\");\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n-            \"-XX:AOTCache=\" + aotCacheFile,\n-            \"-Xlog:aot+heap\",\n-            \"-cp\", appJar, helloClass);\n-        out = CDSTestUtils.executeAndLog(pb, \"prod\");\n-        out.shouldNotContain(\"No tag set matches selection: aot+heap\");\n-        out.shouldContain(\"[aot,heap] resolve subgraph java.lang.Integer$IntegerCache\");\n-        out.shouldHaveExitValue(0);\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/AOTLoggingTag.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test AOT cache should preserve heap object identity when required by JLS. For example, Enums and Integers.\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @build HeapObjectIdentity\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar dummy.jar\n+ *                 Dummy\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar boot.jar\n+ *                 HeapObjectIdentityApp\n+ *                 MyAOTInitedClass\n+ *                 MyAOTInitedClass$MyEnum\n+ *                 MyAOTInitedClass$Wrapper\n+ * @run driver HeapObjectIdentity AOT --two-step-training\n+ *\/\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class HeapObjectIdentity {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"dummy.jar\");\n+    static final String bootJar = ClassFileInstaller.getJarPath(\"boot.jar\");\n+    static final String mainClass = \"HeapObjectIdentityApp\"; \/\/ Loaded from boot.jar\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester t = new Tester();\n+        t.run(args);\n+\n+        \/\/ Integer$IntegerCache should preserve the object identity of cached Integer objects,\n+        \/\/ even when the cache size is different between assembly and production.\n+        t.productionRun(new String[] {\n+                \"-XX:AutoBoxCacheMax=2048\"\n+                });\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            String bootcp = \"-Xbootclasspath\/a:\" + bootJar;\n+            if (runMode == RunMode.ASSEMBLY) {\n+                return new String[] {\n+                    \"-Xlog:aot+class=debug\",\n+                    \"-XX:AOTInitTestClass=MyAOTInitedClass\",\n+                    bootcp\n+                };\n+            } else {\n+                return new String[] {bootcp};\n+            }\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+                runMode.toString(),\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                out.shouldContain(\"MyAOTInitedClass aot-linked inited\");\n+            }\n+        }\n+    }\n+}\n+\n+class HeapObjectIdentityApp {\n+    public static void main(String... args) {\n+        MyAOTInitedClass.test();\n+    }\n+}\n+\n+\/\/ This class is loaded by the boot loader, as -XX:AOTInitTestClass is not too friendly\n+\/\/ with classes by other loaders.\n+class MyAOTInitedClass {\n+    static Object[] archivedObjects;\n+    static {\n+        if (archivedObjects == null) {\n+            archivedObjects = new Object[14];\n+            archivedObjects[0] = Wrapper.BOOLEAN;\n+            archivedObjects[1] = Wrapper.INT.zero();\n+            archivedObjects[2] = Wrapper.DOUBLE.zero();\n+            archivedObjects[3] = MyEnum.DUMMY1;\n+\n+            archivedObjects[4] = Boolean.class;\n+            archivedObjects[5] = Byte.class;\n+            archivedObjects[6] = Character.class;\n+            archivedObjects[7] = Short.class;\n+            archivedObjects[8] = Integer.class;\n+            archivedObjects[9] = Long.class;\n+            archivedObjects[10] = Float.class;\n+            archivedObjects[11] = Double.class;\n+            archivedObjects[12] = Void.class;\n+\n+            archivedObjects[13] = Integer.valueOf(1);\n+        } else {\n+            System.out.println(\"Initialized from CDS\");\n+        }\n+    }\n+\n+    public static void test() {\n+        if (archivedObjects[0] != Wrapper.BOOLEAN) {\n+            throw new RuntimeException(\"Huh 0\");\n+        }\n+\n+        if (archivedObjects[1] != Wrapper.INT.zero()) {\n+            throw new RuntimeException(\"Huh 1\");\n+        }\n+\n+        if (archivedObjects[2] != Wrapper.DOUBLE.zero()) {\n+            throw new RuntimeException(\"Huh 2\");\n+        }\n+\n+        if (archivedObjects[3] != MyEnum.DUMMY1) {\n+            throw new RuntimeException(\"Huh 3\");\n+        }\n+\n+        if (MyEnum.BOOLEAN != true) {\n+            throw new RuntimeException(\"Huh 10.1\");\n+        }\n+        if (MyEnum.BYTE != -128) {\n+            throw new RuntimeException(\"Huh 10.2\");\n+        }\n+        if (MyEnum.CHAR != 'c') {\n+            throw new RuntimeException(\"Huh 10.3\");\n+        }\n+        if (MyEnum.SHORT != -12345) {\n+            throw new RuntimeException(\"Huh 10.4\");\n+        }\n+        if (MyEnum.INT != -123456) {\n+            throw new RuntimeException(\"Huh 10.5\");\n+        }\n+        if (MyEnum.LONG != 0x1234567890L) {\n+            throw new RuntimeException(\"Huh 10.6\");\n+        }\n+        if (MyEnum.LONG2 != -0x1234567890L) {\n+            throw new RuntimeException(\"Huh 10.7\");\n+        }\n+        if (MyEnum.FLOAT != 567891.0f) {\n+            throw new RuntimeException(\"Huh 10.8\");\n+        }\n+        if (MyEnum.DOUBLE != 12345678905678.890) {\n+            throw new RuntimeException(\"Huh 10.9\");\n+        }\n+\n+        checkClass(4, Boolean.class);\n+        checkClass(5, Byte.class);\n+        checkClass(6, Character.class);\n+        checkClass(7, Short.class);\n+        checkClass(8, Integer.class);\n+        checkClass(9, Long.class);\n+        checkClass(10, Float.class);\n+        checkClass(11, Double.class);\n+        checkClass(12, Void.class);\n+\n+        if (archivedObjects[13] != Integer.valueOf(1)) {\n+            throw new RuntimeException(\"Integer cache identity test failed\");\n+        }\n+\n+        System.out.println(\"Success!\");\n+    }\n+\n+    static void checkClass(int index, Class c) {\n+        if (archivedObjects[index] != c) {\n+            throw new RuntimeException(\"archivedObjects[\" + index + \"] should be \" + c);\n+        }\n+    }\n+\n+    \/\/ Simplified version of sun.invoke.util.Wrapper\n+    public enum Wrapper {\n+        \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray\n+        BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0]),\n+        INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0]),\n+        DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0])\n+        ;\n+\n+        public static final int COUNT = 10;\n+        private static final Object DOUBLE_ZERO = (Double)(double)0;\n+\n+        private final Class<?> wrapperType;\n+        private final Class<?> primitiveType;\n+        private final char     basicTypeChar;\n+        private final String   basicTypeString;\n+        private final Object   emptyArray;\n+\n+        Wrapper(Class<?> wtype,\n+                String wtypeName,\n+                Class<?> ptype,\n+                String ptypeName,\n+                char tchar,\n+                Object emptyArray) {\n+            this.wrapperType = wtype;\n+            this.primitiveType = ptype;\n+            this.basicTypeChar = tchar;\n+            this.basicTypeString = String.valueOf(this.basicTypeChar);\n+            this.emptyArray = emptyArray;\n+        }\n+\n+        public Object zero() {\n+            return switch (this) {\n+                case BOOLEAN -> Boolean.FALSE;\n+                case INT -> (Integer)0;\n+                case DOUBLE -> DOUBLE_ZERO;\n+                default -> null;\n+            };\n+        }\n+    }\n+\n+    enum MyEnum {\n+        DUMMY1,\n+        DUMMY2;\n+\n+        static final boolean BOOLEAN = true;\n+        static final byte    BYTE    = -128;\n+        static final short   SHORT   = -12345;\n+        static final char    CHAR    = 'c';\n+        static final int     INT     = -123456;\n+        static final long    LONG    =  0x1234567890L;\n+        static final long    LONG2   = -0x1234567890L;\n+        static final float   FLOAT   = 567891.0f;\n+        static final double  DOUBLE  = 12345678905678.890;\n+    }\n+}\n+\n+class Dummy {}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/HeapObjectIdentity.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n- *             CDSTestClassE CDSTestClassF CDSTestClassG CDSTestClassG$MyEnum CDSTestClassG$Wrapper\n+ *             CDSTestClassE CDSTestClassF\n@@ -61,1 +61,0 @@\n-    static final String CDSTestClassG_name = CDSTestClassG.class.getName();\n@@ -165,9 +164,0 @@\n-\n-        testCase(\"Complex enums\");\n-        output = dumpBootAndHello(CDSTestClassG_name, \"-XX:+AOTClassLinking\", \"-Xlog:cds+class=debug\");\n-        mustSucceed(output);\n-\n-        TestCommon.run(\"-Xbootclasspath\/a:\" + bootJar, \"-cp\", appJar, \"-Xlog:aot+heap,cds+init\",\n-                       CDSTestClassG_name)\n-            .assertNormalExit(\"init subgraph \" + CDSTestClassG_name,\n-                              \"Initialized from CDS\");\n@@ -290,144 +280,0 @@\n-\n-class CDSTestClassG {\n-    static Object[] archivedObjects;\n-    static {\n-        if (archivedObjects == null) {\n-            archivedObjects = new Object[13];\n-            archivedObjects[0] = Wrapper.BOOLEAN;\n-            archivedObjects[1] = Wrapper.INT.zero();\n-            archivedObjects[2] = Wrapper.DOUBLE.zero();\n-            archivedObjects[3] = MyEnum.DUMMY1;\n-\n-            archivedObjects[4] = Boolean.class;\n-            archivedObjects[5] = Byte.class;\n-            archivedObjects[6] = Character.class;\n-            archivedObjects[7] = Short.class;\n-            archivedObjects[8] = Integer.class;\n-            archivedObjects[9] = Long.class;\n-            archivedObjects[10] = Float.class;\n-            archivedObjects[11] = Double.class;\n-            archivedObjects[12] = Void.class;\n-        } else {\n-            System.out.println(\"Initialized from CDS\");\n-        }\n-    }\n-\n-    public static void main(String args[]) {\n-        if (archivedObjects[0] != Wrapper.BOOLEAN) {\n-            throw new RuntimeException(\"Huh 0\");\n-        }\n-\n-        if (archivedObjects[1] != Wrapper.INT.zero()) {\n-            throw new RuntimeException(\"Huh 1\");\n-        }\n-\n-        if (archivedObjects[2] != Wrapper.DOUBLE.zero()) {\n-            throw new RuntimeException(\"Huh 2\");\n-        }\n-\n-        if (archivedObjects[3] != MyEnum.DUMMY1) {\n-            throw new RuntimeException(\"Huh 3\");\n-        }\n-\n-        if (MyEnum.BOOLEAN != true) {\n-            throw new RuntimeException(\"Huh 10.1\");\n-        }\n-        if (MyEnum.BYTE != -128) {\n-            throw new RuntimeException(\"Huh 10.2\");\n-        }\n-        if (MyEnum.CHAR != 'c') {\n-            throw new RuntimeException(\"Huh 10.3\");\n-        }\n-        if (MyEnum.SHORT != -12345) {\n-            throw new RuntimeException(\"Huh 10.4\");\n-        }\n-        if (MyEnum.INT != -123456) {\n-            throw new RuntimeException(\"Huh 10.5\");\n-        }\n-        if (MyEnum.LONG != 0x1234567890L) {\n-            throw new RuntimeException(\"Huh 10.6\");\n-        }\n-        if (MyEnum.LONG2 != -0x1234567890L) {\n-            throw new RuntimeException(\"Huh 10.7\");\n-        }\n-        if (MyEnum.FLOAT != 567891.0f) {\n-            throw new RuntimeException(\"Huh 10.8\");\n-        }\n-        if (MyEnum.DOUBLE != 12345678905678.890) {\n-            throw new RuntimeException(\"Huh 10.9\");\n-        }\n-\n-        checkClass(4, Boolean.class);\n-        checkClass(5, Byte.class);\n-        checkClass(6, Character.class);\n-        checkClass(7, Short.class);\n-        checkClass(8, Integer.class);\n-        checkClass(9, Long.class);\n-        checkClass(10, Float.class);\n-        checkClass(11, Double.class);\n-        checkClass(12, Void.class);\n-\n-        System.out.println(\"Success!\");\n-    }\n-\n-    static void checkClass(int index, Class c) {\n-        if (archivedObjects[index] != c) {\n-            throw new RuntimeException(\"archivedObjects[\" + index + \"] should be \" + c);\n-        }\n-    }\n-\n-    \/\/ Simplified version of sun.invoke.util.Wrapper\n-    public enum Wrapper {\n-        \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray\n-        BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0]),\n-        INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0]),\n-        DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0])\n-        ;\n-\n-        public static final int COUNT = 10;\n-        private static final Object DOUBLE_ZERO = (Double)(double)0;\n-\n-        private final Class<?> wrapperType;\n-        private final Class<?> primitiveType;\n-        private final char     basicTypeChar;\n-        private final String   basicTypeString;\n-        private final Object   emptyArray;\n-\n-        Wrapper(Class<?> wtype,\n-                String wtypeName,\n-                Class<?> ptype,\n-                String ptypeName,\n-                char tchar,\n-                Object emptyArray) {\n-            this.wrapperType = wtype;\n-            this.primitiveType = ptype;\n-            this.basicTypeChar = tchar;\n-            this.basicTypeString = String.valueOf(this.basicTypeChar);\n-            this.emptyArray = emptyArray;\n-        }\n-\n-        public Object zero() {\n-            return switch (this) {\n-                case BOOLEAN -> Boolean.FALSE;\n-                case INT -> (Integer)0;\n-                case DOUBLE -> DOUBLE_ZERO;\n-                default -> null;\n-            };\n-        }\n-    }\n-\n-    enum MyEnum {\n-        DUMMY1,\n-        DUMMY2;\n-\n-        static final boolean BOOLEAN = true;\n-        static final byte    BYTE    = -128;\n-        static final short   SHORT   = -12345;\n-        static final char    CHAR    = 'c';\n-        static final int     INT     = -123456;\n-        static final long    LONG    =  0x1234567890L;\n-        static final long    LONG2   = -0x1234567890L;\n-        static final float   FLOAT   = 567891.0f;\n-        static final double  DOUBLE  = 12345678905678.890;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java","additions":1,"deletions":155,"binary":false,"changes":156,"status":"modified"}]}