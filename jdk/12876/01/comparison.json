{"files":[{"patch":"@@ -1332,4 +1332,3 @@\n-    ResourceBitMap live = block->live_out();\n-    int size = (int)live.size();\n-    for (int number = (int)live.get_next_one_offset(0, size); number < size; number = (int)live.get_next_one_offset(number + 1, size)) {\n-      assert(live.at(number), \"should not stop here otherwise\");\n+    ResourceBitMap& live = block->live_out();\n+    auto updater = [&](BitMap::idx_t index) {\n+      int number = static_cast<int>(index);\n@@ -1350,1 +1349,2 @@\n-    }\n+    };\n+    live.iterate(updater);\n@@ -1741,3 +1741,0 @@\n-  const int size = live_set_size();\n-  const ResourceBitMap live_at_edge = to_block->live_in();\n-\n@@ -1745,1 +1742,3 @@\n-  for (int r = (int)live_at_edge.get_next_one_offset(0, size); r < size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {\n+  const ResourceBitMap& live_at_edge = to_block->live_in();\n+  auto visitor = [&](BitMap::idx_t index) {\n+    int r = static_cast<int>(index);\n@@ -1756,1 +1755,2 @@\n-  }\n+  };\n+  live_at_edge.iterate(visitor, 0, live_set_size());\n@@ -1916,2 +1916,2 @@\n-  int size = live_set_size();\n-  for (int r = (int)block->live_in().get_next_one_offset(0, size); r < size; r = (int)block->live_in().get_next_one_offset(r + 1, size)) {\n+  auto resolver = [&](BitMap::idx_t index) {\n+    int r = static_cast<int>(index);\n@@ -1919,1 +1919,2 @@\n-  }\n+  };\n+  block->live_in().iterate(resolver, 0, live_set_size());\n@@ -1989,2 +1990,2 @@\n-  int size = live_set_size();\n-  for (int r = (int)block->live_in().get_next_one_offset(0, size); r < size; r = (int)block->live_in().get_next_one_offset(r + 1, size)) {\n+  auto resolver = [&](BitMap::idx_t index) {\n+    int r = static_cast<int>(index);\n@@ -1992,1 +1993,2 @@\n-  }\n+  };\n+  block->live_in().iterate(resolver, 0, live_set_size());\n@@ -3469,1 +3471,1 @@\n-    ResourceBitMap live_at_edge = block->live_in();\n+    ResourceBitMap& live_at_edge = block->live_in();\n@@ -3472,1 +3474,2 @@\n-    for (int r = (int)live_at_edge.get_next_one_offset(0, size); r < size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {\n+    auto visitor = [&](BitMap::idx_t index) {\n+      int r = static_cast<int>(index);\n@@ -3481,1 +3484,2 @@\n-    }\n+    };\n+    live_at_edge.iterate(visitor, 0, size);\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -252,5 +252,1 @@\n-  BitMap::idx_t idx = bm.get_next_one_offset(0);\n-  while (idx != size_in_bits) {\n-    found((offset | (uint)idx));\n-    idx = bm.get_next_one_offset(idx + 1);\n-  }\n+  bm.iterate([&](BitMap::idx_t idx) { found(offset | (uint)idx); });\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,0 +108,2 @@\n+  template<typename ReturnType> struct IterateInvoker;\n+\n@@ -255,13 +257,32 @@\n-  \/\/ Iteration support.  Applies the closure to the index for each set bit,\n-  \/\/ starting from the least index in the range to the greatest, in order.\n-  \/\/ The iteration terminates if the closure returns false.  Returns true if\n-  \/\/ the iteration completed, false if terminated early because the closure\n-  \/\/ returned false.  If the closure modifies the bitmap, modifications to\n-  \/\/ bits at indices greater than the current index will affect which further\n-  \/\/ indices the closure will be applied to.\n-  \/\/ precondition: beg and end form a valid range.\n-  template <class BitMapClosureType>\n-  bool iterate(BitMapClosureType* cl, idx_t beg, idx_t end);\n-\n-  template <class BitMapClosureType>\n-  bool iterate(BitMapClosureType* cl);\n+  \/\/ Applies an operation to the index of each set bit in [beg, end), in\n+  \/\/ increasing order.\n+  \/\/\n+  \/\/ If i is an index of the bitmap, the operation is either\n+  \/\/ - function(i)\n+  \/\/ - cl->do_bit(i)\n+  \/\/ The result of an operation must be either void or convertible to bool.\n+  \/\/\n+  \/\/ If an operation returns false then the iteration stops at that index.\n+  \/\/ The result of the iteration is true unless the iteration was stopped by\n+  \/\/ an operation returning false.\n+  \/\/\n+  \/\/ If an operation modifies the bitmap, modifications to bits at indices\n+  \/\/ greater than the current index will affect which further indices the\n+  \/\/ operation will be applied to.\n+  \/\/\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  template<typename Function>\n+  bool iterate(Function function, idx_t beg, idx_t end) const;\n+\n+  template<typename BitMapClosureType>\n+  bool iterate(BitMapClosureType* cl, idx_t beg, idx_t end) const;\n+\n+  template<typename Function>\n+  bool iterate(Function function) const {\n+    return iterate(function, 0, size());\n+  }\n+\n+  template<typename BitMapClosureType>\n+  bool iterate(BitMapClosureType* cl) const {\n+    return iterate(cl, 0, size());\n+  }\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":34,"deletions":13,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -246,2 +246,19 @@\n-template <typename BitMapClosureType>\n-inline bool BitMap::iterate(BitMapClosureType* cl, idx_t beg, idx_t end) {\n+template<typename ReturnType>\n+struct BitMap::IterateInvoker {\n+  template<typename Function>\n+  ReturnType operator()(Function function, idx_t index) const {\n+    return function(index);\n+  }\n+};\n+\n+template<>\n+struct BitMap::IterateInvoker<void> {\n+  template<typename Function>\n+  bool operator()(Function function, idx_t index) const {\n+    function(index);\n+    return true;\n+  }\n+};\n+\n+template <typename Function>\n+inline bool BitMap::iterate(Function function, idx_t beg, idx_t end) const {\n@@ -252,1 +269,1 @@\n-    } else if (!cl->do_bit(index)) {\n+    } else if (!IterateInvoker<decltype(function(index))>()(function, index)) {\n@@ -259,2 +276,3 @@\n-inline bool BitMap::iterate(BitMapClosureType* cl) {\n-  return iterate(cl, 0, size());\n+inline bool BitMap::iterate(BitMapClosureType* cl, idx_t beg, idx_t end) const {\n+  auto function = [&](idx_t index) { return cl->do_bit(index); };\n+  return iterate(function, beg, end);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"unittest.hpp\"\n+\n+using idx_t = BitMap::idx_t;\n+using bm_word_t = BitMap::bm_word_t;\n+\n+static const idx_t BITMAP_SIZE = 1024;\n+static const idx_t BITMAP_WORD_SIZE = align_up(BITMAP_SIZE, BitsPerWord) \/ BitsPerWord;\n+\n+\n+static void test_iterate_step(const BitMap& map,\n+                              idx_t index,\n+                              const idx_t* positions,\n+                              size_t positions_index,\n+                              size_t positions_size) {\n+  ASSERT_LT(positions_index, positions_size);\n+  ASSERT_EQ(index, positions[positions_index]);\n+  ASSERT_TRUE(map.at(index));\n+}\n+\n+\/\/ Test lambda returning void.\n+static void test_iterate_lambda(const BitMap& map,\n+                                const idx_t* positions,\n+                                size_t positions_size) {\n+  SCOPED_TRACE(\"iterate with lambda\");\n+  size_t positions_index = 0;\n+  auto f = [&](idx_t i) {\n+    test_iterate_step(map, i, positions, positions_index++, positions_size);\n+  };\n+  ASSERT_TRUE(map.iterate(f));\n+  ASSERT_EQ(positions_index, positions_size);\n+}\n+\n+\/\/ Test closure returning bool.  Also tests lambda returning bool.\n+static void test_iterate_closure(const BitMap& map,\n+                                 const idx_t* positions,\n+                                 size_t positions_size) {\n+  SCOPED_TRACE(\"iterate with BitMapClosure\");\n+  struct Closure : public BitMapClosure {\n+    const BitMap& _map;\n+    const idx_t* _positions;\n+    size_t _positions_index;\n+    size_t _positions_size;\n+\n+    Closure(const BitMap& map, const idx_t* positions, size_t positions_size)\n+      : _map(map),\n+        _positions(positions),\n+        _positions_index(0),\n+        _positions_size(positions_size)\n+    {}\n+\n+    bool do_bit(idx_t i) override {\n+      test_iterate_step(_map, i, _positions, _positions_index++, _positions_size);\n+      return true;\n+    }\n+  } closure{map, positions, positions_size};\n+  ASSERT_TRUE(map.iterate(&closure));\n+  ASSERT_EQ(closure._positions_index, positions_size);\n+}\n+\n+\/\/ Test closure returning void.  Also tests lambda returning bool.\n+static void test_iterate_non_closure(const BitMap& map,\n+                                     const idx_t* positions,\n+                                     size_t positions_size) {\n+  SCOPED_TRACE(\"iterate with non-BitMapClosure\");\n+  struct Closure {\n+    const BitMap& _map;\n+    const idx_t* _positions;\n+    size_t _positions_index;\n+    size_t _positions_size;\n+\n+    Closure(const BitMap& map, const idx_t* positions, size_t positions_size)\n+      : _map(map),\n+        _positions(positions),\n+        _positions_index(0),\n+        _positions_size(positions_size)\n+    {}\n+\n+    void do_bit(idx_t i) {\n+      test_iterate_step(_map, i, _positions, _positions_index++, _positions_size);\n+    }\n+  } closure{map, positions, positions_size};\n+  ASSERT_TRUE(map.iterate(&closure));\n+  ASSERT_EQ(closure._positions_index, positions_size);\n+}\n+\n+static void fill_iterate_map(BitMap& map,\n+                             const idx_t* positions,\n+                             size_t positions_size) {\n+  map.clear_range(0, map.size());\n+  for (size_t i = 0; i < positions_size; ++i) {\n+    map.set_bit(positions[i]);\n+  }\n+}\n+\n+static void test_iterate(BitMap& map,\n+                         const idx_t* positions,\n+                         size_t positions_size) {\n+  fill_iterate_map(map, positions, positions_size);\n+  test_iterate_lambda(map, positions, positions_size);\n+  test_iterate_closure(map, positions, positions_size);\n+  test_iterate_non_closure(map, positions, positions_size);\n+}\n+\n+TEST(BitMap, iterate_empty) {\n+  bm_word_t test_data[BITMAP_WORD_SIZE];\n+  BitMapView test_map{test_data, BITMAP_SIZE};\n+  idx_t positions[1] = {};\n+  test_iterate(test_map, positions, 0);\n+}\n+\n+TEST(BitMap, iterate_with_endpoints) {\n+  bm_word_t test_data[BITMAP_WORD_SIZE];\n+  BitMapView test_map{test_data, BITMAP_SIZE};\n+  idx_t positions[] = { 0, 2, 6, 31, 61, 131, 247, 578, BITMAP_SIZE - 1 };\n+  test_iterate(test_map, positions, ARRAY_SIZE(positions));\n+}\n+\n+TEST(BitMap, iterate_without_endpoints) {\n+  bm_word_t test_data[BITMAP_WORD_SIZE];\n+  BitMapView test_map{test_data, BITMAP_SIZE};\n+  idx_t positions[] = { 1, 2, 6, 31, 61, 131, 247, 578, BITMAP_SIZE - 2 };\n+  test_iterate(test_map, positions, ARRAY_SIZE(positions));\n+}\n+\n+TEST(BitMap, iterate_full) {\n+  bm_word_t test_data[BITMAP_WORD_SIZE];\n+  BitMapView test_map{test_data, BITMAP_SIZE};\n+  static idx_t positions[BITMAP_SIZE]; \/\/ static to avoid large stack allocation.\n+  for (idx_t i = 0; i < BITMAP_SIZE; ++i) {\n+    positions[i] = i;\n+  }\n+  test_iterate(test_map, positions, ARRAY_SIZE(positions));\n+}\n+\n+TEST(BitMap, iterate_early_termination) {\n+  bm_word_t test_data[BITMAP_WORD_SIZE];\n+  BitMapView test_map{test_data, BITMAP_SIZE};\n+  idx_t positions[] = { 1, 2, 6, 31, 61, 131, 247, 578, BITMAP_SIZE - 2 };\n+  size_t positions_size = ARRAY_SIZE(positions);\n+  size_t positions_index = 0;\n+  fill_iterate_map(test_map, positions, positions_size);\n+  idx_t stop_at = 131;\n+  auto f = [&](idx_t i) {\n+    test_iterate_step(test_map, i, positions, positions_index, positions_size);\n+    if (positions[positions_index] == stop_at) {\n+      return false;\n+    } else {\n+      positions_index += 1;\n+      return true;\n+    }\n+  };\n+  ASSERT_FALSE(test_map.iterate(f));\n+  ASSERT_LT(positions_index, positions_size);\n+  ASSERT_EQ(positions[positions_index], stop_at);\n+\n+  struct Closure : public BitMapClosure {\n+    const BitMap& _map;\n+    const idx_t* _positions;\n+    size_t _positions_index;\n+    size_t _positions_size;\n+    idx_t _stop_at;\n+\n+    Closure(const BitMap& map, const idx_t* positions, size_t positions_size, idx_t stop_at)\n+      : _map(map),\n+        _positions(positions),\n+        _positions_index(0),\n+        _positions_size(positions_size),\n+        _stop_at(stop_at)\n+    {}\n+\n+    bool do_bit(idx_t i) override {\n+      test_iterate_step(_map, i, _positions, _positions_index, _positions_size);\n+      if (_positions[_positions_index] == _stop_at) {\n+        return false;\n+      } else {\n+        _positions_index += 1;\n+        return true;\n+      }\n+    }\n+  } closure{test_map, positions, positions_size, stop_at};\n+  ASSERT_FALSE(test_map.iterate(&closure));\n+  ASSERT_LT(closure._positions_index, positions_size);\n+  ASSERT_EQ(positions[closure._positions_index], stop_at);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap_iterate.cpp","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"}]}