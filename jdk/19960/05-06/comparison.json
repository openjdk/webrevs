{"files":[{"patch":"@@ -2279,13 +2279,1 @@\n-  void generate_rev8_pack2(const VectorRegister vtmp1, const VectorRegister vtmp2) {\n-    __ vrev8_v(vtmp1, vtmp1);\n-    __ vrev8_v(vtmp2, vtmp2);\n-  }\n-\n-  void generate_rev8_pack4(const VectorRegister vtmp1, const VectorRegister vtmp2,\n-                           const VectorRegister vtmp3, const VectorRegister vtmp4) {\n-    generate_rev8_pack2(vtmp1, vtmp2);\n-    generate_rev8_pack2(vtmp3, vtmp4);\n-  }\n-\n-  void generate_vle32_pack2(const Register key, const VectorRegister vtmp1,\n-                            const VectorRegister vtmp2) {\n+  void generate_aes_loadkeys(const Register &key, VectorRegister *working_vregs, int reg_number) {\n@@ -2293,4 +2281,5 @@\n-    __ vle32_v(vtmp1, key);\n-    __ addi(key, key, step);\n-    __ vle32_v(vtmp2, key);\n-    __ addi(key, key, step);\n+    for (int i = 0; i < reg_number; i++) {\n+      __ vle32_v(working_vregs[i], key);\n+      __ vrev8_v(working_vregs[i], working_vregs[i]);\n+      __ addi(key, key, step);\n+    }\n@@ -2299,5 +2288,8 @@\n-  void generate_vle32_pack4(const Register key, const VectorRegister vtmp1,\n-                            const VectorRegister vtmp2, const VectorRegister vtmp3,\n-                            const VectorRegister vtmp4) {\n-    generate_vle32_pack2(key, vtmp1, vtmp2);\n-    generate_vle32_pack2(key, vtmp3, vtmp4);\n+  void generate_aes_encrypt(const VectorRegister &res, VectorRegister *working_vregs, int reg_number) {\n+    assert(reg_number <= 15, \"reg_number should be less than or equal to working_vregs size\")\n+\n+    __ vxor_vv(res, res, working_vregs[0]);\n+    for (int i = 1; i < reg_number; i++) {\n+      __ vaesem_vv(res, working_vregs[i]);\n+    }\n+    __ vaesef_vv(res, working_vregs[reg_number]);\n@@ -2319,1 +2311,1 @@\n-    Label L_do44, L_do52, L_end;\n+    Label L_do44, L_do52;\n@@ -2326,1 +2318,0 @@\n-    const VectorRegister res   = v19;\n@@ -2331,2 +2322,1 @@\n-\n-    const VectorRegister vzero = v17;\n+    const VectorRegister res   = v19;\n@@ -2347,12 +2337,7 @@\n-    for (int i = 0; i < 15; i++) {\n-      __ vle32_v(working_vregs[i], key);\n-      __ vrev8_v(working_vregs[i], working_vregs[i]);\n-      __ addi(key, key, 16);\n-    }\n-\n-    __ vxor_vv(res, res, working_vregs[0]);\n-    for (int i = 1; i < 14; i++) {\n-      __ vaesem_vv(res, working_vregs[i]);\n-    }\n-    __ vaesef_vv(res, working_vregs[14]);\n-    __ j(L_end);\n+    \/\/ Note: the following function performs key += 15*16\n+    generate_aes_loadkeys(key, working_vregs, 15);\n+    generate_aes_encrypt(res, working_vregs, 14);\n+    __ vse32_v(res, to);\n+    __ mv(c_rarg0, 0);\n+    __ leave();\n+    __ ret();\n@@ -2361,12 +2346,7 @@\n-    for (int i = 0; i < 13; i++) {\n-      __ vle32_v(working_vregs[i], key);\n-      __ vrev8_v(working_vregs[i], working_vregs[i]);\n-      __ addi(key, key, 16);\n-    }\n-\n-    __ vxor_vv(res, res, working_vregs[0]);\n-    for (int i = 1; i < 12; i++) {\n-      __ vaesem_vv(res, working_vregs[i]);\n-    }\n-    __ vaesef_vv(res, working_vregs[12]);\n-    __ j(L_end);\n+    \/\/ Note: the following function performs key += 13*16\n+    generate_aes_loadkeys(key, working_vregs, 13);\n+    generate_aes_encrypt(res, working_vregs, 12);\n+    __ vse32_v(res, to);\n+    __ mv(c_rarg0, 0);\n+    __ leave();\n+    __ ret();\n@@ -2375,13 +2355,3 @@\n-    for (int i = 0; i < 11; i++) {\n-      __ vle32_v(working_vregs[i], key);\n-      __ vrev8_v(working_vregs[i], working_vregs[i]);\n-      __ addi(key, key, 16);\n-    }\n-\n-    __ vxor_vv(res, res, working_vregs[0]);\n-    for (int i = 1; i < 10; i++) {\n-      __ vaesem_vv(res, working_vregs[i]);\n-    }\n-    __ vaesef_vv(res, working_vregs[10]);\n-\n-  __ bind(L_end);\n+    \/\/ Note: the following function performs key += 11*16\n+    generate_aes_loadkeys(key, working_vregs, 11);\n+    generate_aes_encrypt(res, working_vregs, 10);\n@@ -2396,11 +2366,10 @@\n-  void generate_aesdecrypt_round(const VectorRegister res, const VectorRegister vzero,\n-                                 const VectorRegister vtmp1, const VectorRegister vtmp2,\n-                                 const VectorRegister vtmp3, const VectorRegister vtmp4) {\n-    __ vxor_vv(res, res, vtmp1);\n-    __ vaesdm_vv(res, vzero);\n-    __ vxor_vv(res, res, vtmp2);\n-    __ vaesdm_vv(res, vzero);\n-    __ vxor_vv(res, res, vtmp3);\n-    __ vaesdm_vv(res, vzero);\n-    __ vxor_vv(res, res, vtmp4);\n-    __ vaesdm_vv(res, vzero);\n+  void generate_aes_decrypt(const VectorRegister &res, const VectorRegister &vzero,\n+    const VectorRegister &vtemp, VectorRegister *working_vregs, int reg_number) {\n+    assert(reg_number <= 14, \"reg_number should be less than or equal to working_vregs size\");\n+\n+    for (int i = 0; i < reg_number; i++) {\n+      __ vxor_vv(res, res, working_vregs[i]);\n+      __ vaesdm_vv(res, vzero);\n+    }\n+    __ vxor_vv(res, res, working_vregs[reg_number]);\n+    __ vaesdf_vv(res, vtemp);\n@@ -2421,1 +2390,2 @@\n-    Label L_doLast;\n+\n+    Label L_do44, L_do52;\n@@ -2428,8 +2398,7 @@\n-    const VectorRegister res   = v16;\n-    const VectorRegister vtmp1 = v4;\n-    const VectorRegister vtmp2 = v5;\n-    const VectorRegister vtmp3 = v6;\n-    const VectorRegister vtmp4 = v7;\n-\n-    const VectorRegister vzero = v17;\n-    const VectorRegister vtemp = v18;\n+    VectorRegister working_vregs[] = {\n+      v4, v5, v6, v7, v8, v9, v10, v11,\n+      v12, v13, v14, v15, v16, v17\n+    };\n+    const VectorRegister res   = v18;\n+    const VectorRegister vzero = v19;\n+    const VectorRegister vtemp = v20;\n@@ -2447,3 +2416,0 @@\n-    \/\/ Note: the following function performs key += 4*16\n-    generate_vle32_pack4(key, vtmp1, vtmp2, vtmp3, vtmp4);\n-\n@@ -2451,23 +2417,0 @@\n-    generate_rev8_pack4(vtmp1, vtmp2, vtmp3, vtmp4);\n-    generate_aesdecrypt_round(res, vzero, vtmp1, vtmp2, vtmp3, vtmp4);\n-\n-    \/\/ Note: the following function performs key += 4*16\n-    generate_vle32_pack4(key, vtmp1, vtmp2, vtmp3, vtmp4);\n-    generate_rev8_pack4(vtmp1, vtmp2, vtmp3, vtmp4);\n-    generate_aesdecrypt_round(res, vzero, vtmp1, vtmp2, vtmp3, vtmp4);\n-\n-    \/\/ Note: the following function performs key += 2*16\n-    generate_vle32_pack2(key, vtmp1, vtmp2);\n-    generate_rev8_pack2(vtmp1, vtmp2);\n-\n-    __ mv(t2, 44);\n-    __ beq(keylen, t2, L_doLast);\n-\n-    __ vxor_vv(res, res, vtmp1);\n-    __ vaesdm_vv(res, vzero);\n-    __ vxor_vv(res, res, vtmp2);\n-    __ vaesdm_vv(res, vzero);\n-\n-    \/\/ Note: the following function performs key += 2*16\n-    generate_vle32_pack2(key, vtmp1, vtmp2);\n-    generate_rev8_pack2(vtmp1, vtmp2);\n@@ -2476,6 +2419,3 @@\n-    __ beq(keylen, t2, L_doLast);\n-\n-    __ vxor_vv(res, res, vtmp1);\n-    __ vaesdm_vv(res, vzero);\n-    __ vxor_vv(res, res, vtmp2);\n-    __ vaesdm_vv(res, vzero);\n+    __ blt(keylen, t2, L_do44);\n+    __ beq(keylen, t2, L_do52);\n+    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n@@ -2483,3 +2423,3 @@\n-    \/\/ Note: the following function performs key += 2*16\n-    generate_vle32_pack2(key, vtmp1, vtmp2);\n-    generate_rev8_pack2(vtmp1, vtmp2);\n+    \/\/ Note: the following function performs key += 14*16\n+    generate_aes_loadkeys(key, working_vregs, 14);\n+    generate_aes_decrypt(res, vzero, vtemp, working_vregs, 13);\n@@ -2487,1 +2427,4 @@\n-    __ bind(L_doLast);\n+    __ vse32_v(res, to);\n+    __ mv(c_rarg0, 0);\n+    __ leave();\n+    __ ret();\n@@ -2489,4 +2432,4 @@\n-    __ vxor_vv(res, res, vtmp1);\n-    __ vaesdm_vv(res, vzero);\n-    __ vxor_vv(res, res, vtmp2);\n-    __ vaesdf_vv(res, vtemp);\n+  __ bind(L_do52);\n+    \/\/ Note: the following function performs key += 12*16\n+    generate_aes_loadkeys(key, working_vregs, 12);\n+    generate_aes_decrypt(res, vzero, vtemp, working_vregs, 11);\n@@ -2496,0 +2439,2 @@\n+    __ leave();\n+    __ ret();\n@@ -2497,0 +2442,7 @@\n+  __ bind(L_do44);\n+    \/\/ Note: the following function performs key += 10*16\n+    generate_aes_loadkeys(key, working_vregs, 10);\n+    generate_aes_decrypt(res, vzero, vtemp, working_vregs, 9);\n+\n+    __ vse32_v(res, to);\n+    __ mv(c_rarg0, 0);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":75,"deletions":123,"binary":false,"changes":198,"status":"modified"}]}