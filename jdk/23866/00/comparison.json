{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,9 +503,9 @@\n-            if (e == null) {\n-                \/\/ Uninitialized, and no pending calls to computeValue.  No change.\n-            } else if (e.isPromise()) {\n-                \/\/ State is uninitialized, with a pending call to finishEntry.\n-                \/\/ Since remove is a no-op in such a state, keep the promise\n-                \/\/ by putting it back into the map.\n-                put(classValue.identity, e);\n-            } else {\n-                \/\/ In an initialized state.  Bump forward, and de-initialize.\n+            \/\/ e == null: Uninitialized, and no pending calls to computeValue.\n+            \/\/ remove didn't change anything.  No change.\n+            \/\/ e.isPromise(): computeValue already used outdated values.\n+            \/\/ remove discarded the outdated computation promise.\n+            \/\/ finishEntry will retry when it discovers the promise is gone.\n+            \/\/ No cache invalidation.  No further action needed.\n+            if (e != null && !e.isPromise()) {\n+                \/\/ Initialized.\n+                \/\/ Bump forward to invalidate racy-read cached entries.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,3 @@\n-\/* @test\n+\/*\n+ * @test\n+ * @bug 8351045\n@@ -26,2 +28,1 @@\n- * @compile ClassValueTest.java\n- * @run testng\/othervm test.java.lang.invoke.ClassValueTest\n+ * @run junit ClassValueTest\n@@ -30,1 +31,7 @@\n-package test.java.lang.invoke;\n+import java.util.ArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.jupiter.api.Test;\n@@ -32,3 +39,1 @@\n-import org.testng.*;\n-import static org.testng.AssertJUnit.*;\n-import org.testng.annotations.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -39,1 +44,1 @@\n-public class ClassValueTest {\n+final class ClassValueTest {\n@@ -146,1 +151,1 @@\n-        assertEquals(countForCVN, 0);\n+        assertEquals(0, countForCVN);\n@@ -155,0 +160,53 @@\n+\n+    private static final int RUNS = 16;\n+    private static final long COMPUTE_TIME_MILLIS = 100;\n+\n+    @Test\n+    void testRemoveOnComputeCases() {\n+        try (var exec = Executors.newVirtualThreadPerTaskExecutor()) {\n+            var tasks = new ArrayList<Future<?>>(RUNS);\n+            for (int i = 0; i < RUNS; i++) {\n+                tasks.add(exec.submit(this::testRemoveOnCompute));\n+            }\n+            for (var task : tasks) {\n+                try {\n+                    task.get();\n+                } catch (InterruptedException | ExecutionException ex) {\n+                    var cause = ex.getCause();\n+                    if (cause instanceof AssertionError ae)\n+                        throw ae;\n+                    throw new RuntimeException(ex);\n+                }\n+            }\n+        }\n+    }\n+\n+    void testRemoveOnCompute() {\n+        AtomicInteger input = new AtomicInteger(0);\n+        ClassValue<Integer> cv = new ClassValue<>() {\n+            @Override\n+            protected Integer computeValue(Class<?> type) {\n+                \/\/ must get early to represent using outdated input\n+                int v = input.get();\n+                try {\n+                    Thread.sleep(COMPUTE_TIME_MILLIS);\n+                } catch (InterruptedException ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+                return v;\n+            }\n+        };\n+        var innocuous = Thread.startVirtualThread(() -> cv.get(int.class));\n+        var refreshInput = Thread.startVirtualThread(() -> {\n+            input.incrementAndGet();\n+            cv.remove(int.class); \/\/ Let's recompute with updated inputs!\n+        });\n+        try {\n+            innocuous.join();\n+            refreshInput.join();\n+        } catch (InterruptedException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+        assertEquals(1, input.get(), \"input not updated\");\n+        assertEquals(1, cv.get(int.class), \"CV not using up-to-date input\");\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":68,"deletions":10,"binary":false,"changes":78,"status":"modified"}]}