{"files":[{"patch":"@@ -1686,2 +1686,2 @@\n-  register_new_node(pre_limit, pre_head->in(0));\n-  register_new_node(pre_opaq , pre_head->in(0));\n+  register_new_node(pre_limit, pre_head->in(LoopNode::EntryControl));\n+  register_new_node(pre_opaq , pre_head->in(LoopNode::EntryControl));\n@@ -2793,0 +2793,1 @@\n+  Node* main_limit_ctrl = get_ctrl(main_limit);\n@@ -2825,0 +2826,1 @@\n+  Node* pre_limit_ctrl = get_ctrl(pre_limit);\n@@ -2827,1 +2829,6 @@\n-  Node *pre_ctrl = pre_end->loopnode()->in(LoopNode::EntryControl);\n+  Node* pre_ctrl = pre_end->loopnode()->in(LoopNode::EntryControl);\n+  \/\/ Range check elimination optimizes out conditions whose parameters are loop invariant in the main loop. They usually\n+  \/\/ have control above the pre loop, but there's no guarantee that they do. There's no guarantee either that the pre\n+  \/\/ loop limit has control that's out of loop (a previous round of range check elimination could have set a limit that's\n+  \/\/ not loop invariant).\n+  Node* new_limit_ctrl = dominated_node(pre_ctrl, pre_limit_ctrl);\n@@ -2887,2 +2894,2 @@\n-      Node *limit_c = get_ctrl(limit);\n-      if (loop->is_member(get_loop(limit_c))) {\n+      Node *limit_ctrl = get_ctrl(limit);\n+      if (loop->is_member(get_loop(limit_ctrl))) {\n@@ -2893,2 +2900,2 @@\n-        limit_c = get_ctrl(limit);\n-        if (loop->is_member(get_loop(limit_c))) {\n+        limit_ctrl = get_ctrl(limit);\n+        if (loop->is_member(get_loop(limit_ctrl))) {\n@@ -2903,1 +2910,1 @@\n-      if (is_dominator(ctrl, limit_c)) {\n+      if (is_dominator(ctrl, limit_ctrl)) {\n@@ -2907,1 +2914,1 @@\n-      assert(is_dominator(compute_early_ctrl(limit, limit_c), pre_end), \"node pinned on loop exit test?\");\n+      assert(is_dominator(compute_early_ctrl(limit, limit_ctrl), pre_end), \"node pinned on loop exit test?\");\n@@ -2916,2 +2923,2 @@\n-      Node *offset_c = get_ctrl(offset);\n-      if (loop->is_member(get_loop(offset_c))) {\n+      Node *offset_ctrl = get_ctrl(offset);\n+      if (loop->is_member(get_loop(offset_ctrl))) {\n@@ -2924,1 +2931,1 @@\n-      if (is_dominator(ctrl, offset_c)) {\n+      if (is_dominator(ctrl, offset_ctrl)) {\n@@ -2928,1 +2935,8 @@\n-      assert(is_dominator(compute_early_ctrl(offset, offset_c), pre_end), \"node pinned on loop exit test?\");\n+      \/\/ offset and limit can have control set below the pre loop when they are not loop invariant in the pre loop.\n+      \/\/ Update their control (and the control of inputs as needed) to be above pre_end\n+      offset_ctrl = ensure_node_and_inputs_are_above_pre_end(pre_end, offset);\n+      limit_ctrl = ensure_node_and_inputs_are_above_pre_end(pre_end, limit);\n+\n+      \/\/ offset and limit could have control below new_limit_ctrl if they are not loop invariant in the pre loop.\n+      new_limit_ctrl = dominated_node(new_limit_ctrl, offset_ctrl, limit_ctrl);\n+\n@@ -2948,1 +2962,1 @@\n-      register_new_node(offset, pre_ctrl);\n+      register_new_node(offset, new_limit_ctrl);\n@@ -2951,1 +2965,1 @@\n-      register_new_node(limit, pre_ctrl);\n+      register_new_node(limit, new_limit_ctrl);\n@@ -2957,1 +2971,1 @@\n-          add_constraint(stride_con, lscale_con, offset, zero, limit, pre_ctrl, &pre_limit, &main_limit);\n+          add_constraint(stride_con, lscale_con, offset, zero, limit, new_limit_ctrl, &pre_limit, &main_limit);\n@@ -3016,1 +3030,1 @@\n-          register_new_node(offset, pre_ctrl);\n+          register_new_node(offset, new_limit_ctrl);\n@@ -3018,1 +3032,1 @@\n-          register_new_node(limit, pre_ctrl);\n+          register_new_node(limit, new_limit_ctrl);\n@@ -3024,1 +3038,1 @@\n-            register_new_node(limit, pre_ctrl);\n+            register_new_node(limit, new_limit_ctrl);\n@@ -3031,1 +3045,1 @@\n-          add_constraint(stride_con, lscale_con, offset, mini, limit, pre_ctrl, &pre_limit, &main_limit);\n+          add_constraint(stride_con, lscale_con, offset, mini, limit, new_limit_ctrl, &pre_limit, &main_limit);\n@@ -3075,1 +3089,1 @@\n-    register_new_node(pre_limit, pre_ctrl);\n+    register_new_node(pre_limit, new_limit_ctrl);\n@@ -3077,0 +3091,6 @@\n+  \/\/ new pre_limit can push Bool\/Cmp\/Opaque nodes down (when one of the eliminated condition has parameters that are not\n+  \/\/ loop invariant in the pre loop.\n+  set_ctrl(pre_opaq, new_limit_ctrl);\n+  set_ctrl(pre_end->cmp_node(), new_limit_ctrl);\n+  set_ctrl(pre_end->in(1), new_limit_ctrl);\n+\n@@ -3096,1 +3116,1 @@\n-  assert(main_limit == cl->limit() || get_ctrl(main_limit) == pre_ctrl, \"wrong control for added limit\");\n+  assert(main_limit == cl->limit() || get_ctrl(main_limit) == new_limit_ctrl, \"wrong control for added limit\");\n@@ -3104,1 +3124,1 @@\n-  register_new_node(main_limit, pre_ctrl);\n+  register_new_node(main_limit, new_limit_ctrl);\n@@ -3115,0 +3135,31 @@\n+  \/\/ new main_limit can push Bool\/Cmp nodes down (when one of the eliminated condition has parameters that are not loop\n+  \/\/ invariant in the pre loop.\n+  set_ctrl(opqzm, new_limit_ctrl);\n+  set_ctrl(iffm->in(1)->in(1), new_limit_ctrl);\n+  set_ctrl(iffm->in(1), new_limit_ctrl);\n+}\n+\n+\/\/ Adjust control for node and its inputs (and inputs of its inputs) to be above the pre end\n+Node* PhaseIdealLoop::ensure_node_and_inputs_are_above_pre_end(CountedLoopEndNode* pre_end, Node* node) {\n+  Node* control = get_ctrl(node);\n+  assert(is_dominator(compute_early_ctrl(node, control), pre_end), \"node pinned on loop exit test?\");\n+\n+  if (is_dominator(control, pre_end)) {\n+    return control;\n+  }\n+  control = pre_end->in(0);\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(node);\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* n = wq.at(i);\n+    assert(is_dominator(compute_early_ctrl(n, get_ctrl(n)), pre_end), \"node pinned on loop exit test?\");\n+    set_ctrl(n, control);\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* in = n->in(j);\n+      if (in != nullptr && has_ctrl(in) && !is_dominator(get_ctrl(in), pre_end)) {\n+        wq.push(in);\n+      }\n+    }\n+  }\n+  return control;\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":74,"deletions":23,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1187,0 +1187,10 @@\n+  Node* dominated_node(Node* c1, Node* c2) {\n+    assert(is_dominator(c1, c2) || is_dominator(c2, c1), \"nodes must be related\");\n+    return is_dominator(c1, c2) ? c2 : c1;\n+  }\n+\n+  \/\/ Return control node that's dominated by the 2 others\n+  Node* dominated_node(Node* c1, Node* c2, Node* c3) {\n+    return dominated_node(c1, dominated_node(c2, c3));\n+  }\n+\n@@ -1787,0 +1797,2 @@\n+\n+  Node* ensure_node_and_inputs_are_above_pre_end(CountedLoopEndNode* pre_end, Node* node);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}