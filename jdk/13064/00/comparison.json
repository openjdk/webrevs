{"files":[{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantBootstraps;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static org.testng.Assert.assertSame;\n+\n+\/*\n+ * @test\n+ * @compile ConstantDescsTest.java\n+ * @run testng ConstantDescsTest\n+ * @summary unit tests for java.lang.constant.ConstantDescs\n+ *\/\n+public class ConstantDescsTest {\n+\n+    \/**\n+     * Checks that ConstantDescs descriptor fields resolve to the right\n+     * constants.\n+     * @throws ReflectiveOperationException if the test fails\n+     *\/\n+    @Test\n+    public void validateAllFields() throws ReflectiveOperationException {\n+        \/\/ Use a minimally-trusted lookup\n+        var lookup = MethodHandles.publicLookup();\n+\n+        assertSame(CD_Object.resolveConstantDesc(lookup), Object.class);\n+        assertSame(CD_String.resolveConstantDesc(lookup), String.class);\n+        assertSame(CD_Class.resolveConstantDesc(lookup), Class.class);\n+        assertSame(CD_Number.resolveConstantDesc(lookup), Number.class);\n+        assertSame(CD_Integer.resolveConstantDesc(lookup), Integer.class);\n+        assertSame(CD_Long.resolveConstantDesc(lookup), Long.class);\n+        assertSame(CD_Float.resolveConstantDesc(lookup), Float.class);\n+        assertSame(CD_Double.resolveConstantDesc(lookup), Double.class);\n+        assertSame(CD_Short.resolveConstantDesc(lookup), Short.class);\n+        assertSame(CD_Byte.resolveConstantDesc(lookup), Byte.class);\n+        assertSame(CD_Character.resolveConstantDesc(lookup), Character.class);\n+        assertSame(CD_Boolean.resolveConstantDesc(lookup), Boolean.class);\n+        assertSame(CD_Void.resolveConstantDesc(lookup), Void.class);\n+        assertSame(CD_Exception.resolveConstantDesc(lookup), Exception.class);\n+        assertSame(CD_Throwable.resolveConstantDesc(lookup), Throwable.class);\n+        assertSame(CD_Enum.resolveConstantDesc(lookup), Enum.class);\n+        assertSame(CD_VarHandle.resolveConstantDesc(lookup), VarHandle.class);\n+        assertSame(CD_MethodHandles.resolveConstantDesc(lookup), MethodHandles.class);\n+        assertSame(CD_MethodHandles_Lookup.resolveConstantDesc(lookup), MethodHandles.Lookup.class);\n+        assertSame(CD_MethodHandle.resolveConstantDesc(lookup), MethodHandle.class);\n+        assertSame(CD_MethodType.resolveConstantDesc(lookup), MethodType.class);\n+        assertSame(CD_CallSite.resolveConstantDesc(lookup), CallSite.class);\n+        assertSame(CD_Collection.resolveConstantDesc(lookup), Collection.class);\n+        assertSame(CD_List.resolveConstantDesc(lookup), List.class);\n+        assertSame(CD_Set.resolveConstantDesc(lookup), Set.class);\n+        assertSame(CD_Map.resolveConstantDesc(lookup), Map.class);\n+        assertSame(CD_ConstantDesc.resolveConstantDesc(lookup), ConstantDesc.class);\n+        assertSame(CD_ClassDesc.resolveConstantDesc(lookup), ClassDesc.class);\n+        assertSame(CD_EnumDesc.resolveConstantDesc(lookup), Enum.EnumDesc.class);\n+        assertSame(CD_MethodTypeDesc.resolveConstantDesc(lookup), MethodTypeDesc.class);\n+        assertSame(CD_MethodHandleDesc.resolveConstantDesc(lookup), MethodHandleDesc.class);\n+        assertSame(CD_DirectMethodHandleDesc.resolveConstantDesc(lookup), DirectMethodHandleDesc.class);\n+        assertSame(CD_VarHandleDesc.resolveConstantDesc(lookup), VarHandle.VarHandleDesc.class);\n+        assertSame(CD_MethodHandleDesc_Kind.resolveConstantDesc(lookup), DirectMethodHandleDesc.Kind.class);\n+        assertSame(CD_DynamicConstantDesc.resolveConstantDesc(lookup), DynamicConstantDesc.class);\n+        assertSame(CD_DynamicCallSiteDesc.resolveConstantDesc(lookup), DynamicCallSiteDesc.class);\n+        assertSame(CD_ConstantBootstraps.resolveConstantDesc(lookup), ConstantBootstraps.class);\n+        assertSame(CD_int.resolveConstantDesc(lookup), int.class);\n+        assertSame(CD_long.resolveConstantDesc(lookup), long.class);\n+        assertSame(CD_float.resolveConstantDesc(lookup), float.class);\n+        assertSame(CD_double.resolveConstantDesc(lookup), double.class);\n+        assertSame(CD_short.resolveConstantDesc(lookup), short.class);\n+        assertSame(CD_byte.resolveConstantDesc(lookup), byte.class);\n+        assertSame(CD_char.resolveConstantDesc(lookup), char.class);\n+        assertSame(CD_boolean.resolveConstantDesc(lookup), boolean.class);\n+        assertSame(CD_void.resolveConstantDesc(lookup), void.class);\n+        assertSame(NULL.resolveConstantDesc(lookup), null);\n+        assertSame(TRUE.resolveConstantDesc(lookup), Boolean.TRUE);\n+        assertSame(FALSE.resolveConstantDesc(lookup), Boolean.FALSE);\n+    }\n+\n+    \/**\n+     * Ensures all public static final descriptor fields in ConstantDescs\n+     * are resolvable.\n+     * @throws ReflectiveOperationException if the test fails\n+     *\/\n+    @Test\n+    public void checkFieldsResolvable() throws ReflectiveOperationException {\n+        \/\/ minimally trusted lookup\n+        var lookup = MethodHandles.publicLookup();\n+        var fields = Stream.of(ConstantDescs.class.getFields())\n+                .filter(f -> f.accessFlags().contains(AccessFlag.STATIC)\n+                        && ConstantDesc.class.isAssignableFrom(f.getType()))\n+                .toArray(Field[]::new);\n+        for (var field : fields) {\n+            var desc = (ConstantDesc) field.get(null);\n+            desc.resolveConstantDesc(lookup);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/constant\/ConstantDescsTest.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"}]}