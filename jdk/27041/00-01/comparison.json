{"files":[{"patch":"@@ -1672,1 +1672,2 @@\n-    \/\/   -XX:+UnlockExperimentalVMOptions -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    \/\/   -XX:+UnlockExperimentalVMOptions -XX:LockingMode=1 -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    \/\/   Note: The -XX:LockingMode option is not available anymore.\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-  \/\/ For lightweight locking\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -769,8 +769,7 @@\n-\/\/ ObjectMonitor* when lightweight locking is used. It is used from contexts\n-\/\/ which require an inflated ObjectMonitor* for a monitor, and expects to throw\n-\/\/ a java.lang.IllegalMonitorStateException if it is not held by the current\n-\/\/ thread. Such as notify\/wait and jni_exit. Lightweight locking keeps it invariant\n-\/\/ that it only inflates if it is already locked by the current thread or the\n-\/\/ current thread is in the process of entering. To maintain this invariant we\n-\/\/ need to throw a java.lang.IllegalMonitorStateException before inflating if\n-\/\/ the current thread is not the owner.\n+\/\/ ObjectMonitor*. It is used from contexts which require an inflatedmonitor,\n+\/\/ and expects to throw a java.lang.IllegalMonitorStateException if it is not\n+\/\/ held by the current thread. Such as notify\/wait and jni_exit.\n+\/\/ Lightweight locking keeps it invariant that it only inflates if it is already\n+\/\/ locked by the current thread or the current thread is in the process of entering.\n+\/\/ To maintain this invariant we need to throw a java.lang.IllegalMonitorStateException\n+\/\/ before inflating if the current thread is not the owner.\n@@ -823,2 +822,2 @@\n-  \/\/ The JavaThread* locking_thread parameter is only used by lightweight locking and\n-  \/\/ requires that the locking_thread == Thread::current() or is suspended throughout\n+  \/\/ The JavaThread* locking parameter requires that the\n+  \/\/ locking_thread == JavaThread::current, or is suspended throughout\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -541,2 +541,1 @@\n-  ObjectMonitor* monitor;\n-  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  ObjectMonitor* monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n@@ -556,2 +555,1 @@\n-  ObjectMonitor* monitor;\n-  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  ObjectMonitor* monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}