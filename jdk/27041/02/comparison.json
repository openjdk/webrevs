{"files":[{"patch":"@@ -334,20 +334,3 @@\n-    oop lockee = monitor->obj();\n-    bool success = false;\n-    if (LockingMode == LM_LEGACY) {\n-      markWord disp = lockee->mark().set_unlocked();\n-      monitor->lock()->set_displaced_header(disp);\n-      success = true;\n-      if (lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {\n-        \/\/ Is it simple recursive case?\n-        if (thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {\n-          monitor->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-        } else {\n-          success = false;\n-        }\n-      }\n-    }\n-    if (!success) {\n-      CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n-          if (HAS_PENDING_EXCEPTION)\n-            goto unwind_and_return;\n-    }\n+    CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n+    if (HAS_PENDING_EXCEPTION)\n+      goto unwind_and_return;\n@@ -484,18 +467,1 @@\n-    bool success = false;\n-    if (LockingMode == LM_LEGACY) {\n-      BasicLock* lock = monitor->lock();\n-      oop rcvr = monitor->obj();\n-      monitor->set_obj(nullptr);\n-      success = true;\n-      markWord header = lock->displaced_header();\n-      if (header.to_pointer() != nullptr) { \/\/ Check for recursive lock\n-        markWord old_header = markWord::encode(lock);\n-        if (rcvr->cas_set_mark(header, old_header) != old_header) {\n-          monitor->set_obj(rcvr);\n-          success = false;\n-        }\n-      }\n-    }\n-    if (!success) {\n-      InterpreterRuntime::monitorexit(monitor);\n-    }\n+    InterpreterRuntime::monitorexit(monitor);\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":4,"deletions":38,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-  CodeStub* slow_path = new MonitorExitStub(lock, LockingMode != LM_MONITOR, monitor_no);\n+  CodeStub* slow_path = new MonitorExitStub(lock, true, monitor_no);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -781,3 +781,0 @@\n-  if (LockingMode == LM_MONITOR) {\n-    lock->set_obj(obj);\n-  }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  assert(oopDesc::is_oop(pre_val, true), \"Error\");\n+  assert(oopDesc::is_oop(pre_val), \"Error\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  assert(oopDesc::is_oop(orig, true \/* ignore mark word *\/), \"Error\");\n+  assert(oopDesc::is_oop(orig), \"Error\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSetRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -353,1 +353,1 @@\n-    assert(oopDesc::is_oop(obj, true), \"Not an oop at \" PTR_FORMAT, p2i(cur));\n+    assert(oopDesc::is_oop(obj), \"Not an oop at \" PTR_FORMAT, p2i(cur));\n@@ -421,1 +421,1 @@\n-    assert(oopDesc::is_oop(obj, true), \"Not an oop at \" PTR_FORMAT, p2i(cur));\n+    assert(oopDesc::is_oop(obj), \"Not an oop at \" PTR_FORMAT, p2i(cur));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  assert(oopDesc::is_oop(cast_to_oop(entry), true \/* ignore mark word *\/),\n+  assert(oopDesc::is_oop(cast_to_oop(entry)),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SATBMarkQueueSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-      assert(oopDesc::is_oop(old_obj, true), \"Not an oop\");\n+      assert(oopDesc::is_oop(old_obj), \"Not an oop\");\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -315,5 +315,0 @@\n-  \/\/ The mark-word has been copied from the original object. It can not be\n-  \/\/ inflating, because inflation can not be interrupted by a safepoint,\n-  \/\/ and after a safepoint, a Java thread would first have to successfully\n-  \/\/ evacuate the object before it could inflate the monitor.\n-  assert(!w.is_being_inflated() || LockingMode == LM_LIGHTWEIGHT, \"must not inflate monitor before evacuation of object succeeds\");\n@@ -337,1 +332,0 @@\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"Must use LW locking, too\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -627,20 +627,1 @@\n-\n-        bool success = false;\n-        if (LockingMode == LM_LEGACY) {\n-           \/\/ Traditional fast locking.\n-          markWord displaced = rcvr->mark().set_unlocked();\n-          mon->lock()->set_displaced_header(displaced);\n-          success = true;\n-          if (rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n-            \/\/ Is it simple recursive case?\n-            if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-              mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-            } else {\n-              success = false;\n-            }\n-          }\n-        }\n-        if (!success) {\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n-        }\n-\n+        CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n@@ -728,20 +709,1 @@\n-\n-      bool success = false;\n-      if (LockingMode == LM_LEGACY) {\n-        \/\/ Traditional fast locking.\n-        markWord displaced = lockee->mark().set_unlocked();\n-        entry->lock()->set_displaced_header(displaced);\n-        success = true;\n-        if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-          \/\/ Is it simple recursive case?\n-          if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-            entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-          } else {\n-            success = false;\n-          }\n-        }\n-      }\n-      if (!success) {\n-        CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n-      }\n-\n+      CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -1660,20 +1622,1 @@\n-\n-          bool success = false;\n-          if (LockingMode == LM_LEGACY) {\n-            \/\/ Traditional fast locking.\n-            markWord displaced = lockee->mark().set_unlocked();\n-            entry->lock()->set_displaced_header(displaced);\n-            success = true;\n-            if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-              \/\/ Is it simple recursive case?\n-              if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-                entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-              } else {\n-                success = false;\n-              }\n-            }\n-          }\n-          if (!success) {\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n-          }\n-\n+          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -1697,19 +1640,1 @@\n-\n-            bool success = false;\n-            if (LockingMode == LM_LEGACY) {\n-              \/\/ If it isn't recursive we either must swap old header or call the runtime\n-              most_recent->set_obj(nullptr);\n-              success = true;\n-              markWord header = lock->displaced_header();\n-              if (header.to_pointer() != nullptr) {\n-                markWord old_header = markWord::encode(lock);\n-                if (lockee->cas_set_mark(header, old_header) != old_header) {\n-                  \/\/ restore object for the slow case\n-                  most_recent->set_obj(lockee);\n-                  success = false;\n-                }\n-              }\n-            }\n-            if (!success) {\n-              InterpreterRuntime::monitorexit(most_recent);\n-            }\n+            InterpreterRuntime::monitorexit(most_recent);\n@@ -3140,21 +3065,1 @@\n-          BasicLock* lock = end->lock();\n-\n-          bool success = false;\n-          if (LockingMode == LM_LEGACY) {\n-            markWord header = lock->displaced_header();\n-            end->set_obj(nullptr);\n-\n-            \/\/ If it isn't recursive we either must swap old header or call the runtime\n-            success = true;\n-            if (header.to_pointer() != nullptr) {\n-              markWord old_header = markWord::encode(lock);\n-              if (lockee->cas_set_mark(header, old_header) != old_header) {\n-                \/\/ restore object for the slow case\n-                end->set_obj(lockee);\n-                success = false;\n-              }\n-            }\n-          }\n-          if (!success) {\n-            InterpreterRuntime::monitorexit(end);\n-          }\n+          InterpreterRuntime::monitorexit(end);\n@@ -3207,1 +3112,1 @@\n-          } else if (LockingMode != LM_LEGACY) {\n+          } else {\n@@ -3213,20 +3118,0 @@\n-          } else {\n-            BasicLock* lock = base->lock();\n-            markWord header = lock->displaced_header();\n-            base->set_obj(nullptr);\n-\n-            \/\/ If it isn't recursive we either must swap old header or call the runtime\n-            bool dec_monitor_count = true;\n-            if (header.to_pointer() != nullptr) {\n-              markWord old_header = markWord::encode(lock);\n-              if (rcvr->cas_set_mark(header, old_header) != old_header) {\n-                \/\/ restore object for the slow case\n-                base->set_obj(rcvr);\n-                dec_monitor_count = false;\n-                InterpreterRuntime::monitorexit(base);\n-                if (THREAD->has_pending_exception()) {\n-                  if (!suppress_error) illegal_state_oop = Handle(THREAD, THREAD->pending_exception());\n-                  THREAD->clear_pending_exception();\n-                }\n-              }\n-            }\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":6,"deletions":121,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -568,2 +568,2 @@\n-  } else if (oopDesc::is_oop_or_null(obj, true) && (!as_string || !java_lang_String::is_instance(obj))) {\n-    if (oopDesc::is_oop_or_null(obj, true)) {\n+  } else if (oopDesc::is_oop_or_null(obj) && (!as_string || !java_lang_String::is_instance(obj))) {\n+    if (oopDesc::is_oop_or_null(obj)) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -344,1 +344,0 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _stack_locker,                                 BasicLock*)                            \\\n@@ -783,4 +782,0 @@\n-  declare_constant(LockingMode::LM_MONITOR)                               \\\n-  declare_constant(LockingMode::LM_LEGACY)                                \\\n-  declare_constant(LockingMode::LM_LIGHTWEIGHT)                           \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -167,4 +167,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,12 +39,4 @@\n-  if (has_monitor()) {\n-    \/\/ Has an inflated monitor. Must be checked before has_locker().\n-    ObjectMonitor* monitor = this->monitor();\n-    return monitor->header();\n-  }\n-  if (has_locker()) {  \/\/ has a stack lock\n-    BasicLock* locker = this->locker();\n-    return locker->displaced_header();\n-  }\n-  \/\/ This should never happen:\n-  fatal(\"bad header=\" INTPTR_FORMAT, value());\n-  return markWord(value());\n+  \/\/ Make sure we have an inflated monitor.\n+  guarantee(has_monitor(), \"bad header=\" INTPTR_FORMAT, value());\n+  ObjectMonitor* monitor = this->monitor();\n+  return monitor->header();\n@@ -55,13 +47,4 @@\n-  if (has_monitor()) {\n-    \/\/ Has an inflated monitor. Must be checked before has_locker().\n-    ObjectMonitor* monitor = this->monitor();\n-    monitor->set_header(m);\n-    return;\n-  }\n-  if (has_locker()) {  \/\/ has a stack lock\n-    BasicLock* locker = this->locker();\n-    locker->set_displaced_header(m);\n-    return;\n-  }\n-  \/\/ This should never happen:\n-  fatal(\"bad header=\" INTPTR_FORMAT, value());\n+  \/\/ Make sure we have an inflated monitor.\n+  guarantee(has_monitor(), \"bad header=\" INTPTR_FORMAT, value());\n+  ObjectMonitor* monitor = this->monitor();\n+  monitor->set_header(m);\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":8,"deletions":25,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,8 +201,0 @@\n-  bool has_locker() const {\n-    assert(LockingMode == LM_LEGACY, \"should only be called with legacy stack locking\");\n-    return (value() & lock_mask_in_place) == locked_value;\n-  }\n-  BasicLock* locker() const {\n-    assert(has_locker(), \"check\");\n-    return (BasicLock*) value();\n-  }\n@@ -211,1 +203,0 @@\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"should only be called with new lightweight locking\");\n@@ -230,5 +221,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      return !UseObjectMonitorTable && lockbits == monitor_value;\n-    }\n-    \/\/ monitor (0b10) | stack-locked (0b00)?\n-    return (lockbits & unlocked_value) == 0;\n+    return !UseObjectMonitorTable && lockbits == monitor_value;\n@@ -307,1 +294,0 @@\n-    NOT_LP64(assert(LockingMode != LM_LEGACY, \"incorrect with LM_LEGACY on 32 bit\");)\n@@ -312,1 +298,0 @@\n-    NOT_LP64(assert(LockingMode != LM_LEGACY, \"incorrect with LM_LEGACY on 32 bit\");)\n@@ -317,1 +302,0 @@\n-    NOT_LP64(assert(LockingMode != LM_LEGACY, \"incorrect with LM_LEGACY on 32 bit\");)\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -113,16 +113,2 @@\n-bool oopDesc::is_oop(oop obj, bool ignore_mark_word) {\n-  if (!Universe::heap()->is_oop(obj)) {\n-    return false;\n-  }\n-\n-  \/\/ Header verification: the mark is typically non-zero. If we're\n-  \/\/ at a safepoint, it must not be zero, except when using the new lightweight locking.\n-  \/\/ Outside of a safepoint, the header could be changing (for example,\n-  \/\/ another thread could be inflating a lock on this object).\n-  if (ignore_mark_word) {\n-    return true;\n-  }\n-  if (obj->mark().value() != 0) {\n-    return true;\n-  }\n-  return LockingMode == LM_LIGHTWEIGHT || !SafepointSynchronize::is_at_safepoint();\n+bool oopDesc::is_oop(oop obj) {\n+  return Universe::heap()->is_oop(obj);\n@@ -132,2 +118,2 @@\n-bool oopDesc::is_oop_or_null(oop obj, bool ignore_mark_word) {\n-  return obj == nullptr ? true : is_oop(obj, ignore_mark_word);\n+bool oopDesc::is_oop_or_null(oop obj) {\n+  return obj == nullptr ? true : is_oop(obj);\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -264,2 +264,2 @@\n-  static bool is_oop(oop obj, bool ignore_mark_word = false);\n-  static bool is_oop_or_null(oop obj, bool ignore_mark_word = false);\n+  static bool is_oop(oop obj);\n+  static bool is_oop_or_null(oop obj);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4791,4 +4791,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n-      Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n-      Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n+    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n@@ -4796,8 +4795,1 @@\n-      generate_slow_guard(test_monitor, slow_region);\n-    } else {\n-      Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n-      Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n-      Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n-\n-      generate_slow_guard(test_not_unlocked, slow_region);\n-    }\n+    generate_slow_guard(test_monitor, slow_region);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1673,0 +1673,1 @@\n+    \/\/   Note: The -XX:LockingMode option is not available anymore.\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1370,5 +1370,0 @@\n-  if (LockingMode == LM_LEGACY && java_thread == nullptr) {\n-    *owned_monitor_count_ptr = 0;\n-    return JVMTI_ERROR_NONE;\n-  }\n-\n@@ -1430,5 +1425,0 @@\n-  if (LockingMode == LM_LEGACY && java_thread == nullptr) {\n-    *monitor_info_count_ptr = 0;\n-    return JVMTI_ERROR_NONE;\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1855,18 +1855,0 @@\n-  if (UseObjectMonitorTable && LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ ObjectMonitorTable requires lightweight locking.\n-    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n-    warning(\"UseObjectMonitorTable requires LM_LIGHTWEIGHT\");\n-  }\n-\n-#if !defined(X86) && !defined(AARCH64) && !defined(PPC64) && !defined(RISCV64) && !defined(S390)\n-  if (LockingMode == LM_MONITOR) {\n-    jio_fprintf(defaultStream::error_stream(),\n-                \"LockingMode == 0 (LM_MONITOR) is not fully implemented on this architecture\\n\");\n-    return false;\n-  }\n-#endif\n-  if (VerifyHeavyMonitors && LockingMode != LM_MONITOR) {\n-    jio_fprintf(defaultStream::error_stream(),\n-                \"-XX:+VerifyHeavyMonitors requires LockingMode == 0 (LM_MONITOR)\\n\");\n-    return false;\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,7 +37,0 @@\n-  } else if (LockingMode == LM_LEGACY) {\n-    markWord mark_word = displaced_header();\n-    if (mark_word.value() != 0) {\n-      \/\/ Print monitor info if there's an owning oop and it refers to this BasicLock.\n-      bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n-      mark_word.print_on(st, print_monitor_info);\n-    }\n@@ -76,17 +69,1 @@\n-  if (LockingMode == LM_LEGACY) {\n-    if (displaced_header().is_neutral()) {\n-      \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-      \/\/ locked so it can't be async deflated until ownership is dropped.\n-      ObjectSynchronizer::inflate_helper(obj);\n-      \/\/ WARNING: We cannot put a check here, because the inflation\n-      \/\/ will not update the displaced header. Once BasicLock is inflated,\n-      \/\/ no one should ever look at its content.\n-    } else {\n-      \/\/ Typically the displaced header will be 0 (recursive stack lock) or\n-      \/\/ unused_mark.  Naively we'd like to assert that the displaced mark\n-      \/\/ value is either 0, neutral, or 3.  But with the advent of the\n-      \/\/ store-before-CAS avoidance in fast_lock\/compiler_lock_object\n-      \/\/ we can find any flavor mark in the displaced mark.\n-    }\n-    dest->set_displaced_header(displaced_header());\n-  } else if (UseObjectMonitorTable) {\n+  if (UseObjectMonitorTable) {\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -38,6 +38,0 @@\n-  \/\/ * For LM_MONITOR\n-  \/\/ Unused.\n-  \/\/ * For LM_LEGACY\n-  \/\/ This is either the actual displaced header from a locked object, or\n-  \/\/ a sentinel zero value indicating a recursive stack-lock.\n-  \/\/ * For LM_LIGHTWEIGHT\n@@ -55,1 +49,0 @@\n-  \/\/ LM_MONITOR\n@@ -58,3 +51,0 @@\n-  \/\/ LM_LEGACY\n-  inline markWord displaced_header() const;\n-  inline void set_displaced_header(markWord header);\n@@ -63,1 +53,0 @@\n-  \/\/ LM_LIGHTWEIGHT\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,10 +31,0 @@\n-inline markWord BasicLock::displaced_header() const {\n-  assert(LockingMode == LM_LEGACY, \"must be\");\n-  return markWord(get_metadata());\n-}\n-\n-inline void BasicLock::set_displaced_header(markWord header) {\n-  assert(LockingMode == LM_LEGACY, \"must be\");\n-  Atomic::store(&_metadata, header.value());\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -149,4 +149,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    return freeze_unsupported;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -536,5 +536,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    _monitors_in_lockstack = 0;\n-  } else {\n-    _monitors_in_lockstack = _thread->lock_stack().monitor_count();\n-  }\n+  _monitors_in_lockstack = _thread->lock_stack().monitor_count();\n@@ -590,20 +586,0 @@\n-#ifdef ASSERT\n-static bool monitors_on_stack(JavaThread* thread) {\n-  assert_frames_in_continuation_are_safe(thread);\n-  ContinuationEntry* ce = thread->last_continuation();\n-  RegisterMap map(thread,\n-                  RegisterMap::UpdateMap::include,\n-                  RegisterMap::ProcessFrames::skip,\n-                  RegisterMap::WalkContinuation::skip);\n-  map.set_include_argument_oops(false);\n-  for (frame f = thread->last_frame(); Continuation::is_frame_in_continuation(ce, f); f = f.sender(&map)) {\n-    if ((f.is_interpreted_frame() && ContinuationHelper::InterpretedFrame::is_owning_locks(f)) ||\n-        (f.is_compiled_frame() && ContinuationHelper::CompiledFrame::is_owning_locks(map.thread(), &map, f)) ||\n-        (f.is_native_frame() && ContinuationHelper::NativeFrame::is_owning_locks(map.thread(), f))) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-#endif \/\/ ASSERT\n-\n@@ -616,1 +592,0 @@\n-  assert(LockingMode != LM_LEGACY || !monitors_on_stack(_thread), \"unexpected monitors on stack\");\n@@ -1765,2 +1740,2 @@\n-  assert(LockingMode == LM_LEGACY || (current->held_monitor_count() == 0 && current->jni_monitor_count() == 0),\n-         \"Held monitor count should only be used for LM_LEGACY: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n+  assert((current->held_monitor_count() == 0 && current->jni_monitor_count() == 0),\n+         \"Held monitor count should not be used for lightweight locking: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1650,7 +1650,0 @@\n-          if (LockingMode == LM_LEGACY && mark.has_locker() && fr.sp() > (intptr_t*)mark.locker()) {\n-            \/\/ With exec_mode == Unpack_none obj may be thread local and locked in\n-            \/\/ a callee frame. Make the lock in the callee a recursive lock and restore the displaced header.\n-            markWord dmw = mark.displaced_mark_helper();\n-            mark.locker()->set_displaced_header(markWord::encode((BasicLock*) nullptr));\n-            obj->set_mark(dmw);\n-          }\n@@ -1662,3 +1655,1 @@\n-              if (LockingMode == LM_LEGACY) {\n-                mon_info->lock()->set_displaced_header(markWord::unused_mark());\n-              } else if (UseObjectMonitorTable) {\n+              if (UseObjectMonitorTable) {\n@@ -1669,1 +1660,1 @@\n-                assert(LockingMode == LM_MONITOR || !UseObjectMonitorTable, \"must be\");\n+                assert(!UseObjectMonitorTable, \"must be\");\n@@ -1679,12 +1670,11 @@\n-        if (LockingMode == LM_LIGHTWEIGHT) {\n-          \/\/ We have lost information about the correct state of the lock stack.\n-          \/\/ Entering may create an invalid lock stack. Inflate the lock if it\n-          \/\/ was fast_locked to restore the valid lock stack.\n-          if (UseObjectMonitorTable) {\n-            \/\/ UseObjectMonitorTable expects the BasicLock cache to be either a\n-            \/\/ valid ObjectMonitor* or nullptr. Right now it is garbage, set it\n-            \/\/ to nullptr.\n-            lock->clear_object_monitor_cache();\n-          }\n-          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n-          if (deoptee_thread->lock_stack().contains(obj())) {\n+        \/\/ We have lost information about the correct state of the lock stack.\n+        \/\/ Entering may create an invalid lock stack. Inflate the lock if it\n+        \/\/ was fast_locked to restore the valid lock stack.\n+        if (UseObjectMonitorTable) {\n+          \/\/ UseObjectMonitorTable expects the BasicLock cache to be either a\n+          \/\/ valid ObjectMonitor* or nullptr. Right now it is garbage, set it\n+          \/\/ to nullptr.\n+          lock->clear_object_monitor_cache();\n+        }\n+        ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n+        if (deoptee_thread->lock_stack().contains(obj())) {\n@@ -1692,9 +1682,1 @@\n-                                                                deoptee_thread, thread);\n-          }\n-          assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n-          assert(obj->mark().has_monitor(), \"must be\");\n-          assert(!deoptee_thread->lock_stack().contains(obj()), \"must be\");\n-          assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->has_owner(deoptee_thread), \"must be\");\n-        } else {\n-          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n-          assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+                                                              deoptee_thread, thread);\n@@ -1702,0 +1684,4 @@\n+        assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+        assert(obj->mark().has_monitor(), \"must be\");\n+        assert(!deoptee_thread->lock_stack().contains(obj()), \"must be\");\n+        assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->has_owner(deoptee_thread), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":18,"deletions":32,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1051,4 +1051,0 @@\n-  develop(bool, VerifyHeavyMonitors, false,                                 \\\n-          \"Checks that no stack locking happens when using \"                \\\n-          \"-XX:LockingMode=0 (LM_MONITOR)\")                                 \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -556,1 +556,1 @@\n-      guarantee(oopDesc::is_oop_or_null(vv, true),\n+      guarantee(oopDesc::is_oop_or_null(vv),\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1066,5 +1066,0 @@\n-bool JavaThread::is_lock_owned(address adr) const {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"should not be called with new lightweight locking\");\n-  return is_in_full_stack(adr);\n-}\n-\n@@ -1440,3 +1435,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lock_stack().oops_do(f);\n-  }\n+  \/\/ Due to lightweight locking\n+  lock_stack().oops_do(f);\n@@ -2002,16 +1996,3 @@\n-\n-  if (LockingMode != LM_LEGACY) {\n-    \/\/ Nothing to do. Just do some sanity check.\n-    assert(_held_monitor_count == 0, \"counter should not be used\");\n-    assert(_jni_monitor_count == 0, \"counter should not be used\");\n-    return;\n-  }\n-\n-  assert(_held_monitor_count >= 0, \"Must always be non-negative: %zd\", _held_monitor_count);\n-  _held_monitor_count += i;\n-  if (jni) {\n-    assert(_jni_monitor_count >= 0, \"Must always be non-negative: %zd\", _jni_monitor_count);\n-    _jni_monitor_count += i;\n-  }\n-  assert(_held_monitor_count >= _jni_monitor_count, \"Monitor count discrepancy detected - held count \"\n-         \"%zd is less than JNI count %zd\", _held_monitor_count, _jni_monitor_count);\n+  \/\/ Nothing to do. Just do some sanity check.\n+  assert(_held_monitor_count == 0, \"counter should not be used\");\n+  assert(_jni_monitor_count == 0, \"counter should not be used\");\n@@ -2025,20 +2006,3 @@\n-\n-  if (LockingMode != LM_LEGACY) {\n-    \/\/ Nothing to do. Just do some sanity check.\n-    assert(_held_monitor_count == 0, \"counter should not be used\");\n-    assert(_jni_monitor_count == 0, \"counter should not be used\");\n-    return;\n-  }\n-\n-  _held_monitor_count -= i;\n-  assert(_held_monitor_count >= 0, \"Must always be non-negative: %zd\", _held_monitor_count);\n-  if (jni) {\n-    _jni_monitor_count -= i;\n-    assert(_jni_monitor_count >= 0, \"Must always be non-negative: %zd\", _jni_monitor_count);\n-  }\n-  \/\/ When a thread is detaching with still owned JNI monitors, the logic that releases\n-  \/\/ the monitors doesn't know to set the \"jni\" flag and so the counts can get out of sync.\n-  \/\/ So we skip this assert if the thread is exiting. Once all monitors are unlocked the\n-  \/\/ JNI count is directly set to zero.\n-  assert(_held_monitor_count >= _jni_monitor_count || is_exiting(), \"Monitor count discrepancy detected - held count \"\n-         \"%zd is less than JNI count %zd\", _held_monitor_count, _jni_monitor_count);\n+  \/\/ Nothing to do. Just do some sanity check.\n+  assert(_held_monitor_count == 0, \"counter should not be used\");\n+  assert(_jni_monitor_count == 0, \"counter should not be used\");\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":8,"deletions":44,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -758,3 +758,0 @@\n-  \/\/ Stack-locking support (not for LM_LIGHTWEIGHT)\n-  bool is_lock_owned(address adr) const;\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -336,2 +336,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-\n@@ -631,1 +629,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -660,1 +657,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -721,1 +717,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -773,10 +768,7 @@\n-\/\/ LightweightSynchronizer::inflate_locked_or_imse is used to to get an inflated\n-\/\/ ObjectMonitor* with LM_LIGHTWEIGHT. It is used from contexts which require\n-\/\/ an inflated ObjectMonitor* for a monitor, and expects to throw a\n-\/\/ java.lang.IllegalMonitorStateException if it is not held by the current\n-\/\/ thread. Such as notify\/wait and jni_exit. LM_LIGHTWEIGHT keeps it invariant\n-\/\/ that it only inflates if it is already locked by the current thread or the\n-\/\/ current thread is in the process of entering. To maintain this invariant we\n-\/\/ need to throw a java.lang.IllegalMonitorStateException before inflating if\n-\/\/ the current thread is not the owner.\n-\/\/ LightweightSynchronizer::inflate_locked_or_imse facilitates this.\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse is used to to get an\n+\/\/ inflated ObjectMonitor* from contexts which require that, such as\n+\/\/ notify\/wait and jni_exit. Lightweight locking keeps the invariant that it\n+\/\/ only inflates if it is already locked by the current thread or the current\n+\/\/ thread is in the process of entering. To maintain this invariant we need to\n+\/\/ throw a java.lang.IllegalMonitorStateException before inflating if the\n+\/\/ current thread is not the owner.\n@@ -784,1 +776,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -829,4 +820,4 @@\n-  \/\/ The JavaThread* locking_thread parameter is only used by LM_LIGHTWEIGHT and requires\n-  \/\/ that the locking_thread == Thread::current() or is suspended throughout the call by\n-  \/\/ some other mechanism.\n-  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ The JavaThread* locking parameter requires that the\n+  \/\/ locking_thread == JavaThread::current, or is suspended throughout\n+  \/\/ the call by some other mechanism.\n+  \/\/ Even with lightweight locking the thread might be nullptr when called from a non\n@@ -834,1 +825,1 @@\n-  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ important for the correctness of the lightweight locking algorithm that the thread\n@@ -946,1 +937,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n@@ -1003,1 +993,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"never use lock-stack when light weight locking is disabled\");\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -300,2 +300,1 @@\n-  _wait_set_lock(0),\n-  _stack_locker(nullptr)\n+  _wait_set_lock(0)\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -163,3 +163,3 @@\n-  \/\/ * LM_LIGHTWEIGHT with UseObjectMonitorTable:\n-  \/\/ Contains the _object's hashCode.\n-  \/\/ * LM_LEGACY, LM_MONITOR, LM_LIGHTWEIGHT without UseObjectMonitorTable:\n+  \/\/ * Lightweight locking with UseObjectMonitorTable:\n+  \/\/   Contains the _object's hashCode.\n+  \/\/ * * Lightweight locking without UseObjectMonitorTable:\n@@ -207,3 +207,0 @@\n-  \/\/ Used in LM_LEGACY mode to store BasicLock* in case of inflation by contending thread.\n-  BasicLock* volatile _stack_locker;\n-\n@@ -321,4 +318,0 @@\n-  \/\/ Get and set _stack_locker.\n-  BasicLock* stack_locker() const;\n-  void set_stack_locker(BasicLock* locker);\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -55,5 +55,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      return current->lock_stack().contains(object());\n-    } else {\n-      return current->is_lock_owned((address)stack_locker());\n-    }\n+    return current->lock_stack().contains(object());\n@@ -119,8 +115,0 @@\n-inline BasicLock* ObjectMonitor::stack_locker() const {\n-  return Atomic::load(&_stack_locker);\n-}\n-\n-inline void ObjectMonitor::set_stack_locker(BasicLock* locker) {\n-  Atomic::store(&_stack_locker, locker);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3371,12 +3371,1 @@\n-      if (LockingMode == LM_LEGACY) {\n-        \/\/ Inflate so the object's header no longer refers to the BasicLock.\n-        if (lock->displaced_header().is_unlocked()) {\n-          \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-          \/\/ locked so it can't be async deflated until ownership is dropped.\n-          \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n-          ObjectSynchronizer::inflate_helper(kptr2->obj());\n-        }\n-        \/\/ Now the displaced header is free to move because the\n-        \/\/ object's header no longer refers to it.\n-        buf[i] = (intptr_t)lock->displaced_header().value();\n-      } else if (UseObjectMonitorTable) {\n+      if (UseObjectMonitorTable) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -285,3 +285,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    LightweightSynchronizer::initialize();\n-  }\n+  LightweightSynchronizer::initialize();\n@@ -346,12 +344,4 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    if (mark.is_fast_locked() && current->lock_stack().contains(cast_to_oop(obj))) {\n-      \/\/ Degenerate notify\n-      \/\/ fast-locked by caller so by definition the implied waitset is empty.\n-      return true;\n-    }\n-  } else if (LockingMode == LM_LEGACY) {\n-    if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n-      \/\/ Degenerate notify\n-      \/\/ stack-locked by caller so by definition the implied waitset is empty.\n-      return true;\n-    }\n+  if (mark.is_fast_locked() && current->lock_stack().contains(cast_to_oop(obj))) {\n+    \/\/ Degenerate notify\n+    \/\/ fast-locked by caller so by definition the implied waitset is empty.\n+    return true;\n@@ -362,1 +352,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT && mon == nullptr) {\n+    if (mon == nullptr) {\n@@ -385,73 +375,0 @@\n-static bool useHeavyMonitors() {\n-#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n-  return LockingMode == LM_MONITOR;\n-#else\n-  return false;\n-#endif\n-}\n-\n-\/\/ The LockNode emitted directly at the synchronization site would have\n-\/\/ been too big if it were to have included support for the cases of inflated\n-\/\/ recursive enter and exit, so they go here instead.\n-\/\/ Note that we can't safely call AsyncPrintJavaStack() from within\n-\/\/ quick_enter() as our thread state remains _in_Java.\n-\n-bool ObjectSynchronizer::quick_enter_legacy(oop obj, BasicLock* lock, JavaThread* current) {\n-  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n-\n-  if (useHeavyMonitors()) {\n-    return false;  \/\/ Slow path\n-  }\n-\n-  assert(LockingMode == LM_LEGACY, \"legacy mode below\");\n-\n-  const markWord mark = obj->mark();\n-\n-  if (mark.has_monitor()) {\n-\n-    ObjectMonitor* const m = read_monitor(mark);\n-    \/\/ An async deflation or GC can race us before we manage to make\n-    \/\/ the ObjectMonitor busy by setting the owner below. If we detect\n-    \/\/ that race we just bail out to the slow-path here.\n-    if (m->object_peek() == nullptr) {\n-      return false;\n-    }\n-\n-    \/\/ Lock contention and Transactional Lock Elision (TLE) diagnostics\n-    \/\/ and observability\n-    \/\/ Case: light contention possibly amenable to TLE\n-    \/\/ Case: TLE inimical operations such as nested\/recursive synchronization\n-\n-    if (m->has_owner(current)) {\n-      m->increment_recursions(current);\n-      current->inc_held_monitor_count();\n-      return true;\n-    }\n-\n-    \/\/ This Java Monitor is inflated so obj's header will never be\n-    \/\/ displaced to this thread's BasicLock. Make the displaced header\n-    \/\/ non-null so this BasicLock is not seen as recursive nor as\n-    \/\/ being locked. We do this unconditionally so that this thread's\n-    \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n-    \/\/ performance reasons, stack walkers generally first check for\n-    \/\/ stack-locking in the object's header, the second check is for\n-    \/\/ recursive stack-locking in the displaced header in the BasicLock,\n-    \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n-    lock->set_displaced_header(markWord::unused_mark());\n-\n-    if (!m->has_owner() && m->try_set_owner(current)) {\n-      assert(m->recursions() == 0, \"invariant\");\n-      current->inc_held_monitor_count();\n-      return true;\n-    }\n-  }\n-\n-  \/\/ Note that we could inflate in quick_enter.\n-  \/\/ This is likely a useful optimization\n-  \/\/ Critically, in quick_enter() we must not:\n-  \/\/ -- block indefinitely, or\n-  \/\/ -- reach a safepoint\n-\n-  return false;        \/\/ revert to slow-path\n-}\n-\n@@ -516,138 +433,1 @@\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    return LightweightSynchronizer::enter_for(obj, lock, locking_thread);\n-  }\n-\n-  if (!enter_fast_impl(obj, lock, locking_thread)) {\n-    \/\/ Inflated ObjectMonitor::enter_for is required\n-\n-    \/\/ An async deflation can race after the inflate_for() call and before\n-    \/\/ enter_for() can make the ObjectMonitor busy. enter_for() returns false\n-    \/\/ if we have lost the race to async deflation and we simply try again.\n-    while (true) {\n-      ObjectMonitor* monitor = inflate_for(locking_thread, obj(), inflate_cause_monitor_enter);\n-      if (monitor->enter_for(locking_thread)) {\n-        return;\n-      }\n-      assert(monitor->is_being_async_deflated(), \"must be\");\n-    }\n-  }\n-}\n-\n-void ObjectSynchronizer::enter_legacy(Handle obj, BasicLock* lock, JavaThread* current) {\n-  if (!enter_fast_impl(obj, lock, current)) {\n-    \/\/ Inflated ObjectMonitor::enter is required\n-\n-    \/\/ An async deflation can race after the inflate() call and before\n-    \/\/ enter() can make the ObjectMonitor busy. enter() returns false if\n-    \/\/ we have lost the race to async deflation and we simply try again.\n-    while (true) {\n-      ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n-      if (monitor->enter(current)) {\n-        return;\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ The interpreter and compiler assembly code tries to lock using the fast path\n-\/\/ of this algorithm. Make sure to update that code if the following function is\n-\/\/ changed. The implementation is extremely sensitive to race condition. Be careful.\n-bool ObjectSynchronizer::enter_fast_impl(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n-\n-  if (obj->klass()->is_value_based()) {\n-    handle_sync_on_value_based_class(obj, locking_thread);\n-  }\n-\n-  locking_thread->inc_held_monitor_count();\n-\n-  if (!useHeavyMonitors()) {\n-    if (LockingMode == LM_LEGACY) {\n-      markWord mark = obj->mark();\n-      if (mark.is_unlocked()) {\n-        \/\/ Anticipate successful CAS -- the ST of the displaced mark must\n-        \/\/ be visible <= the ST performed by the CAS.\n-        lock->set_displaced_header(mark);\n-        if (mark == obj()->cas_set_mark(markWord::from_pointer(lock), mark)) {\n-          return true;\n-        }\n-      } else if (mark.has_locker() &&\n-                 locking_thread->is_lock_owned((address) mark.locker())) {\n-        assert(lock != mark.locker(), \"must not re-lock the same lock\");\n-        assert(lock != (BasicLock*) obj->mark().value(), \"don't relock with same BasicLock\");\n-        lock->set_displaced_header(markWord::from_pointer(nullptr));\n-        return true;\n-      }\n-\n-      \/\/ The object header will never be displaced to this lock,\n-      \/\/ so it does not matter what the value is, except that it\n-      \/\/ must be non-zero to avoid looking like a re-entrant lock,\n-      \/\/ and must not look locked either.\n-      lock->set_displaced_header(markWord::unused_mark());\n-\n-      \/\/ Failed to fast lock.\n-      return false;\n-    }\n-  } else if (VerifyHeavyMonitors) {\n-    guarantee((obj->mark().value() & markWord::lock_mask_in_place) != markWord::locked_value, \"must not be lightweight\/stack-locked\");\n-  }\n-\n-  return false;\n-}\n-\n-void ObjectSynchronizer::exit_legacy(oop object, BasicLock* lock, JavaThread* current) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n-\n-  if (!useHeavyMonitors()) {\n-    markWord mark = object->mark();\n-    if (LockingMode == LM_LEGACY) {\n-      markWord dhw = lock->displaced_header();\n-      if (dhw.value() == 0) {\n-        \/\/ If the displaced header is null, then this exit matches up with\n-        \/\/ a recursive enter. No real work to do here except for diagnostics.\n-#ifndef PRODUCT\n-        if (mark != markWord::INFLATING()) {\n-          \/\/ Only do diagnostics if we are not racing an inflation. Simply\n-          \/\/ exiting a recursive enter of a Java Monitor that is being\n-          \/\/ inflated is safe; see the has_monitor() comment below.\n-          assert(!mark.is_unlocked(), \"invariant\");\n-          assert(!mark.has_locker() ||\n-                 current->is_lock_owned((address)mark.locker()), \"invariant\");\n-          if (mark.has_monitor()) {\n-            \/\/ The BasicLock's displaced_header is marked as a recursive\n-            \/\/ enter and we have an inflated Java Monitor (ObjectMonitor).\n-            \/\/ This is a special case where the Java Monitor was inflated\n-            \/\/ after this thread entered the stack-lock recursively. When a\n-            \/\/ Java Monitor is inflated, we cannot safely walk the Java\n-            \/\/ Monitor owner's stack and update the BasicLocks because a\n-            \/\/ Java Monitor can be asynchronously inflated by a thread that\n-            \/\/ does not own the Java Monitor.\n-            ObjectMonitor* m = read_monitor(mark);\n-            assert(m->object()->mark() == mark, \"invariant\");\n-            assert(m->is_entered(current), \"invariant\");\n-          }\n-        }\n-#endif\n-        return;\n-      }\n-\n-      if (mark == markWord::from_pointer(lock)) {\n-        \/\/ If the object is stack-locked by the current thread, try to\n-        \/\/ swing the displaced header from the BasicLock back to the mark.\n-        assert(dhw.is_neutral(), \"invariant\");\n-        if (object->cas_set_mark(dhw, mark) == mark) {\n-          return;\n-        }\n-      }\n-    }\n-  } else if (VerifyHeavyMonitors) {\n-    guarantee((object->mark().value() & markWord::lock_mask_in_place) != markWord::locked_value, \"must not be lightweight\/stack-locked\");\n-  }\n-\n-  \/\/ We have to take the slow-path of possible inflation and then exit.\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n-  ObjectMonitor* monitor = inflate(current, object, inflate_cause_vm_internal);\n-  assert(!monitor->has_anonymous_owner(), \"must not be\");\n-  monitor->exit(current);\n+  return LightweightSynchronizer::enter_for(obj, lock, locking_thread);\n@@ -674,11 +454,2 @@\n-    ObjectMonitor* monitor;\n-    bool entered;\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      BasicLock lock;\n-      entered = LightweightSynchronizer::inflate_and_enter(obj(), &lock, inflate_cause_jni_enter, current, current) != nullptr;\n-    } else {\n-      monitor = inflate(current, obj(), inflate_cause_jni_enter);\n-      entered = monitor->enter(current);\n-    }\n-\n-    if (entered) {\n+    BasicLock lock;\n+    if (LightweightSynchronizer::inflate_and_enter(obj(), &lock, inflate_cause_jni_enter, current, current) != nullptr) {\n@@ -697,7 +468,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj, inflate_cause_jni_exit, CHECK);\n-  } else {\n-    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-    \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n-    monitor = inflate(current, obj, inflate_cause_jni_exit);\n-  }\n+  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj, inflate_cause_jni_exit, CHECK);\n@@ -744,8 +509,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK_0);\n-  } else {\n-    \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n-    \/\/ field is incremented before ownership is dropped and decremented\n-    \/\/ after ownership is regained.\n-    monitor = inflate(current, obj(), inflate_cause_wait);\n-  }\n+  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK_0);\n@@ -770,5 +528,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK);\n-  } else {\n-    monitor = inflate(THREAD, obj(), inflate_cause_wait);\n-  }\n+  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK);\n@@ -783,19 +537,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    if ((mark.is_fast_locked() && current->lock_stack().contains(obj()))) {\n-      \/\/ Not inflated so there can't be any waiters to notify.\n-      return;\n-    }\n-  } else if (LockingMode == LM_LEGACY) {\n-    if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n-      \/\/ Not inflated so there can't be any waiters to notify.\n-      return;\n-    }\n-  }\n-\n-  ObjectMonitor* monitor;\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n-  } else {\n-    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-    \/\/ dropped by the calling thread.\n-    monitor = inflate(current, obj(), inflate_cause_notify);\n+  if ((mark.is_fast_locked() && current->lock_stack().contains(obj()))) {\n+    \/\/ Not inflated so there can't be any waiters to notify.\n+    return;\n@@ -803,0 +541,1 @@\n+  ObjectMonitor* monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n@@ -811,10 +550,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    if ((mark.is_fast_locked() && current->lock_stack().contains(obj()))) {\n-      \/\/ Not inflated so there can't be any waiters to notify.\n-      return;\n-    }\n-  } else if (LockingMode == LM_LEGACY) {\n-    if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n-      \/\/ Not inflated so there can't be any waiters to notify.\n-      return;\n-    }\n+  if ((mark.is_fast_locked() && current->lock_stack().contains(obj()))) {\n+    \/\/ Not inflated so there can't be any waiters to notify.\n+    return;\n@@ -823,8 +555,1 @@\n-  ObjectMonitor* monitor;\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n-  } else {\n-    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-    \/\/ dropped by the calling thread.\n-    monitor = inflate(current, obj(), inflate_cause_notify);\n-  }\n+  ObjectMonitor* monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n@@ -850,61 +575,0 @@\n-static markWord read_stable_mark(oop obj) {\n-  markWord mark = obj->mark_acquire();\n-  if (!mark.is_being_inflated() || LockingMode == LM_LIGHTWEIGHT) {\n-    \/\/ New lightweight locking does not use the markWord::INFLATING() protocol.\n-    return mark;       \/\/ normal fast-path return\n-  }\n-\n-  int its = 0;\n-  for (;;) {\n-    markWord mark = obj->mark_acquire();\n-    if (!mark.is_being_inflated()) {\n-      return mark;    \/\/ normal fast-path return\n-    }\n-\n-    \/\/ The object is being inflated by some other thread.\n-    \/\/ The caller of read_stable_mark() must wait for inflation to complete.\n-    \/\/ Avoid live-lock.\n-\n-    ++its;\n-    if (its > 10000 || !os::is_MP()) {\n-      if (its & 1) {\n-        os::naked_yield();\n-      } else {\n-        \/\/ Note that the following code attenuates the livelock problem but is not\n-        \/\/ a complete remedy.  A more complete solution would require that the inflating\n-        \/\/ thread hold the associated inflation lock.  The following code simply restricts\n-        \/\/ the number of spinners to at most one.  We'll have N-2 threads blocked\n-        \/\/ on the inflationlock, 1 thread holding the inflation lock and using\n-        \/\/ a yield\/park strategy, and 1 thread in the midst of inflation.\n-        \/\/ A more refined approach would be to change the encoding of INFLATING\n-        \/\/ to allow encapsulation of a native thread pointer.  Threads waiting for\n-        \/\/ inflation to complete would use CAS to push themselves onto a singly linked\n-        \/\/ list rooted at the markword.  Once enqueued, they'd loop, checking a per-thread flag\n-        \/\/ and calling park().  When inflation was complete the thread that accomplished inflation\n-        \/\/ would detach the list and set the markword to inflated with a single CAS and\n-        \/\/ then for each thread on the list, set the flag and unpark() the thread.\n-\n-        \/\/ Index into the lock array based on the current object address.\n-        static_assert(is_power_of_2(inflation_lock_count()), \"must be\");\n-        size_t ix = (cast_from_oop<intptr_t>(obj) >> 5) & (inflation_lock_count() - 1);\n-        int YieldThenBlock = 0;\n-        assert(ix < inflation_lock_count(), \"invariant\");\n-        inflation_lock(ix)->lock();\n-        while (obj->mark_acquire() == markWord::INFLATING()) {\n-          \/\/ Beware: naked_yield() is advisory and has almost no effect on some platforms\n-          \/\/ so we periodically call current->_ParkEvent->park(1).\n-          \/\/ We use a mixed spin\/yield\/block mechanism.\n-          if ((YieldThenBlock++) >= 16) {\n-            Thread::current()->_ParkEvent->park(1);\n-          } else {\n-            os::naked_yield();\n-          }\n-        }\n-        inflation_lock(ix)->unlock();\n-      }\n-    } else {\n-      SpinPause();       \/\/ SMP-polite spinning\n-    }\n-  }\n-}\n-\n@@ -969,1 +633,1 @@\n-  assert(UseObjectMonitorTable && LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -1000,6 +664,2 @@\n-    markWord mark = read_stable_mark(obj);\n-    if (VerifyHeavyMonitors) {\n-      assert(LockingMode == LM_MONITOR, \"+VerifyHeavyMonitors requires LockingMode == 0 (LM_MONITOR)\");\n-      guarantee((obj->mark().value() & markWord::lock_mask_in_place) != markWord::locked_value, \"must not be lightweight\/stack-locked\");\n-    }\n-    if (mark.is_unlocked() || (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked())) {\n+    markWord mark = obj->mark_acquire();\n+    if (mark.is_unlocked() || mark.is_fast_locked()) {\n@@ -1017,4 +677,3 @@\n-      if (LockingMode == LM_LIGHTWEIGHT) {\n-        \/\/ CAS failed, retry\n-        continue;\n-      }\n+      \/\/ CAS failed, retry\n+      continue;\n+\n@@ -1052,19 +711,0 @@\n-    } else if (LockingMode == LM_LEGACY && mark.has_locker()\n-               && current->is_Java_thread()\n-               && JavaThread::cast(current)->is_lock_owned((address)mark.locker())) {\n-      \/\/ This is a stack-lock owned by the calling thread so fetch the\n-      \/\/ displaced markWord from the BasicLock on the stack.\n-      temp = mark.displaced_mark_helper();\n-      assert(temp.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, temp.value());\n-      hash = temp.hash();\n-      if (hash != 0) {                  \/\/ if it has a hash, just return it\n-        return hash;\n-      }\n-      \/\/ WARNING:\n-      \/\/ The displaced header in the BasicLock on a thread's stack\n-      \/\/ is strictly immutable. It CANNOT be changed in ANY cases.\n-      \/\/ So we have to inflate the stack-lock into an ObjectMonitor\n-      \/\/ even if the current thread owns the lock. The BasicLock on\n-      \/\/ a thread's stack can be asynchronously read by other threads\n-      \/\/ during an inflate() call so any change to that stack memory\n-      \/\/ may not propagate to other threads correctly.\n@@ -1073,3 +713,0 @@\n-    \/\/ Inflate the monitor to set the hash.\n-\n-    \/\/ There's no need to inflate if the mark has already got a monitor.\n@@ -1079,1 +716,3 @@\n-    monitor = mark.has_monitor() ? mark.monitor() : inflate(current, obj, inflate_cause_hash_code);\n+    assert(mark.has_monitor(), \"must be\");\n+    monitor = mark.monitor();\n+\n@@ -1119,6 +758,1 @@\n-  markWord mark = read_stable_mark(obj);\n-\n-  if (LockingMode == LM_LEGACY && mark.has_locker()) {\n-    \/\/ stack-locked case, header points into owner's stack\n-    return current->is_lock_owned((address)mark.locker());\n-  }\n+  markWord mark = obj->mark_acquire();\n@@ -1126,1 +760,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n+  if (mark.is_fast_locked()) {\n@@ -1131,1 +765,1 @@\n-  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+  while (mark.has_monitor()) {\n@@ -1145,7 +779,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n-    \/\/ Inflated monitor so header points to ObjectMonitor (tagged pointer).\n-    \/\/ The first stage of async deflation does not affect any field\n-    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n-    ObjectMonitor* monitor = read_monitor(mark);\n-    return monitor->is_entered(current) != 0;\n-  }\n@@ -1159,7 +786,1 @@\n-  markWord mark = read_stable_mark(obj);\n-\n-  if (LockingMode == LM_LEGACY && mark.has_locker()) {\n-    \/\/ stack-locked so header points into owner's stack.\n-    \/\/ owning_thread_from_monitor_owner() may also return null here:\n-    return Threads::owning_thread_from_stacklock(t_list, (address) mark.locker());\n-  }\n+  markWord mark = obj->mark_acquire();\n@@ -1167,1 +788,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n+  if (mark.is_fast_locked()) {\n@@ -1173,1 +794,1 @@\n-  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+  while (mark.has_monitor()) {\n@@ -1187,10 +808,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n-    \/\/ Inflated monitor so header points to ObjectMonitor (tagged pointer).\n-    \/\/ The first stage of async deflation does not affect any field\n-    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n-    ObjectMonitor* monitor = read_monitor(mark);\n-    assert(monitor != nullptr, \"monitor should be non-null\");\n-    \/\/ owning_thread_from_monitor() may also return null here:\n-    return Threads::owning_thread_from_monitor(t_list, monitor);\n-  }\n-\n@@ -1419,224 +1030,0 @@\n-static void post_monitor_inflate_event(EventJavaMonitorInflate* event,\n-                                       const oop obj,\n-                                       ObjectSynchronizer::InflateCause cause) {\n-  assert(event != nullptr, \"invariant\");\n-  const Klass* monitor_klass = obj->klass();\n-  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n-    return;\n-  }\n-  event->set_monitorClass(monitor_klass);\n-  event->set_address((uintptr_t)(void*)obj);\n-  event->set_cause((u1)cause);\n-  event->commit();\n-}\n-\n-\/\/ Fast path code shared by multiple functions\n-void ObjectSynchronizer::inflate_helper(oop obj) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n-  markWord mark = obj->mark_acquire();\n-  if (mark.has_monitor()) {\n-    ObjectMonitor* monitor = read_monitor(mark);\n-    markWord dmw = monitor->header();\n-    assert(dmw.is_neutral(), \"sanity check: header=\" INTPTR_FORMAT, dmw.value());\n-    return;\n-  }\n-  (void)inflate(Thread::current(), obj, inflate_cause_vm_internal);\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop obj, const InflateCause cause) {\n-  assert(current == Thread::current(), \"must be\");\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n-  return inflate_impl(current->is_Java_thread() ? JavaThread::cast(current) : nullptr, obj, cause);\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate_for(JavaThread* thread, oop obj, const InflateCause cause) {\n-  assert(thread == Thread::current() || thread->is_obj_deopt_suspend(), \"must be\");\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_for\");\n-  return inflate_impl(thread, obj, cause);\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* locking_thread, oop object, const InflateCause cause) {\n-  \/\/ The JavaThread* locking_thread requires that the locking_thread == Thread::current() or\n-  \/\/ is suspended throughout the call by some other mechanism.\n-  \/\/ The thread might be nullptr when called from a non JavaThread. (As may still be\n-  \/\/ the case from FastHashCode). However it is only important for correctness that the\n-  \/\/ thread is set when called from ObjectSynchronizer::enter from the owning thread,\n-  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_impl\");\n-  EventJavaMonitorInflate event;\n-\n-  for (;;) {\n-    const markWord mark = object->mark_acquire();\n-\n-    \/\/ The mark can be in one of the following states:\n-    \/\/ *  inflated     - If the ObjectMonitor owner is anonymous and the\n-    \/\/                   locking_thread owns the object lock, then we\n-    \/\/                   make the locking_thread the ObjectMonitor owner.\n-    \/\/ *  stack-locked - Coerce it to inflated from stack-locked.\n-    \/\/ *  INFLATING    - Busy wait for conversion from stack-locked to\n-    \/\/                   inflated.\n-    \/\/ *  unlocked     - Aggressively inflate the object.\n-\n-    \/\/ CASE: inflated\n-    if (mark.has_monitor()) {\n-      ObjectMonitor* inf = mark.monitor();\n-      markWord dmw = inf->header();\n-      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n-      if (inf->has_anonymous_owner() && locking_thread != nullptr) {\n-        assert(LockingMode == LM_LEGACY, \"invariant\");\n-        if (locking_thread->is_lock_owned((address)inf->stack_locker())) {\n-          inf->set_stack_locker(nullptr);\n-          inf->set_owner_from_anonymous(locking_thread);\n-        }\n-      }\n-      return inf;\n-    }\n-\n-    \/\/ CASE: inflation in progress - inflating over a stack-lock.\n-    \/\/ Some other thread is converting from stack-locked to inflated.\n-    \/\/ Only that thread can complete inflation -- other threads must wait.\n-    \/\/ The INFLATING value is transient.\n-    \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n-    \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n-    if (mark == markWord::INFLATING()) {\n-      read_stable_mark(object);\n-      continue;\n-    }\n-\n-    \/\/ CASE: stack-locked\n-    \/\/ Could be stack-locked either by current or by some other thread.\n-    \/\/\n-    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_ attempting\n-    \/\/ to install INFLATING into the mark word.  We originally installed INFLATING,\n-    \/\/ allocated the ObjectMonitor, and then finally STed the address of the\n-    \/\/ ObjectMonitor into the mark.  This was correct, but artificially lengthened\n-    \/\/ the interval in which INFLATING appeared in the mark, thus increasing\n-    \/\/ the odds of inflation contention. If we lose the race to set INFLATING,\n-    \/\/ then we just delete the ObjectMonitor and loop around again.\n-    \/\/\n-    LogStreamHandle(Trace, monitorinflation) lsh;\n-    if (LockingMode == LM_LEGACY && mark.has_locker()) {\n-      ObjectMonitor* m = new ObjectMonitor(object);\n-      \/\/ Optimistically prepare the ObjectMonitor - anticipate successful CAS\n-      \/\/ We do this before the CAS in order to minimize the length of time\n-      \/\/ in which INFLATING appears in the mark.\n-\n-      markWord cmp = object->cas_set_mark(markWord::INFLATING(), mark);\n-      if (cmp != mark) {\n-        delete m;\n-        continue;       \/\/ Interference -- just retry\n-      }\n-\n-      \/\/ We've successfully installed INFLATING (0) into the mark-word.\n-      \/\/ This is the only case where 0 will appear in a mark-word.\n-      \/\/ Only the singular thread that successfully swings the mark-word\n-      \/\/ to 0 can perform (or more precisely, complete) inflation.\n-      \/\/\n-      \/\/ Why do we CAS a 0 into the mark-word instead of just CASing the\n-      \/\/ mark-word from the stack-locked value directly to the new inflated state?\n-      \/\/ Consider what happens when a thread unlocks a stack-locked object.\n-      \/\/ It attempts to use CAS to swing the displaced header value from the\n-      \/\/ on-stack BasicLock back into the object header.  Recall also that the\n-      \/\/ header value (hash code, etc) can reside in (a) the object header, or\n-      \/\/ (b) a displaced header associated with the stack-lock, or (c) a displaced\n-      \/\/ header in an ObjectMonitor.  The inflate() routine must copy the header\n-      \/\/ value from the BasicLock on the owner's stack to the ObjectMonitor, all\n-      \/\/ the while preserving the hashCode stability invariants.  If the owner\n-      \/\/ decides to release the lock while the value is 0, the unlock will fail\n-      \/\/ and control will eventually pass from slow_exit() to inflate.  The owner\n-      \/\/ will then spin, waiting for the 0 value to disappear.   Put another way,\n-      \/\/ the 0 causes the owner to stall if the owner happens to try to\n-      \/\/ drop the lock (restoring the header from the BasicLock to the object)\n-      \/\/ while inflation is in-progress.  This protocol avoids races that might\n-      \/\/ would otherwise permit hashCode values to change or \"flicker\" for an object.\n-      \/\/ Critically, while object->mark is 0 mark.displaced_mark_helper() is stable.\n-      \/\/ 0 serves as a \"BUSY\" inflate-in-progress indicator.\n-\n-\n-      \/\/ fetch the displaced mark from the owner's stack.\n-      \/\/ The owner can't die or unwind past the lock while our INFLATING\n-      \/\/ object is in the mark.  Furthermore the owner can't complete\n-      \/\/ an unlock on the object, either.\n-      markWord dmw = mark.displaced_mark_helper();\n-      \/\/ Catch if the object's header is not neutral (not locked and\n-      \/\/ not marked is what we care about here).\n-      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n-\n-      \/\/ Setup monitor fields to proper values -- prepare the monitor\n-      m->set_header(dmw);\n-\n-      \/\/ Note that a thread can inflate an object\n-      \/\/ that it has stack-locked -- as might happen in wait() -- directly\n-      \/\/ with CAS.  That is, we can avoid the xchg-nullptr .... ST idiom.\n-      if (locking_thread != nullptr && locking_thread->is_lock_owned((address)mark.locker())) {\n-        m->set_owner(locking_thread);\n-      } else {\n-        \/\/ Use ANONYMOUS_OWNER to indicate that the owner is the BasicLock on the stack,\n-        \/\/ and set the stack locker field in the monitor.\n-        m->set_stack_locker(mark.locker());\n-        m->set_anonymous_owner();\n-      }\n-      \/\/ TODO-FIXME: assert BasicLock->dhw != 0.\n-\n-      \/\/ Must preserve store ordering. The monitor state must\n-      \/\/ be stable at the time of publishing the monitor address.\n-      guarantee(object->mark() == markWord::INFLATING(), \"invariant\");\n-      \/\/ Release semantics so that above set_object() is seen first.\n-      object->release_set_mark(markWord::encode(m));\n-\n-      \/\/ Once ObjectMonitor is configured and the object is associated\n-      \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n-      _in_use_list.add(m);\n-\n-      if (log_is_enabled(Trace, monitorinflation)) {\n-        ResourceMark rm;\n-        lsh.print_cr(\"inflate(has_locker): object=\" INTPTR_FORMAT \", mark=\"\n-                     INTPTR_FORMAT \", type='%s'\", p2i(object),\n-                     object->mark().value(), object->klass()->external_name());\n-      }\n-      if (event.should_commit()) {\n-        post_monitor_inflate_event(&event, object, cause);\n-      }\n-      return m;\n-    }\n-\n-    \/\/ CASE: unlocked\n-    \/\/ TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n-    \/\/ If we know we're inflating for entry it's better to inflate by swinging a\n-    \/\/ pre-locked ObjectMonitor pointer into the object header.   A successful\n-    \/\/ CAS inflates the object *and* confers ownership to the inflating thread.\n-    \/\/ In the current implementation we use a 2-step mechanism where we CAS()\n-    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n-    \/\/ An inflateTry() method that we could call from enter() would be useful.\n-\n-    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n-    ObjectMonitor* m = new ObjectMonitor(object);\n-    \/\/ prepare m for installation - set monitor to initial state\n-    m->set_header(mark);\n-\n-    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n-      delete m;\n-      m = nullptr;\n-      continue;\n-      \/\/ interference - the markword changed - just retry.\n-      \/\/ The state-transitions are one-way, so there's no chance of\n-      \/\/ live-lock -- \"Inflated\" is an absorbing state.\n-    }\n-\n-    \/\/ Once the ObjectMonitor is configured and object is associated\n-    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n-    _in_use_list.add(m);\n-\n-    if (log_is_enabled(Trace, monitorinflation)) {\n-      ResourceMark rm;\n-      lsh.print_cr(\"inflate(unlocked): object=\" INTPTR_FORMAT \", mark=\"\n-                   INTPTR_FORMAT \", type='%s'\", p2i(object),\n-                   object->mark().value(), object->klass()->external_name());\n-    }\n-    if (event.should_commit()) {\n-      post_monitor_inflate_event(&event, object, cause);\n-    }\n-    return m;\n-  }\n-}\n-\n@@ -1918,1 +1305,0 @@\n-    case inflate_cause_hash_code:      return \"Monitor Hash Code\";\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":35,"deletions":649,"binary":false,"changes":684,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n- public:\n+public:\n@@ -82,4 +82,3 @@\n-    inflate_cause_hash_code = 4,\n-    inflate_cause_jni_enter = 5,\n-    inflate_cause_jni_exit = 6,\n-    inflate_cause_nof = 7 \/\/ Number of causes\n+    inflate_cause_jni_enter = 4,\n+    inflate_cause_jni_exit = 5,\n+    inflate_cause_nof = 6 \/\/ Number of causes\n@@ -107,4 +106,0 @@\n-private:\n-  \/\/ Shared implementation for enter and enter_for. Performs all but\n-  \/\/ inflated monitor enter.\n-  static bool enter_fast_impl(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n@@ -112,4 +107,0 @@\n-  static bool quick_enter_legacy(oop obj, BasicLock* Lock, JavaThread* current);\n-  static void enter_legacy(Handle obj, BasicLock* Lock, JavaThread* current);\n-  static void exit_legacy(oop obj, BasicLock* lock, JavaThread* current);\n-public:\n@@ -134,9 +125,0 @@\n-  \/\/ Inflate light weight monitor to heavy weight monitor\n-  static ObjectMonitor* inflate(Thread* current, oop obj, const InflateCause cause);\n-  \/\/ Used to inflate a monitor as if it was done from the thread JavaThread.\n-  static ObjectMonitor* inflate_for(JavaThread* thread, oop obj, const InflateCause cause);\n-\n-private:\n-  \/\/ Shared implementation between the different LockingMode.\n-  static ObjectMonitor* inflate_impl(JavaThread* locking_thread, oop obj, const InflateCause cause);\n-\n@@ -144,2 +126,0 @@\n-  \/\/ This version is only for internal use\n-  static void inflate_helper(oop obj);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -50,3 +49,0 @@\n-  } else {\n-    enter_legacy(obj, lock, current);\n-  }\n@@ -64,5 +60,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    return LightweightSynchronizer::quick_enter(obj, lock, current);\n-  } else {\n-    return quick_enter_legacy(obj, lock, current);\n-  }\n+  return LightweightSynchronizer::quick_enter(obj, lock, current);\n@@ -74,5 +66,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    LightweightSynchronizer::exit(object, lock, current);\n-  } else {\n-    exit_legacy(object, lock, current);\n-  }\n+  LightweightSynchronizer::exit(object, lock, current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1297,13 +1297,0 @@\n-JavaThread *Threads::owning_thread_from_stacklock(ThreadsList * t_list, address basicLock) {\n-  assert(LockingMode == LM_LEGACY, \"Not with new lightweight locking\");\n-\n-  JavaThread* the_owner = nullptr;\n-  for (JavaThread* q : *t_list) {\n-    if (q->is_lock_owned(basicLock)) {\n-      the_owner = q;\n-      break;\n-    }\n-  }\n-  return the_owner;\n-}\n-\n@@ -1311,1 +1298,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"Only with new lightweight locking\");\n@@ -1328,6 +1314,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      return owning_thread_from_object(t_list, monitor->object());\n-    } else {\n-      assert(LockingMode == LM_LEGACY, \"invariant\");\n-      return owning_thread_from_stacklock(t_list, (address)monitor->stack_locker());\n-    }\n+    return owning_thread_from_object(t_list, monitor->object());\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,3 +137,0 @@\n-  \/\/ Get owning Java thread from the basicLock address.\n-  static JavaThread *owning_thread_from_stacklock(ThreadsList * t_list, address basicLock);\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -677,1 +677,0 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _stack_locker,                                 BasicLock*)                            \\\n@@ -1644,8 +1643,0 @@\n-  \/**********************************************\/                        \\\n-  \/* LockingMode enum (globalDefinitions.hpp) *\/                          \\\n-  \/**********************************************\/                        \\\n-                                                                          \\\n-  declare_constant(LM_MONITOR)                                            \\\n-  declare_constant(LM_LEGACY)                                             \\\n-  declare_constant(LM_LIGHTWEIGHT)                                        \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-const int LockingMode = LM_LIGHTWEIGHT;\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1012,11 +1012,0 @@\n-enum LockingMode {\n-  \/\/ Use only heavy monitors for locking\n-  LM_MONITOR     = 0,\n-  \/\/ Legacy stack-locking, with monitors as 2nd tier\n-  LM_LEGACY      = 1,\n-  \/\/ New lightweight locking, with monitors as 2nd tier\n-  LM_LIGHTWEIGHT = 2\n-};\n-\n-extern const int LockingMode;\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1081,1 +1081,1 @@\n-  STEP_IF(\"printing lock stack\", _verbose && _thread != nullptr && _thread->is_Java_thread() && LockingMode == LM_LIGHTWEIGHT);\n+  STEP_IF(\"printing lock stack\", _verbose && _thread != nullptr && _thread->is_Java_thread());\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,0 @@\n-    f = type.getField(\"_stack_locker\");\n-    stackLockerFieldOffset = f.getOffset();\n@@ -92,1 +90,0 @@\n-  public Address stackLocker() { return addr.getAddressAt(stackLockerFieldOffset); }\n@@ -123,1 +120,0 @@\n-  private static long          stackLockerFieldOffset;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT || !VM_Version::supports_recursive_lightweight_locking()) {\n+  if (!VM_Version::supports_recursive_lightweight_locking()) {\n@@ -133,1 +133,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT || !VM_Version::supports_recursive_lightweight_locking()) {\n+  if (!VM_Version::supports_recursive_lightweight_locking()) {\n@@ -200,4 +200,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    return;\n-  }\n-\n@@ -266,4 +262,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    return;\n-  }\n-\n","filename":"test\/hotspot\/gtest\/runtime\/test_lockStack.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -56,3 +56,0 @@\n-        if (WB.getBooleanVMFlag(\"VerifyHeavyMonitors\")) {\n-            throw new SkippedException(\"VerifyHeavyMonitors always inflates. Invalid test.\");\n-        }\n","filename":"test\/hotspot\/jtreg\/runtime\/locking\/TestRecursiveMonitorChurn.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}