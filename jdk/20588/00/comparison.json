{"files":[{"patch":"@@ -259,1 +259,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.jfr;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import jdk.internal.vm.Continuation;\n+import jdk.internal.vm.ContinuationSupport;\n@@ -74,9 +76,39 @@\n-    \/* synchronized because of writing the string to the JVM. *\/\n-    private static synchronized long storeString(String s) {\n-        Long lsid = cache.get(s);\n-        long internalSid;\n-        if (lsid != null) {\n-            internalSid = lsid.longValue();\n-            if (isCurrentGeneration(internalSid)) {\n-                \/\/ Someone already updated the cache.\n-                return externalSid(internalSid);\n+    \/* Explicitly pin a virtual thread before acquiring the string pool monitor\n+     * because migrating the EventWriter onto another carrier thread is impossible.\n+     *\/\n+    private static void pinVirtualThread() {\n+        if (Thread.currentThread().isVirtual() && ContinuationSupport.isSupported()) {\n+            Continuation.pin();\n+        }\n+    }\n+\n+    private static void unpinVirtualThread() {\n+        if (Thread.currentThread().isVirtual() && ContinuationSupport.isSupported()) {\n+            Continuation.unpin();\n+        }\n+    }\n+\n+    private static long storeString(String s) {\n+        try {\n+            pinVirtualThread();\n+            \/* synchronized because of writing the string to the JVM. *\/\n+            synchronized (StringPool.class) {\n+                Long lsid = cache.get(s);\n+                long internalSid;\n+                if (lsid != null) {\n+                    internalSid = lsid.longValue();\n+                    if (isCurrentGeneration(internalSid)) {\n+                        \/\/ Someone already updated the cache.\n+                        return externalSid(internalSid);\n+                    }\n+                    internalSid = updateInternalSid(internalSid);\n+                } else {\n+                    \/\/ Not yet added or the cache was cleared.\n+                    internalSid = nextInternalSid();\n+                    currentSizeUTF16 += s.length();\n+                }\n+                long extSid = externalSid(internalSid);\n+                \/\/ Write the string to the JVM before publishing to the cache.\n+                JVM.addStringConstant(extSid, s);\n+                cache.put(s, internalSid);\n+                return extSid;\n@@ -84,5 +116,2 @@\n-            internalSid = updateInternalSid(internalSid);\n-        } else {\n-            \/\/ Not yet added or the cache was cleared.\n-            internalSid = nextInternalSid();\n-            currentSizeUTF16 += s.length();\n+        } finally {\n+            unpinVirtualThread();\n@@ -90,5 +119,0 @@\n-        long extSid = externalSid(internalSid);\n-        \/\/ Write the string to the JVM before publishing to the cache.\n-        JVM.addStringConstant(extSid, s);\n-        cache.put(s, internalSid);\n-        return extSid;\n@@ -146,3 +170,10 @@\n-    private static synchronized void reset() {\n-        cache.clear();\n-        currentSizeUTF16 = 0;\n+    private static void reset() {\n+        try {\n+            pinVirtualThread();\n+            synchronized (StringPool.class) {\n+                cache.clear();\n+                currentSizeUTF16 = 0;\n+            }\n+        } finally {\n+            unpinVirtualThread();\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":54,"deletions":23,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.threading;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ThreadFactory;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8338417\n+ * @summary Tests pinning of virtual threads when the JFR string pool monitor is contended.\n+ * @key jfr\n+ * @requires vm.hasJFR & vm.continuations\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.threading.TestStringPoolVirtualThreadPinning\n+ *\/\n+public class TestStringPoolVirtualThreadPinning {\n+\n+    private static final int VIRTUAL_THREAD_COUNT = 100_000;\n+    private static final int STARTER_THREADS = 10;\n+\n+    @Name(\"test.Tester\")\n+    private static class TestEvent extends Event {\n+        private String eventString = Thread.currentThread().getName();\n+    }\n+\n+    \/*\n+     * During event commit, the thread is in a critical section because it has loaded a carrier thread local event writer object.\n+     * For virtual threads, a contended monitor, such as a synchronized block, is a point where a thread could become unmounted.\n+     * A monitor guards the JFR string pool, but because of the event writer, remounting a virtual thread onto another carrier is impossible.\n+     *\n+     * The test provokes JFR string pool monitor contention to exercise explicit pin constructs to ensure the pinning of virtual threads.\n+    *\/\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+\n+            ThreadFactory factory = Thread.ofVirtual().factory();\n+            CompletableFuture<?>[] c = new CompletableFuture[STARTER_THREADS];\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j] = CompletableFuture.runAsync(() -> {\n+                    for (int i = 0; i < VIRTUAL_THREAD_COUNT \/ STARTER_THREADS; i++) {\n+                        try {\n+                            Thread vt = factory.newThread(TestStringPoolVirtualThreadPinning::emitEvent);\n+                            \/\/ For a thread to be placed in the JFR string pool, it must exceed 16 chars.\n+                            vt.setName(\"VirtualTestThread-\" + i);\n+                            vt.start();\n+                            vt.join();\n+                        } catch (InterruptedException ie) {\n+                            ie.printStackTrace();\n+                        }\n+                    }\n+                });\n+            }\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j].get();\n+            }\n+\n+            r.stop();\n+            Path p = Utils.createTempFile(\"test\", \".jfr\");\n+            r.dump(p);\n+            List<RecordedEvent> events = RecordingFile.readAllEvents(p);\n+            Asserts.assertEquals(events.size(), VIRTUAL_THREAD_COUNT, \"Expected \" + VIRTUAL_THREAD_COUNT + \" events\");\n+            for (RecordedEvent e : events) {\n+                RecordedThread t = e.getThread();\n+                Asserts.assertNotNull(t);\n+                Asserts.assertTrue(t.isVirtual());\n+                Asserts.assertEquals(e.getString(\"eventString\"), t.getJavaName());\n+            }\n+        }\n+    }\n+\n+    private static void emitEvent() {\n+        TestEvent t = new TestEvent();\n+        t.commit();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestStringPoolVirtualThreadPinning.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}