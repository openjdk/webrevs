{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -52,0 +53,1 @@\n+static int pin_offset = invalid_offset;\n@@ -101,0 +103,7 @@\n+\n+  const char pin_name[] = \"pinVirtualThread\";\n+  Symbol* const pin_sym = SymbolTable::new_symbol(valid_name);\n+  assert(pin_sym != nullptr, \"invariant\");\n+  assert(invalid_offset == pin_offset, \"invariant\");\n+  JfrJavaSupport::compute_field_offset(pin_offset, klass, pin_sym, vmSymbols::bool_signature());\n+  assert(pin_offset != invalid_offset, \"invariant\");\n@@ -222,0 +231,5 @@\n+static inline bool pin_virtual(const JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  return JfrThreadLocal::is_vthread(jt) && VMContinuations;\n+}\n+\n@@ -228,1 +242,1 @@\n-  static const char signature[] = \"(JJJZZ)V\";\n+  static const char signature[] = \"(JJJZZZ)V\";\n@@ -237,0 +251,1 @@\n+  args.push_int(pin_virtual(THREAD) ? (jint)JNI_TRUE : (jint)JNI_FALSE);\n@@ -252,0 +267,1 @@\n+      writer->long_field_put(thread_id_offset, current_tid);\n@@ -254,1 +270,3 @@\n-      writer->long_field_put(thread_id_offset, current_tid);\n+      if (!excluded) {\n+        writer->bool_field_put(pin_offset, pin_virtual(jt));\n+      }\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3233,0 +3233,1 @@\n+ * bool pinVirtualThread;\n@@ -3237,0 +3238,1 @@\n+ *   pinVirtualThread = VMContinuations;\n@@ -3248,0 +3250,1 @@\n+ *   pinVirtualThread = false;\n@@ -3253,1 +3256,1 @@\n- *   setField(event_writer, \"threadID\", tid);\n+ *   setField(event_writer, \"pinVirtualThread\", pinVirtualThread);\n@@ -3255,0 +3258,1 @@\n+ *   setField(event_writer, \"threadID\", tid);\n@@ -3325,0 +3329,4 @@\n+  \/\/ Continuation support determines if a virtual thread should be pinned.\n+  Node* global_addr = makecon(TypeRawPtr::make((address)&VMContinuations));\n+  Node* continuation_support = make_load(control(), global_addr, TypeInt::BOOL, T_BOOLEAN, MemNode::unordered);\n+\n@@ -3415,0 +3423,2 @@\n+  PhiNode* pinVirtualThread = new PhiNode(vthread_compare_rgn, TypeInt::BOOL);\n+  record_for_igvn(pinVirtualThread);\n@@ -3427,0 +3437,2 @@\n+  pinVirtualThread->init_req(_true_path, _gvn.transform(continuation_support));\n+  pinVirtualThread->init_req(_false_path, _gvn.intcon(0));\n@@ -3450,0 +3462,3 @@\n+  \/\/ Get the field offset to, conditionally, store an updated pinVirtualThread value later.\n+  Node* const event_writer_pin_field = field_address_from_object(event_writer, \"pinVirtualThread\", \"Z\", false);\n+  const TypePtr* event_writer_pin_field_type = _gvn.type(event_writer_pin_field)->isa_ptr();\n@@ -3470,0 +3485,3 @@\n+  \/\/ Store the pin state to the event writer.\n+  store_to_memory(tid_is_not_equal, event_writer_pin_field, _gvn.transform(pinVirtualThread), T_BOOLEAN, event_writer_pin_field_type, MemNode::unordered);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -259,1 +259,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.jfr;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.Continuation;\n@@ -74,9 +75,35 @@\n-    \/* synchronized because of writing the string to the JVM. *\/\n-    private static synchronized long storeString(String s) {\n-        Long lsid = cache.get(s);\n-        long internalSid;\n-        if (lsid != null) {\n-            internalSid = lsid.longValue();\n-            if (isCurrentGeneration(internalSid)) {\n-                \/\/ Someone already updated the cache.\n-                return externalSid(internalSid);\n+    \/* Explicitly pin a virtual thread before acquiring the string pool monitor\n+     * because migrating the EventWriter onto another carrier thread is impossible.\n+     *\/\n+    private static long storeString(String s, boolean pinVirtualThread) {\n+        if (pinVirtualThread) {\n+            assert(Thread.currentThread().isVirtual());\n+            Continuation.pin();\n+        }\n+        try {\n+            \/* synchronized because of writing the string to the JVM. *\/\n+            synchronized (StringPool.class) {\n+                Long lsid = cache.get(s);\n+                long internalSid;\n+                if (lsid != null) {\n+                    internalSid = lsid.longValue();\n+                    if (isCurrentGeneration(internalSid)) {\n+                        \/\/ Someone already updated the cache.\n+                        return externalSid(internalSid);\n+                    }\n+                    internalSid = updateInternalSid(internalSid);\n+                } else {\n+                    \/\/ Not yet added or the cache was cleared.\n+                    internalSid = nextInternalSid();\n+                    currentSizeUTF16 += s.length();\n+                }\n+                long extSid = externalSid(internalSid);\n+                \/\/ Write the string to the JVM before publishing to the cache.\n+                JVM.addStringConstant(extSid, s);\n+                cache.put(s, internalSid);\n+                return extSid;\n+            }\n+        } finally {\n+            if (pinVirtualThread) {\n+                assert(Thread.currentThread().isVirtual());\n+                Continuation.unpin();\n@@ -84,5 +111,0 @@\n-            internalSid = updateInternalSid(internalSid);\n-        } else {\n-            \/\/ Not yet added or the cache was cleared.\n-            internalSid = nextInternalSid();\n-            currentSizeUTF16 += s.length();\n@@ -90,5 +112,0 @@\n-        long extSid = externalSid(internalSid);\n-        \/\/ Write the string to the JVM before publishing to the cache.\n-        JVM.addStringConstant(extSid, s);\n-        cache.put(s, internalSid);\n-        return extSid;\n@@ -98,1 +115,1 @@\n-    private static long ensureCurrentGeneration(String s, Long lsid) {\n+    private static long ensureCurrentGeneration(String s, Long lsid, boolean pinVirtualThread) {\n@@ -100,1 +117,1 @@\n-        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s);\n+        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s, pinVirtualThread);\n@@ -112,1 +129,1 @@\n-    public static long addString(String s) {\n+    public static long addString(String s, boolean pinVirtualThread) {\n@@ -115,1 +132,1 @@\n-            return ensureCurrentGeneration(s, lsid);\n+            return ensureCurrentGeneration(s, lsid, pinVirtualThread);\n@@ -123,1 +140,1 @@\n-            reset();\n+            reset(pinVirtualThread);\n@@ -125,1 +142,1 @@\n-        return storeString(s);\n+        return storeString(s, pinVirtualThread);\n@@ -146,3 +163,16 @@\n-    private static synchronized void reset() {\n-        cache.clear();\n-        currentSizeUTF16 = 0;\n+    private static void reset(boolean pinVirtualThread) {\n+        if (pinVirtualThread) {\n+            assert(Thread.currentThread().isVirtual());\n+            Continuation.pin();\n+        }\n+        try {\n+            synchronized (StringPool.class) {\n+                cache.clear();\n+                currentSizeUTF16 = 0;\n+            }\n+        } finally {\n+            if (pinVirtualThread) {\n+                assert(Thread.currentThread().isVirtual());\n+                Continuation.unpin();\n+            }\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":59,"deletions":29,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+    private boolean pinVirtualThread;\n@@ -147,1 +148,1 @@\n-            long l = StringPool.addString(s);\n+            long l = StringPool.addString(s, pinVirtualThread);\n@@ -299,1 +300,1 @@\n-    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean excluded) {\n+    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean pinVirtualThread, boolean excluded) {\n@@ -304,0 +305,1 @@\n+        this.pinVirtualThread = pinVirtualThread;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.threading;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ThreadFactory;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8338417\n+ * @summary Tests pinning of virtual threads when the JFR string pool monitor is contended.\n+ * @key jfr\n+ * @requires vm.hasJFR & vm.continuations\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.threading.TestStringPoolVirtualThreadPinning\n+ *\/\n+public class TestStringPoolVirtualThreadPinning {\n+\n+    private static final int VIRTUAL_THREAD_COUNT = 100_000;\n+    private static final int STARTER_THREADS = 10;\n+\n+    @Name(\"test.Tester\")\n+    private static class TestEvent extends Event {\n+        private String eventString = Thread.currentThread().getName();\n+    }\n+\n+    \/*\n+     * During event commit, the thread is in a critical section because it has loaded a carrier thread local event writer object.\n+     * For virtual threads, a contended monitor, such as a synchronized block, is a point where a thread could become unmounted.\n+     * A monitor guards the JFR string pool, but because of the event writer, remounting a virtual thread onto another carrier is impossible.\n+     *\n+     * The test provokes JFR string pool monitor contention to exercise explicit pin constructs to ensure the pinning of virtual threads.\n+    *\/\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+\n+            ThreadFactory factory = Thread.ofVirtual().factory();\n+            CompletableFuture<?>[] c = new CompletableFuture[STARTER_THREADS];\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j] = CompletableFuture.runAsync(() -> {\n+                    for (int i = 0; i < VIRTUAL_THREAD_COUNT \/ STARTER_THREADS; i++) {\n+                        try {\n+                            Thread vt = factory.newThread(TestStringPoolVirtualThreadPinning::emitEvent);\n+                            \/\/ For an event field string to be placed in the JFR string pool, it must exceed 16 characters.\n+                            \/\/ We use the virtual thread name as the event field string so we can verify the result as a 1-1 mapping.\n+                            vt.setName(\"VirtualTestThread-\" + i);\n+                            vt.start();\n+                            vt.join();\n+                        } catch (InterruptedException ie) {\n+                            ie.printStackTrace();\n+                        }\n+                    }\n+                });\n+            }\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j].get();\n+            }\n+\n+            r.stop();\n+            Path p = Utils.createTempFile(\"test\", \".jfr\");\n+            r.dump(p);\n+            List<RecordedEvent> events = RecordingFile.readAllEvents(p);\n+            Asserts.assertEquals(events.size(), VIRTUAL_THREAD_COUNT, \"Expected \" + VIRTUAL_THREAD_COUNT + \" events\");\n+            for (RecordedEvent e : events) {\n+                RecordedThread t = e.getThread();\n+                Asserts.assertNotNull(t);\n+                Asserts.assertTrue(t.isVirtual());\n+                Asserts.assertEquals(e.getString(\"eventString\"), t.getJavaName());\n+            }\n+        }\n+    }\n+\n+    private static void emitEvent() {\n+        TestEvent t = new TestEvent();\n+        t.commit();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestStringPoolVirtualThreadPinning.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"}]}