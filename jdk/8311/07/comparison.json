{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,4 @@\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n+import java.lang.ref.Reference;\n+\n@@ -43,0 +47,1 @@\n+    private static final Cleaner LDAP_CLEANER = Cleaner.create();\n@@ -45,3 +50,0 @@\n-    private boolean cleaned = false;\n-    private LdapResult res;\n-    private LdapClient enumClnt;\n@@ -52,1 +54,1 @@\n-    protected LdapCtx homeCtx;\n+\n@@ -56,0 +58,43 @@\n+    \/* This class maintains the pieces of state that need to be cleaned up (or\n+     * are needed for cleanup). It gets registered with Cleaner to perform cleanup.\n+     * Because the state is mutable, synchronization is used to ensure that all\n+     * updates made by the program thread are seen by the cleanup thread.\n+     *\/\n+    private static class EnumCtx implements Runnable {\n+        \/\/ Only update these variables using the set* methods below\n+        private LdapCtx homeCtx;\n+        private LdapResult res;\n+        private LdapClient enumClnt;\n+\n+        private EnumCtx(LdapCtx homeCtx, LdapResult answer, LdapClient client) {\n+            this.homeCtx = homeCtx;\n+            this.res = answer;\n+            this.enumClnt = client;\n+        }\n+\n+        private synchronized void setRes(LdapResult newRes) { this.res = newRes; }\n+        private synchronized void setHomeCtx(LdapCtx newCtx) { this.homeCtx = newCtx; }\n+        private synchronized void setEnumClnt(LdapClient newClnt) { this.enumClnt = newClnt; }\n+\n+        @Override\n+        public synchronized void run() {\n+            if (enumClnt != null) {\n+                if (homeCtx != null) {\n+                    enumClnt.clearSearchReply(res, homeCtx.reqCtls);\n+                }\n+                enumClnt = null;\n+            }\n+            if (homeCtx != null) {\n+                homeCtx.decEnumCount();\n+                homeCtx = null;\n+            }\n+        }\n+    }\n+\n+    private final EnumCtx enumCtx;\n+    private final Cleanable cleanable;\n+\n+    \/\/ Subclasses interact directly with the LdapCtx. This method provides\n+    \/\/ access to the LdapCtx in the EnumCtx.\n+    protected final LdapCtx homeCtx() { return enumCtx.homeCtx; }\n+\n@@ -87,1 +132,0 @@\n-            res = answer;\n@@ -97,0 +141,1 @@\n+            this.enumCtx = new EnumCtx(homeCtx, answer, homeCtx.clnt);\n@@ -98,3 +143,2 @@\n-            this.homeCtx = homeCtx;\n-            homeCtx.incEnumCount();\n-            enumClnt = homeCtx.clnt; \/\/ remember\n+            this.enumCtx.homeCtx.incEnumCount();\n+            this.cleanable = LDAP_CLEANER.register(this, enumCtx);\n@@ -129,0 +173,7 @@\n+        try {\n+            LdapResult newRes = homeCtx().getSearchReply(enumCtx.enumClnt, enumCtx.res);\n+            enumCtx.setRes(newRes);\n+            if (enumCtx.res == null) {\n+                limit = posn = 0;\n+                return;\n+            }\n@@ -130,9 +181,3 @@\n-        res = homeCtx.getSearchReply(enumClnt, res);\n-        if (res == null) {\n-            limit = posn = 0;\n-            return;\n-        }\n-\n-        entries = res.entries;\n-        limit = (entries == null) ? 0 : entries.size(); \/\/ handle empty set\n-        posn = 0; \/\/ reset\n+            entries = enumCtx.res.entries;\n+            limit = (entries == null) ? 0 : entries.size(); \/\/ handle empty set\n+            posn = 0; \/\/ reset\n@@ -140,5 +185,5 @@\n-        \/\/ minimize the number of calls to processReturnCode()\n-        \/\/ (expensive when batchSize is small and there are many results)\n-        if ((res.status != LdapClient.LDAP_SUCCESS) ||\n-            ((res.status == LdapClient.LDAP_SUCCESS) &&\n-                (res.referrals != null))) {\n+            \/\/ minimize the number of calls to processReturnCode()\n+            \/\/ (expensive when batchSize is small and there are many results)\n+            if ((enumCtx.res.status != LdapClient.LDAP_SUCCESS) ||\n+                ((enumCtx.res.status == LdapClient.LDAP_SUCCESS) &&\n+                    (enumCtx.res.referrals != null))) {\n@@ -146,3 +191,3 @@\n-            try {\n-                \/\/ convert referrals into a chain of LdapReferralException\n-                homeCtx.processReturnCode(res, listArg);\n+                try {\n+                    \/\/ convert referrals into a chain of LdapReferralException\n+                    homeCtx().processReturnCode(enumCtx.res, listArg);\n@@ -150,2 +195,2 @@\n-            } catch (LimitExceededException | PartialResultException e) {\n-                setNamingException(e);\n+                } catch (LimitExceededException | PartialResultException e) {\n+                    setNamingException(e);\n@@ -153,0 +198,1 @@\n+                }\n@@ -154,1 +200,0 @@\n-        }\n@@ -156,6 +201,8 @@\n-        \/\/ merge any newly received referrals with any current referrals\n-        if (res.refEx != null) {\n-            if (refEx == null) {\n-                refEx = res.refEx;\n-            } else {\n-                refEx = refEx.appendUnprocessedReferrals(res.refEx);\n+            \/\/ merge any newly received referrals with any current referrals\n+            if (enumCtx.res.refEx != null) {\n+                if (refEx == null) {\n+                    refEx = enumCtx.res.refEx;\n+                } else {\n+                    refEx = refEx.appendUnprocessedReferrals(enumCtx.res.refEx);\n+                }\n+                enumCtx.res.refEx = null; \/\/ reset\n@@ -163,2 +210,0 @@\n-            res.refEx = null; \/\/ reset\n-        }\n@@ -166,2 +211,6 @@\n-        if (res.resControls != null) {\n-            homeCtx.respCtls = res.resControls;\n+            if (enumCtx.res.resControls != null) {\n+                homeCtx().respCtls = enumCtx.res.resControls;\n+            }\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -312,0 +361,5 @@\n+        try {\n+            if ((refEx != null) &&\n+                (refEx.hasMoreReferrals() ||\n+                 refEx.hasMoreReferralExceptions()\n+                    && !(errEx instanceof LimitExceededException))) {\n@@ -313,4 +367,3 @@\n-        if ((refEx != null) &&\n-            (refEx.hasMoreReferrals() ||\n-             refEx.hasMoreReferralExceptions()\n-                && !(errEx instanceof LimitExceededException))) {\n+                if (homeCtx().handleReferrals == LdapClient.LDAP_REF_THROW) {\n+                    throw (NamingException)(refEx.fillInStackTrace());\n+                }\n@@ -318,3 +371,2 @@\n-            if (homeCtx.handleReferrals == LdapClient.LDAP_REF_THROW) {\n-                throw (NamingException)(refEx.fillInStackTrace());\n-            }\n+                \/\/ process the referrals sequentially\n+                while (true) {\n@@ -322,2 +374,3 @@\n-            \/\/ process the referrals sequentially\n-            while (true) {\n+                    LdapReferralContext refCtx =\n+                        (LdapReferralContext)refEx.getReferralContext(\n+                        homeCtx().envprops, homeCtx().reqCtls);\n@@ -325,3 +378,1 @@\n-                LdapReferralContext refCtx =\n-                    (LdapReferralContext)refEx.getReferralContext(\n-                    homeCtx.envprops, homeCtx.reqCtls);\n+                    try {\n@@ -329,1 +380,2 @@\n-                try {\n+                        update(getReferredResults(refCtx));\n+                        break;\n@@ -331,2 +383,1 @@\n-                    update(getReferredResults(refCtx));\n-                    break;\n+                    } catch (LdapReferralException re) {\n@@ -334,1 +385,6 @@\n-                } catch (LdapReferralException re) {\n+                        \/\/ record a previous exception\n+                        if (errEx == null) {\n+                            errEx = re.getNamingException();\n+                        }\n+                        refEx = re;\n+                        continue;\n@@ -336,3 +392,3 @@\n-                    \/\/ record a previous exception\n-                    if (errEx == null) {\n-                        errEx = re.getNamingException();\n+                    } finally {\n+                        \/\/ Make sure we close referral context\n+                        refCtx.close();\n@@ -340,6 +396,0 @@\n-                    refEx = re;\n-                    continue;\n-\n-                } finally {\n-                    \/\/ Make sure we close referral context\n-                    refCtx.close();\n@@ -347,2 +397,1 @@\n-            }\n-            return hasMoreImpl();\n+                return hasMoreImpl();\n@@ -350,2 +399,2 @@\n-        } else {\n-            cleanup();\n+            } else {\n+                cleanup();\n@@ -353,2 +402,4 @@\n-            if (errEx != null) {\n-                throw errEx;\n+                if (errEx != null) {\n+                    throw errEx;\n+                }\n+                return (false);\n@@ -356,1 +407,3 @@\n-            return (false);\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(enumCtx);\n@@ -365,24 +418,26 @@\n-        \/\/ Cleanup previous context first\n-        homeCtx.decEnumCount();\n-\n-        \/\/ New enum will have already incremented enum count and recorded clnt\n-        homeCtx = ne.homeCtx;\n-        enumClnt = ne.enumClnt;\n-\n-        \/\/ Do this to prevent referral enumeration (ne) from decrementing\n-        \/\/ enum count because we'll be doing that here from this\n-        \/\/ enumeration.\n-        ne.homeCtx = null;\n-\n-        \/\/ Record rest of information from new enum\n-        posn = ne.posn;\n-        limit = ne.limit;\n-        res = ne.res;\n-        entries = ne.entries;\n-        refEx = ne.refEx;\n-        listArg = ne.listArg;\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    protected final void finalize() {\n-        cleanup();\n+        try {\n+            \/\/ Cleanup previous context first\n+            homeCtx().decEnumCount();\n+\n+            \/\/ New enum will have already incremented enum count and recorded clnt\n+            enumCtx.setHomeCtx(ne.enumCtx.homeCtx);\n+            enumCtx.setEnumClnt(ne.enumCtx.enumClnt);\n+\n+            \/\/ 'this' and 'ne' now both refer to ne's homeCtx. 'this' will\n+            \/\/ decrement homeCtx's enum count later (via cleanup() or Cleaner).\n+            \/\/ Clear ne's reference to homeCtx so ne's Cleaner doesn't\n+            \/\/ *also* decrement the count.\n+            ne.enumCtx.setHomeCtx(null);\n+\n+            \/\/ Record rest of information from new enum\n+            posn = ne.posn;\n+            limit = ne.limit;\n+            enumCtx.setRes(ne.enumCtx.res);\n+            entries = ne.entries;\n+            refEx = ne.refEx;\n+            listArg = ne.listArg;\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(ne);\n+            Reference.reachabilityFence(this);\n+        }\n@@ -392,12 +447,2 @@\n-        if (cleaned) return; \/\/ been there; done that\n-\n-        if(enumClnt != null) {\n-            enumClnt.clearSearchReply(res, homeCtx.reqCtls);\n-        }\n-\n-        enumClnt = null;\n-        cleaned = true;\n-        if (homeCtx != null) {\n-            homeCtx.decEnumCount();\n-            homeCtx = null;\n-        }\n+        \/\/ Run the cleaning action (if it has not run already)\n+        cleanable.clean();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/AbstractLdapNamingEnumeration.java","additions":152,"deletions":107,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.lang.ref.Reference;\n@@ -57,0 +58,3 @@\n+        try {\n+            Object obj = null;\n+            String atom = getAtom(dn);\n@@ -58,10 +62,12 @@\n-        Object obj = null;\n-        String atom = getAtom(dn);\n-\n-        if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {\n-            \/\/ serialized object or object reference\n-            try {\n-                PrivilegedExceptionAction<Object> pa = () -> Obj.decodeObject(attrs);\n-                obj = AccessController.doPrivileged(pa, acc);\n-            } catch (PrivilegedActionException e) {\n-                throw (NamingException)e.getException();\n+            if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {\n+                \/\/ serialized object or object reference\n+                try {\n+                    PrivilegedExceptionAction<Object> pa = () -> Obj.decodeObject(attrs);\n+                    obj = AccessController.doPrivileged(pa, acc);\n+                } catch (PrivilegedActionException e) {\n+                    throw (NamingException) e.getException();\n+                }\n+            }\n+            if (obj == null) {\n+                \/\/ DirContext object\n+                obj = new LdapCtx(homeCtx(), dn);\n@@ -69,5 +75,0 @@\n-        }\n-        if (obj == null) {\n-            \/\/ DirContext object\n-            obj = new LdapCtx(homeCtx, dn);\n-        }\n@@ -75,2 +76,2 @@\n-        CompositeName cn = new CompositeName();\n-        cn.add(atom);\n+            CompositeName cn = new CompositeName();\n+            cn.add(atom);\n@@ -78,3 +79,3 @@\n-        try {\n-            obj = DirectoryManager.getObjectInstance(obj, cn, homeCtx,\n-                homeCtx.envprops, attrs);\n+            try {\n+                obj = DirectoryManager.getObjectInstance(obj, cn, homeCtx(),\n+                    homeCtx().envprops, attrs);\n@@ -82,2 +83,2 @@\n-        } catch (NamingException e) {\n-            throw e;\n+            } catch (NamingException e) {\n+                throw e;\n@@ -85,7 +86,7 @@\n-        } catch (Exception e) {\n-            NamingException ne =\n-                new NamingException(\n-                        \"problem generating object using object factory\");\n-            ne.setRootCause(e);\n-            throw ne;\n-        }\n+            } catch (Exception e) {\n+                NamingException ne =\n+                    new NamingException(\n+                            \"problem generating object using object factory\");\n+                ne.setRootCause(e);\n+                throw ne;\n+            }\n@@ -93,6 +94,11 @@\n-        Binding binding;\n-        if (respCtls != null) {\n-           binding = new BindingWithControls(cn.toString(), obj,\n-                                homeCtx.convertControls(respCtls));\n-        } else {\n-            binding = new Binding(cn.toString(), obj);\n+            Binding binding;\n+            if (respCtls != null) {\n+                binding = new BindingWithControls(cn.toString(), obj,\n+                                     homeCtx().convertControls(respCtls));\n+            } else {\n+                binding = new Binding(cn.toString(), obj);\n+            }\n+            binding.setNameInNamespace(dn);\n+            return binding;\n+        } finally {\n+            Reference.reachabilityFence(this);\n@@ -100,2 +106,0 @@\n-        binding.setNameInNamespace(dn);\n-        return binding;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapBindingEnumeration.java","additions":42,"deletions":38,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-\n+import java.lang.ref.Reference;\n@@ -49,0 +49,3 @@\n+        try {\n+            Attribute attr;\n+            String className = null;\n@@ -50,11 +53,8 @@\n-        Attribute attr;\n-        String className = null;\n-\n-        \/\/ use the Java classname if present\n-        if ((attr = attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME])) != null) {\n-            className = (String)attr.get();\n-        } else {\n-            className = defaultClassName;\n-        }\n-        CompositeName cn = new CompositeName();\n-        cn.add(getAtom(dn));\n+            \/\/ use the Java classname if present\n+            if ((attr = attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME])) != null) {\n+                className = (String) attr.get();\n+            } else {\n+                className = defaultClassName;\n+            }\n+            CompositeName cn = new CompositeName();\n+            cn.add(getAtom(dn));\n@@ -62,3 +62,3 @@\n-        NameClassPair ncp;\n-        if (respCtls != null) {\n-            ncp = new NameClassPairWithControls(\n+            NameClassPair ncp;\n+            if (respCtls != null) {\n+                ncp = new NameClassPairWithControls(\n@@ -66,3 +66,8 @@\n-                        homeCtx.convertControls(respCtls));\n-        } else {\n-            ncp = new NameClassPair(cn.toString(), className);\n+                        homeCtx().convertControls(respCtls));\n+            } else {\n+                ncp = new NameClassPair(cn.toString(), className);\n+            }\n+            ncp.setNameInNamespace(dn);\n+            return ncp;\n+        } finally {\n+            Reference.reachabilityFence(this);\n@@ -70,2 +75,0 @@\n-        ncp.setNameInNamespace(dn);\n-        return ncp;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapNamingEnumeration.java","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.lang.ref.Reference;\n@@ -68,0 +69,2 @@\n+        try {\n+            Object obj = null;\n@@ -69,8 +72,3 @@\n-        Object obj = null;\n-\n-        String relStart;         \/\/ name relative to starting search context\n-        String relHome;          \/\/ name relative to homeCtx.currentDN\n-        boolean relative = true; \/\/ whether relative to currentDN\n-\n-        \/\/ need to strip off all but lowest component of dn\n-        \/\/ so that is relative to current context (currentDN)\n+            String relStart;         \/\/ name relative to starting search context\n+            String relHome;          \/\/ name relative to homeCtx.currentDN\n+            boolean relative = true; \/\/ whether relative to currentDN\n@@ -78,4 +76,2 @@\n-        try {\n-            Name parsed = new LdapName(dn);\n-            \/\/ System.err.println(\"dn string: \" + dn);\n-            \/\/ System.err.println(\"dn name: \" + parsed);\n+            \/\/ need to strip off all but lowest component of dn\n+            \/\/ so that is relative to current context (currentDN)\n@@ -83,4 +79,16 @@\n-            if (startName != null && parsed.startsWith(startName)) {\n-                relStart = parsed.getSuffix(startName.size()).toString();\n-                relHome = parsed.getSuffix(homeCtx.currentParsedDN.size()).toString();\n-            } else {\n+            try {\n+                Name parsed = new LdapName(dn);\n+                \/\/ System.err.println(\"dn string: \" + dn);\n+                \/\/ System.err.println(\"dn name: \" + parsed);\n+\n+                if (startName != null && parsed.startsWith(startName)) {\n+                    relStart = parsed.getSuffix(startName.size()).toString();\n+                    relHome = parsed.getSuffix(homeCtx().currentParsedDN.size()).toString();\n+                } else {\n+                    relative = false;\n+                    relHome = relStart =\n+                        LdapURL.toUrlString(homeCtx().hostname, homeCtx().port_number,\n+                        dn, homeCtx().hasLdapsScheme);\n+                }\n+            } catch (NamingException e) {\n+                \/\/ could not parse name\n@@ -89,2 +97,2 @@\n-                    LdapURL.toUrlString(homeCtx.hostname, homeCtx.port_number,\n-                    dn, homeCtx.hasLdapsScheme);\n+                    LdapURL.toUrlString(homeCtx().hostname, homeCtx().port_number,\n+                    dn, homeCtx().hasLdapsScheme);\n@@ -92,21 +100,0 @@\n-        } catch (NamingException e) {\n-            \/\/ could not parse name\n-            relative = false;\n-            relHome = relStart =\n-                LdapURL.toUrlString(homeCtx.hostname, homeCtx.port_number,\n-                dn, homeCtx.hasLdapsScheme);\n-        }\n-\n-        \/\/ Name relative to search context\n-        CompositeName cn = new CompositeName();\n-        if (!relStart.isEmpty()) {\n-            cn.add(relStart);\n-        }\n-\n-        \/\/ Name relative to homeCtx\n-        CompositeName rcn = new CompositeName();\n-        if (!relHome.isEmpty()) {\n-            rcn.add(relHome);\n-        }\n-        \/\/System.err.println(\"relStart: \" + cn);\n-        \/\/System.err.println(\"relHome: \" + rcn);\n@@ -114,2 +101,5 @@\n-        \/\/ Fix attributes to be able to get schema\n-        homeCtx.setParents(attrs, rcn);\n+            \/\/ Name relative to search context\n+            CompositeName cn = new CompositeName();\n+            if (!relStart.isEmpty()) {\n+                cn.add(relStart);\n+            }\n@@ -117,2 +107,27 @@\n-        \/\/ only generate object when requested\n-        if (searchArgs.cons.getReturningObjFlag()) {\n+            \/\/ Name relative to homeCtx\n+            CompositeName rcn = new CompositeName();\n+            if (!relHome.isEmpty()) {\n+                rcn.add(relHome);\n+            }\n+            \/\/System.err.println(\"relStart: \" + cn);\n+            \/\/System.err.println(\"relHome: \" + rcn);\n+\n+            \/\/ Fix attributes to be able to get schema\n+            homeCtx().setParents(attrs, rcn);\n+\n+            \/\/ only generate object when requested\n+            if (searchArgs.cons.getReturningObjFlag()) {\n+\n+                if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {\n+                    \/\/ Entry contains Java-object attributes (ser\/ref object)\n+                    \/\/ serialized object or object reference\n+                    try {\n+                        PrivilegedExceptionAction<Object> pea = () -> Obj.decodeObject(attrs);\n+                        obj = AccessController.doPrivileged(pea, acc);\n+                    } catch (PrivilegedActionException e) {\n+                        throw (NamingException)e.getException();\n+                    }\n+                }\n+                if (obj == null) {\n+                    obj = new LdapCtx(homeCtx(), dn);\n+                }\n@@ -120,3 +135,1 @@\n-            if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {\n-                \/\/ Entry contains Java-object attributes (ser\/ref object)\n-                \/\/ serialized object or object reference\n+                \/\/ Call getObjectInstance before removing unrequested attributes\n@@ -124,4 +137,12 @@\n-                    PrivilegedExceptionAction<Object> pea = () -> Obj.decodeObject(attrs);\n-                    obj = AccessController.doPrivileged(pea, acc);\n-                } catch (PrivilegedActionException e) {\n-                    throw (NamingException)e.getException();\n+                    \/\/ rcn is either relative to homeCtx or a fully qualified DN\n+                    obj = DirectoryManager.getObjectInstance(\n+                        obj, rcn, (relative ? homeCtx() : null),\n+                        homeCtx().envprops, attrs);\n+                } catch (NamingException e) {\n+                    throw e;\n+                } catch (Exception e) {\n+                    NamingException ne =\n+                        new NamingException(\n+                                \"problem generating object using object factory\");\n+                    ne.setRootCause(e);\n+                    throw ne;\n@@ -129,20 +150,0 @@\n-            }\n-            if (obj == null) {\n-                obj = new LdapCtx(homeCtx, dn);\n-            }\n-\n-            \/\/ Call getObjectInstance before removing unrequested attributes\n-            try {\n-                \/\/ rcn is either relative to homeCtx or a fully qualified DN\n-                obj = DirectoryManager.getObjectInstance(\n-                    obj, rcn, (relative ? homeCtx : null),\n-                    homeCtx.envprops, attrs);\n-            } catch (NamingException e) {\n-                throw e;\n-            } catch (Exception e) {\n-                NamingException ne =\n-                    new NamingException(\n-                            \"problem generating object using object factory\");\n-                ne.setRootCause(e);\n-                throw ne;\n-            }\n@@ -150,3 +151,3 @@\n-            \/\/ remove Java attributes from result, if necessary\n-            \/\/ Even if CLASSNAME attr not there, there might be some\n-            \/\/ residual attributes\n+                \/\/ remove Java attributes from result, if necessary\n+                \/\/ Even if CLASSNAME attr not there, there might be some\n+                \/\/ residual attributes\n@@ -154,11 +155,12 @@\n-            String[] reqAttrs;\n-            if ((reqAttrs = searchArgs.reqAttrs) != null) {\n-                \/\/ create an attribute set for those requested\n-                Attributes rattrs = new BasicAttributes(true); \/\/ ignore case\n-                for (int i = 0; i < reqAttrs.length; i++) {\n-                    rattrs.put(reqAttrs[i], null);\n-                }\n-                for (int i = 0; i < Obj.JAVA_ATTRIBUTES.length; i++) {\n-                    \/\/ Remove Java-object attributes if not requested\n-                    if (rattrs.get(Obj.JAVA_ATTRIBUTES[i]) == null) {\n-                        attrs.remove(Obj.JAVA_ATTRIBUTES[i]);\n+                String[] reqAttrs;\n+                if ((reqAttrs = searchArgs.reqAttrs) != null) {\n+                    \/\/ create an attribute set for those requested\n+                    Attributes rattrs = new BasicAttributes(true); \/\/ ignore case\n+                    for (int i = 0; i < reqAttrs.length; i++) {\n+                        rattrs.put(reqAttrs[i], null);\n+                    }\n+                    for (int i = 0; i < Obj.JAVA_ATTRIBUTES.length; i++) {\n+                        \/\/ Remove Java-object attributes if not requested\n+                        if (rattrs.get(Obj.JAVA_ATTRIBUTES[i]) == null) {\n+                            attrs.remove(Obj.JAVA_ATTRIBUTES[i]);\n+                        }\n@@ -167,1 +169,0 @@\n-            }\n@@ -169,1 +170,1 @@\n-        }\n+            }\n@@ -171,15 +172,20 @@\n-        \/*\n-         * name in search result is either the stringified composite name\n-         * relative to the search context that can be passed directly to\n-         * methods of the search context, or the fully qualified DN\n-         * which can be used with the initial context.\n-         *\/\n-        SearchResult sr;\n-        if (respCtls != null) {\n-            sr = new SearchResultWithControls(\n-                (relative ? cn.toString() : relStart), obj, attrs,\n-                relative, homeCtx.convertControls(respCtls));\n-        } else {\n-            sr = new SearchResult(\n-                (relative ? cn.toString() : relStart),\n-                obj, attrs, relative);\n+            \/*\n+             * name in search result is either the stringified composite name\n+             * relative to the search context that can be passed directly to\n+             * methods of the search context, or the fully qualified DN\n+             * which can be used with the initial context.\n+             *\/\n+            SearchResult sr;\n+            if (respCtls != null) {\n+                sr = new SearchResultWithControls(\n+                    (relative ? cn.toString() : relStart), obj, attrs,\n+                    relative, homeCtx().convertControls(respCtls));\n+            } else {\n+                sr = new SearchResult(\n+                    (relative ? cn.toString() : relStart),\n+                    obj, attrs, relative);\n+            }\n+            sr.setNameInNamespace(dn);\n+            return sr;\n+        } finally {\n+            Reference.reachabilityFence(this);\n@@ -187,2 +193,0 @@\n-        sr.setNameInNamespace(dn);\n-        return sr;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapSearchEnumeration.java","additions":108,"deletions":104,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8283660\n+ * @summary Verify the AbstractLdapNamingEnumeration Cleaner doesn't keep the\n+ *          enumeration reachable\n+ * @modules java.naming\/com.sun.jndi.ldap\n+ * @library \/test\/lib ..\/lib\/ \/javax\/naming\/module\/src\/test\/test\/\n+ * @build LDAPServer LDAPTestUtils\n+ * @run main\/othervm LdapEnumeration\n+ *\/\n+\n+import javax.naming.NamingEnumeration;\n+import javax.naming.directory.Attribute;\n+import javax.naming.directory.Attributes;\n+import javax.naming.directory.BasicAttribute;\n+import javax.naming.directory.BasicAttributes;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.InitialDirContext;\n+import javax.naming.directory.SearchControls;\n+import javax.naming.directory.SearchResult;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.SocketAddress;\n+import java.util.Hashtable;\n+import java.util.WeakHashMap;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+\/*\n+ * This test is a copy of com\/sun\/jndi\/ldap\/blits\/AddTests\/AddNewEntry.java,\n+ * altered to confirm that the NamingEnumeration<SearchResult> is not prevented\n+ * from being collected by the Cleaner code in AbstractLdapNamingEnumeration.\n+ *\/\n+public class LdapEnumeration {\n+    static WeakHashMap whm = new WeakHashMap();\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create unbound server socket\n+        ServerSocket serverSocket = new ServerSocket();\n+\n+        \/\/ Bind it to the loopback address\n+        SocketAddress sockAddr = new InetSocketAddress(\n+                InetAddress.getLoopbackAddress(), 0);\n+        serverSocket.bind(sockAddr);\n+\n+        \/\/ Construct the provider URL for LDAPTestUtils\n+        String providerURL = URIBuilder.newBuilder()\n+                .scheme(\"ldap\")\n+                .loopback()\n+                .port(serverSocket.getLocalPort())\n+                .buildUnchecked().toString();\n+\n+        Hashtable<Object, Object> env;\n+\n+        \/\/ initialize test\n+        env = LDAPTestUtils.initEnv(serverSocket, providerURL,\n+                         LdapEnumeration.class.getName(), args, true);\n+\n+        \/* Build attribute set *\/\n+        String[] ids = { \"objectClass\", \"sn\", \"cn\", \"telephoneNumber\", \"mail\",\n+                \"description\", \"uid\" };\n+        Attribute objectClass = new BasicAttribute(ids[0]);\n+        objectClass.add(\"top\");\n+        objectClass.add(\"person\");\n+        objectClass.add(\"organizationalPerson\");\n+        objectClass.add(\"inetOrgPerson\");\n+\n+        Attribute sn = new BasicAttribute(ids[1], \"Powers\");\n+        Attribute cn = new BasicAttribute(ids[2],\n+                \"Austin \\\\\\\"Danger\\\\\\\" Powers\");\n+        Attribute telephoneNumber = new BasicAttribute(ids[3], \"+44 582 10101\");\n+        Attribute mail = new BasicAttribute(ids[4], \"secret_agent_man@imc.org\");\n+        Attribute description = new BasicAttribute(ids[5], \"Yea Baby!!\");\n+        description.add(\"Behave!\");\n+        Attribute uid = new BasicAttribute(ids[6], \"secret_agent_man\");\n+\n+        Attributes attrs = new BasicAttributes();\n+        attrs.put(objectClass);\n+        attrs.put(sn);\n+        attrs.put(cn);\n+        attrs.put(telephoneNumber);\n+        attrs.put(mail);\n+        attrs.put(description);\n+        attrs.put(uid);\n+\n+        DirContext ctx = null;\n+        String[] bases = new String[] { (String) env.get(\"client\"),\n+                (String) env.get(\"vendor\"), \"Add\" };\n+        String baseDN = LDAPTestUtils.buildDN(bases, (String) env.get(\"root\"));\n+        String entryDN = \"cn=Austin Powers,\" + baseDN;\n+        String expect = \"\"; \/\/ relative name\n+\n+        try {\n+            \/\/ connect to server\n+            ctx = new InitialDirContext(env);\n+\n+            \/\/ add entry\n+            ctx.createSubcontext(entryDN, attrs);\n+\n+            \/\/ specify base search\n+            SearchControls constraints = new SearchControls();\n+            constraints.setSearchScope(SearchControls.OBJECT_SCOPE);\n+\n+            NamingEnumeration<SearchResult> results = ctx\n+                    .search(entryDN, \"(objectclass=*)\", constraints);\n+\n+            if (!\"LdapSearchEnumeration\".equals(results.getClass().getSimpleName())) {\n+                throw new RuntimeException(\"Unexpected results class: \" + results.getClass());\n+            }\n+\n+            whm.put(results, null);\n+            results = null;\n+            \/\/ Run GC to run the Cleaner and collect 'results'\n+            for (int i = 0; i < 100; i++) {\n+                System.gc();\n+                Thread.sleep(1);\n+            }\n+            \/\/ If the Cleaner holds a reference to 'results', it won't be cleared from the map\n+            if (whm.size() > 0) {\n+                throw new RuntimeException(\"NamingEnumeration is still strongly reachable\");\n+            }\n+\n+        } finally {\n+            LDAPTestUtils.cleanupSubcontext(ctx, entryDN);\n+            LDAPTestUtils.cleanup(ctx);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/CleanerTests\/LdapEnumeration.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/CleanerTests\/LdapEnumeration.ldap","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/com\/sun\/jndi\/ldap\/blits\/AddTests\/AddNewEntry.ldap","status":"copied"}]}