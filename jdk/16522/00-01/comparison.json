{"files":[{"patch":"@@ -1,218 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#include \"gc\/g1\/g1CollectorState.hpp\"\n-#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n-#include \"gc\/g1\/g1RemoveSelfForwardsTask.hpp\"\n-#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n-#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n-#include \"gc\/g1\/g1OopClosures.inline.hpp\"\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/compressedOops.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/prefetch.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-\n-\n-class PhaseTimesStat {\n-  static constexpr G1GCPhaseTimes::GCParPhases phase_name =\n-    G1GCPhaseTimes::RemoveSelfForwards;\n-\n-  G1GCPhaseTimes* _phase_times;\n-  uint _worker_id;\n-  Ticks _start;\n-\n-public:\n-  PhaseTimesStat(G1GCPhaseTimes* phase_times, uint worker_id) :\n-    _phase_times(phase_times),\n-    _worker_id(worker_id),\n-    _start(Ticks::now()) { }\n-\n-  ~PhaseTimesStat() {\n-    _phase_times->record_or_add_time_secs(phase_name,\n-                                          _worker_id,\n-                                          (Ticks::now() - _start).seconds());\n-  }\n-\n-  void register_empty_chunk() {\n-    _phase_times->record_or_add_thread_work_item(phase_name,\n-                                                 _worker_id,\n-                                                 1,\n-                                                 G1GCPhaseTimes::RemoveSelfForwardEmptyChunksNum);\n-  }\n-\n-  void register_nonempty_chunk() {\n-    _phase_times->record_or_add_thread_work_item(phase_name,\n-                                                 _worker_id,\n-                                                 1,\n-                                                 G1GCPhaseTimes::RemoveSelfForwardChunksNum);\n-  }\n-\n-  void register_objects_count_and_size(size_t num_marked_obj, size_t marked_words) {\n-    _phase_times->record_or_add_thread_work_item(phase_name,\n-                                                 _worker_id,\n-                                                 num_marked_obj,\n-                                                 G1GCPhaseTimes::RemoveSelfForwardObjectsNum);\n-\n-    size_t marked_bytes = marked_words * HeapWordSize;\n-    _phase_times->record_or_add_thread_work_item(phase_name,\n-                                                 _worker_id,\n-                                                 marked_bytes,\n-                                                 G1GCPhaseTimes::RemoveSelfForwardObjectsBytes);\n-  }\n-};\n-\n-\/\/ Fill the memory area from start to end with filler objects, and update the BOT\n-\/\/ accordingly. Since we clear and use the bitmap for marking objects that failed\n-\/\/ evacuation, there is no other work to be done there.\n-static size_t zap_dead_objects(HeapRegion* hr, HeapWord* start, HeapWord* end) {\n-  assert(start <= end, \"precondition\");\n-  if (start == end) {\n-    return 0;\n-  }\n-\n-  hr->fill_range_with_dead_objects(start, end);\n-  return pointer_delta(end, start);\n-}\n-\n-static void update_garbage_words_in_hr(HeapRegion* hr, size_t garbage_words) {\n-  if (garbage_words != 0) {\n-    hr->note_self_forward_chunk_done(garbage_words * HeapWordSize);\n-  }\n-}\n-\n-static void prefetch_obj(HeapWord* obj_addr) {\n-  Prefetch::write(obj_addr, PrefetchScanIntervalInBytes);\n-}\n-\n-void G1RemoveSelfForwardsTask::process_chunk(uint worker_id,\n-                                             uint chunk_idx) {\n-  PhaseTimesStat stat(_g1h->phase_times(), worker_id);\n-\n-  G1CMBitMap* bitmap = _cm->mark_bitmap();\n-  const uint region_idx = _evac_failure_regions->get_region_idx(chunk_idx \/ _num_chunks_per_region);\n-  HeapRegion* hr = _g1h->region_at(region_idx);\n-\n-  HeapWord* hr_bottom = hr->bottom();\n-  HeapWord* hr_top = hr->top();\n-  HeapWord* chunk_start = hr_bottom + (chunk_idx % _num_chunks_per_region) * _chunk_size;\n-\n-  assert(chunk_start < hr->end(), \"inv\");\n-  if (chunk_start >= hr_top) {\n-    return;\n-  }\n-\n-  HeapWord* chunk_end = MIN2(chunk_start + _chunk_size, hr_top);\n-  HeapWord* first_marked_addr = bitmap->get_next_marked_addr(chunk_start, hr_top);\n-\n-  size_t garbage_words = 0;\n-\n-  if (chunk_start == hr_bottom) {\n-    \/\/ This is the bottom-most chunk in this region; zap [bottom, first_marked_addr).\n-    garbage_words += zap_dead_objects(hr, hr_bottom, first_marked_addr);\n-  }\n-\n-  if (first_marked_addr >= chunk_end) {\n-    stat.register_empty_chunk();\n-    update_garbage_words_in_hr(hr, garbage_words);\n-    return;\n-  }\n-\n-  stat.register_nonempty_chunk();\n-\n-  size_t num_marked_objs = 0;\n-  size_t marked_words = 0;\n-\n-  HeapWord* obj_addr = first_marked_addr;\n-  assert(chunk_start <= obj_addr && obj_addr < chunk_end,\n-         \"object \" PTR_FORMAT \" must be within chunk [\" PTR_FORMAT \", \" PTR_FORMAT \"[\",\n-         p2i(obj_addr), p2i(chunk_start), p2i(chunk_end));\n-  do {\n-    assert(bitmap->is_marked(obj_addr), \"inv\");\n-    prefetch_obj(obj_addr);\n-\n-    oop obj = cast_to_oop(obj_addr);\n-    const size_t obj_size = obj->size();\n-    HeapWord* const obj_end_addr = obj_addr + obj_size;\n-\n-    {\n-      \/\/ Process marked object.\n-      assert(obj->is_forwarded() && obj->forwardee() == obj, \"must be self-forwarded\");\n-      obj->init_mark();\n-      hr->update_bot_for_block(obj_addr, obj_end_addr);\n-\n-      \/\/ Statistics\n-      num_marked_objs++;\n-      marked_words += obj_size;\n-    }\n-\n-    assert(obj_end_addr <= hr_top, \"inv\");\n-    \/\/ Use hr_top as the limit so that we zap dead ranges up to the next\n-    \/\/ marked obj or hr_top.\n-    HeapWord* next_marked_obj_addr = bitmap->get_next_marked_addr(obj_end_addr, hr_top);\n-    garbage_words += zap_dead_objects(hr, obj_end_addr, next_marked_obj_addr);\n-    obj_addr = next_marked_obj_addr;\n-  } while (obj_addr < chunk_end);\n-\n-  assert(marked_words > 0 && num_marked_objs > 0, \"inv\");\n-\n-  stat.register_objects_count_and_size(num_marked_objs, marked_words);\n-\n-  update_garbage_words_in_hr(hr, garbage_words);\n-}\n-\n-G1RemoveSelfForwardsTask::G1RemoveSelfForwardsTask(G1EvacFailureRegions* evac_failure_regions) :\n-  WorkerTask(\"G1 Remove Self-forwarding Pointers\"),\n-  _g1h(G1CollectedHeap::heap()),\n-  _cm(_g1h->concurrent_mark()),\n-  _evac_failure_regions(evac_failure_regions),\n-  _chunk_bitmap(mtGC) {\n-\n-  _num_evac_fail_regions = _evac_failure_regions->num_regions_failed_evacuation();\n-  _num_chunks_per_region = G1CollectedHeap::get_chunks_per_region();\n-\n-  _chunk_size = static_cast<uint>(HeapRegion::GrainWords \/ _num_chunks_per_region);\n-\n-  log_debug(gc, ergo)(\"Initializing removing self forwards with %u chunks per region\",\n-                      _num_chunks_per_region);\n-\n-  _chunk_bitmap.resize(_num_chunks_per_region * _num_evac_fail_regions);\n-}\n-\n-void G1RemoveSelfForwardsTask::work(uint worker_id) {\n-  const uint total_workers = G1CollectedHeap::heap()->workers()->active_workers();\n-  const uint total_chunks = _num_chunks_per_region * _num_evac_fail_regions;\n-  const uint start_chunk_idx = worker_id * total_chunks \/ total_workers;\n-\n-  for (uint i = 0; i < total_chunks; i++) {\n-    const uint chunk_idx = (start_chunk_idx + i) % total_chunks;\n-    if (claim_chunk(chunk_idx)) {\n-      process_chunk(worker_id, chunk_idx);\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemoveSelfForwardsTask.cpp","additions":0,"deletions":218,"binary":false,"changes":218,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1REMOVESELFFORWARDSTASK_HPP\n-#define SHARE_GC_G1_G1REMOVESELFFORWARDSTASK_HPP\n-\n-#include \"gc\/shared\/workerThread.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/bitMap.hpp\"\n-\n-class G1CollectedHeap;\n-class G1ConcurrentMark;\n-class G1EvacFailureRegions;\n-\n-\/\/ Task to fixup self-forwarding pointers within the objects installed as a result\n-\/\/ of an evacuation failure.\n-class G1RemoveSelfForwardsTask : public WorkerTask {\n-  G1CollectedHeap* _g1h;\n-  G1ConcurrentMark* _cm;\n-\n-  G1EvacFailureRegions* _evac_failure_regions;\n-  CHeapBitMap _chunk_bitmap;\n-\n-  uint _num_chunks_per_region;\n-  uint _num_evac_fail_regions;\n-  size_t _chunk_size;\n-\n-  bool claim_chunk(uint chunk_idx) {\n-    return _chunk_bitmap.par_set_bit(chunk_idx);\n-  }\n-\n-  void process_chunk(uint worker_id, uint chunk_idx);\n-\n-public:\n-  explicit G1RemoveSelfForwardsTask(G1EvacFailureRegions* evac_failure_regions);\n-\n-  void work(uint worker_id);\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1REMOVESELFFORWARDSTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemoveSelfForwardsTask.hpp","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1CollectorState.hpp\"\n@@ -33,1 +34,1 @@\n-#include \"gc\/g1\/g1EvacStats.inline.hpp\"\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -35,0 +36,2 @@\n+#include \"gc\/g1\/g1EvacStats.inline.hpp\"\n+#include \"gc\/g1\/g1OopClosures.inline.hpp\"\n@@ -38,0 +41,2 @@\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -40,0 +45,4 @@\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/prefetch.hpp\"\n@@ -42,0 +51,1 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n@@ -96,1 +106,3 @@\n-  G1RemoveSelfForwardsTask _task;\n+  G1CollectedHeap* _g1h;\n+  G1ConcurrentMark* _cm;\n+\n@@ -98,0 +110,155 @@\n+  CHeapBitMap _chunk_bitmap;\n+\n+  uint _num_chunks_per_region;\n+  uint _num_evac_fail_regions;\n+  size_t _chunk_size;\n+\n+  class PhaseTimesStat {\n+    static constexpr G1GCPhaseTimes::GCParPhases phase_name =\n+      G1GCPhaseTimes::RemoveSelfForwards;\n+\n+    G1GCPhaseTimes* _phase_times;\n+    uint _worker_id;\n+    Ticks _start;\n+\n+  public:\n+    PhaseTimesStat(G1GCPhaseTimes* phase_times, uint worker_id) :\n+      _phase_times(phase_times),\n+      _worker_id(worker_id),\n+      _start(Ticks::now()) { }\n+\n+    ~PhaseTimesStat() {\n+      _phase_times->record_or_add_time_secs(phase_name,\n+                                            _worker_id,\n+                                            (Ticks::now() - _start).seconds());\n+    }\n+\n+    void register_empty_chunk() {\n+      _phase_times->record_or_add_thread_work_item(phase_name,\n+                                                   _worker_id,\n+                                                   1,\n+                                                   G1GCPhaseTimes::RemoveSelfForwardEmptyChunksNum);\n+    }\n+\n+    void register_nonempty_chunk() {\n+      _phase_times->record_or_add_thread_work_item(phase_name,\n+                                                   _worker_id,\n+                                                   1,\n+                                                   G1GCPhaseTimes::RemoveSelfForwardChunksNum);\n+    }\n+\n+    void register_objects_count_and_size(size_t num_marked_obj, size_t marked_words) {\n+      _phase_times->record_or_add_thread_work_item(phase_name,\n+                                                   _worker_id,\n+                                                   num_marked_obj,\n+                                                   G1GCPhaseTimes::RemoveSelfForwardObjectsNum);\n+\n+      size_t marked_bytes = marked_words * HeapWordSize;\n+      _phase_times->record_or_add_thread_work_item(phase_name,\n+                                                   _worker_id,\n+                                                   marked_bytes,\n+                                                   G1GCPhaseTimes::RemoveSelfForwardObjectsBytes);\n+    }\n+  };\n+\n+  \/\/ Fill the memory area from start to end with filler objects, and update the BOT\n+  \/\/ accordingly. Since we clear and use the bitmap for marking objects that failed\n+  \/\/ evacuation, there is no other work to be done there.\n+  static size_t zap_dead_objects(HeapRegion* hr, HeapWord* start, HeapWord* end) {\n+    assert(start <= end, \"precondition\");\n+    if (start == end) {\n+      return 0;\n+    }\n+\n+    hr->fill_range_with_dead_objects(start, end);\n+    return pointer_delta(end, start);\n+  }\n+\n+  static void update_garbage_words_in_hr(HeapRegion* hr, size_t garbage_words) {\n+    if (garbage_words != 0) {\n+      hr->note_self_forward_chunk_done(garbage_words * HeapWordSize);\n+    }\n+  }\n+\n+  static void prefetch_obj(HeapWord* obj_addr) {\n+    Prefetch::write(obj_addr, PrefetchScanIntervalInBytes);\n+  }\n+\n+  bool claim_chunk(uint chunk_idx) {\n+    return _chunk_bitmap.par_set_bit(chunk_idx);\n+  }\n+\n+  void process_chunk(uint worker_id, uint chunk_idx) {\n+    PhaseTimesStat stat(_g1h->phase_times(), worker_id);\n+\n+    G1CMBitMap* bitmap = _cm->mark_bitmap();\n+    const uint region_idx = _evac_failure_regions->get_region_idx(chunk_idx \/ _num_chunks_per_region);\n+    HeapRegion* hr = _g1h->region_at(region_idx);\n+\n+    HeapWord* hr_bottom = hr->bottom();\n+    HeapWord* hr_top = hr->top();\n+    HeapWord* chunk_start = hr_bottom + (chunk_idx % _num_chunks_per_region) * _chunk_size;\n+\n+    assert(chunk_start < hr->end(), \"inv\");\n+    if (chunk_start >= hr_top) {\n+      return;\n+    }\n+\n+    HeapWord* chunk_end = MIN2(chunk_start + _chunk_size, hr_top);\n+    HeapWord* first_marked_addr = bitmap->get_next_marked_addr(chunk_start, hr_top);\n+\n+    size_t garbage_words = 0;\n+\n+    if (chunk_start == hr_bottom) {\n+      \/\/ This is the bottom-most chunk in this region; zap [bottom, first_marked_addr).\n+      garbage_words += zap_dead_objects(hr, hr_bottom, first_marked_addr);\n+    }\n+\n+    if (first_marked_addr >= chunk_end) {\n+      stat.register_empty_chunk();\n+      update_garbage_words_in_hr(hr, garbage_words);\n+      return;\n+    }\n+\n+    stat.register_nonempty_chunk();\n+\n+    size_t num_marked_objs = 0;\n+    size_t marked_words = 0;\n+\n+    HeapWord* obj_addr = first_marked_addr;\n+    assert(chunk_start <= obj_addr && obj_addr < chunk_end,\n+           \"object \" PTR_FORMAT \" must be within chunk [\" PTR_FORMAT \", \" PTR_FORMAT \"[\",\n+           p2i(obj_addr), p2i(chunk_start), p2i(chunk_end));\n+    do {\n+      assert(bitmap->is_marked(obj_addr), \"inv\");\n+      prefetch_obj(obj_addr);\n+\n+      oop obj = cast_to_oop(obj_addr);\n+      const size_t obj_size = obj->size();\n+      HeapWord* const obj_end_addr = obj_addr + obj_size;\n+\n+      {\n+        \/\/ Process marked object.\n+        assert(obj->is_forwarded() && obj->forwardee() == obj, \"must be self-forwarded\");\n+        obj->init_mark();\n+        hr->update_bot_for_block(obj_addr, obj_end_addr);\n+\n+        \/\/ Statistics\n+        num_marked_objs++;\n+        marked_words += obj_size;\n+      }\n+\n+      assert(obj_end_addr <= hr_top, \"inv\");\n+      \/\/ Use hr_top as the limit so that we zap dead ranges up to the next\n+      \/\/ marked obj or hr_top.\n+      HeapWord* next_marked_obj_addr = bitmap->get_next_marked_addr(obj_end_addr, hr_top);\n+      garbage_words += zap_dead_objects(hr, obj_end_addr, next_marked_obj_addr);\n+      obj_addr = next_marked_obj_addr;\n+    } while (obj_addr < chunk_end);\n+\n+    assert(marked_words > 0 && num_marked_objs > 0, \"inv\");\n+\n+    stat.register_objects_count_and_size(num_marked_objs, marked_words);\n+\n+    update_garbage_words_in_hr(hr, garbage_words);\n+  }\n@@ -102,2 +269,14 @@\n-    _task(evac_failure_regions),\n-    _evac_failure_regions(evac_failure_regions) {\n+    _g1h(G1CollectedHeap::heap()),\n+    _cm(_g1h->concurrent_mark()),\n+    _evac_failure_regions(evac_failure_regions),\n+    _chunk_bitmap(mtGC) {\n+\n+    _num_evac_fail_regions = _evac_failure_regions->num_regions_failed_evacuation();\n+    _num_chunks_per_region = G1CollectedHeap::get_chunks_per_region();\n+\n+    _chunk_size = static_cast<uint>(HeapRegion::GrainWords \/ _num_chunks_per_region);\n+\n+    log_debug(gc, ergo)(\"Initializing removing self forwards with %u chunks per region\",\n+                        _num_chunks_per_region);\n+\n+    _chunk_bitmap.resize(_num_chunks_per_region * _num_evac_fail_regions);\n@@ -114,1 +293,10 @@\n-    _task.work(worker_id);\n+    const uint total_workers = G1CollectedHeap::heap()->workers()->active_workers();\n+    const uint total_chunks = _num_chunks_per_region * _num_evac_fail_regions;\n+    const uint start_chunk_idx = worker_id * total_chunks \/ total_workers;\n+\n+    for (uint i = 0; i < total_chunks; i++) {\n+      const uint chunk_idx = (start_chunk_idx + i) % total_chunks;\n+      if (claim_chunk(chunk_idx)) {\n+        process_chunk(worker_id, chunk_idx);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":193,"deletions":5,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/g1\/g1RemoveSelfForwardsTask.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}