{"files":[{"patch":"@@ -59,1 +59,0 @@\n-import java.util.stream.Collectors;\n@@ -266,4 +265,0 @@\n-     * For methods, any interface method coming from an undocumented supertype\n-     * will be removed if this class (or one of its superclasses) provides\n-     * an override.\n-     *\n@@ -278,29 +273,1 @@\n-        List<Element> members = getVisibleMembers(kind, declaredAndLeafMembers);\n-\n-        if (kind == Kind.METHODS) {\n-            members = removeDuplicates(members);\n-        }\n-\n-        return members;\n-    }\n-\n-    \/**\n-     * Drop any methods that were inlined from an undocumented interface\n-     * and have a local override in this class hierarchy.\n-     *\/\n-    private List<Element> removeDuplicates(List<Element> methods) {\n-        Set<ExecutableElement> localMethods = overriddenMethodTable.values().stream()\n-                .map(info -> info.overriddenMethod)\n-                .collect(Collectors.toSet());\n-\n-        return methods.stream()\n-                .filter(e -> shouldKeepInheritedMethod(e, localMethods))\n-                .toList();\n-    }\n-\n-    private boolean shouldKeepInheritedMethod(Element e, Set<ExecutableElement> overridden) {\n-        if (!(e instanceof ExecutableElement ee)) return true;\n-        TypeElement encl = utils.getEnclosingTypeElement(ee);\n-        boolean hiddenInterface = !Objects.equals(encl, te)\n-                && utils.isUndocumentedEnclosure(encl);\n-        return !hiddenInterface || !overridden.contains(ee);\n+        return getVisibleMembers(kind, declaredAndLeafMembers);\n@@ -714,8 +681,7 @@\n-        \/\/ Multiple-Inheritance: remove the interface method that may have\n-        \/\/ been overridden by another interface method in the hierarchy\n-        \/\/\n-        \/\/ Note: The following approach is very simplistic and is compatible\n-        \/\/ with old VMM. A future enhancement, may include a contention breaker,\n-        \/\/ to correctly eliminate those methods that are merely definitions\n-        \/\/ in favor of concrete overriding methods, for instance those that have\n-        \/\/ API documentation and are not abstract OR default methods.\n+        \/\/ Multiple-Inheritance: No Contention. In Java's method resolution,\n+        \/\/ any override of a signature (whether by a subclass or by a subinterface,\n+        \/\/ including when it is final from superclasses) always takes precedence\n+        \/\/ over the original interface definition. All interface methods have low resolution priority.\n+        \/\/ Therefore, when considering an interface inherited method, as soon as\n+        \/\/ at least one overrider exists in the inheritance chain,\n+        \/\/ we do not inherit the older interface definition.\n@@ -724,6 +690,1 @@\n-            if (list != null) {\n-                boolean found = list.stream()\n-                        .anyMatch(this::isDeclaredInInterface);\n-                if (found)\n-                    return false;\n-            }\n+            if (list != null && !list.isEmpty()) return false;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":9,"deletions":48,"binary":false,"changes":57,"status":"modified"}]}