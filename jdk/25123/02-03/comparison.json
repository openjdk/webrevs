{"files":[{"patch":"@@ -265,0 +265,4 @@\n+     * For methods, any interface method coming from an undocumented supertype\n+     * will be removed if this class (or one of its superclasses) provides\n+     * an override.\n+     *\n@@ -273,1 +277,39 @@\n-        return getVisibleMembers(kind, declaredAndLeafMembers);\n+        List<Element> members = getVisibleMembers(kind, declaredAndLeafMembers);\n+\n+        if (kind == Kind.METHODS) {\n+            members = removeDuplicates(members);\n+        }\n+\n+        return members;\n+    }\n+\n+    \/**\n+     * Drop any methods that were inlined from an undocumented interface\n+     * and have a local override in this class hierarchy.\n+     *\/\n+    private List<Element> removeDuplicates(List<Element> methods) {\n+        List<ExecutableElement> localMethods = getMembers(Kind.METHODS).stream()\n+                .map(ExecutableElement.class::cast)\n+                .toList();\n+\n+        return methods.stream()\n+                .filter(e -> shouldKeepInheritedMethod(e, localMethods))\n+                .toList();\n+    }\n+\n+    private boolean shouldKeepInheritedMethod(Element e, List<ExecutableElement> localMethods) {\n+        TypeElement encl = utils.getEnclosingTypeElement(e);\n+\n+        boolean isHiddenInterfaceMethod =\n+                !Objects.equals(encl, te) && utils.isUndocumentedEnclosure(encl)\n+                        && e instanceof ExecutableElement;\n+\n+        if (isHiddenInterfaceMethod) {\n+            ExecutableElement inherited = (ExecutableElement) e;\n+            for (var local : localMethods) {\n+                if (utils.elementUtils.overrides(local, inherited, te)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n@@ -681,7 +723,8 @@\n-        \/\/ Multiple-Inheritance: No Contention. In Java's method resolution,\n-        \/\/ any override of a signature (whether by a subclass or by a subinterface,\n-        \/\/ including when it is final from superclasses) always takes precedence\n-        \/\/ over the original interface definition. All interface methods have low resolution priority.\n-        \/\/ Therefore, when considering an interface inherited method, as soon as\n-        \/\/ at least one overrider exists in the inheritance chain,\n-        \/\/ we do not inherit the older interface definition.\n+        \/\/ Multiple-Inheritance: remove the interface method that may have\n+        \/\/ been overridden by another interface method in the hierarchy\n+        \/\/\n+        \/\/ Note: The following approach is very simplistic and is compatible\n+        \/\/ with old VMM. A future enhancement, may include a contention breaker,\n+        \/\/ to correctly eliminate those methods that are merely definitions\n+        \/\/ in favor of concrete overriding methods, for instance those that have\n+        \/\/ API documentation and are not abstract OR default methods.\n@@ -690,1 +733,6 @@\n-            if (list != null && !list.isEmpty()) return false;\n+            if (list != null) {\n+                boolean found = list.stream()\n+                        .anyMatch(this::isDeclaredInInterface);\n+                if (found)\n+                    return false;\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":57,"deletions":9,"binary":false,"changes":66,"status":"modified"}]}