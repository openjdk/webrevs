{"files":[{"patch":"@@ -1366,0 +1366,12 @@\n+\/**\n+ * Throws a java\/lang\/UnsupportedOperationException unconditionally.\n+ * This is required by the specification of VarHandle.{access-mode} if\n+ * invoked directly.\n+ *\/\n+JVM_ENTRY(jobject, VH_UOE(JNIEnv* env, jobject vh, jobjectArray args)) {\n+  THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), \"VarHandle access mode methods cannot be invoked reflectively\");\n+  return nullptr;\n+}\n+JVM_END\n+\n+\n@@ -1405,0 +1417,34 @@\n+static JNINativeMethod VH_methods[] = {\n+  \/\/ UnsupportedOperationException throwers\n+  {CC \"get\",                        CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"set\",                        CC \"([\" OBJ \")V\",       FN_PTR(VH_UOE)},\n+  {CC \"getVolatile\",                CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"setVolatile\",                CC \"([\" OBJ \")V\",       FN_PTR(VH_UOE)},\n+  {CC \"getAcquire\",                 CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"setRelease\",                 CC \"([\" OBJ \")V\",       FN_PTR(VH_UOE)},\n+  {CC \"getOpaque\",                  CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"setOpaque\",                  CC \"([\" OBJ \")V\",       FN_PTR(VH_UOE)},\n+  {CC \"compareAndSet\",              CC \"([\" OBJ \")Z\",       FN_PTR(VH_UOE)},\n+  {CC \"compareAndExchange\",         CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"compareAndExchangeAcquire\",  CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"compareAndExchangeRelease\",  CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"weakCompareAndSetPlain\",     CC \"([\" OBJ \")Z\",       FN_PTR(VH_UOE)},\n+  {CC \"weakCompareAndSet\",          CC \"([\" OBJ \")Z\",       FN_PTR(VH_UOE)},\n+  {CC \"weakCompareAndSetAcquire\",   CC \"([\" OBJ \")Z\",       FN_PTR(VH_UOE)},\n+  {CC \"weakCompareAndSetRelease\",   CC \"([\" OBJ \")Z\",       FN_PTR(VH_UOE)},\n+  {CC \"getAndSet\",                  CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndSetAcquire\",           CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndSetRelease\",           CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndAdd\",                  CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndAddAcquire\",           CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndAddRelease\",           CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndBitwiseOr\",            CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndBitwiseOrAcquire\",     CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndBitwiseOrRelease\",     CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndBitwiseAnd\",           CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndBitwiseAndAcquire\",    CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndBitwiseAndRelease\",    CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndBitwiseXor\",           CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndBitwiseXorAcquire\",    CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)},\n+  {CC \"getAndBitwiseXorRelease\",    CC \"([\" OBJ \")\" OBJ,    FN_PTR(VH_UOE)}\n+};\n@@ -1412,0 +1458,1 @@\n+  assert(vmClasses::VarHandle_klass() != nullptr, \"should be present\");\n@@ -1413,2 +1460,4 @@\n-  oop mirror = vmClasses::MethodHandle_klass()->java_mirror();\n-  jclass MH_class = (jclass) JNIHandles::make_local(THREAD, mirror);\n+  oop mh_mirror = vmClasses::MethodHandle_klass()->java_mirror();\n+  oop vh_mirror = vmClasses::VarHandle_klass()->java_mirror();\n+  jclass MH_class = (jclass) JNIHandles::make_local(THREAD, mh_mirror);\n+  jclass VH_class = (jclass) JNIHandles::make_local(THREAD, vh_mirror);\n@@ -1426,0 +1475,4 @@\n+\n+    status = env->RegisterNatives(VH_class, VH_methods, sizeof(VH_methods)\/sizeof(JNINativeMethod));\n+    guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n+              \"register java.lang.invoke.VarHandle natives\");\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -55,1 +56,1 @@\n-    public void methodInvocation(VarHandle.AccessMode accessMode) throws Exception {\n+    public void methodInvocationArgumentMismatch(VarHandle.AccessMode accessMode) throws Exception {\n@@ -58,1 +59,1 @@\n-        \/\/ Try a reflective invoke using a Method\n+        \/\/ Try a reflective invoke using a Method, with no arguments\n@@ -64,0 +65,18 @@\n+    @Test(dataProvider = \"accessModesProvider\")\n+    public void methodInvocationMatchingArguments(VarHandle.AccessMode accessMode) throws Exception {\n+        VarHandle v = handle();\n+\n+        \/\/ Try a reflective invoke using a Method, with the minimal required arguments\n+\n+        Method vhm = VarHandle.class.getMethod(accessMode.methodName(), Object[].class);\n+        Object arg = new Object[0];\n+        try {\n+            vhm.invoke(v, arg);\n+        } catch (InvocationTargetException e) {\n+            if (!(e.getCause() instanceof UnsupportedOperationException)) {\n+                throw new RuntimeException(\"expected UnsupportedOperationException but got: \"\n+                                           + e.getCause().getClass().getName(), e);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestReflection.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"}]}