{"files":[{"patch":"@@ -3304,0 +3304,192 @@\n+\n+    static final class IEEEremainder {\n+        private IEEEremainder() {throw new UnsupportedOperationException();}\n+\n+        static double compute(double x, double p) {\n+            int hx, hp;\n+            \/*unsigned*\/ int sx, lx, lp;\n+            double p_half;\n+\n+            hx = __HI(x);           \/\/ high word of x\n+            lx = __LO(x);           \/\/ low  word of x\n+            hp = __HI(p);           \/\/ high word of p\n+            lp = __LO(p);           \/\/ low  word of p\n+            sx = hx & 0x8000_0000;\n+            hp &= 0x7fff_ffff;\n+            hx &= 0x7fff_ffff;\n+\n+            \/\/ purge off exception values\n+            if ((hp | lp) == 0) {\/\/ p = 0\n+                return (x*p)\/(x*p);\n+            }\n+            if ((hx >= 0x7ff0_0000) ||                   \/\/ not finite\n+                ((hp >= 0x7ff0_0000) &&                   \/\/ p is NaN\n+                 (((hp - 0x7ff0_0000) | lp) != 0)))\n+                return (x*p)\/(x*p);\n+\n+            if (hp <= 0x7fdf_ffff) {  \/\/ now x < 2p\n+                x = __ieee754_fmod(x, p + p);\n+            }\n+            if (((hx - hp) | (lx - lp)) == 0) {\n+                return 0.0*x;\n+            }\n+            x  = Math.abs(x);\n+            p  = Math.abs(p);\n+            if (hp < 0x0020_0000) {\n+                if (x + x > p) {\n+                    x -= p;\n+                    if (x + x >= p) {\n+                        x -= p;\n+                    }\n+                }\n+            } else {\n+                p_half = 0.5*p;\n+                if (x > p_half) {\n+                    x -= p;\n+                    if (x >= p_half) {\n+                        x -= p;\n+                    }\n+                }\n+            }\n+            x = __HI(x, __HI(x)^sx);\n+            return x;\n+        }\n+\n+        private static double __ieee754_fmod(double x, double y) {\n+            int n, hx, hy, hz, ix, iy, sx;\n+            \/*unsigned*\/ int lx, ly, lz;\n+\n+            hx = __HI(x);           \/\/ high word of x\n+            lx = __LO(x);           \/\/ low  word of x\n+            hy = __HI(y);           \/\/ high word of y\n+            ly = __LO(y);           \/\/ low  word of y\n+            sx = hx & 0x8000_0000;  \/\/ sign of x\n+            hx ^= sx;               \/\/ |x|\n+            hy &= 0x7fff_ffff;      \/\/ |y|\n+\n+            \/\/ purge off exception values\n+            if((hy | ly) == 0 || (hx >= 0x7ff0_0000)||       \/\/ y = 0, or x not finite\n+               ((hy | ((ly | -ly) >> 31)) > 0x7ff0_0000))    \/\/ or y is NaN\n+                return (x*y)\/(x*y);\n+            if (hx <= hy) {\n+                if ((hx < hy) || (Integer.compareUnsigned(lx, ly) < 0)) { \/\/ |x| < |y| return x\n+                    return x;\n+                }\n+                if (lx == ly) {\n+                    return signedZero(sx);  \/\/ |x| = |y| return x*0\n+                }\n+            }\n+\n+            ix = ilogb(hx, lx);\n+            iy = ilogb(hy, ly);\n+\n+            \/\/ set up {hx, lx}, {hy, ly} and align y to x\n+            if (ix >= -1022)\n+                hx = 0x0010_0000 | (0x000f_ffff & hx);\n+            else {          \/\/ subnormal x, shift x to normal\n+                n = -1022 - ix;\n+                if (n <= 31) {\n+                    hx = (hx << n) | (lx >>> (32 - n)); \/\/ unsigned shift\n+                    lx <<= n;\n+                } else {\n+                    hx = lx << (n - 32);\n+                    lx = 0;\n+                }\n+            }\n+            if(iy >= -1022)\n+                hy = 0x0010_0000 | (0x000f_ffff & hy);\n+            else {          \/\/ subnormal y, shift y to normal\n+                n = -1022 - iy;\n+                if (n <= 31) {\n+                    hy = (hy << n)|(ly >>> (32 - n)); \/\/ unsigned shift\n+                    ly <<= n;\n+                } else {\n+                    hy = ly << (n - 32);\n+                    ly = 0;\n+                }\n+            }\n+\n+            \/\/ fix point fmod\n+            n = ix - iy;\n+            while(n-- != 0) {\n+                hz = hx - hy;\n+                lz = lx - ly;\n+                if (Integer.compareUnsigned(lx, ly) < 0) {\n+                    hz -= 1;\n+                }\n+                if (hz < 0){\n+                    hx = hx + hx +(lx >>> 31); \/\/ unsigned shift\n+                    lx = lx + lx;\n+                } else {\n+                    if ((hz | lz) == 0) {        \/\/ return sign(x)*0\n+                        return signedZero(sx);\n+                    }\n+                    hx = hz + hz + (lz >>> 31); \/\/ unsigned shift\n+                    lx = lz + lz;\n+                }\n+            }\n+            hz = hx - hy;\n+            lz = lx - ly;\n+            if (Integer.compareUnsigned(lx, ly) < 0) {\n+                hz -= 1;\n+            }\n+            if (hz >= 0) {\n+                hx = hz;\n+                lx = lz;\n+            }\n+\n+            \/\/ convert back to floating value and restore the sign\n+            if ((hx | lx) == 0) {                  \/\/ return sign(x)*0\n+                return signedZero(sx);\n+            }\n+            while (hx < 0x0010_0000) {          \/\/ normalize x\n+                hx = hx + hx + (lx >>> 31); \/\/ unsigned shift\n+                lx = lx + lx;\n+                iy -= 1;\n+            }\n+            if( iy >= -1022) {        \/\/ normalize output\n+                hx = ((hx - 0x0010_0000) | ((iy + 1023) << 20));\n+                x = __HI_LO(hx | sx, lx);\n+            } else {                \/\/ subnormal output\n+                n = -1022 - iy;\n+                if (n <= 20) {\n+                    lx = (lx >>> n)|(\/*(unsigned)*\/hx << (32 - n)); \/\/ unsigned shift\n+                    hx >>= n;\n+                } else if (n <= 31) {\n+                    lx = (hx << (32 - n))|(lx >>> n); \/\/ unsigned shift\n+                    hx = sx;\n+                } else {\n+                    lx = hx >>(n - 32);\n+                    hx = sx;\n+                }\n+                x = __HI_LO(hx | sx, lx);\n+                x *= 1.0;           \/\/ create necessary signal\n+            }\n+            return x;               \/\/ exact output\n+        }\n+\n+        \/*\n+         * Return a double zero with the same sign as the int argument.\n+         *\/\n+        private static double signedZero(int sign) {\n+            return +0.0 * ( (double)sign);\n+        }\n+\n+        private static int ilogb(int hz, int lz) {\n+            int iz, i;\n+            if (hz < 0x0010_0000) {     \/\/ subnormal z\n+                if (hz == 0) {\n+                    for (iz = -1043, i = lz; i > 0; i <<= 1) {\n+                        iz -= 1;\n+                    }\n+                } else {\n+                    for (iz = -1022, i = (hz << 11); i > 0; i <<= 1) {\n+                        iz -= 1;\n+                    }\n+                }\n+            } else {\n+                iz = (hz >> 20) - 1023;\n+            }\n+            return iz;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -372,1 +372,3 @@\n-    public static native double IEEEremainder(double f1, double f2);\n+    public static double IEEEremainder(double f1, double f2) {\n+        return FdLibm.IEEEremainder.compute(f1, f2);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 1994, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"fdlibm.h\"\n-\n-#include \"java_lang_StrictMath.h\"\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_cos(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jcos((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_sin(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jsin((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_tan(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jtan((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_asin(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jasin((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_acos(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jacos((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_atan(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jatan((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_log(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jlog((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_log10(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jlog10((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_sqrt(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jsqrt((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_atan2(JNIEnv *env, jclass unused, jdouble d1, jdouble d2)\n-{\n-    return (jdouble) jatan2((double)d1, (double)d2);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_IEEEremainder(JNIEnv *env, jclass unused,\n-                                  jdouble dividend,\n-                                  jdouble divisor)\n-{\n-    return (jdouble) jremainder(dividend, divisor);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_cosh(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jcosh((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_sinh(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jsinh((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_tanh(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jtanh((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_log1p(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jlog1p((double)d);\n-}\n-\n-JNIEXPORT jdouble JNICALL\n-Java_java_lang_StrictMath_expm1(JNIEnv *env, jclass unused, jdouble d)\n-{\n-    return (jdouble) jexpm1((double)d);\n-}\n","filename":"src\/java.base\/share\/native\/libjava\/StrictMath.c","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304028\n+ * @summary Tests for {Math, StrictMath}.IEEEremainder\n+ *\/\n+\n+public class IeeeRemainderTests {\n+    private IeeeRemainderTests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testIeeeRemainderSpecials();\n+        failures += testIeeeRemainderZeroResult();\n+        failures += testIeeeRemainderOneResult();\n+        failures += testIeeeRemainderRounding();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing IEEEremainder incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static final double NaNd      = Double.NaN;\n+    private static final double MIN_VALUE = Double.MIN_VALUE;\n+    private static final double MIN_NORM  = Double.MIN_NORMAL;\n+    private static final double MAX_VALUE = Double.MAX_VALUE;\n+    private static final double InfinityD = Double.POSITIVE_INFINITY;\n+\n+    \/**\n+     * Special cases from the spec interspersed with test cases.\n+     *\/\n+    private static int testIeeeRemainderSpecials() {\n+        int failures = 0;\n+\n+        \/*\n+         * If either argument is NaN, or the first argument is\n+         * infinite, or the second argument is positive zero or\n+         * negative zero, then the result is NaN.\n+         *\n+         *\/\n+        for(double nan : Tests.NaNs) {\n+            failures += testIEEEremainderCase(nan, 1.0, NaNd);\n+            failures += testIEEEremainderCase(1.0, nan, NaNd);\n+        }\n+\n+\n+        double [][] nanResultCases = {\n+            { InfinityD, InfinityD},\n+            {-InfinityD, InfinityD},\n+\n+            { InfinityD, 1.0},\n+            {-InfinityD, 1.0},\n+\n+            { InfinityD, NaNd},\n+            {-InfinityD, NaNd},\n+\n+            { InfinityD,  0.0},\n+            {-InfinityD,  0.0},\n+            { InfinityD, -0.0},\n+            {-InfinityD, -0.0},\n+        };\n+\n+        for(double[] testCase : nanResultCases) {\n+            failures += testIEEEremainderCase(testCase[0], testCase[1], NaNd);\n+        }\n+\n+        \/*\n+         * If the first argument is finite and the second argument is\n+         * infinite, then the result is the same as the first\n+         * argument.\n+         *\n+         *\/\n+        double [] specialCases = {\n+            +0.0,\n+            +MIN_VALUE,\n+            +MIN_NORM,\n+            +MAX_VALUE,\n+\n+            -0.0,\n+            -MIN_VALUE,\n+            -MIN_NORM,\n+            -MAX_VALUE,\n+        };\n+\n+        double [] infinities = {\n+            +InfinityD,\n+            -InfinityD\n+        };\n+\n+        for (double specialCase : specialCases) {\n+            for (double infinity: infinities) {\n+                failures += testIEEEremainderCase(specialCase, infinity, specialCase);\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testIeeeRemainderZeroResult() {\n+        int failures = 0;\n+\n+        double [] testCases = {\n+            +MIN_VALUE,\n+            +MIN_NORM,\n+            +MAX_VALUE*0.5,\n+\n+            -MIN_VALUE,\n+            -MIN_NORM,\n+            -MAX_VALUE*0.5,\n+        };\n+\n+        for (double testCase : testCases) {\n+            \/*\n+             * \"If the remainder is zero, its sign is the same as the sign of the first argument.\"\n+             *\/\n+            failures += testIEEEremainderCase(testCase*2.0, +testCase, Math.copySign(0.0, testCase));\n+            failures += testIEEEremainderCase(testCase*2.0, -testCase, Math.copySign(0.0, testCase));\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/*\n+     * Construct test cases where the remainder is one.\n+     *\/\n+    private static int testIeeeRemainderOneResult() {\n+        int failures = 0;\n+\n+        double [][] testCases = {\n+            {4.0,                  3.0},\n+\n+            {10_001.0,             5000.0},\n+\n+            {15_001.0,             5000.0},\n+\n+            {10_000.0,             9999.0},\n+\n+            {0x1.0p52 + 1.0,       0x1.0p52},\n+\n+            {0x1.fffffffffffffp52, 0x1.ffffffffffffep52},\n+        };\n+\n+        for (var testCase : testCases) {\n+            failures += testIEEEremainderCase(testCase[0], testCase[1], 1.0);\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/*\n+     * Test cases that differ in rounding between % and IEEEremainder.\n+     *\/\n+    private static int testIeeeRemainderRounding() {\n+        int failures = 0;\n+\n+        double [][] testCases = {\n+            {3.0,                2.0, -1.0},\n+            {3.0,               -2.0, -1.0},\n+        };\n+\n+        for (var testCase : testCases) {\n+            failures += testIEEEremainderCase(testCase[0], testCase[1], testCase[2]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/*\n+     * For exact cases, built-in % remainder and IEEE remainder should\n+     * be the same since the rounding mode in the implicit divide\n+     * doesn't come into play.\n+     *\/\n+    private static double remainder(double a, double b) {\n+        return a % b;\n+    }\n+\n+    private static int testIEEEremainderCase(double input1, double input2, double expected) {\n+        int failures = 0;\n+        failures += Tests.test(\"StrictMath.IEEEremainder\", input1, input2, StrictMath::IEEEremainder, expected);\n+        failures += Tests.test(\"Math.IEEEremainder\",       input1, input2, Math::IEEEremainder,       expected);\n+\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/IeeeRemainderTests.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301833 8302026 8301444 8302028 8302040 8302027\n+ * @bug 8301833 8302026 8301444 8302028 8302040 8302027 8304028\n@@ -138,0 +138,1 @@\n+            new BinaryTestCase(\"IEEEremainder\", FdlibmTranslit::IEEEremainder, StrictMath::IEEEremainder, 20, 20),\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExhaustingTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -145,0 +145,4 @@\n+    public static double IEEEremainder(double f1, double f2) {\n+        return IEEEremainder.compute(f1, f2);\n+    }\n+\n@@ -2586,0 +2590,167 @@\n+\n+    private static final class IEEEremainder {\n+        private static final double zero = 0.0;\n+        private static double one = 1.0;\n+        private static double[] Zero = {0.0, -0.0,};\n+\n+        static double compute(double x, double p) {\n+            int hx,hp;\n+            \/*unsigned*\/ int sx,lx,lp;\n+            double p_half;\n+\n+            hx = __HI(x);           \/* high word of x *\/\n+            lx = __LO(x);           \/* low  word of x *\/\n+            hp = __HI(p);           \/* high word of p *\/\n+            lp = __LO(p);           \/* low  word of p *\/\n+            sx = hx&0x80000000;\n+            hp &= 0x7fffffff;\n+            hx &= 0x7fffffff;\n+\n+            \/* purge off exception values *\/\n+            if((hp|lp)==0) return (x*p)\/(x*p);      \/* p = 0 *\/\n+            if((hx>=0x7ff00000)||                   \/* x not finite *\/\n+               ((hp>=0x7ff00000)&&                   \/* p is NaN *\/\n+                (((hp-0x7ff00000)|lp)!=0)))\n+                return (x*p)\/(x*p);\n+\n+\n+            if (hp<=0x7fdfffff) x = __ieee754_fmod(x,p+p);  \/* now x < 2p *\/\n+            if (((hx-hp)|(lx-lp))==0) return zero*x;\n+            x  = Math.abs(x);\n+            p  = Math.abs(p);\n+            if (hp<0x00200000) {\n+                if(x+x>p) {\n+                    x-=p;\n+                    if(x+x>=p) x -= p;\n+                }\n+            } else {\n+                p_half = 0.5*p;\n+                if(x>p_half) {\n+                    x-=p;\n+                    if(x>=p_half) x -= p;\n+                }\n+            }\n+            \/\/ __HI(x) ^= sx;\n+            x = __HI(x, __HI(x)^sx);\n+            return x;\n+        }\n+\n+        private static double __ieee754_fmod(double x, double y) {\n+            int n,hx,hy,hz,ix,iy,sx,i;\n+            \/*unsigned*\/ int lx,ly,lz;\n+\n+            hx = __HI(x);           \/* high word of x *\/\n+            lx = __LO(x);           \/* low  word of x *\/\n+            hy = __HI(y);           \/* high word of y *\/\n+            ly = __LO(y);           \/* low  word of y *\/\n+            sx = hx&0x80000000;             \/* sign of x *\/\n+            hx ^=sx;                \/* |x| *\/\n+            hy &= 0x7fffffff;       \/* |y| *\/\n+\n+            \/* purge off exception values *\/\n+            if((hy|ly)==0||(hx>=0x7ff00000)||       \/* y=0,or x not finite *\/\n+               ((hy|((ly|-ly)>>31))>0x7ff00000))     \/* or y is NaN *\/\n+                return (x*y)\/(x*y);\n+            if(hx<=hy) {\n+                \/\/ if((hx<hy)||(lx<ly)) return x;      \/* |x|<|y| return x *\/\n+                if((hx<hy)||(Integer.compareUnsigned(lx,ly) < 0))  return x;  \/* |x|<|y| return x *\/\n+                if(lx==ly)\n+                    return Zero[\/*(unsigned)*\/sx>>>31];  \/* |x|=|y| return x*0*\/ \/\/ unsigned shift\n+            }\n+\n+            \/* determine ix = ilogb(x) *\/\n+            if(hx<0x00100000) {     \/* subnormal x *\/\n+                if(hx==0) {\n+                    for (ix = -1043, i=lx; i>0; i<<=1) ix -=1;\n+                } else {\n+                    for (ix = -1022,i=(hx<<11); i>0; i<<=1) ix -=1;\n+                }\n+            } else ix = (hx>>20)-1023;\n+\n+            \/* determine iy = ilogb(y) *\/\n+            if(hy<0x00100000) {     \/* subnormal y *\/\n+                if(hy==0) {\n+                    for (iy = -1043, i=ly; i>0; i<<=1) iy -=1;\n+                } else {\n+                    for (iy = -1022,i=(hy<<11); i>0; i<<=1) iy -=1;\n+                }\n+            } else iy = (hy>>20)-1023;\n+\n+            \/* set up {hx,lx}, {hy,ly} and align y to x *\/\n+            if(ix >= -1022)\n+                hx = 0x00100000|(0x000fffff&hx);\n+            else {          \/* subnormal x, shift x to normal *\/\n+                n = -1022-ix;\n+                if(n<=31) {\n+                    hx = (hx<<n)|(lx >>> (32-n)); \/\/ unsigned shift\n+                    lx <<= n;\n+                } else {\n+                    hx = lx<<(n-32);\n+                    lx = 0;\n+                }\n+            }\n+            if(iy >= -1022)\n+                hy = 0x00100000|(0x000fffff&hy);\n+            else {          \/* subnormal y, shift y to normal *\/\n+                n = -1022-iy;\n+                if(n<=31) {\n+                    hy = (hy<<n)|(ly >>> (32-n)); \/\/ unsigned shift\n+                    ly <<= n;\n+                } else {\n+                    hy = ly<<(n-32);\n+                    ly = 0;\n+                }\n+            }\n+\n+            \/* fix point fmod *\/\n+            n = ix - iy;\n+            while(n-- != 0) {\n+                hz=hx-hy;lz=lx-ly;\n+                \/\/ if(lx<ly) hz -= 1;\n+                if(Integer.compareUnsigned(lx, ly) < 0) hz -= 1;\n+                if(hz<0){hx = hx+hx+(lx >>> 31); lx = lx+lx;} \/\/ unsigned shift\n+                else {\n+                    if((hz|lz)==0)          \/* return sign(x)*0 *\/\n+                        return Zero[\/*(unsigned)*\/sx>>>31]; \/\/ unsigned shift\n+                    hx = hz+hz+(lz >>> 31); \/\/ unsigned shift\n+                    lx = lz+lz;\n+                }\n+            }\n+            hz=hx-hy;lz=lx-ly;\n+            \/\/ if(lx<ly) hz -= 1;\n+            if(Integer.compareUnsigned(lx, ly) < 0) hz -= 1;\n+            if(hz>=0) {hx=hz;lx=lz;}\n+\n+            \/* convert back to floating value and restore the sign *\/\n+            if((hx|lx)==0)                  \/* return sign(x)*0 *\/\n+                return Zero[\/*(unsigned)*\/sx >>> 31]; \/\/ unsigned shift\n+            while(hx<0x00100000) {          \/* normalize x *\/\n+                hx = hx+hx+(lx >>> 31); lx = lx+lx; \/\/ unsigned shift\n+                iy -= 1;\n+            }\n+            if(iy>= -1022) {        \/* normalize output *\/\n+                hx = ((hx-0x00100000)|((iy+1023)<<20));\n+                \/\/ __HI(x) = hx|sx;\n+                x = __HI(x, hx|sx);\n+                \/\/ __LO(x) = lx;\n+                x = __LO(x, lx);\n+            } else {                \/* subnormal output *\/\n+                n = -1022 - iy;\n+                if(n<=20) {\n+                    lx = (lx >>> n)|(\/*(unsigned)*\/hx<<(32-n)); \/\/ unsigned shift\n+                    hx >>= n;\n+                } else if (n<=31) {\n+                    lx = (hx<<(32-n))|(lx >>> n); \/\/ unsigned shift\n+                    hx = sx;\n+                } else {\n+                    lx = hx>>(n-32); hx = sx;\n+                }\n+                \/\/ __HI(x) = hx|sx;\n+                x = __HI(x, hx|sx);\n+                \/\/ __LO(x) = lx;\n+                x = __LO(x, lx);\n+                x *= one;           \/* create necessary signal *\/\n+            }\n+            return x;               \/* exact output *\/\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"modified"}]}