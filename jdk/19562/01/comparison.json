{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,4 +67,0 @@\n-\n-bool MallocHeader::get_stack(NativeCallStack& stack) const {\n-  return MallocSiteTable::access_stack(stack, _mst_marker);\n-}\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -133,1 +133,0 @@\n-  bool get_stack(NativeCallStack& stack) const;\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,2 +134,2 @@\n-  static inline bool access_stack(NativeCallStack& stack, uint32_t marker) {\n-    MallocSite* site = malloc_site(marker);\n+  static inline bool access_stack(NativeCallStack& stack, const MallocHeader& header) {\n+    MallocSite* site = malloc_site(header.mst_marker());\n","filename":"src\/hotspot\/share\/nmt\/mallocSiteTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -302,1 +302,1 @@\n-      if (block->get_stack(ncs)) {\n+      if (MallocSiteTable::access_stack(ncs, *block)) {\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}