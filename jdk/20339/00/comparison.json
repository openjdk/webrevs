{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,4 @@\n-import jdk.internal.misc.Unsafe;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -32,1 +35,1 @@\n- * The RenderBuffer class is a simplified, high-performance, Unsafe wrapper\n+ * The RenderBuffer class is a simplified, high-performance class\n@@ -34,1 +37,1 @@\n- * environment.  It's functionality is similar to the ByteBuffer and related\n+ * environment.  Its functionality is similar to the ByteBuffer and related\n@@ -41,0 +44,1 @@\n+ * Failure to do so will result in exceptions from the FFM API, or worse.\n@@ -46,1 +50,1 @@\n-public class RenderBuffer {\n+public final class RenderBuffer {\n@@ -51,6 +55,6 @@\n-    protected static final long SIZEOF_BYTE   = 1L;\n-    protected static final long SIZEOF_SHORT  = 2L;\n-    protected static final long SIZEOF_INT    = 4L;\n-    protected static final long SIZEOF_FLOAT  = 4L;\n-    protected static final long SIZEOF_LONG   = 8L;\n-    protected static final long SIZEOF_DOUBLE = 8L;\n+    private static final int SIZEOF_BYTE   = 1;\n+    private static final int SIZEOF_SHORT  = 2;\n+    private static final int SIZEOF_INT    = 4;\n+    private static final int SIZEOF_FLOAT  = 4;\n+    private static final int SIZEOF_LONG   = 8;\n+    private static final int SIZEOF_DOUBLE = 8;\n@@ -59,7 +63,4 @@\n-     * Represents the number of elements at which we have empirically\n-     * determined that the average cost of a JNI call exceeds the expense\n-     * of an element by element copy.  In other words, if the number of\n-     * elements in an array to be copied exceeds this value, then we should\n-     * use the copyFromArray() method to complete the bulk put operation.\n-     * (This value can be adjusted if the cost of JNI downcalls is reduced\n-     * in a future release.)\n+     * Measurements show that using the copy API from a segment backed by a heap\n+     * array gets reliably faster than individual puts around a length of 10.\n+     * However the time is miniscule in the context of what it is used for\n+     * and much more than adequate, so no problem expected if this changes over time.\n@@ -67,12 +68,11 @@\n-    private static final int COPY_FROM_ARRAY_THRESHOLD = 6;\n-\n-    protected final Unsafe unsafe;\n-    protected final long baseAddress;\n-    protected final long endAddress;\n-    protected long curAddress;\n-    protected final int capacity;\n-\n-    protected RenderBuffer(int numBytes) {\n-        unsafe = Unsafe.getUnsafe();\n-        curAddress = baseAddress = unsafe.allocateMemory(numBytes);\n-        endAddress = baseAddress + numBytes;\n+    private static final int COPY_FROM_ARRAY_THRESHOLD = 10;\n+\n+    MemorySegment segment;\n+    private final long baseAddress;\n+    private long curOffset;\n+    private final int capacity;\n+\n+    private RenderBuffer(int numBytes) {\n+        segment = Arena.global().allocate(numBytes, SIZEOF_DOUBLE);\n+        baseAddress = segment.address();\n+        curOffset = 0L;\n@@ -106,1 +106,1 @@\n-        return (int)(endAddress - curAddress);\n+        return (int)(capacity - curOffset);\n@@ -110,1 +110,1 @@\n-        return (int)(curAddress - baseAddress);\n+        return (int)(curOffset);\n@@ -114,1 +114,1 @@\n-        curAddress = baseAddress + numBytes;\n+        curOffset = numBytes;\n@@ -118,1 +118,1 @@\n-        curAddress = baseAddress;\n+        curOffset = 0L;\n@@ -122,1 +122,1 @@\n-        curAddress += numBytes;\n+        curOffset += numBytes;\n@@ -131,2 +131,2 @@\n-        unsafe.putByte(curAddress, x);\n-        curAddress += SIZEOF_BYTE;\n+        segment.set(JAVA_BYTE, curOffset, x);\n+        curOffset += SIZEOF_BYTE;\n@@ -142,3 +142,3 @@\n-            long offsetInBytes = offset * SIZEOF_BYTE + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_BYTE;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n+            int offsetInBytes = offset * SIZEOF_BYTE;\n+            int lengthInBytes = length * SIZEOF_BYTE;\n+            MemorySegment.copy(x, offsetInBytes, segment, JAVA_BYTE, curOffset, length);\n@@ -161,2 +161,2 @@\n-        unsafe.putShort(curAddress, x);\n-        curAddress += SIZEOF_SHORT;\n+        segment.set(JAVA_SHORT, curOffset, x);\n+        curOffset += SIZEOF_SHORT;\n@@ -173,3 +173,3 @@\n-            long offsetInBytes = offset * SIZEOF_SHORT + Unsafe.ARRAY_SHORT_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_SHORT;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n+            int offsetInBytes = offset * SIZEOF_SHORT;\n+            int lengthInBytes = length * SIZEOF_SHORT;\n+            MemorySegment.copy(x, offsetInBytes, segment, JAVA_SHORT, curOffset, length);\n@@ -192,1 +192,1 @@\n-        unsafe.putInt(baseAddress + pos, x);\n+        segment.set(JAVA_INT, pos, x);\n@@ -198,2 +198,2 @@\n-        unsafe.putInt(curAddress, x);\n-        curAddress += SIZEOF_INT;\n+        segment.set(JAVA_INT, curOffset, x);\n+        curOffset += SIZEOF_INT;\n@@ -210,3 +210,3 @@\n-            long offsetInBytes = offset * SIZEOF_INT + Unsafe.ARRAY_INT_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_INT;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n+            int offsetInBytes = offset * SIZEOF_INT;\n+            int lengthInBytes = length * SIZEOF_INT;\n+            MemorySegment.copy(x, offsetInBytes, segment, JAVA_INT, curOffset, length);\n@@ -229,2 +229,2 @@\n-        unsafe.putFloat(curAddress, x);\n-        curAddress += SIZEOF_FLOAT;\n+        segment.set(JAVA_FLOAT, curOffset, x);\n+        curOffset += SIZEOF_FLOAT;\n@@ -241,3 +241,3 @@\n-            long offsetInBytes = offset * SIZEOF_FLOAT + Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_FLOAT;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n+            int offsetInBytes = offset * SIZEOF_FLOAT;\n+            int lengthInBytes = length * SIZEOF_FLOAT;\n+            MemorySegment.copy(x, offsetInBytes, segment, JAVA_FLOAT, curOffset, length);\n@@ -260,2 +260,2 @@\n-        unsafe.putLong(curAddress, x);\n-        curAddress += SIZEOF_LONG;\n+        segment.set(JAVA_LONG, curOffset, x);\n+        curOffset += SIZEOF_LONG;\n@@ -272,3 +272,3 @@\n-            long offsetInBytes = offset * SIZEOF_LONG + Unsafe.ARRAY_LONG_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_LONG;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n+            int offsetInBytes = offset * SIZEOF_LONG;\n+            int lengthInBytes = length * SIZEOF_LONG;\n+            MemorySegment.copy(x, offsetInBytes, segment, JAVA_LONG, curOffset, length);\n@@ -291,2 +291,2 @@\n-        unsafe.putDouble(curAddress, x);\n-        curAddress += SIZEOF_DOUBLE;\n+        segment.set(JAVA_DOUBLE, curOffset, x);\n+        curOffset += SIZEOF_DOUBLE;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/RenderBuffer.java","additions":63,"deletions":63,"binary":false,"changes":126,"status":"modified"}]}