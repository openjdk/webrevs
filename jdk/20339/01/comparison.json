{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,4 @@\n-import jdk.internal.misc.Unsafe;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -32,1 +35,1 @@\n- * The RenderBuffer class is a simplified, high-performance, Unsafe wrapper\n+ * The RenderBuffer class is a simplified, high-performance class\n@@ -34,1 +37,1 @@\n- * environment.  It's functionality is similar to the ByteBuffer and related\n+ * environment.  Its functionality is similar to the ByteBuffer and related\n@@ -41,0 +44,1 @@\n+ * Failure to do so will result in exceptions from the FFM API, or worse.\n@@ -46,1 +50,1 @@\n-public class RenderBuffer {\n+public final class RenderBuffer {\n@@ -51,6 +55,6 @@\n-    protected static final long SIZEOF_BYTE   = 1L;\n-    protected static final long SIZEOF_SHORT  = 2L;\n-    protected static final long SIZEOF_INT    = 4L;\n-    protected static final long SIZEOF_FLOAT  = 4L;\n-    protected static final long SIZEOF_LONG   = 8L;\n-    protected static final long SIZEOF_DOUBLE = 8L;\n+    private static final int SIZEOF_BYTE   = 1;\n+    private static final int SIZEOF_SHORT  = 2;\n+    private static final int SIZEOF_INT    = 4;\n+    private static final int SIZEOF_FLOAT  = 4;\n+    private static final int SIZEOF_LONG   = 8;\n+    private static final int SIZEOF_DOUBLE = 8;\n@@ -59,7 +63,4 @@\n-     * Represents the number of elements at which we have empirically\n-     * determined that the average cost of a JNI call exceeds the expense\n-     * of an element by element copy.  In other words, if the number of\n-     * elements in an array to be copied exceeds this value, then we should\n-     * use the copyFromArray() method to complete the bulk put operation.\n-     * (This value can be adjusted if the cost of JNI downcalls is reduced\n-     * in a future release.)\n+     * Measurements show that using the copy API from a segment backed by a heap\n+     * array gets reliably faster than individual puts around a length of 10.\n+     * However the time is miniscule in the context of what it is used for\n+     * and much more than adequate, so no problem expected if this changes over time.\n@@ -67,13 +68,8 @@\n-    private static final int COPY_FROM_ARRAY_THRESHOLD = 6;\n-\n-    protected final Unsafe unsafe;\n-    protected final long baseAddress;\n-    protected final long endAddress;\n-    protected long curAddress;\n-    protected final int capacity;\n-\n-    protected RenderBuffer(int numBytes) {\n-        unsafe = Unsafe.getUnsafe();\n-        curAddress = baseAddress = unsafe.allocateMemory(numBytes);\n-        endAddress = baseAddress + numBytes;\n-        capacity = numBytes;\n+    private static final int COPY_FROM_ARRAY_THRESHOLD = 10;\n+\n+    private final MemorySegment segment;\n+    private int curOffset;\n+\n+    private RenderBuffer(int numBytes) {\n+        segment = Arena.global().allocate(numBytes, SIZEOF_DOUBLE);\n+        curOffset = 0;\n@@ -93,1 +89,1 @@\n-        return baseAddress;\n+        return segment.address();\n@@ -102,1 +98,1 @@\n-        return capacity;\n+        return (int)segment.byteSize();\n@@ -106,1 +102,1 @@\n-        return (int)(endAddress - curAddress);\n+        return (capacity() - curOffset);\n@@ -110,1 +106,1 @@\n-        return (int)(curAddress - baseAddress);\n+        return curOffset;\n@@ -113,2 +109,2 @@\n-    public final void position(long numBytes) {\n-        curAddress = baseAddress + numBytes;\n+    public final void position(int bytePos) {\n+        curOffset = bytePos;\n@@ -118,1 +114,1 @@\n-        curAddress = baseAddress;\n+        curOffset = 0;\n@@ -121,2 +117,2 @@\n-    public final RenderBuffer skip(long numBytes) {\n-        curAddress += numBytes;\n+    public final RenderBuffer skip(int numBytes) {\n+        curOffset += numBytes;\n@@ -131,2 +127,2 @@\n-        unsafe.putByte(curAddress, x);\n-        curAddress += SIZEOF_BYTE;\n+        segment.set(JAVA_BYTE, curOffset, x);\n+        curOffset += SIZEOF_BYTE;\n@@ -142,4 +138,2 @@\n-            long offsetInBytes = offset * SIZEOF_BYTE + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_BYTE;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n-            position(position() + lengthInBytes);\n+            MemorySegment.copy(x, offset, segment, JAVA_BYTE, curOffset, length);\n+            position(position() + length * SIZEOF_BYTE);\n@@ -161,2 +155,2 @@\n-        unsafe.putShort(curAddress, x);\n-        curAddress += SIZEOF_SHORT;\n+        segment.set(JAVA_SHORT, curOffset, x);\n+        curOffset += SIZEOF_SHORT;\n@@ -173,4 +167,2 @@\n-            long offsetInBytes = offset * SIZEOF_SHORT + Unsafe.ARRAY_SHORT_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_SHORT;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n-            position(position() + lengthInBytes);\n+            MemorySegment.copy(x, offset, segment, JAVA_SHORT, curOffset, length);\n+            position(position() + length * SIZEOF_SHORT);\n@@ -191,2 +183,2 @@\n-        \/\/ assert (baseAddress + pos % SIZEOF_INT == 0);\n-        unsafe.putInt(baseAddress + pos, x);\n+        \/\/ assert (getAddress() + pos % SIZEOF_INT == 0);\n+        segment.set(JAVA_INT, pos, x);\n@@ -198,2 +190,2 @@\n-        unsafe.putInt(curAddress, x);\n-        curAddress += SIZEOF_INT;\n+        segment.set(JAVA_INT, curOffset, x);\n+        curOffset += SIZEOF_INT;\n@@ -210,4 +202,2 @@\n-            long offsetInBytes = offset * SIZEOF_INT + Unsafe.ARRAY_INT_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_INT;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n-            position(position() + lengthInBytes);\n+            MemorySegment.copy(x, offset, segment, JAVA_INT, curOffset, length);\n+            position(position() + length * SIZEOF_INT);\n@@ -229,2 +219,2 @@\n-        unsafe.putFloat(curAddress, x);\n-        curAddress += SIZEOF_FLOAT;\n+        segment.set(JAVA_FLOAT, curOffset, x);\n+        curOffset += SIZEOF_FLOAT;\n@@ -241,4 +231,2 @@\n-            long offsetInBytes = offset * SIZEOF_FLOAT + Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_FLOAT;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n-            position(position() + lengthInBytes);\n+            MemorySegment.copy(x, offset, segment, JAVA_FLOAT, curOffset, length);\n+            position(position() + length * SIZEOF_FLOAT);\n@@ -260,2 +248,2 @@\n-        unsafe.putLong(curAddress, x);\n-        curAddress += SIZEOF_LONG;\n+        segment.set(JAVA_LONG, curOffset, x);\n+        curOffset += SIZEOF_LONG;\n@@ -272,4 +260,2 @@\n-            long offsetInBytes = offset * SIZEOF_LONG + Unsafe.ARRAY_LONG_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_LONG;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n-            position(position() + lengthInBytes);\n+            MemorySegment.copy(x, offset, segment, JAVA_LONG, curOffset, length);\n+            position(position() + length * SIZEOF_LONG);\n@@ -291,2 +277,2 @@\n-        unsafe.putDouble(curAddress, x);\n-        curAddress += SIZEOF_DOUBLE;\n+        segment.set(JAVA_DOUBLE, curOffset, x);\n+        curOffset += SIZEOF_DOUBLE;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/RenderBuffer.java","additions":60,"deletions":74,"binary":false,"changes":134,"status":"modified"}]}