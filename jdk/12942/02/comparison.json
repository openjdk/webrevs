{"files":[{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/rootnode.hpp\"\n@@ -214,1 +215,0 @@\n-  ResourceMark rm;\n@@ -3892,13 +3892,1 @@\n-    Node* invar_scale = align_to_ref_p.invar_scale();\n-    if (invar_scale != nullptr) {\n-      invar = new LShiftINode(invar, invar_scale);\n-      _igvn.register_new_node_with_optimizer(invar);\n-    }\n-    Node* aref = new URShiftINode(invar, log2_elt);\n-    _igvn.register_new_node_with_optimizer(aref);\n-    _phase->set_ctrl(aref, pre_ctrl);\n-    if (align_to_ref_p.negate_invar()) {\n-      e = new SubINode(e, aref);\n-    } else {\n-      e = new AddINode(e, aref);\n-    }\n+    e = new URShiftINode(invar, log2_elt);\n@@ -4080,3 +4068,5 @@\n-  _mem(mem), _slp(slp),  _base(nullptr),  _adr(nullptr),\n-  _scale(0), _offset(0), _invar(nullptr), _negate_invar(false),\n-  _invar_scale(nullptr),\n+  _mem(mem), _slp(slp), _base(nullptr), _adr(nullptr),\n+  _scale(0), _offset(0), _invar(nullptr),\n+#ifdef ASSERT\n+  _debug_invar(nullptr), _debug_negate_invar(false), _debug_invar_scale(nullptr),\n+#endif\n@@ -4113,1 +4103,1 @@\n-  for (i = 0; i < 3; i++) {\n+  for (i = 0; ; i++) {\n@@ -4149,3 +4139,5 @@\n-  _mem(p->_mem), _slp(p->_slp),  _base(nullptr),  _adr(nullptr),\n-  _scale(0), _offset(0), _invar(nullptr), _negate_invar(false),\n-  _invar_scale(nullptr),\n+  _mem(p->_mem), _slp(p->_slp), _base(nullptr), _adr(nullptr),\n+  _scale(0), _offset(0), _invar(nullptr),\n+#ifdef ASSERT\n+  _debug_invar(nullptr), _debug_negate_invar(false), _debug_invar_scale(nullptr),\n+#endif\n@@ -4265,1 +4257,1 @@\n-    if (!has_iv() && _invar == nullptr) {\n+    if (!has_iv()) {\n@@ -4277,4 +4269,7 @@\n-        _invar = tmp._invar;\n-        if (_invar != nullptr) {\n-          _negate_invar = tmp._negate_invar;\n-          _invar_scale = n->in(2);\n+        if (tmp._invar != nullptr) {\n+          BasicType bt = tmp._invar->bottom_type()->basic_type();\n+          assert(bt == T_INT || bt == T_LONG, \"\");\n+          maybe_add_to_invar(register_if_new(LShiftNode::make(tmp._invar, n->in(2), bt)));\n+#ifdef ASSERT\n+          _debug_invar_scale = n->in(2);\n+#endif\n@@ -4282,1 +4277,1 @@\n-        NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, _invar, _negate_invar);)\n+        NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, _invar);)\n@@ -4316,4 +4311,1 @@\n-  if (_invar != nullptr) { \/\/ already has an invariant\n-    NOT_PRODUCT(_tracer.offset_plus_k_5(n, _invar);)\n-    return false;\n-  }\n+  assert((_debug_invar == nullptr) == (_invar == nullptr), \"\");\n@@ -4326,2 +4318,1 @@\n-      _negate_invar = negate;\n-      _invar = n->in(1);\n+      maybe_add_to_invar(maybe_negate_invar(negate, n->in(1)));\n@@ -4329,1 +4320,1 @@\n-      NOT_PRODUCT(_tracer.offset_plus_k_6(n, _invar, _negate_invar, _offset);)\n+      NOT_PRODUCT(_tracer.offset_plus_k_6(n, _invar, negate, _offset);)\n@@ -4333,3 +4324,2 @@\n-      _negate_invar = negate;\n-      _invar = n->in(2);\n-      NOT_PRODUCT(_tracer.offset_plus_k_7(n, _invar, _negate_invar, _offset);)\n+      maybe_add_to_invar(maybe_negate_invar(negate, n->in(2)));\n+      NOT_PRODUCT(_tracer.offset_plus_k_7(n, _invar, negate, _offset);)\n@@ -4341,2 +4331,1 @@\n-      _negate_invar = negate;\n-      _invar = n->in(1);\n+      maybe_add_to_invar(maybe_negate_invar(negate, n->in(1)));\n@@ -4344,1 +4333,1 @@\n-      NOT_PRODUCT(_tracer.offset_plus_k_8(n, _invar, _negate_invar, _offset);)\n+      NOT_PRODUCT(_tracer.offset_plus_k_8(n, _invar, negate, _offset);)\n@@ -4348,3 +4337,2 @@\n-      _negate_invar = !negate;\n-      _invar = n->in(2);\n-      NOT_PRODUCT(_tracer.offset_plus_k_9(n, _invar, _negate_invar, _offset);)\n+      maybe_add_to_invar(maybe_negate_invar(!negate, n->in(2)));\n+      NOT_PRODUCT(_tracer.offset_plus_k_9(n, _invar, !negate, _offset);)\n@@ -4367,3 +4355,2 @@\n-      _negate_invar = negate;\n-      _invar = n;\n-      NOT_PRODUCT(_tracer.offset_plus_k_10(n, _invar, _negate_invar, _offset);)\n+      maybe_add_to_invar(maybe_negate_invar(negate, n));\n+      NOT_PRODUCT(_tracer.offset_plus_k_10(n, _invar, negate, _offset);)\n@@ -4378,0 +4365,60 @@\n+Node* SWPointer::maybe_negate_invar(bool negate, Node* invar) {\n+#ifdef ASSERT\n+  _debug_negate_invar = negate;\n+#endif\n+  if (negate) {\n+    BasicType bt = invar->bottom_type()->basic_type();\n+    assert(bt == T_INT || bt == T_LONG, \"\");\n+    PhaseIterGVN& igvn = phase()->igvn();\n+    Node* zero = igvn.zerocon(bt);\n+    phase()->set_ctrl(zero, phase()->C->root());\n+    Node* sub = SubNode::make(zero, invar, bt);\n+    invar = register_if_new(sub);\n+  }\n+  return invar;\n+}\n+\n+Node* SWPointer::register_if_new(Node* n) const {\n+  PhaseIterGVN& igvn = phase()->igvn();\n+  Node* prev = igvn.hash_find_insert(n);\n+  if (prev != nullptr) {\n+    n->destruct(&igvn);\n+    n = prev;\n+  } else {\n+    Node* c = phase()->get_early_ctrl(n);\n+    phase()->register_new_node(n, c);\n+  }\n+  return n;\n+}\n+\n+void SWPointer::maybe_add_to_invar(Node* new_invar) {\n+  if (_invar == nullptr) {\n+    _invar = new_invar;\n+#ifdef ASSERT\n+    _debug_invar = new_invar;\n+#endif\n+    return;\n+  }\n+#ifdef ASSERT\n+  _debug_invar = NodeSentinel;\n+#endif\n+  BasicType new_invar_bt = new_invar->bottom_type()->basic_type();\n+  assert(new_invar_bt == T_INT || new_invar_bt == T_LONG, \"\");\n+  BasicType invar_bt = _invar->bottom_type()->basic_type();\n+  assert(invar_bt == T_INT || invar_bt == T_LONG, \"\");\n+\n+  BasicType bt = (new_invar_bt == T_LONG || invar_bt == T_LONG) ? T_LONG : T_INT;\n+  Node* current_invar = _invar;\n+  if (invar_bt != bt) {\n+    assert(bt == T_LONG && invar_bt == T_INT, \"\");\n+    assert(new_invar_bt == bt, \"\");\n+    current_invar = register_if_new(new ConvI2LNode(current_invar));\n+  } else if (new_invar_bt != bt) {\n+    assert(bt == T_LONG && new_invar_bt == T_INT, \"\");\n+    assert(invar_bt == bt, \"\");\n+    new_invar = register_if_new(new ConvI2LNode(new_invar));\n+  }\n+  Node* add = AddNode::make(current_invar, new_invar, bt);\n+  _invar = register_if_new(add);\n+}\n+\n@@ -4414,1 +4461,1 @@\n-    tty->print(\"  invar: %c[%d] << [%d]\", _negate_invar?'-':'+', _invar->_idx, _invar_scale->_idx);\n+    tty->print(\"  invar: [%d]\", _invar->_idx);\n@@ -4604,1 +4651,1 @@\n-void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int offset, Node* invar, bool negate_invar) {\n+void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int offset, Node* invar) {\n@@ -4610,1 +4657,1 @@\n-      print_depth(); tty->print_cr(\"  \\\\ SWPointer::scaled_iv: scaled invariant: %c[%d]\", (negate_invar?'-':'+'), invar->_idx);\n+      print_depth(); tty->print_cr(\"  \\\\ SWPointer::scaled_iv: scaled invariant: [%d]\", invar->_idx);\n@@ -4662,1 +4709,1 @@\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d\",\n+    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _debug_negate_invar = %d, _invar = %d, _offset = %d\",\n@@ -4671,1 +4718,1 @@\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d\",\n+    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _debug_negate_invar = %d, _invar = %d, _offset = %d\",\n@@ -4680,1 +4727,1 @@\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_SubI is PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d\",\n+    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_SubI is PASSED, setting _debug_negate_invar = %d, _invar = %d, _offset = %d\",\n@@ -4689,1 +4736,1 @@\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_SubI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d\", n->_idx, _negate_invar, _invar->_idx, _offset);\n+    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_SubI PASSED, setting _debug_negate_invar = %d, _invar = %d, _offset = %d\", n->_idx, _negate_invar, _invar->_idx, _offset);\n@@ -4697,1 +4744,1 @@\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d\", n->_idx, _negate_invar, _invar->_idx, _offset);\n+    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: PASSED, setting _debug_negate_invar = %d, _invar = %d, _offset = %d\", n->_idx, _negate_invar, _invar->_idx, _offset);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":101,"deletions":54,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -639,2 +639,5 @@\n-  bool  _negate_invar;       \/\/ if true then use: (0 - _invar)\n-  Node* _invar_scale;        \/\/ multiplier for invariant\n+#ifdef ASSERT\n+  Node* _debug_invar;\n+  bool  _debug_negate_invar;       \/\/ if true then use: (0 - _invar)\n+  Node* _debug_invar_scale;        \/\/ multiplier for invariant\n+#endif\n@@ -682,2 +685,0 @@\n-  bool  negate_invar()     { return _negate_invar; }\n-  Node* invar_scale()      { return _invar_scale; }\n@@ -690,3 +691,5 @@\n-      return (_invar        == q._invar   &&\n-              _invar_scale  == q._invar_scale &&\n-              _negate_invar == q._negate_invar);\n+    assert(_debug_invar == NodeSentinel || q._debug_invar == NodeSentinel ||\n+           (_invar == q._invar) == (_debug_invar == q._debug_invar &&\n+                                    _debug_invar_scale == q._debug_invar_scale &&\n+                                    _debug_negate_invar == q._debug_negate_invar), \"\");\n+    return _invar == q._invar;\n@@ -770,1 +773,1 @@\n-    void scaled_iv_9(Node* n, int _scale, int _offset, Node* _invar, bool _negate_invar);\n+    void scaled_iv_9(Node* n, int _scale, int _offset, Node* _invar);\n@@ -787,0 +790,6 @@\n+\n+  Node* maybe_negate_invar(bool negate, Node* invar);\n+\n+  void maybe_add_to_invar(Node* new_invar);\n+\n+  Node* register_if_new(Node* n) const;\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+import java.util.Objects;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8300257\n+ * @requires (os.simpleArch == \"x64\") | (os.simpleArch == \"aarch64\")\n+ * @summary C2: vectorization fails on some simple Memory Segment loops\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestVectorizationMultiInvar\n+ *\/\n+\n+public class TestVectorizationMultiInvar {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+    }\n+\n+    static int size = 1024;\n+    static byte[] byteArray = new byte[size * 8];\n+    static int[] intArray = new int[size];\n+    static long[] longArray = new long[size];\n+    static long baseOffset = 0;\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    public static void testByteLong1(byte[] dest, long[] src) {\n+        for (int i = 0; i < src.length; i++) {\n+            long j = Objects.checkIndex(i * 8, (long)(src.length * 8));\n+            UNSAFE.putLongUnaligned(dest, baseOffset + j, src[i]);\n+        }\n+    }\n+\n+    @Run(test = \"testByteLong1\")\n+    public static void testByteLong1_runner() {\n+        baseOffset = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+        testByteLong1(byteArray, longArray);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    public static void testLoopNest1(byte[] dest, byte[] src,\n+                                     long start1, long stop1,\n+                                     long start2, long stop2,\n+                                     long start3, long stop3,\n+                                     long start4, long stop4,\n+                                     long start5, long stop5) {\n+        if (src == null || dest == null) {\n+        }\n+        for (long i = start1; i < stop1; i++) {\n+            for (long j = start2; j < stop2; j++) {\n+                for (long k = start3; k < stop3; k++) {\n+                    for (long l = start4; l < stop4; l++) {\n+                        for (long m = start5; m < stop5; m++) {\n+                            long invar = i + j + k + l + m;\n+                            for (int n = 0; n < src.length - (int)invar; n++) {\n+                                UNSAFE.putByte(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + n + invar, UNSAFE.getByte(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + n + invar));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"testLoopNest1\")\n+    public static void testLoopNest1_runner() {\n+        testLoopNest1(byteArray, byteArray, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    public static void testLoopNest2(int[] dest, int[] src,\n+                                     long start1, long stop1,\n+                                     long start2, long stop2,\n+                                     long start3, long stop3,\n+                                     long start4, long stop4,\n+                                     long start5, long stop5) {\n+        if (src == null || dest == null) {\n+        }\n+        for (long i = start1; i < stop1; i++) {\n+            for (long j = start2; j < stop2; j++) {\n+                for (long k = start3; k < stop3; k++) {\n+                    for (long l = start4; l < stop4; l++) {\n+                        for (long m = start5; m < stop5; m++) {\n+                            long invar = i + j + k + l + m;\n+                            for (int n = 0; n < src.length - (int)invar; n++) {\n+                                UNSAFE.putInt(dest, UNSAFE.ARRAY_INT_BASE_OFFSET + (n + invar) * UNSAFE.ARRAY_INT_INDEX_SCALE, UNSAFE.getInt(src, UNSAFE.ARRAY_INT_BASE_OFFSET + (n + invar) * UNSAFE.ARRAY_INT_INDEX_SCALE));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"testLoopNest2\")\n+    public static void testLoopNest2_runner() {\n+        testLoopNest2(intArray, intArray, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMultiInvar.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}