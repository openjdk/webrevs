{"files":[{"patch":"@@ -52,1 +52,0 @@\n-import java.util.Collections;\n@@ -381,17 +380,14 @@\n-        Set<String> roots = new HashSet<>();\n-        for (String mod : options.addMods) {\n-            if (mod.equals(ALL_MODULE_PATH) && options.modulePath.size() > 0) {\n-                ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, Set.of());\n-                \/\/ all observable modules are roots\n-                finder.findAll()\n-                      .stream()\n-                      .map(ModuleReference::descriptor)\n-                      .map(ModuleDescriptor::name)\n-                      .forEach(mn -> roots.add(mn));\n-            } else {\n-                roots.add(mod);\n-            }\n-        }\n-\n-        ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, roots);\n-        if (finder.find(\"java.base\").isEmpty()) {\n+        ModuleFinder appModuleFinder = newModuleFinder(options.modulePath);\n+        ModuleFinder finder = appModuleFinder;\n+        boolean isLinkFromRuntime = false;\n+        if (!appModuleFinder.find(\"java.base\").isPresent()) {\n+            \/\/ If the application module finder doesn't contain the\n+            \/\/ java.base module we have one of two cases:\n+            \/\/ 1. A custom module is being linked into a runtime, but the JDK\n+            \/\/    modules have not been provided on the module path.\n+            \/\/ 2. We have a run-time image based link.\n+            \/\/\n+            \/\/ Distinguish case 2 by adding the default 'jmods' folder and try\n+            \/\/ the look-up again. For case 1 this will now find java.base, but\n+            \/\/ not for case 2, since the jmods folder is not there or doesn't\n+            \/\/ include the java.base module.\n@@ -401,0 +397,13 @@\n+                finder = newModuleFinder(options.modulePath);\n+            }\n+            \/\/ We've just added the default module path ('jmods'). If we still\n+            \/\/ don't find java.base, we must resolve JDK modules from the\n+            \/\/ current run-time image.\n+            if (!finder.find(\"java.base\").isPresent()) {\n+                \/\/ If we don't have a linkable run-time image this is an error\n+                if (!LinkableRuntimeImage.isLinkableRuntime()) {\n+                    throw taskHelper.newBadArgs(\"err.runtime.link.not.linkable.runtime\");\n+                }\n+                isLinkFromRuntime = true;\n+                \/\/ JDK modules come from the system module path\n+                finder = ModuleFinder.compose(ModuleFinder.ofSystem(), appModuleFinder);\n@@ -402,1 +411,0 @@\n-            finder = newModuleFinder(options.modulePath, options.limitMods, roots);\n@@ -405,11 +413,19 @@\n-        boolean isLinkFromRuntime = options.modulePath.isEmpty();\n-        \/\/ In case of custom modules outside the JDK we may\n-        \/\/ have a non-empty module path, which must not include\n-        \/\/ java.base. If it did, we link using packaged modules from that\n-        \/\/ module path. If the module path does not include java.base, we have\n-        \/\/ the case where we link from the run-time image. In that case, we take\n-        \/\/ the JDK modules from the run-time image (ModuleFinder.ofSystem()).\n-        if (finder.find(\"java.base\").isEmpty()) {\n-            isLinkFromRuntime = true;\n-            ModuleFinder runtimeImageFinder = ModuleFinder.ofSystem();\n-            finder = combinedFinders(runtimeImageFinder, finder, options.limitMods, roots);\n+        \/\/ Sanity check version if we use JMODs\n+        if (!isLinkFromRuntime) {\n+            checkVersion(finder);\n+        }\n+\n+        \/\/ Determine the roots set\n+        Set<String> roots = new HashSet<>();\n+        for (String mod : options.addMods) {\n+            if (mod.equals(ALL_MODULE_PATH)) {\n+                ModuleFinder mf = limitFinder(finder, options.limitMods,\n+                                              Set.of());\n+                mf.findAll()\n+                  .stream()\n+                  .map(ModuleReference::descriptor)\n+                  .map(ModuleDescriptor::name)\n+                  .forEach(mn -> roots.add(mn));\n+            } else {\n+                roots.add(mod);\n+            }\n@@ -417,0 +433,1 @@\n+        finder = limitFinder(finder, options.limitMods, roots);\n@@ -432,13 +449,2 @@\n-    \/**\n-     * Creates a combined module finder of {@code finder} and\n-     * {@code runtimeImageFinder} that first looks-up modules in the\n-     * {@code runtimeImageFinder} and if not present in {@code finder}.\n-     *\n-     * @param runtimeImageFinder A system modules finder.\n-     * @param finder A module finder based on packaged modules.\n-     * @param limitMods The set of limited modules for the resulting\n-     *                  finder (if any).\n-     * @param roots All module roots.\n-     *\n-     * @return A combined finder, or the input finder, potentially applying\n-     *         module limits.\n+    \/*\n+     * Creates a ModuleFinder for the given module paths.\n@@ -446,28 +452,4 @@\n-    private ModuleFinder combinedFinders(ModuleFinder runtimeImageFinder,\n-                                         ModuleFinder finder,\n-                                         Set<String> limitMods,\n-                                         Set<String> roots) {\n-        ModuleFinder combined = new ModuleFinder() {\n-\n-            @Override\n-            public Optional<ModuleReference> find(String name) {\n-                Optional<ModuleReference> mref = runtimeImageFinder.find(name);\n-                if (mref.isEmpty()) {\n-                    return finder.find(name);\n-                }\n-                return mref;\n-            }\n-\n-            @Override\n-            public Set<ModuleReference> findAll() {\n-                Set<ModuleReference> all = new HashSet<>();\n-                all.addAll(runtimeImageFinder.findAll());\n-                all.addAll(finder.findAll());\n-                return Collections.unmodifiableSet(all);\n-            }\n-        };\n-        \/\/ if limitmods is specified then limit the universe\n-        if (limitMods != null && !limitMods.isEmpty()) {\n-            return limitFinder(combined, limitMods, Objects.requireNonNull(roots));\n-        }\n-        return combined;\n+    public static ModuleFinder newModuleFinder(List<Path> paths) {\n+        Runtime.Version version = Runtime.version();\n+        Path[] entries = paths.toArray(new Path[0]);\n+        return ModulePath.of(version, true, entries);\n@@ -513,4 +495,51 @@\n-     * Returns a module finder of the given module path or the system modules\n-     * if the module path is empty that limits the observable modules to those\n-     * in the transitive closure of the modules specified in {@code limitMods}\n-     * plus other modules specified in the {@code roots} set.\n+     * Returns a module finder of the given module finder that limits the\n+     * observable modules to those in the transitive closure of the modules\n+     * specified in {@code limitMods} plus other modules specified in the\n+     * {@code roots} set.\n+     *\/\n+    public static ModuleFinder limitFinder(ModuleFinder finder,\n+                                           Set<String> limitMods,\n+                                           Set<String> roots) {\n+        \/\/ if limitMods is specified then limit the universe\n+        if (limitMods != null && !limitMods.isEmpty()) {\n+            Objects.requireNonNull(roots);\n+            \/\/ resolve all root modules\n+            Configuration cf = Configuration.empty()\n+                    .resolve(finder,\n+                             ModuleFinder.of(),\n+                             limitMods);\n+\n+            \/\/ module name -> reference\n+            Map<String, ModuleReference> map = new HashMap<>();\n+            cf.modules().forEach(m -> {\n+                ModuleReference mref = m.reference();\n+                map.put(mref.descriptor().name(), mref);\n+            });\n+\n+            \/\/ add the other modules\n+            roots.stream()\n+                .map(finder::find)\n+                .flatMap(Optional::stream)\n+                .forEach(mref -> map.putIfAbsent(mref.descriptor().name(), mref));\n+\n+            \/\/ set of modules that are observable\n+            Set<ModuleReference> mrefs = new HashSet<>(map.values());\n+\n+            return new ModuleFinder() {\n+                @Override\n+                public Optional<ModuleReference> find(String name) {\n+                    return Optional.ofNullable(map.get(name));\n+                }\n+\n+                @Override\n+                public Set<ModuleReference> findAll() {\n+                    return mrefs;\n+                }\n+            };\n+        }\n+        return finder;\n+    }\n+\n+    \/*\n+     * Checks the version of the module descriptor of java.base for compatibility\n+     * with the current runtime version.\n@@ -518,2 +547,3 @@\n-     * @throws IllegalArgumentException if java.base module is present\n-     * but its descriptor has no version\n+     * @throws IllegalArgumentException the descriptor of java.base has no\n+     * version or the java.base version is not the same as the current runtime's\n+     * version.\n@@ -521,12 +551,6 @@\n-    public static ModuleFinder newModuleFinder(List<Path> paths,\n-                                               Set<String> limitMods,\n-                                               Set<String> roots)\n-    {\n-        Runtime.Version version = Runtime.version();\n-        Path[] entries = paths.toArray(new Path[0]);\n-        ModuleFinder finder = paths.isEmpty() ? ModuleFinder.ofSystem()\n-                                              : ModulePath.of(version, true, entries);\n-        if (finder.find(\"java.base\").isPresent()) {\n-            \/\/ use the version of java.base module, if present, as\n-            \/\/ the release version for multi-release JAR files\n-            ModuleDescriptor.Version v = finder.find(\"java.base\").get()\n+    private static void checkVersion(ModuleFinder finder) {\n+        assert finder.find(\"java.base\").isPresent();\n+\n+        \/\/ use the version of java.base module, if present, as\n+        \/\/ the release version for multi-release JAR files\n+        ModuleDescriptor.Version v = finder.find(\"java.base\").get()\n@@ -534,11 +558,9 @@\n-                    new IllegalArgumentException(\"No version in java.base descriptor\")\n-                );\n-\n-            \/\/ java.base version is different than the current runtime version\n-            version = Runtime.Version.parse(v.toString());\n-            if (Runtime.version().feature() != version.feature() ||\n-                Runtime.version().interim() != version.interim())\n-            {\n-                \/\/ jlink version and java.base version do not match.\n-                \/\/ We do not (yet) support this mode.\n-                throw new IllegalArgumentException(taskHelper.getMessage(\"err.jlink.version.mismatch\",\n+                new IllegalArgumentException(\"No version in java.base descriptor\")\n+                        );\n+\n+        Runtime.Version version = Runtime.Version.parse(v.toString());\n+        if (Runtime.version().feature() != version.feature() ||\n+                Runtime.version().interim() != version.interim()) {\n+            \/\/ jlink version and java.base version do not match.\n+            \/\/ We do not (yet) support this mode.\n+            throw new IllegalArgumentException(taskHelper.getMessage(\"err.jlink.version.mismatch\",\n@@ -547,6 +569,0 @@\n-            }\n-        }\n-\n-        \/\/ if limitmods is specified then limit the universe\n-        if (limitMods != null && !limitMods.isEmpty()) {\n-            finder = limitFinder(finder, limitMods, Objects.requireNonNull(roots));\n@@ -554,1 +570,0 @@\n-        return finder;\n@@ -614,4 +629,0 @@\n-            if (!LinkableRuntimeImage.isLinkableRuntime()) {\n-                String msg = taskHelper.getMessage(\"err.runtime.link.not.linkable.runtime\");\n-                throw new IllegalArgumentException(msg);\n-            }\n@@ -776,43 +787,0 @@\n-    \/*\n-     * Returns a ModuleFinder that limits observability to the given root\n-     * modules, their transitive dependences, plus a set of other modules.\n-     *\/\n-    public static ModuleFinder limitFinder(ModuleFinder finder,\n-                                           Set<String> roots,\n-                                           Set<String> otherMods) {\n-\n-        \/\/ resolve all root modules\n-        Configuration cf = Configuration.empty()\n-                .resolve(finder,\n-                         ModuleFinder.of(),\n-                         roots);\n-\n-        \/\/ module name -> reference\n-        Map<String, ModuleReference> map = new HashMap<>();\n-        cf.modules().forEach(m -> {\n-            ModuleReference mref = m.reference();\n-            map.put(mref.descriptor().name(), mref);\n-        });\n-\n-        \/\/ add the other modules\n-        otherMods.stream()\n-            .map(finder::find)\n-            .flatMap(Optional::stream)\n-            .forEach(mref -> map.putIfAbsent(mref.descriptor().name(), mref));\n-\n-        \/\/ set of modules that are observable\n-        Set<ModuleReference> mrefs = new HashSet<>(map.values());\n-\n-        return new ModuleFinder() {\n-            @Override\n-            public Optional<ModuleReference> find(String name) {\n-                return Optional.ofNullable(map.get(name));\n-            }\n-\n-            @Override\n-            public Set<ModuleReference> findAll() {\n-                return mrefs;\n-            }\n-        };\n-    }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":122,"deletions":154,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+        boolean linkFromRuntime = false;\n@@ -159,1 +160,1 @@\n-                JlinkTask.newModuleFinder(modulePaths, limits, mods), false, false, false);\n+                JlinkTask.limitFinder(JlinkTask.newModuleFinder(modulePaths), limits, mods), linkFromRuntime, false, false);\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import static jdk.test.lib.process.ProcessTools.executeProcess;\n+import static org.testng.Assert.assertTrue;\n+\n@@ -36,3 +39,0 @@\n-import jdk.test.lib.compiler.CompilerUtils;\n-import static jdk.test.lib.process.ProcessTools.*;\n-\n@@ -41,1 +41,3 @@\n-import static org.testng.Assert.*;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n@@ -45,1 +47,1 @@\n- * @bug 8174826\n+ * @bug 8174826 8345573\n@@ -47,1 +49,1 @@\n- * @modules jdk.compiler jdk.jlink\n+ * @modules jdk.compiler jdk.jlink\/jdk.tools.jlink.internal\n@@ -50,1 +52,1 @@\n- * @run testng BindServices\n+ * @run testng\/othervm BindServices\n@@ -59,0 +61,2 @@\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final boolean JMODS_EXIST = Files.exists(Paths.get(JAVA_HOME, \"jmods\"));\n@@ -60,3 +64,3 @@\n-    private static final String MODULE_PATH =\n-        Paths.get(JAVA_HOME, \"jmods\").toString() +\n-            File.pathSeparator + MODS_DIR.toString();\n+    private static final String MODULE_PATH = (JMODS_EXIST ? Paths.get(JAVA_HOME, \"jmods\").toString() +\n+                                                             File.pathSeparator : \"\") +\n+                                                 MODS_DIR.toString();\n@@ -68,4 +72,4 @@\n-    private static boolean hasJmods() {\n-        if (!Files.exists(Paths.get(JAVA_HOME, \"jmods\"))) {\n-            System.err.println(\"Test skipped. NO jmods directory\");\n-            return false;\n+    private static boolean isExplodedJDKImage() {\n+        if (!JMODS_EXIST && !LINKABLE_RUNTIME) {\n+            System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+            return true;\n@@ -73,1 +77,1 @@\n-        return true;\n+        return false;\n@@ -81,1 +85,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -92,1 +96,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -106,1 +110,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -125,1 +129,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -156,1 +160,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n","filename":"test\/jdk\/tools\/jlink\/bindservices\/BindServices.java","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n@@ -35,1 +38,0 @@\n-import jdk.test.lib.compiler.CompilerUtils;\n@@ -39,1 +41,3 @@\n-import static org.testng.Assert.*;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n@@ -43,1 +47,1 @@\n- * @bug 8174826\n+ * @bug 8174826 8345573\n@@ -45,1 +49,1 @@\n- * @modules jdk.charsets jdk.compiler jdk.jlink\n+ * @modules jdk.charsets jdk.compiler jdk.jlink\/jdk.tools.jlink.internal\n@@ -57,3 +61,6 @@\n-    private static final String MODULE_PATH =\n-        Paths.get(JAVA_HOME, \"jmods\").toString() +\n-        File.pathSeparator + MODS_DIR.toString();\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final boolean JMODS_EXIST = Files.exists(Paths.get(JAVA_HOME, \"jmods\"));\n+\n+    private static final String MODULE_PATH = (JMODS_EXIST ? Paths.get(JAVA_HOME, \"jmods\").toString() +\n+                                                             File.pathSeparator : \"\") +\n+                                              MODS_DIR.toString();\n@@ -65,4 +72,4 @@\n-    private static boolean hasJmods() {\n-        if (!Files.exists(Paths.get(JAVA_HOME, \"jmods\"))) {\n-            System.err.println(\"Test skipped. NO jmods directory\");\n-            return false;\n+    private static boolean isExplodedJDKImage() {\n+        if (!JMODS_EXIST && !LINKABLE_RUNTIME) {\n+            System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+            return true;\n@@ -70,1 +77,1 @@\n-        return true;\n+        return false;\n@@ -78,1 +85,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -128,1 +135,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -148,1 +155,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -168,1 +175,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -187,1 +194,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -206,1 +213,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -224,1 +231,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -239,1 +246,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -253,1 +260,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -271,1 +278,1 @@\n-        if (!hasJmods()) return;\n+        if (isExplodedJDKImage()) return;\n","filename":"test\/jdk\/tools\/jlink\/bindservices\/SuggestProviders.java","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -195,1 +195,2 @@\n-            String msg = String.format(\"Expected jlink to %s given a jmodless image. Exit code was: %d\",\n+            String msg = String.format(\"Expected jlink to %s given a linkable run-time image. \" +\n+                                       \"Exit code was: %d\",\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AbstractLinkableRuntimeTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}