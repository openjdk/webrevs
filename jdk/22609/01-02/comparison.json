{"files":[{"patch":"@@ -380,10 +380,14 @@\n-        ModuleFinder initialFinder = createFinderFromPath(options.modulePath);\n-        boolean isLinkFromRuntime = determineLinkFromRuntime(initialFinder, options.modulePath);\n-        ModuleFinder rootsFinder = isLinkFromRuntime ? ModuleFinder.compose(ModuleFinder.ofSystem(),\n-                                                                            initialFinder) :\n-                                                       initialFinder;\n-        if (rootsFinder.find(\"java.base\").isEmpty()) {\n-            assert !isLinkFromRuntime : \"Expected regular JMODs based link\";\n-            \/\/ External module linked into a custom runtime, but JDK modules\n-            \/\/ not observable on the module path. Add the default module path\n-            \/\/ if that exists.\n+        ModuleFinder appModulePathFinder = createFinderFromPath(options.modulePath);\n+        ModuleFinder finder = appModulePathFinder;\n+        boolean isLinkFromRuntime = false;\n+        if (!appModulePathFinder.find(\"java.base\").isPresent()) {\n+            \/\/ If the application module path finder doesn't contain the\n+            \/\/ java.base module we have one of two cases:\n+            \/\/ 1. A custom module is being linked into a runtime, but the JDK\n+            \/\/    modules have not been provided on the module path.\n+            \/\/ 2. We have a run-time image based link.\n+            \/\/\n+            \/\/ Distinguish case 2 by adding the default 'jmods' folder and try\n+            \/\/ the look-up again. For case 1 this will now find java.base, but\n+            \/\/ not for case 2, since the jmods folder is not there or doesn't\n+            \/\/ include the java.base module.\n@@ -393,1 +397,9 @@\n-                rootsFinder = createFinderFromPath(options.modulePath);\n+                finder = createFinderFromPath(options.modulePath);\n+            }\n+            \/\/ We've just added the default module path ('jmods'). If we still\n+            \/\/ don't find java.base, we must resolve JDK modules from the\n+            \/\/ current run-time image.\n+            if (!finder.find(\"java.base\").isPresent()) {\n+                isLinkFromRuntime = true;\n+                \/\/ JDK modules come from the system module path\n+                finder = ModuleFinder.compose(ModuleFinder.ofSystem(), appModulePathFinder);\n@@ -397,0 +409,1 @@\n+        \/\/ Determine the roots set\n@@ -399,3 +412,3 @@\n-            if (mod.equals(ALL_MODULE_PATH) && options.modulePath.size() > 0) {\n-                ModuleFinder mf = newModuleFinder(rootsFinder, options.limitMods, Set.of(), isLinkFromRuntime);\n-                \/\/ all observable modules are roots\n+            if (mod.equals(ALL_MODULE_PATH)) {\n+                ModuleFinder mf = newModuleFinder(finder, options.limitMods,\n+                                                  Set.of(), isLinkFromRuntime);\n@@ -411,2 +424,1 @@\n-\n-        ModuleFinder finder = newModuleFinder(rootsFinder, options.limitMods, roots, isLinkFromRuntime);\n+        finder = newModuleFinder(finder, options.limitMods, roots, isLinkFromRuntime);\n@@ -428,33 +440,0 @@\n-    \/*\n-     * Determine whether or not JDK modules should be resolved from the run-time\n-     * image.\n-     *\n-     * @return {@code false} if JMODs including java.base are present on the\n-     *         module path or in the default module path ('jmods'). {@code true}\n-     *         otherwise.\n-     *\/\n-    private static boolean determineLinkFromRuntime(ModuleFinder initialFinder,\n-                                                    List<Path> modulePath) {\n-        boolean linkFromRuntime = false;\n-        if (!initialFinder.find(\"java.base\").isPresent()) {\n-            \/\/ If the initial finder doesn't contain the java.base module\n-            \/\/ we have one of two cases:\n-            \/\/ 1. A custom module is being linked into a runtime, but the JDK\n-            \/\/    modules have not been provided.\n-            \/\/ 2. We have a run-time image based link.\n-            \/\/\n-            \/\/ Distinguish case 2 by adding the default 'jmods' folder and try\n-            \/\/ the look-up again. For case 1 this will now find java.base, but\n-            \/\/ not for case 2, since the jmods folder is not there or doesn't\n-            \/\/ include the java.base module.\n-            List<Path> pathCopy = new ArrayList<>(modulePath);\n-            Path defaultPath = getDefaultModulePath();\n-            if (defaultPath != null) {\n-                pathCopy.add(defaultPath);\n-            }\n-            ModuleFinder finder = createFinderFromPath(pathCopy);\n-            linkFromRuntime = !finder.find(\"java.base\").isPresent();\n-        }\n-        return linkFromRuntime;\n-    }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":28,"deletions":49,"binary":false,"changes":77,"status":"modified"}]}