{"files":[{"patch":"@@ -52,1 +52,0 @@\n-import java.util.Collections;\n@@ -381,0 +380,17 @@\n+        ModuleFinder initialFinder = createFinderFromPath(options.modulePath);\n+        boolean isLinkFromRuntime = determineLinkFromRuntime(initialFinder, options.modulePath);\n+        ModuleFinder rootsFinder = isLinkFromRuntime ? ModuleFinder.compose(ModuleFinder.ofSystem(),\n+                                                                            initialFinder) :\n+                                                       initialFinder;\n+        if (rootsFinder.find(\"java.base\").isEmpty()) {\n+            assert !isLinkFromRuntime : \"Expected regular JMODs based link\";\n+            \/\/ External module linked into a custom runtime, but JDK modules\n+            \/\/ not observable on the module path. Add the default module path\n+            \/\/ if that exists.\n+            Path defModPath = getDefaultModulePath();\n+            if (defModPath != null) {\n+                options.modulePath.add(defModPath);\n+                rootsFinder = createFinderFromPath(options.modulePath);\n+            }\n+        }\n+\n@@ -384,1 +400,1 @@\n-                ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, Set.of());\n+                ModuleFinder mf = newModuleFinder(rootsFinder, options.limitMods, Set.of(), isLinkFromRuntime);\n@@ -386,5 +402,5 @@\n-                finder.findAll()\n-                      .stream()\n-                      .map(ModuleReference::descriptor)\n-                      .map(ModuleDescriptor::name)\n-                      .forEach(mn -> roots.add(mn));\n+                mf.findAll()\n+                  .stream()\n+                  .map(ModuleReference::descriptor)\n+                  .map(ModuleDescriptor::name)\n+                  .forEach(mn -> roots.add(mn));\n@@ -396,21 +412,1 @@\n-        ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, roots);\n-        if (finder.find(\"java.base\").isEmpty()) {\n-            Path defModPath = getDefaultModulePath();\n-            if (defModPath != null) {\n-                options.modulePath.add(defModPath);\n-            }\n-            finder = newModuleFinder(options.modulePath, options.limitMods, roots);\n-        }\n-\n-        boolean isLinkFromRuntime = options.modulePath.isEmpty();\n-        \/\/ In case of custom modules outside the JDK we may\n-        \/\/ have a non-empty module path, which must not include\n-        \/\/ java.base. If it did, we link using packaged modules from that\n-        \/\/ module path. If the module path does not include java.base, we have\n-        \/\/ the case where we link from the run-time image. In that case, we take\n-        \/\/ the JDK modules from the run-time image (ModuleFinder.ofSystem()).\n-        if (finder.find(\"java.base\").isEmpty()) {\n-            isLinkFromRuntime = true;\n-            ModuleFinder runtimeImageFinder = ModuleFinder.ofSystem();\n-            finder = combinedFinders(runtimeImageFinder, finder, options.limitMods, roots);\n-        }\n+        ModuleFinder finder = newModuleFinder(rootsFinder, options.limitMods, roots, isLinkFromRuntime);\n@@ -432,10 +428,3 @@\n-    \/**\n-     * Creates a combined module finder of {@code finder} and\n-     * {@code runtimeImageFinder} that first looks-up modules in the\n-     * {@code runtimeImageFinder} and if not present in {@code finder}.\n-     *\n-     * @param runtimeImageFinder A system modules finder.\n-     * @param finder A module finder based on packaged modules.\n-     * @param limitMods The set of limited modules for the resulting\n-     *                  finder (if any).\n-     * @param roots All module roots.\n+    \/*\n+     * Determine whether or not JDK modules should be resolved from the run-time\n+     * image.\n@@ -443,2 +432,3 @@\n-     * @return A combined finder, or the input finder, potentially applying\n-     *         module limits.\n+     * @return {@code false} if JMODs including java.base are present on the\n+     *         module path or in the default module path ('jmods'). {@code true}\n+     *         otherwise.\n@@ -446,13 +436,18 @@\n-    private ModuleFinder combinedFinders(ModuleFinder runtimeImageFinder,\n-                                         ModuleFinder finder,\n-                                         Set<String> limitMods,\n-                                         Set<String> roots) {\n-        ModuleFinder combined = new ModuleFinder() {\n-\n-            @Override\n-            public Optional<ModuleReference> find(String name) {\n-                Optional<ModuleReference> mref = runtimeImageFinder.find(name);\n-                if (mref.isEmpty()) {\n-                    return finder.find(name);\n-                }\n-                return mref;\n+    private static boolean determineLinkFromRuntime(ModuleFinder initialFinder,\n+                                                    List<Path> modulePath) {\n+        boolean linkFromRuntime = false;\n+        if (!initialFinder.find(\"java.base\").isPresent()) {\n+            \/\/ If the initial finder doesn't contain the java.base module\n+            \/\/ we have one of two cases:\n+            \/\/ 1. A custom module is being linked into a runtime, but the JDK\n+            \/\/    modules have not been provided.\n+            \/\/ 2. We have a run-time image based link.\n+            \/\/\n+            \/\/ Distinguish case 2 by adding the default 'jmods' folder and try\n+            \/\/ the look-up again. For case 1 this will now find java.base, but\n+            \/\/ not for case 2, since the jmods folder is not there or doesn't\n+            \/\/ include the java.base module.\n+            List<Path> pathCopy = new ArrayList<>(modulePath);\n+            Path defaultPath = getDefaultModulePath();\n+            if (defaultPath != null) {\n+                pathCopy.add(defaultPath);\n@@ -460,12 +455,2 @@\n-\n-            @Override\n-            public Set<ModuleReference> findAll() {\n-                Set<ModuleReference> all = new HashSet<>();\n-                all.addAll(runtimeImageFinder.findAll());\n-                all.addAll(finder.findAll());\n-                return Collections.unmodifiableSet(all);\n-            }\n-        };\n-        \/\/ if limitmods is specified then limit the universe\n-        if (limitMods != null && !limitMods.isEmpty()) {\n-            return limitFinder(combined, limitMods, Objects.requireNonNull(roots));\n+            ModuleFinder finder = createFinderFromPath(pathCopy);\n+            linkFromRuntime = !finder.find(\"java.base\").isPresent();\n@@ -473,1 +458,10 @@\n-        return combined;\n+        return linkFromRuntime;\n+    }\n+\n+    \/*\n+     * Creates a ModuleFinder for the given module paths.\n+     *\/\n+    public static ModuleFinder createFinderFromPath(List<Path> paths) {\n+        Runtime.Version version = Runtime.version();\n+        Path[] entries = paths.toArray(new Path[0]);\n+        return ModulePath.of(version, true, entries);\n@@ -513,4 +507,4 @@\n-     * Returns a module finder of the given module path or the system modules\n-     * if the module path is empty that limits the observable modules to those\n-     * in the transitive closure of the modules specified in {@code limitMods}\n-     * plus other modules specified in the {@code roots} set.\n+     * Returns a module finder of the given module finder that limits the\n+     * observable modules to those in the transitive closure of the modules\n+     * specified in {@code limitMods} plus other modules specified in the\n+     * {@code roots} set.\n@@ -519,1 +513,2 @@\n-     * but its descriptor has no version\n+     * but its descriptor has no version or the java.base version is not the\n+     * same as the current runtime.\n@@ -521,1 +516,1 @@\n-    public static ModuleFinder newModuleFinder(List<Path> paths,\n+    public static ModuleFinder newModuleFinder(ModuleFinder original,\n@@ -523,1 +518,2 @@\n-                                               Set<String> roots)\n+                                               Set<String> roots,\n+                                               boolean isRuntimeLink)\n@@ -526,4 +522,2 @@\n-        Path[] entries = paths.toArray(new Path[0]);\n-        ModuleFinder finder = paths.isEmpty() ? ModuleFinder.ofSystem()\n-                                              : ModulePath.of(version, true, entries);\n-        if (finder.find(\"java.base\").isPresent()) {\n+        ModuleFinder finder = original;\n+        if (!isRuntimeLink && finder.find(\"java.base\").isPresent()) {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":71,"deletions":77,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+        boolean linkFromRuntime = false;\n@@ -159,1 +160,1 @@\n-                JlinkTask.newModuleFinder(modulePaths, limits, mods), false, false, false);\n+                JlinkTask.newModuleFinder(JlinkTask.createFinderFromPath(modulePaths), limits, mods, linkFromRuntime), linkFromRuntime, false, false);\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import static jdk.test.lib.process.ProcessTools.executeProcess;\n+import static org.testng.Assert.assertTrue;\n+\n@@ -36,3 +39,0 @@\n-import jdk.test.lib.compiler.CompilerUtils;\n-import static jdk.test.lib.process.ProcessTools.*;\n-\n@@ -41,1 +41,3 @@\n-import static org.testng.Assert.*;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n@@ -45,1 +47,1 @@\n- * @bug 8174826\n+ * @bug 8174826 8345573\n@@ -47,1 +49,1 @@\n- * @modules jdk.compiler jdk.jlink\n+ * @modules jdk.compiler jdk.jlink\/jdk.tools.jlink.internal\n@@ -50,1 +52,1 @@\n- * @run testng BindServices\n+ * @run testng\/othervm BindServices\n@@ -59,0 +61,2 @@\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final boolean JMODS_EXIST = Files.exists(Paths.get(JAVA_HOME, \"jmods\"));\n@@ -60,3 +64,3 @@\n-    private static final String MODULE_PATH =\n-        Paths.get(JAVA_HOME, \"jmods\").toString() +\n-            File.pathSeparator + MODS_DIR.toString();\n+    private static final String MODULE_PATH = (JMODS_EXIST ? Paths.get(JAVA_HOME, \"jmods\").toString() +\n+                                                             File.pathSeparator : \"\") +\n+                                                 MODS_DIR.toString();\n@@ -68,4 +72,6 @@\n-    private static boolean hasJmods() {\n-        if (!Files.exists(Paths.get(JAVA_HOME, \"jmods\"))) {\n-            System.err.println(\"Test skipped. NO jmods directory\");\n-            return false;\n+    private static boolean isApplicable() {\n+        if (!JMODS_EXIST) {\n+            if (!LINKABLE_RUNTIME) {\n+                System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+                return false;\n+            }\n@@ -81,1 +87,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -92,1 +98,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -106,1 +112,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -125,1 +131,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -156,1 +162,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n","filename":"test\/jdk\/tools\/jlink\/bindservices\/BindServices.java","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n@@ -35,1 +38,0 @@\n-import jdk.test.lib.compiler.CompilerUtils;\n@@ -39,1 +41,3 @@\n-import static org.testng.Assert.*;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n@@ -43,1 +47,1 @@\n- * @bug 8174826\n+ * @bug 8174826 8345573\n@@ -45,1 +49,1 @@\n- * @modules jdk.charsets jdk.compiler jdk.jlink\n+ * @modules jdk.charsets jdk.compiler jdk.jlink\/jdk.tools.jlink.internal\n@@ -57,3 +61,6 @@\n-    private static final String MODULE_PATH =\n-        Paths.get(JAVA_HOME, \"jmods\").toString() +\n-        File.pathSeparator + MODS_DIR.toString();\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final boolean JMODS_EXIST = Files.exists(Paths.get(JAVA_HOME, \"jmods\"));\n+\n+    private static final String MODULE_PATH = (JMODS_EXIST ? Paths.get(JAVA_HOME, \"jmods\").toString() +\n+                                                             File.pathSeparator : \"\") +\n+                                              MODS_DIR.toString();\n@@ -65,4 +72,6 @@\n-    private static boolean hasJmods() {\n-        if (!Files.exists(Paths.get(JAVA_HOME, \"jmods\"))) {\n-            System.err.println(\"Test skipped. NO jmods directory\");\n-            return false;\n+    private static boolean isApplicable() {\n+        if (!JMODS_EXIST) {\n+            if (!LINKABLE_RUNTIME) {\n+                System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+                return false;\n+            }\n@@ -78,1 +87,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -128,1 +137,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -148,1 +157,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -168,1 +177,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -187,1 +196,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -206,1 +215,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -224,1 +233,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -239,1 +248,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -253,1 +262,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -271,1 +280,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n","filename":"test\/jdk\/tools\/jlink\/bindservices\/SuggestProviders.java","additions":31,"deletions":22,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -195,1 +195,2 @@\n-            String msg = String.format(\"Expected jlink to %s given a jmodless image. Exit code was: %d\",\n+            String msg = String.format(\"Expected jlink to %s given a run-time image \" +\n+                                       \"link capable image. Exit code was: %d\",\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AbstractLinkableRuntimeTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}