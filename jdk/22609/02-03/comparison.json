{"files":[{"patch":"@@ -380,2 +380,2 @@\n-        ModuleFinder appModulePathFinder = createFinderFromPath(options.modulePath);\n-        ModuleFinder finder = appModulePathFinder;\n+        ModuleFinder appModuleFinder = newModuleFinder(options.modulePath);\n+        ModuleFinder finder = appModuleFinder;\n@@ -383,2 +383,2 @@\n-        if (!appModulePathFinder.find(\"java.base\").isPresent()) {\n-            \/\/ If the application module path finder doesn't contain the\n+        if (!appModuleFinder.find(\"java.base\").isPresent()) {\n+            \/\/ If the application module finder doesn't contain the\n@@ -397,1 +397,1 @@\n-                finder = createFinderFromPath(options.modulePath);\n+                finder = newModuleFinder(options.modulePath);\n@@ -403,0 +403,4 @@\n+                \/\/ If we don't have a linkable run-time image this is an error\n+                if (!LinkableRuntimeImage.isLinkableRuntime()) {\n+                    throw taskHelper.newBadArgs(\"err.runtime.link.not.linkable.runtime\");\n+                }\n@@ -405,1 +409,1 @@\n-                finder = ModuleFinder.compose(ModuleFinder.ofSystem(), appModulePathFinder);\n+                finder = ModuleFinder.compose(ModuleFinder.ofSystem(), appModuleFinder);\n@@ -409,0 +413,5 @@\n+        \/\/ Sanity check version if we use JMODs\n+        if (!isLinkFromRuntime) {\n+            checkVersion(finder);\n+        }\n+\n@@ -413,2 +422,2 @@\n-                ModuleFinder mf = newModuleFinder(finder, options.limitMods,\n-                                                  Set.of(), isLinkFromRuntime);\n+                ModuleFinder mf = limitFinder(finder, options.limitMods,\n+                                              Set.of());\n@@ -424,1 +433,1 @@\n-        finder = newModuleFinder(finder, options.limitMods, roots, isLinkFromRuntime);\n+        finder = limitFinder(finder, options.limitMods, roots);\n@@ -443,1 +452,1 @@\n-    public static ModuleFinder createFinderFromPath(List<Path> paths) {\n+    public static ModuleFinder newModuleFinder(List<Path> paths) {\n@@ -490,0 +499,47 @@\n+     *\/\n+    public static ModuleFinder limitFinder(ModuleFinder finder,\n+                                           Set<String> limitMods,\n+                                           Set<String> roots) {\n+        \/\/ if limitMods is specified then limit the universe\n+        if (limitMods != null && !limitMods.isEmpty()) {\n+            Objects.requireNonNull(roots);\n+            \/\/ resolve all root modules\n+            Configuration cf = Configuration.empty()\n+                    .resolve(finder,\n+                             ModuleFinder.of(),\n+                             limitMods);\n+\n+            \/\/ module name -> reference\n+            Map<String, ModuleReference> map = new HashMap<>();\n+            cf.modules().forEach(m -> {\n+                ModuleReference mref = m.reference();\n+                map.put(mref.descriptor().name(), mref);\n+            });\n+\n+            \/\/ add the other modules\n+            roots.stream()\n+                .map(finder::find)\n+                .flatMap(Optional::stream)\n+                .forEach(mref -> map.putIfAbsent(mref.descriptor().name(), mref));\n+\n+            \/\/ set of modules that are observable\n+            Set<ModuleReference> mrefs = new HashSet<>(map.values());\n+\n+            return new ModuleFinder() {\n+                @Override\n+                public Optional<ModuleReference> find(String name) {\n+                    return Optional.ofNullable(map.get(name));\n+                }\n+\n+                @Override\n+                public Set<ModuleReference> findAll() {\n+                    return mrefs;\n+                }\n+            };\n+        }\n+        return finder;\n+    }\n+\n+    \/*\n+     * Checks the version of the module descriptor of java.base for compatibility\n+     * with the current runtime version.\n@@ -491,3 +547,3 @@\n-     * @throws IllegalArgumentException if java.base module is present\n-     * but its descriptor has no version or the java.base version is not the\n-     * same as the current runtime.\n+     * @throws IllegalArgumentException the descriptor of java.base has no\n+     * version or the java.base version is not the same as the current runtime's\n+     * version.\n@@ -495,11 +551,6 @@\n-    public static ModuleFinder newModuleFinder(ModuleFinder original,\n-                                               Set<String> limitMods,\n-                                               Set<String> roots,\n-                                               boolean isRuntimeLink)\n-    {\n-        Runtime.Version version = Runtime.version();\n-        ModuleFinder finder = original;\n-        if (!isRuntimeLink && finder.find(\"java.base\").isPresent()) {\n-            \/\/ use the version of java.base module, if present, as\n-            \/\/ the release version for multi-release JAR files\n-            ModuleDescriptor.Version v = finder.find(\"java.base\").get()\n+    private static void checkVersion(ModuleFinder finder) {\n+        assert finder.find(\"java.base\").isPresent();\n+\n+        \/\/ use the version of java.base module, if present, as\n+        \/\/ the release version for multi-release JAR files\n+        ModuleDescriptor.Version v = finder.find(\"java.base\").get()\n@@ -507,11 +558,9 @@\n-                    new IllegalArgumentException(\"No version in java.base descriptor\")\n-                );\n-\n-            \/\/ java.base version is different than the current runtime version\n-            version = Runtime.Version.parse(v.toString());\n-            if (Runtime.version().feature() != version.feature() ||\n-                Runtime.version().interim() != version.interim())\n-            {\n-                \/\/ jlink version and java.base version do not match.\n-                \/\/ We do not (yet) support this mode.\n-                throw new IllegalArgumentException(taskHelper.getMessage(\"err.jlink.version.mismatch\",\n+                new IllegalArgumentException(\"No version in java.base descriptor\")\n+                        );\n+\n+        Runtime.Version version = Runtime.Version.parse(v.toString());\n+        if (Runtime.version().feature() != version.feature() ||\n+                Runtime.version().interim() != version.interim()) {\n+            \/\/ jlink version and java.base version do not match.\n+            \/\/ We do not (yet) support this mode.\n+            throw new IllegalArgumentException(taskHelper.getMessage(\"err.jlink.version.mismatch\",\n@@ -520,6 +569,0 @@\n-            }\n-        }\n-\n-        \/\/ if limitmods is specified then limit the universe\n-        if (limitMods != null && !limitMods.isEmpty()) {\n-            finder = limitFinder(finder, limitMods, Objects.requireNonNull(roots));\n@@ -527,1 +570,0 @@\n-        return finder;\n@@ -587,4 +629,0 @@\n-            if (!LinkableRuntimeImage.isLinkableRuntime()) {\n-                String msg = taskHelper.getMessage(\"err.runtime.link.not.linkable.runtime\");\n-                throw new IllegalArgumentException(msg);\n-            }\n@@ -749,43 +787,0 @@\n-    \/*\n-     * Returns a ModuleFinder that limits observability to the given root\n-     * modules, their transitive dependences, plus a set of other modules.\n-     *\/\n-    public static ModuleFinder limitFinder(ModuleFinder finder,\n-                                           Set<String> roots,\n-                                           Set<String> otherMods) {\n-\n-        \/\/ resolve all root modules\n-        Configuration cf = Configuration.empty()\n-                .resolve(finder,\n-                         ModuleFinder.of(),\n-                         roots);\n-\n-        \/\/ module name -> reference\n-        Map<String, ModuleReference> map = new HashMap<>();\n-        cf.modules().forEach(m -> {\n-            ModuleReference mref = m.reference();\n-            map.put(mref.descriptor().name(), mref);\n-        });\n-\n-        \/\/ add the other modules\n-        otherMods.stream()\n-            .map(finder::find)\n-            .flatMap(Optional::stream)\n-            .forEach(mref -> map.putIfAbsent(mref.descriptor().name(), mref));\n-\n-        \/\/ set of modules that are observable\n-        Set<ModuleReference> mrefs = new HashSet<>(map.values());\n-\n-        return new ModuleFinder() {\n-            @Override\n-            public Optional<ModuleReference> find(String name) {\n-                return Optional.ofNullable(map.get(name));\n-            }\n-\n-            @Override\n-            public Set<ModuleReference> findAll() {\n-                return mrefs;\n-            }\n-        };\n-    }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":84,"deletions":89,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-                JlinkTask.newModuleFinder(JlinkTask.createFinderFromPath(modulePaths), limits, mods, linkFromRuntime), linkFromRuntime, false, false);\n+                JlinkTask.limitFinder(JlinkTask.newModuleFinder(modulePaths), limits, mods), linkFromRuntime, false, false);\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,6 +72,4 @@\n-    private static boolean isApplicable() {\n-        if (!JMODS_EXIST) {\n-            if (!LINKABLE_RUNTIME) {\n-                System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n-                return false;\n-            }\n+    private static boolean isExplodedJDKImage() {\n+        if (!JMODS_EXIST && !LINKABLE_RUNTIME) {\n+            System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+            return true;\n@@ -79,1 +77,1 @@\n-        return true;\n+        return false;\n@@ -87,1 +85,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -98,1 +96,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -112,1 +110,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -131,1 +129,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -162,1 +160,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n","filename":"test\/jdk\/tools\/jlink\/bindservices\/BindServices.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -72,6 +72,4 @@\n-    private static boolean isApplicable() {\n-        if (!JMODS_EXIST) {\n-            if (!LINKABLE_RUNTIME) {\n-                System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n-                return false;\n-            }\n+    private static boolean isExplodedJDKImage() {\n+        if (!JMODS_EXIST && !LINKABLE_RUNTIME) {\n+            System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+            return true;\n@@ -79,1 +77,1 @@\n-        return true;\n+        return false;\n@@ -87,1 +85,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -137,1 +135,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -157,1 +155,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -177,1 +175,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -196,1 +194,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -215,1 +213,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -233,1 +231,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -248,1 +246,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -262,1 +260,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n@@ -280,1 +278,1 @@\n-        if (!isApplicable()) return;\n+        if (isExplodedJDKImage()) return;\n","filename":"test\/jdk\/tools\/jlink\/bindservices\/SuggestProviders.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -195,2 +195,2 @@\n-            String msg = String.format(\"Expected jlink to %s given a run-time image \" +\n-                                       \"link capable image. Exit code was: %d\",\n+            String msg = String.format(\"Expected jlink to %s given a linkable run-time image. \" +\n+                                       \"Exit code was: %d\",\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AbstractLinkableRuntimeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}