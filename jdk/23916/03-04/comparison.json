{"files":[{"patch":"@@ -528,25 +528,0 @@\n-Pair<bool, bool> GraphKit::builtin_throw_applies(Deoptimization::DeoptReason reason) {\n-  \/\/ If this particular condition has not yet happened at this\n-  \/\/ bytecode, then use the uncommon trap mechanism, and allow for\n-  \/\/ a future recompilation if several traps occur here.\n-  \/\/ If the throw is hot, try to use a more complicated inline mechanism\n-  \/\/ which keeps execution inside the compiled code.\n-  bool treat_throw_as_hot = false;\n-\n-  if (ProfileTraps) {\n-    if (too_many_traps(reason)) {\n-      treat_throw_as_hot = true;\n-    }\n-    \/\/ (If there is no MDO at all, assume it is early in\n-    \/\/ execution, and that any deopts are part of the\n-    \/\/ startup transient, and don't need to be remembered.)\n-\n-    \/\/ Also, if there is a local exception handler, treat all throws\n-    \/\/ as hot if there has been at least one in this method.\n-    if (C->trap_count(reason) != 0 && method()->method_data()->trap_count(reason) != 0 && has_exception_handler()) {\n-      treat_throw_as_hot = true;\n-    }\n-  }\n-  return {treat_throw_as_hot && method()->can_omit_stack_trace(), treat_throw_as_hot};\n-}\n-\n@@ -554,4 +529,3 @@\n-void GraphKit::builtin_throw(Deoptimization::DeoptReason reason, ciInstance* ex_obj) {\n-  bool must_throw = true;\n-  Pair<bool, bool> applies_and_treat_throw_as_hot = builtin_throw_applies(reason);\n-  bool treat_throw_as_hot = applies_and_treat_throw_as_hot.second;\n+void GraphKit::builtin_throw(Deoptimization::DeoptReason reason) {\n+  builtin_throw(reason, builtin_throw_exception(reason), \/*allow_too_many_traps*\/ true);\n+}\n@@ -559,0 +533,3 @@\n+void GraphKit::builtin_throw(Deoptimization::DeoptReason reason,\n+                             ciInstance* ex_obj,\n+                             bool allow_too_many_traps) {\n@@ -565,8 +542,8 @@\n-  if (applies_and_treat_throw_as_hot.first) {\n-    \/\/ If the throw is local, we use a pre-existing instance and\n-    \/\/ punt on the backtrace.  This would lead to a missing backtrace\n-    \/\/ (a repeat of 4292742) if the backtrace object is ever asked\n-    \/\/ for its backtrace.\n-    \/\/ Fixing this remaining case of 4292742 requires some flavor of\n-    \/\/ escape analysis.  Leave that for the future.\n-    if (ex_obj != nullptr) {\n+  if (is_builtin_throw_hot(reason)) {\n+    if (method()->can_omit_stack_trace() && ex_obj != nullptr) {\n+      \/\/ If the throw is local, we use a pre-existing instance and\n+      \/\/ punt on the backtrace.  This would lead to a missing backtrace\n+      \/\/ (a repeat of 4292742) if the backtrace object is ever asked\n+      \/\/ for its backtrace.\n+      \/\/ Fixing this remaining case of 4292742 requires some flavor of\n+      \/\/ escape analysis.  Leave that for the future.\n@@ -575,1 +552,1 @@\n-        uncommon_trap_if_should_post_on_exceptions(reason, must_throw);\n+        uncommon_trap_if_should_post_on_exceptions(reason, true \/*must_throw*\/);\n@@ -606,0 +583,12 @@\n+    } else if (builtin_throw_too_many_traps(reason, ex_obj)) {\n+      \/\/ We cannot afford to take too many traps here. Suffer in the interpreter instead.\n+      assert(allow_too_many_traps, \"not allowed\");\n+      if (C->log() != nullptr) {\n+        C->log()->elem(\"hot_throw preallocated='0' reason='%s' mcount='%d'\",\n+                       Deoptimization::trap_reason_name(reason),\n+                       C->trap_count(reason));\n+      }\n+      uncommon_trap(reason, Deoptimization::Action_none,\n+                    (ciKlass*) nullptr, (char*) nullptr,\n+                    true \/*must_throw*\/);\n+      return;\n@@ -617,13 +606,0 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? C->method() : nullptr;\n-  Deoptimization::DeoptAction action = Deoptimization::Action_maybe_recompile;\n-  if (treat_throw_as_hot\n-      && (method()->method_data()->trap_recompiled_at(bci(), m)\n-          || C->too_many_traps(reason))) {\n-    \/\/ We cannot afford to take more traps here.  Suffer in the interpreter.\n-    if (C->log() != nullptr)\n-      C->log()->elem(\"hot_throw preallocated='0' reason='%s' mcount='%d'\",\n-                     Deoptimization::trap_reason_name(reason),\n-                     C->trap_count(reason));\n-    action = Deoptimization::Action_none;\n-  }\n-\n@@ -634,0 +610,29 @@\n+  uncommon_trap(reason, Deoptimization::Action_maybe_recompile,\n+                (ciKlass*) nullptr, (char*) nullptr,\n+                true \/*must_throw*\/);\n+}\n+\n+bool GraphKit::is_builtin_throw_hot(Deoptimization::DeoptReason reason) {\n+  \/\/ If this particular condition has not yet happened at this\n+  \/\/ bytecode, then use the uncommon trap mechanism, and allow for\n+  \/\/ a future recompilation if several traps occur here.\n+  \/\/ If the throw is hot, try to use a more complicated inline mechanism\n+  \/\/ which keeps execution inside the compiled code.\n+  if (ProfileTraps) {\n+    if (too_many_traps(reason)) {\n+      return true;\n+    }\n+    \/\/ (If there is no MDO at all, assume it is early in\n+    \/\/ execution, and that any deopts are part of the\n+    \/\/ startup transient, and don't need to be remembered.)\n+\n+    \/\/ Also, if there is a local exception handler, treat all throws\n+    \/\/ as hot if there has been at least one in this method.\n+    if (C->trap_count(reason) != 0 &&\n+        method()->method_data()->trap_count(reason) != 0 &&\n+        has_exception_handler()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n@@ -635,1 +640,13 @@\n-  uncommon_trap(reason, action, (ciKlass*)nullptr, (char*)nullptr, must_throw);\n+bool GraphKit::builtin_throw_too_many_traps(Deoptimization::DeoptReason reason,\n+                                            ciInstance* ex_obj) {\n+  if (is_builtin_throw_hot(reason)) {\n+    if (method()->can_omit_stack_trace() && ex_obj != nullptr) {\n+      return false; \/\/ no traps; throws preallocated exception instead\n+    }\n+    ciMethod* m = Deoptimization::reason_is_speculate(reason) ? C->method() : nullptr;\n+    if (method()->method_data()->trap_recompiled_at(bci(), m) ||\n+        C->too_many_traps(reason)) {\n+      return true;\n+    }\n+  }\n+  return false;\n@@ -638,2 +655,2 @@\n-ciInstance* GraphKit::guess_exception_from_deopt_reason(Deoptimization::DeoptReason reason) const {\n-  \/\/ Preconstructed exception objects, to use when we don't need the backtrace.\n+ciInstance* GraphKit::builtin_throw_exception(Deoptimization::DeoptReason reason) const {\n+  \/\/ Preallocated exception objects to use when we don't need the backtrace.\n@@ -656,4 +673,0 @@\n-void GraphKit::builtin_throw(Deoptimization::DeoptReason reason) {\n-  builtin_throw(reason, guess_exception_from_deopt_reason(reason));\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":71,"deletions":58,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -279,3 +279,10 @@\n-  void builtin_throw(Deoptimization::DeoptReason reason, ciInstance* exception_object);\n-  Pair<bool, bool> builtin_throw_applies(Deoptimization::DeoptReason reason);\n-  ciInstance* guess_exception_from_deopt_reason(Deoptimization::DeoptReason reason) const;\n+  void builtin_throw(Deoptimization::DeoptReason reason,\n+                     ciInstance* exception_object,\n+                     bool allow_too_many_traps);\n+  bool builtin_throw_too_many_traps(Deoptimization::DeoptReason reason,\n+                                    ciInstance* exception_object);\n+ private:\n+  bool is_builtin_throw_hot(Deoptimization::DeoptReason reason);\n+  ciInstance* builtin_throw_exception(Deoptimization::DeoptReason reason) const;\n+\n+ public:\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2006,1 +2006,8 @@\n-void LibraryCallKit::inline_math_mathExact(Node* math, Node* test, bool use_builtin_throw) {\n+bool LibraryCallKit::inline_math_mathExact(Node* math, Node* test) {\n+  if (builtin_throw_too_many_traps(Deoptimization::Reason_intrinsic,\n+                                   env()->ArithmeticException_instance())) {\n+    \/\/ It has been already too many times, but we cannot use builtin_throw care (e.g. we care about backtraces),\n+    \/\/ so let's bail out intrinsic rather than risking deopting again.\n+    return false;\n+  }\n+\n@@ -2020,6 +2027,3 @@\n-    if (use_builtin_throw) {\n-      builtin_throw(Deoptimization::Reason_intrinsic, env()->ArithmeticException_instance());\n-    } else {\n-      uncommon_trap(Deoptimization::Reason_intrinsic,\n-                    Deoptimization::Action_maybe_recompile);\n-    }\n+    builtin_throw(Deoptimization::Reason_intrinsic,\n+                  env()->ArithmeticException_instance(),\n+                  \/*allow_too_many_traps*\/ false);\n@@ -2030,0 +2034,1 @@\n+  return true;\n@@ -2035,10 +2040,0 @@\n-  bool use_builtin_throw = false;\n-  if (builtin_throw_applies(Deoptimization::Reason_intrinsic).first) {\n-    \/\/ If builtin_throw would work (notably, the throw is hot and we don't care about backtraces),\n-    \/\/ instead of bailing out on intrinsic or potentially deopting, let's do that!\n-    use_builtin_throw = true;\n-  } else if (too_many_traps(Deoptimization::Reason_intrinsic)) {\n-    \/\/ It has been already too many times, but we cannot use builtin_throw care (e.g. we care about backtraces),\n-    \/\/ so let's bail out intrinsic rather than risking deopting again.\n-    return false;\n-  }\n@@ -2049,2 +2044,1 @@\n-  inline_math_mathExact(operation, ofcheck, use_builtin_throw);\n-  return true;\n+  return inline_math_mathExact(operation, ofcheck);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-  void inline_math_mathExact(Node* math, Node* test, bool use_builtin_throw);\n+  bool inline_math_mathExact(Node* math, Node* test);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}