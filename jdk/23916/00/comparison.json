{"files":[{"patch":"@@ -1964,1 +1964,1 @@\n-                  Deoptimization::Action_none);\n+                  Deoptimization::Action_maybe_recompile);\n@@ -1974,0 +1974,3 @@\n+  if (too_many_traps(Deoptimization::Reason_intrinsic)) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,401 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.MILLISECONDS)\n+public abstract class MathExact {\n+    @Param({\"1000000\"})\n+    public int SIZE;\n+\n+\n+    \/\/ === multiplyExact(int, int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testMultiplyI(int i) {\n+        try {\n+            return Math.multiplyExact(i, i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testMultiplyI(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            \/\/ 46_340 < 2 ^ 15.5 (< 46_341, but that's not important)\n+            \/\/ so\n+            \/\/ 46_340 ^ 2 < 2 ^ 31\n+            testMultiplyI(i % 46_341);\n+        }\n+    }\n+\n+\n+    \/\/ === multiplyExact(long, long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testMultiplyL(long i) {\n+        try {\n+            return Math.multiplyExact(i, i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            \/\/ (2 ^ 63 - 1)^0.5 ~= 3_037_000_499.9761\n+            \/\/ Starting at 3_037_000_000 so that almost all computations overflow\n+            testMultiplyL(3_037_000_000L + i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testMultiplyL(i);\n+        }\n+    }\n+\n+\n+    \/\/ === negateExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testNegateI(int i) {\n+        try {\n+            return Math.negateExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(Integer.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(Integer.MAX_VALUE);\n+        }\n+    }\n+\n+\n+    \/\/ === negateExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testNegateL(long i) {\n+        try {\n+            return Math.negateExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(Long.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(Long.MAX_VALUE);\n+        }\n+    }\n+\n+\n+    \/\/ === incrementExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testIncrementI(int i) {\n+        try {\n+            return Math.incrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(Integer.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(Integer.MIN_VALUE + i);\n+        }\n+    }\n+\n+\n+    \/\/ === incrementExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testIncrementL(long i) {\n+        try {\n+            return Math.incrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(Long.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(Long.MIN_VALUE + i);\n+        }\n+    }\n+\n+\n+    \/\/ === decrementExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testDecrementI(int i) {\n+        try {\n+            return Math.decrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(Integer.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(Integer.MAX_VALUE - i);\n+        }\n+    }\n+\n+\n+    \/\/ === decrementExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testDecrementL(long i) {\n+        try {\n+            return Math.decrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(Long.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(Long.MAX_VALUE - i);\n+        }\n+    }\n+\n+\n+    \/\/ === addExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testAddI(int l, int r) {\n+        try {\n+            return Math.addExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testAddI(Integer.MAX_VALUE - 1_000, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testAddI(i * 5, i);\n+        }\n+    }\n+\n+\n+    \/\/ === addExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testAddL(long l, long r) {\n+        try {\n+            return Math.addExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testAddL(Long.MAX_VALUE - 1_000L, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testAddL(i * 5L, i);\n+        }\n+    }\n+\n+\n+    \/\/ === subtractExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testSubtractI(int l, int r) {\n+        try {\n+            return Math.subtractExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testSubtractI(Integer.MIN_VALUE + 1_000, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testSubtractI(i * 5, i);\n+        }\n+    }\n+\n+\n+    \/\/ === subtractExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testSubtractL(long l, long r) {\n+        try {\n+            return Math.subtractExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testSubtractL(Long.MIN_VALUE + 1_000L, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testSubtractL(i * 5L, i);\n+        }\n+    }\n+\n+\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:TieredStopAtLevel=1\"})\n+    public static class C1_1 extends MathExact {}\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:TieredStopAtLevel=2\"})\n+    public static class C1_2 extends MathExact {}\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:TieredStopAtLevel=3\"})\n+    public static class C1_3 extends MathExact {}\n+\n+    @Fork(value = 1)\n+    public static class C2 extends MathExact {}\n+\n+    @Fork(value = 1,\n+            jvmArgs = {\n+                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                    \"-XX:DisableIntrinsic=_addExactI,_incrementExactI,_addExactL,_incrementExactL,_subtractExactI,_decrementExactI,_subtractExactL,_decrementExactL,_negateExactI,_negateExactL,_multiplyExactI,_multiplyExactL\",\n+            })\n+    public static class C2_no_intrinsics extends MathExact {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MathExact.java","additions":401,"deletions":0,"binary":false,"changes":401,"status":"added"}]}