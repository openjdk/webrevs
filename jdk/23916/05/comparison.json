{"files":[{"patch":"@@ -530,26 +530,2 @@\n-  bool must_throw = true;\n-\n-  \/\/ If this particular condition has not yet happened at this\n-  \/\/ bytecode, then use the uncommon trap mechanism, and allow for\n-  \/\/ a future recompilation if several traps occur here.\n-  \/\/ If the throw is hot, try to use a more complicated inline mechanism\n-  \/\/ which keeps execution inside the compiled code.\n-  bool treat_throw_as_hot = false;\n-  ciMethodData* md = method()->method_data();\n-\n-  if (ProfileTraps) {\n-    if (too_many_traps(reason)) {\n-      treat_throw_as_hot = true;\n-    }\n-    \/\/ (If there is no MDO at all, assume it is early in\n-    \/\/ execution, and that any deopts are part of the\n-    \/\/ startup transient, and don't need to be remembered.)\n-\n-    \/\/ Also, if there is a local exception handler, treat all throws\n-    \/\/ as hot if there has been at least one in this method.\n-    if (C->trap_count(reason) != 0\n-        && method()->method_data()->trap_count(reason) != 0\n-        && has_exception_handler()) {\n-        treat_throw_as_hot = true;\n-    }\n-  }\n+  builtin_throw(reason, builtin_throw_exception(reason), \/*allow_too_many_traps*\/ true);\n+}\n@@ -557,0 +533,3 @@\n+void GraphKit::builtin_throw(Deoptimization::DeoptReason reason,\n+                             ciInstance* ex_obj,\n+                             bool allow_too_many_traps) {\n@@ -563,29 +542,8 @@\n-  if (treat_throw_as_hot && method()->can_omit_stack_trace()) {\n-    \/\/ If the throw is local, we use a pre-existing instance and\n-    \/\/ punt on the backtrace.  This would lead to a missing backtrace\n-    \/\/ (a repeat of 4292742) if the backtrace object is ever asked\n-    \/\/ for its backtrace.\n-    \/\/ Fixing this remaining case of 4292742 requires some flavor of\n-    \/\/ escape analysis.  Leave that for the future.\n-    ciInstance* ex_obj = nullptr;\n-    switch (reason) {\n-    case Deoptimization::Reason_null_check:\n-      ex_obj = env()->NullPointerException_instance();\n-      break;\n-    case Deoptimization::Reason_div0_check:\n-      ex_obj = env()->ArithmeticException_instance();\n-      break;\n-    case Deoptimization::Reason_range_check:\n-      ex_obj = env()->ArrayIndexOutOfBoundsException_instance();\n-      break;\n-    case Deoptimization::Reason_class_check:\n-      ex_obj = env()->ClassCastException_instance();\n-      break;\n-    case Deoptimization::Reason_array_check:\n-      ex_obj = env()->ArrayStoreException_instance();\n-      break;\n-    default:\n-      break;\n-    }\n-    \/\/ If we have a preconstructed exception object, use it.\n-    if (ex_obj != nullptr) {\n+  if (is_builtin_throw_hot(reason)) {\n+    if (method()->can_omit_stack_trace() && ex_obj != nullptr) {\n+      \/\/ If the throw is local, we use a pre-existing instance and\n+      \/\/ punt on the backtrace.  This would lead to a missing backtrace\n+      \/\/ (a repeat of 4292742) if the backtrace object is ever asked\n+      \/\/ for its backtrace.\n+      \/\/ Fixing this remaining case of 4292742 requires some flavor of\n+      \/\/ escape analysis.  Leave that for the future.\n@@ -594,1 +552,1 @@\n-        uncommon_trap_if_should_post_on_exceptions(reason, must_throw);\n+        uncommon_trap_if_should_post_on_exceptions(reason, true \/*must_throw*\/);\n@@ -625,0 +583,12 @@\n+    } else if (builtin_throw_too_many_traps(reason, ex_obj)) {\n+      \/\/ We cannot afford to take too many traps here. Suffer in the interpreter instead.\n+      assert(allow_too_many_traps, \"not allowed\");\n+      if (C->log() != nullptr) {\n+        C->log()->elem(\"hot_throw preallocated='0' reason='%s' mcount='%d'\",\n+                       Deoptimization::trap_reason_name(reason),\n+                       C->trap_count(reason));\n+      }\n+      uncommon_trap(reason, Deoptimization::Action_none,\n+                    (ciKlass*) nullptr, (char*) nullptr,\n+                    true \/*must_throw*\/);\n+      return;\n@@ -636,13 +606,0 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? C->method() : nullptr;\n-  Deoptimization::DeoptAction action = Deoptimization::Action_maybe_recompile;\n-  if (treat_throw_as_hot\n-      && (method()->method_data()->trap_recompiled_at(bci(), m)\n-          || C->too_many_traps(reason))) {\n-    \/\/ We cannot afford to take more traps here.  Suffer in the interpreter.\n-    if (C->log() != nullptr)\n-      C->log()->elem(\"hot_throw preallocated='0' reason='%s' mcount='%d'\",\n-                     Deoptimization::trap_reason_name(reason),\n-                     C->trap_count(reason));\n-    action = Deoptimization::Action_none;\n-  }\n-\n@@ -653,0 +610,18 @@\n+  uncommon_trap(reason, Deoptimization::Action_maybe_recompile,\n+                (ciKlass*) nullptr, (char*) nullptr,\n+                true \/*must_throw*\/);\n+}\n+\n+bool GraphKit::is_builtin_throw_hot(Deoptimization::DeoptReason reason) {\n+  \/\/ If this particular condition has not yet happened at this\n+  \/\/ bytecode, then use the uncommon trap mechanism, and allow for\n+  \/\/ a future recompilation if several traps occur here.\n+  \/\/ If the throw is hot, try to use a more complicated inline mechanism\n+  \/\/ which keeps execution inside the compiled code.\n+  if (ProfileTraps) {\n+    if (too_many_traps(reason)) {\n+      return true;\n+    }\n+    \/\/ (If there is no MDO at all, assume it is early in\n+    \/\/ execution, and that any deopts are part of the\n+    \/\/ startup transient, and don't need to be remembered.)\n@@ -654,1 +629,9 @@\n-  uncommon_trap(reason, action, (ciKlass*)nullptr, (char*)nullptr, must_throw);\n+    \/\/ Also, if there is a local exception handler, treat all throws\n+    \/\/ as hot if there has been at least one in this method.\n+    if (C->trap_count(reason) != 0 &&\n+        method()->method_data()->trap_count(reason) != 0 &&\n+        has_exception_handler()) {\n+      return true;\n+    }\n+  }\n+  return false;\n@@ -657,0 +640,32 @@\n+bool GraphKit::builtin_throw_too_many_traps(Deoptimization::DeoptReason reason,\n+                                            ciInstance* ex_obj) {\n+  if (is_builtin_throw_hot(reason)) {\n+    if (method()->can_omit_stack_trace() && ex_obj != nullptr) {\n+      return false; \/\/ no traps; throws preallocated exception instead\n+    }\n+    ciMethod* m = Deoptimization::reason_is_speculate(reason) ? C->method() : nullptr;\n+    if (method()->method_data()->trap_recompiled_at(bci(), m) ||\n+        C->too_many_traps(reason)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+ciInstance* GraphKit::builtin_throw_exception(Deoptimization::DeoptReason reason) const {\n+  \/\/ Preallocated exception objects to use when we don't need the backtrace.\n+  switch (reason) {\n+  case Deoptimization::Reason_null_check:\n+    return env()->NullPointerException_instance();\n+  case Deoptimization::Reason_div0_check:\n+    return env()->ArithmeticException_instance();\n+  case Deoptimization::Reason_range_check:\n+    return env()->ArrayIndexOutOfBoundsException_instance();\n+  case Deoptimization::Reason_class_check:\n+    return env()->ClassCastException_instance();\n+  case Deoptimization::Reason_array_check:\n+    return env()->ArrayStoreException_instance();\n+  default:\n+    return nullptr;\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":85,"deletions":70,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -279,0 +279,10 @@\n+  void builtin_throw(Deoptimization::DeoptReason reason,\n+                     ciInstance* exception_object,\n+                     bool allow_too_many_traps);\n+  bool builtin_throw_too_many_traps(Deoptimization::DeoptReason reason,\n+                                    ciInstance* exception_object);\n+ private:\n+  bool is_builtin_throw_hot(Deoptimization::DeoptReason reason);\n+  ciInstance* builtin_throw_exception(Deoptimization::DeoptReason reason) const;\n+\n+ public:\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2006,1 +2006,8 @@\n-void LibraryCallKit::inline_math_mathExact(Node* math, Node *test) {\n+bool LibraryCallKit::inline_math_mathExact(Node* math, Node* test) {\n+  if (builtin_throw_too_many_traps(Deoptimization::Reason_intrinsic,\n+                                   env()->ArithmeticException_instance())) {\n+    \/\/ It has been already too many times, but we cannot use builtin_throw (e.g. we care about backtraces),\n+    \/\/ so let's bail out intrinsic rather than risking deopting again.\n+    return false;\n+  }\n+\n@@ -2020,2 +2027,3 @@\n-    uncommon_trap(Deoptimization::Reason_intrinsic,\n-                  Deoptimization::Action_none);\n+    builtin_throw(Deoptimization::Reason_intrinsic,\n+                  env()->ArithmeticException_instance(),\n+                  \/*allow_too_many_traps*\/ false);\n@@ -2026,0 +2034,1 @@\n+  return true;\n@@ -2035,2 +2044,1 @@\n-  inline_math_mathExact(operation, ofcheck);\n-  return true;\n+  return inline_math_mathExact(operation, ofcheck);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-  void inline_math_mathExact(Node* math, Node* test);\n+  bool inline_math_mathExact(Node* math, Node* test);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          The base case\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          With ProfileTraps enabled to allow builtin_throw to work\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:+ProfileTraps -XX:+StackTraceInThrowable -XX:+OmitStackTraceInFastThrow\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          ProfileTraps off => throw will never be hot for builtin_throw\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:-ProfileTraps\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          OmitStackTraceInFastThrow off => can_omit_stack_trace is false => no builtin_throw\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:+ProfileTraps -XX:+StackTraceInThrowable -XX:-OmitStackTraceInFastThrow\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          StackTraceInThrowable off => can_omit_stack_trace is true => yes builtin_throw\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:+ProfileTraps -XX:-StackTraceInThrowable -XX:+OmitStackTraceInFastThrow\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          StackTraceInThrowable off && OmitStackTraceInFastThrow off => can_omit_stack_trace is true => yes builtin_throw\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:+ProfileTraps -XX:-StackTraceInThrowable -XX:-OmitStackTraceInFastThrow\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          Without intrinsics\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:DisableIntrinsic=_addExactI,_incrementExactI,_addExactL,_incrementExactL,_subtractExactI,_decrementExactI,_subtractExactL,_decrementExactL,_negateExactI,_negateExactL,_multiplyExactI,_multiplyExactL\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+package compiler.intrinsics.mathexact;\n+\n+import java.lang.reflect.Method;\n+\n+import compiler.lib.generators.RestrictableGenerator;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import static compiler.lib.generators.Generators.G;\n+\n+public class OverflowTest {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final RestrictableGenerator<Integer> int_gen = G.ints();\n+    private static final int LIMIT = 10_000;\n+\n+    public static void main(String... args) throws NoSuchMethodException {\n+        OverflowTest t = new OverflowTest();\n+        t.run();\n+    }\n+\n+    void run() throws NoSuchMethodException {\n+        check_compilation();\n+        check_multiplyI();\n+    }\n+\n+    void check_compilation() throws NoSuchMethodException {\n+        \/\/ Force Math loading\n+        Math.min(2, 3);\n+        comp_multiplyI(0, 0);\n+        comp_multiplyI_no_catch(0, 0);\n+        int_multiplyI(0, 0);\n+\n+        Method comp_multiplyI_meth = OverflowTest.class.getDeclaredMethod(\"comp_multiplyI\", int.class, int.class);\n+        Asserts.assertTrue(WHITE_BOX.isMethodCompiled(comp_multiplyI_meth), \"comp_multiplyI(int, int) is not compiled\");\n+\n+        Method comp_multiplyI_no_catch_meth = OverflowTest.class.getDeclaredMethod(\"comp_multiplyI_no_catch\", int.class, int.class);\n+        Asserts.assertTrue(WHITE_BOX.isMethodCompiled(comp_multiplyI_no_catch_meth), \"comp_multiplyI_no_catch(int, int) is not compiled\");\n+\n+        Method int_multiplyI_meth = OverflowTest.class.getDeclaredMethod(\"int_multiplyI\", int.class, int.class);\n+        Asserts.assertFalse(WHITE_BOX.isMethodCompiled(int_multiplyI_meth), \"int_multiplyI(int, int) is compiled\");\n+    }\n+\n+    void assert_consistent(Integer comp_res, Integer int_res) {\n+        if (int_res == null) {\n+            Asserts.assertNull(comp_res);\n+        } else {\n+            Asserts.assertNotNull(comp_res);\n+            Asserts.assertEquals(comp_res, int_res);\n+        }\n+    }\n+\n+    Integer comp_multiplyI(int a, int b) {\n+        try {\n+            return Math.multiplyExact(a, b);\n+        } catch (ArithmeticException e) {\n+            return null;\n+        }\n+    }\n+\n+    int comp_multiplyI_no_catch(int a, int b) {\n+        return Math.multiplyExact(a, b);\n+    }\n+\n+    Integer int_multiplyI(int a, int b) {\n+        try {\n+            return Math.multiplyExact(a, b);\n+        } catch (ArithmeticException e) {\n+            return null;\n+        }\n+    }\n+\n+    void check_multiplyI() {\n+        \/\/ 46_340 < 2 ^ 15.5 < 46_341 =>\n+        \/\/ 46_340^2 < 2 ^ 31 < 46_341^2\n+        int limit_square_do_not_overflow = 46_340;\n+\n+        \/\/ In bound cases\n+        for (int i = 0; i < LIMIT; i++) {\n+            int a = limit_square_do_not_overflow - i;\n+            Integer comp_res = comp_multiplyI(a, a);\n+            Integer int_res = int_multiplyI(a, a);\n+            Asserts.assertNotNull(int_res);\n+            assert_consistent(comp_res, int_res);\n+        }\n+        for (int i = 0; i < LIMIT; i++) {\n+            int a = limit_square_do_not_overflow - i;\n+            Integer comp_res;\n+            try {\n+                comp_res = comp_multiplyI_no_catch(a, a);\n+            } catch (ArithmeticException _) {\n+                comp_res = null;\n+            }\n+            Integer int_res = int_multiplyI(a, a);\n+            Asserts.assertNotNull(int_res);\n+            assert_consistent(comp_res, int_res);\n+        }\n+\n+        \/\/ Out of bound cases\n+        for (int i = 0; i < LIMIT; i++) {\n+            int a = limit_square_do_not_overflow + 1 + i;\n+            Integer comp_res = comp_multiplyI(a, a);\n+            Integer int_res = int_multiplyI(a, a);\n+            Asserts.assertNull(int_res);\n+            assert_consistent(comp_res, int_res);\n+        }\n+        for (int i = 0; i < LIMIT; i++) {\n+            int a = limit_square_do_not_overflow + 1 + i;\n+            Integer comp_res;\n+            try {\n+                comp_res = comp_multiplyI_no_catch(a, a);\n+            } catch (ArithmeticException _) {\n+                comp_res = null;\n+            }\n+            Integer int_res = int_multiplyI(a, a);\n+            Asserts.assertNull(int_res);\n+            assert_consistent(comp_res, int_res);\n+        }\n+\n+        \/\/ Random slice\n+        int lhs = int_gen.next();\n+        int rhs_start = int_gen.next() & 0xff_ff_00_00;\n+        for (int i = 0; i < 0x1_00_00; i++) {\n+            int rhs = rhs_start | i;\n+            Integer comp_res = comp_multiplyI(lhs, rhs);\n+            Integer int_res = int_multiplyI(lhs, rhs);\n+            assert_consistent(comp_res, int_res);\n+        }\n+        for (int i = 0; i < 0x1_00_00; i++) {\n+            int rhs = rhs_start | i;\n+            Integer comp_res;\n+            try {\n+                comp_res = comp_multiplyI_no_catch(lhs, rhs);\n+            } catch (ArithmeticException _) {\n+                comp_res = null;\n+            }\n+            Integer int_res = int_multiplyI(lhs, rhs);\n+            assert_consistent(comp_res, int_res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/mathexact\/OverflowTest.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,403 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.MILLISECONDS)\n+public abstract class MathExact {\n+    @Param({\"1000000\"})\n+    public int SIZE;\n+\n+\n+    \/\/ === multiplyExact(int, int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testMultiplyI(int i) {\n+        try {\n+            return Math.multiplyExact(i, i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testMultiplyI(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            \/\/ 46_340 < 2 ^ 15.5 (< 46_341, but that's not important)\n+            \/\/ so\n+            \/\/ 46_340 ^ 2 < 2 ^ 31\n+            testMultiplyI(i % 46_341);\n+        }\n+    }\n+\n+\n+    \/\/ === multiplyExact(long, long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testMultiplyL(long i) {\n+        try {\n+            return Math.multiplyExact(i, i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            \/\/ (2 ^ 63 - 1)^0.5 ~= 3_037_000_499.9761\n+            \/\/ Starting at 3_037_000_000 so that almost all computations overflow\n+            testMultiplyL(3_037_000_000L + i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testMultiplyL(i);\n+        }\n+    }\n+\n+\n+    \/\/ === negateExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testNegateI(int i) {\n+        try {\n+            return Math.negateExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(Integer.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(Integer.MAX_VALUE);\n+        }\n+    }\n+\n+\n+    \/\/ === negateExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testNegateL(long i) {\n+        try {\n+            return Math.negateExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(Long.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(Long.MAX_VALUE);\n+        }\n+    }\n+\n+\n+    \/\/ === incrementExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testIncrementI(int i) {\n+        try {\n+            return Math.incrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(Integer.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(Integer.MIN_VALUE + i);\n+        }\n+    }\n+\n+\n+    \/\/ === incrementExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testIncrementL(long i) {\n+        try {\n+            return Math.incrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(Long.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(Long.MIN_VALUE + i);\n+        }\n+    }\n+\n+\n+    \/\/ === decrementExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testDecrementI(int i) {\n+        try {\n+            return Math.decrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(Integer.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(Integer.MAX_VALUE - i);\n+        }\n+    }\n+\n+\n+    \/\/ === decrementExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testDecrementL(long i) {\n+        try {\n+            return Math.decrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(Long.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(Long.MAX_VALUE - i);\n+        }\n+    }\n+\n+\n+    \/\/ === addExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testAddI(int l, int r) {\n+        try {\n+            return Math.addExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testAddI(Integer.MAX_VALUE - 1_000, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testAddI(i * 5, i);\n+        }\n+    }\n+\n+\n+    \/\/ === addExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testAddL(long l, long r) {\n+        try {\n+            return Math.addExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testAddL(Long.MAX_VALUE - 1_000L, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testAddL(i * 5L, i);\n+        }\n+    }\n+\n+\n+    \/\/ === subtractExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testSubtractI(int l, int r) {\n+        try {\n+            return Math.subtractExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testSubtractI(Integer.MIN_VALUE + 1_000, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testSubtractI(i * 5, i);\n+        }\n+    }\n+\n+\n+    \/\/ === subtractExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testSubtractL(long l, long r) {\n+        try {\n+            return Math.subtractExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testSubtractL(Long.MIN_VALUE + 1_000L, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testSubtractL(i * 5L, i);\n+        }\n+    }\n+\n+\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:TieredStopAtLevel=1\"})\n+    public static class C1_1 extends MathExact {}\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:TieredStopAtLevel=2\"})\n+    public static class C1_2 extends MathExact {}\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:TieredStopAtLevel=3\"})\n+    public static class C1_3 extends MathExact {}\n+\n+    @Fork(value = 1)\n+    public static class C2 extends MathExact {}\n+\n+    @Fork(value = 1,\n+            jvmArgs = {\n+                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                    \"-XX:DisableIntrinsic=_addExactI,_incrementExactI,_addExactL,_incrementExactL,_subtractExactI,_decrementExactI,_subtractExactL,_decrementExactL,_negateExactI,_negateExactL,_multiplyExactI,_multiplyExactL\",\n+            })\n+    public static class C2_no_intrinsics extends MathExact {}\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:-OmitStackTraceInFastThrow\"})\n+    public static class C2_no_builtin_throw extends MathExact {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MathExact.java","additions":403,"deletions":0,"binary":false,"changes":403,"status":"added"}]}