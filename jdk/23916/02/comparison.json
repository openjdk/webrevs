{"files":[{"patch":"@@ -528,4 +528,1 @@\n-\/\/------------------------------builtin_throw----------------------------------\n-void GraphKit::builtin_throw(Deoptimization::DeoptReason reason) {\n-  bool must_throw = true;\n-\n+Pair<bool, bool> GraphKit::builtin_throw_applies(Deoptimization::DeoptReason reason) {\n@@ -538,1 +535,0 @@\n-  ciMethodData* md = method()->method_data();\n@@ -550,4 +546,2 @@\n-    if (C->trap_count(reason) != 0\n-        && method()->method_data()->trap_count(reason) != 0\n-        && has_exception_handler()) {\n-        treat_throw_as_hot = true;\n+    if (C->trap_count(reason) != 0 && method()->method_data()->trap_count(reason) != 0 && has_exception_handler()) {\n+      treat_throw_as_hot = true;\n@@ -556,0 +550,8 @@\n+  return {treat_throw_as_hot && method()->can_omit_stack_trace(), treat_throw_as_hot};\n+}\n+\n+\/\/------------------------------builtin_throw----------------------------------\n+void GraphKit::builtin_throw(Deoptimization::DeoptReason reason, ciInstance* ex_obj) {\n+  bool must_throw = true;\n+  Pair<bool, bool> applies_and_treat_throw_as_hot = builtin_throw_applies(reason);\n+  bool treat_throw_as_hot = applies_and_treat_throw_as_hot.second;\n@@ -563,1 +565,1 @@\n-  if (treat_throw_as_hot && method()->can_omit_stack_trace()) {\n+  if (applies_and_treat_throw_as_hot.first) {\n@@ -570,20 +572,0 @@\n-    ciInstance* ex_obj = nullptr;\n-    switch (reason) {\n-    case Deoptimization::Reason_null_check:\n-      ex_obj = env()->NullPointerException_instance();\n-      break;\n-    case Deoptimization::Reason_div0_check:\n-      ex_obj = env()->ArithmeticException_instance();\n-      break;\n-    case Deoptimization::Reason_range_check:\n-      ex_obj = env()->ArrayIndexOutOfBoundsException_instance();\n-      break;\n-    case Deoptimization::Reason_class_check:\n-      ex_obj = env()->ClassCastException_instance();\n-      break;\n-    case Deoptimization::Reason_array_check:\n-      ex_obj = env()->ArrayStoreException_instance();\n-      break;\n-    default:\n-      break;\n-    }\n@@ -657,0 +639,20 @@\n+ciInstance* GraphKit::guess_exception_from_deopt_reason(Deoptimization::DeoptReason reason) const {\n+  switch (reason) {\n+  case Deoptimization::Reason_null_check:\n+    return env()->NullPointerException_instance();\n+  case Deoptimization::Reason_div0_check:\n+    return env()->ArithmeticException_instance();\n+  case Deoptimization::Reason_range_check:\n+    return env()->ArrayIndexOutOfBoundsException_instance();\n+  case Deoptimization::Reason_class_check:\n+    return env()->ClassCastException_instance();\n+  case Deoptimization::Reason_array_check:\n+    return env()->ArrayStoreException_instance();\n+  default:\n+    return nullptr;\n+  }\n+}\n+\n+void GraphKit::builtin_throw(Deoptimization::DeoptReason reason) {\n+  builtin_throw(reason, guess_exception_from_deopt_reason(reason));\n+}\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":32,"deletions":30,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -279,0 +279,3 @@\n+  void builtin_throw(Deoptimization::DeoptReason reason, ciInstance* exception_object);\n+  Pair<bool, bool> builtin_throw_applies(Deoptimization::DeoptReason reason);\n+  ciInstance* guess_exception_from_deopt_reason(Deoptimization::DeoptReason reason) const;\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2020,1 +2020,1 @@\n-void LibraryCallKit::inline_math_mathExact(Node* math, Node *test) {\n+void LibraryCallKit::inline_math_mathExact(Node* math, Node* test, bool use_builtin_throw) {\n@@ -2034,2 +2034,6 @@\n-    uncommon_trap(Deoptimization::Reason_intrinsic,\n-                  Deoptimization::Action_none);\n+    if (use_builtin_throw) {\n+      builtin_throw(Deoptimization::Reason_intrinsic, env()->ArithmeticException_instance());\n+    } else {\n+      uncommon_trap(Deoptimization::Reason_intrinsic,\n+                    Deoptimization::Action_maybe_recompile);\n+    }\n@@ -2045,0 +2049,10 @@\n+  bool use_builtin_throw = false;\n+  if (builtin_throw_applies(Deoptimization::Reason_intrinsic).first) {\n+    \/\/ If builtin_throw would work (notably, the throw is hot and we don't care about backtraces),\n+    \/\/ instead of bailing out on intrinsic or potentially deopting, let's do that!\n+    use_builtin_throw = true;\n+  } else if (too_many_traps(Deoptimization::Reason_intrinsic)) {\n+    \/\/ It has been already too many times, but we cannot use builtin_throw care (e.g. we care about backtraces),\n+    \/\/ so let's bail out intrinsic rather than risking deopting again.\n+    return false;\n+  }\n@@ -2049,1 +2063,1 @@\n-  inline_math_mathExact(operation, ofcheck);\n+  inline_math_mathExact(operation, ofcheck, use_builtin_throw);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-  void inline_math_mathExact(Node* math, Node* test);\n+  void inline_math_mathExact(Node* math, Node* test, bool use_builtin_throw);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          The base case\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          With ProfileTraps enabled to allow builtin_throw to work\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:+ProfileTraps -XX:+StackTraceInThrowable -XX:+OmitStackTraceInFastThrow\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          ProfileTraps off => throw will never be hot for builtin_throw\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:-ProfileTraps\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          OmitStackTraceInFastThrow off => can_omit_stack_trace is false => no builtin_throw\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:+ProfileTraps -XX:+StackTraceInThrowable -XX:-OmitStackTraceInFastThrow\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          StackTraceInThrowable off => can_omit_stack_trace is true => yes builtin_throw\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:+ProfileTraps -XX:-StackTraceInThrowable -XX:+OmitStackTraceInFastThrow\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          StackTraceInThrowable off && OmitStackTraceInFastThrow off => can_omit_stack_trace is true => yes builtin_throw\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:+ProfileTraps -XX:-StackTraceInThrowable -XX:-OmitStackTraceInFastThrow\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Math.*Exact intrinsics, especially in case of overflow\n+ *          Without intrinsics\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI\n+ *      -Xcomp -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.intrinsics.mathexact.OverflowTest::comp_*\n+ *      -XX:CompileCommand=dontinline,compiler.intrinsics.mathexact.OverflowTest::*\n+ *      -XX:DisableIntrinsic=_addExactI,_incrementExactI,_addExactL,_incrementExactL,_subtractExactI,_decrementExactI,_subtractExactL,_decrementExactL,_negateExactI,_negateExactL,_multiplyExactI,_multiplyExactL\n+ *      compiler.intrinsics.mathexact.OverflowTest\n+ *\/\n+\n+package compiler.intrinsics.mathexact;\n+\n+import java.lang.reflect.Method;\n+\n+import compiler.lib.generators.RestrictableGenerator;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import static compiler.lib.generators.Generators.G;\n+\n+public class OverflowTest {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final RestrictableGenerator<Integer> int_gen = G.ints();\n+    private static final int LIMIT = 10_000;\n+\n+    public static void main(String... args) throws NoSuchMethodException {\n+        OverflowTest t = new OverflowTest();\n+        t.run();\n+    }\n+\n+    void run() throws NoSuchMethodException {\n+        check_compilation();\n+        check_multiplyI();\n+    }\n+\n+    void check_compilation() throws NoSuchMethodException {\n+        \/\/ Force Math loading\n+        Math.min(2, 3);\n+        comp_multiplyI(0, 0);\n+        comp_multiplyI_no_catch(0, 0);\n+        int_multiplyI(0, 0);\n+\n+        Method comp_multiplyI_meth = OverflowTest.class.getDeclaredMethod(\"comp_multiplyI\", int.class, int.class);\n+        Asserts.assertTrue(WHITE_BOX.isMethodCompiled(comp_multiplyI_meth), \"comp_multiplyI(int, int) is not compiled\");\n+\n+        Method comp_multiplyI_no_catch_meth = OverflowTest.class.getDeclaredMethod(\"comp_multiplyI_no_catch\", int.class, int.class);\n+        Asserts.assertTrue(WHITE_BOX.isMethodCompiled(comp_multiplyI_no_catch_meth), \"comp_multiplyI_no_catch(int, int) is not compiled\");\n+\n+        Method int_multiplyI_meth = OverflowTest.class.getDeclaredMethod(\"int_multiplyI\", int.class, int.class);\n+        Asserts.assertFalse(WHITE_BOX.isMethodCompiled(int_multiplyI_meth), \"int_multiplyI(int, int) is compiled\");\n+    }\n+\n+    void assert_consistent(Integer comp_res, Integer int_res) {\n+        if (int_res == null) {\n+            Asserts.assertNull(comp_res);\n+        } else {\n+            Asserts.assertNotNull(comp_res);\n+            Asserts.assertEquals(comp_res, int_res);\n+        }\n+    }\n+\n+    Integer comp_multiplyI(int a, int b) {\n+        try {\n+            return Math.multiplyExact(a, b);\n+        } catch (ArithmeticException e) {\n+            return null;\n+        }\n+    }\n+\n+    int comp_multiplyI_no_catch(int a, int b) {\n+        return Math.multiplyExact(a, b);\n+    }\n+\n+    Integer int_multiplyI(int a, int b) {\n+        try {\n+            return Math.multiplyExact(a, b);\n+        } catch (ArithmeticException e) {\n+            return null;\n+        }\n+    }\n+\n+    void check_multiplyI() {\n+        \/\/ 46_340 < 2 ^ 15.5 < 46_341 =>\n+        \/\/ 46_340^2 < 2 ^ 31 < 46_341^2\n+        int limit_square_do_not_overflow = 46_340;\n+\n+        \/\/ In bound cases\n+        for (int i = 0; i < LIMIT; i++) {\n+            int a = limit_square_do_not_overflow - i;\n+            Integer comp_res = comp_multiplyI(a, a);\n+            Integer int_res = int_multiplyI(a, a);\n+            Asserts.assertNotNull(int_res);\n+            assert_consistent(comp_res, int_res);\n+        }\n+        for (int i = 0; i < LIMIT; i++) {\n+            int a = limit_square_do_not_overflow - i;\n+            Integer comp_res;\n+            try {\n+                comp_res = comp_multiplyI_no_catch(a, a);\n+            } catch (ArithmeticException _) {\n+                comp_res = null;\n+            }\n+            Integer int_res = int_multiplyI(a, a);\n+            Asserts.assertNotNull(int_res);\n+            assert_consistent(comp_res, int_res);\n+        }\n+\n+        \/\/ Out of bound cases\n+        for (int i = 0; i < LIMIT; i++) {\n+            int a = limit_square_do_not_overflow + 1 + i;\n+            Integer comp_res = comp_multiplyI(a, a);\n+            Integer int_res = int_multiplyI(a, a);\n+            Asserts.assertNull(int_res);\n+            assert_consistent(comp_res, int_res);\n+        }\n+        for (int i = 0; i < LIMIT; i++) {\n+            int a = limit_square_do_not_overflow + 1 + i;\n+            Integer comp_res;\n+            try {\n+                comp_res = comp_multiplyI_no_catch(a, a);\n+            } catch (ArithmeticException _) {\n+                comp_res = null;\n+            }\n+            Integer int_res = int_multiplyI(a, a);\n+            Asserts.assertNull(int_res);\n+            assert_consistent(comp_res, int_res);\n+        }\n+\n+        \/\/ Random slice\n+        int lhs = int_gen.next();\n+        int rhs_start = int_gen.next() & 0xff_ff_00_00;\n+        for (int i = 0; i < 0x1_00_00; i++) {\n+            int rhs = rhs_start | i;\n+            Integer comp_res = comp_multiplyI(lhs, rhs);\n+            Integer int_res = int_multiplyI(lhs, rhs);\n+            assert_consistent(comp_res, int_res);\n+        }\n+        for (int i = 0; i < 0x1_00_00; i++) {\n+            int rhs = rhs_start | i;\n+            Integer comp_res;\n+            try {\n+                comp_res = comp_multiplyI_no_catch(lhs, rhs);\n+            } catch (ArithmeticException _) {\n+                comp_res = null;\n+            }\n+            Integer int_res = int_multiplyI(lhs, rhs);\n+            assert_consistent(comp_res, int_res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/mathexact\/OverflowTest.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,403 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.MILLISECONDS)\n+public abstract class MathExact {\n+    @Param({\"1000000\"})\n+    public int SIZE;\n+\n+\n+    \/\/ === multiplyExact(int, int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testMultiplyI(int i) {\n+        try {\n+            return Math.multiplyExact(i, i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testMultiplyI(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            \/\/ 46_340 < 2 ^ 15.5 (< 46_341, but that's not important)\n+            \/\/ so\n+            \/\/ 46_340 ^ 2 < 2 ^ 31\n+            testMultiplyI(i % 46_341);\n+        }\n+    }\n+\n+\n+    \/\/ === multiplyExact(long, long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testMultiplyL(long i) {\n+        try {\n+            return Math.multiplyExact(i, i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            \/\/ (2 ^ 63 - 1)^0.5 ~= 3_037_000_499.9761\n+            \/\/ Starting at 3_037_000_000 so that almost all computations overflow\n+            testMultiplyL(3_037_000_000L + i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopMultiplyLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testMultiplyL(i);\n+        }\n+    }\n+\n+\n+    \/\/ === negateExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testNegateI(int i) {\n+        try {\n+            return Math.negateExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(Integer.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testNegateI(Integer.MAX_VALUE);\n+        }\n+    }\n+\n+\n+    \/\/ === negateExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testNegateL(long i) {\n+        try {\n+            return Math.negateExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(Long.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopNegateLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testNegateL(Long.MAX_VALUE);\n+        }\n+    }\n+\n+\n+    \/\/ === incrementExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testIncrementI(int i) {\n+        try {\n+            return Math.incrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(Integer.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testIncrementI(Integer.MIN_VALUE + i);\n+        }\n+    }\n+\n+\n+    \/\/ === incrementExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testIncrementL(long i) {\n+        try {\n+            return Math.incrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(Long.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopIncrementLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testIncrementL(Long.MIN_VALUE + i);\n+        }\n+    }\n+\n+\n+    \/\/ === decrementExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testDecrementI(int i) {\n+        try {\n+            return Math.decrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(Integer.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(i);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            testDecrementI(Integer.MAX_VALUE - i);\n+        }\n+    }\n+\n+\n+    \/\/ === decrementExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testDecrementL(long i) {\n+        try {\n+            return Math.decrementExact(i);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(Long.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopDecrementLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(i);\n+        }\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testDecrementL(Long.MAX_VALUE - i);\n+        }\n+    }\n+\n+\n+    \/\/ === addExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testAddI(int l, int r) {\n+        try {\n+            return Math.addExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testAddI(Integer.MAX_VALUE - 1_000, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testAddI(i * 5, i);\n+        }\n+    }\n+\n+\n+    \/\/ === addExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testAddL(long l, long r) {\n+        try {\n+            return Math.addExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testAddL(Long.MAX_VALUE - 1_000L, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopAddLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testAddL(i * 5L, i);\n+        }\n+    }\n+\n+\n+    \/\/ === subtractExact(int) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testSubtractI(int l, int r) {\n+        try {\n+            return Math.subtractExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractIOverflow() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testSubtractI(Integer.MIN_VALUE + 1_000, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractIInBounds() {\n+        for (int i = 0; i < SIZE; i++) {\n+            testSubtractI(i * 5, i);\n+        }\n+    }\n+\n+\n+    \/\/ === subtractExact(long) ===\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long testSubtractL(long l, long r) {\n+        try {\n+            return Math.subtractExact(l, r);\n+        } catch (ArithmeticException e) {\n+            return 0L;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractLOverflow() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testSubtractL(Long.MIN_VALUE + 1_000L, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void loopSubtractLInBounds() {\n+        for (long i = 0L; i < (long)SIZE; i++) {\n+            testSubtractL(i * 5L, i);\n+        }\n+    }\n+\n+\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:TieredStopAtLevel=1\"})\n+    public static class C1_1 extends MathExact {}\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:TieredStopAtLevel=2\"})\n+    public static class C1_2 extends MathExact {}\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:TieredStopAtLevel=3\"})\n+    public static class C1_3 extends MathExact {}\n+\n+    @Fork(value = 1)\n+    public static class C2 extends MathExact {}\n+\n+    @Fork(value = 1,\n+            jvmArgs = {\n+                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                    \"-XX:DisableIntrinsic=_addExactI,_incrementExactI,_addExactL,_incrementExactL,_subtractExactI,_decrementExactI,_subtractExactL,_decrementExactL,_negateExactI,_negateExactL,_multiplyExactI,_multiplyExactL\",\n+            })\n+    public static class C2_no_intrinsics extends MathExact {}\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:-OmitStackTraceInFastThrow\"})\n+    public static class C2_no_builtin_throw extends MathExact {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MathExact.java","additions":403,"deletions":0,"binary":false,"changes":403,"status":"added"}]}