{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.source.tree.NewArrayTree;\n@@ -110,0 +111,1 @@\n+import java.util.Optional;\n@@ -305,0 +307,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n@@ -453,0 +456,6 @@\n+                        if (isAnnotation(tp)) {\n+                            Predicate<Element> accept = accessibility.and(STATIC_ONLY)\n+                                    .and(IS_PACKAGE.or(IS_CLASS).or(IS_INTERFACE));\n+                            addScopeElements(at, scope, IDENTITY, accept, IS_PACKAGE.negate().and(smartTypeFilter), result);\n+                            break;\n+                        }\n@@ -475,0 +484,12 @@\n+                    case ANNOTATION: {\n+                        Element annotationType = at.trees().getElement(tp);\n+                        addElements(ElementFilter.methodsIn(annotationType.getEnclosedElements()), TRUE, TRUE, _ -> \" = \", result);\n+                        boolean hasValue =\n+                                ElementFilter.methodsIn(annotationType.getEnclosedElements())\n+                                             .stream()\n+                                             .anyMatch(ee -> ee.getSimpleName().contentEquals(\"value\"));\n+                        if (!hasValue) {\n+                            break;\n+                        }\n+                        \/\/fall-through\n+                    }\n@@ -480,0 +501,1 @@\n+                        boolean insertPrimitiveTypes = true;\n@@ -507,0 +529,23 @@\n+                        } else if (tp.getParentPath().getLeaf().getKind() == Kind.ANNOTATION) {\n+                            AnnotationTree annotation = (AnnotationTree) tp.getParentPath().getLeaf();\n+                            Element annotationType = at.trees().getElement(tp.getParentPath());\n+                            Set<String> present = annotation.getArguments()\n+                                                            .stream()\n+                                                            .filter(expr -> expr.getKind() == Kind.ASSIGNMENT)\n+                                                            .map(expr -> (AssignmentTree) expr)\n+                                                            .map(assign -> assign.getVariable())\n+                                                            .filter(var -> var.getKind() == Kind.IDENTIFIER)\n+                                                            .map(var -> ((IdentifierTree) var).getName().toString())\n+                                                            .collect(Collectors.toSet());\n+                            addElements(ElementFilter.methodsIn(annotationType.getEnclosedElements()), el -> !present.contains(el.getSimpleName().toString()), TRUE, _ -> \" = \", result);\n+                            break;\n+                        } else if (isAnnotationAttributeValue(tp) || tp.getLeaf().getKind() == Kind.ANNOTATION) {\n+                            accept = accessibility.and(el -> {\n+                                return switch (el.getKind()) {\n+                                    case PACKAGE, ANNOTATION_TYPE, ENUM, INTERFACE, RECORD, ENUM_CONSTANT -> true;\n+                                    case CLASS -> !((TypeElement) el).asType().getKind().isPrimitive();\n+                                    case FIELD -> isAnnotationAttributeValueType(at, el.asType());\n+                                    default -> false;\n+                                };\n+                            });\n+                            insertPrimitiveTypes = false;\n@@ -511,10 +556,20 @@\n-                        Tree parent = tp.getParentPath().getLeaf();\n-                        accept = switch (parent.getKind()) {\n-                            case VARIABLE -> ((VariableTree) parent).getType() == tp.getLeaf() ?\n-                                             IS_VOID.negate() :\n-                                             TRUE;\n-                            case PARAMETERIZED_TYPE -> FALSE; \/\/ TODO: JEP 218: Generics over Primitive Types\n-                            case TYPE_PARAMETER, CLASS, INTERFACE, ENUM, RECORD -> FALSE;\n-                            default -> TRUE;\n-                        };\n-                        addElements(primitivesOrVoid(at), accept, smartFilter, result);\n+                        if (insertPrimitiveTypes) {\n+                            Tree parent = tp.getParentPath().getLeaf();\n+                            accept = switch (parent.getKind()) {\n+                                case VARIABLE -> ((VariableTree) parent).getType() == tp.getLeaf() ?\n+                                                 IS_VOID.negate() :\n+                                                 TRUE;\n+                                case PARAMETERIZED_TYPE -> FALSE; \/\/ TODO: JEP 218: Generics over Primitive Types\n+                                case TYPE_PARAMETER, CLASS, INTERFACE, ENUM, RECORD -> FALSE;\n+                                default -> TRUE;\n+                            };\n+                            addElements(primitivesOrVoid(at), accept, smartFilter, result);\n+                        }\n+\n+                        boolean hasBooleanSmartType = targetTypes != null &&\n+                                StreamSupport.stream(targetTypes.spliterator(), false)\n+                                             .anyMatch(tm -> tm.getKind() == TypeKind.BOOLEAN);\n+                        if (hasBooleanSmartType) {\n+                            result.add(new SuggestionImpl(\"true\", true));\n+                            result.add(new SuggestionImpl(\"false\", true));\n+                        }\n@@ -911,0 +966,6 @@\n+    private boolean isAnnotation(TreePath tp) {\n+        Tree parent = tp.getParentPath().getLeaf();\n+        return parent.getKind() == Kind.ANNOTATION &&\n+                ((AnnotationTree)parent).getAnnotationType().equals(tp.getLeaf());\n+    }\n+\n@@ -926,0 +987,14 @@\n+    private boolean isAnnotationAttributeValue(TreePath tp) {\n+        if (tp.getParentPath() == null) {\n+            return false;\n+        }\n+        if (tp.getParentPath().getLeaf().getKind() == Kind.NEW_ARRAY &&\n+            ((NewArrayTree) tp.getParentPath().getLeaf()).getInitializers().contains(tp.getLeaf())) {\n+            return isAnnotationAttributeValue(tp.getParentPath());\n+        }\n+        if (tp.getParentPath().getParentPath() == null) {\n+            return false;\n+        }\n+        return tp.getParentPath().getParentPath().getLeaf().getKind() == Kind.ANNOTATION;\n+    }\n+\n@@ -952,0 +1027,11 @@\n+    private boolean isAnnotationAttributeValueType(AnalyzeTask at, TypeMirror type) {\n+        if (type.getKind().isPrimitive()) {\n+            return true;\n+        }\n+        if (type.getKind() == TypeKind.DECLARED) {\n+            Element el = ((DeclaredType) type).asElement();\n+            return el.getKind() == ElementKind.ENUM || el.equals(at.getElements().getTypeElement(\"java.lang.String\"));\n+        }\n+        return false;\n+    }\n+\n@@ -1249,0 +1335,20 @@\n+        if (current.getKind() == Kind.ANNOTATION) {\n+            Element type = at.trees().getElement(forPath);\n+            if (type != null) {\n+                Optional<ExecutableElement> valueAttr =\n+                        ElementFilter.methodsIn(type.getEnclosedElements())\n+                                     .stream()\n+                                     .filter(ee -> ee.getSimpleName().contentEquals(\"value\"))\n+                                     .findAny();\n+                if (valueAttr.isPresent()) {\n+                    TypeMirror returnType = valueAttr.orElseThrow().getReturnType();\n+\n+                    if (returnType.getKind() == TypeKind.ARRAY) {\n+                        returnType = ((ArrayType) returnType).getComponentType();\n+                    }\n+\n+                    return Collections.singletonList(returnType);\n+                }\n+            }\n+        }\n+\n@@ -1250,0 +1356,8 @@\n+            case NEW_ARRAY:\n+                if (isAnnotationAttributeValue(forPath)) {\n+                    forPath = forPath.getParentPath();\n+                    current = forPath.getLeaf();\n+                    \/\/fall-through\n+                } else {\n+                    break;\n+                }\n@@ -1252,2 +1366,17 @@\n-                if (tree.getExpression() == current)\n-                    return Collections.singletonList(at.trees().getTypeMirror(new TreePath(forPath.getParentPath(), tree.getVariable())));\n+                if (tree.getExpression() == current) {\n+                    if (forPath.getParentPath().getParentPath().getLeaf().getKind() == Kind.ANNOTATION) {\n+                        Element method = at.trees().getElement(new TreePath(forPath.getParentPath(), tree.getVariable()));\n+                        if (method != null && method.getKind() == ElementKind.METHOD) {\n+                            TypeMirror returnType = ((ExecutableElement) method).getReturnType();\n+\n+                            if (returnType.getKind() == TypeKind.ARRAY) {\n+                                returnType = ((ArrayType) returnType).getComponentType();\n+                            }\n+\n+                            return Collections.singletonList(returnType);\n+                        }\n+                        return null;\n+                    } else {\n+                        return Collections.singletonList(at.trees().getTypeMirror(new TreePath(forPath.getParentPath(), tree.getVariable())));\n+                    }\n+                }\n@@ -1501,1 +1630,2 @@\n-                   tp.getLeaf().getKind() != Kind.MEMBER_SELECT) {\n+                   tp.getLeaf().getKind() != Kind.MEMBER_SELECT &&\n+                   tp.getLeaf().getKind() != Kind.ANNOTATION) {\n@@ -1554,0 +1684,12 @@\n+            } else if (tp.getLeaf().getKind() == Kind.ANNOTATION) {\n+                Element el = at.trees().getElement(tp);\n+\n+                if (el == null ||\n+                    el.getKind() != ElementKind.ANNOTATION_TYPE) {\n+                    \/\/erroneous state:\n+                    return Collections.emptyList();\n+                }\n+\n+                elements = ElementFilter.methodsIn(el.getEnclosedElements())\n+                                        .stream()\n+                                        .map(ee -> (Element) ee);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":155,"deletions":13,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -824,0 +824,18 @@\n+\n+    public void testAnnotation() {\n+        assertCompletion(\"@Deprec|\", \"Deprecated\");\n+        assertCompletion(\"@Deprecated(|\", \"forRemoval = \", \"since = \");\n+        assertCompletion(\"@Deprecated(forRemoval = |\", true, \"false\", \"true\");\n+        assertCompletion(\"@Deprecated(forRemoval = true, |\", \"since = \");\n+        assertEval(\"import java.lang.constant.ConstantDescs;\");\n+        assertEval(\"import static java.lang.constant.ConstantDescs.*;\");\n+        assertEval(\"@interface Ann1 { public String test(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann1(test = |\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\"), Set.of(\"CD_char\", \"byte\"));\n+        assertEval(\"@interface Ann2 { public String[] test(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann2(test = {|\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\"), Set.of(\"CD_char\", \"byte\"));\n+        assertCompletionIncludesExcludes(\"@Ann2(test = {|\", true, Set.of(\"INIT_NAME\"), Set.of(\"java.\", \"ConstantDescs\", \"CD_char\", \"byte\"));\n+        assertEval(\"@interface Ann3 { public String value(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann3(|\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\", \"value = \"), Set.of(\"CD_char\", \"byte\"));\n+        assertCompletionIncludesExcludes(\"@Ann3(|\", true, Set.of(\"INIT_NAME\", \"value = \"), Set.of(\"java.\", \"ConstantDescs\", \"CD_char\", \"byte\"));\n+        assertSignature(\"@Deprecated(|\", \"boolean Deprecated.forRemoval()\", \"String Deprecated.since()\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}