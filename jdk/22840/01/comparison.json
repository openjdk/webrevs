{"files":[{"patch":"@@ -397,1 +397,1 @@\n-                            prefixOpt.orElse(\"\").substring(cursor - anchor[0]);\n+                            prefixOpt.orElse(\"\");\n@@ -399,1 +399,1 @@\n-                    if (!prefix.isEmpty() && !command) {\n+                    if (prefix.length() > cursor - anchor[0] && !command) {\n@@ -408,0 +408,1 @@\n+                                                       anchor[0],\n@@ -612,0 +613,1 @@\n+        private final int anchor;\n@@ -617,0 +619,1 @@\n+                                      int anchor,\n@@ -621,0 +624,1 @@\n+            this.anchor = anchor;\n@@ -633,1 +637,8 @@\n-            in.putString(prefix);\n+            String existingPrefix = in.getBuffer().substring(anchor, cursor);\n+\n+            if (prefix.startsWith(existingPrefix)) {\n+                in.putString(prefix.substring(existingPrefix.length()));\n+            } else {\n+                in.getBuffer().backspace(existingPrefix.length());\n+                in.putString(prefix);\n+            }\n@@ -642,1 +653,1 @@\n-            if (!prefix.isEmpty())\n+            if (prefix.length() > existingPrefix.length())\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.source.tree.NewArrayTree;\n@@ -113,0 +114,1 @@\n+import java.util.Optional;\n@@ -311,2 +313,2 @@\n-        return computeSuggestions(codeWrap, cursor, requiredPrefix, anchor).stream()\n-                .filter(s -> s.continuation().startsWith(requiredPrefix[0]) && !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))\n+        return computeSuggestions(codeWrap, code, cursor, requiredPrefix, anchor).stream()\n+                .filter(s -> filteringText(s).startsWith(requiredPrefix[0]) && !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))\n@@ -317,1 +319,7 @@\n-    private List<Suggestion> computeSuggestions(OuterWrap code, int cursor, String[] requiredPrefix, int[] anchor) {\n+    private static String filteringText(Suggestion suggestion) {\n+        return suggestion instanceof SuggestionImpl impl\n+                ? impl.filteringText\n+                : suggestion.continuation();\n+    }\n+\n+    private List<Suggestion> computeSuggestions(OuterWrap code, String inputCode, int cursor, String[] requiredPrefix, int[] anchor) {\n@@ -480,0 +488,13 @@\n+                        if (isAnnotation(tp)) {\n+                            if (getAnnotationAttributeNameOrNull(tp.getParentPath(), true) != null) {\n+                                \/\/nested annotation\n+                                result = completionSuggestionsImpl(inputCode, cursor - 1, anchor);\n+                                requiredPrefix[0] = \"@\" + requiredPrefix[0];\n+                                return result;\n+                            }\n+\n+                            Predicate<Element> accept = accessibility.and(STATIC_ONLY)\n+                                    .and(IS_PACKAGE.or(IS_CLASS).or(IS_INTERFACE));\n+                            addScopeElements(at, scope, IDENTITY, accept, IS_PACKAGE.negate().and(smartTypeFilter), result);\n+                            break;\n+                        }\n@@ -513,0 +534,1 @@\n+                        boolean insertPrimitiveTypes = true;\n@@ -540,0 +562,71 @@\n+                        } else if (tp.getParentPath().getLeaf().getKind() == Kind.ANNOTATION) {\n+                            AnnotationTree annotation = (AnnotationTree) tp.getParentPath().getLeaf();\n+                            Element annotationType = at.trees().getElement(tp.getParentPath());\n+                            Set<String> present = annotation.getArguments()\n+                                                            .stream()\n+                                                            .filter(expr -> expr.getKind() == Kind.ASSIGNMENT)\n+                                                            .map(expr -> (AssignmentTree) expr)\n+                                                            .map(assign -> assign.getVariable())\n+                                                            .filter(var -> var.getKind() == Kind.IDENTIFIER)\n+                                                            .map(var -> ((IdentifierTree) var).getName().toString())\n+                                                            .collect(Collectors.toSet());\n+                            addElements(ElementFilter.methodsIn(annotationType.getEnclosedElements()), el -> !present.contains(el.getSimpleName().toString()), TRUE, _ -> \" = \", result);\n+                            break;\n+                        } else if (getAnnotationAttributeNameOrNull(tp, true) instanceof String attributeName) {\n+                            Element annotationType = tp.getParentPath().getParentPath().getLeaf().getKind() == Kind.ANNOTATION\n+                                    ? at.trees().getElement(tp.getParentPath().getParentPath())\n+                                    : at.trees().getElement(tp.getParentPath().getParentPath().getParentPath());\n+                            if (sp.getEndPosition(topLevel, tp.getParentPath().getLeaf()) == (-1)) {\n+                                \/\/synthetic 'value':\n+                                addElements(ElementFilter.methodsIn(annotationType.getEnclosedElements()), TRUE, TRUE, _ -> \" = \", result);\n+                                boolean hasValue = findAnnotationAttributeIfAny(annotationType, \"value\").isPresent();\n+                                if (!hasValue) {\n+                                    break;\n+                                }\n+                            }\n+                            Optional<ExecutableElement> ee = findAnnotationAttributeIfAny(annotationType, attributeName);\n+                            if (ee.isEmpty()) {\n+                                break;\n+                            }\n+                            TypeMirror relevantAttributeType = ee.orElseThrow().getReturnType();\n+                            if (relevantAttributeType.getKind() == TypeKind.ARRAY) {\n+                                relevantAttributeType = ((ArrayType) relevantAttributeType).getComponentType();\n+                            }\n+                            if (relevantAttributeType.getKind() == TypeKind.DECLARED &&\n+                                at.getTypes().asElement(relevantAttributeType) instanceof Element attributeTypeEl) {\n+                                if (attributeTypeEl.getKind() == ElementKind.ANNOTATION_TYPE) {\n+                                    boolean hasAnyAttributes =\n+                                            ElementFilter.methodsIn(attributeTypeEl.getEnclosedElements())\n+                                                         .stream()\n+                                                         .anyMatch(attribute -> attribute.getParameters().isEmpty());\n+                                    String paren = hasAnyAttributes ? \"(\" : \"\";\n+                                    String name = scopeContent(at, scope, IDENTITY).contains(attributeTypeEl)\n+                                            ? attributeTypeEl.getSimpleName().toString() \/\/simple name ought to be enough:\n+                                            : ((TypeElement) attributeTypeEl).getQualifiedName().toString();\n+                                    result.add(new SuggestionImpl(\"@\" + name + paren, true));\n+                                    break;\n+                                } else if (attributeTypeEl.getKind() == ElementKind.ENUM) {\n+                                    String typeName = scopeContent(at, scope, IDENTITY).contains(attributeTypeEl)\n+                                            ? attributeTypeEl.getSimpleName().toString() \/\/simple name ought to be enough:\n+                                            : ((TypeElement) attributeTypeEl).getQualifiedName().toString();\n+                                    result.add(new SuggestionImpl(typeName, true));\n+                                    result.addAll(ElementFilter.fieldsIn(attributeTypeEl.getEnclosedElements())\n+                                                               .stream()\n+                                                               .filter(e -> e.getKind() == ElementKind.ENUM_CONSTANT)\n+                                                               .map(c -> new SuggestionImpl(scopeContent(at, scope, IDENTITY).contains(c)\n+                                                                       ? c.getSimpleName().toString()\n+                                                                       : typeName + \".\" + c.getSimpleName(), c.getSimpleName().toString(),\n+                                                                       true))\n+                                                               .toList());\n+                                    break;\n+                                }\n+                            }\n+                            accept = accessibility.and(el -> {\n+                                return switch (el.getKind()) {\n+                                    case PACKAGE, ANNOTATION_TYPE, ENUM, INTERFACE, RECORD, ENUM_CONSTANT -> true;\n+                                    case CLASS -> !((TypeElement) el).asType().getKind().isPrimitive();\n+                                    case FIELD -> isPermittedAnnotationAttributeFieldType(at, el.asType());\n+                                    default -> false;\n+                                };\n+                            });\n+                            insertPrimitiveTypes = false;\n@@ -544,10 +637,20 @@\n-                        Tree parent = tp.getParentPath().getLeaf();\n-                        accept = switch (parent.getKind()) {\n-                            case VARIABLE -> ((VariableTree) parent).getType() == tp.getLeaf() ?\n-                                             IS_VOID.negate() :\n-                                             TRUE;\n-                            case PARAMETERIZED_TYPE -> FALSE; \/\/ TODO: JEP 218: Generics over Primitive Types\n-                            case TYPE_PARAMETER, CLASS, INTERFACE, ENUM, RECORD -> FALSE;\n-                            default -> TRUE;\n-                        };\n-                        addElements(primitivesOrVoid(at), accept, smartFilter, result);\n+                        if (insertPrimitiveTypes) {\n+                            Tree parent = tp.getParentPath().getLeaf();\n+                            accept = switch (parent.getKind()) {\n+                                case VARIABLE -> ((VariableTree) parent).getType() == tp.getLeaf() ?\n+                                                 IS_VOID.negate() :\n+                                                 TRUE;\n+                                case PARAMETERIZED_TYPE -> FALSE; \/\/ TODO: JEP 218: Generics over Primitive Types\n+                                case TYPE_PARAMETER, CLASS, INTERFACE, ENUM, RECORD -> FALSE;\n+                                default -> TRUE;\n+                            };\n+                            addElements(primitivesOrVoid(at), accept, smartFilter, result);\n+                        }\n+\n+                        boolean hasBooleanSmartType = targetTypes != null &&\n+                                StreamSupport.stream(targetTypes.spliterator(), false)\n+                                             .anyMatch(tm -> tm.getKind() == TypeKind.BOOLEAN);\n+                        if (hasBooleanSmartType) {\n+                            result.add(new SuggestionImpl(\"true\", true));\n+                            result.add(new SuggestionImpl(\"false\", true));\n+                        }\n@@ -915,0 +1018,6 @@\n+                if (end == (-1) && tree.getKind() == Kind.ASSIGNMENT &&\n+                    getCurrentPath() != null &&\n+                    getCurrentPath().getLeaf().getKind() == Kind.ANNOTATION) {\n+                    \/\/the assignment is synthetically generated, take the end pos of the nested tree:\n+                    end = sp.getEndPosition(topLevel, ((AssignmentTree) tree).getExpression());\n+                }\n@@ -944,0 +1053,6 @@\n+    private boolean isAnnotation(TreePath tp) {\n+        Tree parent = tp.getParentPath().getLeaf();\n+        return parent.getKind() == Kind.ANNOTATION &&\n+                ((AnnotationTree)parent).getAnnotationType().equals(tp.getLeaf());\n+    }\n+\n@@ -959,0 +1074,33 @@\n+    private String getAnnotationAttributeNameOrNull(TreePath tp, boolean acceptArray) {\n+        if (tp.getParentPath() == null) {\n+            return null;\n+        }\n+        if (tp.getParentPath().getLeaf().getKind() == Kind.NEW_ARRAY &&\n+            ((NewArrayTree) tp.getParentPath().getLeaf()).getInitializers().contains(tp.getLeaf())) {\n+            if (acceptArray) {\n+                return getAnnotationAttributeNameOrNull(tp.getParentPath(), false);\n+            } else {\n+                return null;\n+            }\n+        }\n+        if (tp.getParentPath().getParentPath() == null ||\n+            tp.getParentPath().getLeaf().getKind() != Kind.ASSIGNMENT ||\n+            tp.getParentPath().getParentPath().getLeaf().getKind() != Kind.ANNOTATION) {\n+            return null;\n+        }\n+        AssignmentTree assign = (AssignmentTree) tp.getParentPath().getLeaf();\n+        if (assign.getVariable().getKind() != Kind.IDENTIFIER) {\n+            return null;\n+        }\n+        return ((IdentifierTree) assign.getVariable()).getName().toString();\n+    }\n+\n+    private Optional<ExecutableElement> findAnnotationAttributeIfAny(Element annotationType,\n+                                                                     String attributeName) {\n+        return ElementFilter.methodsIn(annotationType.getEnclosedElements())\n+                            .stream()\n+                            .filter(ee -> ee.getSimpleName().contentEquals(attributeName))\n+                            .filter(ee -> ee.getParameters().isEmpty())\n+                            .findAny();\n+    }\n+\n@@ -985,0 +1133,11 @@\n+    private boolean isPermittedAnnotationAttributeFieldType(AnalyzeTask at, TypeMirror type) {\n+        if (type.getKind().isPrimitive()) {\n+            return true;\n+        }\n+        if (type.getKind() == TypeKind.DECLARED) {\n+            Element el = ((DeclaredType) type).asElement();\n+            return el.getKind() == ElementKind.ENUM || el.equals(at.getElements().getTypeElement(\"java.lang.String\"));\n+        }\n+        return false;\n+    }\n+\n@@ -1235,1 +1394,1 @@\n-    private Iterable<? extends Element> scopeContent(AnalyzeTask at, Scope scope, Function<Element, Iterable<? extends Element>> elementConvertor) {\n+    private Collection<? extends Element> scopeContent(AnalyzeTask at, Scope scope, Function<Element, Iterable<? extends Element>> elementConvertor) {\n@@ -1304,0 +1463,20 @@\n+        if (current.getKind() == Kind.ANNOTATION) {\n+            Element type = at.trees().getElement(forPath);\n+            if (type != null) {\n+                Optional<ExecutableElement> valueAttr =\n+                        ElementFilter.methodsIn(type.getEnclosedElements())\n+                                     .stream()\n+                                     .filter(ee -> ee.getSimpleName().contentEquals(\"value\"))\n+                                     .findAny();\n+                if (valueAttr.isPresent()) {\n+                    TypeMirror returnType = valueAttr.orElseThrow().getReturnType();\n+\n+                    if (returnType.getKind() == TypeKind.ARRAY) {\n+                        returnType = ((ArrayType) returnType).getComponentType();\n+                    }\n+\n+                    return Collections.singletonList(returnType);\n+                }\n+            }\n+        }\n+\n@@ -1305,0 +1484,8 @@\n+            case NEW_ARRAY:\n+                if (getAnnotationAttributeNameOrNull(forPath, true) != null) {\n+                    forPath = forPath.getParentPath();\n+                    current = forPath.getLeaf();\n+                    \/\/fall-through\n+                } else {\n+                    break;\n+                }\n@@ -1307,2 +1494,17 @@\n-                if (tree.getExpression() == current)\n-                    return Collections.singletonList(at.trees().getTypeMirror(new TreePath(forPath.getParentPath(), tree.getVariable())));\n+                if (tree.getExpression() == current) {\n+                    if (forPath.getParentPath().getParentPath().getLeaf().getKind() == Kind.ANNOTATION) {\n+                        Element method = at.trees().getElement(new TreePath(forPath.getParentPath(), tree.getVariable()));\n+                        if (method != null && method.getKind() == ElementKind.METHOD) {\n+                            TypeMirror returnType = ((ExecutableElement) method).getReturnType();\n+\n+                            if (returnType.getKind() == TypeKind.ARRAY) {\n+                                returnType = ((ArrayType) returnType).getComponentType();\n+                            }\n+\n+                            return Collections.singletonList(returnType);\n+                        }\n+                        return null;\n+                    } else {\n+                        return Collections.singletonList(at.trees().getTypeMirror(new TreePath(forPath.getParentPath(), tree.getVariable())));\n+                    }\n+                }\n@@ -1556,1 +1758,2 @@\n-                   tp.getLeaf().getKind() != Kind.MEMBER_SELECT) {\n+                   tp.getLeaf().getKind() != Kind.MEMBER_SELECT &&\n+                   tp.getLeaf().getKind() != Kind.ANNOTATION) {\n@@ -1609,0 +1812,12 @@\n+            } else if (tp.getLeaf().getKind() == Kind.ANNOTATION) {\n+                Element el = at.trees().getElement(tp);\n+\n+                if (el == null ||\n+                    el.getKind() != ElementKind.ANNOTATION_TYPE) {\n+                    \/\/erroneous state:\n+                    return Collections.emptyList();\n+                }\n+\n+                elements = ElementFilter.methodsIn(el.getEnclosedElements())\n+                                        .stream()\n+                                        .map(ee -> (Element) ee);\n@@ -2211,0 +2426,1 @@\n+        private final String filteringText;\n@@ -2220,0 +2436,11 @@\n+            this(continuation, continuation, matchesType);\n+        }\n+\n+        \/**\n+         * Create a {@code Suggestion} instance.\n+         *\n+         * @param continuation a candidate continuation of the user's input\n+         * @param filteringText a text that should be used for filtering\n+         * @param matchesType does the candidate match the target type\n+         *\/\n+        public SuggestionImpl(String continuation, String filteringText, boolean matchesType) {\n@@ -2221,0 +2448,1 @@\n+            this.filteringText = filteringText;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":245,"deletions":17,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -837,0 +837,42 @@\n+\n+    public void testAnnotation() {\n+        assertCompletion(\"@Deprec|\", \"Deprecated\");\n+        assertCompletion(\"@Deprecated(|\", \"forRemoval = \", \"since = \");\n+        assertCompletion(\"@Deprecated(forRemoval = |\", true, \"false\", \"true\");\n+        assertCompletion(\"@Deprecated(forRemoval = true, |\", \"since = \");\n+        assertEval(\"import java.lang.constant.ConstantDescs;\");\n+        assertEval(\"import static java.lang.constant.ConstantDescs.*;\");\n+        assertEval(\"@interface Ann1 { public String test(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann1(test = |\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\"), Set.of(\"CD_char\", \"byte\"));\n+        assertEval(\"@interface Ann2 { public String[] test(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann2(test = {|\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\"), Set.of(\"CD_char\", \"byte\"));\n+        assertCompletionIncludesExcludes(\"@Ann2(test = {|\", true, Set.of(\"INIT_NAME\"), Set.of(\"java.\", \"ConstantDescs\", \"CD_char\", \"byte\"));\n+        assertEval(\"@interface Ann3 { public String value(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann3(|\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\", \"value = \"), Set.of(\"CD_char\", \"byte\"));\n+        assertCompletionIncludesExcludes(\"@Ann3(|\", true, Set.of(\"INIT_NAME\", \"value = \"), Set.of(\"java.\", \"ConstantDescs\", \"CD_char\", \"byte\"));\n+        assertSignature(\"@Deprecated(|\", \"boolean Deprecated.forRemoval()\", \"String Deprecated.since()\");\n+        assertEval(\"@interface Ann4 { public String[] value(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann4({|\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\"), Set.of(\"value = \"));\n+        assertEval(\"@interface Ann5 { public Ann4[] value(); }\");\n+        assertCompletion(\"@Ann5(|\", true, \"@Ann4(\", \"value = \");\n+        assertCompletion(\"@Ann5({|\", true, \"@Ann4(\");\n+        assertCompletion(\"@Ann5(|\", false);\n+        assertCompletion(\"@Ann5({|\", false);\n+        assertCompletion(\"@Ann5(@|\", true, \"@Ann4(\");\n+        assertCompletion(\"@Ann5(v|\", true, \"value = \");\n+        assertEval(\"@interface Ann6 { public java.lang.annotation.Retention[] value(); }\");\n+        assertCompletion(\"@Ann6(|\", true, \"@java.lang.annotation.Retention(\", \"value = \");\n+        assertEval(\"@interface Ann7 { }\"); \/\/no attributes\n+        assertEval(\"@interface Ann8 { public Ann7[] value(); }\");\n+        assertCompletion(\"@Ann8(|\", true, \"@Ann7\", \"value = \");\n+        assertEval(\"enum En { AA, BB, EE; }\");\n+        assertEval(\"@interface Ann9 { public En[] value(); }\");\n+        assertCompletion(\"@Ann9(|\", true, \"En\", \"En.AA\", \"En.BB\", \"En.EE\", \"value = \");\n+        assertCompletion(\"@Ann9(A|\", true, \"En.AA\");\n+        assertCompletion(\"@Ann9(E|\", true, \"En\", \"En.EE\");\n+        assertCompletionIncludesExcludes(\"@Ann9(En.|\", Set.of(\"AA\", \"BB\", \"EE\"), Set.of());\n+        assertEval(\"@interface AnnA { public java.lang.annotation.RetentionPolicy[] value(); }\");\n+        assertCompletion(\"@AnnA(C|\", true, \"java.lang.annotation.RetentionPolicy.CLASS\");\n+        assertEval(\"import static java.lang.annotation.RetentionPolicy.*;\");\n+        assertCompletion(\"@AnnA(C|\", true, \"CLASS\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -343,0 +343,19 @@\n+\n+    public void testAnnotation() throws Exception {\n+        doRunTest((inputSink, out) -> {\n+            inputSink.write(\"@interface Ann1 { public java.lang.annotation.Retention[] value(); }\\n\");\n+            waitOutput(out, \"\\n\\\\u001B\\\\[\\\\?2004h\" + PROMPT);\n+\n+            \/\/-> <tab>\n+            inputSink.write(\"@Ann1(\" + TAB);\n+            waitOutput(out, \".*@java.lang.annotation.Retention\\\\(.*value =.*\" +\n+                            REDRAW_PROMPT + \"@Ann1\\\\(\");\n+            inputSink.write(\"@\" + TAB);\n+            waitOutput(out, \"^@java.lang.annotation.Retention\\\\(\");\n+            inputSink.write(TAB);\n+            waitOutput(out, \".*java.lang.annotation.RetentionPolicy.*java.lang.annotation.RetentionPolicy.CLASS.*\" +\n+                            REDRAW_PROMPT + \"@Ann1\\\\(@java.lang.annotation.Retention\\\\(\");\n+            inputSink.write(\"CL\" + TAB);\n+            waitOutput(out, \"CL\\\\u001B\\\\[2Djava.lang.annotation.RetentionPolicy.CLASS \\\\u0008\");\n+        });\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/ToolTabSnippetTest.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"}]}