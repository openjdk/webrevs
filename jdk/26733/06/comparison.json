{"files":[{"patch":"@@ -51,8 +51,0 @@\n-const unsigned int initial_size = 431;\n-\n-static JfrCHeapTraceIdSet* c_heap_allocate_set(int size = initial_size) {\n-  return new JfrCHeapTraceIdSet(size);\n-}\n-\n-static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n-\n@@ -69,8 +61,2 @@\n-static bool has_thread_exited(traceid tid) {\n-  assert(tid != 0, \"invariant\");\n-  if (unloaded_thread_id_set == nullptr) {\n-    return false;\n-  }\n-  ThreadIdExclusiveAccess lock;\n-  return unloaded_thread_id_set->contains(tid);\n-}\n+static const unsigned initial_set_size = 512;\n+static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n@@ -81,1 +67,1 @@\n-    unloaded_thread_id_set = c_heap_allocate_set();\n+    unloaded_thread_id_set = new (mtTracing) JfrCHeapTraceIdSet(initial_set_size);\n@@ -196,6 +182,0 @@\n-static JfrResourceAreaTraceIdSet* id_set = nullptr;\n-\n-static void prepare_for_resolution() {\n-  id_set = new JfrResourceAreaTraceIdSet(initial_size);\n-}\n-\n@@ -216,0 +196,2 @@\n+static JfrResourceAreaTraceIdSet* resolution_set = nullptr;\n+\n@@ -223,1 +205,1 @@\n-    prepare_for_resolution();\n+    resolution_set = new JfrResourceAreaTraceIdSet(initial_set_size);\n@@ -225,0 +207,1 @@\n+\n@@ -317,2 +300,2 @@\n-  assert(id_set != nullptr, \"invariant\");\n-  return !id_set->add(method_id);\n+  assert(resolution_set != nullptr, \"invariant\");\n+  return !resolution_set->add(method_id);\n@@ -359,1 +342,1 @@\n-  if (sample->is_virtual_thread() || has_thread_exited(sample->thread_id())) {\n+  if (sample->is_virtual_thread() || sample->thread_exited()) {\n@@ -375,1 +358,1 @@\n-  int _count;\n+  unsigned _count;\n@@ -381,1 +364,1 @@\n-  int count() const { return _count; }\n+  unsigned count() const { return _count; }\n@@ -397,2 +380,1 @@\n-  const int64_t count_offset = writer.reserve(sizeof(u4)); \/\/ Don't know how many yet\n-\n+  writer.write_count(_stacktrace_id_set->size());\n@@ -402,1 +384,0 @@\n-  writer.write_count(lpstw.count(), count_offset);\n@@ -425,0 +406,10 @@\n+static void check_if_thread_exited(const ObjectSample* sample) {\n+  assert(sample != nullptr, \"invariant\");\n+  if (sample->thread_exited() || unloaded_thread_id_set == nullptr) {\n+    return;\n+  }\n+  if (unloaded_thread_id_set->contains(sample->thread_id())) {\n+    sample->set_thread_exited();\n+  }\n+}\n+\n@@ -434,0 +425,1 @@\n+    check_if_thread_exited(sample);\n@@ -440,0 +432,7 @@\n+static void delete_unloaded_thread_id_set() {\n+  if (unloaded_thread_id_set != nullptr) {\n+    delete unloaded_thread_id_set;\n+    unloaded_thread_id_set = nullptr;\n+  }\n+}\n+\n@@ -445,0 +444,1 @@\n+  ThreadIdExclusiveAccess lock;\n@@ -446,0 +446,1 @@\n+  delete_unloaded_thread_id_set();\n@@ -448,3 +449,6 @@\n-static inline unsigned int set_size() {\n-  const unsigned int queue_size = static_cast<unsigned int>(JfrOptionSet::old_object_queue_size());\n-  return queue_size > initial_size ? queue_size : initial_size;\n+static inline unsigned stacktrace_id_set_size() {\n+  unsigned queue_size = static_cast<unsigned>(JfrOptionSet::old_object_queue_size());\n+  if (!is_power_of_2(queue_size)) {\n+    queue_size = next_power_of_2(queue_size);\n+  }\n+  return queue_size > initial_set_size ? queue_size : initial_set_size;\n@@ -459,1 +463,3 @@\n-    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(set_size());\n+    const unsigned stacktrace_set_size = stacktrace_id_set_size();\n+    assert(is_power_of_2(stacktrace_set_size), \"invariant\");\n+    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(stacktrace_set_size);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":42,"deletions":36,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  mutable bool _thread_exited;\n@@ -85,1 +86,2 @@\n-                   _virtual_thread(false) {}\n+                   _virtual_thread(false),\n+                   _thread_exited(false) {}\n@@ -228,0 +230,9 @@\n+  bool thread_exited() const {\n+    return _thread_exited;\n+  }\n+\n+  void set_thread_exited() const {\n+    assert(!_thread_exited, \"invariant\");\n+    _thread_exited = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-void JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {\n+size_t JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {\n@@ -71,1 +71,1 @@\n-    return;\n+    return 0;\n@@ -90,0 +90,1 @@\n+  return 1;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  static void write(JfrChunkWriter& writer);\n+  static size_t write(JfrChunkWriter& writer);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1051,2 +1051,0 @@\n-  KlassUsedPredicate _klass_used_predicate;\n-  MethodUsedPredicate _method_used_predicate;\n@@ -1058,2 +1056,0 @@\n-    _klass_used_predicate(current_epoch()),\n-    _method_used_predicate(current_epoch()),\n@@ -1063,1 +1059,1 @@\n-    if (_method_used_predicate(klass)) {\n+    if (klass->is_instance_klass()) {\n@@ -1078,1 +1074,1 @@\n-    return _klass_used_predicate(klass) ? _klass_cb(klass) : true;\n+    return _klass_cb(klass);\n@@ -1283,1 +1279,1 @@\n-    _artifacts = new JfrArtifactSet(class_unload);\n+    _artifacts = new JfrArtifactSet(class_unload, previous_epoch());\n@@ -1285,1 +1281,1 @@\n-    _artifacts->initialize(class_unload);\n+    _artifacts->initialize(class_unload, previous_epoch());\n@@ -1287,0 +1283,1 @@\n+  assert(current_epoch() || _leakp_writer != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,6 +32,10 @@\n-JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_table(nullptr),\n-                                                    _klass_list(nullptr),\n-                                                    _total_count(0),\n-                                                    _class_unload(class_unload) {\n-  initialize(class_unload);\n-  assert(_klass_list != nullptr, \"invariant\");\n+JfrArtifactSet::JfrArtifactSet(bool class_unload, bool previous_epoch) : _symbol_table(nullptr),\n+                                                                         _klass_set(nullptr),\n+                                                                         _klass_loader_set(nullptr),\n+                                                                         _klass_loader_leakp_set(nullptr),\n+                                                                         _total_count(0),\n+                                                                         _class_unload(class_unload) {\n+  initialize(class_unload, previous_epoch);\n+  assert(!previous_epoch || _klass_loader_leakp_set != nullptr, \"invariant\");\n+  assert(_klass_loader_set != nullptr, \"invariant\");\n+  assert(_klass_set != nullptr, \"invariant\");\n@@ -40,2 +44,3 @@\n-static const size_t initial_klass_list_size = 4096;\n-const int initial_klass_loader_set_size = 64;\n+static unsigned initial_klass_set_size = 4096;\n+static unsigned initial_klass_loader_set_size = 64;\n+static unsigned initial_klass_loader_leakp_set_size = 64;\n@@ -43,1 +48,1 @@\n-void JfrArtifactSet::initialize(bool class_unload) {\n+void JfrArtifactSet::initialize(bool class_unload, bool previous_epoch) {\n@@ -53,3 +58,5 @@\n-  _klass_loader_leakp_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n-  _klass_loader_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n-  _klass_list = new GrowableArray<const Klass*>(initial_klass_list_size);\n+  if (previous_epoch) {\n+    _klass_loader_leakp_set = new JfrKlassSet(initial_klass_loader_leakp_set_size);\n+  }\n+  _klass_loader_set = new JfrKlassSet(initial_klass_loader_set_size);\n+  _klass_set = new JfrKlassSet(initial_klass_set_size);\n@@ -96,5 +103,1 @@\n-  return _klass_list->is_nonempty();\n-}\n-\n-int JfrArtifactSet::entries() const {\n-  return _klass_list->length();\n+  return _klass_set->is_nonempty();\n@@ -102,2 +105,1 @@\n-\n-static inline bool not_in_set(GrowableArray<const Klass*>* set, const Klass* k) {\n+static inline bool not_in_set(JfrArtifactSet::JfrKlassSet* set, const Klass* k) {\n@@ -106,1 +108,1 @@\n-  return !JfrMutablePredicate<const Klass*, compare_klasses>::test(set, k);\n+  return set->add(k);\n@@ -119,2 +121,2 @@\n-  assert(_klass_list != nullptr, \"invariant\");\n-  _klass_list->append(k);\n+  assert(_klass_set != nullptr, \"invariant\");\n+  _klass_set->add(k);\n@@ -124,0 +126,4 @@\n+  assert(_klass_set != nullptr, \"invariant\");\n+  initial_klass_set_size = MAX2(initial_klass_set_size, _klass_set->table_size());\n+  assert(_klass_loader_set != nullptr, \"invariant\");\n+  initial_klass_loader_set_size = MAX2(initial_klass_loader_set_size, _klass_loader_set->table_size());\n@@ -130,0 +136,2 @@\n+  assert(_klass_loader_leakp_set != nullptr, \"invariant\");\n+  initial_klass_loader_leakp_set_size = MAX2(initial_klass_loader_leakp_set_size, _klass_loader_leakp_set->table_size());\n@@ -131,1 +139,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -34,3 +35,0 @@\n-template <typename T>\n-class GrowableArray;\n-\n@@ -138,21 +136,0 @@\n-class KlassUsedPredicate {\n-  bool _current_epoch;\n- public:\n-  KlassUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n-  bool operator()(const Klass* klass) {\n-    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n-  }\n-};\n-\n-class MethodUsedPredicate {\n-  bool _current_epoch;\n-public:\n-  MethodUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n-  bool operator()(const Klass* klass) {\n-    if (!klass->is_instance_klass()) {\n-      return false;\n-    }\n-    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n-  }\n-};\n-\n@@ -206,0 +183,26 @@\n+ public:\n+  class JfrArtifactSetConfig : public AllStatic {\n+   public:\n+    typedef const Klass* KEY_TYPE;\n+\n+    constexpr static AnyObj::allocation_type alloc_type() {\n+      return AnyObj::RESOURCE_AREA;\n+    }\n+\n+    constexpr static MemTag memory_tag() {\n+      return mtInternal;\n+    }\n+\n+    \/\/ Knuth multiplicative hashing.\n+    static uint32_t hash(const KEY_TYPE& k) {\n+      const uint32_t v = static_cast<uint32_t>(JfrTraceId::load_raw(k));\n+      return v * UINT32_C(2654435761);\n+    }\n+\n+    static bool cmp(const KEY_TYPE& lhs, const KEY_TYPE& rhs) {\n+      return lhs == rhs;\n+    }\n+  };\n+\n+  typedef JfrSet<JfrArtifactSetConfig> JfrKlassSet;\n+\n@@ -208,3 +211,3 @@\n-  GrowableArray<const Klass*>* _klass_list;\n-  GrowableArray<const Klass*>* _klass_loader_set;\n-  GrowableArray<const Klass*>* _klass_loader_leakp_set;\n+  JfrKlassSet* _klass_set;\n+  JfrKlassSet* _klass_loader_set;\n+  JfrKlassSet* _klass_loader_leakp_set;\n@@ -215,1 +218,1 @@\n-  JfrArtifactSet(bool class_unload);\n+  JfrArtifactSet(bool class_unload, bool previous_epoch);\n@@ -219,1 +222,1 @@\n-  void initialize(bool class_unload);\n+  void initialize(bool class_unload, bool previous_epoch);\n@@ -234,1 +237,0 @@\n-  int entries() const;\n@@ -257,1 +259,1 @@\n-    if (iterate(functor, _klass_list)) {\n+    if (iterate(functor, _klass_set)) {\n@@ -264,6 +266,4 @@\n-  bool iterate(Functor& functor, GrowableArray<const Klass*>* list) const {\n-    assert(list != nullptr, \"invariant\");\n-    for (int i = 0; i < list->length(); ++i) {\n-      if (!functor(list->at(i))) {\n-        return false;\n-      }\n+  bool iterate(Functor& functor, JfrKlassSet* set) const {\n+    assert(set != nullptr, \"invariant\");\n+    if (set->is_nonempty()) {\n+      set->iterate(functor);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -370,0 +370,1 @@\n+  size_t _elements;\n@@ -371,1 +372,1 @@\n-  MetadataEvent(JfrChunkWriter& cw) : _cw(cw) {}\n+  MetadataEvent(JfrChunkWriter& cw) : _cw(cw), _elements(0) {}\n@@ -373,1 +374,1 @@\n-    JfrMetadataEvent::write(_cw);\n+    _elements = JfrMetadataEvent::write(_cw);\n@@ -376,1 +377,1 @@\n-  size_t elements() const { return 1; }\n+  size_t elements() const { return _elements; }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-static const int initial_size = 1009;\n+static const int initial_size = 1024;\n@@ -36,1 +36,1 @@\n-  return new JfrCHeapTraceIdSet(size);\n+  return new (mtTracing) JfrCHeapTraceIdSet(size);\n@@ -71,7 +71,0 @@\n-static bool is_nonempty_set(u1 epoch) {\n-  if (epoch == 0) {\n-    return _unload_set_epoch_0 != nullptr && _unload_set_epoch_0->is_nonempty();\n-  }\n-  return _unload_set_epoch_1 != nullptr && _unload_set_epoch_1->is_nonempty();\n-}\n-\n@@ -80,3 +73,1 @@\n-  if (is_nonempty_set(JfrTraceIdEpoch::previous())) {\n-    get_unload_set_previous_epoch()->clear();\n-  }\n+  get_unload_set_previous_epoch()->clear();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"utilities\/resizableHashTable.hpp\"\n@@ -32,2 +31,2 @@\n-template <typename AllocPolicy = JfrCHeapObj, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n-class ConfigTraceID : public AllStatic {\n+template <typename K, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n+class JfrSetConfig : public AllStatic {\n@@ -35,2 +34,1 @@\n-  typedef AllocPolicy STORAGE;\n-  typedef traceid TYPE;\n+  typedef K KEY_TYPE;\n@@ -47,3 +45,3 @@\n-  static uint32_t hash(const TYPE& id) {\n-    const uint32_t v = static_cast<uint32_t>(id);\n-    return v * UINT32_C(2654435761);\n+  static uint32_t hash(const KEY_TYPE& key) {\n+    const uint32_t k = static_cast<uint32_t>(key);\n+    return k * UINT32_C(2654435761);\n@@ -52,1 +50,1 @@\n-  static bool cmp(const TYPE& lhs, const TYPE& rhs) {\n+  static bool cmp(const KEY_TYPE& lhs, const KEY_TYPE& rhs) {\n@@ -57,2 +55,0 @@\n-constexpr static unsigned int MAX_TABLE_SIZE = 0x3fffffff;\n-\n@@ -60,7 +56,16 @@\n-class JfrSet : public CONFIG::STORAGE {\n- public:\n-  typedef typename CONFIG::TYPE TYPE;\n-  typedef ResizeableHashTable<TYPE, TYPE, CONFIG::alloc_type(), CONFIG::memory_tag(), CONFIG::hash, CONFIG::cmp> HashMap;\n-\n-  constexpr static bool is_cheap() {\n-    return CONFIG::alloc_type() == AnyObj::C_HEAP;\n+class JfrSetStorage : public AnyObj {\n+  typedef typename CONFIG::KEY_TYPE K;\n+ protected:\n+  K* _table;\n+  unsigned _table_size;\n+  unsigned _elements;\n+\n+  static K* alloc_table(unsigned table_size) {\n+    K* table;\n+    if (CONFIG::alloc_type() == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(K, table_size, CONFIG::memory_tag());\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(K, table_size);\n+    }\n+    memset(table, 0, table_size * sizeof(K));\n+    return table;\n@@ -69,2 +74,4 @@\n-  JfrSet(unsigned int initial_size, unsigned int max_size = MAX_TABLE_SIZE) :\n-    _map(is_cheap() ? new (CONFIG::memory_tag()) HashMap(initial_size, max_size) : new HashMap(initial_size, max_size)) {}\n+  JfrSetStorage(unsigned table_size) :\n+    _table(alloc_table(table_size)),\n+    _table_size(table_size),\n+    _elements(0) {}\n@@ -72,3 +79,3 @@\n-  ~JfrSet() {\n-    if (is_cheap()) {\n-      delete _map;\n+  ~JfrSetStorage() {\n+    if (CONFIG::alloc_type() == C_HEAP) {\n+      FREE_C_HEAP_ARRAY(K, _table);\n@@ -78,4 +85,10 @@\n-  bool add(const TYPE& k) {\n-    bool inserted;\n-    _map->put_if_absent(k, &inserted);\n-    return inserted;\n+ public:\n+  template <typename Functor>\n+  void iterate(Functor& functor) {\n+    assert(is_nonempty(), \"invariant\");\n+    for (unsigned i = 0; i < _table_size; ++i) {\n+      K k = _table[i];\n+      if (k != 0) {\n+        functor(k);\n+      }\n+    }\n@@ -84,2 +97,2 @@\n-  bool remove(const TYPE& k) {\n-    return _map->remove(k);\n+  unsigned table_size() const {\n+    return _table_size;\n@@ -88,2 +101,2 @@\n-  bool contains(const TYPE& k) const {\n-    return _map->contains(k);\n+  unsigned size() const {\n+    return _elements;\n@@ -92,2 +105,2 @@\n-  bool is_empty() const {\n-    return _map->number_of_entries() == 0;\n+  bool is_nonempty() const {\n+    return _elements > 0;\n@@ -96,2 +109,2 @@\n-  bool is_nonempty() const {\n-    return !is_empty();\n+  void clear() {\n+    memset(_table, 0, _table_size * sizeof(K));\n@@ -99,0 +112,1 @@\n+};\n@@ -100,2 +114,11 @@\n-  int size() const {\n-    return _map->number_of_entries();\n+template <typename CONFIG>\n+class JfrSet : public JfrSetStorage<CONFIG> {\n+  typedef typename CONFIG::KEY_TYPE K;\n+  static_assert(sizeof(K) > 1, \"invalid size of CONFIG::KEY_TYPE\");\n+ private:\n+  static const constexpr unsigned max_initial_size = 1 << 30;\n+  unsigned _table_mask;\n+  unsigned _resize_threshold; \/\/ 0.5 load factor\n+\n+  uint32_t slot_idx(const uint32_t hash) const {\n+    return hash & _table_mask;\n@@ -104,3 +127,23 @@\n-  void clear() {\n-    if (is_nonempty()) {\n-      _map->unlink(this);\n+  void resize() {\n+    assert(this->_elements == _resize_threshold, \"invariant\");\n+    K* const old_table = this->_table;\n+    assert(old_table != nullptr, \"invariant\");\n+    const unsigned old_table_size = this->table_size();\n+    guarantee(old_table_size <= max_initial_size, \"overflow\");\n+    this->_table_size = old_table_size << 1;\n+    this->_table = JfrSetStorage<CONFIG>::alloc_table(this->_table_size);\n+    _table_mask = this->_table_size - 1;\n+    _resize_threshold = old_table_size;\n+    for (unsigned i = 0; i < old_table_size; ++i) {\n+      const K k = old_table[i];\n+      if (k != 0) {\n+        uint32_t idx = slot_idx(CONFIG::hash(k));\n+        do {\n+          K v = this->_table[idx];\n+          if (v == 0) {\n+            this->_table[idx] = k;\n+            break;\n+          }\n+          idx = slot_idx(idx + 1);\n+        } while (true);\n+      }\n@@ -108,1 +151,5 @@\n-    assert(is_empty(), \"invariant\");\n+    if (CONFIG::alloc_type() == AnyObj::C_HEAP) {\n+      FREE_C_HEAP_ARRAY(K, old_table);\n+    }\n+    assert(_table_mask + 1 == this->_table_size, \"invariant\");\n+    assert(_resize_threshold << 1 == this->_table_size, \"invariant\");\n@@ -111,3 +158,18 @@\n-  \/\/ Callback for node deletion, used by clear().\n-  bool do_entry(const TYPE& k, const TYPE& v) {\n-    return true;\n+  K* find_slot(K const& k) const {\n+    uint32_t idx = slot_idx(CONFIG::hash(k));\n+    assert(idx < this->table_size(), \"invariant\");\n+    K* result = nullptr;\n+    while (true) {\n+      K v = this->_table[idx];\n+      if (v == 0) {\n+        result = &this->_table[idx];\n+        break;\n+      }\n+      if (CONFIG::cmp(v, k)) {\n+        result = reinterpret_cast<K*>(p2i(&this->_table[idx]) | 1);\n+        break;\n+      }\n+      idx = slot_idx(idx + 1);\n+    }\n+    assert(result != nullptr, \"invariant\");\n+    return result;\n@@ -116,2 +178,29 @@\n- private:\n-  HashMap* _map;\n+ public:\n+  JfrSet(unsigned size) :\n+    JfrSetStorage<CONFIG>(size),\n+    _table_mask(size - 1),\n+    _resize_threshold(size >> 1) {\n+    assert(size >= 2, \"invariant\");\n+    assert(size % 2 == 0, \"invariant\");\n+    assert(size <= max_initial_size, \"avoid overflow in resize\");\n+  }\n+\n+  bool contains(K const& k) const {\n+    K* const slot = find_slot(k);\n+    return p2i(slot) & 1;\n+  }\n+\n+  bool add(K const& k) {\n+    K* const slot = find_slot(k);\n+    if (p2i(slot) & 1) {\n+      \/\/ Already exists.\n+      return false;\n+    }\n+    assert(*slot == 0, \"invariant\");\n+    *slot = k;\n+    if (++this->_elements == _resize_threshold) {\n+      resize();\n+    }\n+    assert(this->_elements < _resize_threshold, \"invariant\");\n+    return true;\n+  }\n@@ -120,2 +209,2 @@\n-typedef JfrSet<ConfigTraceID<> > JfrCHeapTraceIdSet;\n-typedef JfrSet<ConfigTraceID<ResourceObj, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n+typedef JfrSet<JfrSetConfig<traceid> > JfrCHeapTraceIdSet;\n+typedef JfrSet<JfrSetConfig<traceid, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSet.hpp","additions":138,"deletions":49,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -146,2 +146,0 @@\n-        Asserts.assertGT((long) re.getValue(\"elements\"), 0L, \"No elements\");\n-        Asserts.assertGT((long) re.getValue(\"size\"), 0L, \"Empty size\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFlush.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}