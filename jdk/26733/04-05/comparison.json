{"files":[{"patch":"@@ -358,1 +358,1 @@\n-  int _count;\n+  unsigned _count;\n@@ -364,1 +364,1 @@\n-  int count() const { return _count; }\n+  unsigned count() const { return _count; }\n@@ -376,0 +376,1 @@\n+  assert(_stacktrace_id_set->is_nonempty(), \"invariant\");\n@@ -378,4 +379,0 @@\n-\n-  \/\/ save context\n-  const JfrCheckpointContext ctx = writer.context();\n-\n@@ -383,2 +380,1 @@\n-  const int64_t count_offset = writer.reserve(sizeof(u4)); \/\/ Don't know how many yet\n-\n+  writer.write_count(_stacktrace_id_set->size());\n@@ -387,7 +383,1 @@\n-\n-  if (lpstw.count() == 0) {\n-    writer.set_context(ctx);\n-    return;\n-  }\n-\n-  writer.write_count(lpstw.count(), count_offset);\n+  assert(lpstw.count() == _stacktrace_id_set->size(), \"invariant\");\n@@ -477,1 +467,3 @@\n-    write_stacktraces(thread);\n+    if (_stacktrace_id_set->is_nonempty()) {\n+      write_stacktraces(thread);\n+    }\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -609,0 +609,1 @@\n+  assert(!_artifacts->has_klass_entries(), \"invariant\");\n@@ -632,0 +633,1 @@\n+  assert(!_artifacts->has_klass_entries(), \"invariant\");\n@@ -1283,0 +1285,1 @@\n+  assert(!_artifacts->has_klass_entries(), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -102,0 +102,3 @@\n+bool JfrArtifactSet::has_klass_entries() const {\n+  return _klass_set->is_nonempty();\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -268,1 +268,3 @@\n-    set->iterate(functor);\n+    if (set->is_nonempty()) {\n+      set->iterate(functor);\n+    }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  unsigned _elements;\n@@ -75,1 +76,2 @@\n-    _table_size(table_size) {}\n+    _table_size(table_size),\n+    _elements(0) {}\n@@ -83,4 +85,0 @@\n-  K* table() const {\n-    return _table;\n-  }\n-\n@@ -90,0 +88,1 @@\n+    assert(is_nonempty(), \"invariant\");\n@@ -102,0 +101,8 @@\n+  unsigned size() const {\n+    return _elements;\n+  }\n+\n+  bool is_nonempty() const {\n+    return _elements > 0;\n+  }\n+\n@@ -113,1 +120,2 @@\n-  const unsigned _max_probe_sequence;\n+  unsigned _table_mask;\n+  unsigned _resize_threshold; \/\/ 0.5 load factor\n@@ -116,1 +124,1 @@\n-    return hash & (this->table_size() - 1);\n+    return hash & _table_mask;\n@@ -120,2 +128,2 @@\n-   begin:\n-    K* const old_table = this->table();\n+    assert(this->_elements == _resize_threshold, \"invariant\");\n+    K* const old_table = this->_table;\n@@ -125,2 +133,4 @@\n-    this->_table_size = old_table_size * 2;\n-    this->_table = this->alloc_table(this->_table_size);\n+    this->_table_size = old_table_size << 1;\n+    this->_table = JfrSetStorage<CONFIG>::alloc_table(this->_table_size);\n+    _table_mask = this->_table_size - 1;\n+    _resize_threshold = old_table_size;\n@@ -131,1 +141,0 @@\n-        unsigned probe_sequence = 0;\n@@ -136,1 +145,1 @@\n-            goto continue_for_loop;\n+            break;\n@@ -139,6 +148,1 @@\n-        } while (++probe_sequence < _max_probe_sequence);\n-        memcpy(this->_table, old_table, old_table_size * sizeof(K));\n-        if (CONFIG::alloc_type() == AnyObj::C_HEAP) {\n-          FREE_C_HEAP_ARRAY(K, old_table);\n-        }\n-        goto begin;\n+        } while (true);\n@@ -146,1 +150,0 @@\n-      continue_for_loop:;\n@@ -148,1 +151,0 @@\n-\n@@ -152,0 +154,2 @@\n+    assert(_table_mask + 1 == this->_table_size, \"invariant\");\n+    assert(_resize_threshold << 1 == this->_table_size, \"invariant\");\n@@ -157,2 +161,2 @@\n-    unsigned probe_sequence = 0;\n-    do {\n+    K* result = nullptr;\n+    while (true) {\n@@ -161,1 +165,2 @@\n-        return &this->_table[idx];\n+        result = &this->_table[idx];\n+        break;\n@@ -164,1 +169,2 @@\n-        return reinterpret_cast<K*>(p2i(&this->_table[idx]) | 1);\n+        result = reinterpret_cast<K*>(p2i(&this->_table[idx]) | 1);\n+        break;\n@@ -167,2 +173,3 @@\n-    } while (++probe_sequence < _max_probe_sequence);\n-    return nullptr; \/\/ Will trigger resize.\n+    }\n+    assert(result != nullptr, \"invariant\");\n+    return result;\n@@ -172,1 +179,1 @@\n-  JfrSet(unsigned size, unsigned max_probe_sequence = 8) :\n+  JfrSet(unsigned size) :\n@@ -174,1 +181,3 @@\n-    _max_probe_sequence(max_probe_sequence) {\n+    _table_mask(size - 1),\n+    _resize_threshold(size >> 1) {\n+    assert(size >= 2, \"invariant\");\n@@ -181,1 +190,1 @@\n-    return slot != nullptr && (p2i(slot) & 1);\n+    return p2i(slot) & 1;\n@@ -186,8 +195,8 @@\n-    if (slot != nullptr) {\n-      if (p2i(slot) & 1) {\n-        \/\/ Already exists.\n-        return false;\n-      }\n-      assert(*slot == 0, \"invariant\");\n-      *slot = k;\n-      return true;\n+    if (p2i(slot) & 1) {\n+      \/\/ Already exists.\n+      return false;\n+    }\n+    assert(*slot == 0, \"invariant\");\n+    *slot = k;\n+    if (++this->_elements == _resize_threshold) {\n+      resize();\n@@ -195,2 +204,2 @@\n-    resize();\n-    return add(k);\n+    assert(this->_elements < _resize_threshold, \"invariant\");\n+    return true;\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSet.hpp","additions":49,"deletions":40,"binary":false,"changes":89,"status":"modified"}]}