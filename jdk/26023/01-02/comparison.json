{"files":[{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include \"compilerThreadTimeout_linux.hpp\"\n+#include \"signals_posix.hpp\"\n+\n+#include <pthread.h>\n+\n+#ifndef PRODUCT\n+void compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n+  CompilerThread::current()->timeout()->compiler_signal_handler(signo, info, context);\n+}\n+\n+void CompilerThreadTimeoutLinux::compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n+  switch (signo) {\n+    case TIMEOUT_SIGNAL: {\n+      assert(!_timeout_armed, \"compile task timed out\");\n+    }\n+    default: {\n+      assert(false, \"unexpected signal %d\", signo);\n+    }\n+  }\n+}\n+\n+void CompilerThreadTimeoutLinux::arm() {\n+  if (CompileTaskTimeout == 0) {\n+    return;\n+  }\n+\n+  const intx sec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) \/ NANOSECS_PER_SEC;\n+  const intx nsec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) % NANOSECS_PER_SEC;\n+  const struct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\n+  const struct itimerspec its {.it_interval = ts, .it_value = ts};\n+\n+  \/\/ Start the timer.\n+  timer_settime(_timeout_timer, 0, &its, nullptr);\n+  _timeout_armed = true;\n+}\n+\n+void CompilerThreadTimeoutLinux::disarm() {\n+  if (CompileTaskTimeout == 0) {\n+    return;\n+  }\n+\n+  _timeout_armed = false;\n+\n+  \/\/ Reset the timer by setting it to zero.\n+  const struct itimerspec its {\n+    .it_interval = {.tv_sec = 0, .tv_nsec=0},\n+    .it_value = {.tv_sec = 0, .tv_nsec=0}\n+  };\n+  timer_settime(_timeout_timer, 0, &its, nullptr);\n+}\n+\n+bool CompilerThreadTimeoutLinux::init_timeout() {\n+  if (CompileTaskTimeout == 0) {\n+    return true;\n+  }\n+\n+  JavaThread* thread = JavaThread::current();\n+\n+  \/\/ Create a POSIX timer sending SIGALRM to this thread only.\n+  sigevent_t sev;\n+  sev.sigev_value.sival_ptr = nullptr;\n+  sev.sigev_signo = TIMEOUT_SIGNAL;\n+  sev.sigev_notify = SIGEV_THREAD_ID;\n+  #ifdef MUSL_LIBC\n+  sev.sigev_notify_thread_id = thread->osthread()->thread_id();\n+  #else\n+  sev._sigev_un._tid = thread->osthread()->thread_id();\n+  #endif \/\/ MUSL_LIBC\n+  clockid_t clock;\n+  int err = pthread_getcpuclockid(thread->osthread()->pthread_id(), &clock);\n+  if (err != 0) {\n+    return false;\n+  }\n+  err = timer_create(clock, &sev, &_timeout_timer);\n+  if (err != 0) {\n+    return false;\n+  }\n+\n+  \/\/ Install the signal handler and check that we do not have a conflicting handler.\n+  struct sigaction sigact, sigact_old;\n+  err = PosixSignals::install_sigaction_signal_handler(&sigact,\n+                                                       &sigact_old,\n+                                                       TIMEOUT_SIGNAL,\n+                                                       (sa_sigaction_t)::compiler_signal_handler);\n+  if (err != 0 || (sigact_old.sa_sigaction != sigact.sa_sigaction &&\n+      sigact_old.sa_handler != SIG_DFL && sigact_old.sa_handler != SIG_IGN)) {\n+    return false;\n+  }\n+  return true;\n+}\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/os\/linux\/compilerThreadTimeout_linux.cpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n+#define LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <csignal>\n+#include <ctime>\n+\n+class CompilerThreadTimeoutLinux : public CHeapObj<mtCompiler> {\n+#ifndef PRODUCT\n+ public:\n+  static const int TIMEOUT_SIGNAL = SIGALRM;\n+  void compiler_signal_handler(int signo, siginfo_t* info, void* context);\n+ private:\n+  timer_t          _timeout_timer;\n+  volatile bool    _timeout_armed;\n+#endif \/\/ !PRODUCT\n+ public:\n+  CompilerThreadTimeoutLinux() NOT_PRODUCT(: _timeout_timer(nullptr)COMMA\n+                                             _timeout_armed(false)) {};\n+\n+  bool init_timeout() PRODUCT_RETURN_(return true;);\n+  void arm()          PRODUCT_RETURN;\n+  void disarm()       PRODUCT_RETURN;\n+};\n+\n+#endif \/\/LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/compilerThreadTimeout_linux.hpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -221,1 +221,1 @@\n-  thread->timeout_arm();\n+  thread->timeout()->arm();\n@@ -232,0 +232,1 @@\n+  thread->timeout()->disarm();\n@@ -236,1 +237,0 @@\n-      thread->timeout_disarm();\n@@ -258,1 +258,0 @@\n-    thread->timeout_disarm();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/globals.hpp\"\n@@ -31,12 +29,0 @@\n-#include \"runtime\/osThread.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#ifndef PRODUCT\n-#ifdef LINUX\n-#include \"signals_posix.hpp\"\n-\n-#include <csignal>\n-#include <ctime>\n-#include <pthread.h>\n-#endif \/\/ LINUX\n-#endif \/\/ !PRODUCT\n@@ -57,0 +43,1 @@\n+  _timeout = nullptr;\n@@ -66,0 +53,1 @@\n+  delete _timeout;\n@@ -88,87 +76,0 @@\n-\n-#ifndef PRODUCT\n-#ifdef LINUX\n-  void compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n-    CompilerThread::current()->compiler_signal_handler(signo, info, context);\n-  }\n-  void CompilerThread::compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n-    switch (signo) {\n-      case TIMEOUT_SIGNAL: {\n-        assert(!Atomic::load_acquire(&_timeout_armed), \"compile task timed out\");\n-      }\n-      default: {\n-        assert(false, \"unexpected signal %d\", signo);\n-      }\n-    }\n-  }\n-\n-  bool CompilerThread::init_compilation_timeout() {\n-    _timeout_armed = false;\n-    if (CompileTaskTimeout == 0) {\n-      return true;\n-    }\n-\n-    JavaThread* thread = JavaThread::current();\n-\n-    \/\/ Create a POSIX timer sending SIGALRM to this thread only.\n-    sigevent_t sev;\n-    sev.sigev_value.sival_ptr = nullptr;\n-    sev.sigev_signo = TIMEOUT_SIGNAL;\n-    sev.sigev_notify = SIGEV_THREAD_ID;\n-    #ifdef MUSL_LIBC\n-    sev.sigev_notify_thread_id = thread->osthread()->thread_id();\n-    #else\n-    sev._sigev_un._tid = thread->osthread()->thread_id();\n-    #endif \/\/ MUSL_LIBC\n-    clockid_t clock;\n-    int err = pthread_getcpuclockid(thread->osthread()->pthread_id(), &clock);\n-    if (err != 0) {\n-      return false;\n-    }\n-    err = timer_create(clock, &sev, &_timeout_timer);\n-    if (err != 0) {\n-      return false;\n-    }\n-\n-    \/\/ Install the signal handler and check that we do not have a conflicting handler.\n-    struct sigaction sigact, sigact_old;\n-    err = PosixSignals::install_sigaction_signal_handler(&sigact,\n-                                                         &sigact_old,\n-                                                         TIMEOUT_SIGNAL,\n-                                                         (sa_sigaction_t)::compiler_signal_handler);\n-    if (err != 0 || (sigact_old.sa_sigaction != sigact.sa_sigaction &&\n-        sigact_old.sa_handler != SIG_DFL && sigact_old.sa_handler != SIG_IGN)) {\n-      return false;\n-    }\n-    return true;\n-  }\n-  void CompilerThread::timeout_arm() {\n-    if (CompileTaskTimeout == 0) {\n-      return;\n-    }\n-\n-    const intx sec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) \/ NANOSECS_PER_SEC;\n-    const intx nsec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) % NANOSECS_PER_SEC;\n-    const struct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\n-    const struct itimerspec its {.it_interval = ts, .it_value = ts};\n-\n-    \/\/ Start the timer.\n-    timer_settime(_timeout_timer, 0, &its, nullptr);\n-    Atomic::release_store(&_timeout_armed, (bool) true);\n-  }\n-  void CompilerThread::timeout_disarm() {\n-    if (CompileTaskTimeout == 0) {\n-      return;\n-    }\n-\n-    Atomic::release_store(&_timeout_armed, (bool)false);\n-\n-    \/\/ Reset the timer by setting it to zero.\n-    const struct itimerspec its {\n-      .it_interval = {.tv_sec = 0, .tv_nsec=0},\n-      .it_value = {.tv_sec = 0, .tv_nsec=0}\n-    };\n-    timer_settime(_timeout_timer, 0, &its, nullptr);\n-  }\n-#endif \/\/ LINUX\n-#endif \/\/ \/!PRODUCT\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":2,"deletions":101,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -31,1 +33,0 @@\n-#ifndef PRODUCT\n@@ -33,1 +34,1 @@\n-#include <csignal>\n+#include \"compilerThreadTimeout_linux.hpp\"\n@@ -35,1 +36,0 @@\n-#endif \/\/!PRODUCT\n@@ -48,0 +48,8 @@\n+class CompilerThreadTimeoutGeneric : public CHeapObj<mtCompiler> {\n+ public:\n+  CompilerThreadTimeoutGeneric() {};\n+  void arm() { return; };\n+  void disarm() { return; };\n+  bool init_timeout() { return true; };\n+};\n+\n@@ -52,0 +60,7 @@\n+\n+#ifdef LINUX\n+  typedef CompilerThreadTimeoutLinux Timeout;\n+#else \/\/ LINUX\n+  typedef CompilerThreadTimeoutGeneric Timeout;\n+#endif \/\/ LINUX\n+\n@@ -67,0 +82,1 @@\n+  Timeout*              _timeout;\n@@ -125,17 +141,5 @@\n-#ifdef LINUX\n-#ifndef PRODUCT\n- private:\n-  static const int TIMEOUT_SIGNAL = SIGALRM;\n-  timer_t               _timeout_timer;\n-  volatile bool         _timeout_armed;\n- public:\n-  void compiler_signal_handler(int signo, siginfo_t* info, void* context);\n-#endif \/\/ !PRODUCT\n-  bool init_compilation_timeout() PRODUCT_RETURN_(return true;);\n-  void timeout_arm() PRODUCT_RETURN;\n-  void timeout_disarm() PRODUCT_RETURN;\n-#else\n-  bool init_compilation_timeout() { return true; };\n-  void timeout_arm() {};\n-  void timeout_disarm() {};\n-#endif \/\/ LINUX\n+  Timeout* timeout() const { return _timeout; };\n+  bool init_compilation_timeout() {\n+    _timeout = new Timeout();\n+    return _timeout->init_timeout();\n+  };\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"}]}