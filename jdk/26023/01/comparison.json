{"files":[{"patch":"@@ -92,0 +92,5 @@\n+  develop(intx, CompileTaskTimeout, 0,                                  \\\n+          \"Set the timeout for compile tasks' CPU time in milliseconds.\"\\\n+          \"0 = no timeout (default)\")                                   \\\n+          range(0,1000000)                                              \\\n+                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+  thread->timeout_arm();\n@@ -235,0 +236,1 @@\n+      thread->timeout_disarm();\n@@ -256,0 +258,1 @@\n+    thread->timeout_disarm();\n@@ -1918,0 +1921,4 @@\n+  if (!thread->init_compilation_timeout()) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/globals.hpp\"\n@@ -29,0 +31,12 @@\n+#include \"runtime\/osThread.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#ifndef PRODUCT\n+#ifdef LINUX\n+#include \"signals_posix.hpp\"\n+\n+#include <csignal>\n+#include <ctime>\n+#include <pthread.h>\n+#endif \/\/ LINUX\n+#endif \/\/ !PRODUCT\n@@ -74,0 +88,87 @@\n+\n+#ifndef PRODUCT\n+#ifdef LINUX\n+  void compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n+    CompilerThread::current()->compiler_signal_handler(signo, info, context);\n+  }\n+  void CompilerThread::compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n+    switch (signo) {\n+      case TIMEOUT_SIGNAL: {\n+        assert(!Atomic::load_acquire(&_timeout_armed), \"compile task timed out\");\n+      }\n+      default: {\n+        assert(false, \"unexpected signal %d\", signo);\n+      }\n+    }\n+  }\n+\n+  bool CompilerThread::init_compilation_timeout() {\n+    _timeout_armed = false;\n+    if (CompileTaskTimeout == 0) {\n+      return true;\n+    }\n+\n+    JavaThread* thread = JavaThread::current();\n+\n+    \/\/ Create a POSIX timer sending SIGALRM to this thread only.\n+    sigevent_t sev;\n+    sev.sigev_value.sival_ptr = nullptr;\n+    sev.sigev_signo = TIMEOUT_SIGNAL;\n+    sev.sigev_notify = SIGEV_THREAD_ID;\n+    #ifdef MUSL_LIBC\n+    sev.sigev_notify_thread_id = thread->osthread()->thread_id();\n+    #else\n+    sev._sigev_un._tid = thread->osthread()->thread_id();\n+    #endif \/\/ MUSL_LIBC\n+    clockid_t clock;\n+    int err = pthread_getcpuclockid(thread->osthread()->pthread_id(), &clock);\n+    if (err != 0) {\n+      return false;\n+    }\n+    err = timer_create(clock, &sev, &_timeout_timer);\n+    if (err != 0) {\n+      return false;\n+    }\n+\n+    \/\/ Install the signal handler and check that we do not have a conflicting handler.\n+    struct sigaction sigact, sigact_old;\n+    err = PosixSignals::install_sigaction_signal_handler(&sigact,\n+                                                         &sigact_old,\n+                                                         TIMEOUT_SIGNAL,\n+                                                         (sa_sigaction_t)::compiler_signal_handler);\n+    if (err != 0 || (sigact_old.sa_sigaction != sigact.sa_sigaction &&\n+        sigact_old.sa_handler != SIG_DFL && sigact_old.sa_handler != SIG_IGN)) {\n+      return false;\n+    }\n+    return true;\n+  }\n+  void CompilerThread::timeout_arm() {\n+    if (CompileTaskTimeout == 0) {\n+      return;\n+    }\n+\n+    const intx sec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) \/ NANOSECS_PER_SEC;\n+    const intx nsec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) % NANOSECS_PER_SEC;\n+    const struct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\n+    const struct itimerspec its {.it_interval = ts, .it_value = ts};\n+\n+    \/\/ Start the timer.\n+    timer_settime(_timeout_timer, 0, &its, nullptr);\n+    Atomic::release_store(&_timeout_armed, (bool) true);\n+  }\n+  void CompilerThread::timeout_disarm() {\n+    if (CompileTaskTimeout == 0) {\n+      return;\n+    }\n+\n+    Atomic::release_store(&_timeout_armed, (bool)false);\n+\n+    \/\/ Reset the timer by setting it to zero.\n+    const struct itimerspec its {\n+      .it_interval = {.tv_sec = 0, .tv_nsec=0},\n+      .it_value = {.tv_sec = 0, .tv_nsec=0}\n+    };\n+    timer_settime(_timeout_timer, 0, &its, nullptr);\n+  }\n+#endif \/\/ LINUX\n+#endif \/\/ \/!PRODUCT\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -29,0 +29,7 @@\n+#include \"utilities\/macros.hpp\"\n+\n+#ifndef PRODUCT\n+#ifdef LINUX\n+#include <csignal>\n+#endif \/\/LINUX\n+#endif \/\/!PRODUCT\n@@ -116,1 +123,19 @@\n-#endif\n+#endif \/\/ !PRODUCT\n+\n+#ifdef LINUX\n+#ifndef PRODUCT\n+ private:\n+  static const int TIMEOUT_SIGNAL = SIGALRM;\n+  timer_t               _timeout_timer;\n+  volatile bool         _timeout_armed;\n+ public:\n+  void compiler_signal_handler(int signo, siginfo_t* info, void* context);\n+#endif \/\/ !PRODUCT\n+  bool init_compilation_timeout() PRODUCT_RETURN_(return true;);\n+  void timeout_arm() PRODUCT_RETURN;\n+  void timeout_disarm() PRODUCT_RETURN;\n+#else\n+  bool init_compilation_timeout() { return true; };\n+  void timeout_arm() {};\n+  void timeout_disarm() {};\n+#endif \/\/ LINUX\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires os.family != \"windows\" & os.family != \"aix\"\n+ * @requires os.family != \"windows\" & os.family != \"aix\" & vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/signal\/TestSigalrm.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}