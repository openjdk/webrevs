{"files":[{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include \"compilerThreadTimeout_linux.hpp\"\n+#include \"signals_posix.hpp\"\n+\n+#include <pthread.h>\n+\n+#ifndef PRODUCT\n+#ifdef ASSERT\n+void compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n+  CompilerThread::current()->timeout()->compiler_signal_handler(signo, info, context);\n+}\n+\n+void CompilerThreadTimeoutLinux::compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n+  switch (signo) {\n+    case TIMEOUT_SIGNAL: {\n+      assert(!_timeout_armed, \"compile task timed out\");\n+    }\n+    default: {\n+      assert(false, \"unexpected signal %d\", signo);\n+    }\n+  }\n+}\n+#endif \/\/ ASSERT\n+#endif \/\/ !PRODUCT\n+\n+void CompilerThreadTimeoutLinux::arm() {\n+#ifdef ASSERT\n+  if (CompileTaskTimeout == 0) {\n+    return;\n+  }\n+\n+  const intx sec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) \/ NANOSECS_PER_SEC;\n+  const intx nsec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) % NANOSECS_PER_SEC;\n+  const struct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\n+  const struct itimerspec its {.it_interval = ts, .it_value = ts};\n+\n+  \/\/ Start the timer.\n+  timer_settime(_timeout_timer, 0, &its, nullptr);\n+  _timeout_armed = true;\n+#endif \/\/ ASSERT\n+}\n+\n+void CompilerThreadTimeoutLinux::disarm() {\n+#ifdef ASSERT\n+  if (CompileTaskTimeout == 0) {\n+    return;\n+  }\n+\n+  _timeout_armed = false;\n+\n+  \/\/ Reset the timer by setting it to zero.\n+  const struct itimerspec its {\n+    .it_interval = {.tv_sec = 0, .tv_nsec=0},\n+    .it_value = {.tv_sec = 0, .tv_nsec=0}\n+  };\n+  timer_settime(_timeout_timer, 0, &its, nullptr);\n+#endif \/\/ ASSERT\n+}\n+\n+bool CompilerThreadTimeoutLinux::init_timeout() {\n+#ifdef ASSERT\n+  if (CompileTaskTimeout == 0) {\n+    return true;\n+  }\n+\n+  JavaThread* thread = JavaThread::current();\n+\n+  \/\/ Create a POSIX timer sending SIGALRM to this thread only.\n+  sigevent_t sev;\n+  sev.sigev_value.sival_ptr = nullptr;\n+  sev.sigev_signo = TIMEOUT_SIGNAL;\n+  sev.sigev_notify = SIGEV_THREAD_ID;\n+  #ifdef MUSL_LIBC\n+  sev.sigev_notify_thread_id = thread->osthread()->thread_id();\n+  #else\n+  sev._sigev_un._tid = thread->osthread()->thread_id();\n+  #endif \/\/ MUSL_LIBC\n+  clockid_t clock;\n+  int err = pthread_getcpuclockid(thread->osthread()->pthread_id(), &clock);\n+  if (err != 0) {\n+    return false;\n+  }\n+  err = timer_create(clock, &sev, &_timeout_timer);\n+  if (err != 0) {\n+    return false;\n+  }\n+\n+  \/\/ Install the signal handler and check that we do not have a conflicting handler.\n+  struct sigaction sigact, sigact_old;\n+  err = PosixSignals::install_sigaction_signal_handler(&sigact,\n+                                                       &sigact_old,\n+                                                       TIMEOUT_SIGNAL,\n+                                                       (sa_sigaction_t)::compiler_signal_handler);\n+  if (err != 0 || (sigact_old.sa_sigaction != sigact.sa_sigaction &&\n+      sigact_old.sa_handler != SIG_DFL && sigact_old.sa_handler != SIG_IGN)) {\n+    return false;\n+  }\n+#endif \/\/ ASSERT\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/linux\/compilerThreadTimeout_linux.cpp","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n+#define LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <csignal>\n+#include <ctime>\n+\n+class CompilerThreadTimeoutLinux : public CHeapObj<mtCompiler> {\n+#ifndef PRODUCT\n+#ifdef ASSERT\n+ public:\n+  static const int TIMEOUT_SIGNAL = SIGALRM;\n+  void compiler_signal_handler(int signo, siginfo_t* info, void* context);\n+ private:\n+  timer_t          _timeout_timer;\n+  volatile bool    _timeout_armed;\n+#endif \/\/ ASSERT\n+#endif \/\/ !PRODUCT\n+ public:\n+  CompilerThreadTimeoutLinux() NOT_PRODUCT(DEBUG_ONLY(:\n+    _timeout_timer(nullptr)COMMA\n+    _timeout_armed(false))) {};\n+\n+  bool init_timeout();\n+  void arm();\n+  void disarm();\n+};\n+\n+#endif \/\/LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/compilerThreadTimeout_linux.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -92,0 +92,5 @@\n+  develop(intx, CompileTaskTimeout, 0,                                  \\\n+          \"Set the timeout for compile tasks' CPU time in milliseconds.\"\\\n+          \"0 = no timeout (default)\")                                   \\\n+          range(0,1000000)                                              \\\n+                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+  thread->timeout()->arm();\n@@ -231,0 +232,1 @@\n+  thread->timeout()->disarm();\n@@ -1920,0 +1922,4 @@\n+  if (!thread->init_compilation_timeout()) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  _timeout = nullptr;\n@@ -52,0 +53,1 @@\n+  delete _timeout;\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -29,0 +31,5 @@\n+#include \"utilities\/macros.hpp\"\n+\n+#ifdef LINUX\n+#include \"compilerThreadTimeout_linux.hpp\"\n+#endif \/\/LINUX\n@@ -41,0 +48,8 @@\n+class CompilerThreadTimeoutGeneric : public CHeapObj<mtCompiler> {\n+ public:\n+  CompilerThreadTimeoutGeneric() {};\n+  void arm() { return; };\n+  void disarm() { return; };\n+  bool init_timeout() { return true; };\n+};\n+\n@@ -45,0 +60,7 @@\n+\n+#ifdef LINUX\n+  typedef CompilerThreadTimeoutLinux Timeout;\n+#else \/\/ LINUX\n+  typedef CompilerThreadTimeoutGeneric Timeout;\n+#endif \/\/ LINUX\n+\n@@ -60,0 +82,1 @@\n+  Timeout*              _timeout;\n@@ -116,1 +139,7 @@\n-#endif\n+#endif \/\/ !PRODUCT\n+\n+  Timeout* timeout() const { return _timeout; };\n+  bool init_compilation_timeout() {\n+    _timeout = new Timeout();\n+    return _timeout->init_timeout();\n+  };\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires os.family != \"windows\" & os.family != \"aix\"\n+ * @requires os.family != \"windows\" & os.family != \"aix\" & vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/signal\/TestSigalrm.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}