{"files":[{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.verify;\n+\n+import java.util.Optional;\n+import java.lang.foreign.*;\n+\n+\/**\n+ * The Verify class provides a single Verify.checkEQ static method, which recursively compares\n+ * the two Objects by value. It deconstructs Object[], compares boxed primitive types, and\n+ * compares the content of arrays and MemorySegments.\n+ *\n+ * When a comparison fail, then methods print helpful messages, before throwing a VerifyException.\n+ *\/\n+public final class Verify {\n+    \/**\n+     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     *\/\n+    public static void checkEQ(Object a, Object b) {\n+        checkEQ(a, b, \"\");\n+    }\n+\n+    \/**\n+     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     *\/\n+    private static void checkEQ(Object a, Object b, String context) {\n+        \/\/ Both null\n+        if (a == null && b == null) {\n+            return;\n+        }\n+\n+        \/\/ Null mismatch\n+        if (a == null || b == null) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: null mismatch\");\n+            print(a, \"a \" + context);\n+            print(b, \"b \" + context);\n+            throw new VerifyException(\"Object array null mismatch.\");\n+        }\n+\n+        \/\/ Class mismatch\n+        Class ca = a.getClass();\n+        Class cb = b.getClass();\n+        if (ca != cb) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: class mismatch.\");\n+            System.err.println(\"       \" + ca.getName() + \" vs \" + cb.getName());\n+            print(a, \"a \" + context);\n+            print(b, \"b \" + context);\n+            throw new VerifyException(\"Object array class mismatch.\");\n+        }\n+\n+        switch (a) {\n+            case Object[]  x -> checkEQimpl(x, (Object[])b,                context);\n+            case Byte      x -> checkEQimpl(x, ((Byte)b).byteValue(),      context);\n+            case Character x -> checkEQimpl(x, ((Character)b).charValue(), context);\n+            case Short     x -> checkEQimpl(x, ((Short)b).shortValue(),    context);\n+            case Integer   x -> checkEQimpl(x, ((Integer)b).intValue(),    context);\n+            case Long      x -> checkEQimpl(x, ((Long)b).longValue(),      context);\n+            case Float     x -> checkEQimpl(x, ((Float)b).floatValue(),    context);\n+            case Double    x -> checkEQimpl(x, ((Double)b).doubleValue(),  context);\n+            case byte[]    x -> checkEQimpl(x, (byte[])b,                  context);\n+            case char[]    x -> checkEQimpl(x, (char[])b,                  context);\n+            case short[]   x -> checkEQimpl(x, (short[])b,                 context);\n+            case int[]     x -> checkEQimpl(x, (int[])b,                   context);\n+            case long[]    x -> checkEQimpl(x, (long[])b,                  context);\n+            case float[]   x -> checkEQimpl(x, (float[])b,                 context);\n+            case double[]  x -> checkEQimpl(x, (double[])b,                context);\n+            case MemorySegment x -> checkEQimpl(x, (MemorySegment) b,      context);\n+            default -> {\n+                System.err.println(\"ERROR: Verify.checkEQ failed: type not supported: \" + ca.getName());\n+                print(a, \"a \" + context);\n+                print(b, \"b \" + context);\n+                throw new VerifyException(\"Object array type not supported: \" + ca.getName());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two bytes are identical.\n+     *\/\n+    private static void checkEQimpl(byte a, byte b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two chars are identical.\n+     *\/\n+    private static void checkEQimpl(char a, char b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + (int)a + \" vs \" + (int)b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two shorts are identical.\n+     *\/\n+    private static void checkEQimpl(short a, short b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + (int)a + \" vs \" + (int)b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two ints are identical.\n+     *\/\n+    private static void checkEQimpl(int a, int b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two longs are identical.\n+     *\/\n+    private static void checkEQimpl(long a, long b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two floats have identical bits.\n+     *\/\n+    private static void checkEQimpl(float a, float b, String context) {\n+        if (Float.floatToRawIntBits(a) != Float.floatToRawIntBits(b)) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n+            System.err.println(\"       Values: \" + a + \" vs \" + b);\n+            System.err.println(\"       Values: \" + Float.floatToRawIntBits(a) + \" vs \" + Float.floatToRawIntBits(b));\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two doubles have identical bits.\n+     *\/\n+    private static void checkEQimpl(double a, double b, String context) {\n+        if (Double.doubleToRawLongBits(a) != Double.doubleToRawLongBits(b)) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n+            System.err.println(\"       Values: \" + a + \" vs \" + b);\n+            System.err.println(\"       Values: \" + Double.doubleToRawLongBits(a) + \" vs \" + Double.doubleToRawLongBits(b));\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that the content of two MemorySegments is identical. Note: we do not check the\n+     * backing type, only the size and content.\n+     *\/\n+    private static void checkEQimpl(MemorySegment a, MemorySegment b, String context) {\n+        long offset = a.mismatch(b);\n+        if (offset == -1) { return; }\n+\n+        \/\/ Print some general info\n+        System.err.println(\"ERROR: Verify.checkEQ failed for: \" + context);\n+\n+        printMemorySegment(a, \"a \" + context);\n+        printMemorySegment(b, \"b \" + context);\n+\n+        \/\/ (1) Mismatch on size\n+        if (a.byteSize() != b.byteSize()) {\n+            throw new VerifyException(\"MemorySegment byteSize mismatch.\");\n+        }\n+\n+        \/\/ (2) Value mismatch\n+        System.err.println(\"  Value mismatch at byte offset: \" + offset);\n+        printMemorySegmentValue(a, offset, 16);\n+        printMemorySegmentValue(b, offset, 16);\n+        throw new VerifyException(\"MemorySegment value mismatch.\");\n+    }\n+\n+    \/**\n+     * Verify that the content of two byte arrays is identical.\n+     *\/\n+    private static void checkEQimpl(byte[] a, byte[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two char arrays is identical.\n+     *\/\n+    private static void checkEQimpl(char[] a, char[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two short arrays is identical.\n+     *\/\n+    private static void checkEQimpl(short[] a, short[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two int arrays is identical.\n+     *\/\n+    private static void checkEQimpl(int[] a, int[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two long arrays is identical.\n+     *\/\n+    private static void checkEQimpl(long[] a, long[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two float arrays is identical.\n+     *\/\n+    private static void checkEQimpl(float[] a, float[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two double arrays is identical.\n+     *\/\n+    private static void checkEQimpl(double[] a, double[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two Object arrays is identical, recursively:\n+     * every element is compared with checkEQimpl for the corresponding type.\n+     *\/\n+    private static void checkEQimpl(Object[] a, Object[] b, String context) {\n+        \/\/ (1) Length mismatch\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            throw new VerifyException(\"Object array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Recursive checkEQ call.\n+            checkEQ(a[i], b[i], \"[\" + i + \"]\" + context);\n+        }\n+    }\n+\n+    private static void print(Object a, String context) {\n+        if (a == null) {\n+            System.err.println(\"  \" + context + \": null\");\n+        } else {\n+            System.err.println(\"  \" + context + \": \" + a);\n+        }\n+    }\n+\n+    private static void printMemorySegment(MemorySegment a, String context) {\n+        Optional<Object> maybeBase = a.heapBase();\n+        System.err.println(\"  \" + context + \" via MemorySegment:\");\n+        if (maybeBase.isEmpty()) {\n+            System.err.println(\"    no heap base (native).\");\n+        } else {\n+            Object base = maybeBase.get();\n+            System.err.println(\"    heap base: \" + base);\n+        }\n+        System.err.println(\"    address: \" + a.address());\n+        System.err.println(\"    byteSize: \" + a.byteSize());\n+    }\n+\n+    private static void printMemorySegmentValue(MemorySegment a, long offset, int range) {\n+        long start = Long.max(offset - range, 0);\n+        long end   = Long.min(offset + range, a.byteSize());\n+        for (long i = start; i < end; i++) {\n+            byte b = a.get(ValueLayout.JAVA_BYTE, i);\n+            System.err.print(String.format(\"%02x \", b));\n+        }\n+        System.err.println(\"\");\n+        for (long i = start; i < end; i++) {\n+            if (i == offset) {\n+                System.err.print(\"^^ \");\n+            } else {\n+                System.err.print(\"   \");\n+            }\n+        }\n+        System.err.println(\"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/Verify.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.verify;\n+\n+\/**\n+ * Exception thrown in verification.\n+ *\/\n+public class VerifyException extends RuntimeException {\n+    public VerifyException(String message) {\n+        super(\"Value verification failed:\" + System.lineSeparator() + message);\n+    }\n+\n+    public VerifyException(String message, Throwable e) {\n+        super(\"Value verification failed:\" + System.lineSeparator() + message, e);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/VerifyException.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to show Verify.checkEQ with IR framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver verify.examples.TestVerifyInCheckMethod\n+ *\/\n+\n+package verify.examples;\n+\n+import compiler.lib.verify.*;\n+import compiler.lib.ir_framework.*;\n+\n+\/**\n+ * Example to show the use of Verify.checkEQ in @Check method.\n+ *\/\n+public class TestVerifyInCheckMethod {\n+    public static int[] INPUT_A = new int[100];\n+    static {\n+        for (int i = 0; i < INPUT_A.length; i++) {\n+            INPUT_A[i] = i;\n+        }\n+    }\n+    public static float INPUT_B = 42;\n+\n+    \/\/ Must make sure to clone input arrays, if it is mutated in the test.\n+    public static Object GOLD = test(INPUT_A.clone(), INPUT_B);;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Setup\n+    public static Object[] setup() {\n+        \/\/ Must make sure to clone input arrays, if it is mutated in the test.\n+        return new Object[] {INPUT_A.clone(), INPUT_B};\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    public static Object test(int[] a, float b) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (int)(a[i] * b);\n+        }\n+        \/\/ Since we have more than one value, we wrap them in an Object[].\n+        return new Object[] {a, b};\n+    }\n+\n+    @Check(test = \"test\")\n+    public static void check(Object result) {\n+        Verify.checkEQ(result, GOLD);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/examples\/TestVerifyInCheckMethod.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,419 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test functionality of IntGenerator implementations.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver verify.tests.TestVerify\n+ *\/\n+\n+package verify.tests;\n+\n+import java.lang.foreign.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.verify.*;\n+\n+public class TestVerify {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        \/\/ Test consecutive memory: array, MemorySegment, etc.\n+        testArrayByte();\n+        testArrayChar();\n+        testArrayShort();\n+        testArrayInt();\n+        testArrayLong();\n+        testArrayFloat();\n+        testArrayDouble();\n+        testNativeMemorySegment();\n+\n+        \/\/ Test recursive data: Object array of values, etc.\n+        testRecursive();\n+    }\n+\n+    public static void testArrayByte() {\n+        byte[] a = new byte[1000];\n+        byte[] b = new byte[1001];\n+        byte[] c = new byte[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayShort() {\n+        short[] a = new short[1000];\n+        short[] b = new short[1001];\n+        short[] c = new short[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayChar() {\n+        char[] a = new char[1000];\n+        char[] b = new char[1001];\n+        char[] c = new char[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayInt() {\n+        int[] a = new int[1000];\n+        int[] b = new int[1001];\n+        int[] c = new int[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayLong() {\n+        long[] a = new long[1000];\n+        long[] b = new long[1001];\n+        long[] c = new long[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayFloat() {\n+        float[] a = new float[1000];\n+        float[] b = new float[1001];\n+        float[] c = new float[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayDouble() {\n+        double[] a = new double[1000];\n+        double[] b = new double[1001];\n+        double[] c = new double[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+    public static void testNativeMemorySegment() {\n+        MemorySegment a = Arena.ofAuto().allocate(1000, 1);\n+        MemorySegment b = Arena.ofAuto().allocate(1001, 1);\n+        MemorySegment c = Arena.ofAuto().allocate(1000, 1);\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        c.set(ValueLayout.JAVA_BYTE, RANDOM.nextLong(c.byteSize()), (byte)1);\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+    }\n+\n+    public static void testRecursive() {\n+        Verify.checkEQ(null, null);\n+\n+        \/\/ Null mismatch\n+        checkNE(42, null);\n+\n+        byte[] a = new byte[1000];\n+        int[]  b = new int[1000];\n+        int[]  c = new int[1001];\n+        int[]  d = new int[1000];\n+\n+        Object[] o1 = new Object[]{a, a};\n+        Object[] o2 = new Object[]{a, a, a};\n+        Object[] o3 = new Object[]{a, a, null};\n+        Object[] o4 = new Object[]{a, a, b};\n+        Object[] o5 = new Object[]{a, a, c};\n+        Object[] o6 = new Object[]{a, a, d};\n+\n+        Verify.checkEQ(o1, o1);\n+        Verify.checkEQ(o2, o2);\n+        Verify.checkEQ(o3, o3);\n+        Verify.checkEQ(o4, o6);\n+\n+        \/\/ Size mismatch\n+        checkNE(o1, o2);\n+\n+        \/\/ First level value mismatch: a vs null on position 2\n+        checkNE(o2, o3);\n+\n+        \/\/ First level class mismatch: byte[] vs int[]\n+        checkNE(o2, o4);\n+\n+        \/\/ Second level length mismatch on arrays b and c.\n+        checkNE(o4, o5);\n+\n+        d[RANDOM.nextInt(d.length)] = 1;\n+\n+        \/\/ Second level value mismatch between b and d.\n+        checkNE(o4, o6);\n+\n+        \/\/ Now test all primitive array types.\n+        byte[]   aB = new byte[100];\n+        char[]   aC = new char[100];\n+        short[]  aS = new short[100];\n+        int[]    aI = new int[100];\n+        long[]   aL = new long[100];\n+        float[]  aF = new float[100];\n+        double[] aD = new double[100];\n+\n+        Verify.checkEQ(new Object[] {aB, aC, aS, aI, aL, aF, aD}, new Object[] {aB, aC, aS, aI, aL, aF, aD});\n+\n+        \/\/ First level class mismatch: char[] vs short[]\n+        checkNE(new Object[] {aC}, new Object[] {aS});\n+\n+        \/\/ Verify MemorySegment\n+        MemorySegment mC = MemorySegment.ofArray(aC);\n+        MemorySegment mS = MemorySegment.ofArray(aS);\n+        Verify.checkEQ(new Object[] {mC}, new Object[] {mC});\n+        Verify.checkEQ(new Object[] {mS}, new Object[] {mS});\n+\n+        \/\/ Second level type mismatch: backing type short[] vs char[]\n+        checkNE(new Object[] {mC}, new Object[] {mS});\n+\n+        \/\/ Second level type mismatch: backing type int[] vs char[]\n+        MemorySegment mI = MemorySegment.ofArray(aI);\n+        checkNE(new Object[] {mI}, new Object[] {mC});\n+\n+        \/\/ Verify boxed primitives:\n+        Byte bb1 = 42;\n+        Byte bb2 = 42;\n+        Byte bb3 = 11;\n+\n+        Verify.checkEQ(new Object[] {(byte)42}, new Object[] {(byte)42});\n+        Verify.checkEQ(new Object[] {(byte)42}, new Object[] {bb1});\n+        Verify.checkEQ(new Object[] {bb1},      new Object[] {bb2});\n+\n+        \/\/ Second level value mismatch: 42 vs 11\n+        checkNE(new Object[] {bb1},      new Object[] {bb3});\n+\n+        Verify.checkEQ((byte)42,   (byte)42);\n+        Verify.checkEQ((short)42,  (short)42);\n+        Verify.checkEQ((char)42,   (char)42);\n+        Verify.checkEQ((int)42,    (int)42);\n+        Verify.checkEQ((long)42,   (long)42);\n+        Verify.checkEQ((float)42,  (float)42);\n+        Verify.checkEQ((double)42, (double)42);\n+\n+        \/\/ Boxed type mismatch: float vs int\n+        checkNE((int)42, (float)42);\n+\n+        \/\/ Boxed value mismatch.\n+        for (int i = 0; i < 10; i++) {\n+            byte v1 = (byte)RANDOM.nextInt();\n+            byte v2 = (byte)(v1 ^ (1 << RANDOM.nextInt(8)));\n+            checkNE(v1, v2);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            char v1 = (char)RANDOM.nextInt();\n+            char v2 = (char)(v1 ^ (1 << RANDOM.nextInt(16)));\n+            checkNE(v1, v2);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            char v1 = (char)RANDOM.nextInt();\n+            char v2 = (char)(v1 ^ (1 << RANDOM.nextInt(16)));\n+            checkNE(v1, v2);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            int v1 = (int)RANDOM.nextInt();\n+            int v2 = (int)(v1 ^ (1 << RANDOM.nextInt(32)));\n+            checkNE(v1, v2);\n+            checkNE(Float.intBitsToFloat(v1), Float.intBitsToFloat(v2));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            long v1 = (long)RANDOM.nextLong();\n+            long v2 = (long)(v1 ^ (1L << RANDOM.nextInt(64)));\n+            checkNE(v1, v2);\n+            checkNE(Double.longBitsToDouble(v1), Double.longBitsToDouble(v2));\n+        }\n+    }\n+\n+    public static void checkNE(Object a, Object b) {\n+         try {\n+            Verify.checkEQ(a, b);\n+            throw new RuntimeException(\"Should have thrown\");\n+        } catch (VerifyException e) {}\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/tests\/TestVerify.java","additions":419,"deletions":0,"binary":false,"changes":419,"status":"added"}]}