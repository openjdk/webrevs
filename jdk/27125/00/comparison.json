{"files":[{"patch":"@@ -665,2 +665,1 @@\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    -1 for unlimited (or unavailable)\n@@ -668,1 +667,1 @@\n-jlong CgroupSubsystem::memory_limit_in_bytes() {\n+ssize_t CgroupSubsystem::memory_limit_in_bytes() {\n@@ -674,3 +673,3 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  log_trace(os, container)(\"total physical memory: \" JULONG_FORMAT, phys_mem);\n-  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n+  size_t phys_mem = os::Linux::physical_memory();\n+  log_trace(os, container)(\"total physical memory: %zu\", phys_mem);\n+  ssize_t mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n@@ -724,1 +723,1 @@\n-bool CgroupController::read_number(const char* filename, julong* result) {\n+bool CgroupController::read_number(const char* filename, size_t& result) {\n@@ -730,1 +729,1 @@\n-  int matched = sscanf(buf, JULONG_FORMAT, result);\n+  int matched = sscanf(buf, \"%zu\", &result);\n@@ -737,1 +736,1 @@\n-bool CgroupController::read_number_handle_max(const char* filename, jlong* result) {\n+bool CgroupController::read_number_handle_max(const char* filename, ssize_t& result) {\n@@ -743,2 +742,2 @@\n-  jlong val = limit_from_str(buf);\n-  if (val == OSCONTAINER_ERROR) {\n+  ssize_t val = 0;\n+  if (!limit_from_str(buf, val)) {\n@@ -747,1 +746,1 @@\n-  *result = val;\n+  result = val;\n@@ -751,1 +750,1 @@\n-bool CgroupController::read_numerical_key_value(const char* filename, const char* key, julong* result) {\n+bool CgroupController::read_numerical_key_value(const char* filename, const char* key, size_t& result) {\n@@ -753,1 +752,0 @@\n-  assert(result != nullptr, \"result pointer must not be null\");\n@@ -791,1 +789,1 @@\n-      int matched = sscanf(value_substr, JULONG_FORMAT, result);\n+      int matched = sscanf(value_substr, \"%zu\", &result);\n@@ -802,1 +800,1 @@\n-  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", JULONG_FORMAT,\n+  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", \"%zu\",\n@@ -807,1 +805,1 @@\n-bool CgroupController::read_numerical_tuple_value(const char* filename, bool use_first, jlong* result) {\n+bool CgroupController::read_numerical_tuple_value(const char* filename, bool use_first, ssize_t& result) {\n@@ -818,2 +816,2 @@\n-  jlong val = limit_from_str(token);\n-  if (val == OSCONTAINER_ERROR) {\n+  ssize_t val = 0;\n+  if (!limit_from_str(token, val)) {\n@@ -822,1 +820,1 @@\n-  *result = val;\n+  result = val;\n@@ -826,1 +824,1 @@\n-jlong CgroupController::limit_from_str(char* limit_str) {\n+bool CgroupController::limit_from_str(char* limit_str, ssize_t& value) {\n@@ -828,1 +826,1 @@\n-    return OSCONTAINER_ERROR;\n+    return false;\n@@ -833,1 +831,2 @@\n-    return (jlong)-1;\n+    value = (ssize_t)-1;\n+    return true;\n@@ -835,3 +834,3 @@\n-  julong limit;\n-  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n-    return OSCONTAINER_ERROR;\n+  size_t limit;\n+  if (sscanf(limit_str, \"%zu\", &limit) != 1) {\n+    return false;\n@@ -839,1 +838,2 @@\n-  return (jlong)limit;\n+  value = static_cast<ssize_t>(limit);\n+  return true;\n@@ -844,3 +844,3 @@\n-jlong CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  julong host_swap = os::Linux::host_swap();\n+ssize_t CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n+  size_t phys_mem = os::Linux::physical_memory();\n+  size_t host_swap = os::Linux::host_swap();\n@@ -850,3 +850,3 @@\n-jlong CgroupSubsystem::memory_and_swap_usage_in_bytes() {\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  julong host_swap = os::Linux::host_swap();\n+ssize_t CgroupSubsystem::memory_and_swap_usage_in_bytes() {\n+  size_t phys_mem = os::Linux::physical_memory();\n+  size_t host_swap = os::Linux::host_swap();\n@@ -856,2 +856,2 @@\n-jlong CgroupSubsystem::memory_soft_limit_in_bytes() {\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+ssize_t CgroupSubsystem::memory_soft_limit_in_bytes() {\n+  size_t phys_mem = os::Linux::physical_memory();\n@@ -861,1 +861,1 @@\n-jlong CgroupSubsystem::memory_throttle_limit_in_bytes() {\n+ssize_t CgroupSubsystem::memory_throttle_limit_in_bytes() {\n@@ -865,1 +865,1 @@\n-jlong CgroupSubsystem::memory_usage_in_bytes() {\n+ssize_t CgroupSubsystem::memory_usage_in_bytes() {\n@@ -869,1 +869,1 @@\n-jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n+ssize_t CgroupSubsystem::memory_max_usage_in_bytes() {\n@@ -873,1 +873,1 @@\n-jlong CgroupSubsystem::rss_usage_in_bytes() {\n+ssize_t CgroupSubsystem::rss_usage_in_bytes() {\n@@ -877,1 +877,1 @@\n-jlong CgroupSubsystem::cache_usage_in_bytes() {\n+ssize_t CgroupSubsystem::cache_usage_in_bytes() {\n@@ -893,1 +893,1 @@\n-jlong CgroupSubsystem::cpu_usage_in_micros() {\n+ssize_t CgroupSubsystem::cpu_usage_in_micros() {\n@@ -898,1 +898,1 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  size_t phys_mem = os::Linux::physical_memory();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  is_ok = controller->read_number(filename, &retval);                                 \\\n+  is_ok = controller->read_number(filename, retval);                                  \\\n@@ -78,1 +78,1 @@\n-    return OSCONTAINER_ERROR;                                                         \\\n+    return false;                                                                     \\\n@@ -80,1 +80,2 @@\n-  log_trace(os, container)(log_string \" is: \" JULONG_FORMAT, retval);                 \\\n+  log_trace(os, container)(log_string \" is: %zu\", retval);                            \\\n+  return true;                                                                        \\\n@@ -86,1 +87,1 @@\n-  is_ok = controller->read_number_handle_max(filename, &retval);                      \\\n+  is_ok = controller->read_number_handle_max(filename, retval);                       \\\n@@ -89,1 +90,1 @@\n-    return OSCONTAINER_ERROR;                                                         \\\n+    return false;                                                                     \\\n@@ -91,1 +92,2 @@\n-  log_trace(os, container)(log_string \" is: \" JLONG_FORMAT, retval);                  \\\n+  log_trace(os, container)(log_string \" is: %zd\", retval);                            \\\n+  return true;                                                                        \\\n@@ -116,1 +118,1 @@\n-    \/* Read a numerical value as unsigned long\n+    \/* Read a numerical value as size_t\n@@ -119,1 +121,1 @@\n-     * the parsed value is set in the provided julong pointer.\n+     * the parsed value is set in the provided size_t reference.\n@@ -121,1 +123,1 @@\n-    bool read_number(const char* filename, julong* result);\n+    bool read_number(const char* filename, size_t& result);\n@@ -127,2 +129,2 @@\n-     * the parsed value (which might be negative) is being set in\n-     * the provided jlong pointer.\n+     * the parsed value in the range [-1,SSIZE_MAX] is being set in\n+     * the provided ssize_t reference. -1 means the value is unlimited.\n@@ -130,1 +132,1 @@\n-    bool read_number_handle_max(const char* filename, jlong* result);\n+    bool read_number_handle_max(const char* filename, ssize_t& result);\n@@ -148,1 +150,2 @@\n-     * value of the appropriate tuple entry set in the provided jlong pointer.\n+     * value of the appropriate tuple entry set in the provided ssize_t reference\n+     * in the range [-1,SSIZE_MAX]. -1 means unlimited tuple value.\n@@ -150,1 +153,1 @@\n-    bool read_numerical_tuple_value(const char* filename, bool use_first, jlong* result);\n+    bool read_numerical_tuple_value(const char* filename, bool use_first, ssize_t& result);\n@@ -154,1 +157,1 @@\n-     * via the passed in julong pointer. Example interface file 'memory.stat'\n+     * via the passed in size_t reference. Example interface file 'memory.stat'\n@@ -157,1 +160,1 @@\n-     * being set in the provided julong pointer.\n+     * being set in the provided size_t reference.\n@@ -159,1 +162,1 @@\n-    bool read_numerical_key_value(const char* filename, const char* key, julong* result);\n+    bool read_numerical_key_value(const char* filename, const char* key, size_t& result);\n@@ -162,1 +165,1 @@\n-    static jlong limit_from_str(char* limit_str);\n+    static bool limit_from_str(char* limit_str, ssize_t& value);\n@@ -167,1 +170,1 @@\n-    volatile jlong _metric;\n+    volatile ssize_t _metric;\n@@ -177,2 +180,2 @@\n-    jlong value() { return _metric; }\n-    void set_value(jlong value, jlong timeout) {\n+    ssize_t value() { return _metric; }\n+    void set_value(ssize_t value, jlong timeout) {\n@@ -222,1 +225,1 @@\n-    virtual jlong cpu_usage_in_micros() = 0;\n+    virtual ssize_t cpu_usage_in_micros() = 0;\n@@ -234,10 +237,10 @@\n-    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n-    virtual jlong memory_usage_in_bytes() = 0;\n-    virtual jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) = 0;\n-    virtual jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) = 0;\n-    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n-    virtual jlong memory_throttle_limit_in_bytes() = 0;\n-    virtual jlong memory_max_usage_in_bytes() = 0;\n-    virtual jlong rss_usage_in_bytes() = 0;\n-    virtual jlong cache_usage_in_bytes() = 0;\n-    virtual void print_version_specific_info(outputStream* st, julong host_mem) = 0;\n+    virtual ssize_t read_memory_limit_in_bytes(size_t host_mem) = 0;\n+    virtual ssize_t memory_usage_in_bytes() = 0;\n+    virtual ssize_t memory_and_swap_limit_in_bytes(size_t host_mem, size_t host_swap) = 0;\n+    virtual ssize_t memory_and_swap_usage_in_bytes(size_t host_mem, size_t host_swap) = 0;\n+    virtual ssize_t memory_soft_limit_in_bytes(size_t host_mem) = 0;\n+    virtual ssize_t memory_throttle_limit_in_bytes() = 0;\n+    virtual ssize_t memory_max_usage_in_bytes() = 0;\n+    virtual ssize_t rss_usage_in_bytes() = 0;\n+    virtual ssize_t cache_usage_in_bytes() = 0;\n+    virtual void print_version_specific_info(outputStream* st, size_t host_mem) = 0;\n@@ -254,1 +257,1 @@\n-    jlong memory_limit_in_bytes();\n+    ssize_t memory_limit_in_bytes();\n@@ -257,2 +260,2 @@\n-    virtual jlong pids_max() = 0;\n-    virtual jlong pids_current() = 0;\n+    virtual ssize_t pids_max() = 0;\n+    virtual ssize_t pids_current() = 0;\n@@ -272,1 +275,1 @@\n-    jlong cpu_usage_in_micros();\n+    ssize_t cpu_usage_in_micros();\n@@ -274,8 +277,8 @@\n-    jlong memory_usage_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_and_swap_usage_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_throttle_limit_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n+    ssize_t memory_usage_in_bytes();\n+    ssize_t memory_and_swap_limit_in_bytes();\n+    ssize_t memory_and_swap_usage_in_bytes();\n+    ssize_t memory_soft_limit_in_bytes();\n+    ssize_t memory_throttle_limit_in_bytes();\n+    ssize_t memory_max_usage_in_bytes();\n+    ssize_t rss_usage_in_bytes();\n+    ssize_t cache_usage_in_bytes();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":47,"deletions":44,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  size_t phys_mem = os::Linux::physical_memory();\n@@ -70,3 +70,3 @@\n-  jlong limit = mem->read_memory_limit_in_bytes(phys_mem);\n-  jlong lowest_limit = limit < 0 ? phys_mem : limit;\n-  julong orig_limit = ((julong)lowest_limit) != phys_mem ? lowest_limit : phys_mem;\n+  ssize_t limit = mem->read_memory_limit_in_bytes(phys_mem);\n+  ssize_t lowest_limit = limit < 0 ? static_cast<ssize_t>(phys_mem) : limit;\n+  size_t orig_limit = ((size_t)lowest_limit) != phys_mem ? static_cast<size_t>(lowest_limit) : phys_mem;\n@@ -93,1 +93,1 @@\n-  if ((julong)lowest_limit != orig_limit) {\n+  if (static_cast<size_t>(lowest_limit) != orig_limit) {\n@@ -99,1 +99,1 @@\n-                             \"Lowest limit was: \" JLONG_FORMAT,\n+                             \"Lowest limit was: %zd\",\n@@ -103,1 +103,1 @@\n-    log_trace(os, container)(\"Lowest limit was: \" JLONG_FORMAT, lowest_limit);\n+    log_trace(os, container)(\"Lowest limit was: %zd\", lowest_limit);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -138,20 +138,2 @@\n-static inline\n-void verbose_log(julong read_mem_limit, julong host_mem) {\n-  if (log_is_enabled(Debug, os, container)) {\n-    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n-    if (mem_limit < 0 || read_mem_limit >= host_mem) {\n-      const char *reason;\n-      if (mem_limit == OSCONTAINER_ERROR) {\n-        reason = \"failed\";\n-      } else if (mem_limit == -1) {\n-        reason = \"unlimited\";\n-      } else {\n-        assert(read_mem_limit >= host_mem, \"Expected read value exceeding host_mem\");\n-        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n-        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n-        reason = \"ignored\";\n-      }\n-      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                               reason, mem_limit, host_mem);\n-    }\n-  }\n+bool CgroupV1MemoryController::read_memory_limit_val(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.limit_in_bytes\", \"Memory Limit\", result);\n@@ -160,6 +142,12 @@\n-jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n-  julong memlimit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n-  if (memlimit >= phys_mem) {\n-    verbose_log(memlimit, phys_mem);\n-    return (jlong)-1;\n+ssize_t CgroupV1MemoryController::read_memory_limit_in_bytes(size_t host_mem) {\n+  size_t memlimit = 0;\n+  if (!read_memory_limit_val(memlimit)) {\n+    log_trace(os, container)(\"container memory limit failed, using host value %zu\", host_mem);\n+    return (ssize_t)-1; \/\/ treat as unlimited\n+  }\n+  if (memlimit >= host_mem) {\n+    \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+    \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+    log_trace(os, container)(\"container memory limit ignored: %zu, using host value %zu\",\n+                              memlimit, host_mem);\n+    return (ssize_t)-1; \/\/ unlimited\n@@ -167,2 +155,1 @@\n-    verbose_log(memlimit, phys_mem);\n-    return (jlong)memlimit;\n+    return static_cast<ssize_t>(memlimit);\n@@ -172,1 +159,5 @@\n-\/* read_mem_swap\n+bool CgroupV1MemoryController::read_mem_swap(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", result);\n+}\n+\n+\/* memory_and_swap_limit_in_bytes\n@@ -176,1 +167,1 @@\n- * negative value is returned indicating the determined status.\n+ * negative value is returned indicating an unlimited value.\n@@ -180,3 +171,2 @@\n- *    * OSCONTAINER_ERROR if the limit cannot be retrieved (i.e. not supported) or\n- *    * -1 if there isn't any limit in place (note: includes values which exceed a physical\n- *      upper bound)\n+ *    * -1 if there isn't any limit in place. note: this includes values which exceed\n+ *      a physical upper bound (or a failure to read from the interface files).\n@@ -184,8 +174,6 @@\n-jlong CgroupV1MemoryController::read_mem_swap(julong host_total_memsw) {\n-  julong memswlimit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n-  if (memswlimit >= host_total_memsw) {\n-    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memswlimit;\n+ssize_t CgroupV1MemoryController::memory_and_swap_limit_in_bytes(size_t host_mem, size_t host_swap) {\n+  size_t total_mem_swap = host_mem + host_swap;\n+  size_t memory_swap = 0;\n+  bool mem_swap_read_failed = false;\n+  if (!read_mem_swap(memory_swap)) {\n+    mem_swap_read_failed = true;\n@@ -193,6 +181,3 @@\n-}\n-\n-jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) {\n-  jlong memory_swap = read_mem_swap(host_mem + host_swap);\n-  if (memory_swap == -1) {\n-    return memory_swap;\n+  if (memory_swap >= total_mem_swap) {\n+    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n+    return (ssize_t)-1;\n@@ -203,5 +188,9 @@\n-  jlong swappiness = read_mem_swappiness();\n-  if (swappiness == 0 || memory_swap == OSCONTAINER_ERROR) {\n-    jlong memlimit = read_memory_limit_in_bytes(host_mem);\n-    if (memory_swap == OSCONTAINER_ERROR) {\n-      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JLONG_FORMAT \" because swap is not supported\", memlimit);\n+  size_t swappiness = 0;\n+  if (!read_mem_swappiness(swappiness)) {\n+    \/\/ assume no swap\n+    mem_swap_read_failed = true;\n+  }\n+  if (swappiness == 0 || mem_swap_read_failed) {\n+    ssize_t memlimit = read_memory_limit_in_bytes(host_mem);\n+    if (mem_swap_read_failed) {\n+      log_trace(os, container)(\"Memory and Swap Limit has been reset to %zd because swap is not supported\", memlimit);\n@@ -209,1 +198,1 @@\n-      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JLONG_FORMAT \" because swappiness is 0\", memlimit);\n+      log_trace(os, container)(\"Memory and Swap Limit has been reset to %zd because swappiness is 0\", memlimit);\n@@ -213,1 +202,1 @@\n-  return memory_swap;\n+  return static_cast<ssize_t>(memory_swap);\n@@ -217,4 +206,2 @@\n-jlong memory_swap_usage_impl(CgroupController* ctrl) {\n-  julong memory_swap_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", memory_swap_usage);\n-  return (jlong)memory_swap_usage;\n+bool memory_swap_usage_impl(CgroupController* ctrl, size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", result);\n@@ -223,3 +210,3 @@\n-jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong phys_mem, julong host_swap) {\n-  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n-  jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n+ssize_t CgroupV1MemoryController::memory_and_swap_usage_in_bytes(size_t phys_mem, size_t host_swap) {\n+  ssize_t memory_sw_limit = memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+  ssize_t memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -227,1 +214,1 @@\n-    jlong delta_swap = memory_sw_limit - memory_limit;\n+    ssize_t delta_swap = memory_sw_limit - memory_limit;\n@@ -229,1 +216,5 @@\n-      return memory_swap_usage_impl(reader());\n+      size_t swap_usage = 0;\n+      if (!memory_swap_usage_impl(reader(), swap_usage)) {\n+        return -1; \/\/ usage value error\n+      }\n+      return static_cast<ssize_t>(swap_usage);\n@@ -235,4 +226,6 @@\n-jlong CgroupV1MemoryController::read_mem_swappiness() {\n-  julong swappiness;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n-  return (jlong)swappiness;\n+bool CgroupV1MemoryController::read_mem_swappiness(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.swappiness\", \"Swappiness\", result);\n+}\n+\n+bool CgroupV1MemoryController::memory_soft_limit_val(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", result);\n@@ -241,4 +234,6 @@\n-jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n-  julong memsoftlimit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n-  if (memsoftlimit >= phys_mem) {\n+ssize_t CgroupV1MemoryController::memory_soft_limit_in_bytes(size_t phys_mem) {\n+  size_t mem_soft_limit = 0;\n+  if (!memory_soft_limit_val(mem_soft_limit)) {\n+    return (ssize_t)-1; \/\/ treat as unlimited\n+  }\n+  if (mem_soft_limit >= phys_mem) {\n@@ -246,1 +241,1 @@\n-    return (jlong)-1;\n+    return (ssize_t)-1;\n@@ -248,1 +243,1 @@\n-    return (jlong)memsoftlimit;\n+    return static_cast<ssize_t>(mem_soft_limit);\n@@ -252,1 +247,1 @@\n-jlong CgroupV1MemoryController::memory_throttle_limit_in_bytes() {\n+ssize_t CgroupV1MemoryController::memory_throttle_limit_in_bytes() {\n@@ -255,1 +250,1 @@\n-  return OSCONTAINER_ERROR; \/\/ not supported\n+  return (ssize_t)-1; \/\/ not supported\n@@ -284,1 +279,9 @@\n-\/* memory_usage_in_bytes\n+ssize_t CgroupV1MemoryController::memory_usage_in_bytes() {\n+  size_t memory_usage = 0;\n+  if (!memory_usage_val(memory_usage)) {\n+    return -1; \/\/ usage value error\n+  }\n+  return static_cast<ssize_t>(memory_usage);\n+}\n+\n+\/* memory_usage_val\n@@ -286,1 +289,1 @@\n- * Return the amount of used memory for this process.\n+ * Read the amount of used memory for this process into the passed in reference 'result'\n@@ -289,3 +292,2 @@\n- *    memory usage in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    true when reading of the file was successful and 'result' was set appropriately\n+ *    false when reading of the file failed\n@@ -293,4 +295,6 @@\n-jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n-  julong memusage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n-  return (jlong)memusage;\n+bool CgroupV1MemoryController::memory_usage_val(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.usage_in_bytes\", \"Memory Usage\", result);\n+}\n+\n+bool CgroupV1MemoryController::memory_max_usage_val(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", result);\n@@ -304,2 +308,1 @@\n- *    max memory usage in bytes or\n- *    OSCONTAINER_ERROR for not supported\n+ *    max memory usage in bytes. -1 when unavailable\n@@ -307,4 +310,6 @@\n-jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n-  julong memmaxusage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n-  return (jlong)memmaxusage;\n+ssize_t CgroupV1MemoryController::memory_max_usage_in_bytes() {\n+  size_t memory_max_usage = 0;\n+  if (!memory_max_usage_val(memory_max_usage)) {\n+     return -1; \/\/ usage value error\n+  }\n+  return static_cast<ssize_t>(memory_max_usage);\n@@ -313,3 +318,3 @@\n-jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n-  julong rss;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n+ssize_t CgroupV1MemoryController::rss_usage_in_bytes() {\n+  size_t rss = 0;\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"rss\", rss);\n@@ -317,1 +322,1 @@\n-    return OSCONTAINER_ERROR;\n+    return -1; \/\/ usage value error\n@@ -319,2 +324,2 @@\n-  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n-  return (jlong)rss;\n+  log_trace(os, container)(\"RSS usage is: %zu\", rss);\n+  return static_cast<ssize_t>(rss);\n@@ -323,3 +328,3 @@\n-jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n-  julong cache;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n+ssize_t CgroupV1MemoryController::cache_usage_in_bytes() {\n+  size_t cache;\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"cache\", cache);\n@@ -327,1 +332,1 @@\n-    return OSCONTAINER_ERROR;\n+    return -1; \/\/ usage value error\n@@ -329,2 +334,2 @@\n-  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n-  return cache;\n+  log_trace(os, container)(\"Cache usage is: %zu\", cache);\n+  return static_cast<ssize_t>(cache);\n@@ -333,4 +338,2 @@\n-jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n-  julong kmem_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n-  return (jlong)kmem_usage;\n+bool CgroupV1MemoryController::kernel_memory_usage_val(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", result);\n@@ -339,5 +342,4 @@\n-jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong phys_mem) {\n-  julong kmem_limit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n-  if (kmem_limit >= phys_mem) {\n-    return (jlong)-1;\n+ssize_t CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n+  size_t kmem_usage = 0;\n+  if (!kernel_memory_usage_val(kmem_usage)) {\n+    return -1; \/\/ usage value error\n@@ -345,1 +347,1 @@\n-  return (jlong)kmem_limit;\n+  return static_cast<ssize_t>(kmem_usage);\n@@ -348,4 +350,2 @@\n-jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n-  julong kmem_max_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n-  return (jlong)kmem_max_usage;\n+bool CgroupV1MemoryController::kernel_memory_limit_val(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", result);\n@@ -354,4 +354,24 @@\n-void CgroupV1MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n-  jlong kmem_usage = kernel_memory_usage_in_bytes();\n-  jlong kmem_limit = kernel_memory_limit_in_bytes(phys_mem);\n-  jlong kmem_max_usage = kernel_memory_max_usage_in_bytes();\n+ssize_t CgroupV1MemoryController::kernel_memory_limit_in_bytes(size_t phys_mem) {\n+  size_t kmem_limit = 0;\n+  if (!kernel_memory_limit_val(kmem_limit) || kmem_limit >= phys_mem) {\n+    return (ssize_t)-1; \/\/ treat as unlimited\n+  }\n+  return static_cast<ssize_t>(kmem_limit);\n+}\n+\n+bool CgroupV1MemoryController::kernel_memory_max_usage_val(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", result);\n+}\n+\n+ssize_t CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n+  size_t kmem_max_usage = 0;\n+  if (!kernel_memory_max_usage_val(kmem_max_usage)) {\n+    return -1; \/\/ usage value error\n+  }\n+  return static_cast<ssize_t>(kmem_max_usage);\n+}\n+\n+void CgroupV1MemoryController::print_version_specific_info(outputStream* st, size_t phys_mem) {\n+  ssize_t kmem_usage = kernel_memory_usage_in_bytes();\n+  ssize_t kmem_limit = kernel_memory_limit_in_bytes(phys_mem);\n+  ssize_t kmem_max_usage = kernel_memory_max_usage_in_bytes();\n@@ -359,3 +379,3 @@\n-  OSContainer::print_container_helper(st, kmem_limit, \"kernel_memory_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, kmem_usage, \"kernel_memory_usage_in_bytes\");\n-  OSContainer::print_container_helper(st, kmem_max_usage, \"kernel_memory_max_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, kmem_limit, \"kernel_memory_limit_in_bytes\", false \/* is_usage *\/);\n+  OSContainer::print_container_helper(st, kmem_usage, \"kernel_memory_usage_in_bytes\", true  \/* is_usage *\/);\n+  OSContainer::print_container_helper(st, kmem_max_usage, \"kernel_memory_max_usage_in_bytes\", true \/* is_usage *\/);\n@@ -383,2 +403,1 @@\n- *    -1 for no quota\n- *    OSCONTAINER_ERROR for not supported\n+ *    -1 for no quota or when an error occurs\n@@ -387,2 +406,2 @@\n-  julong quota;\n-  bool is_ok = reader()->read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  size_t quota = 0;\n+  bool is_ok = reader()->read_number(\"\/cpu.cfs_quota_us\", quota);\n@@ -391,1 +410,1 @@\n-    return OSCONTAINER_ERROR;\n+    return -1; \/\/ treat as unlimited\n@@ -400,0 +419,4 @@\n+bool CgroupV1CpuController::cpu_period(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.cfs_period_us\", \"CPU Period\", result);\n+}\n+\n@@ -401,3 +424,9 @@\n-  julong period;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n-  return (int)period;\n+  size_t period = 0;\n+  if (!cpu_period(period)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n+  return static_cast<int>(period);\n+}\n+\n+bool CgroupV1CpuController::cpu_shares(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.shares\", \"CPU Shares\", result);\n@@ -413,2 +442,1 @@\n- *    -1 for no share setup\n- *    OSCONTAINER_ERROR for not supported\n+ *    -1 for no share setup (or error)\n@@ -417,2 +445,4 @@\n-  julong shares;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  size_t shares = 0;\n+  if (!cpu_shares(shares)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n@@ -426,3 +456,9 @@\n-jlong CgroupV1CpuacctController::cpu_usage_in_micros() {\n-  julong cpu_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpuacct.usage\", \"CPU Usage\", cpu_usage);\n+bool CgroupV1CpuacctController::cpu_usage_in_micros(size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpuacct.usage\", \"CPU Usage\", result);\n+}\n+\n+ssize_t CgroupV1CpuacctController::cpu_usage_in_micros() {\n+  size_t cpu_usage = 0;\n+  if (!cpu_usage_in_micros(cpu_usage)) {\n+    return -1; \/\/ usage value error\n+  }\n@@ -430,1 +466,6 @@\n-  return (jlong)cpu_usage \/ 1000;\n+  return static_cast<ssize_t>(cpu_usage \/ 1000);\n+}\n+\n+static\n+bool pids_max_val(CgroupController* ctrl, ssize_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/pids.max\", \"Maximum number of tasks\", result);\n@@ -439,2 +480,1 @@\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    -1 for unlimited (or failure to retrieve the value)\n@@ -442,5 +482,12 @@\n-jlong CgroupV1Subsystem::pids_max() {\n-  if (_pids == nullptr) return OSCONTAINER_ERROR;\n-  jlong pids_max;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_pids, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n-  return pids_max;\n+ssize_t CgroupV1Subsystem::pids_max() {\n+  if (_pids == nullptr) return -1; \/\/ treat as unlimited\n+  ssize_t pids_val = 0;\n+  if (!pids_max_val(_pids, pids_val)) {\n+    return -1; \/\/ treat failure as unlimited\n+  }\n+  return pids_val;\n+}\n+\n+static\n+bool pids_current_val(CgroupController* ctrl, size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/pids.current\", \"Current number of tasks\", result);\n@@ -454,2 +501,1 @@\n- *    current number of tasks\n- *    OSCONTAINER_ERROR for not supported\n+ *    current number of tasks or -1 for not supported\n@@ -457,5 +503,7 @@\n-jlong CgroupV1Subsystem::pids_current() {\n-  if (_pids == nullptr) return OSCONTAINER_ERROR;\n-  julong pids_current;\n-  CONTAINER_READ_NUMBER_CHECKED(_pids, \"\/pids.current\", \"Current number of tasks\", pids_current);\n-  return (jlong)pids_current;\n+ssize_t CgroupV1Subsystem::pids_current() {\n+  if (_pids == nullptr) return -1; \/\/ treat as unlimited\n+  size_t pids_current = 0;\n+  if (!pids_current_val(_pids, pids_current)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n+  return static_cast<ssize_t>(pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":201,"deletions":153,"binary":false,"changes":354,"status":"modified"},{"patch":"@@ -76,0 +76,10 @@\n+    bool read_memory_limit_val(size_t& result);\n+    bool memory_usage_val(size_t& result);\n+    bool read_mem_swappiness(size_t& result);\n+    bool read_mem_swap(size_t& result);\n+    bool memory_soft_limit_val(size_t& result);\n+    bool memory_max_usage_val(size_t& result);\n+    bool kernel_memory_usage_val(size_t& result);\n+    bool kernel_memory_limit_val(size_t& result);\n+    bool kernel_memory_max_usage_val(size_t& result);\n+\n@@ -80,13 +90,13 @@\n-    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_usage_in_bytes() override;\n-    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) override;\n-    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) override;\n-    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_throttle_limit_in_bytes() override;\n-    jlong memory_max_usage_in_bytes() override;\n-    jlong rss_usage_in_bytes() override;\n-    jlong cache_usage_in_bytes() override;\n-    jlong kernel_memory_usage_in_bytes();\n-    jlong kernel_memory_limit_in_bytes(julong host_mem);\n-    jlong kernel_memory_max_usage_in_bytes();\n-    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    ssize_t read_memory_limit_in_bytes(size_t host_mem) override;\n+    ssize_t memory_usage_in_bytes() override;\n+    ssize_t memory_and_swap_limit_in_bytes(size_t host_mem, size_t host_swap) override;\n+    ssize_t memory_and_swap_usage_in_bytes(size_t host_mem, size_t host_swap) override;\n+    ssize_t memory_soft_limit_in_bytes(size_t host_mem) override;\n+    ssize_t memory_throttle_limit_in_bytes() override;\n+    ssize_t memory_max_usage_in_bytes() override;\n+    ssize_t rss_usage_in_bytes() override;\n+    ssize_t cache_usage_in_bytes() override;\n+    ssize_t kernel_memory_usage_in_bytes();\n+    ssize_t kernel_memory_limit_in_bytes(size_t host_mem);\n+    ssize_t kernel_memory_max_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st, size_t host_mem) override;\n@@ -102,3 +112,0 @@\n-  private:\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap(julong host_total_memsw);\n@@ -118,0 +125,2 @@\n+    bool cpu_period(size_t& result);\n+    bool cpu_shares(size_t& result);\n@@ -149,0 +158,1 @@\n+    bool cpu_usage_in_micros(size_t& result);\n@@ -150,1 +160,1 @@\n-    jlong cpu_usage_in_micros() override;\n+    ssize_t cpu_usage_in_micros() override;\n@@ -182,3 +192,3 @@\n-    jlong kernel_memory_usage_in_bytes();\n-    jlong kernel_memory_limit_in_bytes();\n-    jlong kernel_memory_max_usage_in_bytes();\n+    ssize_t kernel_memory_usage_in_bytes();\n+    ssize_t kernel_memory_limit_in_bytes();\n+    ssize_t kernel_memory_max_usage_in_bytes();\n@@ -189,2 +199,2 @@\n-    jlong pids_max();\n-    jlong pids_current();\n+    ssize_t pids_max();\n+    ssize_t pids_current();\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -45,0 +45,5 @@\n+static\n+bool read_cpu_shares_value(CgroupV2Controller* ctrl, size_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/cpu.weight\", \"Raw value for CPU Shares\", value);\n+}\n+\n@@ -52,2 +57,1 @@\n- *    -1 for no share setup\n- *    OSCONTAINER_ERROR for not supported\n+ *    -1 for no share setup (or on error)\n@@ -56,2 +60,5 @@\n-  julong shares;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  size_t shares = 0;\n+  bool is_ok = read_cpu_shares_value(reader(), shares);\n+  if (!is_ok) {\n+    return -1; \/\/ treat as unlimited\n+  }\n@@ -102,1 +109,0 @@\n- *    OSCONTAINER_ERROR for not supported\n@@ -105,2 +111,2 @@\n-  jlong quota_val;\n-  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n+  ssize_t quota_val = 0;\n+  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, quota_val);\n@@ -108,1 +114,1 @@\n-    return OSCONTAINER_ERROR;\n+    return -1; \/\/ treat as no limit\n@@ -146,3 +152,2 @@\n-int CgroupV2CpuController::cpu_period() {\n-  jlong period_val;\n-  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n+bool CgroupV2CpuController::cpu_period(ssize_t& value) {\n+  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, value);\n@@ -151,1 +156,10 @@\n-    return OSCONTAINER_ERROR;\n+    return false;\n+  }\n+  log_trace(os, container)(\"CPU Period is: %zd\", value);\n+  return true;\n+}\n+\n+int CgroupV2CpuController::cpu_period() {\n+  ssize_t period = 0;\n+  if (!cpu_period(period)) {\n+    return -1; \/\/ treat as unlimited\n@@ -153,3 +167,1 @@\n-  int period = (int)period_val;\n-  log_trace(os, container)(\"CPU Period is: %d\", period);\n-  return period;\n+  return static_cast<int>(period);\n@@ -158,3 +170,2 @@\n-jlong CgroupV2CpuController::cpu_usage_in_micros() {\n-  julong cpu_usage;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/cpu.stat\", \"usage_usec\", &cpu_usage);\n+bool CgroupV2CpuController::cpu_usage_in_micros(size_t& value) {\n+  bool is_ok = reader()->read_numerical_key_value(\"\/cpu.stat\", \"usage_usec\", value);\n@@ -163,1 +174,18 @@\n-    return OSCONTAINER_ERROR;\n+    return false;\n+  }\n+  log_trace(os, container)(\"CPU Usage is: %zu\", value);\n+  return true;\n+}\n+\n+ssize_t CgroupV2CpuController::cpu_usage_in_micros() {\n+  size_t usage_micros = 0;\n+  if (!cpu_usage_in_micros(usage_micros)) {\n+    return -1; \/\/ usage value error\n+  }\n+  return static_cast<ssize_t>(usage_micros);\n+}\n+\n+ssize_t CgroupV2MemoryController::memory_usage_in_bytes() {\n+  size_t mem_usage = 0;\n+  if (!memory_usage_in_bytes(mem_usage)) {\n+    return -1; \/\/ usage value error\n@@ -165,2 +193,1 @@\n-  log_trace(os, container)(\"CPU Usage is: \" JULONG_FORMAT, cpu_usage);\n-  return (jlong)cpu_usage;\n+  return static_cast<ssize_t>(mem_usage);\n@@ -171,1 +198,2 @@\n- * Return the amount of used memory used by this cgroup and descendents\n+ * read the amount of used memory used by this cgroup and descendents\n+ * into the passed in 'value' reference.\n@@ -174,3 +202,1 @@\n- *    memory usage in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    false on failure, true otherwise.\n@@ -178,4 +204,14 @@\n-jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n-  julong memusage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.current\", \"Memory Usage\", memusage);\n-  return (jlong)memusage;\n+bool CgroupV2MemoryController::memory_usage_in_bytes(size_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.current\", \"Memory Usage\", value);\n+}\n+\n+ssize_t CgroupV2MemoryController::memory_soft_limit_in_bytes(size_t host_mem) {\n+  ssize_t result = 0;\n+  if (!memory_soft_limit_in_bytes(host_mem, result)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n+  return result;\n+}\n+\n+bool CgroupV2MemoryController::memory_soft_limit_in_bytes(size_t phys_mem, ssize_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.low\", \"Memory Soft Limit\", value);\n@@ -184,4 +220,10 @@\n-jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n-  jlong mem_soft_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n-  return mem_soft_limit;\n+ssize_t CgroupV2MemoryController::memory_throttle_limit_in_bytes() {\n+  ssize_t result = 0;\n+  if (!memory_throttle_limit_in_bytes(result)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n+  return result;\n+}\n+\n+bool CgroupV2MemoryController::memory_throttle_limit_in_bytes(ssize_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.high\", \"Memory Throttle Limit\", value);\n@@ -190,4 +232,6 @@\n-jlong CgroupV2MemoryController::memory_throttle_limit_in_bytes() {\n-  jlong mem_throttle_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.high\", \"Memory Throttle Limit\", mem_throttle_limit);\n-  return mem_throttle_limit;\n+ssize_t CgroupV2MemoryController::memory_max_usage_in_bytes() {\n+  size_t max_usage = 0;\n+  if (!memory_max_usage_in_bytes(max_usage)) {\n+    return -1; \/\/ usage value error\n+  }\n+  return static_cast<ssize_t>(max_usage);\n@@ -196,4 +240,10 @@\n-jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n-  julong mem_max_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.peak\", \"Maximum Memory Usage\", mem_max_usage);\n-  return mem_max_usage;\n+bool CgroupV2MemoryController::memory_max_usage_in_bytes(size_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.peak\", \"Maximum Memory Usage\", value);\n+}\n+\n+ssize_t CgroupV2MemoryController::rss_usage_in_bytes() {\n+  size_t rss_usage = 0;\n+  if (!rss_usage_in_bytes(rss_usage)) {\n+    return -1; \/\/ usage value error\n+  }\n+  return static_cast<ssize_t>(rss_usage);\n@@ -202,3 +252,2 @@\n-jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n-  julong rss;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n+bool CgroupV2MemoryController::rss_usage_in_bytes(size_t& value) {\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"anon\", value);\n@@ -206,1 +255,1 @@\n-    return OSCONTAINER_ERROR;\n+    return false;\n@@ -208,2 +257,2 @@\n-  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n-  return (jlong)rss;\n+  log_trace(os, container)(\"RSS usage is: %zu\", value);\n+  return true;\n@@ -212,3 +261,10 @@\n-jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n-  julong cache;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n+ssize_t CgroupV2MemoryController::cache_usage_in_bytes() {\n+  size_t cache_usage = 0;\n+  if (!cache_usage_in_bytes(cache_usage)) {\n+    return -1; \/\/ usage value error\n+  }\n+  return static_cast<ssize_t>(cache_usage);\n+}\n+\n+bool CgroupV2MemoryController::cache_usage_in_bytes(size_t& value) {\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"file\", value);\n@@ -216,1 +272,1 @@\n-    return OSCONTAINER_ERROR;\n+    return false;\n@@ -218,2 +274,10 @@\n-  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n-  return (jlong)cache;\n+  log_trace(os, container)(\"Cache usage is: %zu\", value);\n+  return true;\n+}\n+\n+ssize_t CgroupV2MemoryController::memory_and_swap_limit_in_bytes(size_t host_mem, size_t host_swap) {\n+  ssize_t mem_swap_limit = 0;\n+  if (!memory_and_swap_limit_in_bytes(host_mem, host_swap, mem_swap_limit)) {\n+    return -1; \/\/ treat as unlimited;\n+  }\n+  return mem_swap_limit;\n@@ -227,4 +291,5 @@\n-jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong phys_mem,\n-                                                               julong host_swap \/* unused in cg v2 *\/) {\n-  jlong swap_limit;\n-  bool is_ok = reader()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n+bool CgroupV2MemoryController::memory_and_swap_limit_in_bytes(size_t phys_mem,\n+                                                              size_t host_swap \/* unused in cg v2 *\/,\n+                                                              ssize_t& result) {\n+  ssize_t swap_limit = -1;\n+  bool is_ok = reader()->read_number_handle_max(\"\/memory.swap.max\", swap_limit);\n@@ -235,1 +300,1 @@\n-    return read_memory_limit_in_bytes(phys_mem);\n+    return read_memory_limit_in_bytes(phys_mem, result);\n@@ -237,1 +302,1 @@\n-  log_trace(os, container)(\"Swap Limit is: \" JLONG_FORMAT, swap_limit);\n+  log_trace(os, container)(\"Swap Limit is: %zd\", swap_limit);\n@@ -239,3 +304,6 @@\n-    jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n-    assert(memory_limit >= 0, \"swap limit without memory limit?\");\n-    return memory_limit + swap_limit;\n+    ssize_t memory_limit = -1;\n+    if (read_memory_limit_in_bytes(phys_mem, memory_limit)) {\n+      assert(memory_limit >= 0, \"swap limit without memory limit?\");\n+      result = memory_limit + swap_limit;\n+      return true;\n+    }\n@@ -243,2 +311,3 @@\n-  log_trace(os, container)(\"Memory and Swap Limit is: \" JLONG_FORMAT, swap_limit);\n-  return swap_limit;\n+  log_trace(os, container)(\"Memory and Swap Limit is: %zd\", swap_limit);\n+  result = swap_limit;\n+  return true;\n@@ -249,4 +318,2 @@\n-jlong memory_swap_current_value(CgroupV2Controller* ctrl) {\n-  julong swap_current;\n-  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n-  return (jlong)swap_current;\n+bool memory_swap_current_value(CgroupV2Controller* ctrl, size_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", result);\n@@ -255,5 +322,4 @@\n-jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) {\n-  jlong memory_usage = memory_usage_in_bytes();\n-  if (memory_usage >= 0) {\n-      jlong swap_current = memory_swap_current_value(reader());\n-      return memory_usage + (swap_current >= 0 ? swap_current : 0);\n+ssize_t CgroupV2MemoryController::memory_and_swap_usage_in_bytes(size_t host_mem, size_t host_swap) {\n+  size_t memory_swap_usage = 0;\n+  if (!memory_and_swap_usage_in_bytes(host_mem, host_swap, memory_swap_usage)) {\n+    return -1; \/\/ usage value error\n@@ -261,1 +327,17 @@\n-  return memory_usage; \/\/ not supported or unlimited case\n+  return static_cast<ssize_t>(memory_swap_usage);\n+}\n+\n+bool CgroupV2MemoryController::memory_and_swap_usage_in_bytes(size_t host_mem, size_t host_swap, size_t& result) {\n+  size_t memory_usage = 0;\n+  bool is_ok = memory_usage_in_bytes(memory_usage);\n+  if (!is_ok) {\n+     return false;\n+  }\n+  size_t swap_current = 0;\n+  is_ok = memory_swap_current_value(reader(), swap_current);\n+  if (!is_ok) {\n+    result = memory_usage; \/\/ treat as no swap usage\n+    return true;\n+  }\n+  result = memory_usage + swap_current;\n+  return true;\n@@ -265,3 +347,9 @@\n-jlong memory_limit_value(CgroupV2Controller* ctrl) {\n-  jlong memory_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", memory_limit);\n+bool memory_limit_value(CgroupV2Controller* ctrl, ssize_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", result);\n+}\n+\n+ssize_t CgroupV2MemoryController::read_memory_limit_in_bytes(size_t host_mem) {\n+  ssize_t memory_limit = 0;\n+  if (!read_memory_limit_in_bytes(host_mem, memory_limit)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n@@ -273,1 +361,2 @@\n- * Return the limit of available memory for this process.\n+ * Calculate the limit of available memory for this process. The result will be\n+ * set in the 'result' variable if the function returns true.\n@@ -276,2 +365,2 @@\n- *    memory limit in bytes or\n- *    -1 for unlimited, OSCONTAINER_ERROR for an error\n+ *    true when the limit could be read correctly.\n+ *    false in case of any error.\n@@ -279,2 +368,15 @@\n-jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n-  jlong limit = memory_limit_value(reader());\n+bool CgroupV2MemoryController::read_memory_limit_in_bytes(size_t phys_mem, ssize_t& result) {\n+  ssize_t limit = -1; \/\/ default unlimited\n+  bool is_ok = memory_limit_value(reader(), limit);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"container memory limit failed, using host value %zu\",\n+                              phys_mem);\n+    return false;\n+  }\n+  size_t read_limit = static_cast<size_t>(limit);\n+  ssize_t orig_limit = limit;\n+  bool exceeds_physical_mem = false;\n+  if (read_limit >= phys_mem) {\n+    exceeds_physical_mem = true;\n+    limit = -1; \/\/ reset limit\n+  }\n@@ -285,1 +387,1 @@\n-      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+      log_trace(os, container)(\"Memory Limit is: %zd\", limit);\n@@ -287,15 +389,10 @@\n-  }\n-  if (log_is_enabled(Debug, os, container)) {\n-    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n-    if (limit < 0 || read_limit >= phys_mem) {\n-      const char* reason;\n-      if (limit == -1) {\n-        reason = \"unlimited\";\n-      } else if (limit == OSCONTAINER_ERROR) {\n-        reason = \"failed\";\n-      } else {\n-        assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n-        reason = \"ignored\";\n-      }\n-      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                               reason, limit, phys_mem);\n+    if (orig_limit < 0 || exceeds_physical_mem) {\n+        const char* reason;\n+        if (orig_limit == -1) {\n+          reason = \"unlimited\";\n+        } else {\n+          assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n+          reason = \"ignored\";\n+        }\n+        log_trace(os, container)(\"container memory limit %s: %zd, using host value %zu\",\n+                                 reason, orig_limit, phys_mem);\n@@ -304,1 +401,2 @@\n-  return limit;\n+  result = limit;\n+  return true;\n@@ -308,4 +406,2 @@\n-jlong memory_swap_limit_value(CgroupV2Controller* ctrl) {\n-  jlong swap_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n-  return swap_limit;\n+bool memory_swap_limit_value(CgroupV2Controller* ctrl, ssize_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", value);\n@@ -330,3 +426,8 @@\n-void CgroupV2MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n-  jlong swap_current = memory_swap_current_value(reader());\n-  jlong swap_limit = memory_swap_limit_value(reader());\n+void CgroupV2MemoryController::print_version_specific_info(outputStream* st, size_t phys_mem) {\n+  size_t swap_current_val = 0;\n+  ssize_t swap_current = -1;\n+  if (memory_swap_current_value(reader(), swap_current_val)) {\n+    swap_current = static_cast<ssize_t>(swap_current_val);\n+  }\n+  ssize_t swap_limit = -1;\n+  memory_swap_limit_value(reader(), swap_limit); \/\/ use default of -1 if we have a failure\n@@ -334,2 +435,2 @@\n-  OSContainer::print_container_helper(st, swap_current, \"memory_swap_current_in_bytes\");\n-  OSContainer::print_container_helper(st, swap_limit, \"memory_swap_max_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, swap_current, \"memory_swap_current_in_bytes\", true \/* is_usage *\/);\n+  OSContainer::print_container_helper(st, swap_limit, \"memory_swap_max_limit_in_bytes\", false \/* is_usage *\/);\n@@ -349,1 +450,3 @@\n- * Return the maximum number of tasks available to the process\n+ * Calculate the maximum number of tasks available to the process. Set the\n+ * value in the passed in 'value' reference. The value might be -1 when\n+ * there is no limit.\n@@ -352,3 +455,2 @@\n- *    maximum number of tasks\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    true if the value has been set appropriately\n+ *    false if there was an error\n@@ -356,4 +458,10 @@\n-jlong CgroupV2Subsystem::pids_max() {\n-  jlong pids_max;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(unified(), \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n-  return pids_max;\n+bool CgroupV2Subsystem::pids_max(ssize_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(unified(), \"\/pids.max\", \"Maximum number of tasks\", value);\n+}\n+\n+ssize_t CgroupV2Subsystem::pids_max() {\n+  ssize_t max_pids = 0;\n+  if (!pids_max(max_pids)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n+  return max_pids;\n@@ -364,1 +472,2 @@\n- * The number of tasks currently in the cgroup (and its descendants) of the process\n+ * The number of tasks currently in the cgroup (and its descendants) of the process. Set\n+ * in the passed in 'value' reference.\n@@ -367,2 +476,2 @@\n- *    current number of tasks\n- *    OSCONTAINER_ERROR for not supported\n+ *    true on success\n+ *    false when there was an error\n@@ -370,4 +479,10 @@\n-jlong CgroupV2Subsystem::pids_current() {\n-  julong pids_current;\n-  CONTAINER_READ_NUMBER_CHECKED(unified(), \"\/pids.current\", \"Current number of tasks\", pids_current);\n-  return pids_current;\n+bool CgroupV2Subsystem::pids_current(size_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(unified(), \"\/pids.current\", \"Current number of tasks\", value);\n+}\n+\n+ssize_t CgroupV2Subsystem::pids_current() {\n+  size_t pids_curr = 0;\n+  if (!pids_current(pids_curr)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n+  return static_cast<ssize_t>(pids_curr);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":238,"deletions":123,"binary":false,"changes":361,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+    bool cpu_period(ssize_t& value);\n+    bool cpu_usage_in_micros(size_t& value);\n@@ -65,1 +67,1 @@\n-    jlong cpu_usage_in_micros();\n+    ssize_t cpu_usage_in_micros();\n@@ -90,1 +92,1 @@\n-    jlong cpu_usage_in_micros() override {\n+    ssize_t cpu_usage_in_micros() override {\n@@ -113,0 +115,10 @@\n+    bool read_memory_limit_in_bytes(size_t phys_mem, ssize_t& result);\n+    bool memory_and_swap_limit_in_bytes(size_t phys_mem, size_t host_swap, ssize_t& result);\n+    bool memory_and_swap_usage_in_bytes(size_t host_mem, size_t host_swap, size_t& result);\n+    bool memory_soft_limit_in_bytes(size_t phys_mem, ssize_t& value);\n+    bool memory_throttle_limit_in_bytes(ssize_t& value);\n+    bool memory_usage_in_bytes(size_t& value);\n+    bool memory_max_usage_in_bytes(size_t& value);\n+    bool rss_usage_in_bytes(size_t& value);\n+    bool cache_usage_in_bytes(size_t& value);\n+\n@@ -117,10 +129,10 @@\n-    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swp) override;\n-    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swp) override;\n-    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_throttle_limit_in_bytes() override;\n-    jlong memory_usage_in_bytes() override;\n-    jlong memory_max_usage_in_bytes() override;\n-    jlong rss_usage_in_bytes() override;\n-    jlong cache_usage_in_bytes() override;\n-    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    ssize_t read_memory_limit_in_bytes(size_t host_mem) override;\n+    ssize_t memory_and_swap_limit_in_bytes(size_t host_mem, size_t host_swap) override;\n+    ssize_t memory_and_swap_usage_in_bytes(size_t host_mem, size_t host_swap) override;\n+    ssize_t memory_soft_limit_in_bytes(size_t host_mem) override;\n+    ssize_t memory_throttle_limit_in_bytes() override;\n+    ssize_t memory_usage_in_bytes() override;\n+    ssize_t memory_max_usage_in_bytes() override;\n+    ssize_t rss_usage_in_bytes() override;\n+    ssize_t cache_usage_in_bytes() override;\n+    void print_version_specific_info(outputStream* st, size_t host_mem) override;\n@@ -154,0 +166,2 @@\n+    bool pids_max(ssize_t& value);\n+    bool pids_current(size_t& value);\n@@ -163,2 +177,2 @@\n-    jlong pids_max() override;\n-    jlong pids_current() override;\n+    ssize_t pids_max() override;\n+    ssize_t pids_current() override;\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-jlong OSContainer::memory_limit_in_bytes() {\n+ssize_t OSContainer::memory_limit_in_bytes() {\n@@ -108,1 +108,3 @@\n-  return cgroup_subsystem->memory_limit_in_bytes();\n+  ssize_t result = cgroup_subsystem->memory_limit_in_bytes();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -111,1 +113,1 @@\n-jlong OSContainer::memory_and_swap_limit_in_bytes() {\n+ssize_t OSContainer::memory_and_swap_limit_in_bytes() {\n@@ -113,1 +115,3 @@\n-  return cgroup_subsystem->memory_and_swap_limit_in_bytes();\n+  ssize_t result = cgroup_subsystem->memory_and_swap_limit_in_bytes();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -116,1 +120,1 @@\n-jlong OSContainer::memory_and_swap_usage_in_bytes() {\n+ssize_t OSContainer::memory_and_swap_usage_in_bytes() {\n@@ -118,1 +122,3 @@\n-  return cgroup_subsystem->memory_and_swap_usage_in_bytes();\n+  ssize_t result = cgroup_subsystem->memory_and_swap_usage_in_bytes();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -121,1 +127,1 @@\n-jlong OSContainer::memory_soft_limit_in_bytes() {\n+ssize_t OSContainer::memory_soft_limit_in_bytes() {\n@@ -123,1 +129,3 @@\n-  return cgroup_subsystem->memory_soft_limit_in_bytes();\n+  ssize_t result = cgroup_subsystem->memory_soft_limit_in_bytes();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -126,1 +134,1 @@\n-jlong OSContainer::memory_throttle_limit_in_bytes() {\n+ssize_t OSContainer::memory_throttle_limit_in_bytes() {\n@@ -128,1 +136,3 @@\n-  return cgroup_subsystem->memory_throttle_limit_in_bytes();\n+  ssize_t result = cgroup_subsystem->memory_throttle_limit_in_bytes();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -131,1 +141,1 @@\n-jlong OSContainer::memory_usage_in_bytes() {\n+ssize_t OSContainer::memory_usage_in_bytes() {\n@@ -133,1 +143,3 @@\n-  return cgroup_subsystem->memory_usage_in_bytes();\n+  ssize_t result = cgroup_subsystem->memory_usage_in_bytes();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -136,1 +148,1 @@\n-jlong OSContainer::memory_max_usage_in_bytes() {\n+ssize_t OSContainer::memory_max_usage_in_bytes() {\n@@ -138,1 +150,3 @@\n-  return cgroup_subsystem->memory_max_usage_in_bytes();\n+  ssize_t result = cgroup_subsystem->memory_max_usage_in_bytes();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -141,1 +155,1 @@\n-jlong OSContainer::rss_usage_in_bytes() {\n+ssize_t OSContainer::rss_usage_in_bytes() {\n@@ -143,1 +157,3 @@\n-  return cgroup_subsystem->rss_usage_in_bytes();\n+  ssize_t result = cgroup_subsystem->rss_usage_in_bytes();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -146,1 +162,1 @@\n-jlong OSContainer::cache_usage_in_bytes() {\n+ssize_t OSContainer::cache_usage_in_bytes() {\n@@ -148,1 +164,3 @@\n-  return cgroup_subsystem->cache_usage_in_bytes();\n+  ssize_t result = cgroup_subsystem->cache_usage_in_bytes();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -168,1 +186,3 @@\n-  return cgroup_subsystem->active_processor_count();\n+  int result = cgroup_subsystem->active_processor_count();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -173,1 +193,3 @@\n-  return cgroup_subsystem->cpu_quota();\n+  int result = cgroup_subsystem->cpu_quota();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -178,1 +200,3 @@\n-  return cgroup_subsystem->cpu_period();\n+  int result = cgroup_subsystem->cpu_period();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -183,1 +207,3 @@\n-  return cgroup_subsystem->cpu_shares();\n+  int result = cgroup_subsystem->cpu_shares();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -186,1 +212,1 @@\n-jlong OSContainer::cpu_usage_in_micros() {\n+ssize_t OSContainer::cpu_usage_in_micros() {\n@@ -188,1 +214,3 @@\n-  return cgroup_subsystem->cpu_usage_in_micros();\n+  ssize_t result = cgroup_subsystem->cpu_usage_in_micros();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -191,1 +219,1 @@\n-jlong OSContainer::pids_max() {\n+ssize_t OSContainer::pids_max() {\n@@ -193,1 +221,3 @@\n-  return cgroup_subsystem->pids_max();\n+  ssize_t result = cgroup_subsystem->pids_max();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -196,1 +226,1 @@\n-jlong OSContainer::pids_current() {\n+ssize_t OSContainer::pids_current() {\n@@ -198,1 +228,3 @@\n-  return cgroup_subsystem->pids_current();\n+  ssize_t result = cgroup_subsystem->pids_current();\n+  assert(result >= -1, \"must be\");\n+  return result;\n@@ -201,1 +233,2 @@\n-void OSContainer::print_container_helper(outputStream* st, jlong j, const char* metrics) {\n+void OSContainer::print_container_helper(outputStream* st, ssize_t j, const char* metrics, bool is_usage) {\n+  assert(j >= -1, \"invariant\");\n@@ -205,1 +238,1 @@\n-      st->print_cr(UINT64_FORMAT \" k\", uint64_t(j) \/ K);\n+      st->print_cr(\"%zd k\", (ssize_t)(j \/ K));\n@@ -207,1 +240,1 @@\n-      st->print_cr(UINT64_FORMAT, uint64_t(j));\n+      st->print_cr(\"%zd\", j);\n@@ -210,1 +243,3 @@\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    \/\/ Usages are never unlimited (or -1). Only in the error case.\n+    \/\/ For limits we might have -1 for either: unlimited or error case.\n+    st->print(\"%s\", (is_usage ? \"unavailable\" : \"unlimited or unavailable\"));\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":67,"deletions":32,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  static void print_container_helper(outputStream* st, jlong j, const char* metrics);\n+  static void print_container_helper(outputStream* st, ssize_t j, const char* metrics, bool is_usage);\n@@ -53,9 +53,9 @@\n-  static jlong memory_limit_in_bytes();\n-  static jlong memory_and_swap_limit_in_bytes();\n-  static jlong memory_and_swap_usage_in_bytes();\n-  static jlong memory_soft_limit_in_bytes();\n-  static jlong memory_throttle_limit_in_bytes();\n-  static jlong memory_usage_in_bytes();\n-  static jlong memory_max_usage_in_bytes();\n-  static jlong rss_usage_in_bytes();\n-  static jlong cache_usage_in_bytes();\n+  static ssize_t memory_limit_in_bytes();\n+  static ssize_t memory_and_swap_limit_in_bytes();\n+  static ssize_t memory_and_swap_usage_in_bytes();\n+  static ssize_t memory_soft_limit_in_bytes();\n+  static ssize_t memory_throttle_limit_in_bytes();\n+  static ssize_t memory_usage_in_bytes();\n+  static ssize_t memory_max_usage_in_bytes();\n+  static ssize_t rss_usage_in_bytes();\n+  static ssize_t cache_usage_in_bytes();\n@@ -73,1 +73,1 @@\n-  static jlong cpu_usage_in_micros();\n+  static ssize_t cpu_usage_in_micros();\n@@ -75,2 +75,2 @@\n-  static jlong pids_max();\n-  static jlong pids_current();\n+  static ssize_t pids_max();\n+  static ssize_t pids_current();\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -217,2 +217,1 @@\n-julong os::Linux::available_memory_in_container() {\n-  julong avail_mem = static_cast<julong>(-1L);\n+bool os::Linux::available_memory_in_container(size_t& value) {\n@@ -220,2 +219,2 @@\n-    jlong mem_limit = OSContainer::memory_limit_in_bytes();\n-    jlong mem_usage;\n+    ssize_t mem_limit = OSContainer::memory_limit_in_bytes();\n+    ssize_t mem_usage;\n@@ -223,1 +222,1 @@\n-      log_debug(os, container)(\"container memory usage failed: \" JLONG_FORMAT \", using host value\", mem_usage);\n+      log_debug(os, container)(\"container memory usage failed: %zd, using host value\", mem_usage);\n@@ -226,1 +225,2 @@\n-      avail_mem = mem_limit > mem_usage ? (julong)mem_limit - (julong)mem_usage : 0;\n+      value = mem_limit > mem_usage ? (size_t)mem_limit - (size_t)mem_usage : 0;\n+      return true;\n@@ -229,1 +229,1 @@\n-  return avail_mem;\n+  return false;\n@@ -237,4 +237,4 @@\n-  julong avail_mem = available_memory_in_container();\n-  if (avail_mem != static_cast<julong>(-1L)) {\n-    log_trace(os)(\"available container memory: \" JULONG_FORMAT, avail_mem);\n-    value = static_cast<size_t>(avail_mem);\n+  size_t avail_mem = 0;\n+  if (available_memory_in_container(avail_mem)) {\n+    log_trace(os)(\"available container memory: %zu\", avail_mem);\n+    value = avail_mem;\n@@ -244,0 +244,1 @@\n+  bool found_available_mem = false;\n@@ -248,1 +249,1 @@\n-      if (fscanf(fp, \"MemAvailable: \" JULONG_FORMAT \" kB\", &avail_mem) == 1) {\n+      if (fscanf(fp, \"MemAvailable: %zu kB\", &avail_mem) == 1) {\n@@ -250,0 +251,1 @@\n+        found_available_mem = true;\n@@ -255,1 +257,3 @@\n-  if (avail_mem == static_cast<julong>(-1L)) {\n+  \/\/ Only enter the free memory block if we\n+  \/\/ haven't found the available memory\n+  if (!found_available_mem) {\n@@ -260,1 +264,1 @@\n-    avail_mem = static_cast<julong>(free_mem);\n+    avail_mem = free_mem;\n@@ -262,2 +266,2 @@\n-  log_trace(os)(\"available memory: \" JULONG_FORMAT, avail_mem);\n-  value = static_cast<size_t>(avail_mem);\n+  log_trace(os)(\"available memory: %zu\", avail_mem);\n+  value = avail_mem;\n@@ -274,4 +278,4 @@\n-  julong free_mem = available_memory_in_container();\n-  if (free_mem != static_cast<julong>(-1L)) {\n-    log_trace(os)(\"free container memory: \" JULONG_FORMAT, free_mem);\n-    value = static_cast<size_t>(free_mem);\n+  size_t free_mem = 0;\n+  if (available_memory_in_container(free_mem)) {\n+    log_trace(os)(\"free container memory: %zu\", free_mem);\n+    value = free_mem;\n@@ -285,3 +289,3 @@\n-  free_mem = (julong)si.freeram * si.mem_unit;\n-  log_trace(os)(\"free memory: \" JULONG_FORMAT, free_mem);\n-  value = static_cast<size_t>(free_mem);\n+  free_mem = static_cast<size_t>(si.freeram * si.mem_unit);\n+  log_trace(os)(\"free memory: %zu\", free_mem);\n+  value = free_mem;\n@@ -293,2 +297,2 @@\n-    jlong memory_and_swap_limit_in_bytes = OSContainer::memory_and_swap_limit_in_bytes();\n-    jlong memory_limit_in_bytes = OSContainer::memory_limit_in_bytes();\n+    ssize_t memory_and_swap_limit_in_bytes = OSContainer::memory_and_swap_limit_in_bytes();\n+    ssize_t memory_limit_in_bytes = OSContainer::memory_limit_in_bytes();\n@@ -331,2 +335,5 @@\n-    jlong mem_swap_limit = OSContainer::memory_and_swap_limit_in_bytes();\n-    jlong mem_limit = OSContainer::memory_limit_in_bytes();\n+    \/\/ We are using jlong for various delta calculations since negative values\n+    \/\/ might be out of range for ssize_t (which has range [-1,SSIZE_MAX])\n+\n+    ssize_t mem_swap_limit = OSContainer::memory_and_swap_limit_in_bytes();\n+    ssize_t mem_limit = OSContainer::memory_limit_in_bytes();\n@@ -339,2 +346,2 @@\n-      jlong mem_swap_usage = OSContainer::memory_and_swap_usage_in_bytes();\n-      jlong mem_usage = OSContainer::memory_usage_in_bytes();\n+      ssize_t mem_swap_usage = OSContainer::memory_and_swap_usage_in_bytes();\n+      ssize_t mem_usage = OSContainer::memory_usage_in_bytes();\n@@ -351,2 +358,2 @@\n-    log_trace(os,container)(\"os::free_swap_space: container_swap_limit=\" JLONG_FORMAT\n-                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: %zu\",\n+    log_trace(os,container)(\"os::free_swap_space: container_swap_limit=%zd\"\n+                            \" container_mem_limit=%zd returning host value: %zu\",\n@@ -361,1 +368,1 @@\n-    jlong mem_limit;\n+    ssize_t mem_limit;\n@@ -363,1 +370,1 @@\n-      log_trace(os)(\"total container memory: \" JLONG_FORMAT, mem_limit);\n+      log_trace(os)(\"total container memory: %zd\", mem_limit);\n@@ -517,1 +524,1 @@\n-julong os::Linux::host_swap() {\n+size_t os::Linux::host_swap() {\n@@ -520,1 +527,1 @@\n-  return (julong)(si.totalswap * si.mem_unit);\n+  return static_cast<size_t>((si.totalswap * si.mem_unit));\n@@ -2487,1 +2494,1 @@\n-    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no quota\");\n+    st->print_cr(\"no quota or unavailable\");\n@@ -2495,1 +2502,1 @@\n-    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no period\");\n+    st->print_cr(\"no period or unavailable\");\n@@ -2503,1 +2510,1 @@\n-    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no shares\");\n+    st->print_cr(\"no shares or unavailable\");\n@@ -2506,1 +2513,1 @@\n-  jlong j = OSContainer::cpu_usage_in_micros();\n+  ssize_t j = OSContainer::cpu_usage_in_micros();\n@@ -2509,1 +2516,1 @@\n-    st->print_cr(JLONG_FORMAT, j);\n+    st->print_cr(\"%zd\", j);\n@@ -2511,1 +2518,1 @@\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"no usage\");\n+    st->print_cr(\"unavailable\");\n@@ -2514,8 +2521,8 @@\n-  OSContainer::print_container_helper(st, OSContainer::memory_limit_in_bytes(), \"memory_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_and_swap_limit_in_bytes(), \"memory_and_swap_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_soft_limit_in_bytes(), \"memory_soft_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_throttle_limit_in_bytes(), \"memory_throttle_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_usage_in_bytes(), \"memory_usage_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_max_usage_in_bytes(), \"memory_max_usage_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::rss_usage_in_bytes(), \"rss_usage_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::cache_usage_in_bytes(), \"cache_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, OSContainer::memory_limit_in_bytes(), \"memory_limit_in_bytes\", false \/* is_usage *\/);\n+  OSContainer::print_container_helper(st, OSContainer::memory_and_swap_limit_in_bytes(), \"memory_and_swap_limit_in_bytes\", false \/* is_usage *\/);\n+  OSContainer::print_container_helper(st, OSContainer::memory_soft_limit_in_bytes(), \"memory_soft_limit_in_bytes\", false \/* is_usage *\/);\n+  OSContainer::print_container_helper(st, OSContainer::memory_throttle_limit_in_bytes(), \"memory_throttle_limit_in_bytes\", false \/* is_usage *\/);\n+  OSContainer::print_container_helper(st, OSContainer::memory_usage_in_bytes(), \"memory_usage_in_bytes\", true \/* is_usage *\/);\n+  OSContainer::print_container_helper(st, OSContainer::memory_max_usage_in_bytes(), \"memory_max_usage_in_bytes\", true \/* is_usage *\/);\n+  OSContainer::print_container_helper(st, OSContainer::rss_usage_in_bytes(), \"rss_usage_in_bytes\", true \/* is_usage *\/);\n+  OSContainer::print_container_helper(st, OSContainer::cache_usage_in_bytes(), \"cache_usage_in_bytes\", true \/* is_usage *\/);\n@@ -2528,1 +2535,1 @@\n-    st->print_cr(JLONG_FORMAT, j);\n+    st->print_cr(\"%zd\", j);\n@@ -2530,1 +2537,1 @@\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    st->print_cr(\"unlimited or unavailable\");\n@@ -2536,1 +2543,1 @@\n-    st->print_cr(JLONG_FORMAT, j);\n+    st->print_cr(\"%zd\", j);\n@@ -2538,3 +2545,1 @@\n-    if (j == OSCONTAINER_ERROR) {\n-      st->print_cr(\"not supported\");\n-    }\n+    st->print_cr(\"unavailable\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":60,"deletions":55,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  static julong available_memory_in_container();\n+  static bool available_memory_in_container(size_t& value);\n@@ -121,1 +121,1 @@\n-  static julong host_swap();\n+  static size_t host_swap();\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -424,1 +424,1 @@\n-  return os::Linux::host_swap();\n+  return static_cast<jlong>(os::Linux::host_swap());\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2522,1 +2522,1 @@\n-  LINUX_ONLY(return (jlong)os::Linux::host_swap();)\n+  LINUX_ONLY(return static_cast<jlong>(os::Linux::host_swap());)\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong x = bad;\n+  constexpr size_t bad = 0xBAD;\n+  size_t x = bad;\n@@ -111,1 +111,1 @@\n-  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -117,1 +117,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -123,1 +123,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -129,1 +129,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -135,1 +135,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -153,2 +153,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong x = bad;\n+  constexpr size_t bad = 0xBAD;\n+  size_t x = bad;\n@@ -157,1 +157,1 @@\n-  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -159,1 +159,1 @@\n-  EXPECT_EQ((julong)100, x);\n+  EXPECT_EQ((size_t)100, x);\n@@ -163,1 +163,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -165,1 +165,1 @@\n-  EXPECT_EQ((julong)111, x);\n+  EXPECT_EQ((size_t)111, x);\n@@ -169,1 +169,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -171,1 +171,1 @@\n-  EXPECT_EQ((julong)111, x);\n+  EXPECT_EQ((size_t)111, x);\n@@ -175,1 +175,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -177,1 +177,1 @@\n-  EXPECT_EQ((julong)133, x);\n+  EXPECT_EQ((size_t)133, x);\n@@ -181,1 +181,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -183,1 +183,1 @@\n-  EXPECT_EQ((julong)333, x);\n+  EXPECT_EQ((size_t)333, x);\n@@ -187,1 +187,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -189,1 +189,1 @@\n-  EXPECT_EQ((julong)1, x);\n+  EXPECT_EQ((size_t)1, x);\n@@ -198,2 +198,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong a = bad;\n+  constexpr size_t bad = 0xBAD;\n+  size_t a = bad;\n@@ -201,1 +201,1 @@\n-  bool is_ok = null_path_controller->read_number(test_file_path, &a);\n+  bool is_ok = null_path_controller->read_number(test_file_path, a);\n@@ -224,3 +224,3 @@\n-  constexpr julong bad = 0xBAD;\n-  julong result = bad;\n-  bool is_ok = unknown_path_ctrl->read_number(test_file_path, &result);\n+  constexpr size_t bad = 0xBAD;\n+  size_t result = bad;\n+  bool is_ok = unknown_path_ctrl->read_number(test_file_path, result);\n@@ -235,2 +235,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong a = bad;\n+  constexpr size_t bad = 0xBAD;\n+  size_t a = bad;\n@@ -238,1 +238,1 @@\n-  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, a);\n@@ -246,1 +246,1 @@\n-  constexpr julong bad = 0xBAD;\n+  constexpr size_t bad = 0xBAD;\n@@ -255,2 +255,2 @@\n-  julong foo = bad;\n-  bool ok = controller->read_number(base_with_slash, &foo);\n+  size_t foo = bad;\n+  bool ok = controller->read_number(base_with_slash, foo);\n@@ -258,1 +258,1 @@\n-  EXPECT_EQ((julong)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+  EXPECT_EQ((size_t)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n@@ -264,1 +264,1 @@\n-  ok = controller->read_number(base_with_slash, &foo);\n+  ok = controller->read_number(base_with_slash, foo);\n@@ -266,1 +266,1 @@\n-  EXPECT_EQ((jlong)-1, (jlong)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+  EXPECT_EQ((ssize_t)-1, (ssize_t)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n@@ -270,1 +270,1 @@\n-  ok = controller->read_number(base_with_slash, &foo);\n+  ok = controller->read_number(base_with_slash, foo);\n@@ -276,1 +276,1 @@\n-  jlong result = -10;\n+  ssize_t result = 0;\n@@ -278,1 +278,1 @@\n-  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  ok = controller->read_number_handle_max(base_with_slash, result);\n@@ -280,1 +280,1 @@\n-  EXPECT_EQ((jlong)-1, result) << \"'max' means unlimited (-1)\";\n+  EXPECT_EQ((ssize_t)-1, result) << \"'max' means unlimited (-1)\";\n@@ -282,1 +282,1 @@\n-  result = -10;\n+  result = 0;\n@@ -284,1 +284,1 @@\n-  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  ok = controller->read_number_handle_max(base_with_slash, result);\n@@ -286,1 +286,1 @@\n-  EXPECT_EQ((jlong)11114, result) << \"Incorrect result\";\n+  EXPECT_EQ((ssize_t)11114, result) << \"Incorrect result\";\n@@ -288,1 +288,4 @@\n-  result = -10;\n+  result = 0;\n+  \/\/ This is a contrived test case not matching cgroup interface files\n+  \/\/ in the wild where numbers are positive. The value is deliberately\n+  \/\/ outside the ssize_t range. Yet it should work\n@@ -290,1 +293,1 @@\n-  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  ok = controller->read_number_handle_max(base_with_slash, result);\n@@ -292,1 +295,1 @@\n-  EXPECT_EQ((jlong)-51114, result) << \"Incorrect result\";\n+  EXPECT_EQ((ssize_t)-51114, result) << \"Incorrect result\";\n@@ -375,2 +378,2 @@\n-  jlong result = -10;\n-  bool ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  ssize_t result = 0;\n+  bool ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, result);\n@@ -378,1 +381,1 @@\n-  EXPECT_EQ((jlong)-1, result) << \"max should be unlimited (-1)\";\n+  EXPECT_EQ((ssize_t)-1, result) << \"max should be unlimited (-1)\";\n@@ -380,2 +383,2 @@\n-  result = -10;\n-  ok = controller->read_numerical_tuple_value(base_with_slash, false \/* use_first *\/, &result);\n+  result = 0;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, false \/* use_first *\/, result);\n@@ -383,1 +386,1 @@\n-  EXPECT_EQ((jlong)10000, result);\n+  EXPECT_EQ((ssize_t)10000, result);\n@@ -387,2 +390,2 @@\n-  result = -10;\n-  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  result = 0;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, result);\n@@ -390,1 +393,1 @@\n-  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+  EXPECT_EQ((ssize_t)0, result) << \"result value should be unchanged\";\n@@ -393,2 +396,2 @@\n-  result = -10;\n-  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  result = 0;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, result);\n@@ -396,1 +399,1 @@\n-  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+  EXPECT_EQ((ssize_t)0, result) << \"result value should be unchanged\";\n@@ -410,2 +413,2 @@\n-  julong a = 0xBAD;\n-  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  size_t a = 0xBAD;\n+  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, a);\n@@ -413,1 +416,1 @@\n-  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  EXPECT_EQ((size_t)0xBAD, a) << \"Expected untouched scan value\";\n@@ -420,2 +423,2 @@\n-  julong a = 0xBAD;\n-  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, &a);\n+  size_t a = 0xBAD;\n+  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, a);\n@@ -423,1 +426,1 @@\n-  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  EXPECT_EQ((size_t)0xBAD, a) << \"Expected untouched scan value\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":67,"deletions":64,"binary":false,"changes":131,"status":"modified"}]}