{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zLock.inline.hpp\"\n@@ -48,0 +49,1 @@\n+    _shared_small_page(nullptr),\n@@ -49,1 +51,1 @@\n-    _shared_small_page(nullptr) {}\n+    _medium_page_alloc_lock() {}\n@@ -80,0 +82,7 @@\n+zaddress ZObjectAllocator::alloc_object_in_page_atomic(ZPage* page, size_t size) {\n+  if (page == nullptr) {\n+    return zaddress::null;\n+  }\n+  return page->alloc_object_atomic(size);\n+}\n+\n@@ -85,1 +94,0 @@\n-  zaddress addr = zaddress::null;\n@@ -87,4 +95,1 @@\n-\n-  if (page != nullptr) {\n-    addr = page->alloc_object_atomic(size);\n-  }\n+  zaddress addr = alloc_object_in_page_atomic(page, size);\n@@ -129,0 +134,33 @@\n+zaddress ZObjectAllocator::alloc_object_in_medium_page(size_t size,\n+                                                       ZAllocationFlags flags) {\n+  ZPage** shared_medium_page = _shared_medium_page.addr();\n+  ZPage* page = Atomic::load_acquire(shared_medium_page);\n+\n+  zaddress addr = alloc_object_in_page_atomic(page, size);\n+\n+  if (is_null(addr)) {\n+    \/\/ When a new medium page is required, we synchronize the allocation\n+    \/\/ of the new page using a lock. This is to avoid having multiple\n+    \/\/ threads requesting a medium page from the page cache when we know\n+    \/\/ only one of the will succeed in installing the page at this layer.\n+    ZLocker<ZConditionLock> locker(&_medium_page_alloc_lock);\n+\n+    \/\/ When holding the lock we can't allow the page allocator to stall,\n+    \/\/ which in the common case it won't. The page allocation is thus done\n+    \/\/ in a non-blocking fashion and only if this fails we below (while not\n+    \/\/ holding the lock) do the blocking page allocation.\n+    ZAllocationFlags non_blocking_flags = flags;\n+    non_blocking_flags.set_non_blocking();\n+\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, non_blocking_flags);\n+  }\n+\n+  if (is_null(addr) && !flags.non_blocking()) {\n+    \/\/ The above allocation attempts failed and this allocation should stall\n+    \/\/ until memory is available. Redo the allocation with blocking enabled.\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, flags);\n+  }\n+\n+  return addr;\n+}\n+\n@@ -144,1 +182,1 @@\n-  return alloc_object_in_shared_page(_shared_medium_page.addr(), ZPageType::medium, ZPageSizeMedium, size, flags);\n+  return alloc_object_in_medium_page(size, flags);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":45,"deletions":7,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zLock.hpp\"\n@@ -42,1 +43,0 @@\n-  ZContended<ZPage*> _shared_medium_page;\n@@ -44,0 +44,2 @@\n+  ZContended<ZPage*> _shared_medium_page;\n+  ZConditionLock     _medium_page_alloc_lock;\n@@ -59,0 +61,3 @@\n+  zaddress alloc_object_in_medium_page(size_t size,\n+                                       ZAllocationFlags flags);\n+\n@@ -63,0 +68,1 @@\n+  zaddress alloc_object_in_page_atomic(ZPage* page, size_t size);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}