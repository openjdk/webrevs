{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jfr.Description;\n@@ -37,0 +38,1 @@\n+@Description(\"Measures the approximate time it takes for a method to execute, including all delays, not just CPU processing time\")\n@@ -46,0 +48,1 @@\n+    @Description(\"The value may be missing (Long.MIN_VALUE) if the clock-resolution is too low to establish a minimum time\")\n@@ -50,0 +53,1 @@\n+    @Description(\"The value may be missing (Long.MIN_VALUE) if the clock-resolution is too low to establish an average time\")\n@@ -54,0 +58,1 @@\n+    @Description(\"The value may be missing (Long.MIN_VALUE) if the clock-resolution is too low to establish a maximum time\")\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/MethodTimingEvent.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -474,1 +474,1 @@\n-table = \"COLUMN 'Timed Method', 'Invocations', 'Min. Time', 'Max. Time', 'Average Time'\n+table = \"COLUMN 'Timed Method', 'Invocations', 'Minimum Time', 'Average Time', 'Maximum Time'\n@@ -476,1 +476,1 @@\n-         SELECT LAST_BATCH(method) AS M, LAST_BATCH(invocations), LAST_BATCH(minimum), LAST_BATCH(maximum), LAST_BATCH(average)\n+         SELECT LAST_BATCH(method) AS M, LAST_BATCH(invocations), LAST_BATCH(minimum), LAST_BATCH(average), LAST_BATCH(maximum)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+    private static final long MISSING = Long.MIN_VALUE;\n@@ -63,1 +64,0 @@\n-                long average = invocations == 0 ? Long.MIN_VALUE : time \/ invocations;\n@@ -65,3 +65,0 @@\n-                if (min == Long.MAX_VALUE) {\n-                    min = Long.MIN_VALUE; \/\/ Signals that the value is missing\n-                }\n@@ -69,1 +66,15 @@\n-                MethodTimingEvent.commit(timestamp, methodId, invocations, min, average, max);\n+                if (time == 0 || invocations == 0) {\n+                    \/\/ If time is zero, it's a low resolution clock and more invocations are needed.\n+                    MethodTimingEvent.commit(timestamp, methodId, invocations, MISSING, MISSING, MISSING);\n+                } else {\n+                    long average = (time + invocations \/ 2) \/ invocations;\n+                    if (min == Long.MAX_VALUE) {\n+                        min = average;\n+                    }\n+                    if (max == Long.MIN_VALUE) {\n+                        min = average;\n+                    }\n+                    min = Math.min(min, average);\n+                    max = Math.max(max, average);\n+                    MethodTimingEvent.commit(timestamp, methodId, invocations, min, average, max);\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/TimedClass.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+        if (duration == 0) {\n+            return; \/\/ Ignore data due to low-resolution clock\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/TimedMethod.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}