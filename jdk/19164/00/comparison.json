{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import sun.util.logging.PlatformLogger;\n@@ -76,0 +75,1 @@\n+        private final TreeSet<String> linkerTypes = new TreeSet<>();\n@@ -90,0 +90,6 @@\n+        HolderClassBuilder addLinkerType(String methodType) {\n+            validateMethodType(methodType);\n+            linkerTypes.add(methodType);\n+            return this;\n+        }\n+\n@@ -133,1 +139,1 @@\n-            \/\/ The invoker type to ask for is retrieved by removing the first\n+            \/\/ The linker type to ask for is retrieved by removing the first\n@@ -135,0 +141,16 @@\n+            MethodType[] linkerMethodTypes = new MethodType[linkerTypes.size()];\n+            index = 0;\n+            for (String linkerType : linkerTypes) {\n+                MethodType mt = asMethodType(linkerType);\n+                final int lastParam = mt.parameterCount() - 1;\n+                if (!checkLinkerTypeParams(mt)) {\n+                    throw new RuntimeException(\n+                            \"Linker type parameter must start and end with Object: \" + linkerType);\n+                }\n+                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                linkerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+                index++;\n+            }\n+\n+            \/\/ The invoker type to ask for is retrieved by removing the first\n+            \/\/ argument, which needs to be of Object.class\n@@ -139,1 +161,0 @@\n-                final int lastParam = mt.parameterCount() - 1;\n@@ -142,1 +163,1 @@\n-                            \"Invoker type parameter must start and end with Object: \" + invokerType);\n+                            \"Invoker type parameter must start with 2 Objects: \" + invokerType);\n@@ -144,2 +165,1 @@\n-                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n-                invokerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+                invokerMethodTypes[index] = mt.dropParameterTypes(0, 2);\n@@ -174,1 +194,1 @@\n-                            invokerMethodTypes, callSiteMethodTypes));\n+                            linkerMethodTypes, invokerMethodTypes, callSiteMethodTypes));\n@@ -210,0 +230,6 @@\n+            return (mt.parameterCount() >= 2 &&\n+                    mt.parameterType(0) == Object.class &&\n+                    mt.parameterType(1) == Object.class);\n+        }\n+\n+        public static boolean checkLinkerTypeParams(MethodType mt) {\n@@ -323,0 +349,3 @@\n+                                } else if (parts[2].endsWith(\"nvoker\")) {\n+                                    \/\/ MH.exactInvoker exactInvoker MH.invoker invoker\n+                                    builder.addInvokerType(methodType);\n@@ -324,8 +353,1 @@\n-                                    MethodType mt = HolderClassBuilder.asMethodType(methodType);\n-                                    \/\/ Work around JDK-8327499\n-                                    if (HolderClassBuilder.checkInvokerTypeParams(mt)) {\n-                                        builder.addInvokerType(methodType);\n-                                    } else {\n-                                        PlatformLogger.getLogger(\"java.lang.invoke\")\n-                                                .warning(\"Invalid LF_RESOLVE \" + parts[1] + \" \" + parts[2] + \" \" + parts[3]);\n-                                    }\n+                                    builder.addLinkerType(methodType);\n@@ -468,2 +490,2 @@\n-     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n-     * and {@code callSiteMethodTypes}.\n+     * the invoker forms for the set of supplied {@code linkerMethodTypes}\n+     * {@code invokerMethodTypes}, and {@code callSiteMethodTypes}.\n@@ -472,1 +494,2 @@\n-            MethodType[] invokerMethodTypes, MethodType[] callSiteMethodTypes) {\n+            MethodType[] linkerMethodTypes, MethodType[] invokerMethodTypes,\n+            MethodType[] callSiteMethodTypes) {\n@@ -477,2 +500,2 @@\n-        int[] types = {\n-            MethodTypeForm.LF_EX_LINKER,\n+\n+        int[] invokerTypes = {\n@@ -480,2 +503,1 @@\n-            MethodTypeForm.LF_GEN_LINKER,\n-            MethodTypeForm.LF_GEN_INVOKER\n+            MethodTypeForm.LF_GEN_INVOKER,\n@@ -484,1 +506,1 @@\n-        for (int i = 0; i < invokerMethodTypes.length; i++) {\n+        for (MethodType methodType : invokerMethodTypes) {\n@@ -486,3 +508,3 @@\n-            if (dedupSet.add(invokerMethodTypes[i])) {\n-                for (int type : types) {\n-                    LambdaForm invokerForm = Invokers.invokeHandleForm(invokerMethodTypes[i],\n+            if (dedupSet.add(methodType)) {\n+                for (int type : invokerTypes) {\n+                    LambdaForm invokerForm = Invokers.invokeHandleForm(methodType,\n@@ -496,0 +518,18 @@\n+        int[] linkerTypes = {\n+                MethodTypeForm.LF_EX_LINKER,\n+                MethodTypeForm.LF_GEN_LINKER,\n+        };\n+\n+        dedupSet = new HashSet<>();\n+        for (MethodType methodType : linkerMethodTypes) {\n+            \/\/ generate methods representing linkers of the specified type\n+            if (dedupSet.add(methodType)) {\n+                for (int type : linkerTypes) {\n+                    LambdaForm linkerForm = Invokers.invokeHandleForm(methodType,\n+                            \/*customized*\/false, type);\n+                    forms.add(linkerForm);\n+                    names.add(linkerForm.kind.defaultLambdaName);\n+                }\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":66,"deletions":26,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.MethodTypeDesc;\n@@ -32,0 +34,1 @@\n+import org.testng.Assert;\n@@ -40,1 +43,4 @@\n- \/*\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+\n+\/*\n@@ -42,1 +48,1 @@\n- * @bug 8252919\n+ * @bug 8252919 8327499\n@@ -125,0 +131,41 @@\n+    @Test\n+    public static void testInvokers() throws IOException {\n+        var fileString = \"[LF_RESOLVE] java.lang.invoke.Invokers$Holder invoker L3I_L (fail)\";\n+        Path invokersTrace = Files.createTempFile(\"invokers\", \"trace\");\n+        Files.writeString(invokersTrace, fileString, Charset.defaultCharset());\n+        Result result = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(helper.createNewImageDir(\"jli-invokers\"))\n+                .option(\"--generate-jli-classes=@\" + invokersTrace.toString())\n+                .addMods(\"java.base\")\n+                .call();\n+\n+        var image = result.assertSuccess();\n+        var targetMtd = MethodTypeDesc.of(CD_Object, CD_Object, CD_Object, CD_Object, CD_int);\n+\n+        validateHolderClasses(image);\n+        JImageValidator.validate(image.resolve(\"lib\").resolve(\"modules\"),\n+                List.of(), List.of(), bytes -> {\n+                    var cf = ClassFile.of().parse(bytes);\n+                    if (!cf.thisClass().name().equalsString(\"java\/lang\/invoke\/Invokers$Holder\")) {\n+                        return;\n+                    }\n+\n+                    boolean found = false;\n+                    for (var m : cf.methods()) {\n+                        \/\/ LambdaForm.Kind\n+                        if (m.methodName().equalsString(\"invoker\") && m.methodTypeSymbol().equals(targetMtd)) {\n+                            found = true;\n+                            break;\n+                        }\n+                    }\n+                    if (!found) {\n+                        var methodsInfo = cf.methods().stream()\n+                                .map(m -> m.methodName() + m.methodTypeSymbol().displayDescriptor())\n+                                .collect(Collectors.joining(\"\\n\"));\n+\n+                        Assert.fail(\"Missing invoker L3I_L in java.lang.invoke.Invokers$Holder, found:\\n\" + methodsInfo);\n+                    }\n+                });\n+    }\n+\n","filename":"test\/jdk\/tools\/jlink\/plugins\/GenerateJLIClassesPluginTest.java","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.function.Consumer;\n@@ -175,0 +176,5 @@\n+        validate(jimage, expectedLocations, unexpectedPaths, _ -> {});\n+    }\n+\n+    public static void validate(Path jimage, List<String> expectedLocations,\n+            List<String> unexpectedPaths, Consumer<byte[]> classChecker) throws IOException {\n@@ -198,0 +204,1 @@\n+                    classChecker.accept(r);\n@@ -225,1 +232,1 @@\n-    public static void readClass(byte[] clazz) throws IOException{\n+    public static void readClass(byte[] clazz) throws IOException {\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageValidator.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"}]}