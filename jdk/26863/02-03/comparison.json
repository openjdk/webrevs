{"files":[{"patch":"@@ -1000,6 +1000,4 @@\n-  \/\/ We acquire the init_lock monitor to serialize with class linking\n-  \/\/ so we are not getting bytecodes at the same time the linking process\n-  \/\/ is rewriting them.\n-  JavaThread* current = JavaThread::current();\n-  Handle h_init_lock(current, mh->method_holder()->init_lock());\n-  ObjectLocker ol(h_init_lock, current);\n+  \/\/ We must copy bytecodes only from linked classes.\n+  \/\/ Being linked guarantees we are not getting bytecodes at\n+  \/\/ the same time the linking process is rewriting them.\n+  guarantee(mh->method_holder()->is_linked(), \"Bytecodes must be copied from a linked class\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -453,0 +453,11 @@\n+      \/\/ Link the class to avoid races with the rewriter. This will call the verifier also\n+      \/\/ on the class. Linking is done already below in VM_RedefineClasses below, but we need\n+      \/\/ to keep that for other VM_RedefineClasses callers.\n+      ik->link_class(current_thread);\n+      if (current_thread->has_pending_exception()) {\n+        \/\/ Retransform\/JVMTI swallows error messages. Using this class will rerun the verifier in a context\n+        \/\/ that propagates the VerifyError, if thrown.\n+        current_thread->clear_pending_exception();\n+        return JVMTI_ERROR_INVALID_CLASS;\n+      }\n+\n@@ -3420,1 +3431,2 @@\n-  methodHandle mh(Thread::current(), method);\n+  JavaThread* current_thread = JavaThread::current();\n+  methodHandle mh(current_thread, method);\n@@ -3429,0 +3441,6 @@\n+  \/\/ Make sure the class is verified and rewritten first.\n+  mh->method_holder()->link_class(current_thread);\n+  if (current_thread->has_pending_exception()) {\n+    current_thread->clear_pending_exception();\n+    return JVMTI_ERROR_INVALID_CLASS;\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277444\n+ *\n+ * @library \/test\/lib\n+ * @compile SimpleIdentityTransformer.java\n+ * @run shell MakeJAR.sh retransformAgent\n+ * @run main\/othervm -javaagent:retransformAgent.jar RetransformBigClassTest\n+ *\/\n+\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+\n+\/*\n+ * JvmtiClassFileReconstituter::copy_bytecodes restores bytecodes rewritten\n+ * by the linking process. It is used by RetransformClasses.\n+ * JDK-8277444 is a data race between copy_bytecodes and the linking process.\n+ * This test puts the linking process in one thread and the retransforming process\n+ * in another thread. The test uses Class.forName(\"BigClass\", false, classLoader)\n+ * which does not link the class. When the class is used, the linking process starts.\n+ * In another thread retransforming of the class is happening,\n+ * We generate a class with big methods. A number of methods and thier size are\n+ * chosen to make the linking and retransforming processes running concurrently.\n+ * We delay the retransforming process to follow the linking process.\n+ * If there is no synchronization between the processes, a data race will happen.\n+ *\/\n+public class RetransformBigClassTest extends AInstrumentationTestCase {\n+\n+    private static final Object LOCK = new Object();\n+    private static final int COUNTER_INC_COUNT            = 2000; \/\/ A number of 'c+=1;' statements in methods of a class.\n+    private static final int MIN_LINK_TIME_MS             = 60;   \/\/ This time is chosen to be big enough the linking and retransforming processes are running in parallel.\n+    private static final int RETRANSFORM_CLASSES_DELAY_MS = 37;   \/\/ We manage to create a data race when a delay is in the range 0.52x - 0.62x of MIN_LINK_TIME_MS.\n+\n+    private static Class<?> bigClass;\n+    private static byte[] bigClassBytecode;\n+\n+    private Thread retransformThread;\n+\n+    RetransformBigClassTest() {\n+        super(\"RetransformBigClassTest\");\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        new RetransformBigClassTest().runTest();\n+    }\n+\n+    protected final void doRunTest() throws Throwable {\n+        ClassLoader classLoader = new ClassLoader() {\n+                @Override\n+                protected Class<?> findClass(String name) throws ClassNotFoundException {\n+                    if (name.equals(\"BigClass\")) {\n+                        return defineClass(name, bigClassBytecode, 0, bigClassBytecode.length);\n+                    }\n+\n+                    return super.findClass(name);\n+                }\n+        };\n+        synchronized (LOCK) {\n+            bigClass = Class.forName(\"BigClass\", false, classLoader);\n+            LOCK.notify();\n+        }\n+        \/\/ Make a use of the BigClass\n+        assertTrue(bigClass.getConstructor().newInstance().hashCode() != 0);\n+        retransformThread.join();\n+    }\n+\n+    private byte[] createClassBytecode(String className, int methodCount) throws Exception {\n+        String methodBody = \"\";\n+        for (int j = 0; j < COUNTER_INC_COUNT; j++) {\n+            methodBody += \"c+=1;\";\n+        }\n+\n+        String classSrc = \"public class \" + className + \" { int c;\";\n+\n+        for (int i = 0; i < methodCount; i++) {\n+            classSrc += \"\\npublic void m\" + i + \"(){\";\n+            classSrc += methodBody;\n+            classSrc += \"\\n}\";\n+        }\n+        classSrc += \"\\n}\";\n+\n+        return InMemoryJavaCompiler.compile(className, classSrc);\n+    }\n+\n+    \/\/ We calculate a number of methods the linking time to exceed MIN_LINK_TIME_MS.\n+    \/\/ We create a class having 5 methods and trigger the linking process.\n+    \/\/ We measure the time taken and use it to calculate the needed number.\n+    private int findMethodCount() throws Exception {\n+        int methodCount = 5;\n+        final String className = \"BigClass\" + methodCount;\n+        final byte[] bytecode = createClassBytecode(className, methodCount);\n+        ClassLoader classLoader = new ClassLoader() {\n+            @Override\n+            protected Class<?> findClass(String name) throws ClassNotFoundException {\n+                if (name.equals(className)) {\n+                    return defineClass(name, bytecode, 0, bytecode.length);\n+                }\n+\n+                return super.findClass(name);\n+            }\n+        };\n+        var bigClass = Class.forName(className, false, classLoader);\n+        long startTime = System.nanoTime();\n+        assertTrue(bigClass.getConstructor().newInstance().hashCode() != 0);\n+        double linkTimeMs = (System.nanoTime() - startTime) \/ 1000000.0;\n+        System.out.println(\"Link time for a class with \" + methodCount + \" methods each having \" + COUNTER_INC_COUNT + \" counter increments: \" + Math.round(linkTimeMs));\n+        if (linkTimeMs < MIN_LINK_TIME_MS) {\n+          methodCount = (int)Math.round((MIN_LINK_TIME_MS * methodCount) \/ linkTimeMs);\n+        }\n+        System.out.println(\"The number of methods to exceed \" + MIN_LINK_TIME_MS + \" ms linking time: \" + methodCount);\n+        return methodCount;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        bigClassBytecode = createClassBytecode(\"BigClass\", findMethodCount());\n+        fInst.addTransformer(new SimpleIdentityTransformer());\n+        retransformThread = new Thread(() -> {\n+            try {\n+                synchronized (LOCK) {\n+                    while (bigClass == null) {\n+                        System.out.println(\"[retransformThread]: Waiting for bigClass\");\n+                        LOCK.wait();\n+                    }\n+                }\n+                Thread.sleep(RETRANSFORM_CLASSES_DELAY_MS);\n+                fInst.retransformClasses(bigClass);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        retransformThread.start();\n+        Thread.sleep(100);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformBigClassTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"}]}