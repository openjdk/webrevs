{"files":[{"patch":"@@ -274,0 +274,1 @@\n+macro(OpaqueInitializedAssertionPredicate)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -352,1 +352,4 @@\n-    if (iff->in(1)->Opcode() == Op_Opaque4 && assertion_predicate_has_loop_opaque_node(iff)) {\n+    Node* bol = iff->in(1);\n+    assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"should not find an Initialized Assertion Predicate\");\n+    if (bol->is_Opaque4()) {\n+      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -355,1 +358,1 @@\n-        list.push(iff->in(1));\n+        list.push(bol);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1204,1 +1204,1 @@\n-      if (bol->req() != 2) {\n+      if (bol->req() < 2) {\n@@ -1208,1 +1208,2 @@\n-        assert(bol->Opcode() == Op_Conv2B, \"predicate check only\");\n+        assert(bol->is_Opaque4() || bol->is_OpaqueInitializedAssertionPredicate(),\n+               \"Opaque node of non-null-check or of Initialized Assertion Predicate\");\n@@ -1388,2 +1389,4 @@\n-      if (iff->in(1)->Opcode() == Op_Opaque4) {\n-        assert(assertion_predicate_has_loop_opaque_node(iff), \"unexpected\");\n+      Node* bol = iff->in(1);\n+      assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"should not find an Initialized Assertion Predicate\");\n+      if (bol->is_Opaque4()) {\n+        assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -1499,1 +1502,1 @@\n-  Opaque4Node* new_opaque4_node;\n+  Node* new_opaque_node;\n@@ -1501,1 +1504,1 @@\n-    \/\/ Only set a new OpaqueLoopInitNode node and clone the existing OpaqueLoopStrideNode without modification.\n+    \/\/ Clone the Template Assertion Predicate and set a new OpaqueLoopInitNode to create a new Template Assertion Predicate.\n@@ -1503,0 +1506,1 @@\n+    \/\/ We keep the Opaque4 node since it's still a template.\n@@ -1504,1 +1508,1 @@\n-    new_opaque4_node = template_assertion_predicate_expression.clone_and_replace_init(new_init, control, this);\n+    new_opaque_node = template_assertion_predicate_expression.clone_and_replace_init(new_init, control, this);\n@@ -1506,1 +1510,2 @@\n-    new_opaque4_node = template_assertion_predicate_expression.clone_and_replace_init_and_stride(new_init, new_stride,\n+    \/\/ Create an Initialized Assertion Predicate from the Template Assertion Predicate.\n+    new_opaque_node = template_assertion_predicate_expression.clone_and_replace_init_and_stride(new_init, new_stride,\n@@ -1508,0 +1513,3 @@\n+    \/\/ Since this is an Initialized Assertion Predicate, we use the dedicated opaque node.\n+    new_opaque_node = new OpaqueInitializedAssertionPredicateNode(new_opaque_node->in(1)->as_Bool());\n+    register_new_node(new_opaque_node, control);\n@@ -1512,1 +1520,1 @@\n-  new_iff->set_req(1, new_opaque4_node);\n+  new_iff->set_req(1, new_opaque_node);\n@@ -1968,1 +1976,1 @@\n-    if (proj->unique_ctrl_out()->Opcode() != Op_Halt) {\n+    if (!proj->unique_ctrl_out()->is_Halt()) {\n@@ -1971,7 +1979,5 @@\n-    if (iff->in(1)->Opcode() == Op_Opaque4) {\n-      if (!assertion_predicate_has_loop_opaque_node(iff)) {\n-        \/\/ No OpaqueLoop* node? Then it's one of the two Initialized Assertion Predicates:\n-        \/\/ - For the initial access a[init]\n-        \/\/ - For the last access a[init+old_stride-orig_stride]\n-        \/\/ We could keep the one for the initial access but we do not know which one we currently have here. Just kill both.\n-        \/\/ We will create new Initialized Assertion Predicates from the Template Assertion Predicates below:\n+    Node* bol = iff->in(1);\n+    if (bol->is_Opaque4()) {\n+      if (assertion_predicate_has_loop_opaque_node(iff)) {\n+        \/\/ This is a Template Assertion Predicate for the initial or last access.\n+        \/\/ Create an Initialized Assertion Predicates for it accordingly:\n@@ -1980,3 +1986,0 @@\n-        _igvn.replace_input_of(iff, 1, iff->in(1)->in(2));\n-      } else {\n-        \/\/ Template Assertion Predicate: Clone it to create initialized version with new stride.\n@@ -1986,0 +1989,4 @@\n+      } else {\n+        \/\/ Ignore Opaque4 from a non-null-check for an intrinsic or unsafe access. This could happen when we maximally\n+        \/\/ unroll a non-main loop with such an If with an Opaque4 node directly above the loop entry.\n+        assert(!loop_head->is_main_loop(), \"Opaque4 node from a non-null check - should not be at main loop\");\n@@ -1987,0 +1994,6 @@\n+    } else if (bol->is_OpaqueInitializedAssertionPredicate()) {\n+      \/\/ This is one of the two Initialized Assertion Predicates:\n+      \/\/ - For the initial access a[init]\n+      \/\/ - For the last access a[init+old_stride-orig_stride]\n+      \/\/ We could keep the one for the initial access but we do not know which one we currently have here. Just kill both.\n+      _igvn.replace_input_of(iff, 1, _igvn.intcon(1));\n@@ -2009,1 +2022,1 @@\n-    if (proj->unique_ctrl_out()->Opcode() != Op_Halt) {\n+    if (!proj->unique_ctrl_out()->is_Halt()) {\n@@ -2012,1 +2025,3 @@\n-    if (iff->in(1)->Opcode() == Op_Opaque4 && assertion_predicate_has_loop_opaque_node(iff)) {\n+    if (iff->in(1)->is_Opaque4()) {\n+      \/\/ Initialize from Template Assertion Predicate.\n+      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -2015,1 +2030,1 @@\n-      assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"unexpected\");\n+      assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"must not find OpaqueLoop* nodes\");\n@@ -2046,2 +2061,5 @@\n-    if (iff->in(1)->Opcode() == Op_Opaque4) {\n-      assert(assertion_predicate_has_loop_opaque_node(iff), \"unexpected\");\n+    Node* bol = iff->in(1);\n+    assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"should not find an Initialized Assertion Predicate\");\n+    if (bol->is_Opaque4()) {\n+      \/\/ Initialize from Template Assertion Predicate.\n+      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -2770,4 +2788,4 @@\n-Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(IdealLoopTree* loop,\n-                                                                      Node* ctrl, const int scale_con,\n-                                                                      Node* offset, Node* limit, jint stride_con,\n-                                                                      Node* value) {\n+Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* ctrl,\n+                                                                      const int scale_con, Node* offset, Node* limit,\n+                                                                      jint stride_con, Node* value,\n+                                                                      const bool is_template) {\n@@ -2777,2 +2795,7 @@\n-  Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));\n-  register_new_node(opaque_bol, ctrl);\n+  Node* opaque_assertion_predicate;\n+  if (is_template) {\n+    opaque_assertion_predicate = new Opaque4Node(C, bol, _igvn.intcon(1));\n+  } else {\n+    opaque_assertion_predicate = new OpaqueInitializedAssertionPredicateNode(bol);\n+  }\n+  register_new_node(opaque_assertion_predicate, ctrl);\n@@ -2781,1 +2804,1 @@\n-    new_iff = new IfNode(ctrl, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n+    new_iff = new IfNode(ctrl, opaque_assertion_predicate, PROB_MAX, COUNT_UNKNOWN);\n@@ -2783,1 +2806,1 @@\n-    new_iff = new RangeCheckNode(ctrl, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n+    new_iff = new RangeCheckNode(ctrl, opaque_assertion_predicate, PROB_MAX, COUNT_UNKNOWN);\n@@ -2984,1 +3007,1 @@\n-                                                                       int_limit, stride_con, init);\n+                                                                       int_limit, stride_con, init, false);\n@@ -2990,1 +3013,1 @@\n-                                                                       int_limit, stride_con, opaque_init);\n+                                                                       int_limit, stride_con, opaque_init, true);\n@@ -3003,1 +3026,1 @@\n-                                                                       int_limit, stride_con, max_value);\n+                                                                       int_limit, stride_con, max_value, true);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":59,"deletions":36,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -4374,4 +4374,3 @@\n-    Node* opaque4 = C->template_assertion_predicate_opaq_node(i - 1);\n-    assert(opaque4->Opcode() == Op_Opaque4, \"must be\");\n-    if (!useful_predicates.member(opaque4)) { \/\/ not in the useful list\n-      _igvn.replace_node(opaque4, opaque4->in(2));\n+    Opaque4Node* opaque4_node = C->template_assertion_predicate_opaq_node(i - 1)->as_Opaque4();\n+    if (!useful_predicates.member(opaque4_node)) { \/\/ not in the useful list\n+      _igvn.replace_node(opaque4_node, opaque4_node->in(2));\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1383,1 +1383,2 @@\n-                                                        Node* offset, Node* limit, jint stride_con, Node* value);\n+                                                        Node* offset, Node* limit, int stride_con, Node* value,\n+                                                        bool is_template);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -781,2 +781,6 @@\n-  if (bol->Opcode() == Op_Opaque4) {\n-    return nullptr; \/\/ Ignore loop predicate checks (the Opaque4 ensures they will go away)\n+  assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"Initialized Assertion Predicates cannot form a diamond with Halt\");\n+  if (bol->is_Opaque4()) {\n+    \/\/ Ignore Template Assertion Predicates with Opaque4 nodes.\n+    assert(assertion_predicate_has_loop_opaque_node(iff),\n+           \"must be Template Assertion Predicate, non-null-check with Opaque4 cannot form a diamond with Halt\");\n+    return nullptr;\n@@ -1665,1 +1669,2 @@\n-      n->Opcode() != Op_Opaque4 &&\n+      !n->is_Opaque4() &&\n+      !n->is_OpaqueInitializedAssertionPredicate() &&\n@@ -1978,1 +1983,1 @@\n-    Node *b = phi->in(i);\n+    Node* b = phi->in(i);\n@@ -1982,1 +1987,2 @@\n-      assert(b->is_Bool() || b->Opcode() == Op_Opaque4, \"\");\n+      assert(b->is_Bool() || b->is_Opaque4() || b->is_OpaqueInitializedAssertionPredicate(),\n+             \"bool, non-null check with Opaque4 node or Initialized Assertion Predicate with its Opaque node\");\n@@ -1985,1 +1991,0 @@\n-\n@@ -1989,1 +1994,1 @@\n-  if (n->Opcode() == Op_Opaque4) {\n+  if (n->is_Opaque4() || n->is_OpaqueInitializedAssertionPredicate()) {\n@@ -2162,1 +2167,1 @@\n-      if (use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque4 ||\n+      if (use->is_If() || use->is_CMove() || use->is_Opaque4() ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2430,1 +2430,1 @@\n-               n->Opcode() == Op_Opaque4   ||\n+               n->is_Opaque4()             ||\n@@ -2505,1 +2505,1 @@\n-      } else if (n->Opcode() == Op_Opaque4) {\n+      } else if (n->is_Opaque4()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -613,1 +613,1 @@\n-  if (Opcode() == Op_Opaque4) {\n+  if (is_Opaque4()) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+class OpaqueInitializedAssertionPredicateNode;\n@@ -798,3 +799,4 @@\n-    DEFINE_CLASS_ID(Move,     Node, 18)\n-    DEFINE_CLASS_ID(LShift,   Node, 19)\n-    DEFINE_CLASS_ID(Neg,      Node, 20)\n+    DEFINE_CLASS_ID(OpaqueInitializedAssertionPredicate,  Node, 18)\n+    DEFINE_CLASS_ID(Move,     Node, 19)\n+    DEFINE_CLASS_ID(LShift,   Node, 20)\n+    DEFINE_CLASS_ID(Neg,      Node, 21)\n@@ -969,0 +971,1 @@\n+  DEFINE_CLASS_QUERY(OpaqueInitializedAssertionPredicate)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/connode.hpp\"\n@@ -105,0 +106,19 @@\n+const Type* OpaqueInitializedAssertionPredicateNode::Value(PhaseGVN* phase) const {\n+  return phase->type(in(1));\n+}\n+\n+Node* OpaqueInitializedAssertionPredicateNode::Identity(PhaseGVN* phase) {\n+  if (phase->C->post_loop_opts_phase()) {\n+    \/\/ Initialized Assertion Predicates must always evaluate to true. Therefore, we get rid of them in product builds\n+    \/\/ as they are useless. In debug builds we keep them as additional verification code.\n+#ifdef ASSERT\n+    return in(1);\n+#else\n+    return phase->intcon(1);\n+#endif \/\/ ASSERT\n+  } else {\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -135,0 +135,14 @@\n+\/\/ This node is used for Initialized Assertion Predicate BoolNodes. Initialized Assertion Predicates must always evaluate\n+\/\/ to true. Therefore, we get rid of them in product builds as they are useless. In debug builds we keep them as\n+\/\/ additional verification code (i.e. removing this node and use the BoolNode input instead).\n+class OpaqueInitializedAssertionPredicateNode : public Node {\n+ public:\n+  OpaqueInitializedAssertionPredicateNode(BoolNode* bol) : Node(nullptr, bol) {\n+    init_class_id(Class_OpaqueInitializedAssertionPredicate);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n+};\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  return has_opaque4(predicate_proj) && has_halt(predicate_proj);\n+  return has_assertion_predicate_opaque(predicate_proj) && has_halt(predicate_proj);\n@@ -48,2 +48,3 @@\n-\/\/ Check if the If node of `predicate_proj` has an Opaque4 node as input.\n-bool AssertionPredicatesWithHalt::has_opaque4(const Node* predicate_proj) {\n+\/\/ Check if the If node of `predicate_proj` has an Opaque4 (Template Assertion Predicate) or an\n+\/\/ OpaqueInitializedAssertionPredicate (Initialized Assertion Predicate) node as input.\n+bool AssertionPredicatesWithHalt::has_assertion_predicate_opaque(const Node* predicate_proj) {\n@@ -51,1 +52,2 @@\n-  return iff->in(1)->Opcode() == Op_Opaque4;\n+  Node* bol = iff->in(1);\n+  return bol->is_Opaque4() || bol->is_OpaqueInitializedAssertionPredicate();\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-  static bool has_opaque4(const Node* predicate_proj);\n+  static bool has_assertion_predicate_opaque(const Node* predicate_proj);\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-            if (use->Opcode() == Op_Opaque4) {\n+            if (use->is_Opaque4() || use->is_OpaqueInitializedAssertionPredicate()) {\n@@ -354,2 +354,2 @@\n-              \/\/ Uses are either IfNodes, CMoves or Opaque4\n-              if (u->Opcode() == Op_Opaque4) {\n+              \/\/ Uses are either IfNodes, CMoves, Opaque4, or OpaqueInitializedAssertionPredicates\n+              if (u->is_Opaque4() || u->is_OpaqueInitializedAssertionPredicate()) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,407 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8330386\n+ * @summary Test that replacing Opaque4 nodes with OpaqueInitializedAssertionPredicate for Initialized Assertion Predicates\n+ *          works. We test following cases explicitly:\n+ *          1) Cloning down CmpUNode in Split If with involved OpaqueInitializedAssertionPredicateNodes\n+ *          2) Special casing OpaqueInitializedAssertionPredicate in IdealLoopTree::policy_range_check()\n+ *          3) Special casing Opaque4 node from non-null check for intrinsics and unsafe accesses inside\n+ *             PhaseIdealLoop::update_main_loop_assertion_predicates().\n+ * @requires vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc:+open\n+ * @run main\/othervm -Xbatch -XX:LoopMaxUnroll=0\n+ *                   -XX:CompileCommand=compileonly,*TestOpaqueInitializedAssertionPredicateNode::test*\n+ *                   -XX:CompileCommand=dontinline,*TestOpaqueInitializedAssertionPredicateNode::dontInline\n+ *                   compiler.predicates.assertion.TestOpaqueInitializedAssertionPredicateNode\n+ * @run main\/othervm -Xcomp -XX:LoopMaxUnroll=0 -XX:-LoopUnswitching\n+ *                   -XX:CompileCommand=compileonly,*TestOpaqueInitializedAssertionPredicateNode::test*\n+ *                   -XX:CompileCommand=dontinline,*TestOpaqueInitializedAssertionPredicateNode::dontInline\n+ *                   compiler.predicates.assertion.TestOpaqueInitializedAssertionPredicateNode\n+ * @run main\/othervm -Xbatch -XX:LoopMaxUnroll=0 -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=compileonly,*TestOpaqueInitializedAssertionPredicateNode::test*\n+ *                   -XX:CompileCommand=dontinline,*TestOpaqueInitializedAssertionPredicateNode::dontInline\n+ *                   compiler.predicates.assertion.TestOpaqueInitializedAssertionPredicateNode\n+ *\/\n+\n+\/*\n+ * @test id=noflags\n+ * @bug 8330386\n+ * @modules java.base\/jdk.internal.misc:+open\n+ * @run main compiler.predicates.assertion.TestOpaqueInitializedAssertionPredicateNode\n+ *\/\n+\n+package compiler.predicates.assertion;\n+\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Field;\n+\n+public class TestOpaqueInitializedAssertionPredicateNode {\n+\n+    static boolean flag, flag2;\n+    static int iFld;\n+    static int x;\n+    static int y = 51;\n+    static int iArrLength;\n+    static int[] iArr = new int[100];\n+\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static final long OFFSET;\n+\n+    static {\n+        try {\n+            Field fieldIFld = A.class.getDeclaredField(\"iFld\");\n+            OFFSET = UNSAFE.objectFieldOffset(fieldIFld);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Integer.compareUnsigned(23, 34); \/\/ Make sure loaded with -Xcomp.\n+        A a = new A(34);\n+        for (int i = 0; i < 10000; i++) {\n+            iArrLength = i % 15 == 0 ? 30 : 100;\n+            flag = i % 3 == 0;\n+            flag2 = i % 5 == 0;\n+            x = (i % 15 == 0 ? 100 : 0);\n+            testCloneDown();\n+            testOnlyCloneDownCmp();\n+            testCloneDownInsideLoop();\n+            maybeNull(null); \/\/ Make sure return value is sometimes null.\n+            testPolicyRangeCheck(a);\n+            testUnsafeAccess(a);\n+            testOpaqueOutsideLoop();\n+            testOpaqueInsideIfOutsideLoop();\n+        }\n+    }\n+\n+    \/\/ Profiling will tell us that the return value is sometimes null and sometimes not.\n+    static A maybeNull(Object o) {\n+        return (A)o;\n+    }\n+\n+    static void testCloneDown() {\n+        int a;\n+        int b;\n+        int[] iArr = new int[iArrLength];\n+\n+        for (int i = 2; i < 4; i *= 2) ; \/\/ Make sure to run with loop opts.\n+\n+        if (flag) {\n+            a = 34;\n+        } else {\n+            a = 3;\n+        }\n+        \/\/ Region to split through\n+\n+        \/\/ --- BLOCK start ---\n+\n+        \/\/ CMoveI(Bool(CmpU(y, iArr.length))), 34, 23)  (**)\n+        if (Integer.compareUnsigned(y, iArr.length) < 0) {\n+            b = 34;\n+        } else {\n+            b = 23;\n+        }\n+        iFld = b; \/\/ iFld = CMoveI -> make sure CMoveI is inside BLOCK\n+\n+        \/\/ --- BLOCK end ---\n+\n+        if (a > 23) { \/\/ If to split -> need to empty BLOCK\n+            iFld = 34;\n+        }\n+\n+        if (flag2) {\n+            \/\/ Avoid out-of-bounds access in loop below\n+            return;\n+        }\n+\n+        \/\/ When peeling the loop, we create an Initialized Assertion Predicate with the same CmpU as (**) above:\n+        \/\/ IAP(CmpU(y, iArr.length))\n+        \/\/\n+        \/\/ At Split If: Need to clone CmpU down because it has two uses:\n+        \/\/ - Bool of Cmove used in \"iFld = b\"\n+        \/\/ - Bool for IAP\n+        \/\/\n+        \/\/ => IAP uses OpaqueInitializedAssertionPredicate -> clone_cmp_down() therefore needs to handle that.\n+        for (int i = y - 1; i < 100; i++) {\n+            iArr[i] = 34; \/\/ Hoisted with Loop Predicate\n+            if (flag) { \/\/ Reason to peel.\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test() but we only clone down the CmpU and not the Bool with the OpaqueInitializedAssertionPredicate\n+    static void testOnlyCloneDownCmp() {\n+        int a;\n+        int b;\n+        int[] iArr = new int[iArrLength];\n+\n+        for (int i = 2; i < 4; i *= 2) ; \/\/ Make sure to run with loop opts.\n+\n+        if (flag) {\n+            a = 34;\n+        } else {\n+            a = 3;\n+        }\n+        \/\/ Region to split through\n+\n+        \/\/ --- BLOCK start ---\n+\n+        \/\/ CMoveI(Bool(CmpU(51, iArr.length))), 34, 23)  (**)\n+        \/\/ Using constant 51 -> cannot common up with Bool from Initialized Assertion Predicate\n+        if (Integer.compareUnsigned(51, iArr.length) < 0) {\n+            b = 34;\n+        } else {\n+            b = 23;\n+        }\n+        iFld = b; \/\/ iFld = CMoveI -> make sure CMoveI is inside BLOCK\n+\n+        \/\/ --- BLOCK end ---\n+\n+        if (a > 23) { \/\/ If to split -> need to empty BLOCK\n+            iFld = 34;\n+        }\n+\n+        if (flag2) {\n+            \/\/ Avoid out-of-bounds access in loop below\n+            return;\n+        }\n+\n+        \/\/ When peeling the loop, we create an Initialized Assertion Predicate with the same CmpU as (**) above:\n+        \/\/ IAP(CmpU(y, iArr.length))\n+        \/\/\n+        \/\/ At Split If: Need to clone CmpU down because it has two uses:\n+        \/\/ - Bool of Cmove used in \"iFld = b\"\n+        \/\/ - Bool for IAP\n+        \/\/\n+        \/\/ => IAP uses OpaqueInitializedAssertionPredicate -> clone_cmp_down() therefore needs to handle that.\n+        for (int i = 50; i < 100; i++) {\n+            iArr[i] = 34; \/\/ Hoisted with Loop Predicate\n+            if (flag) { \/\/ Reason to peel.\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test() but everything inside another loop.\n+    static void testCloneDownInsideLoop() {\n+        int a;\n+        int b;\n+        int[] iArr = new int[iArrLength];\n+\n+        for (int i = 3; i < 30; i *= 2) { \/\/ Non-counted loop\n+            if (i < 10) {\n+                a = 34;\n+            } else {\n+                a = 3;\n+            }\n+            \/\/ Region to split through\n+\n+            \/\/ --- BLOCK start ---\n+\n+            \/\/ CMoveI(Bool(CmpU(a + i, iArr.length))), 34, 23)  (**)\n+            if (Integer.compareUnsigned(a + i, iArr.length) < 0) {\n+                b = 34;\n+            } else {\n+                b = 23;\n+            }\n+            iFld = b; \/\/ iFld = CMoveI -> make sure CMoveI is inside BLOCK\n+\n+            \/\/ --- BLOCK end ---\n+\n+            if (a > 23) { \/\/ If to split -> need to empty BLOCK\n+                iFld = 34;\n+            }\n+\n+            if (i < x) {\n+                \/\/ Avoid out-of-bounds access in loop below\n+                return;\n+            }\n+\n+            \/\/ When peeling the loop, we create an Initialized Assertion Predicate with the same CmpU as (**) above:\n+            \/\/ IAP(CmpU(a + i, iArr.length))\n+            \/\/\n+            \/\/ At Split If: Need to clone CmpU down because it has two uses:\n+            \/\/ - Bool of Cmove used in \"iFld = b\"\n+            \/\/ - Bool for IAP\n+            \/\/\n+            \/\/ => IAP uses OpaqueInitializedAssertionPredicate -> clone_cmp_down() therefore needs to handle that.\n+            for (int j = a + i - 1; j < 100; j++) {\n+                iArr[j] = 34; \/\/ Hoisted with Loop Predicate\n+                if (flag) { \/\/ Reason to peel.\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testPolicyRangeCheck(Object o) {\n+        int two = 100;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            two = 2;\n+        }\n+\n+        \/\/ 4) We call IdealLoopTree::policy_range_check() for this loop:\n+        \/\/    - Initialized Assertion Predicate is now part of loop body.\n+        \/\/    - Opaque4 node for null-check is also part of loop body.\n+         \/\/   We also check the If nodes for these Opaque nodes could be eliminated with\n+         \/\/   Range Check Elimination. We thus need to exclude Ifs with\n+         \/\/   Opaque4 and OpaqueInitializedAssertionPredicate nodes in policy_range_check().\n+        for (int i = 0; i < 100; i++) {\n+            A a = maybeNull(o); \/\/ Profiling tells us that return value *might* be null.\n+            iFld = UNSAFE.getInt(a, OFFSET); \/\/ Emits If with Opaque4Node for null check.\n+\n+            \/\/ 1) Apply Loop Predication: Loop Predicate + Template Assertion Predicate\n+            \/\/ 2) Apply Loop Peeling: Create Initialized Assertion Predicate with\n+            \/\/                        OpaqueInitializedAssertionPredicate\n+            \/\/ 3) After CCP: C2 knows that two == 2. CountedLoopEnd found to be true\n+            \/\/               (only execute loop once) -> CountedLoop removed\n+            for (int j = 0; j < two; j++) {\n+                iArr[j] = 34; \/\/ Hoisted in Loop Predication\n+                if (flag) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testUnsafeAccess(Object o) {\n+        A a = maybeNull(o); \/\/ Profiling tells us that return value *might* be null.\n+        iFld = UNSAFE.getInt(a, OFFSET); \/\/ Emits If with Opaque4Node for null check.\n+\n+        \/\/ We don't have any Parse Predicates with -XX:PerMethodTrapLimit=0. And therefore, If with Opaque4 will\n+        \/\/ directly be above CountedLoop. When maximally unrolling the counted loop, we try to update any Assertion\n+        \/\/ Predicate. We will find the If with the Opaque4 node for the non-null check which is not an Assertion\n+        \/\/ Predicate. This needs to be handled separately in PhaseIdealLoop::update_main_loop_assertion_predicates().\n+        for (int i = 0; i < 10; i++) {\n+            iFld *= 34;\n+        }\n+    }\n+\n+    \/\/ [If->OpaqueInitializedAssertionPredicate]->Bool->Cmp, []: Inside Loop, other nodes outside.\n+    static void testOpaqueOutsideLoop() {\n+        int two = 100;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            two = 2;\n+        }\n+\n+        \/\/ 4) After CCP, we can apply Loop Peeling since we removed enough nodes to bring the body size down below 255.\n+        \/\/ When cloning the Bool for the IAP, we have a use inside the loop (initializedAssertionPredicateBool) and one\n+        \/\/ outside for the IAP (input to the OpaqueInitializedAssertionPredicate being outside the loop)\n+        \/\/ As a result, we add the OpaqueInitializedAssertionPredicate to the split if set in clone_loop_handle_data_uses().\n+        for (short i = 3; i < 30; i*=2) { \/\/ Use short such that we do not need overflow protection for Loop Predicates\n+            if (two == 100) {\n+                \/\/ Before CCP: Uninlined method call prevents peeling.\n+                \/\/ After CCP: C2 knows that two == 2 and we remove this call which enables Loop Peeling for i-loop.\n+                dontInline();\n+            }\n+\n+            \/\/ Same condition as used for IAP in j-loop below.\n+            boolean initializedAssertionPredicateBool = Integer.compareUnsigned(1 + i, iArr.length) < 0;\n+\n+            if (flag) {\n+                \/\/ 1) Loop Predicate + Template Assertion Predicate\n+                \/\/ 2) Loop Peeling: Create IAP with same condition as initializedAssertionPredicateBool -> can be shared.\n+                \/\/                  The IAP is on a loop-exit and therefore outside the loop.\n+                \/\/ 3) After CCP: C2 knows that two == 2 and loop is removed.\n+                for (short j = 0; j < two; j++) {\n+                    iArr[i + j] = 34; \/\/ Hoisted in Loop Predication\n+                    if (flag2) {\n+                        break;\n+                    }\n+                }\n+                break;\n+            }\n+\n+            \/\/ Use Bool inside i-loop such that when applying Loop Peeling for i-loop, ctrl of Bool is inside loop and\n+            \/\/ OpaqueInitializedAssertionPredicate of IAP is outside of i-loop.\n+            if (initializedAssertionPredicateBool) {\n+                iFld = 3;\n+            }\n+        }\n+    }\n+\n+    \/\/ Similar to testOpaqueOutside loop but Opaque is now also inside loop.\n+    \/\/ [If]->OpaqueInitializedAssertionPredicate->Bool->Cmp, []: Inside Loop, other nodes outside.\n+    static void testOpaqueInsideIfOutsideLoop() {\n+        int two = 100;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            two = 2;\n+        }\n+\n+        for (short i = 3; i < 30; i*=2) {\n+            if (two == 100) {\n+                \/\/ Before CCP: Uninlined method call prevents peeling.\n+                \/\/ After CCP: C2 knows that two == 2 and we remove this call which enables Loop Peeling for i-loop.\n+                dontInline();\n+            }\n+\n+            \/\/ 1) Loop Predicate + Template Assertion Predicate\n+            \/\/ 2) Loop Peeling: Create IAP with same condition as initializedAssertionPredicateBool -> can be shared.\n+            \/\/                  The IAP is on a loop-exit and therefore outside the loop.\n+            \/\/ 3) After CCP: C2 knows that two == 2 and loop is removed.\n+            for (short j = 0; j < two; j++) {\n+                iArr[i + j] = 34; \/\/ Hoisted in Loop Predication\n+                if (flag2) {\n+                    break;\n+                }\n+            }\n+\n+            if (flag) {\n+                \/\/ Same loop as above. We create the same IAP which can share the same OpaqueInitializedAssertionPredicate.\n+                \/\/ Therefore, the OpaqueInitializedAssertionPredicate is inside the loop while this If is outside the loop.\n+                \/\/ At Loop Peeling, we clone the Opaque node and create a Phi to merge both loop versions into the IAP If. In\n+                \/\/ clone_loop_handle_data_uses(), we add the If for the IAP to the split if set in (). Later, we\n+                \/\/ process its input phi with their OpaqueInitializedAssertionPredicate inputs.\n+                for (short j = 0; j < two; j++) {\n+                    iArr[i + j] = 34; \/\/ Hoisted in Loop Predication\n+                    if (flag2) {\n+                        break;\n+                    }\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ Not inlined\n+    static void dontInline() {}\n+\n+    static class A {\n+        int iFld;\n+        A(int i) {\n+            this.iFld = i;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestOpaqueInitializedAssertionPredicateNode.java","additions":407,"deletions":0,"binary":false,"changes":407,"status":"added"}]}