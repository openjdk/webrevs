{"files":[{"patch":"@@ -1514,1 +1514,1 @@\n-    new_opaque_node = new OpaqueInitializedAssertionPredicateNode(new_opaque_node->in(1)->as_Bool());\n+    new_opaque_node = new OpaqueInitializedAssertionPredicateNode(new_opaque_node->in(1)->as_Bool(), C);\n@@ -2799,1 +2799,1 @@\n-    opaque_assertion_predicate = new OpaqueInitializedAssertionPredicateNode(bol);\n+    opaque_assertion_predicate = new OpaqueInitializedAssertionPredicateNode(bol, C);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2434,0 +2434,1 @@\n+               n->is_OpaqueInitializedAssertionPredicate() ||\n@@ -2521,0 +2522,11 @@\n+      } else if (n->is_OpaqueInitializedAssertionPredicate()) {\n+          \/\/ Initialized Assertion Predicates must always evaluate to true. Therefore, we get rid of them in product\n+          \/\/ builds as they are useless. In debug builds we keep them as additional verification code. Even though\n+          \/\/ loop opts are already over, we want to keep Initialized Assertion Predicates alive as long as possible to\n+          \/\/ enable folding of dead control paths within which cast nodes become top after due to impossible types -\n+          \/\/ even after loop opts are over. Therefore, we delay the removal of these opaque nodes until now.\n+#ifdef ASSERT\n+        _igvn.replace_node(n, n->in(1));\n+#else\n+        _igvn.replace_node(n, _igvn.intcon(1));\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"opto\/connode.hpp\"\n@@ -110,15 +109,0 @@\n-Node* OpaqueInitializedAssertionPredicateNode::Identity(PhaseGVN* phase) {\n-  if (phase->C->post_loop_opts_phase()) {\n-    \/\/ Initialized Assertion Predicates must always evaluate to true. Therefore, we get rid of them in product builds\n-    \/\/ as they are useless. In debug builds we keep them as additional verification code.\n-#ifdef ASSERT\n-    return in(1);\n-#else\n-    return phase->intcon(1);\n-#endif \/\/ ASSERT\n-  } else {\n-    phase->C->record_for_post_loop_opts_igvn(this);\n-  }\n-  return this;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(nullptr, tst, final_tst) {\n+  Opaque4Node(Compile* C, Node* tst, Node* final_tst) : Node(nullptr, tst, final_tst) {\n@@ -131,1 +131,0 @@\n-  virtual const Type *bottom_type() const { return TypeInt::BOOL; }\n@@ -133,0 +132,1 @@\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n@@ -136,2 +136,2 @@\n-\/\/ to true. Therefore, we get rid of them in product builds as they are useless. In debug builds we keep them as\n-\/\/ additional verification code (i.e. removing this node and use the BoolNode input instead).\n+\/\/ to true. Therefore, we get rid of them in product builds during macro expansion as they are useless. In debug builds\n+\/\/ we keep them as additional verification code (i.e. removing this node and use the BoolNode input instead).\n@@ -140,1 +140,1 @@\n-  OpaqueInitializedAssertionPredicateNode(BoolNode* bol) : Node(nullptr, bol) {\n+  OpaqueInitializedAssertionPredicateNode(BoolNode* bol, Compile* C) : Node(nullptr, bol) {\n@@ -142,0 +142,2 @@\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n@@ -145,1 +147,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"}]}