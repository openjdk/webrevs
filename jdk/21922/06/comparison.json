{"files":[{"patch":"@@ -886,1 +886,7 @@\n-        __ check_klass_subtype_slow_path(x14, x10, x12, x15, nullptr, &miss);\n+        __ check_klass_subtype_slow_path(x14,     \/*sub_klass*\/\n+                                         x10,     \/*super_klass*\/\n+                                         x12,     \/*tmp1_reg*\/\n+                                         x15,     \/*tmp2_reg*\/\n+                                         nullptr, \/*L_success*\/\n+                                         &miss    \/*L_failure*\/);\n+        \/\/ Need extras for table lookup: x7, x11, x13\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4080,2 +4080,2 @@\n-  assert_different_registers(sub_klass, super_klass, tmp_reg);\n-  bool must_load_sco = (super_check_offset == noreg);\n+  assert_different_registers(sub_klass, super_klass, tmp_reg, super_check_offset);\n+  bool must_load_sco = !super_check_offset->is_valid();\n@@ -4084,2 +4084,0 @@\n-  } else {\n-    assert_different_registers(sub_klass, super_klass, super_check_offset);\n@@ -4121,0 +4119,1 @@\n+  beq(super_klass, t0, *L_success);\n@@ -4133,1 +4132,0 @@\n-  beq(super_klass, t0, *L_success);\n@@ -4162,6 +4160,7 @@\n-void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n-                                                   Register super_klass,\n-                                                   Register tmp1_reg,\n-                                                   Register tmp2_reg,\n-                                                   Label* L_success,\n-                                                   Label* L_failure) {\n+void MacroAssembler::check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                                          Register super_klass,\n+                                                          Register tmp1_reg,\n+                                                          Register tmp2_reg,\n+                                                          Label* L_success,\n+                                                          Label* L_failure,\n+                                                          bool set_cond_codes) {\n@@ -4241,1 +4240,3 @@\n-  sd(super_klass, super_cache_addr);\n+  if (UseSecondarySupersCache) {\n+    sd(super_klass, super_cache_addr);\n+  }\n@@ -4282,0 +4283,97 @@\n+\/\/ If Register r is invalid, remove a new register from\n+\/\/ available_regs, and add new register to regs_to_push.\n+Register MacroAssembler::allocate_if_noreg(Register r,\n+                                  RegSetIterator<Register> &available_regs,\n+                                  RegSet &regs_to_push) {\n+  if (!r->is_valid()) {\n+    r = *available_regs++;\n+    regs_to_push += r;\n+  }\n+  return r;\n+}\n+\n+\/\/ check_klass_subtype_slow_path_table() looks for super_klass in the\n+\/\/ hash table belonging to super_klass, branching to L_success or\n+\/\/ L_failure as appropriate. This is essentially a shim which\n+\/\/ allocates registers as necessary then calls\n+\/\/ lookup_secondary_supers_table() to do the work. Any of the tmp\n+\/\/ regs may be noreg, in which case this logic will chooses some\n+\/\/ registers push and pop them from the stack.\n+void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n+                                                         Register super_klass,\n+                                                         Register tmp1_reg,\n+                                                         Register tmp2_reg,\n+                                                         Label* L_success,\n+                                                         Label* L_failure,\n+                                                         bool set_cond_codes) {\n+  RegSet tmps = RegSet::of(tmp1_reg, tmp2_reg);\n+\n+  assert_different_registers(sub_klass, super_klass, tmp1_reg, tmp2_reg);\n+\n+  Label L_fallthrough;\n+  int label_nulls = 0;\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n+\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path\");\n+\n+  RegSet caller_save_regs = RegSet::of(x7) + RegSet::range(x10, x17) + RegSet::range(x28, x31);\n+  RegSetIterator<Register> available_regs = (caller_save_regs - tmps - sub_klass - super_klass).begin();\n+\n+  RegSet pushed_regs;\n+\n+  tmp1_reg = allocate_if_noreg(tmp1_reg, available_regs, pushed_regs);\n+  tmp2_reg = allocate_if_noreg(tmp2_reg, available_regs, pushed_regs);\n+\n+  Register tmp3_reg = noreg, tmp4_reg = noreg, result_reg = noreg;\n+\n+  tmp3_reg = allocate_if_noreg(tmp3_reg, available_regs, pushed_regs);\n+  tmp4_reg = allocate_if_noreg(tmp4_reg, available_regs, pushed_regs);\n+  result_reg = allocate_if_noreg(result_reg, available_regs, pushed_regs);\n+\n+  push_reg(pushed_regs, sp);\n+\n+  lookup_secondary_supers_table_var(sub_klass,\n+                                    super_klass,\n+                                    result_reg,\n+                                    tmp1_reg, tmp2_reg, tmp3_reg,\n+                                    tmp4_reg, nullptr);\n+\n+  \/\/ Move the result to t1 as we are about to unspill the tmp registers.\n+  mv(t1, result_reg);\n+\n+  \/\/ Unspill the tmp. registers:\n+  pop_reg(pushed_regs, sp);\n+\n+  \/\/ NB! Callers may assume that, when set_cond_codes is true, this\n+  \/\/ code sets tmp2_reg to a nonzero value.\n+  if (set_cond_codes) {\n+    mv(tmp2_reg, 1);\n+  }\n+\n+  bnez(t1, *L_failure);\n+\n+  if (L_success != &L_fallthrough) {\n+    j(*L_success);\n+  }\n+\n+  bind(L_fallthrough);\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register tmp1_reg,\n+                                                   Register tmp2_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure,\n+                                                   bool set_cond_codes) {\n+  if (UseSecondarySupersTable) {\n+    check_klass_subtype_slow_path_table\n+      (sub_klass, super_klass, tmp1_reg, tmp2_reg, L_success, L_failure, set_cond_codes);\n+  } else {\n+    check_klass_subtype_slow_path_linear\n+      (sub_klass, super_klass, tmp1_reg, tmp2_reg, L_success, L_failure, set_cond_codes);\n+  }\n+}\n+\n@@ -4297,11 +4395,10 @@\n-\/\/ Return true: we succeeded in generating this code\n-bool MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n-                                                   Register r_super_klass,\n-                                                   Register result,\n-                                                   Register tmp1,\n-                                                   Register tmp2,\n-                                                   Register tmp3,\n-                                                   Register tmp4,\n-                                                   u1 super_klass_slot,\n-                                                   bool stub_is_near) {\n-  assert_different_registers(r_sub_klass, r_super_klass, result, tmp1, tmp2, tmp3, tmp4, t0);\n+bool MacroAssembler::lookup_secondary_supers_table_const(Register r_sub_klass,\n+                                                         Register r_super_klass,\n+                                                         Register result,\n+                                                         Register tmp1,\n+                                                         Register tmp2,\n+                                                         Register tmp3,\n+                                                         Register tmp4,\n+                                                         u1 super_klass_slot,\n+                                                         bool stub_is_near) {\n+  assert_different_registers(r_sub_klass, r_super_klass, result, tmp1, tmp2, tmp3, tmp4, t0, t1);\n@@ -4382,0 +4479,92 @@\n+\/\/ At runtime, return 0 in result if r_super_klass is a superclass of\n+\/\/ r_sub_klass, otherwise return nonzero. Use this version of\n+\/\/ lookup_secondary_supers_table() if you don't know ahead of time\n+\/\/ which superclass will be searched for. Used by interpreter and\n+\/\/ runtime stubs. It is larger and has somewhat greater latency than\n+\/\/ the version above, which takes a constant super_klass_slot.\n+void MacroAssembler::lookup_secondary_supers_table_var(Register r_sub_klass,\n+                                                       Register r_super_klass,\n+                                                       Register result,\n+                                                       Register tmp1,\n+                                                       Register tmp2,\n+                                                       Register tmp3,\n+                                                       Register tmp4,\n+                                                       Label *L_success) {\n+  assert_different_registers(r_sub_klass, r_super_klass, result, tmp1, tmp2, tmp3, tmp4, t0, t1);\n+\n+  Label L_fallthrough;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_index = tmp3,\n+    r_bitmap      = tmp4,\n+    slot          = t1;\n+\n+  lbu(slot, Address(r_super_klass, Klass::hash_slot_offset()));\n+\n+  \/\/ Make sure that result is nonzero if the test below misses.\n+  mv(result, 1);\n+\n+  ld(r_bitmap, Address(r_sub_klass, Klass::secondary_supers_bitmap_offset()));\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+\n+  \/\/ This next instruction is equivalent to:\n+  \/\/ mv(tmp_reg, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1));\n+  \/\/ sub(r_array_index, slot, tmp_reg);\n+  xori(r_array_index, slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1));\n+  sll(r_array_index, r_bitmap, r_array_index);\n+  test_bit(t0, r_array_index, Klass::SECONDARY_SUPERS_TABLE_SIZE - 1);\n+  beqz(t0, L_fallthrough);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  population_count(r_array_index, r_array_index, tmp1, tmp2);\n+\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  const Register\n+    r_array_base   = tmp1,\n+    r_array_length = tmp2;\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  \/\/ We will consult the secondary-super array.\n+  ld(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  shadd(result, r_array_index, r_array_base, result, LogBytesPerWord);\n+  ld(result, Address(result));\n+  xorr(result, result, r_super_klass);\n+  beqz(result, L_success ? *L_success : L_fallthrough); \/\/ Found a match\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  ror_reg(r_bitmap, r_bitmap, slot);\n+  test_bit(t0, r_bitmap, 1);\n+  beqz(t0, L_fallthrough);\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the logic we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index,\n+                                          r_bitmap, result, r_array_length, false \/*is_stub*\/);\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  bind(L_fallthrough);\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                  result, tmp1, tmp2, tmp3);\n+  }\n+\n+  if (L_success) {\n+    beqz(result, *L_success);\n+  }\n+}\n+\n@@ -4390,2 +4579,3 @@\n-                                                             Register tmp1) {\n-  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, tmp1, result, t0);\n+                                                             Register tmp,\n+                                                             bool is_stub) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, tmp, result, t0);\n@@ -4394,1 +4584,1 @@\n-    r_array_length = tmp1,\n+    r_array_length = tmp,\n@@ -4397,2 +4587,4 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,\n-                                          r_array_index, r_sub_klass, result, r_bitmap);\n+  if (is_stub) {\n+    LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,\n+                                            r_array_index, r_sub_klass, result, r_bitmap);\n+  }\n@@ -4425,2 +4617,4 @@\n-    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n-    \/\/ eventually terminates.\n+    \/\/ As long as the bitmap is not completely full,\n+    \/\/ array_length == popcount(bitmap). The array_length check above\n+    \/\/ guarantees there are 0s in the bitmap, so the loop eventually\n+    \/\/ terminates.\n@@ -4478,3 +4672,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,\n-                                          r_array_index, r_sub_klass, result, r_bitmap);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":224,"deletions":33,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -326,1 +326,35 @@\n-                                     Label* L_failure);\n+                                     Label* L_failure,\n+                                     bool set_cond_codes = false);\n+\n+  void check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                            Register super_klass,\n+                                            Register tmp1_reg,\n+                                            Register tmp2_reg,\n+                                            Label* L_success,\n+                                            Label* L_failure,\n+                                            bool set_cond_codes = false);\n+\n+  void check_klass_subtype_slow_path_table(Register sub_klass,\n+                                           Register super_klass,\n+                                           Register tmp1_reg,\n+                                           Register tmp2_reg,\n+                                           Label* L_success,\n+                                           Label* L_failure,\n+                                           bool set_cond_codes = false);\n+\n+  \/\/ If r is valid, return r.\n+  \/\/ If r is invalid, remove a register r2 from available_regs, add r2\n+  \/\/ to regs_to_push, then return r2.\n+  Register allocate_if_noreg(const Register r,\n+                             RegSetIterator<Register> &available_regs,\n+                             RegSet &regs_to_push);\n+\n+  \/\/ Secondary subtype checking\n+  void lookup_secondary_supers_table_var(Register sub_klass,\n+                                         Register r_super_klass,\n+                                         Register result,\n+                                         Register tmp1,\n+                                         Register tmp2,\n+                                         Register tmp3,\n+                                         Register tmp4,\n+                                         Label *L_success);\n@@ -332,9 +366,9 @@\n-  bool lookup_secondary_supers_table(Register r_sub_klass,\n-                                     Register r_super_klass,\n-                                     Register result,\n-                                     Register tmp1,\n-                                     Register tmp2,\n-                                     Register tmp3,\n-                                     Register tmp4,\n-                                     u1 super_klass_slot,\n-                                     bool stub_is_near = false);\n+  bool lookup_secondary_supers_table_const(Register r_sub_klass,\n+                                           Register r_super_klass,\n+                                           Register result,\n+                                           Register tmp1,\n+                                           Register tmp2,\n+                                           Register tmp3,\n+                                           Register tmp4,\n+                                           u1 super_klass_slot,\n+                                           bool stub_is_near = false);\n@@ -354,1 +388,2 @@\n-                                               Register tmp1);\n+                                               Register tmp,\n+                                               bool is_stub = true);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":46,"deletions":11,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2367,1 +2367,1 @@\n-                                     nullptr, &miss);\n+                                     nullptr, &miss, \/*set_cond_codes*\/ true);\n@@ -10022,0 +10022,1 @@\n+  predicate(!UseSecondarySupersTable);\n@@ -10025,1 +10026,1 @@\n-  ins_cost(11 * DEFAULT_COST);\n+  ins_cost(20 * DEFAULT_COST);\n@@ -10035,0 +10036,27 @@\n+\/\/ Two versions of partialSubtypeCheck, both used when we need to\n+\/\/ search for a super class in the secondary supers array. The first\n+\/\/ is used when we don't know _a priori_ the class being searched\n+\/\/ for. The second, far more common, is used when we do know: this is\n+\/\/ used for instanceof, checkcast, and any case where C2 can determine\n+\/\/ it by constant propagation.\n+\n+instruct partialSubtypeCheckVarSuper(iRegP_R14 sub, iRegP_R10 super, iRegP_R15 result,\n+                                     iRegP_R11 tmpR11, iRegP_R12 tmpR12, iRegP_R13 tmpR13,\n+                                     iRegP_R16 tmpR16, rFlagsReg cr)\n+%{\n+  predicate(UseSecondarySupersTable);\n+  match(Set result (PartialSubtypeCheck sub super));\n+  effect(TEMP tmpR11, TEMP tmpR12, TEMP tmpR13, TEMP tmpR16, KILL cr);\n+\n+  ins_cost(10 * DEFAULT_COST);  \/\/ slightly larger than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+\n+  ins_encode %{\n+    __ lookup_secondary_supers_table_var($sub$$Register, $super$$Register, $result$$Register,\n+                                         $tmpR11$$Register, $tmpR12$$Register, $tmpR13$$Register,\n+                                         $tmpR16$$Register, nullptr \/*L_success*\/);\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -10042,1 +10070,1 @@\n-  ins_cost(7 * DEFAULT_COST); \/\/ needs to be less than competing nodes\n+  ins_cost(5 * DEFAULT_COST); \/\/ needs to be less than competing nodes\n@@ -10049,3 +10077,3 @@\n-      success = __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register, $result$$Register,\n-                                                 $tmpR11$$Register, $tmpR12$$Register, $tmpR13$$Register,\n-                                                 $tmpR16$$Register, super_klass_slot);\n+      success = __ lookup_secondary_supers_table_const($sub$$Register, $super_reg$$Register, $result$$Register,\n+                                                       $tmpR11$$Register, $tmpR12$$Register, $tmpR13$$Register,\n+                                                       $tmpR16$$Register, super_klass_slot);\n@@ -10065,16 +10093,0 @@\n-instruct partialSubtypeCheckVsZero(iRegP_R15 result, iRegP_R14 sub, iRegP_R10 super, iRegP_R12 tmp,\n-                                   immP0 zero, rFlagsReg cr)\n-%{\n-  match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));\n-  effect(KILL tmp, KILL result);\n-\n-  ins_cost(11 * DEFAULT_COST);\n-  format %{ \"partialSubtypeCheck $result, $sub, $super == 0\\t#@partialSubtypeCheckVsZero\" %}\n-\n-  ins_encode(riscv_enc_partial_subtype_check(sub, super, tmp, result));\n-\n-  opcode(0x0); \/\/ Don't zero result reg on hit\n-\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":34,"deletions":22,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1457,0 +1457,3 @@\n+                           Register result,\n+                           Register tmp1,\n+                           Register tmp2,\n@@ -1465,1 +1468,1 @@\n-    __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, nullptr);\n+    __ check_klass_subtype_slow_path(sub_klass, super_klass, tmp1, tmp2, &L_success, nullptr);\n@@ -1594,1 +1597,12 @@\n-    generate_type_check(r9_klass, ckoff, ckval, L_store_element);\n+\n+    BLOCK_COMMENT(\"type_check:\");\n+    generate_type_check(r9_klass, \/*sub_klass*\/\n+                        ckoff,    \/*super_check_offset*\/\n+                        ckval,    \/*super_klass*\/\n+                        x10,      \/*result*\/\n+                        gct1,     \/*tmp1*\/\n+                        gct2,     \/*tmp2*\/\n+                        L_store_element);\n+\n+    \/\/ Fall through on failure!\n+\n@@ -1603,1 +1617,1 @@\n-    __ xori(count, count, -1);                   \/\/ report (-1^K) to caller\n+    __ xori(count, count, -1);            \/\/ report (-1^K) to caller\n@@ -1968,1 +1982,1 @@\n-      generate_type_check(scratch_src_klass, sco_temp, dst_klass, L_plain_copy);\n+      generate_type_check(scratch_src_klass, sco_temp, dst_klass, noreg, noreg, noreg, L_plain_copy);\n@@ -3009,3 +3023,3 @@\n-    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass, result,\n-                                     r_array_base, r_array_length, r_array_index,\n-                                     r_bitmap, super_klass_index, \/*stub_is_near*\/true);\n+    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass, result,\n+                                           r_array_base, r_array_length, r_array_index,\n+                                           r_bitmap, super_klass_index, \/*stub_is_near*\/ true);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"}]}