{"files":[{"patch":"@@ -35,1 +35,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n@@ -37,1 +37,1 @@\n-    guarantee(ni->data() == (intptr_t)(x + o), \"instructions must match\");\n+    guarantee(ni->data() == (intptr_t)x, \"instructions must match\");\n@@ -39,1 +39,1 @@\n-    ni->set_data((intptr_t)(x + o));\n+    ni->set_data((intptr_t)x);\n","filename":"src\/hotspot\/cpu\/arm\/relocInfo_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,4 +35,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n-  \/\/ Currently we don't support splitting of relocations.\n-  assert(o == 0, \"tried to split relocations\");\n-\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/ppc\/relocInfo_ppc.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -355,4 +355,0 @@\n-\n-  RelocationHolder rspec(int offset) const {\n-    return offset == 0 ? _rspec : _rspec.plus(offset);\n-  }\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n-  \/\/ we don't support splitting of relocations, so o must be zero:\n-  assert(o == 0, \"tried to split relocations\");\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n@@ -39,1 +37,1 @@\n-        nativeMovConstReg_at(addr())->set_data_plain(((intptr_t)x) + o, code());\n+        nativeMovConstReg_at(addr())->set_data_plain(((intptr_t)x), code());\n@@ -43,1 +41,1 @@\n-          nativeMovConstReg_at(addr())->set_narrow_klass(((intptr_t)x) + o);\n+          nativeMovConstReg_at(addr())->set_narrow_klass(((intptr_t)x));\n@@ -45,1 +43,1 @@\n-          nativeMovConstReg_at(addr())->set_narrow_oop(((intptr_t)x) + o);\n+          nativeMovConstReg_at(addr())->set_narrow_oop(((intptr_t)x));\n@@ -50,1 +48,1 @@\n-        nativeMovConstReg_at(addr())->set_pcrel_addr(((intptr_t)x) + o, code());\n+        nativeMovConstReg_at(addr())->set_pcrel_addr(((intptr_t)x), code());\n@@ -53,1 +51,1 @@\n-        nativeMovConstReg_at(addr())->set_pcrel_data(((intptr_t)x) + o, code());\n+        nativeMovConstReg_at(addr())->set_pcrel_data(((intptr_t)x), code());\n","filename":"src\/hotspot\/cpu\/s390\/relocInfo_s390.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n@@ -41,1 +41,0 @@\n-  x += o;\n@@ -83,1 +82,1 @@\n-    guarantee(*pd_address_in_code() == (x + o), \"instructions must match\");\n+    guarantee(*pd_address_in_code() == x, \"instructions must match\");\n@@ -85,1 +84,1 @@\n-    *pd_address_in_code() = x + o;\n+    *pd_address_in_code() = x;\n","filename":"src\/hotspot\/cpu\/x86\/relocInfo_x86.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/zero\/relocInfo_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -280,24 +280,0 @@\n-\/\/\/\/\/\/\/\/ Methods for RelocationHolder\n-\n-RelocationHolder RelocationHolder::plus(int offset) const {\n-  if (offset != 0) {\n-    switch (type()) {\n-    case relocInfo::none:\n-      break;\n-    case relocInfo::oop_type:\n-      {\n-        oop_Relocation* r = (oop_Relocation*)reloc();\n-        return oop_Relocation::spec(r->oop_index(), r->offset() + offset);\n-      }\n-    case relocInfo::metadata_type:\n-      {\n-        metadata_Relocation* r = (metadata_Relocation*)reloc();\n-        return metadata_Relocation::spec(r->metadata_index(), r->offset() + offset);\n-      }\n-    default:\n-      ShouldNotReachHere();\n-    }\n-  }\n-  return (*this);\n-}\n-\n@@ -405,1 +381,1 @@\n-  p = pack_2_ints_to(p, _oop_index, _offset);\n+  p = pack_1_int_to(p, _oop_index);\n@@ -411,1 +387,1 @@\n-  unpack_2_ints(_oop_index, _offset);\n+  _oop_index = unpack_1_int();\n@@ -416,1 +392,1 @@\n-  p = pack_2_ints_to(p, _metadata_index, _offset);\n+  p = pack_1_int_to(p, _metadata_index);\n@@ -422,1 +398,1 @@\n-  unpack_2_ints(_metadata_index, _offset);\n+  _metadata_index = unpack_1_int();\n@@ -858,2 +834,2 @@\n-      tty->print(\" | [oop_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \" offset=%d]\",\n-                 p2i(oop_addr), p2i(raw_oop), r->offset());\n+      tty->print(\" | [oop_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n+                 p2i(oop_addr), p2i(raw_oop));\n@@ -881,2 +857,2 @@\n-      tty->print(\" | [metadata_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \" offset=%d]\",\n-                 p2i(metadata_addr), p2i(raw_metadata), r->offset());\n+      tty->print(\" | [metadata_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n+                 p2i(metadata_addr), p2i(raw_metadata));\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -133,5 +133,1 @@\n-\/\/          [[N]n l] and l is a byte offset to be applied to the oop\n-\/\/          [Nn Ll]  both index and offset may be 32 bits if necessary\n-\/\/   Here is a special hack, used only by the old compiler:\n-\/\/          [[N]n 00] the value is the __address__ of the nth oop in the pool\n-\/\/   (Note that the offset allows optimal references to class variables.)\n+\/\/          [Nn]     index may be 32 bits if necessary\n@@ -518,3 +514,0 @@\n-  \/\/ Add a constant offset to a relocation.  Helper for class Address.\n-  RelocationHolder plus(int offset) const;\n-\n@@ -791,2 +784,2 @@\n-  void       pd_set_data_value       (address x, intptr_t off, bool verify_only = false); \/\/ a set or mem-ref\n-  void       pd_verify_data_value    (address x, intptr_t off) { pd_set_data_value(x, off, true); }\n+  void       pd_set_data_value       (address x, bool verify_only = false); \/\/ a set or mem-ref\n+  void       pd_verify_data_value    (address x) { pd_set_data_value(x, true); }\n@@ -898,1 +891,0 @@\n-\/\/ By convention, the \"value\" does not include a separately reckoned \"offset\".\n@@ -903,1 +895,1 @@\n-  bool          is_data() override             { return true; }\n+  bool    is_data() override { return true; }\n@@ -905,6 +897,4 @@\n-  \/\/ both target and offset must be computed somehow from relocation data\n-  virtual int    offset()                      { return 0; }\n-  address         value() override             = 0;\n-  void        set_value(address x) override    { set_value(x, offset()); }\n-  void        set_value(address x, intptr_t o) {\n-    if (addr_in_const())\n+  \/\/ target must be computed somehow from relocation data\n+  address value() override = 0;\n+  void    set_value(address x) override {\n+    if (addr_in_const()) {\n@@ -912,2 +902,3 @@\n-    else\n-      pd_set_data_value(x, o);\n+    } else {\n+      pd_set_data_value(x);\n+    }\n@@ -915,2 +906,2 @@\n-  void        verify_value(address x) {\n-    if (addr_in_const())\n+  void    verify_value(address x) {\n+    if (addr_in_const()) {\n@@ -918,2 +909,3 @@\n-    else\n-      pd_verify_data_value(x, offset());\n+    } else {\n+      pd_verify_data_value(x);\n+    }\n@@ -921,12 +913,0 @@\n-\n-  \/\/ The \"o\" (displacement) argument is relevant only to split relocations\n-  \/\/ on RISC machines.  In some CPUs (SPARC), the set-hi and set-lo ins'ns\n-  \/\/ can encode more than 32 bits between them.  This allows compilers to\n-  \/\/ share set-hi instructions between addresses that differ by a small\n-  \/\/ offset (e.g., different static variables in the same class).\n-  \/\/ On such machines, the \"x\" argument to set_value on all set-lo\n-  \/\/ instructions must be the same as the \"x\" argument for the\n-  \/\/ corresponding set-hi instructions.  The \"o\" arguments for the\n-  \/\/ set-hi instructions are ignored, and must not affect the high-half\n-  \/\/ immediate constant.  The \"o\" arguments for the set-lo instructions are\n-  \/\/ added into the low-half immediate constant, and must not overflow it.\n@@ -979,3 +959,2 @@\n-  \/\/ encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]\n-  \/\/ an oop in the CodeBlob's oop pool\n-  static RelocationHolder spec(int oop_index, int offset = 0) {\n+  \/\/ an oop in the CodeBlob's oop pool; encoded as [n] or [Nn]\n+  static RelocationHolder spec(int oop_index) {\n@@ -983,1 +962,1 @@\n-    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n+    return RelocationHolder::construct<oop_Relocation>(oop_index);\n@@ -985,1 +964,1 @@\n-  \/\/ an oop in the instruction stream\n+  \/\/ an oop in the instruction stream; encoded as []\n@@ -992,2 +971,1 @@\n-    const int offset    = 0;    \/\/ if you want an offset, use the oop pool\n-    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n+    return RelocationHolder::construct<oop_Relocation>(oop_index);\n@@ -1000,1 +978,0 @@\n-  jint _offset;                     \/\/ byte offset to apply to the oop itself\n@@ -1002,2 +979,2 @@\n-  oop_Relocation(int oop_index, int offset)\n-    : DataRelocation(relocInfo::oop_type), _oop_index(oop_index), _offset(offset) { }\n+  oop_Relocation(int oop_index)\n+    : DataRelocation(relocInfo::oop_type), _oop_index(oop_index) { }\n@@ -1010,1 +987,0 @@\n-  int offset() override { return _offset; }\n@@ -1012,1 +988,1 @@\n-  \/\/ data is packed in \"2_ints\" format:  [i o] or [Ii Oo]\n+  \/\/ oop_index is packed in \"1_int\" format:  [n] or [Nn]\n@@ -1034,3 +1010,2 @@\n-  \/\/ encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]\n-  \/\/ an metadata in the CodeBlob's metadata pool\n-  static RelocationHolder spec(int metadata_index, int offset = 0) {\n+  \/\/ an metadata in the CodeBlob's metadata pool; encoded as [n] or [Nn]\n+  static RelocationHolder spec(int metadata_index) {\n@@ -1038,1 +1013,1 @@\n-    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index);\n@@ -1040,1 +1015,1 @@\n-  \/\/ an metadata in the instruction stream\n+  \/\/ an metadata in the instruction stream; encoded as []\n@@ -1043,2 +1018,1 @@\n-    const int offset    = 0;    \/\/ if you want an offset, use the metadata pool\n-    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index);\n@@ -1051,1 +1025,0 @@\n-  jint _offset;                     \/\/ byte offset to apply to the metadata itself\n@@ -1053,2 +1026,2 @@\n-  metadata_Relocation(int metadata_index, int offset)\n-    : DataRelocation(relocInfo::metadata_type), _metadata_index(metadata_index), _offset(offset) { }\n+  metadata_Relocation(int metadata_index)\n+    : DataRelocation(relocInfo::metadata_type), _metadata_index(metadata_index) { }\n@@ -1066,1 +1039,0 @@\n-  int offset() override { return _offset; }\n@@ -1068,1 +1040,1 @@\n-  \/\/ data is packed in \"2_ints\" format:  [i o] or [Ii Oo]\n+  \/\/ metadata_index is packed in \"1_int\" format:  [n] or [Nn]\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":32,"deletions":60,"binary":false,"changes":92,"status":"modified"}]}