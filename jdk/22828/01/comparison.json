{"files":[{"patch":"@@ -103,2 +103,1 @@\n-                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs,\n-                                                        AssertionPredicateType assertion_predicate_type) {\n+                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs) {\n@@ -146,2 +145,1 @@\n-      new_iff = new IfNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt\n-                           NOT_PRODUCT(COMMA assertion_predicate_type));\n+      new_iff = new IfNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt);\n@@ -150,2 +148,1 @@\n-      new_iff = new RangeCheckNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt\n-                                   NOT_PRODUCT(COMMA assertion_predicate_type));\n+      new_iff = new RangeCheckNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt);\n@@ -275,62 +272,3 @@\n-IfProjNode* PhaseIdealLoop::clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* parse_predicate_proj,\n-                                                                     Node* new_entry, Deoptimization::DeoptReason reason,\n-                                                                     const bool slow_loop) {\n-\n-  IfProjNode* new_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, new_entry, reason, Op_ParsePredicate,\n-                                                               slow_loop);\n-  assert(new_predicate_proj->is_IfTrue(), \"the success projection of a Parse Predicate is a true projection\");\n-  ParsePredicateNode* parse_predicate = new_predicate_proj->in(0)->as_ParsePredicate();\n-  return new_predicate_proj;\n-}\n-\n-\/\/ Clones Template Assertion Predicates to both unswitched loops starting at 'old_predicate_proj' by following its\n-\/\/ control inputs. It also rewires the control edges of data nodes with dependencies in the loop from the old predicates\n-\/\/ to the new  cloned predicates.\n-void PhaseIdealLoop::clone_assertion_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n-                                                                   ParsePredicateSuccessProj* old_parse_predicate_proj,\n-                                                                   ParsePredicateNode* true_path_loop_parse_predicate,\n-                                                                   ParsePredicateNode* false_path_loop_parse_predicate) {\n-  \/\/ Push the original Template Assertion Predicates on a list to later process them in reverse order to keep the\n-  \/\/ original predicate order.\n-  Unique_Node_List list;\n-  get_template_assertion_predicates(old_parse_predicate_proj, list);\n-\n-  Node_List to_process;\n-  for (int i = list.size() - 1; i >= 0; i--) {\n-    IfTrueNode* template_assertion_predicate_success_proj = list.at(i)->as_IfTrue();\n-    assert(template_assertion_predicate_success_proj->in(0)->is_If(), \"must be If node\");\n-\n-    IfTrueNode* true_path_loop_proj =\n-        clone_assertion_predicate_for_unswitched_loops(template_assertion_predicate_success_proj,\n-                                                       true_path_loop_parse_predicate);\n-    IfTrueNode* false_path_loop_proj =\n-        clone_assertion_predicate_for_unswitched_loops(template_assertion_predicate_success_proj,\n-                                                       false_path_loop_parse_predicate);\n-\n-    \/\/ Update control dependent data nodes.\n-    for (DUIterator j = template_assertion_predicate_success_proj->outs();\n-         template_assertion_predicate_success_proj->has_out(j);\n-         j++) {\n-      Node* true_path_loop_node = template_assertion_predicate_success_proj->out(j);\n-      if (loop->is_member(get_loop(ctrl_or_self(true_path_loop_node)))) {\n-        assert(true_path_loop_node->in(0) == template_assertion_predicate_success_proj, \"only control edge\");\n-        Node* false_path_loop_node = old_new[true_path_loop_node->_idx];\n-        assert(false_path_loop_node->in(0) == template_assertion_predicate_success_proj, \"only control edge\");\n-        _igvn.replace_input_of(true_path_loop_node, 0, true_path_loop_proj);\n-        to_process.push(false_path_loop_node);\n-        --j;\n-      }\n-    }\n-    \/\/ Have to delay updates to the false path loop so uses of predicate are not modified while we iterate on them.\n-    while (to_process.size() > 0) {\n-      Node* slow_node = to_process.pop();\n-      _igvn.replace_input_of(slow_node, 0, false_path_loop_proj);\n-    }\n-  }\n-}\n-\n-\/\/ Put all Template Assertion Predicate projections on a list, starting at 'predicate' and going up in the tree. If 'get_opaque'\n-\/\/ is set, then the OpaqueTemplateAssertionPredicateNode nodes of the Assertion Predicates are put on the list instead\n-\/\/ of the projections.\n-void PhaseIdealLoop::get_template_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list,\n-                                                       const bool get_opaque) {\n+\/\/ Put all OpaqueTemplateAssertionPredicate nodes on a list, starting at 'predicate' and going up in the tree.\n+void PhaseIdealLoop::get_opaque_template_assertion_predicate_nodes(ParsePredicateSuccessProj* parse_predicate_proj,\n+                                                                   Unique_Node_List& list) {\n@@ -339,77 +277,2 @@\n-  TemplateAssertionPredicateCollector template_assertion_predicate_collector(list, get_opaque);\n-  predicate_iterator.for_each(template_assertion_predicate_collector);\n-}\n-\n-\/\/ Clone an Assertion Predicate for an unswitched loop. OpaqueLoopInit and OpaqueLoopStride nodes are cloned and uncommon\n-\/\/ traps are kept for the predicate (a Halt node is used later when creating pre\/main\/post loops and copying this cloned\n-\/\/ predicate again).\n-IfTrueNode*\n-PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(IfTrueNode* template_assertion_predicate_success_proj,\n-                                                               ParsePredicateNode* unswitched_loop_parse_predicate) {\n-  TemplateAssertionPredicate template_assertion_predicate(template_assertion_predicate_success_proj);\n-  IfTrueNode* template_success_proj = template_assertion_predicate.clone(unswitched_loop_parse_predicate->in(0), this);\n-  _igvn.replace_input_of(unswitched_loop_parse_predicate, 0, template_success_proj);\n-  set_idom(unswitched_loop_parse_predicate, template_success_proj, dom_depth(template_success_proj));\n-  return template_success_proj;\n-}\n-\n-\/\/ Clone the old Parse Predicates and Assertion Predicates before the unswitch If to the unswitched loops after the\n-\/\/ unswitch If.\n-void PhaseIdealLoop::clone_parse_and_assertion_predicates_to_unswitched_loop(IdealLoopTree* loop, Node_List& old_new,\n-                                                                             IfProjNode*& true_path_loop_entry,\n-                                                                             IfProjNode*& false_path_loop_entry) {\n-  LoopNode* head = loop->_head->as_Loop();\n-  Node* entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n-\n-  const Predicates predicates(entry);\n-  clone_loop_predication_predicates_to_unswitched_loop(loop, old_new, predicates.loop_predicate_block(),\n-                                                       Deoptimization::Reason_predicate, true_path_loop_entry, false_path_loop_entry);\n-  clone_loop_predication_predicates_to_unswitched_loop(loop, old_new, predicates.profiled_loop_predicate_block(),\n-                                                       Deoptimization::Reason_profile_predicate, true_path_loop_entry, false_path_loop_entry);\n-\n-  const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n-  if (loop_limit_check_predicate_block->has_parse_predicate() && !head->is_CountedLoop()) {\n-    \/\/ Don't clone the Loop Limit Check Parse Predicate if we already have a counted loop (a Loop Limit Check Predicate\n-    \/\/ is only created when converting a LoopNode to a CountedLoopNode).\n-    clone_parse_predicate_to_unswitched_loops(loop_limit_check_predicate_block, Deoptimization::Reason_loop_limit_check,\n-                                              true_path_loop_entry, false_path_loop_entry);\n-  }\n-}\n-\n-\/\/ Clone the Parse Predicate and Template Assertion Predicates of a Loop Predication related Predicate Block.\n-void PhaseIdealLoop::clone_loop_predication_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n-                                                                          const PredicateBlock* predicate_block,\n-                                                                          Deoptimization::DeoptReason reason,\n-                                                                          IfProjNode*& true_path_loop_entry,\n-                                                                          IfProjNode*& false_path_loop_entry) {\n-  if (predicate_block->has_parse_predicate()) {\n-    \/\/ We currently only clone Assertion Predicates if there are Parse Predicates. This is not entirely correct and will\n-    \/\/ be changed with the complete fix for Assertion Predicates.\n-    clone_parse_predicate_to_unswitched_loops(predicate_block, reason, true_path_loop_entry, false_path_loop_entry);\n-    assert(true_path_loop_entry->in(0)->is_ParsePredicate() && false_path_loop_entry->in(0)->is_ParsePredicate(),\n-           \"must be success projections of the cloned Parse Predicates\");\n-    clone_assertion_predicates_to_unswitched_loop(loop, old_new, predicate_block->parse_predicate_success_proj(),\n-                                                  true_path_loop_entry->in(0)->as_ParsePredicate(),\n-                                                  false_path_loop_entry->in(0)->as_ParsePredicate());\n-  }\n-}\n-\n-void PhaseIdealLoop::clone_parse_predicate_to_unswitched_loops(const PredicateBlock* predicate_block,\n-                                                               Deoptimization::DeoptReason reason,\n-                                                               IfProjNode*& iffast_pred, IfProjNode*& ifslow_pred) {\n-  assert(predicate_block->has_parse_predicate(), \"must have parse predicate\");\n-  ParsePredicateSuccessProj* parse_predicate_proj = predicate_block->parse_predicate_success_proj();\n-  iffast_pred = clone_parse_predicate_to_unswitched_loop(parse_predicate_proj, iffast_pred, reason, false);\n-  check_cloned_parse_predicate_for_unswitching(iffast_pred, true);\n-\n-  ifslow_pred = clone_parse_predicate_to_unswitched_loop(parse_predicate_proj, ifslow_pred, reason, true);\n-  check_cloned_parse_predicate_for_unswitching(ifslow_pred, false);\n-}\n-\n-#ifndef PRODUCT\n-void PhaseIdealLoop::check_cloned_parse_predicate_for_unswitching(const Node* new_entry, const bool is_fast_loop) {\n-  assert(new_entry != nullptr, \"IfTrue or IfFalse after clone predicate\");\n-  if (TraceLoopPredicate) {\n-    tty->print(\"Parse Predicate cloned to %s loop: \", is_fast_loop ? \"fast\" : \"slow\");\n-    new_entry->in(0)->dump();\n-  }\n+  OpaqueTemplateAssertionPredicateCollector opaque_template_assertion_predicate_collector(list);\n+  predicate_iterator.for_each(opaque_template_assertion_predicate_collector);\n@@ -417,1 +280,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":8,"deletions":146,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -239,0 +239,14 @@\n+  \/\/ Unswitch the original loop on the invariant loop selector by creating a true-path-loop and a false-path-loop.\n+  \/\/ Remove the unswitch candidate If from both unswitched loop versions which are now covered by the loop selector If.\n+  void unswitch(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+    const uint first_false_path_loop_node_index = _phase->C->unique();\n+    clone_loop(unswitched_loop_selector);\n+\n+    move_parse_and_template_assertion_predicates_to_unswitched_loops(unswitched_loop_selector,\n+                                                                     first_false_path_loop_node_index);\n+    DEBUG_ONLY(verify_unswitched_loop_versions(_loop->_head->as_Loop(), unswitched_loop_selector);)\n+\n+    _phase->recompute_dom_depth();\n+    remove_unswitch_candidate_from_loops(unswitched_loop_selector);\n+  }\n+\n@@ -240,2 +254,8 @@\n-  void fix_loop_entries(IfProjNode* true_path_loop_entry, IfProjNode* false_path_loop_entry) {\n-    _phase->replace_loop_entry(_loop_head, true_path_loop_entry);\n+  void clone_loop(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+    _phase->clone_loop(_loop, _old_new, _phase->dom_depth(_loop_head),\n+                       PhaseIdealLoop::CloneIncludesStripMined, unswitched_loop_selector.selector());\n+    fix_loop_entries(unswitched_loop_selector);\n+  }\n+\n+  void fix_loop_entries(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+    _phase->replace_loop_entry(_loop_head, unswitched_loop_selector.true_path_loop_proj());\n@@ -243,1 +263,2 @@\n-    _phase->replace_loop_entry(false_path_loop_strip_mined_head, false_path_loop_entry);\n+    _phase->replace_loop_entry(false_path_loop_strip_mined_head,\n+                               unswitched_loop_selector.false_path_loop_proj());\n@@ -246,2 +267,13 @@\n-  Node* old_to_new(const Node* old) const {\n-    return _old_new[old->_idx];\n+  \/\/ Moves the Parse And Template Assertion Predicates to the true and false path loop. They are inserted between the\n+  \/\/ loop heads and the loop selector If projections. The old Parse and Template Assertion Predicates before\n+  \/\/ the unswitched loop selector are killed.\n+  void move_parse_and_template_assertion_predicates_to_unswitched_loops(\n+    const UnswitchedLoopSelector& unswitched_loop_selector, const uint first_false_path_loop_node_index) const {\n+    const NodeInOriginalLoopBody node_in_true_path_loop_body(first_false_path_loop_node_index, _old_new);\n+    const NodeInClonedLoopBody node_in_false_path_loop_body(first_false_path_loop_node_index);\n+    CloneUnswitchedLoopPredicatesVisitor\n+    clone_unswitched_loop_predicates_visitor(_loop_head, old_to_new(_loop_head)->as_Loop(), node_in_true_path_loop_body,\n+                                             node_in_false_path_loop_body, _phase);\n+    Node* source_loop_entry = unswitched_loop_selector.selector()->in(0);\n+    PredicateIterator predicate_iterator(source_loop_entry);\n+    predicate_iterator.for_each(clone_unswitched_loop_predicates_visitor);\n@@ -266,0 +298,4 @@\n+  Node* old_to_new(const Node* old) const {\n+    return _old_new[old->_idx];\n+  }\n+\n@@ -279,22 +315,0 @@\n- public:\n-  \/\/ Unswitch the original loop on the invariant loop selector by creating a true-path-loop and a false-path-loop.\n-  \/\/ Remove the unswitch candidate If from both unswitched loop versions which are now covered by the loop selector If.\n-  void unswitch(const UnswitchedLoopSelector& unswitched_loop_selector) {\n-    _phase->clone_loop(_loop, _old_new, _phase->dom_depth(_loop_head),\n-                       PhaseIdealLoop::CloneIncludesStripMined, unswitched_loop_selector.selector());\n-\n-    \/\/ At this point, the selector If projections are the corresponding loop entries.\n-    \/\/ clone_parse_and_assertion_predicates_to_unswitched_loop() could clone additional predicates after the selector\n-    \/\/ If projections. The loop entries are updated accordingly.\n-    IfProjNode* true_path_loop_entry = unswitched_loop_selector.true_path_loop_proj();\n-    IfProjNode* false_path_loop_entry = unswitched_loop_selector.false_path_loop_proj();\n-    _phase->clone_parse_and_assertion_predicates_to_unswitched_loop(_loop, _old_new,\n-                                                                    true_path_loop_entry, false_path_loop_entry);\n-\n-    fix_loop_entries(true_path_loop_entry, false_path_loop_entry);\n-\n-    DEBUG_ONLY(verify_unswitched_loop_versions(_loop->_head->as_Loop(), unswitched_loop_selector);)\n-\n-    _phase->recompute_dom_depth();\n-    remove_unswitch_candidate_from_loops(unswitched_loop_selector);\n-  }\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":41,"deletions":27,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -4461,1 +4461,1 @@\n-      get_template_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n+      get_opaque_template_assertion_predicate_nodes(parse_predicate_proj, useful_predicates);\n@@ -4469,1 +4469,1 @@\n-      get_template_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n+      get_opaque_template_assertion_predicate_nodes(parse_predicate_proj, useful_predicates);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -945,1 +945,2 @@\n-  static void get_template_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, bool get_opaque = false);\n+  static void get_opaque_template_assertion_predicate_nodes(ParsePredicateSuccessProj* parse_predicate_proj,\n+                                                            Unique_Node_List& list);\n@@ -1353,3 +1354,2 @@\n-      ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason, int opcode,\n-      bool rewire_uncommon_proj_phi_inputs = false,\n-      AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None);\n+    ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason, int opcode,\n+    bool rewire_uncommon_proj_phi_inputs = false);\n@@ -1664,5 +1664,0 @@\n- public:\n-  \/\/ Clone Parse Predicates to slow and fast loop when unswitching a loop\n-  void clone_parse_and_assertion_predicates_to_unswitched_loop(IdealLoopTree* loop, Node_List& old_new,\n-                                                               IfProjNode*& true_path_loop_entry,\n-                                                               IfProjNode*& false_path_loop_entry);\n@@ -1670,16 +1665,0 @@\n-  void clone_loop_predication_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n-                                                            const PredicateBlock* predicate_block,\n-                                                            Deoptimization::DeoptReason reason,\n-                                                            IfProjNode*& true_path_loop_entry,\n-                                                            IfProjNode*& false_path_loop_entry);\n-  void clone_parse_predicate_to_unswitched_loops(const PredicateBlock* predicate_block, Deoptimization::DeoptReason reason,\n-                                                 IfProjNode*& iffast_pred, IfProjNode*& ifslow_pred);\n-  IfProjNode* clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n-                                                       Deoptimization::DeoptReason reason, bool slow_loop);\n-  void clone_assertion_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n-                                                     ParsePredicateSuccessProj* old_parse_predicate_proj,\n-                                                     ParsePredicateNode* true_path_loop_parse_predicate,\n-                                                     ParsePredicateNode* false_path_loop_parse_predicate);\n-  IfTrueNode* clone_assertion_predicate_for_unswitched_loops(IfTrueNode* template_assertion_predicate_success_proj,\n-                                                             ParsePredicateNode* unswitched_loop_parse_predicate);\n-  static void check_cloned_parse_predicate_for_unswitching(const Node* new_entry, bool is_fast_loop) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/connode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,0 +85,19 @@\n+ParsePredicateSuccessProj* ParsePredicate::clone_to_unswitched_loop(Node* new_control, const bool is_true_path_loop,\n+                                                                    PhaseIdealLoop* phase) const {\n+  ParsePredicateSuccessProj* success_proj = phase->create_new_if_for_predicate(_success_proj, new_control,\n+                                                                               _parse_predicate_node->deopt_reason(),\n+                                                                               Op_ParsePredicate, is_true_path_loop);\n+  NOT_PRODUCT(trace_cloned_parse_predicate(is_true_path_loop, success_proj));\n+  return success_proj;\n+}\n+\n+#ifndef PRODUCT\n+void ParsePredicate::trace_cloned_parse_predicate(const bool is_true_path_loop,\n+                                                  const ParsePredicateSuccessProj* success_proj) {\n+  if (TraceLoopPredicate) {\n+    tty->print(\"Parse Predicate cloned to %s path loop: \", is_true_path_loop ? \"true\" : \"false\");\n+    success_proj->in(0)->dump();\n+  }\n+}\n+#endif \/\/ NOT PRODUCT\n+\n@@ -199,0 +218,6 @@\n+\/\/ Kills the Template Assertion Predicate by setting the condition to true. Will be folded away in the next IGVN round.\n+void TemplateAssertionPredicate::kill(PhaseIdealLoop* phase) const {\n+  ConINode* true_con = phase->intcon(1);\n+  phase->igvn().replace_input_of(_if_node, 1, true_con);\n+}\n+\n@@ -950,2 +975,2 @@\n-\/\/     Predicate 1             old target        clone           |    \\\n-\/\/          |                  loop entry        TAP 2           |     cloned Template Assertion\n+\/\/     Predicate 1            old target         clone           |    \\\n+\/\/          |                 loop entry         TAP 2           |     cloned Template Assertion\n@@ -980,0 +1005,67 @@\n+TargetLoopPredicateChain::TargetLoopPredicateChain(LoopNode* loop_head, PhaseIdealLoop* phase)\n+    : DEBUG_ONLY(_old_target_loop_entry(loop_head->in(LoopNode::EntryControl)) COMMA)\n+      DEBUG_ONLY(_node_index_before_cloning(phase->C->unique()) COMMA)\n+      _current_predicate_chain_head(loop_head),\n+      _phase(phase) {}\n+\n+\/\/ Inserts the provided newly cloned predicate to the head of the target loop predicate chain.\n+void TargetLoopPredicateChain::insert_predicate(IfTrueNode* predicate_success_proj) {\n+  rewire_to_target_chain_head(predicate_success_proj);\n+  _current_predicate_chain_head = predicate_success_proj->in(0);\n+  assert(predicate_success_proj->_idx >= _node_index_before_cloning, \"must be a newly cloned predicate\");\n+  assert(_current_predicate_chain_head->in(0) == _old_target_loop_entry &&\n+         _old_target_loop_entry->unique_ctrl_out() == _current_predicate_chain_head , \"must be connected now\");\n+}\n+\n+void TargetLoopPredicateChain::rewire_to_target_chain_head(IfTrueNode* template_assertion_predicate_success_proj) const {\n+  if (_current_predicate_chain_head->is_Loop()) {\n+    _phase->replace_loop_entry(_current_predicate_chain_head->as_Loop(), template_assertion_predicate_success_proj);\n+  } else {\n+    _phase->replace_control(_current_predicate_chain_head, template_assertion_predicate_success_proj);\n+  }\n+}\n+\n+ClonePredicateToTargetLoop::ClonePredicateToTargetLoop(LoopNode* target_loop_head, const NodeInLoopBody& node_in_loop_body,\n+                                                       PhaseIdealLoop* phase)\n+    : _old_target_loop_entry(target_loop_head->in(LoopNode::EntryControl)),\n+      _target_loop_predicate_chain(target_loop_head, phase),\n+      _node_in_loop_body(node_in_loop_body),\n+      _phase(phase) {}\n+\n+\n+CloneUnswitchedLoopPredicatesVisitor::CloneUnswitchedLoopPredicatesVisitor(\n+    LoopNode* true_path_loop_head, LoopNode* false_path_loop_head,\n+    const NodeInOriginalLoopBody& node_in_true_path_loop_body, const NodeInClonedLoopBody& node_in_false_path_loop_body,\n+    PhaseIdealLoop* phase)\n+    : _clone_predicate_to_true_path_loop(true_path_loop_head, node_in_true_path_loop_body, phase),\n+      _clone_predicate_to_false_path_loop(false_path_loop_head, node_in_false_path_loop_body, phase),\n+      _phase(phase),\n+      _has_hoisted_check_parse_predicates(false) {}\n+\n+\/\/ Keep track of whether we are in the correct Predicate Block where Template Assertion Predicates can be found.\n+\/\/ The PredicateIterator will always start at the loop entry and first visits the Loop Limit Check Predicate Block.\n+void CloneUnswitchedLoopPredicatesVisitor::visit(const ParsePredicate& parse_predicate) {\n+  Deoptimization::DeoptReason deopt_reason = parse_predicate.head()->deopt_reason();\n+  if (deopt_reason == Deoptimization::Reason_predicate ||\n+      deopt_reason == Deoptimization::Reason_profile_predicate) {\n+    _has_hoisted_check_parse_predicates = true;\n+  }\n+\n+  _clone_predicate_to_true_path_loop.clone_parse_predicate(parse_predicate, true);\n+  _clone_predicate_to_false_path_loop.clone_parse_predicate(parse_predicate, false);\n+  parse_predicate.kill(_phase->igvn());\n+}\n+\n+\/\/ Clone the Template Assertion Predicate, which is currently found before the newly added unswitched loop selector,\n+\/\/ to the true path and false path loop.\n+void CloneUnswitchedLoopPredicatesVisitor::visit(const TemplateAssertionPredicate& template_assertion_predicate) {\n+  if (!_has_hoisted_check_parse_predicates) {\n+    \/\/ Only process if we are in the correct Predicate Block.\n+    return;\n+  }\n+\n+  _clone_predicate_to_true_path_loop.clone_template_assertion_predicate(template_assertion_predicate);\n+  _clone_predicate_to_false_path_loop.clone_template_assertion_predicate(template_assertion_predicate);\n+  template_assertion_predicate.kill(_phase);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":94,"deletions":2,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"opto\/connode.hpp\"\n@@ -235,1 +234,1 @@\n-class PredicateVisitor : StackObj {\n+class PredicateVisitor : public StackObj {\n@@ -300,0 +299,2 @@\n+  NOT_PRODUCT(static void trace_cloned_parse_predicate(bool is_true_path_loop,\n+                                                       const ParsePredicateSuccessProj* success_proj);)\n@@ -328,0 +329,9 @@\n+\n+  ParsePredicateSuccessProj* clone_to_unswitched_loop(Node* new_control, bool is_true_path_loop,\n+                                                      PhaseIdealLoop* phase) const;\n+\n+  \/\/ Kills this Parse Predicate by marking it useless. Will be folded away in the next IGVN round.\n+  void kill(const PhaseIterGVN& igvn) const {\n+    _parse_predicate_node->mark_useless();\n+    igvn._worklist.push(_parse_predicate_node);\n+  }\n@@ -402,0 +412,1 @@\n+  void kill(PhaseIdealLoop* phase) const;\n@@ -1009,3 +1020,88 @@\n-\/\/ This visitor collects all Template Assertion Predicates If nodes or the corresponding Opaque nodes, depending on the\n-\/\/ provided 'get_opaque' flag, to the provided list.\n-class TemplateAssertionPredicateCollector : public PredicateVisitor {\n+\/\/ This class establishes a predicate chain at the target loop by rewiring newly cloned predicates to the current head\n+\/\/ of the predicate chain.\n+class TargetLoopPredicateChain : public StackObj {\n+  DEBUG_ONLY(const Node* const _old_target_loop_entry;)\n+  DEBUG_ONLY(const node_idx_t _node_index_before_cloning;)\n+  Node* _current_predicate_chain_head;\n+  PhaseIdealLoop* const _phase;\n+\n+  void rewire_to_target_chain_head(IfTrueNode* template_assertion_predicate_success_proj) const;\n+\n+public:\n+  TargetLoopPredicateChain(LoopNode* loop_head, PhaseIdealLoop* phase);\n+  NONCOPYABLE(TargetLoopPredicateChain);\n+\n+  void insert_predicate(IfTrueNode* predicate_success_proj);\n+};\n+\n+\/\/ This class clones Parse and Template Assertion Predicates to the provided target loop. This also involves rewiring\n+\/\/ of any data pinned to Template Assertion Predicates. The Template Assertion Predicate Expressions are cloned\n+\/\/ without applying any changes to them.\n+\/\/\n+\/\/ Each time a predicate is cloned, it is inserted at the top of previously cloned predicates. This ensures that the\n+\/\/ target loop predicate chain order of the newly cloned predicates is the same as in the source loop from which the\n+\/\/ predicates were cloned from.\n+\/\/\n+\/\/ Template Assertion Predicate Example:\n+\/\/\n+\/\/            x                           _old_target_loop_entry                                 _old_target_loop_entry\n+\/\/            |                                |           |                                               |\n+\/\/    Template Assertion                       |       Cloned Template       2. rewire data          Cloned Template\n+\/\/        Predicate           1. clone         |     Assertion Predicate        and predicate      Assertion Predicate\n+\/\/            |     \\         =======>         |                             ===============>           |        \\\n+\/\/            |     data                       |                                                        |        data\n+\/\/            |                                |                                                        |\n+\/\/    source loop head                      target loop head                                       target loop head\n+class ClonePredicateToTargetLoop : public StackObj {\n+  Node* const _old_target_loop_entry; \/\/ Used as control for each newly cloned predicate.\n+  TargetLoopPredicateChain _target_loop_predicate_chain;\n+  const NodeInLoopBody& _node_in_loop_body;\n+  PhaseIdealLoop* const _phase;\n+\n+public:\n+  ClonePredicateToTargetLoop(LoopNode* target_loop_head, const NodeInLoopBody& node_in_loop_body, PhaseIdealLoop* phase);\n+\n+  \/\/ Clones the provided Parse Predicate to the head of the current predicate chain at the target loop.\n+  void clone_parse_predicate(const ParsePredicate& parse_predicate, bool is_true_path_loop) {\n+    ParsePredicateSuccessProj* cloned_parse_predicate_success_proj =\n+      parse_predicate.clone_to_unswitched_loop(_old_target_loop_entry, is_true_path_loop, _phase);\n+    _target_loop_predicate_chain.insert_predicate(cloned_parse_predicate_success_proj);\n+  }\n+\n+  \/\/ Clones the provided Template Assertion Predicate to the head of the current predicate chain at the target loop.\n+  void clone_template_assertion_predicate(const TemplateAssertionPredicate& template_assertion_predicate) {\n+    IfTrueNode* cloned_template_success_proj = template_assertion_predicate.clone(_old_target_loop_entry,\n+                                                                                  _phase);\n+    template_assertion_predicate.rewire_loop_data_dependencies(cloned_template_success_proj, _node_in_loop_body, _phase);\n+    _target_loop_predicate_chain.insert_predicate(cloned_template_success_proj);\n+  }\n+};\n+\n+\/\/ Visitor to clone Parse and Template Assertion Predicates from a loop to its unswitched true and false path loop.\n+\/\/ The cloned predicates are not updated in any way. Thus, an Initialized Assertion Predicate is also not required to\n+\/\/ be created. Note that the data dependencies from the Template Assertion Predicates are also updated to the newly\n+\/\/ cloned Template Assertion Predicates, depending on whether they belong to the true or false path loop.\n+class CloneUnswitchedLoopPredicatesVisitor : public PredicateVisitor {\n+  ClonePredicateToTargetLoop _clone_predicate_to_true_path_loop;\n+  ClonePredicateToTargetLoop _clone_predicate_to_false_path_loop;\n+\n+  PhaseIdealLoop* const _phase;\n+  bool _has_hoisted_check_parse_predicates;\n+\n+ public:\n+  CloneUnswitchedLoopPredicatesVisitor(LoopNode* true_path_loop_head,\n+                                       LoopNode* false_path_loop_head,\n+                                       const NodeInOriginalLoopBody& node_in_true_path_loop_body,\n+                                       const NodeInClonedLoopBody& node_in_false_path_loop_body,\n+                                       PhaseIdealLoop* phase);\n+  NONCOPYABLE(CloneUnswitchedLoopPredicatesVisitor);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const ParsePredicate& parse_predicate) override;\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override;\n+};\n+\n+\/\/ This visitor collects all OpaqueTemplateAssertionNodes of Template Assertion Predicates. This is used for cleaning\n+\/\/ up unused Template Assertion Predicates.\n+class OpaqueTemplateAssertionPredicateCollector : public PredicateVisitor {\n@@ -1013,1 +1109,0 @@\n-  const bool _get_opaque;\n@@ -1016,3 +1111,1 @@\n-  TemplateAssertionPredicateCollector(Unique_Node_List& list, const bool get_opaque)\n-      : _list(list),\n-        _get_opaque(get_opaque) {}\n+  explicit OpaqueTemplateAssertionPredicateCollector(Unique_Node_List& list) : _list(list) {}\n@@ -1023,5 +1116,1 @@\n-    if (_get_opaque) {\n-      _list.push(template_assertion_predicate.opaque_node());\n-    } else {\n-      _list.push(template_assertion_predicate.tail());\n-    }\n+    _list.push(template_assertion_predicate.opaque_node());\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":103,"deletions":14,"binary":false,"changes":117,"status":"modified"}]}