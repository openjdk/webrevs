{"files":[{"patch":"@@ -270,4 +270,1 @@\n-    \/\/ Cannot cast to own type\n-    if (to_bt == from_bt) {\n-      return false;\n-    }\n+    assert(to_bt != from_bt, \"Must call with different from_bt and to_bt\");\n@@ -275,0 +272,1 @@\n+    \/\/ T_CHAR is not supported yet due to the backend not implementing vector casts to and from char.\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -537,1 +537,1 @@\n-  NOT_PRODUCT(virtual const char* name() const override { return \"Cast\"; };)\n+  NOT_PRODUCT(virtual const char* name() const override { return \"CastVector\"; };)\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,0 +108,6 @@\n+        tests.put(\"testIntToShort\",  () -> { return testIntToShort(aI.clone(), bS.clone()); });\n+        tests.put(\"testIntToByte\",   () -> { return testIntToByte(aI.clone(), bB.clone()); });\n+        tests.put(\"testShortToByte\", () -> { return testShortToByte(aS.clone(), bB.clone()); });\n+        tests.put(\"testShortToInt\",  () -> { return testShortToInt(aS.clone(), bI.clone()); });\n+        tests.put(\"testByteToInt\",   () -> { return testByteToInt(aB.clone(), bI.clone()); });\n+        tests.put(\"testByteToShort\", () -> { return testByteToShort(aB.clone(), bS.clone()); });\n@@ -130,1 +136,7 @@\n-                 \"test11\"})\n+                 \"test11\",\n+                 \"testIntToShort\",\n+                 \"testIntToByte\",\n+                 \"testShortToByte\",\n+                 \"testShortToInt\",\n+                 \"testByteToInt\",\n+                 \"testByteToShort\"})\n@@ -476,0 +488,76 @@\n+\n+    \/\/ Narrowing\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n+    public Object[] testIntToShort(int[] ints, short[] res) {\n+        for (int i = 0; i < ints.length; i++) {\n+            res[i] = (short) ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n+    public Object[] testIntToByte(int[] ints, byte[] res) {\n+        for (int i = 0; i < ints.length; i++) {\n+            res[i] = (byte) ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2B, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    public Object[] testShortToByte(short[] shorts, byte[] res) {\n+        for (int i = 0; i < shorts.length; i++) {\n+            res[i] = (byte) shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    \/\/ Widening\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2I, IRNode.VECTOR_SIZE + \"min(max_short, max_int)\", \">0\" })\n+    public Object[] testShortToInt(short[] shorts, int[] res) {\n+        for (int i = 0; i < shorts.length; i++) {\n+            res[i] = shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2I, IRNode.VECTOR_SIZE + \"min(max_byte, max_int)\", \">0\" })\n+    public Object[] testByteToInt(byte[] bytes, int[] res) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_byte, max_short)\", \">0\" })\n+    public Object[] testByteToShort(byte[] bytes, short[] res) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":89,"deletions":1,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-\n-import compiler.lib.generators.*;\n-import compiler.lib.ir_framework.*;\n-import java.util.Random;\n-import jdk.test.lib.Utils;\n-\n-\/*\n- * @test\n- * @bug 8342095\n- * @key randomness\n- * @summary Ensure that vectorization of conversions between subword types works as expected.\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestSubwordVectorization\n- *\/\n-\n-public class TestSubwordVectorization {\n-    private static final Generator<Integer> G = Generators.G.ints();\n-\n-    private static final int SIZE = 1024;\n-\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Setup\n-    static Object[] setupIntArray() {\n-        int[] res = new int[SIZE];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = G.next();\n-        }\n-\n-        return new Object[] { res };\n-    }\n-\n-    @Setup\n-    static Object[] setupShortArray() {\n-        short[] res = new short[SIZE];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = G.next().shortValue();\n-        }\n-\n-        return new Object[] { res };\n-    }\n-\n-    @Setup\n-    static Object[] setupByteArray() {\n-        byte[] res = new byte[SIZE];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = G.next().byteValue();\n-        }\n-\n-        return new Object[] { res };\n-    }\n-\n-    \/\/ Narrowing\n-\n-    @Test\n-    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n-        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n-        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n-    @Arguments(setup = \"setupIntArray\")\n-    public Object[] testIntToShort(int[] ints) {\n-        short[] res = new short[SIZE];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = (short) ints[i];\n-        }\n-\n-        return new Object[] { ints, res };\n-    }\n-\n-    @Check(test = \"testIntToShort\")\n-    public void checkTestIntToShort(Object[] vals) {\n-        int[] ints = (int[]) vals[0];\n-        short[] res = (short[]) vals[1];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            short value = (short) ints[i];\n-\n-            if (res[i] != value) {\n-                throw new IllegalStateException(\"Int to short test failed: Expected \" + value + \" but got \" + res[i]);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n-        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n-        counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n-    @Arguments(setup = \"setupIntArray\")\n-    public Object[] testIntToByte(int[] ints) {\n-        byte[] res = new byte[SIZE];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = (byte) ints[i];\n-        }\n-\n-        return new Object[] { ints, res };\n-    }\n-\n-    @Check(test = \"testIntToByte\")\n-    public void checkTestIntToByte(Object[] vals) {\n-        int[] ints = (int[]) vals[0];\n-        byte[] res = (byte[]) vals[1];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            byte value = (byte) ints[i];\n-\n-            if (res[i] != value) {\n-                throw new IllegalStateException(\"Int to byte test failed: Expected \" + value + \" but got \" + res[i]);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n-        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n-        counts = { IRNode.VECTOR_CAST_S2B, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n-    @Arguments(setup = \"setupShortArray\")\n-    public Object[] testShortToByte(short[] shorts) {\n-        byte[] res = new byte[SIZE];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = (byte) shorts[i];\n-        }\n-\n-        return new Object[] { shorts, res };\n-    }\n-\n-    @Check(test = \"testShortToByte\")\n-    public void checkTestShortToByte(Object[] vals) {\n-        short[] shorts = (short[]) vals[0];\n-        byte[] res = (byte[]) vals[1];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            byte value = (byte) shorts[i];\n-\n-            if (res[i] != value) {\n-                throw new IllegalStateException(\"Short to byte test failed: Expected \" + value + \" but got \" + res[i]);\n-            }\n-        }\n-    }\n-\n-    \/\/ Widening\n-\n-    @Test\n-    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n-        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n-        counts = { IRNode.VECTOR_CAST_S2I, IRNode.VECTOR_SIZE + \"min(max_short, max_int)\", \">0\" })\n-    @Arguments(setup = \"setupShortArray\")\n-    public Object[] testShortToInt(short[] shorts) {\n-        int[] res = new int[SIZE];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = shorts[i];\n-        }\n-\n-        return new Object[] { shorts, res };\n-    }\n-\n-    @Check(test = \"testShortToInt\")\n-    public void checkTestShortToInt(Object[] vals) {\n-        short[] shorts = (short[]) vals[0];\n-        int[] res = (int[]) vals[1];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            int value = shorts[i];\n-\n-            if (res[i] != value) {\n-                throw new IllegalStateException(\"Short to int test failed: Expected \" + value + \" but got \" + res[i]);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n-        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n-        counts = { IRNode.VECTOR_CAST_B2I, IRNode.VECTOR_SIZE + \"min(max_byte, max_int)\", \">0\" })\n-    @Arguments(setup = \"setupByteArray\")\n-    public Object[] testByteToInt(byte[] bytes) {\n-        int[] res = new int[SIZE];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = bytes[i];\n-        }\n-\n-        return new Object[] { bytes, res };\n-    }\n-\n-    @Check(test = \"testByteToInt\")\n-    public void checkTestByteToInt(Object[] vals) {\n-        byte[] bytes = (byte[]) vals[0];\n-        int[] res = (int[]) vals[1];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            int value = bytes[i];\n-\n-            if (res[i] != value) {\n-                throw new IllegalStateException(\"Byte to int test failed: Expected \" + value + \" but got \" + res[i]);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n-        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n-        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_byte, max_short)\", \">0\" })\n-    @Arguments(setup = \"setupByteArray\")\n-    public Object[] testByteToShort(byte[] bytes) {\n-        short[] res = new short[SIZE];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = bytes[i];\n-        }\n-\n-        return new Object[] { bytes, res };\n-    }\n-\n-    @Check(test = \"testByteToShort\")\n-    public void checkTestByteToShort(Object[] vals) {\n-        byte[] bytes = (byte[]) vals[0];\n-        short[] res = (short[]) vals[1];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            short value = bytes[i];\n-\n-            if (res[i] != value) {\n-                throw new IllegalStateException(\"Byte to short test failed: Expected \" + value + \" but got \" + res[i]);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSubwordVectorization.java","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"}]}