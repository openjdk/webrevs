{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,0 +201,4 @@\n+  static bool is_vector_cast_supported(BasicType from_bt, BasicType to_bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,0 +194,4 @@\n+  static bool is_vector_cast_supported(BasicType from_bt, BasicType to_bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,4 @@\n+  static bool is_vector_cast_supported(BasicType from_bt, BasicType to_bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,0 +200,4 @@\n+  static bool is_vector_cast_supported(BasicType from_bt, BasicType to_bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,0 +197,4 @@\n+  static bool is_vector_cast_supported(BasicType from_bt, BasicType to_bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,0 +264,23 @@\n+  static bool is_vector_cast_supported(BasicType from_bt, BasicType to_bt) {\n+    \/\/ Vector casts are only supported on AVX1 and higher\n+    if (UseAVX == 0) {\n+      return false;\n+    }\n+\n+    \/\/ Cannot cast to own type\n+    if (to_bt == from_bt) {\n+      return false;\n+    }\n+\n+    switch (from_bt) {\n+      case T_INT:\n+      case T_SHORT:\n+      case T_BYTE: {\n+        return to_bt == T_INT || to_bt == T_SHORT || to_bt == T_BYTE;\n+      }\n+      default: {\n+        return false;\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2350,2 +2350,11 @@\n-  \/\/ Default case: input size of use equals output size of def.\n-  return type2aelembytes(use_bt) == type2aelembytes(def_bt);\n+  \/\/ Input size of use equals output size of def\n+  if (type2aelembytes(use_bt) == type2aelembytes(def_bt)) {\n+    return true;\n+  }\n+\n+  \/\/ Input sizes differ, but platform supports a cast to change the def shape to the use shape\n+  if (Matcher::is_vector_cast_supported(def_bt, use_bt)) {\n+    return true;\n+  }\n+\n+  return false;\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -189,0 +189,13 @@\n+    Node* in_p0 = pack_in->at(0);\n+    BasicType def_bt = _vloop_analyzer.types().velt_basic_type(in_p0);\n+    BasicType use_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+\n+    \/\/ If the use and def types are different, emit a cast node\n+    if (use_bt != def_bt && !p0->is_Convert() && Matcher::is_vector_cast_supported(def_bt, use_bt)) {\n+      VTransformNode* in = get_vtnode(pack_in->at(0));\n+      VTransformNode* cast = new (_vtransform.arena()) VTransformCastVectorNode(_vtransform, pack->size(), def_bt, use_bt);\n+      cast->set_req(1, in);\n+\n+      return cast;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -604,0 +604,9 @@\n+VTransformApplyResult VTransformCastVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                       const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* value = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  VectorNode* vn = VectorCastNode::make(VectorCastNode::opcode(-1, _from_bt), value, _to_bt, _vlen);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, value);\n+\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->vect_type()->length_in_bytes());\n+}\n+\n@@ -699,0 +708,4 @@\n+void VTransformCastVectorNode::print_spec() const {\n+  tty->print(\"vlen=%d from=%s to=%s\", _vlen, type2name(_from_bt), type2name(_to_bt));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -525,0 +525,16 @@\n+class VTransformCastVectorNode : public VTransformNode {\n+private:\n+  uint _vlen;\n+  BasicType _from_bt;\n+  BasicType _to_bt;\n+\n+public:\n+  \/\/ req = 2 -> [ctrl, input]\n+  VTransformCastVectorNode(VTransform& vtransform, int vlen, BasicType from_bt, BasicType to_bt) : VTransformNode(vtransform, 2),\n+    _vlen(vlen), _from_bt(from_bt), _to_bt(to_bt) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Cast\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -330,1 +330,1 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\"},\n@@ -332,1 +332,2 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n@@ -335,1 +336,0 @@\n-    \/\/ Vector code would need a conversion. We may add this in the future.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8342095\n+ * @key randomness\n+ * @summary Ensure that vectorization of conversions between subword types works as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestSubwordVectorization\n+ *\/\n+\n+public class TestSubwordVectorization {\n+    private static final Generator<Integer> G = Generators.G.ints();\n+\n+    private static final int SIZE = 1024;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Setup\n+    static Object[] setupIntArray() {\n+        int[] res = new int[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = G.next();\n+        }\n+\n+        return new Object[] { res };\n+    }\n+\n+    @Setup\n+    static Object[] setupShortArray() {\n+        short[] res = new short[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = G.next().shortValue();\n+        }\n+\n+        return new Object[] { res };\n+    }\n+\n+    @Setup\n+    static Object[] setupByteArray() {\n+        byte[] res = new byte[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = G.next().byteValue();\n+        }\n+\n+        return new Object[] { res };\n+    }\n+\n+    \/\/ Narrowing\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n+    @Arguments(setup = \"setupIntArray\")\n+    public Object[] testIntToShort(int[] ints) {\n+        short[] res = new short[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+    @Check(test = \"testIntToShort\")\n+    public void checkTestIntToShort(Object[] vals) {\n+        int[] ints = (int[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short value = (short) ints[i];\n+\n+            if (res[i] != value) {\n+                throw new IllegalStateException(\"Int to short test failed: Expected \" + value + \" but got \" + res[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n+    @Arguments(setup = \"setupIntArray\")\n+    public Object[] testIntToByte(int[] ints) {\n+        byte[] res = new byte[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+    @Check(test = \"testIntToByte\")\n+    public void checkTestIntToByte(Object[] vals) {\n+        int[] ints = (int[]) vals[0];\n+        byte[] res = (byte[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            byte value = (byte) ints[i];\n+\n+            if (res[i] != value) {\n+                throw new IllegalStateException(\"Int to byte test failed: Expected \" + value + \" but got \" + res[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2B, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortToByte(short[] shorts) {\n+        byte[] res = new byte[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    @Check(test = \"testShortToByte\")\n+    public void checkTestShortToByte(Object[] vals) {\n+        short[] shorts = (short[]) vals[0];\n+        byte[] res = (byte[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            byte value = (byte) shorts[i];\n+\n+            if (res[i] != value) {\n+                throw new IllegalStateException(\"Short to byte test failed: Expected \" + value + \" but got \" + res[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Widening\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2I, IRNode.VECTOR_SIZE + \"min(max_short, max_int)\", \">0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortToInt(short[] shorts) {\n+        int[] res = new int[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    @Check(test = \"testShortToInt\")\n+    public void checkTestShortToInt(Object[] vals) {\n+        short[] shorts = (short[]) vals[0];\n+        int[] res = (int[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            int value = shorts[i];\n+\n+            if (res[i] != value) {\n+                throw new IllegalStateException(\"Short to int test failed: Expected \" + value + \" but got \" + res[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2I, IRNode.VECTOR_SIZE + \"min(max_byte, max_int)\", \">0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteToInt(byte[] bytes) {\n+        int[] res = new int[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Check(test = \"testByteToInt\")\n+    public void checkTestByteToInt(Object[] vals) {\n+        byte[] bytes = (byte[]) vals[0];\n+        int[] res = (int[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            int value = bytes[i];\n+\n+            if (res[i] != value) {\n+                throw new IllegalStateException(\"Byte to int test failed: Expected \" + value + \" but got \" + res[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_byte, max_short)\", \">0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteToShort(byte[] bytes) {\n+        short[] res = new short[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Check(test = \"testByteToShort\")\n+    public void checkTestByteToShort(Object[] vals) {\n+        byte[] bytes = (byte[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short value = bytes[i];\n+\n+            if (res[i] != value) {\n+                throw new IllegalStateException(\"Byte to short test failed: Expected \" + value + \" but got \" + res[i]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSubwordVectorization.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,3 +255,2 @@\n-    \/\/ Note that right shift operations on subword expressions cannot be\n-    \/\/ vectorized since precise type info about signedness is missing.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(applyIfCPUFeature = {\"avx\", \"true\"},\n+            counts = {IRNode.RSHIFT_VI, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @bug 8183390 8340010 8342095\n@@ -111,4 +112,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2I, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -125,1 +125,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n@@ -137,4 +137,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2I, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n@@ -149,0 +148,12 @@\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    public short[] signExtensionFromByteToShort() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = bytes[i];\n+        }\n+        return res;\n+    }\n+\n@@ -151,4 +162,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -164,4 +174,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_char)\", \">0\" })\n@@ -177,5 +186,4 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n-    public byte[] NarrowToByte() {\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n+    public byte[] narrowToByte() {\n@@ -189,0 +197,12 @@\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2B, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    public byte[] narrowShortToByte() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) shorts[i];\n+        }\n+        return res;\n+    }\n+\n@@ -268,1 +288,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n@@ -281,1 +301,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":45,"deletions":25,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class VectorSubword {\n+    @Param({\"1024\"})\n+    public int SIZE;\n+\n+    private byte[] bytes;\n+    private short[] shorts;\n+    private int[] ints;\n+\n+    @Setup\n+    public void init() {\n+        bytes = new byte[SIZE];\n+        shorts = new short[SIZE];\n+        ints = new int[SIZE];\n+    }\n+\n+    @Benchmark\n+    public void intToShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shorts[i] = (short) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intToByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i] = (byte) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortToByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i] = (byte) shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortToInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteToInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = bytes[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteToShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shorts[i] = bytes[i];\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorSubword.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}