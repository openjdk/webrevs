{"files":[{"patch":"@@ -2217,1 +2217,1 @@\n-  if (!is_velt_basic_type_compatible_use_def(use, def)) {\n+  if (!is_velt_basic_type_compatible_use_def(use, def, d_pk->size())) {\n@@ -2283,1 +2283,1 @@\n-bool SuperWord::is_velt_basic_type_compatible_use_def(Node* use, Node* def) const {\n+bool SuperWord::is_velt_basic_type_compatible_use_def(Node* use, Node* def, const uint pack_size) const {\n@@ -2309,2 +2309,11 @@\n-  \/\/ Default case: input size of use equals output size of def.\n-  return type2aelembytes(use_bt) == type2aelembytes(def_bt);\n+  \/\/ Input size of use equals output size of def\n+  if (type2aelembytes(use_bt) == type2aelembytes(def_bt)) {\n+    return true;\n+  }\n+\n+  \/\/ Subword cast: Element sizes differ, but the platform supports a cast to change the def shape to the use shape.\n+  if (VectorCastNode::is_supported_subword_cast(def_bt, use_bt, pack_size)) {\n+    return true;\n+  }\n+\n+  return false;\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -656,1 +656,1 @@\n-  bool is_velt_basic_type_compatible_use_def(Node* use, Node* def) const;\n+  bool is_velt_basic_type_compatible_use_def(Node* use, Node* def, const uint pack_size) const;\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -257,0 +257,14 @@\n+    Node* in_p0 = pack_in->at(0);\n+    BasicType def_bt = _vloop_analyzer.types().velt_basic_type(in_p0);\n+    BasicType use_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+\n+    \/\/ If the use and def types are different, emit a cast node\n+    if (use_bt != def_bt && !p0->is_Convert() && VectorCastNode::is_supported_subword_cast(def_bt, use_bt, pack->size())) {\n+      VTransformNode* in = get_vtnode(pack_in->at(0));\n+      const VTransformVectorNodeProperties properties = VTransformVectorNodeProperties::make_from_pack(pack, _vloop_analyzer);\n+      VTransformNode* cast = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, 2, properties, VectorCastNode::opcode(-1, def_bt));\n+      cast->set_req(1, in);\n+\n+      return cast;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1536,0 +1536,7 @@\n+bool VectorCastNode::is_supported_subword_cast(BasicType def_bt, BasicType use_bt, const uint pack_size) {\n+  assert(def_bt != use_bt, \"use and def types must be different\");\n+\n+  \/\/ Opcode is only required to disambiguate half float, so we pass -1 as it can't be encountered here.\n+  return (is_subword_type(def_bt) || is_subword_type(use_bt)) && VectorCastNode::implemented(-1, pack_size, def_bt, use_bt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1835,0 +1835,1 @@\n+  static bool is_supported_subword_cast(BasicType def_bt, BasicType use_bt, const uint pack_size);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -978,0 +978,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +34,1 @@\n- * @bug 8294816\n+ * @bug 8294816 8342095\n@@ -61,3 +62,3 @@\n-    \/\/ Ensure vector max\/min instructions are not generated for integer subword types\n-    \/\/ as Java APIs for Math.min\/max do not support integer subword types and superword\n-    \/\/ should not generate vectorized Min\/Max nodes for them.\n+    \/\/ Ensure that casts to\/from subword types are emitted, as java APIs for Math.min\/max do not support integer subword\n+    \/\/ types and superword should generate int versions and then cast between them.\n+\n@@ -65,1 +66,1 @@\n-    @IR(failOn = {IRNode.MIN_VI, IRNode.MIN_VF, IRNode.MIN_VD})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -81,1 +82,1 @@\n-    @IR(failOn = {IRNode.MAX_VI, IRNode.MAX_VF, IRNode.MAX_VD})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -96,1 +97,1 @@\n-    @IR(failOn = {IRNode.MIN_VI, IRNode.MIN_VF, IRNode.MIN_VD})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n@@ -112,1 +113,1 @@\n-    @IR(failOn = {IRNode.MAX_VI, IRNode.MAX_VF, IRNode.MAX_VD})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMinMaxSubword.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @bug 8325155\n+ * @bug 8325155 8342095\n@@ -109,0 +109,16 @@\n+        tests.put(\"testByteToInt\",   () -> { return testByteToInt(aB.clone(), bI.clone()); });\n+        tests.put(\"testByteToShort\", () -> { return testByteToShort(aB.clone(), bS.clone()); });\n+        tests.put(\"testByteToChar\",  () -> { return testByteToChar(aB.clone(), bC.clone()); });\n+        tests.put(\"testByteToLong\",  () -> { return testByteToLong(aB.clone(), bL.clone()); });\n+        tests.put(\"testShortToByte\", () -> { return testShortToByte(aS.clone(), bB.clone()); });\n+        tests.put(\"testShortToChar\", () -> { return testShortToChar(aS.clone(), bC.clone()); });\n+        tests.put(\"testShortToInt\",  () -> { return testShortToInt(aS.clone(), bI.clone()); });\n+        tests.put(\"testShortToLong\", () -> { return testShortToLong(aS.clone(), bL.clone()); });\n+        tests.put(\"testIntToShort\",  () -> { return testIntToShort(aI.clone(), bS.clone()); });\n+        tests.put(\"testIntToChar\",   () -> { return testIntToChar(aI.clone(), bC.clone()); });\n+        tests.put(\"testIntToByte\",   () -> { return testIntToByte(aI.clone(), bB.clone()); });\n+        tests.put(\"testIntToLong\",   () -> { return testIntToLong(aI.clone(), bL.clone()); });\n+        tests.put(\"testLongToByte\",  () -> { return testLongToByte(aL.clone(), bB.clone()); });\n+        tests.put(\"testLongToShort\", () -> { return testLongToShort(aL.clone(), bS.clone()); });\n+        tests.put(\"testLongToChar\",  () -> { return testLongToChar(aL.clone(), bC.clone()); });\n+        tests.put(\"testLongToInt\",   () -> { return testLongToInt(aL.clone(), bI.clone()); });\n@@ -131,1 +147,17 @@\n-                 \"test11\"})\n+                 \"test11\",\n+                 \"testByteToInt\",\n+                 \"testByteToShort\",\n+                 \"testByteToChar\",\n+                 \"testByteToLong\",\n+                 \"testShortToByte\",\n+                 \"testShortToChar\",\n+                 \"testShortToInt\",\n+                 \"testShortToLong\",\n+                 \"testIntToShort\",\n+                 \"testIntToChar\",\n+                 \"testIntToByte\",\n+                 \"testIntToLong\",\n+                 \"testLongToByte\",\n+                 \"testLongToShort\",\n+                 \"testLongToChar\",\n+                 \"testLongToInt\"})\n@@ -331,1 +363,1 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\"},\n@@ -333,1 +365,2 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -336,1 +369,0 @@\n-    \/\/ Vector code would need a conversion. We may add this in the future.\n@@ -481,0 +513,197 @@\n+\n+    \/\/ Narrowing\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n+    public Object[] testIntToShort(int[] ints, short[] res) {\n+        for (int i = 0; i < ints.length; i++) {\n+            res[i] = (short) ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_char)\", \">0\" })\n+    public Object[] testIntToChar(int[] ints, char[] res) {\n+        for (int i = 0; i < ints.length; i++) {\n+            res[i] = (char) ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n+    public Object[] testIntToByte(int[] ints, byte[] res) {\n+        for (int i = 0; i < ints.length; i++) {\n+            res[i] = (byte) ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2B, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    public Object[] testShortToByte(short[] shorts, byte[] res) {\n+        for (int i = 0; i < shorts.length; i++) {\n+            res[i] = (byte) shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx2\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_L2B, IRNode.VECTOR_SIZE + \"min(max_long, max_byte)\", \">0\" })\n+    public Object[] testLongToByte(long[] longs, byte[] res) {\n+        for (int i = 0; i < longs.length; i++) {\n+            res[i] = (byte) longs[i];\n+        }\n+\n+        return new Object[] { longs, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_L2S, IRNode.VECTOR_SIZE + \"min(max_long, max_short)\", \">0\" })\n+    public Object[] testLongToShort(long[] longs, short[] res) {\n+        for (int i = 0; i < longs.length; i++) {\n+            res[i] = (short) longs[i];\n+        }\n+\n+        return new Object[] { longs, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_L2S, IRNode.VECTOR_SIZE + \"min(max_long, max_char)\", \">0\" })\n+    public Object[] testLongToChar(long[] longs, char[] res) {\n+        for (int i = 0; i < longs.length; i++) {\n+            res[i] = (char) longs[i];\n+        }\n+\n+        return new Object[] { longs, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_L2I, IRNode.VECTOR_SIZE + \"min(max_long, max_int)\", \">0\" })\n+    public Object[] testLongToInt(long[] longs, int[] res) {\n+        for (int i = 0; i < longs.length; i++) {\n+            res[i] = (int) longs[i];\n+        }\n+\n+        return new Object[] { longs, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.STORE_VECTOR, \">0\" })\n+    public Object[] testShortToChar(short[] shorts, char[] res) {\n+        for (int i = 0; i < shorts.length; i++) {\n+            res[i] = (char) shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    \/\/ Widening\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2I, IRNode.VECTOR_SIZE + \"min(max_short, max_int)\", \">0\" })\n+    public Object[] testShortToInt(short[] shorts, int[] res) {\n+        for (int i = 0; i < shorts.length; i++) {\n+            res[i] = shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2I, IRNode.VECTOR_SIZE + \"min(max_byte, max_int)\", \">0\" })\n+    public Object[] testByteToInt(byte[] bytes, int[] res) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_byte, max_short)\", \">0\" })\n+    public Object[] testByteToShort(byte[] bytes, short[] res) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_byte, max_char)\", \">0\" })\n+    public Object[] testByteToChar(byte[] bytes, char[] res) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            res[i] = (char) bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx2\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2L, IRNode.VECTOR_SIZE + \"min(max_byte, max_long)\", \">0\" })\n+    public Object[] testByteToLong(byte[] bytes, long[] res) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2L, IRNode.VECTOR_SIZE + \"min(max_short, max_long)\", \">0\" })\n+    public Object[] testShortToLong(short[] shorts, long[] res) {\n+        for (int i = 0; i < shorts.length; i++) {\n+            res[i] = shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"avx\", \"true\", \"asimd\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \">0\" })\n+    public Object[] testIntToLong(int[] ints, long[] res) {\n+        for (int i = 0; i < ints.length; i++) {\n+            res[i] = ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":235,"deletions":6,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8340093\n+ * @bug 8340093 8342095\n@@ -34,1 +34,1 @@\n- * @bug 8340093\n+ * @bug 8340093 8342095\n@@ -42,1 +42,1 @@\n- * @bug 8340093\n+ * @bug 8340093 8342095\n@@ -458,1 +458,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.AND_REDUCTION_V, \"> 0\",\n+                  IRNode.AND_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -469,1 +475,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.OR_REDUCTION_V, \"> 0\",\n+                  IRNode.OR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -480,1 +492,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.XOR_REDUCTION_V, \"> 0\",\n+                  IRNode.XOR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -513,1 +531,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.MIN_REDUCTION_V, \"> 0\",\n+                  IRNode.MIN_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -524,1 +548,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.MAX_REDUCTION_V, \"> 0\",\n+                  IRNode.MAX_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -536,1 +566,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.AND_REDUCTION_V, \"> 0\",\n+                  IRNode.AND_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -547,1 +583,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.OR_REDUCTION_V, \"> 0\",\n+                  IRNode.OR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -558,1 +600,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.XOR_REDUCTION_V, \"> 0\",\n+                  IRNode.XOR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -591,1 +639,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.MIN_REDUCTION_V, \"> 0\",\n+                  IRNode.MIN_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -602,1 +656,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.MAX_REDUCTION_V, \"> 0\",\n+                  IRNode.MAX_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -614,1 +674,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.AND_REDUCTION_V, \"> 0\",\n+                  IRNode.AND_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -625,1 +691,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.OR_REDUCTION_V, \"> 0\",\n+                  IRNode.OR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -636,1 +708,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.XOR_REDUCTION_V, \"> 0\",\n+                  IRNode.XOR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -669,1 +747,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.MIN_REDUCTION_V, \"> 0\",\n+                  IRNode.MIN_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -680,1 +764,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_B) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                  IRNode.MAX_REDUCTION_V, \"> 0\",\n+                  IRNode.MAX_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_B,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -926,1 +1016,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.AND_REDUCTION_V, \"> 0\",\n+                  IRNode.AND_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -937,1 +1033,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.OR_REDUCTION_V, \"> 0\",\n+                  IRNode.OR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -948,1 +1050,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.XOR_REDUCTION_V, \"> 0\",\n+                  IRNode.XOR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -981,1 +1089,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.MIN_REDUCTION_V, \"> 0\",\n+                  IRNode.MIN_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -992,1 +1106,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.MAX_REDUCTION_V, \"> 0\",\n+                  IRNode.MAX_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -1004,1 +1124,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.AND_REDUCTION_V, \"> 0\",\n+                  IRNode.AND_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -1015,1 +1141,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.OR_REDUCTION_V, \"> 0\",\n+                  IRNode.OR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -1026,1 +1158,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.XOR_REDUCTION_V, \"> 0\",\n+                  IRNode.XOR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -1059,1 +1197,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.MIN_REDUCTION_V, \"> 0\",\n+                  IRNode.MIN_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -1070,1 +1214,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.MAX_REDUCTION_V, \"> 0\",\n+                  IRNode.MAX_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -1082,1 +1232,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.AND_REDUCTION_V, \"> 0\",\n+                  IRNode.AND_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -1093,1 +1249,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.OR_REDUCTION_V, \"> 0\",\n+                  IRNode.OR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -1104,1 +1266,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.XOR_REDUCTION_V, \"> 0\",\n+                  IRNode.XOR_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -1137,1 +1305,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.MIN_REDUCTION_V, \"> 0\",\n+                  IRNode.MIN_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n@@ -1148,1 +1322,7 @@\n-    @IR(failOn = IRNode.LOAD_VECTOR_S) \/\/ does not vectorize for now, might in the future.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                  IRNode.MAX_REDUCTION_V, \"> 0\",\n+                  IRNode.MAX_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"})\n+    @IR(failOn = IRNode.LOAD_VECTOR_S,\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestReductions.java","additions":214,"deletions":34,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +28,1 @@\n- * @bug 8286847 8353600\n+ * @bug 8286847 8353600 8342095\n@@ -119,3 +120,0 @@\n-    \/\/ NOTE: currently, there is no platform supporting RotateLeftV\/RotateRightV intrinsic.\n-    \/\/ If there is some implementation, it could probably in a wrong way which is different\n-    \/\/ from what java language spec expects.\n@@ -123,1 +121,3 @@\n-    @IR(failOn = { IRNode.ROTATE_LEFT_V })\n+    @IR(counts = { IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                   IRNode.ROTATE_LEFT_V, \"> 0\" },\n+        applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -133,1 +133,3 @@\n-    @IR(failOn = { IRNode.ROTATE_RIGHT_V })\n+    @IR(counts = { IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\",\n+                   IRNode.ROTATE_RIGHT_V, \"> 0\" },\n+        applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -141,1 +143,3 @@\n-    @IR(failOn = { IRNode.ROTATE_LEFT_V })\n+    @IR(counts = { IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                   IRNode.ROTATE_LEFT_V, \"> 0\" },\n+        applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -151,1 +155,3 @@\n-    @IR(failOn = { IRNode.ROTATE_RIGHT_V })\n+    @IR(counts = { IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\",\n+                   IRNode.ROTATE_RIGHT_V, \"> 0\" },\n+        applyIfCPUFeature = {\"avx512f\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRotateByteAndShortVector.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.g\n@@ -32,1 +32,1 @@\n- * @bug 8350177 8362171 8369881\n+ * @bug 8350177 8362171 8369881 8342095\n@@ -76,1 +76,2 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\" },\n+        applyIfCPUFeatureOr = { \"avx2\", \"true\", \"asimd\", \"true\" })\n@@ -101,1 +102,2 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\" },\n+        applyIfCPUFeatureOr = { \"avx2\", \"true\", \"asimd\", \"true\" })\n@@ -126,1 +128,2 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\" },\n+        applyIfCPUFeatureOr = { \"avx2\", \"true\", \"asimd\", \"true\" })\n@@ -151,1 +154,2 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \"> 0\" },\n+        applyIfCPUFeatureOr = { \"avx2\", \"true\", \"asimd\", \"true\" })\n@@ -280,1 +284,2 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\" },\n+        applyIfCPUFeatureOr = { \"avx2\", \"true\", \"asimd\", \"true\" })\n@@ -305,1 +310,2 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\" },\n+        applyIfCPUFeatureOr = { \"avx2\", \"true\", \"asimd\", \"true\" })\n@@ -330,1 +336,2 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\" },\n+        applyIfCPUFeatureOr = { \"avx2\", \"true\", \"asimd\", \"true\" })\n@@ -406,1 +413,2 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \"> 0\" },\n+        applyIfCPUFeatureOr = { \"avx2\", \"true\", \"asimd\", \"true\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSubwordTruncation.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -250,3 +250,2 @@\n-    \/\/ Note that right shift operations on subword expressions cannot be\n-    \/\/ vectorized since precise type info about signedness is missing.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(applyIfCPUFeature = {\"avx\", \"true\"},\n+            counts = {IRNode.RSHIFT_VI, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @bug 8183390 8340010 8342095\n@@ -111,4 +112,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2I, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -125,1 +125,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n@@ -137,4 +137,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2I, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n@@ -149,0 +148,12 @@\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    public short[] signExtensionFromByteToShort() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = bytes[i];\n+        }\n+        return res;\n+    }\n+\n@@ -151,4 +162,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -164,4 +174,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_char)\", \">0\" })\n@@ -177,5 +186,4 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n-    public byte[] NarrowToByte() {\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n+    public byte[] narrowToByte() {\n@@ -189,0 +197,12 @@\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2B, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    public byte[] narrowShortToByte() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) shorts[i];\n+        }\n+        return res;\n+    }\n+\n@@ -271,1 +291,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n@@ -284,1 +304,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":45,"deletions":25,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +27,1 @@\n+ * @bug 8183390 8342095\n@@ -213,0 +215,2 @@\n+    \/\/ Min\/Max vectorization requires a cast from subword to int and back to subword, to avoid losing the higher order bits.\n+\n@@ -214,3 +218,1 @@\n-    \/\/ Note that min operations on subword types cannot be vectorized\n-    \/\/ because higher bits will be lost.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -226,3 +228,1 @@\n-    \/\/ Note that max operations on subword types cannot be vectorized\n-    \/\/ because higher bits will be lost.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class VectorSubword {\n+    @Param({\"1024\"})\n+    public int SIZE;\n+\n+    private byte[] bytes;\n+    private short[] shorts;\n+    private char[] chars;\n+    private int[] ints;\n+    private long[] longs;\n+\n+    @Setup\n+    public void init() {\n+        bytes = new byte[SIZE];\n+        shorts = new short[SIZE];\n+        chars = new char[SIZE];\n+        ints = new int[SIZE];\n+        longs = new long[SIZE];\n+    }\n+\n+    \/\/ Narrowing\n+\n+    @Benchmark\n+    public void shortToByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i] = (byte) shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortToChar() {\n+        for (int i = 0; i < SIZE; i++) {\n+            chars[i] = (char) shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void charToByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i] = (byte) chars[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void charToShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shorts[i] = (short) chars[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intToByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i] = (byte) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intToShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shorts[i] = (short) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intToChar() {\n+        for (int i = 0; i < SIZE; i++) {\n+            chars[i] = (char) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longToByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i] = (byte) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longToShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shorts[i] = (short) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longToChar() {\n+        for (int i = 0; i < SIZE; i++) {\n+            chars[i] = (char) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longToInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = (int) longs[i];\n+        }\n+    }\n+\n+    \/\/ Widening\n+\n+    @Benchmark\n+    public void byteToShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shorts[i] = bytes[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteToChar() {\n+        for (int i = 0; i < SIZE; i++) {\n+            chars[i] = (char) bytes[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteToInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = bytes[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteToLong() {\n+        for (int i = 0; i < SIZE; i++) {\n+            longs[i] = bytes[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortToInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortToLong() {\n+        for (int i = 0; i < SIZE; i++) {\n+            longs[i] = shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void charToInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = chars[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void charToLong() {\n+        for (int i = 0; i < SIZE; i++) {\n+            longs[i] = chars[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intToLong() {\n+        for (int i = 0; i < SIZE; i++) {\n+            longs[i] = ints[i];\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorSubword.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"}]}