{"files":[{"patch":"@@ -2312,1 +2312,1 @@\n-  if (!is_velt_basic_type_compatible_use_def(use, def)) {\n+  if (!is_velt_basic_type_compatible_use_def(use, def, d_pk->size())) {\n@@ -2378,1 +2378,1 @@\n-bool SuperWord::is_velt_basic_type_compatible_use_def(Node* use, Node* def) const {\n+bool SuperWord::is_velt_basic_type_compatible_use_def(Node* use, Node* def, const uint pack_size) const {\n@@ -2404,2 +2404,18 @@\n-  \/\/ Default case: input size of use equals output size of def.\n-  return type2aelembytes(use_bt) == type2aelembytes(def_bt);\n+  \/\/ Input size of use equals output size of def\n+  if (type2aelembytes(use_bt) == type2aelembytes(def_bt)) {\n+    return true;\n+  }\n+\n+  \/\/ Subword cast: Element sizes differ, but the platform supports a cast to change the def shape to the use shape.\n+  if (is_supported_subword_cast(def_bt, use_bt, pack_size)) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool SuperWord::is_supported_subword_cast(BasicType def_bt, BasicType use_bt, const uint pack_size) {\n+  assert(def_bt != use_bt, \"use and def types must be different\");\n+\n+  \/\/ Opcode is only required to disambiguate half float, so we pass -1 as it can't be encountered here.\n+  return (is_subword_type(def_bt) || is_subword_type(use_bt)) && VectorCastNode::implemented(-1, pack_size, def_bt, use_bt);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -656,1 +656,1 @@\n-  bool is_velt_basic_type_compatible_use_def(Node* use, Node* def) const;\n+  bool is_velt_basic_type_compatible_use_def(Node* use, Node* def, const uint pack_size) const;\n@@ -659,0 +659,3 @@\n+\n+public:\n+  static bool is_supported_subword_cast(BasicType def_bt, BasicType use_bt, const uint pack_size);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -192,0 +192,13 @@\n+    Node* in_p0 = pack_in->at(0);\n+    BasicType def_bt = _vloop_analyzer.types().velt_basic_type(in_p0);\n+    BasicType use_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+\n+    \/\/ If the use and def types are different, emit a cast node\n+    if (use_bt != def_bt && !p0->is_Convert() && SuperWord::is_supported_subword_cast(def_bt, use_bt, pack->size())) {\n+      VTransformNode* in = get_vtnode(pack_in->at(0));\n+      VTransformNode* cast = new (_vtransform.arena()) VTransformCastVectorNode(_vtransform, pack->size(), def_bt, use_bt);\n+      cast->set_req(1, in);\n+\n+      return cast;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -698,0 +698,9 @@\n+VTransformApplyResult VTransformCastVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                       const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* value = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  VectorNode* vn = VectorCastNode::make(VectorCastNode::opcode(-1, _from_bt), value, _to_bt, _vlen);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, value);\n+\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->vect_type()->length_in_bytes());\n+}\n+\n@@ -793,0 +802,4 @@\n+void VTransformCastVectorNode::print_spec() const {\n+  tty->print(\"vlen=%d from=%s to=%s\", _vlen, type2name(_from_bt), type2name(_to_bt));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -533,0 +533,16 @@\n+class VTransformCastVectorNode : public VTransformNode {\n+private:\n+  uint _vlen;\n+  BasicType _from_bt;\n+  BasicType _to_bt;\n+\n+public:\n+  \/\/ req = 2 -> [ctrl, input]\n+  VTransformCastVectorNode(VTransform& vtransform, int vlen, BasicType from_bt, BasicType to_bt) : VTransformNode(vtransform, 2),\n+    _vlen(vlen), _from_bt(from_bt), _to_bt(to_bt) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"CastVector\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -60,3 +60,3 @@\n-    \/\/ Ensure vector max\/min instructions are not generated for integer subword types\n-    \/\/ as Java APIs for Math.min\/max do not support integer subword types and superword\n-    \/\/ should not generate vectorized Min\/Max nodes for them.\n+    \/\/ Ensure that casts to\/from subword types are emitted, as java APIs for Math.min\/max do not support integer subword\n+    \/\/ types and superword should generate int versions and then cast between them.\n+\n@@ -64,1 +64,1 @@\n-    @IR(failOn = {IRNode.MIN_VI, IRNode.MIN_VF, IRNode.MIN_VD})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -80,1 +80,1 @@\n-    @IR(failOn = {IRNode.MAX_VI, IRNode.MAX_VF, IRNode.MAX_VD})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -95,1 +95,1 @@\n-    @IR(failOn = {IRNode.MIN_VI, IRNode.MIN_VF, IRNode.MIN_VD})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -111,1 +111,1 @@\n-    @IR(failOn = {IRNode.MAX_VI, IRNode.MAX_VF, IRNode.MAX_VD})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE_ANY, \">0\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMinMaxSubword.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,16 @@\n+        tests.put(\"testByteToInt\",   () -> { return testByteToInt(aB.clone(), bI.clone()); });\n+        tests.put(\"testByteToShort\", () -> { return testByteToShort(aB.clone(), bS.clone()); });\n+        tests.put(\"testByteToChar\",  () -> { return testByteToChar(aB.clone(), bC.clone()); });\n+        tests.put(\"testByteToLong\",  () -> { return testByteToLong(aB.clone(), bL.clone()); });\n+        tests.put(\"testShortToByte\", () -> { return testShortToByte(aS.clone(), bB.clone()); });\n+        tests.put(\"testShortToChar\", () -> { return testShortToChar(aS.clone(), bC.clone()); });\n+        tests.put(\"testShortToInt\",  () -> { return testShortToInt(aS.clone(), bI.clone()); });\n+        tests.put(\"testShortToLong\", () -> { return testShortToLong(aS.clone(), bL.clone()); });\n+        tests.put(\"testIntToShort\",  () -> { return testIntToShort(aI.clone(), bS.clone()); });\n+        tests.put(\"testIntToChar\",   () -> { return testIntToChar(aI.clone(), bC.clone()); });\n+        tests.put(\"testIntToByte\",   () -> { return testIntToByte(aI.clone(), bB.clone()); });\n+        tests.put(\"testIntToLong\",   () -> { return testIntToLong(aI.clone(), bL.clone()); });\n+        tests.put(\"testLongToByte\",  () -> { return testLongToByte(aL.clone(), bB.clone()); });\n+        tests.put(\"testLongToShort\", () -> { return testLongToShort(aL.clone(), bS.clone()); });\n+        tests.put(\"testLongToChar\",  () -> { return testLongToChar(aL.clone(), bC.clone()); });\n+        tests.put(\"testLongToInt\",   () -> { return testLongToInt(aL.clone(), bI.clone()); });\n@@ -130,1 +146,17 @@\n-                 \"test11\"})\n+                 \"test11\",\n+                 \"testByteToInt\",\n+                 \"testByteToShort\",\n+                 \"testByteToChar\",\n+                 \"testByteToLong\",\n+                 \"testShortToByte\",\n+                 \"testShortToChar\",\n+                 \"testShortToInt\",\n+                 \"testShortToLong\",\n+                 \"testIntToShort\",\n+                 \"testIntToChar\",\n+                 \"testIntToByte\",\n+                 \"testIntToLong\",\n+                 \"testLongToByte\",\n+                 \"testLongToShort\",\n+                 \"testLongToChar\",\n+                 \"testLongToInt\"})\n@@ -330,1 +362,1 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\"},\n@@ -332,1 +364,2 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -335,1 +368,0 @@\n-    \/\/ Vector code would need a conversion. We may add this in the future.\n@@ -476,0 +508,197 @@\n+\n+    \/\/ Narrowing\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n+    public Object[] testIntToShort(int[] ints, short[] res) {\n+        for (int i = 0; i < ints.length; i++) {\n+            res[i] = (short) ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_char)\", \">0\" })\n+    public Object[] testIntToChar(int[] ints, char[] res) {\n+        for (int i = 0; i < ints.length; i++) {\n+            res[i] = (char) ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n+    public Object[] testIntToByte(int[] ints, byte[] res) {\n+        for (int i = 0; i < ints.length; i++) {\n+            res[i] = (byte) ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2B, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    public Object[] testShortToByte(short[] shorts, byte[] res) {\n+        for (int i = 0; i < shorts.length; i++) {\n+            res[i] = (byte) shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx2\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_L2B, IRNode.VECTOR_SIZE + \"min(max_long, max_byte)\", \">0\" })\n+    public Object[] testLongToByte(long[] longs, byte[] res) {\n+        for (int i = 0; i < longs.length; i++) {\n+            res[i] = (byte) longs[i];\n+        }\n+\n+        return new Object[] { longs, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_L2S, IRNode.VECTOR_SIZE + \"min(max_long, max_short)\", \">0\" })\n+    public Object[] testLongToShort(long[] longs, short[] res) {\n+        for (int i = 0; i < longs.length; i++) {\n+            res[i] = (short) longs[i];\n+        }\n+\n+        return new Object[] { longs, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_L2S, IRNode.VECTOR_SIZE + \"min(max_long, max_char)\", \">0\" })\n+    public Object[] testLongToChar(long[] longs, char[] res) {\n+        for (int i = 0; i < longs.length; i++) {\n+            res[i] = (char) longs[i];\n+        }\n+\n+        return new Object[] { longs, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_L2I, IRNode.VECTOR_SIZE + \"min(max_long, max_int)\", \">0\" })\n+    public Object[] testLongToInt(long[] longs, int[] res) {\n+        for (int i = 0; i < longs.length; i++) {\n+            res[i] = (int) longs[i];\n+        }\n+\n+        return new Object[] { longs, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.STORE_VECTOR, \">0\" })\n+    public Object[] testShortToChar(short[] shorts, char[] res) {\n+        for (int i = 0; i < shorts.length; i++) {\n+            res[i] = (char) shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    \/\/ Widening\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2I, IRNode.VECTOR_SIZE + \"min(max_short, max_int)\", \">0\" })\n+    public Object[] testShortToInt(short[] shorts, int[] res) {\n+        for (int i = 0; i < shorts.length; i++) {\n+            res[i] = shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2I, IRNode.VECTOR_SIZE + \"min(max_byte, max_int)\", \">0\" })\n+    public Object[] testByteToInt(byte[] bytes, int[] res) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_byte, max_short)\", \">0\" })\n+    public Object[] testByteToShort(byte[] bytes, short[] res) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_byte, max_char)\", \">0\" })\n+    public Object[] testByteToChar(byte[] bytes, char[] res) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            res[i] = (char) bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx2\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2L, IRNode.VECTOR_SIZE + \"min(max_byte, max_long)\", \">0\" })\n+    public Object[] testByteToLong(byte[] bytes, long[] res) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2L, IRNode.VECTOR_SIZE + \"min(max_short, max_long)\", \">0\" })\n+    public Object[] testShortToLong(short[] shorts, long[] res) {\n+        for (int i = 0; i < shorts.length; i++) {\n+            res[i] = shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \">0\" })\n+    public Object[] testIntToLong(int[] ints, long[] res) {\n+        for (int i = 0; i < ints.length; i++) {\n+            res[i] = ints[i];\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":234,"deletions":5,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(applyIfCPUFeature = { \"avx2\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -101,1 +101,1 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(applyIfCPUFeature = { \"avx2\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -126,1 +126,1 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(applyIfCPUFeature = { \"avx2\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -151,1 +151,1 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(applyIfCPUFeature = { \"avx2\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -280,1 +280,1 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(applyIfCPUFeature = { \"avx2\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -305,1 +305,1 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(applyIfCPUFeature = { \"avx2\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -330,1 +330,1 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(applyIfCPUFeature = { \"avx2\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -355,1 +355,1 @@\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @IR(applyIfCPUFeature = { \"avx2\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE_ANY, \">0\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSubwordTruncation.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -250,3 +250,2 @@\n-    \/\/ Note that right shift operations on subword expressions cannot be\n-    \/\/ vectorized since precise type info about signedness is missing.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(applyIfCPUFeature = {\"avx\", \"true\"},\n+            counts = {IRNode.RSHIFT_VI, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @bug 8183390 8340010 8342095\n@@ -111,4 +112,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2I, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -125,1 +125,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n@@ -137,4 +137,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2I, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n@@ -149,0 +148,12 @@\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    public short[] signExtensionFromByteToShort() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = bytes[i];\n+        }\n+        return res;\n+    }\n+\n@@ -151,4 +162,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -164,4 +174,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_char)\", \">0\" })\n@@ -177,5 +186,4 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n-    public byte[] NarrowToByte() {\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n+    public byte[] narrowToByte() {\n@@ -189,0 +197,12 @@\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2B, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    public byte[] narrowShortToByte() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) shorts[i];\n+        }\n+        return res;\n+    }\n+\n@@ -271,1 +291,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n@@ -284,1 +304,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":44,"deletions":24,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -213,0 +213,2 @@\n+    \/\/ Min\/Max vectorization requires a cast from subword to int and back to subword, to avoid losing the higher order bits.\n+\n@@ -214,3 +216,1 @@\n-    \/\/ Note that min operations on subword types cannot be vectorized\n-    \/\/ because higher bits will be lost.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE_ANY, \">0\" })\n@@ -226,3 +226,1 @@\n-    \/\/ Note that max operations on subword types cannot be vectorized\n-    \/\/ because higher bits will be lost.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" }, counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE_ANY, \">0\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class VectorSubword {\n+    @Param({\"1024\"})\n+    public int SIZE;\n+\n+    private byte[] bytes;\n+    private short[] shorts;\n+    private char[] chars;\n+    private int[] ints;\n+    private long[] longs;\n+\n+    @Setup\n+    public void init() {\n+        bytes = new byte[SIZE];\n+        shorts = new short[SIZE];\n+        chars = new char[SIZE];\n+        ints = new int[SIZE];\n+        longs = new long[SIZE];\n+    }\n+\n+    \/\/ Narrowing\n+\n+    @Benchmark\n+    public void shortToByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i] = (byte) shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortToChar() {\n+        for (int i = 0; i < SIZE; i++) {\n+            chars[i] = (char) shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void charToByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i] = (byte) chars[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void charToShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shorts[i] = (short) chars[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intToByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i] = (byte) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intToShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shorts[i] = (short) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intToChar() {\n+        for (int i = 0; i < SIZE; i++) {\n+            chars[i] = (char) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longToByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i] = (byte) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longToShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shorts[i] = (short) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longToChar() {\n+        for (int i = 0; i < SIZE; i++) {\n+            chars[i] = (char) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longToInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = (int) longs[i];\n+        }\n+    }\n+\n+    \/\/ Widening\n+\n+    @Benchmark\n+    public void byteToShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shorts[i] = bytes[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteToChar() {\n+        for (int i = 0; i < SIZE; i++) {\n+            chars[i] = (char) bytes[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteToInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = bytes[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteToLong() {\n+        for (int i = 0; i < SIZE; i++) {\n+            longs[i] = bytes[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortToInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortToLong() {\n+        for (int i = 0; i < SIZE; i++) {\n+            longs[i] = shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void charToInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = chars[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void charToLong() {\n+        for (int i = 0; i < SIZE; i++) {\n+            longs[i] = chars[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intToLong() {\n+        for (int i = 0; i < SIZE; i++) {\n+            longs[i] = ints[i];\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorSubword.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"}]}