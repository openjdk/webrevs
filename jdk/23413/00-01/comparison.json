{"files":[{"patch":"@@ -270,0 +270,5 @@\n+    \/\/ Cannot cast to own type\n+    if (to_bt == from_bt) {\n+      return false;\n+    }\n+\n@@ -271,5 +276,4 @@\n-      case T_INT: {\n-        return to_bt == T_SHORT || to_bt == T_BYTE;\n-      }\n-      case T_SHORT: {\n-        return to_bt == T_BYTE;\n+      case T_INT:\n+      case T_SHORT:\n+      case T_BYTE: {\n+        return to_bt == T_INT || to_bt == T_SHORT || to_bt == T_BYTE;\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-      VTransformNode* cast = new (_vtransform.arena()) VTransformCastNode(_vtransform, pack->size(), def_bt, use_bt);\n+      VTransformNode* cast = new (_vtransform.arena()) VTransformCastVectorNode(_vtransform, pack->size(), def_bt, use_bt);\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -604,1 +604,1 @@\n-VTransformApplyResult VTransformCastNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+VTransformApplyResult VTransformCastVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n@@ -708,1 +708,1 @@\n-void VTransformCastNode::print_spec() const {\n+void VTransformCastVectorNode::print_spec() const {\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -525,1 +525,1 @@\n-class VTransformCastNode : public VTransformNode {\n+class VTransformCastVectorNode : public VTransformNode {\n@@ -533,1 +533,1 @@\n-  VTransformCastNode(VTransform& vtransform, int vlen, BasicType from_bt, BasicType to_bt) : VTransformNode(vtransform, 2),\n+  VTransformCastVectorNode(VTransform& vtransform, int vlen, BasicType from_bt, BasicType to_bt) : VTransformNode(vtransform, 2),\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+\n+import compiler.lib.generators.*;\n@@ -40,1 +42,2 @@\n-    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final Generator<Integer> G = Generators.G.ints();\n+\n@@ -52,1 +55,1 @@\n-            res[i] = RANDOM.nextInt();\n+            res[i] = G.next();\n@@ -63,1 +66,12 @@\n-            res[i] = (short) RANDOM.nextInt();\n+            res[i] = G.next().shortValue();\n+        }\n+\n+        return new Object[] { res };\n+    }\n+\n+    @Setup\n+    static Object[] setupByteArray() {\n+        byte[] res = new byte[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = G.next().byteValue();\n@@ -69,0 +83,2 @@\n+    \/\/ Narrowing\n+\n@@ -72,1 +88,1 @@\n-        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE_ANY, \">0\" })\n+        counts = { IRNode.VECTOR_CAST_I2S, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -101,1 +117,1 @@\n-        counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE_ANY, \">0\" })\n+        counts = { IRNode.VECTOR_CAST_I2B, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n@@ -130,1 +146,1 @@\n-        counts = { IRNode.VECTOR_CAST_S2B, IRNode.VECTOR_SIZE_ANY, \">0\" })\n+        counts = { IRNode.VECTOR_CAST_S2B, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n@@ -155,0 +171,89 @@\n+\n+    \/\/ Widening\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2I, IRNode.VECTOR_SIZE + \"min(max_short, max_int)\", \">0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortToInt(short[] shorts) {\n+        int[] res = new int[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = shorts[i];\n+        }\n+\n+        return new Object[] { shorts, res };\n+    }\n+\n+    @Check(test = \"testShortToInt\")\n+    public void checkTestShortToInt(Object[] vals) {\n+        short[] shorts = (short[]) vals[0];\n+        int[] res = (int[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            int value = shorts[i];\n+\n+            if (res[i] != value) {\n+                throw new IllegalStateException(\"Short to int test failed: Expected \" + value + \" but got \" + res[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2I, IRNode.VECTOR_SIZE + \"min(max_byte, max_int)\", \">0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteToInt(byte[] bytes) {\n+        int[] res = new int[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Check(test = \"testByteToInt\")\n+    public void checkTestByteToInt(Object[] vals) {\n+        byte[] bytes = (byte[]) vals[0];\n+        int[] res = (int[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            int value = bytes[i];\n+\n+            if (res[i] != value) {\n+                throw new IllegalStateException(\"Byte to int test failed: Expected \" + value + \" but got \" + res[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_byte, max_short)\", \">0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteToShort(byte[] bytes) {\n+        short[] res = new short[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = bytes[i];\n+        }\n+\n+        return new Object[] { bytes, res };\n+    }\n+\n+    @Check(test = \"testByteToShort\")\n+    public void checkTestByteToShort(Object[] vals) {\n+        byte[] bytes = (byte[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short value = bytes[i];\n+\n+            if (res[i] != value) {\n+                throw new IllegalStateException(\"Byte to short test failed: Expected \" + value + \" but got \" + res[i]);\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSubwordVectorization.java","additions":111,"deletions":6,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -112,4 +112,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_S2I, IRNode.VECTOR_SIZE + \"min(max_int, max_short)\", \">0\" })\n@@ -126,1 +125,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n@@ -138,4 +137,3 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n-    \/\/ Assert the vectorization failure so that we are reminded to update\n-    \/\/ the test when this limitation is addressed in the future.\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2I, IRNode.VECTOR_SIZE + \"min(max_int, max_byte)\", \">0\" })\n@@ -150,0 +148,12 @@\n+    @Test\n+    @IR(applyIfCPUFeature = { \"avx\", \"true\" },\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        counts = { IRNode.VECTOR_CAST_B2S, IRNode.VECTOR_SIZE + \"min(max_short, max_byte)\", \">0\" })\n+    public short[] signExtensionFromByteToShort() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = bytes[i];\n+        }\n+        return res;\n+    }\n+\n@@ -278,1 +288,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n@@ -291,1 +301,1 @@\n-    \/\/ Subword vector casts do not work currently, see JDK-8342095.\n+    \/\/ Subword vector casts with char do not work currently, see JDK-8349562.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"}]}