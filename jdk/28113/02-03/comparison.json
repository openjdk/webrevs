{"files":[{"patch":"@@ -67,1 +67,1 @@\n-      vtn = new (_vtransform.arena()) VTransformLoopPhiNode(_vtransform, n->as_Phi());\n+      vtn = new (_vtransform.arena()) VTransformPhiScalarNode(_vtransform, n->as_Phi());\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"vtransform.hpp\"\n@@ -65,1 +66,1 @@\n-          !(vtn->isa_LoopPhi() != nullptr ||\n+          !(vtn->isa_PhiScalar() != nullptr ||\n@@ -126,2 +127,7 @@\n-        \/\/ Skip LoopPhi backedge.\n-        if ((use->isa_LoopPhi() != nullptr || use->isa_CountedLoop() != nullptr) && use->in_req(2) == vtn) { continue; }\n+        \/\/ Skip backedges.\n+        if ((use->isa_PhiScalar() != nullptr ||\n+             use->isa_PhiVector() != nullptr ||\n+             use->isa_CountedLoop() != nullptr\n+            ) && use->in_req(2) == vtn) {\n+          continue;\n+        }\n@@ -851,1 +857,1 @@\n-VTransformApplyResult VTransformLoopPhiNode::apply(VTransformApplyState& apply_state) const {\n+VTransformApplyResult VTransformPhiScalarNode::apply(VTransformApplyState& apply_state) const {\n@@ -865,1 +871,1 @@\n-void VTransformLoopPhiNode::apply_backedge(VTransformApplyState& apply_state) const {\n+void VTransformPhiScalarNode::apply_backedge(VTransformApplyState& apply_state) const {\n@@ -1081,1 +1087,1 @@\n-  VTransformLoopPhiNode* phi = in_req(1)->isa_LoopPhi();\n+  VTransformPhiScalarNode* phi = in_req(1)->isa_PhiScalar();\n@@ -1146,1 +1152,2 @@\n-        if (use->isa_LoopPhi() == nullptr &&\n+        \/\/ TODO: this is not right\n+        if (use->isa_PhiScalar() == nullptr &&\n@@ -1201,4 +1208,15 @@\n-  \/\/ Turn the scalar phi into a vector phi.\n-  VTransformLoopPhiNode* phi = in_req(1)->isa_LoopPhi();\n-  VTransformNode* init = phi->in_req(1);\n-  phi->set_req(1, vtn_identity_vector);\n+  \/\/ Look at old scalar phsai\n+  VTransformPhiScalarNode* phi_scalar = in_req(1)->isa_PhiScalar();\n+  PhiNode* old_phi = phi_scalar->node();\n+  VTransformNode* init = phi_scalar->in_req(1);\n+\n+  TRACE_OPTIMIZE(\n+    tty->print(\"  phi_scalar \");\n+    phi_scalar->print();\n+  )\n+\n+  \/\/ Create new vector phi\n+  const VTransformVectorNodeProperties properties = VTransformVectorNodeProperties::make_for_phi_vector(old_phi, vlen, bt);\n+  VTransformPhiVectorNode* phi_vector = new (vtransform.arena()) VTransformPhiVectorNode(vtransform, 3, properties);\n+  phi_vector->init_req(0, phi_scalar->in_req(0));\n+  phi_vector->init_req(1, vtn_identity_vector);\n@@ -1208,1 +1226,1 @@\n-  VTransformReductionVectorNode* last_red    = phi->in_req(2)->isa_ReductionVector();\n+  VTransformReductionVectorNode* last_red    = phi_scalar->in_req(2)->isa_ReductionVector();\n@@ -1210,1 +1228,1 @@\n-  VTransformNode* current_vector_accumulator = phi;\n+  VTransformNode* current_vector_accumulator = phi_vector;\n@@ -1228,1 +1246,1 @@\n-  phi->set_req(2, current_vector_accumulator);\n+  phi_vector->set_req(2, current_vector_accumulator);\n@@ -1235,2 +1253,2 @@\n-    tty->print(\"  phi        \");\n-    phi->print();\n+    tty->print(\"  phi_scalar \");\n+    phi_scalar->print();\n@@ -1252,0 +1270,33 @@\n+VTransformApplyResult VTransformPhiVectorNode::apply(VTransformApplyState& apply_state) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  Node* in0 = apply_state.transformed_node(in_req(0));\n+  Node* in1 = apply_state.transformed_node(in_req(1));\n+\n+  \/\/ We create a new phi node, because the type is different to the scalar phi.\n+  PhiNode* old_phi = approximate_origin()->as_Phi();\n+  PhiNode* new_phi = old_phi->clone()->as_Phi();\n+\n+  phase->igvn().replace_input_of(new_phi, 0, in0);\n+  phase->igvn().replace_input_of(new_phi, 1, in1);\n+  \/\/ Note: the backedge is hooked up later.\n+\n+  \/\/ Give the new phi node the correct vector type.\n+  const TypeVect* vt = TypeVect::make(element_basic_type(), vector_length());\n+  new_phi->as_Type()->set_type(vt);\n+  phase->igvn().set_type(new_phi, vt);\n+\n+  return VTransformApplyResult::make_vector(new_phi, vt);\n+}\n+\n+\/\/ Cleanup backedges. In the schedule, the backedges come after their phis. Hence,\n+\/\/ we only have the transformed backedges after the phis are already transformed.\n+\/\/ We hook the backedges into the phis now, during cleanup.\n+void VTransformPhiVectorNode::apply_backedge(VTransformApplyState& apply_state) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n+\n+  \/\/\/\/ Data phi\/backedge\n+  \/\/Node* in2 = apply_state.transformed_node(in_req(2));\n+  \/\/phase->igvn().replace_input_of(_node, 2, in2);\n+}\n+\n+\n@@ -1377,1 +1428,1 @@\n-void VTransformLoopPhiNode::print_spec() const {\n+void VTransformPhiScalarNode::print_spec() const {\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":68,"deletions":17,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-class VTransformLoopPhiNode;\n+class VTransformPhiScalarNode;\n@@ -87,0 +87,1 @@\n+class VTransformPhiVectorNode;\n@@ -534,1 +535,1 @@\n-  virtual VTransformLoopPhiNode* isa_LoopPhi() { return nullptr; }\n+  virtual VTransformPhiScalarNode* isa_PhiScalar() { return nullptr; }\n@@ -542,0 +543,1 @@\n+  virtual VTransformPhiVectorNode* isa_PhiVector() { return nullptr; }\n@@ -604,1 +606,1 @@\n-class VTransformLoopPhiNode : public VTransformNode {\n+class VTransformPhiScalarNode : public VTransformNode {\n@@ -608,1 +610,1 @@\n-  VTransformLoopPhiNode(VTransform& vtransform, PhiNode* n) :\n+  VTransformPhiScalarNode(VTransform& vtransform, PhiNode* n) :\n@@ -614,1 +616,3 @@\n-  virtual VTransformLoopPhiNode* isa_LoopPhi() override { return this; }\n+  PhiNode* node() const { return _node; }\n+\n+  virtual VTransformPhiScalarNode* isa_PhiScalar() override { return this; }\n@@ -617,1 +621,1 @@\n-  NOT_PRODUCT(virtual const char* name() const override { return \"LoopPhi\"; };)\n+  NOT_PRODUCT(virtual const char* name() const override { return \"PhiScalar\"; };)\n@@ -738,0 +742,4 @@\n+  static VTransformVectorNodeProperties make_for_phi_vector(PhiNode* phi, int vlen, BasicType bt) {\n+    return VTransformVectorNodeProperties(phi, phi->Opcode(), vlen, bt);\n+  }\n+\n@@ -848,0 +856,10 @@\n+class VTransformPhiVectorNode : public VTransformVectorNode {\n+public:\n+  VTransformPhiVectorNode(VTransform& vtransform, uint req, const VTransformVectorNodeProperties properties) :\n+    VTransformVectorNode(vtransform, req, properties) {}\n+  virtual VTransformPhiVectorNode* isa_PhiVector() override { return this; }\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  virtual void apply_backedge(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"PhiVector\"; };)\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"}]}