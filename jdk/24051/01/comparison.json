{"files":[{"patch":"@@ -1671,1 +1671,1 @@\n-    shiftLCnt = phase->intcon(shift_mask + 1 - shift);\n+    shiftLCnt = phase->intcon((shift_mask + 1 - shift) & shift_mask);\n@@ -1687,0 +1687,1 @@\n+    shiftLCnt = phase->transform(new AndINode(shiftLCnt, phase->intcon(shift_mask)));\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8351627\n+ * @summary C2 AArch64 ROR\/ROL: assert((1 << ((T>>1)+3)) > shift) failed: Invalid Shift value\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:-TieredCompilation compiler.vectorapi.TestRotateWithZero\n+ *\/\n+public class TestRotateWithZero {\n+    private static final int INVOCATIONS = 10000;\n+    private static final int LENGTH = 2048;\n+    private static final Generators random = Generators.G;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_PREFERRED;\n+\n+    private static int[] arr1;\n+    private static int[] arr2;\n+    private static int[] res;\n+    private static short[] sarr1;\n+    private static short[] sarr2;\n+    private static short[] sres;\n+\n+    static {\n+        arr1 = new int[LENGTH];\n+        arr2 = new int[LENGTH];\n+        res = new int[LENGTH];\n+        sarr1 = new short[LENGTH];\n+        sarr2 = new short[LENGTH];\n+        sres = new short[LENGTH];\n+\n+        random.fill(random.ints(), arr1);\n+        Generator<Integer> shortGen = random.uniformInts(Short.MIN_VALUE, Short.MAX_VALUE);\n+        for (int i = 0; i < LENGTH; i++) {\n+            sarr1[i] = shortGen.next().shortValue();\n+            sarr2[i] = (short)0;\n+            arr2[i] = 0;\n+        }\n+    }\n+\n+    private static void rotateRightWithZero() {\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector v = IntVector.fromArray(I_SPECIES, arr1, i);\n+            v.lanewise(VectorOperators.ROR, 0).intoArray(res, i);\n+        }\n+    }\n+\n+    private static void rotateLeftWithZero() {\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector v = IntVector.fromArray(I_SPECIES, arr1, i);\n+            v.lanewise(VectorOperators.ROL, 0).intoArray(res, i);\n+        }\n+    }\n+\n+    private static void rotateRightWithZeroConst() {\n+        IntVector vzero = IntVector.zero(I_SPECIES);\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector v = IntVector.fromArray(I_SPECIES, arr1, i);\n+            v.lanewise(VectorOperators.ROR, vzero).intoArray(res, i);\n+        }\n+    }\n+\n+    private static void rotateLeftWithZeroConst() {\n+        IntVector vzero = IntVector.zero(I_SPECIES);\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector v = IntVector.fromArray(I_SPECIES, arr1, i);\n+            v.lanewise(VectorOperators.ROL, vzero).intoArray(res, i);\n+        }\n+    }\n+\n+    private static void rotateRightWithZeroArr() {\n+        IntVector vzero = IntVector.fromArray(I_SPECIES, arr2, 0);\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector v = IntVector.fromArray(I_SPECIES, arr1, i);\n+            v.lanewise(VectorOperators.ROR, vzero).intoArray(res, i);\n+        }\n+    }\n+\n+    private static void rotateLeftWithZeroArr() {\n+        IntVector vzero = IntVector.fromArray(I_SPECIES, arr2, 0);\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector v = IntVector.fromArray(I_SPECIES, arr1, i);\n+            v.lanewise(VectorOperators.ROL, vzero).intoArray(res, i);\n+        }\n+    }\n+\n+    private static void rotateRightWithZeroVar() {\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector v = IntVector.fromArray(I_SPECIES, arr1, i);\n+            v.lanewise(VectorOperators.ROR, arr2[i]).intoArray(res, i);\n+        }\n+    }\n+\n+    private static void rotateLeftWithZeroVar() {\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector v = IntVector.fromArray(I_SPECIES, arr1, i);\n+            v.lanewise(VectorOperators.ROL, arr2[i]).intoArray(res, i);\n+        }\n+    }\n+\n+    private static void rotateRightWithZero_subword() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector v = ShortVector.fromArray(S_SPECIES, sarr1, i);\n+            v.lanewise(VectorOperators.ROR, 0).intoArray(sres, i);\n+        }\n+    }\n+\n+    private static void rotateLeftWithZero_subword() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector v = ShortVector.fromArray(S_SPECIES, sarr1, i);\n+            v.lanewise(VectorOperators.ROL, 0).intoArray(sres, i);\n+        }\n+    }\n+\n+    private static void rotateRightWithZeroConst_subword() {\n+        ShortVector vzero = ShortVector.zero(S_SPECIES);\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector v = ShortVector.fromArray(S_SPECIES, sarr1, i);\n+            v.lanewise(VectorOperators.ROR, vzero).intoArray(sres, i);\n+        }\n+    }\n+\n+    private static void rotateLeftWithZeroConst_subword() {\n+        ShortVector vzero = ShortVector.zero(S_SPECIES);\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector v = ShortVector.fromArray(S_SPECIES, sarr1, i);\n+            v.lanewise(VectorOperators.ROL, vzero).intoArray(sres, i);\n+        }\n+    }\n+\n+    private static void rotateRightWithZeroArr_subword() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector v1 = ShortVector.fromArray(S_SPECIES, sarr1, i);\n+            ShortVector v2 = ShortVector.fromArray(S_SPECIES, sarr2, i);\n+            v1.lanewise(VectorOperators.ROR, v2).intoArray(sres, i);\n+        }\n+    }\n+\n+    private static void rotateLeftWithZeroArr_subword() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector v1 = ShortVector.fromArray(S_SPECIES, sarr1, i);\n+            ShortVector v2 = ShortVector.fromArray(S_SPECIES, sarr2, i);\n+            v1.lanewise(VectorOperators.ROL, v2).intoArray(sres, i);\n+        }\n+    }\n+\n+    private static void rotateRightWithZeroVar_subword() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector v = ShortVector.fromArray(S_SPECIES, sarr1, i);\n+            v.lanewise(VectorOperators.ROR, sarr2[i]).intoArray(sres, i);\n+        }\n+    }\n+\n+    private static void rotateLeftWithZeroVar_subword() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector v = ShortVector.fromArray(S_SPECIES, sarr1, i);\n+            v.lanewise(VectorOperators.ROL, sarr2[i]).intoArray(sres, i);\n+        }\n+    }\n+\n+    private static void checkResults(int[] ref, int[] res) {\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals(ref[i], res[i]);\n+        }\n+    }\n+\n+    private static void checkResults(short[] ref, short[] res) {\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals(ref[i], res[i]);\n+        }\n+    }\n+\n+    private static void test() {\n+        \/\/ Test rotate with a immediate 0\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateRightWithZero();\n+        }\n+        checkResults(arr1, res);\n+\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateLeftWithZero();\n+        }\n+        checkResults(arr1, res);\n+\n+        \/\/ Test rotate with a constant vector with all zeros\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateRightWithZeroConst();\n+        }\n+        checkResults(arr1, res);\n+\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateLeftWithZeroConst();\n+        }\n+        checkResults(arr1, res);\n+\n+        \/\/ Test rotate with a vector loaded from the memory\n+        \/\/ filled with zeros\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateRightWithZeroArr();\n+        }\n+        checkResults(arr1, res);\n+\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateLeftWithZeroArr();\n+        }\n+        checkResults(arr1, res);\n+\n+        \/\/ Test rotate with a variable assigned with zero.\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateRightWithZeroVar();\n+        }\n+        checkResults(arr1, res);\n+\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateLeftWithZeroVar();\n+        }\n+        checkResults(arr1, res);\n+    }\n+\n+    private static void test_subword() {\n+        \/\/ Test rotate with a immediate 0\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateRightWithZero_subword();\n+        }\n+        checkResults(sarr1, sres);\n+\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateLeftWithZero_subword();\n+        }\n+        checkResults(sarr1, sres);\n+\n+        \/\/ Test rotate with a constant vector with all zeros\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateRightWithZeroConst_subword();\n+        }\n+        checkResults(sarr1, sres);\n+\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateLeftWithZeroConst_subword();\n+        }\n+        checkResults(sarr1, sres);\n+\n+        \/\/ Test rotate with a vector loaded from the memory\n+        \/\/ filled with zeros\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateRightWithZeroArr_subword();\n+        }\n+        checkResults(sarr1, sres);\n+\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateLeftWithZeroArr_subword();\n+        }\n+        checkResults(sarr1, sres);\n+\n+        \/\/ Test rotate with a variable assigned with zero.\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateRightWithZeroVar_subword();\n+        }\n+        checkResults(sarr1, sres);\n+\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            rotateLeftWithZeroVar_subword();\n+        }\n+        checkResults(sarr1, sres);\n+    }\n+\n+    public static void main(String[] args) {\n+        test();\n+        test_subword();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestRotateWithZero.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"}]}