{"files":[{"patch":"@@ -547,0 +547,1 @@\n+    MFVSRLD_OPCODE = (31u << OPCODE_SHIFT |  307u << 1),\n@@ -739,0 +740,8 @@\n+    VCLZB_OPCODE   = (4u  << OPCODE_SHIFT | 1794u     ),\n+    VCLZH_OPCODE   = (4u  << OPCODE_SHIFT | 1858u     ),\n+    VCLZW_OPCODE   = (4u  << OPCODE_SHIFT | 1922u     ),\n+    VCLZD_OPCODE   = (4u  << OPCODE_SHIFT | 1986u     ),\n+    VCTZB_OPCODE   = (4u  << OPCODE_SHIFT | 28u << 16 | 1538u),\n+    VCTZH_OPCODE   = (4u  << OPCODE_SHIFT | 29u << 16 | 1538u),\n+    VCTZW_OPCODE   = (4u  << OPCODE_SHIFT | 30u << 16 | 1538u),\n+    VCTZD_OPCODE   = (4u  << OPCODE_SHIFT | 31u << 16 | 1538u),\n@@ -2337,0 +2346,8 @@\n+  inline void vclzb(    VectorRegister d, VectorRegister b);\n+  inline void vclzh(    VectorRegister d, VectorRegister b);\n+  inline void vclzw(    VectorRegister d, VectorRegister b);\n+  inline void vclzd(    VectorRegister d, VectorRegister b);\n+  inline void vctzb(    VectorRegister d, VectorRegister b);\n+  inline void vctzh(    VectorRegister d, VectorRegister b);\n+  inline void vctzw(    VectorRegister d, VectorRegister b);\n+  inline void vctzd(    VectorRegister d, VectorRegister b);\n@@ -2361,0 +2378,1 @@\n+  inline void mfvsrld(  Register        d, VectorSRegister a); \/\/ Requires Power9.\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -876,0 +876,1 @@\n+inline void Assembler::mfvsrld( Register d, VectorSRegister a)               { emit_int32( MFVSRLD_OPCODE | vsrs(a)  | ra(d)); }\n@@ -1079,0 +1080,8 @@\n+inline void Assembler::vclzb(   VectorRegister d, VectorRegister b)                   { emit_int32( VCLZB_OPCODE    | vrt(d) | vrb(b)); }\n+inline void Assembler::vclzh(   VectorRegister d, VectorRegister b)                   { emit_int32( VCLZH_OPCODE    | vrt(d) | vrb(b)); }\n+inline void Assembler::vclzw(   VectorRegister d, VectorRegister b)                   { emit_int32( VCLZW_OPCODE    | vrt(d) | vrb(b)); }\n+inline void Assembler::vclzd(   VectorRegister d, VectorRegister b)                   { emit_int32( VCLZD_OPCODE    | vrt(d) | vrb(b)); }\n+inline void Assembler::vctzb(   VectorRegister d, VectorRegister b)                   { emit_int32( VCTZB_OPCODE    | vrt(d) | vrb(b)); }\n+inline void Assembler::vctzh(   VectorRegister d, VectorRegister b)                   { emit_int32( VCTZH_OPCODE    | vrt(d) | vrb(b)); }\n+inline void Assembler::vctzw(   VectorRegister d, VectorRegister b)                   { emit_int32( VCTZW_OPCODE    | vrt(d) | vrb(b)); }\n+inline void Assembler::vctzd(   VectorRegister d, VectorRegister b)                   { emit_int32( VCTZD_OPCODE    | vrt(d) | vrb(b)); }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2111,0 +2111,1 @@\n+    case Op_PopCountVL:\n@@ -2112,0 +2113,4 @@\n+    case Op_CountLeadingZerosV:\n+      return SuperwordUseVSX && UseCountLeadingZerosInstructionsPPC64;\n+    case Op_CountTrailingZerosV:\n+      return SuperwordUseVSX && UseCountTrailingZerosInstructionsPPC64;\n@@ -14080,1 +14085,1 @@\n-\/\/ Vector Population Count Instructions\n+\/\/ Vector Population Count and Zeros Count Instructions\n@@ -14084,0 +14089,1 @@\n+  match(Set dst (PopCountVL src));\n@@ -14108,0 +14114,52 @@\n+instruct vcount_leading_zeros_reg(vecX dst, vecX src) %{\n+  match(Set dst (CountLeadingZerosV src));\n+  format %{ \"VCLZ $dst,$src\\t\/\/ leading zeros count packed\" %}\n+  size(4);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_BYTE:\n+        __ vclzb($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        break;\n+      case T_SHORT:\n+        __ vclzh($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        break;\n+      case T_INT:\n+        __ vclzw($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        break;\n+      case T_LONG:\n+        __ vclzd($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vcount_trailing_zeros_reg(vecX dst, vecX src) %{\n+  match(Set dst (CountTrailingZerosV src));\n+  format %{ \"VCTZ $dst,$src\\t\/\/ trailing zeros count packed\" %}\n+  size(4);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_BYTE:\n+        __ vctzb($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        break;\n+      case T_SHORT:\n+        __ vctzh($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        break;\n+      case T_INT:\n+        __ vctzw($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        break;\n+      case T_LONG:\n+        __ vctzd($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-*           (os.simpleArch == \"riscv64\" & vm.cpu.features ~= \".*zvbb.*\")\n+*           (os.simpleArch == \"riscv64\" & vm.cpu.features ~= \".*zvbb.*\") |\n+*           ((os.arch == \"ppc64\" | os.arch == \"ppc64le\") & vm.cpu.features ~= \".*darn.*\")\n@@ -73,1 +74,2 @@\n-    @IR(counts = {IRNode.COUNT_TRAILING_ZEROS_VL, \"> 0\"})\n+    @IR(applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"},\n+        counts = {IRNode.COUNT_TRAILING_ZEROS_VL, \"> 0\"})\n@@ -81,1 +83,2 @@\n-    @IR(counts = {IRNode.COUNT_LEADING_ZEROS_VL, \"> 0\"})\n+    @IR(applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"},\n+        counts = {IRNode.COUNT_LEADING_ZEROS_VL, \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestNumberOfContinuousZeros.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-*           (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zvbb.*\")\n+*           (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zvbb.*\") |\n+*           os.arch == \"ppc64\" | os.arch == \"ppc64le\"\n@@ -62,1 +63,2 @@\n-    @IR(counts = {IRNode.POPCOUNT_VL, \">= 1\"}) \/\/ At least one PopCountVL node is generated if vectorization is successful\n+    @IR(applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"},\n+        counts = {IRNode.POPCOUNT_VL, \">= 1\"}) \/\/ At least one PopCountVL node is generated if vectorization is successful\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVectorLong.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}