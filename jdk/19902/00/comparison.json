{"files":[{"patch":"@@ -103,1 +103,1 @@\n-      \"the alloc region should never be empty\");\n+                      \"the alloc region should never be empty\");\n@@ -109,4 +109,1 @@\n-  assert_alloc_region(alloc_region->used() >= _used_bytes_before, \"invariant\");\n-  size_t allocated_bytes = alloc_region->used() - _used_bytes_before;\n-  retire_region(alloc_region, allocated_bytes);\n-  _used_bytes_before = 0;\n+  retire_region(alloc_region);\n@@ -135,1 +132,0 @@\n-  assert_alloc_region(_used_bytes_before == 0, \"pre-condition\");\n@@ -141,3 +137,3 @@\n-    \/\/ Need to do this before the allocation\n-    _used_bytes_before = new_alloc_region->used();\n-    HeapWord* result = allocate(new_alloc_region, word_size);\n+\n+    assert(new_alloc_region->is_empty(), \"new regions should be empty\");\n+    HeapWord* result = new_alloc_region->allocate(word_size);\n@@ -162,1 +158,1 @@\n-  assert_alloc_region(_alloc_region == nullptr && _used_bytes_before == 0, \"pre-condition\");\n+  assert_alloc_region(_alloc_region == nullptr, \"pre-condition\");\n@@ -171,6 +167,1 @@\n-  \/\/ We explicitly check that the region is not empty to make sure we\n-  \/\/ maintain the \"the alloc region cannot be empty\" invariant.\n-  assert_alloc_region(alloc_region != nullptr && !alloc_region->is_empty(), \"pre-condition\");\n-  assert_alloc_region(_alloc_region == _dummy_region &&\n-                         _used_bytes_before == 0 && _count == 0,\n-                         \"pre-condition\");\n+  assert_alloc_region(_alloc_region == _dummy_region && _count == 0, \"pre-condition\");\n@@ -178,3 +169,1 @@\n-  _used_bytes_before = alloc_region->used();\n-  _alloc_region = alloc_region;\n-  _count += 1;\n+  update_alloc_region(alloc_region);\n@@ -240,1 +229,1 @@\n-                     min_word_size, desired_word_size, actual_word_size, p2i(result));\n+                   min_word_size, desired_word_size, actual_word_size, p2i(result));\n@@ -255,1 +244,0 @@\n-    _used_bytes_before(0),\n@@ -264,3 +252,2 @@\n-void MutatorAllocRegion::retire_region(G1HeapRegion* alloc_region,\n-                                       size_t allocated_bytes) {\n-  _g1h->retire_mutator_alloc_region(alloc_region, allocated_bytes);\n+void MutatorAllocRegion::retire_region(G1HeapRegion* alloc_region) {\n+  _g1h->retire_mutator_alloc_region(alloc_region, alloc_region->used());\n@@ -349,2 +336,3 @@\n-void G1GCAllocRegion::retire_region(G1HeapRegion* alloc_region,\n-                                    size_t allocated_bytes) {\n+void G1GCAllocRegion::retire_region(G1HeapRegion* alloc_region) {\n+  assert(alloc_region->used() >= _used_bytes_before, \"invariant\");\n+  size_t allocated_bytes = alloc_region->used() - _used_bytes_before;\n@@ -352,0 +340,1 @@\n+  _used_bytes_before = 0;\n@@ -363,0 +352,5 @@\n+\n+void G1GCAllocRegion::reuse(G1HeapRegion* alloc_region) {\n+  _used_bytes_before = alloc_region->used();\n+  set(alloc_region);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":20,"deletions":26,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -100,4 +100,0 @@\n-  \/\/ Perform a non-MT-safe allocation out of the given region.\n-  inline HeapWord* allocate(G1HeapRegion* alloc_region,\n-                            size_t word_size);\n-\n@@ -107,8 +103,0 @@\n-  \/\/ Perform a MT-safe allocation out of the given region, with the given\n-  \/\/ minimum and desired size. Returns the actual size allocated (between\n-  \/\/ minimum and desired size) in actual_word_size if the allocation has been\n-  \/\/ successful.\n-  inline HeapWord* par_allocate(G1HeapRegion* alloc_region,\n-                                size_t min_word_size,\n-                                size_t desired_word_size,\n-                                size_t* actual_word_size);\n@@ -134,2 +122,1 @@\n-  virtual void retire_region(G1HeapRegion* alloc_region,\n-                             size_t allocated_bytes) = 0;\n+  virtual void retire_region(G1HeapRegion* alloc_region) = 0;\n@@ -208,4 +195,3 @@\n-  virtual G1HeapRegion* allocate_new_region(size_t word_size);\n-  virtual void retire_region(G1HeapRegion* alloc_region, size_t allocated_bytes);\n-  virtual size_t retire(bool fill_up);\n-\n+  G1HeapRegion* allocate_new_region(size_t word_size) override;\n+  void retire_region(G1HeapRegion* alloc_region) override;\n+  size_t retire(bool fill_up) override;\n@@ -234,1 +220,1 @@\n-  virtual G1HeapRegion* release();\n+  G1HeapRegion* release() override;\n@@ -236,1 +222,1 @@\n-  virtual void init();\n+  void init() override;\n@@ -241,0 +227,1 @@\n+  size_t _used_bytes_before;\n@@ -245,2 +232,2 @@\n-  virtual G1HeapRegion* allocate_new_region(size_t word_size);\n-  virtual void retire_region(G1HeapRegion* alloc_region, size_t allocated_bytes);\n+  G1HeapRegion* allocate_new_region(size_t word_size) override;\n+  void retire_region(G1HeapRegion* alloc_region) override;\n@@ -248,1 +235,1 @@\n-  virtual size_t retire(bool fill_up);\n+  size_t retire(bool fill_up) override;\n@@ -252,1 +239,1 @@\n-  : G1AllocRegion(name, bot_updates, node_index), _stats(stats), _purpose(purpose) {\n+    : G1AllocRegion(name, bot_updates, node_index), _used_bytes_before(0), _stats(stats), _purpose(purpose) {\n@@ -255,0 +242,6 @@\n+public:\n+  \/\/ This can be used to set the active region to a specific\n+  \/\/ region. (Use Example: we try to retain the last old GC alloc\n+  \/\/ region that we've used during a GC and we can use set() to\n+  \/\/ re-instate it at the beginning of the next GC.)\n+  void reuse(G1HeapRegion* alloc_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":17,"deletions":24,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -44,7 +44,0 @@\n-inline HeapWord* G1AllocRegion::allocate(G1HeapRegion* alloc_region,\n-                                         size_t word_size) {\n-  assert(alloc_region != nullptr, \"pre-condition\");\n-\n-  return alloc_region->allocate(word_size);\n-}\n-\n@@ -52,8 +45,0 @@\n-  size_t temp;\n-  return par_allocate(alloc_region, word_size, word_size, &temp);\n-}\n-\n-inline HeapWord* G1AllocRegion::par_allocate(G1HeapRegion* alloc_region,\n-                                             size_t min_word_size,\n-                                             size_t desired_word_size,\n-                                             size_t* actual_word_size) {\n@@ -62,2 +47,2 @@\n-\n-  return alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n+  size_t temp;\n+  return alloc_region->par_allocate(word_size, word_size, &temp);\n@@ -70,1 +55,3 @@\n-  assert_alloc_region(alloc_region != nullptr, \"not initialized properly\");\n+  assert_alloc_region(alloc_region != nullptr && !alloc_region->is_empty(), \"not initialized properly\");\n+\n+  HeapWord* result = alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n@@ -72,1 +59,0 @@\n-  HeapWord* result = par_allocate(alloc_region, min_word_size, desired_word_size, actual_word_size);\n@@ -75,1 +61,2 @@\n-    return result;\n+  } else {\n+    trace(\"alloc failed\", min_word_size, desired_word_size);\n@@ -77,2 +64,1 @@\n-  trace(\"alloc failed\", min_word_size, desired_word_size);\n-  return nullptr;\n+  return result;\n@@ -115,1 +101,1 @@\n-    HeapWord* result = par_allocate(_retained_alloc_region, min_word_size, desired_word_size, actual_word_size);\n+    HeapWord* result = _retained_alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-    old->set(retained_region);\n+    old->reuse(retained_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,12 +130,0 @@\n-  \/\/ Try to allocate at least min_word_size and up to desired_size from this region.\n-  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n-  \/\/ space allocated.\n-  \/\/ This version assumes that all allocation requests to this G1HeapRegion are properly\n-  \/\/ synchronized.\n-  inline HeapWord* allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-  \/\/ Try to allocate at least min_word_size and up to desired_size from this G1HeapRegion.\n-  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n-  \/\/ space allocated.\n-  \/\/ This version synchronizes with other calls to par_allocate_impl().\n-  inline HeapWord* par_allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-\n@@ -166,0 +154,5 @@\n+\n+  \/\/ Try to allocate at least min_word_size and up to desired_size from this HeapRegion.\n+  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n+  \/\/ space allocated.\n+  \/\/ This version synchronizes with other calls to par_allocate().\n@@ -168,0 +161,5 @@\n+  \/\/ Try to allocate at least min_word_size and up to desired_size from this region.\n+  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n+  \/\/ space allocated.\n+  \/\/ This version assumes that all allocation requests to this HeapRegion are properly\n+  \/\/ synchronized.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -45,41 +45,0 @@\n-inline HeapWord* G1HeapRegion::allocate_impl(size_t min_word_size,\n-                                           size_t desired_word_size,\n-                                           size_t* actual_size) {\n-  HeapWord* obj = top();\n-  size_t available = pointer_delta(end(), obj);\n-  size_t want_to_allocate = MIN2(available, desired_word_size);\n-  if (want_to_allocate >= min_word_size) {\n-    HeapWord* new_top = obj + want_to_allocate;\n-    set_top(new_top);\n-    assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n-    *actual_size = want_to_allocate;\n-    return obj;\n-  } else {\n-    return nullptr;\n-  }\n-}\n-\n-inline HeapWord* G1HeapRegion::par_allocate_impl(size_t min_word_size,\n-                                               size_t desired_word_size,\n-                                               size_t* actual_size) {\n-  do {\n-    HeapWord* obj = top();\n-    size_t available = pointer_delta(end(), obj);\n-    size_t want_to_allocate = MIN2(available, desired_word_size);\n-    if (want_to_allocate >= min_word_size) {\n-      HeapWord* new_top = obj + want_to_allocate;\n-      HeapWord* result = Atomic::cmpxchg(&_top, obj, new_top);\n-      \/\/ result can be one of two:\n-      \/\/  the old top value: the exchange succeeded\n-      \/\/  otherwise: the new value of the top is returned.\n-      if (result == obj) {\n-        assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n-        *actual_size = want_to_allocate;\n-        return obj;\n-      }\n-    } else {\n-      return nullptr;\n-    }\n-  } while (true);\n-}\n-\n@@ -230,1 +189,19 @@\n-  return par_allocate_impl(min_word_size, desired_word_size, actual_word_size);\n+  do {\n+    HeapWord* obj = top();\n+    size_t available = pointer_delta(end(), obj);\n+    size_t want_to_allocate = MIN2(available, desired_word_size);\n+    if (want_to_allocate >= min_word_size) {\n+      HeapWord* new_top = obj + want_to_allocate;\n+      HeapWord* result = Atomic::cmpxchg(&_top, obj, new_top);\n+      \/\/ result can be one of two:\n+      \/\/ the old top value: the exchange succeeded\n+      \/\/ otherwise: the new value of the top is returned.\n+      if (result == obj) {\n+        assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n+        *actual_word_size = want_to_allocate;\n+        return obj;\n+      }\n+    } else {\n+      return nullptr;\n+    }\n+  } while (true);\n@@ -241,1 +218,12 @@\n-  return allocate_impl(min_word_size, desired_word_size, actual_word_size);\n+  HeapWord* obj = top();\n+  size_t available = pointer_delta(end(), obj);\n+  size_t want_to_allocate = MIN2(available, desired_word_size);\n+  if (want_to_allocate >= min_word_size) {\n+    HeapWord* new_top = obj + want_to_allocate;\n+    set_top(new_top);\n+    assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n+    *actual_word_size = want_to_allocate;\n+    return obj;\n+  } else {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":31,"deletions":43,"binary":false,"changes":74,"status":"modified"}]}