{"files":[{"patch":"@@ -454,2 +454,1 @@\n-  \/\/ methods on the table during a callback is not supported.Only MultiGetHandle\n-  \/\/ supports multiple gets.\n+  \/\/ methods on the table during a callback is not supported.\n@@ -541,12 +540,0 @@\n-  \/\/ Scoped multi getter.\n-  class MultiGetHandle : private ScopedCS {\n-   public:\n-    MultiGetHandle(Thread* thread, ConcurrentHashTable<CONFIG, MT>* cht)\n-      : ScopedCS(thread, cht) {}\n-    \/\/ In the MultiGetHandle scope you can lookup items matching LOOKUP_FUNC.\n-    \/\/ The VALUEs are safe as long as you never save the VALUEs outside the\n-    \/\/ scope, e.g. after ~MultiGetHandle().\n-    template <typename LOOKUP_FUNC>\n-    VALUE* get(LOOKUP_FUNC& lookup_f, bool* grow_hint = nullptr);\n-  };\n-\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -236,8 +236,0 @@\n-template <typename CONFIG, MemTag MT>\n-template <typename LOOKUP_FUNC>\n-inline typename CONFIG::Value* ConcurrentHashTable<CONFIG, MT>::\n-  MultiGetHandle::get(LOOKUP_FUNC& lookup_f, bool* grow_hint)\n-{\n-  return ScopedCS::_cht->internal_get(ScopedCS::_thread, lookup_f, grow_hint);\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-typedef ConcurrentHashTable<Pointer, mtInternal>::MultiGetHandle SimpleTestGetHandle;\n@@ -348,4 +347,0 @@\n-  {\n-    SimpleTestGetHandle get_handle(thr, cht);\n-    EXPECT_EQ(*get_handle.get(stl), val) << \"Getting a pre-existing value failed.\";\n-  }\n@@ -559,1 +554,0 @@\n-typedef ConcurrentHashTable<TestInterface, mtInternal>::MultiGetHandle TestGetHandle;\n@@ -791,9 +785,2 @@\n-      if (v & 0x1) {\n-        TestLookup tl(v);\n-        tv = cht_get_copy(_cht, this, tl);\n-      } else {\n-        TestLookup tl(v);\n-        TestGetHandle value_handle(this, _cht);\n-        uintptr_t* tmp = value_handle.get(tl);\n-        tv = tmp != nullptr ? *tmp : 0;\n-      }\n+      TestLookup tl(v);\n+      tv = cht_get_copy(_cht, this, tl);\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"}]}