{"files":[{"patch":"@@ -413,0 +413,2 @@\n+  DEBUG_ONLY(CompilationMemoryStatistic::do_test_allocations();)\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  : _ciEnv_arena(mtCompiler) {\n+  : _ciEnv_arena(mtCompiler, Arena::Tag::tag_cienv) {\n@@ -241,1 +241,1 @@\n-ciEnv::ciEnv(Arena* arena) : _ciEnv_arena(mtCompiler) {\n+ciEnv::ciEnv(Arena* arena) : _ciEnv_arena(mtCompiler, Arena::Tag::tag_cienv) {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  Arena* arena = new (mtCompiler) Arena(mtCompiler);\n+  Arena* arena = new (mtCompiler) Arena(mtCompiler, Arena::Tag::tag_cienv);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_COMPILER_COMPILATIONMEMSTATINTERNALS_HPP\n+#define SHARE_COMPILER_COMPILATIONMEMSTATINTERNALS_HPP\n+\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/arena.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#ifdef COMPILER2\n+#include \"opto\/phase.hpp\"\n+#endif\n+\n+class CompileTask;\n+class Method;\n+class Symbol;\n+class outputStream;\n+\n+#ifdef COMPILER2\n+constexpr int phase_trc_id_max     = (int)Phase::PhaseTraceId::max_phase_timers;\n+constexpr int phase_trc_id_none    = (int)Phase::PhaseTraceId::_t_none;\n+#else\n+\/\/ In minimal builds, the ArenaCounterTable is just a single-dimension vector of arena tags (see below)\n+constexpr int phase_trc_id_max = 1;\n+constexpr int phase_trc_id_none = 0;\n+#endif\n+inline void check_phase_trace_id(int v) { assert(v >= 0 && v < phase_trc_id_max, \"OOB (%d)\", v); }\n+\n+constexpr int arena_tag_max = (int)Arena::Tag::tag_count;\n+inline void check_arena_tag(int v) { assert(v >= 0 && v < arena_tag_max, \"OOB (%d)\", v); }\n+\n+\/\/ A two-dimensional table, containing byte counters per arena type and\n+\/\/ per compilation phase.\n+class ArenaCounterTable {\n+  size_t _v[phase_trc_id_max][arena_tag_max];\n+public:\n+  ArenaCounterTable();\n+  void copy_from(const ArenaCounterTable& other);\n+  inline size_t at(int phase_trc_id, int arena_tag) const;\n+  inline void add(size_t size, int phase_trc_id, int arena_tag);\n+  inline void sub(size_t size, int phase_trc_id, int arena_tag);\n+  void print_on(outputStream* ss) const;\n+  void summarize(size_t out[arena_tag_max]) const;\n+};\n+\n+struct PhaseInfo {\n+  int id, num;\n+  const char* text;\n+};\n+\n+\/\/ A stack keeping track of the current compilation phase. Fixed-width for simplicity\n+\/\/ (we should never go beyond 5 or so in depth).\n+class PhaseInfoStack {\n+  static constexpr int max_depth = 16;\n+  int _depth;\n+  PhaseInfo _stack[max_depth];\n+public:\n+  inline PhaseInfoStack();\n+  inline bool empty() const { return _depth == 0; }\n+  inline void push(PhaseInfo info);\n+  inline void pop();\n+  inline const PhaseInfo& top() const;\n+  inline int depth() const  { return _depth; }\n+};\n+\n+\/\/ A very simple fixed-width FIFO buffer, used for the phase timeline\n+template <typename T, int size>\n+class SimpleFifo {\n+  STATIC_ASSERT((size * 2) < INT_MAX);\n+  T _v[size];\n+  int _pos;\n+  int _oldest;\n+  uint64_t _lost;\n+\n+  int current_pos() const           { return _pos; }\n+  static int pos_to_index(int pos)  { return pos % size; }\n+  T& at(int pos)                    { return *(_v + pos_to_index(pos)); }\n+\n+public:\n+  SimpleFifo() : _pos(0), _oldest(0), _lost(0UL) {}\n+  T& current()                      { return at(current_pos()); }\n+  T& last()                         { assert(!empty(), \"sanity\"); return at(current_pos() - 1); }\n+  bool empty() const                { return _pos == _oldest; }\n+  uint64_t lost() const             { return _lost; }\n+\n+  void advance() {\n+    _pos ++;\n+    if (_pos >= size) {\n+      _oldest ++;\n+      _lost ++;\n+    }\n+    if (_pos == INT_MAX) {\n+      _pos -= size;\n+      _oldest -= size;\n+    }\n+  }\n+\n+  void revert() {\n+    assert(!empty(), \"sanity\");\n+    _pos--;\n+  }\n+\n+  template<typename F>\n+  void iterate_all(F f) const {\n+    for (int i = _oldest; i < _pos; i++) {\n+      const int index = pos_to_index(i);\n+      f(_v[index]);\n+    }\n+  }\n+\n+  void copy_from(const SimpleFifo& other) {\n+    memcpy(_v, other._v, sizeof(_v));\n+    _pos = other._pos;\n+    _lost = other._lost;\n+    _oldest = other._oldest;\n+  }\n+};\n+\n+\/\/ Holds a table of n entries; each entry keeping start->end footprints when\n+\/\/ a phase started and ended; each entry also keeping the phase-local peak (if\n+\/\/ a phase caused a temporary spike in footprint that vanished before the phase\n+\/\/ ended).\n+\/\/ Handling nested phases: for this structure, there is always a phase active;\n+\/\/ if a phase ends, we \"restart\" the parent phase (which often is the\n+\/\/ \"outside any phase\" phase).\n+class FootprintTimeline {\n+public:\n+  static constexpr unsigned max_num_phases = 256; \/\/ beyond that we wrap, keeping just the last n phases\n+private:\n+  template <typename T, typename dT>\n+  struct C {\n+    T start, peak, cur;\n+    void init(T v)        { start = cur = peak = v; }\n+    void update(T v)      { cur = v; if (v > peak) peak = v; }\n+    dT end_delta() const  { return (dT)cur - (dT)start; }\n+    size_t temporary_peak_size() const { return MIN2(peak - cur, peak - start); }\n+  };\n+  struct Entry {\n+    PhaseInfo info;\n+    int level;\n+    C<size_t, ssize_t> _bytes;\n+    C<unsigned, signed int> _live_nodes;\n+  };\n+  SimpleFifo<Entry, max_num_phases> _fifo;\n+  DEBUG_ONLY(bool _inbetween_phases;)\n+public:\n+  FootprintTimeline();\n+  void copy_from(const FootprintTimeline& other);\n+  inline void on_footprint_change(size_t cur_abs, unsigned cur_nodes);\n+  void on_phase_end(size_t cur_abs, unsigned cur_nodes);\n+  void on_phase_start(PhaseInfo info, size_t cur_abs, unsigned cur_nodes, int level);\n+  void print_on(outputStream* st) const;\n+};\n+\n+\/\/ We keep the name of the involved symbols in Symbol (made permanent) instead of resolving them to string and\n+\/\/ storing those. That significantly reduces footprint for the result store and delays resolving until printing\n+\/\/ time, which may be never.\n+class FullMethodName {\n+  Symbol* _k;\n+  Symbol* _m;\n+  Symbol* _s;\n+public:\n+  FullMethodName();\n+  FullMethodName(const Method* m);\n+  FullMethodName(const FullMethodName& o);\n+  FullMethodName& operator=(const FullMethodName& o);\n+  void make_permanent();\n+  void print_on(outputStream* st) const;\n+  char* as_C_string(char* buf, size_t len) const;\n+  bool operator== (const FullMethodName& b) const;\n+  DEBUG_ONLY(bool is_test_class() const;)\n+};\n+\n+\/\/ ArenaState is the central data structure holding all statistics and temp data during\n+\/\/ a single compilation. It is created on demand (if memstat is active) and tied to the\n+\/\/ CompilerThread.\n+class ArenaStatCounter : public CHeapObj<mtCompiler> {\n+\n+  FullMethodName _fmn;\n+\n+  \/\/ from directives\n+  const bool _should_print_memstat;\n+  const bool _should_crash_on_memlimit;\n+\n+  \/\/ Bytes total now\n+  size_t _current;\n+  \/\/ Bytes total at last global peak\n+  size_t _peak;\n+  \/\/ Bytes per arena\/phase, now\n+  ArenaCounterTable _counters_current;\n+  \/\/ Bytes per arena\/phase when we last reached the global peak\n+  ArenaCounterTable _counters_at_global_peak;\n+\n+  \/\/ Number of live nodes now (C2 only)\n+  unsigned _live_nodes_current;\n+  \/\/ Number of live nodes at global peak (C2 only)\n+  unsigned _live_nodes_at_global_peak;\n+\n+  \/\/ MemLimit handling\n+  const size_t _limit;\n+  bool _hit_limit;\n+  bool _limit_in_process;\n+\n+  \/\/ Keep track of current C2 phase\n+  int _phase_counter;\n+  PhaseInfoStack _phase_info_stack;\n+\n+  \/\/ Keep track of C2 phase allocations over time\n+  FootprintTimeline _timeline;\n+\n+  const CompilerType _comp_type;\n+  const int _comp_id;\n+\n+  DEBUG_ONLY(bool _is_test_class;)\n+\n+  int retrieve_live_node_count() const;\n+\n+  DEBUG_ONLY(void verify() const;)\n+\n+public:\n+  ArenaStatCounter(const CompileTask* task, size_t limit);\n+\n+  void on_phase_start(PhaseInfo info);\n+  void on_phase_end();\n+\n+  \/\/ Account an arena allocation. Returns true if new peak reached.\n+  bool on_arena_chunk_allocation(size_t size, int arena_tag, uint64_t* stamp);\n+\n+  \/\/ Account an arena deallocation.\n+  void on_arena_chunk_deallocation(size_t size, uint64_t stamp);\n+\n+  void print_peak_state_on(outputStream* st) const;\n+  void print_error_state_on(outputStream* st) const;\n+\n+  size_t limit() const                  { return _limit; }\n+  bool   hit_limit() const              { return _hit_limit; }\n+  bool   limit_in_process() const       { return _limit_in_process; }\n+  void   set_limit_in_process(bool v)   { _limit_in_process = v; }\n+\n+  const FullMethodName& fmn() const     { return _fmn; }\n+  bool should_print_memstat()           { return _should_print_memstat; };\n+  bool should_crash_on_memlimit() const { return _should_crash_on_memlimit; };\n+\n+  CompilerType comp_type() const        { return _comp_type; }\n+  int comp_id() const                   { return _comp_id; }\n+  DEBUG_ONLY(bool is_test_class() const { return _is_test_class; })\n+\n+  \/\/ Bytes total at last global peak\n+  size_t peak() const                   { return _peak; }\n+\n+  \/\/ Bytes per arena\/phase when we last reached the global peak\n+  const ArenaCounterTable& counters_at_global_peak() const { return _counters_at_global_peak; }\n+  const FootprintTimeline& timeline() const                { return _timeline; }\n+  \/\/ Number of live nodes at global peak (C2 only)\n+  unsigned live_nodes_at_global_peak() const { return _live_nodes_at_global_peak; }\n+\n+  int advance_phase_counter() { return ++_phase_counter; }\n+};\n+\n+#endif \/\/ SHARE_COMPILER_COMPILATIONMEMSTATINTERNALS_HPP\n","filename":"src\/hotspot\/share\/compiler\/compilationMemStatInternals.hpp","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_COMPILATIONMEMSTATINTERNALS_INLINE_HPP\n+#define SHARE_COMPILATIONMEMSTATINTERNALS_INLINE_HPP\n+\n+#include \"compiler\/compilationMemStatInternals.hpp\"\n+\n+inline PhaseInfoStack::PhaseInfoStack() : _depth(0) {}\n+\n+inline void PhaseInfoStack::push(PhaseInfo info) {\n+#ifdef ASSERT\n+  check_phase_trace_id(info.id);\n+  if (_depth == 0) {\n+    assert(info.id == phase_trc_id_none, \"first entry must be none\");\n+  } else {\n+    assert(info.id != phase_trc_id_none, \"subsequent entries must not be none\");\n+  }\n+  assert(_depth < max_depth, \"Sanity\");\n+#endif \/\/ ASSERT\n+  _stack[_depth] = info;\n+  if (_depth < max_depth) {\n+    _depth++;\n+  }\n+}\n+\n+inline void PhaseInfoStack::pop() {\n+#ifdef ASSERT\n+  assert(!empty(), \"Sanity \");\n+  const PhaseInfo to_be_popped = top();\n+  if (_depth == 1) {\n+    assert(to_be_popped.id == phase_trc_id_none, \"first entry must be none\");\n+  } else {\n+    assert(to_be_popped.id != phase_trc_id_none, \"subsequent entries must not be none\");\n+  }\n+#endif \/\/ ASSERT\n+  if (_depth > 0) {\n+    _depth--;\n+  }\n+}\n+\n+inline const PhaseInfo& PhaseInfoStack::top() const {\n+  assert(!empty(), \"Sanity\");\n+  return _stack[_depth - 1];\n+}\n+\n+inline size_t ArenaCounterTable::at(int phase_trc_id, int arena_tag) const {\n+  check_phase_trace_id(phase_trc_id);\n+  check_arena_tag(arena_tag);\n+  return _v[phase_trc_id][arena_tag];\n+}\n+\n+inline void ArenaCounterTable::add(size_t size, int phase_trc_id, int arena_tag) {\n+  check_arena_tag(arena_tag);\n+  const size_t old = at(phase_trc_id, arena_tag);\n+  _v[phase_trc_id][arena_tag] += size;\n+  assert(at(phase_trc_id, arena_tag) >= old, \"Overflow\");\n+}\n+\n+inline void ArenaCounterTable::sub(size_t size, int phase_trc_id, int arena_tag) {\n+  check_arena_tag(arena_tag);\n+  assert(at(phase_trc_id, arena_tag) >= size, \"Underflow (%zu %zu)\", at(phase_trc_id, arena_tag), size);\n+  _v[phase_trc_id][arena_tag] -= size;\n+}\n+\n+inline void FootprintTimeline::on_footprint_change(size_t cur_abs, unsigned cur_nodes) {\n+  assert(!_inbetween_phases, \"no phase started?\");\n+  Entry& e = _fifo.current();\n+  e._bytes.update(cur_abs);\n+  e._live_nodes.update(cur_nodes);\n+}\n+\n+#endif \/\/ SHARE_COMPILATIONMEMSTATINTERNALS_INLINE_HPP\n","filename":"src\/hotspot\/share\/compiler\/compilationMemStatInternals.inline.hpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc. and\/or its affiliates.\n@@ -26,5 +26,1 @@\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#ifdef COMPILER1\n-#include \"c1\/c1_Compilation.hpp\"\n-#endif\n+#include \"code\/nmethod.hpp\"\n@@ -32,1 +28,2 @@\n-#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compilationMemStatInternals.inline.hpp\"\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -34,2 +31,1 @@\n-#include \"compiler\/compileTask.hpp\"\n-#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -37,0 +33,3 @@\n+#include \"compiler\/compileTask.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -38,1 +37,0 @@\n-#include \"memory\/resourceArea.hpp\"\n@@ -40,0 +38,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -41,4 +40,1 @@\n-#ifdef COMPILER2\n-#include \"opto\/node.hpp\" \/\/ compile.hpp is not self-contained\n-#include \"opto\/compile.hpp\"\n-#endif\n+#include \"runtime\/atomic.hpp\"\n@@ -47,0 +43,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -50,2 +47,0 @@\n-#include \"utilities\/quickSort.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n@@ -53,2 +48,143 @@\n-ArenaStatCounter::ArenaStatCounter() {\n-  reset();\n+#ifdef COMPILER1\n+#include \"c1\/c1_Compilation.hpp\"\n+#endif\n+\n+#ifdef COMPILER2\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/node.hpp\" \/\/ compile.hpp is not self-contained\n+#endif\n+\n+static const char* phase_trc_id_to_string(int phase_trc_id) {\n+  return COMPILER2_PRESENT(Phase::get_phase_trace_id_text((Phase::PhaseTraceId)phase_trc_id))\n+         NOT_COMPILER2(\"\");\n+}\n+\n+\/\/ If crash option on memlimit is enabled and an oom occurred, the stats for the\n+\/\/ first offending compilation.\n+static ArenaStatCounter* volatile _arenastat_oom_crash = nullptr;\n+\n+\/\/ Arena-chunk stamping\n+union chunkstamp_t {\n+  uint64_t raw;\n+  struct {\n+    uint32_t tracked;\n+    uint16_t arena_tag;\n+    uint16_t phase_id;\n+  };\n+};\n+STATIC_ASSERT(sizeof(chunkstamp_t) == sizeof(chunkstamp_t::raw));\n+\n+ArenaCounterTable::ArenaCounterTable() {\n+  memset(_v, 0, sizeof(_v));\n+}\n+\n+void ArenaCounterTable::copy_from(const ArenaCounterTable& other) {\n+  memcpy(_v, other._v, sizeof(_v));\n+}\n+\n+void ArenaCounterTable::summarize(size_t out[arena_tag_max]) const {\n+  memset(out, 0, arena_tag_max * sizeof(size_t));\n+  for (int i = 0; i < phase_trc_id_max; i++) {\n+    for (int j = 0; j < arena_tag_max; j++) {\n+      out[j] += _v[i][j];\n+    }\n+  }\n+}\n+\n+void ArenaCounterTable::print_on(outputStream* st) const {\n+  bool header_printed = false;\n+  for (int phase_trc_id = 0; phase_trc_id < phase_trc_id_max; phase_trc_id++) {\n+    size_t sum = 0;\n+    for (int arena_tag = 0; arena_tag < arena_tag_max; arena_tag++) {\n+      sum += at(phase_trc_id, arena_tag);\n+    }\n+    if (sum > 0) { \/\/ omit phases that did not contribute to allocation load\n+      if (!header_printed) {\n+        st->print(\"%-24s %10s\", \"Phase\", \"Total\");\n+        for (int arena_tag = 0; arena_tag < arena_tag_max; arena_tag++) {\n+          st->print(\"%10s\", Arena::tag_name[arena_tag]);\n+        }\n+        st->cr();\n+        header_printed = true;\n+      }\n+      st->print(\"%-24s \", phase_trc_id_to_string(phase_trc_id));\n+      st->print(\"%10zu\", sum);\n+      for (int arena_tag = 0; arena_tag < arena_tag_max; arena_tag++) {\n+        const size_t v = at(phase_trc_id, arena_tag);\n+        st->print(\"%10zu\", v);\n+      }\n+      st->cr();\n+    }\n+  }\n+}\n+\n+\/\/ When reporting phase footprint movements, if phase-local peak over start as well over end\n+\/\/ was larger than this threshold, we report it.\n+static constexpr size_t significant_peak_threshold = M;\n+\n+FootprintTimeline::FootprintTimeline() {\n+  DEBUG_ONLY(_inbetween_phases = true;)\n+}\n+\n+void FootprintTimeline::copy_from(const FootprintTimeline& other) {\n+  _fifo.copy_from(other._fifo);\n+  DEBUG_ONLY(_inbetween_phases = other._inbetween_phases;)\n+}\n+\n+void FootprintTimeline::print_on(outputStream* st) const {\n+  const int start_indent = st->indentation();\n+  if (!_fifo.empty()) {\n+               \/\/ .123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789\n+    st->print_cr(\"Phase seq. number                             Bytes                  Nodes\");\n+    unsigned from = 0;\n+    if (_fifo.lost() > 0) {\n+      st->print_cr(\"         (\" UINT64_FORMAT \" older entries lost)\", _fifo.lost());\n+    }\n+    int last_level = 0;\n+    int last_num = 0; \/\/ see if we are regressing\n+    auto printer = [&](const Entry& e) {\n+      int col = start_indent;\n+      check_phase_trace_id(e.info.id);\n+      st->print(\"%*s\", e.level,\n+          ((e.level < last_level) ? \"<\" : ((e.level > last_level) ? \">\" : \" \"))\n+      );\n+      last_level = e.level;\n+      st->print(\"%d \", e.info.num);\n+      if (e.info.num < last_num) {\n+        st->print(\"(cont.) \");\n+      }\n+      last_num = e.info.num;\n+      col += 15; st->fill_to(col);\n+      st->print(\"%24s\", e.info.text);\n+      col += 25; st->fill_to(col);\n+      char tmp[64];\n+      os::snprintf(tmp, sizeof(tmp), \"%9zu (%+zd)\", e._bytes.cur, e._bytes.end_delta());\n+      st->print(\"%s \", tmp); \/\/ end\n+      col += 21; st->fill_to(col);\n+      os::snprintf(tmp, sizeof(tmp), \"%6u (%+d)\", e._live_nodes.cur, e._live_nodes.end_delta());\n+      st->print(\"%s \", tmp); \/\/ end\n+      if (e._bytes.temporary_peak_size() > significant_peak_threshold) {\n+        col += 20; st->fill_to(col);\n+        st->print(\" significant temporary peak: %zu (%+zd)\", e._bytes.peak, (ssize_t)e._bytes.peak - e._bytes.start); \/\/ peak\n+      }\n+      st->cr();\n+    };\n+    _fifo.iterate_all(printer);\n+  }\n+}\n+\n+void FootprintTimeline::on_phase_end(size_t cur_abs, unsigned cur_nodes) {\n+  const Entry& old = _fifo.current();\n+\n+  \/\/ One last counter update in old phase:\n+  \/\/ We see all allocations, so cur_abs given should correspond to our topmost cur.\n+  \/\/ But the same does not hold for nodes, since we only get updated when node allocation\n+  \/\/ would cause a new arena chunk to be born. Node allocations that don't cause arena\n+  \/\/ chunks (the vast majority) fly by us.\n+  assert(old._bytes.cur == cur_abs, \"miscount\");\n+  on_footprint_change(cur_abs, cur_nodes);\n+\n+  \/\/ Close old, open new entry\n+  _fifo.advance();\n+\n+  DEBUG_ONLY(_inbetween_phases = true;)\n@@ -57,10 +193,26 @@\n-void ArenaStatCounter::reset() {\n-  _current = 0;\n-  _peak = 0;\n-  _current_by_tag.clear();\n-  _peak_by_tag.clear();\n-  _limit = 0;\n-  _hit_limit = false;\n-  _limit_in_process = false;\n-  _live_nodes_at_peak = 0;\n-  _active = false;\n+void FootprintTimeline::on_phase_start(PhaseInfo info, size_t cur_abs, unsigned cur_nodes, int level) {\n+  if (!_fifo.empty() && _fifo.last().info.id == info.id && _fifo.last().level == level) {\n+    \/\/ Two phases with the same id are collapsed if they were not interleaved by another phase\n+    _fifo.revert();\n+    \/\/ We now just continue bookkeeping into the last entry\n+  } else {\n+    \/\/ seed current entry\n+    Entry& e = _fifo.current();\n+    e._bytes.init(cur_abs);\n+    e._live_nodes.init(cur_nodes);\n+    e.info = info;\n+    e.level = level;\n+  }\n+  DEBUG_ONLY(_inbetween_phases = false;)\n+}\n+\n+FullMethodName::FullMethodName() : _k(nullptr), _m(nullptr), _s(nullptr) {}\n+\n+FullMethodName::FullMethodName(const Method* m) :\n+  _k(m->klass_name()), _m(m->name()), _s(m->signature()) {};\n+\n+FullMethodName::FullMethodName(const FullMethodName& o) : _k(o._k), _m(o._m), _s(o._s) {}\n+\n+FullMethodName& FullMethodName::operator=(const FullMethodName& o) {\n+  _k = o._k; _m = o._m; _s = o._s;\n+  return *this;\n@@ -69,4 +221,4 @@\n-void ArenaStatCounter::start(size_t limit) {\n-  reset();\n-  _active = true;\n-  _limit = limit;\n+void FullMethodName::make_permanent() {\n+  _k->make_permanent();\n+  _m->make_permanent();\n+  _s->make_permanent();\n@@ -75,4 +227,8 @@\n-void ArenaStatCounter::end() {\n-  _limit = 0;\n-  _hit_limit = false;\n-  _active = false;\n+void FullMethodName::print_on(outputStream* st) const {\n+  char tmp[1024];\n+  st->print_raw(_k->as_C_string(tmp, sizeof(tmp)));\n+  st->print_raw(\"::\");\n+  st->print_raw(_m->as_C_string(tmp, sizeof(tmp)));\n+  st->put('(');\n+  st->print_raw(_s->as_C_string(tmp, sizeof(tmp)));\n+  st->put(')');\n@@ -81,2 +237,66 @@\n-void ArenaStatCounter::update_c2_node_count() {\n-  assert(_active, \"compilaton has not yet started\");\n+char* FullMethodName::as_C_string(char* buf, size_t len) const {\n+  stringStream ss(buf, len);\n+  print_on(&ss);\n+  return buf;\n+}\n+\n+bool FullMethodName::operator== (const FullMethodName& b) const {\n+  return _k == b._k && _m == b._m && _s == b._s;\n+}\n+\n+#ifdef ASSERT\n+bool FullMethodName::is_test_class() const {\n+  char tmp[1024];\n+  _k->as_C_string(tmp, sizeof(tmp));\n+  return strstr(tmp, \"CompileCommandPrintMemStat\") != nullptr ||\n+         strstr(tmp, \"CompileCommandMemLimit\") != nullptr;\n+}\n+#endif \/\/ ASSERT\n+\n+ArenaStatCounter::ArenaStatCounter(const CompileTask* task, size_t limit) :\n+    _fmn(task->method()),\n+    _should_print_memstat(task->directive()->should_print_memstat()),\n+    _should_crash_on_memlimit(task->directive()->should_crash_at_mem_limit()),\n+    _current(0), _peak(0), _live_nodes_current(0), _live_nodes_at_global_peak(0),\n+    _limit(limit), _hit_limit(false), _limit_in_process(false),\n+    _phase_counter(0), _comp_type(task->compiler()->type()), _comp_id(task->compile_id())\n+    DEBUG_ONLY(COMMA _is_test_class(false))\n+{\n+  _fmn.make_permanent();\n+#ifdef ASSERT\n+  \/\/ If the class name matches the JTreg test class, we are in test mode and\n+  \/\/ will do some test allocations to test the statistic\n+  _is_test_class = _fmn.is_test_class();\n+#endif \/\/ ASSERT\n+}\n+\n+void ArenaStatCounter::on_phase_start(PhaseInfo info) {\n+  \/\/ Update node counter\n+  _live_nodes_current = retrieve_live_node_count();\n+\n+  \/\/ For the timeline, when nesting TracePhase happens, we maintain the illusion of a flat succession of\n+  \/\/ separate phases. Thus, { TracePhase p1; { TracePhase p2; }} will be seen as:\n+  \/\/ P1 starts -> P1 ends -> P2 starts -> P2 ends -> P1 starts -> P1 ends\n+  \/\/ In other words, when a child phase interrupts a parent phase, it \"ends\" the parent phase, which will\n+  \/\/ be \"restarted\" when the child phase ends.\n+  \/\/ This is the only way to get a per-phase timeline that makes any sort of sense.\n+  if (!_phase_info_stack.empty()) {\n+    _timeline.on_phase_end(_current, _live_nodes_current);\n+  }\n+  _phase_info_stack.push(info);\n+  _timeline.on_phase_start(info, _current, _live_nodes_current, _phase_info_stack.depth());\n+}\n+\n+void ArenaStatCounter::on_phase_end() {\n+  PhaseInfo top = _phase_info_stack.top();\n+  _phase_info_stack.pop();\n+  _live_nodes_current = retrieve_live_node_count();\n+  _timeline.on_phase_end(_current, _live_nodes_current);\n+  if (!_phase_info_stack.empty()) {\n+    \/\/ \"restart\" parent phase in timeline\n+    _timeline.on_phase_start(_phase_info_stack.top(), _current, _live_nodes_current, _phase_info_stack.depth());\n+  }\n+}\n+\n+int ArenaStatCounter::retrieve_live_node_count() const {\n+  int result = 0;\n@@ -84,8 +304,6 @@\n-  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n-  const CompileTask* const task = th->task();\n-  if (task != nullptr &&\n-      th->task()->compiler() != nullptr &&\n-      th->task()->compiler()->type() == compiler_c2) {\n-    const Compile* const comp = Compile::current();\n-    if (comp != nullptr) {\n-      _live_nodes_at_peak = comp->live_nodes();\n+  if (_comp_type == compiler_c2) {\n+    \/\/ Update C2 node count\n+    \/\/ Careful, Compile::current() may be NULL in a short time window when Compile itself\n+    \/\/ is still being constructed.\n+    if (Compile::current() != nullptr) {\n+      result = Compile::current()->live_nodes();\n@@ -94,1 +312,2 @@\n-#endif\n+#endif \/\/ COMPILER2\n+  return result;\n@@ -97,3 +316,2 @@\n-\/\/ Account an arena allocation or de-allocation.\n-bool ArenaStatCounter::account(ssize_t delta, int tag) {\n-  assert(_active, \"compilaton has not yet started\");\n+\/\/ Account an arena allocation. Returns true if new peak reached.\n+bool ArenaStatCounter::on_arena_chunk_allocation(size_t size, int arena_tag, uint64_t* stamp) {\n@@ -101,11 +319,12 @@\n-#ifdef ASSERT\n-  \/\/ Note: if this fires, we free more arena memory under the scope of the\n-  \/\/ CompilationMemoryHistoryMark than we allocate. This cannot be since we\n-  \/\/ assume arena allocations in CompilerThread to be stack bound and symmetric.\n-  assert(delta >= 0 || ((ssize_t)_current + delta) >= 0,\n-         \"Negative overflow (d=%zd %zu %zu)\", delta, _current, _peak);\n-#endif\n-  \/\/ Update totals\n-  _current += delta;\n-  _current_by_tag.add(tag, delta);\n-  \/\/ Did we reach a peak?\n+\n+  const size_t old_current = _current;\n+  _current += size;\n+  assert(_current >= old_current, \"Overflow\");\n+\n+  const int phase_trc_id = _phase_info_stack.top().id;\n+  _counters_current.add(size, phase_trc_id, arena_tag);\n+  _live_nodes_current = retrieve_live_node_count();\n+\n+  _timeline.on_footprint_change(_current, _live_nodes_current);\n+\n+  \/\/ Did we reach a global peak?\n@@ -114,4 +333,4 @@\n-    assert(delta > 0, \"Sanity (%zu %zu)\", _current, _peak);\n-    update_c2_node_count();\n-    _peak_by_tag = _current_by_tag;\n-    rc = true;\n+    \/\/ snapshot all current counters\n+    _counters_at_global_peak.copy_from(_counters_current);\n+    \/\/ snapshot live nodes\n+    _live_nodes_at_global_peak = _live_nodes_current;\n@@ -122,0 +341,2 @@\n+    \/\/ report peak back\n+    rc = true;\n@@ -123,0 +344,8 @@\n+\n+  \/\/ calculate arena chunk stamp\n+  chunkstamp_t cs;\n+  cs.tracked = 1;\n+  cs.arena_tag = checked_cast<uint16_t>(arena_tag);\n+  cs.phase_id = checked_cast<uint16_t>(_phase_info_stack.top().id);\n+  *stamp = cs.raw;\n+\n@@ -126,5 +355,57 @@\n-void ArenaStatCounter::print_on(outputStream* st) const {\n-  st->print(\"%zu [\", _peak);\n-  for (int tag = 0; tag < _peak_by_tag.element_count(); tag++) {\n-    if (_peak_by_tag.counter(tag) > 0) {\n-      st->print(\"%s %zu \", _peak_by_tag.tag_name(tag), _peak_by_tag.counter(tag));\n+void ArenaStatCounter::on_arena_chunk_deallocation(size_t size, uint64_t stamp) {\n+  assert(_current >= size, \"Underflow (%zu %zu)\", size, _current);\n+\n+  \/\/ Extract tag and phase id from stamp\n+  chunkstamp_t cs;\n+  cs.raw = stamp;\n+  assert(cs.tracked == 1, \"Sanity\");\n+  const int arena_tag = cs.arena_tag;\n+  assert(arena_tag >= 0 && arena_tag < arena_tag_max, \"Arena Tag OOB (%d)\", arena_tag_max);\n+  const int phase_trc_id(cs.phase_id);\n+  assert(phase_trc_id >= 0 && phase_trc_id < phase_trc_id_max, \"Phase trace id OOB (%d)\", phase_trc_id);\n+\n+  _current -= size;\n+  _counters_current.sub(size, phase_trc_id, arena_tag);\n+  _live_nodes_current = retrieve_live_node_count();\n+  _timeline.on_footprint_change(_current, _live_nodes_current);\n+}\n+\n+\/\/ Used for logging, not for the report table generated with jcmd Compiler.memory\n+void ArenaStatCounter::print_peak_state_on(outputStream* st) const {\n+  st->print(\"Total Usage: %zu \", _peak);\n+  if (_peak > 0) {\n+#ifdef COMPILER2\n+    \/\/ C1: print allocations broken down by arena types\n+    if (_comp_type == CompilerType::compiler_c1) {\n+      st->print(\"[\");\n+      size_t sums[arena_tag_max];\n+      _counters_at_global_peak.summarize(sums);\n+      bool print_comma = false;\n+      for (int i = 0; i < arena_tag_max; i++) {\n+        if (sums[i] > 0) {\n+          if (print_comma) {\n+            st->print_raw(\", \");\n+          }\n+          st->print(\"%s %zu\", Arena::tag_name[i], sums[i]);\n+          print_comma = true;\n+        }\n+      }\n+      st->print_cr(\"]\");\n+    }\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+    \/\/ C2: print counters and timeline on multiple lines, indented\n+    if (_comp_type == CompilerType::compiler_c2) {\n+      streamIndentor si(st, 4);\n+      st->cr();\n+      st->print_cr(\"--- Arena Usage by Arena Type and compilation phase, at arena usage peak of %zu ---\", _peak);\n+      {\n+        streamIndentor si(st, 4);\n+       _counters_at_global_peak.print_on(st);\n+      }\n+      st->print_cr(\"--- Allocation timelime by phase ---\");\n+      {\n+        streamIndentor si(st, 4);\n+        _timeline.print_on(st);\n+      }\n+      st->print_cr(\"---\");\n@@ -132,4 +413,0 @@\n-  }\n-  st->print(\"]\");\n-#ifdef ASSERT\n-  st->print(\" (%zu->%zu)\", _peak, _current);\n@@ -137,0 +414,3 @@\n+  } else {\n+    st->cr();\n+  }\n@@ -139,18 +419,9 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ Backend\n-\n-class FullMethodName {\n-  Symbol* const _k;\n-  Symbol* const _m;\n-  Symbol* const _s;\n-\n-public:\n-\n-  FullMethodName(const Method* m) :\n-    _k(m->klass_name()), _m(m->name()), _s(m->signature()) {};\n-  FullMethodName(const FullMethodName& o) : _k(o._k), _m(o._m), _s(o._s) {}\n-\n-  void make_permanent() {\n-    _k->make_permanent();\n-    _m->make_permanent();\n-    _s->make_permanent();\n+#ifdef ASSERT\n+void ArenaStatCounter::verify() const {\n+  assert(_current <= _peak, \"Sanity\");\n+#ifdef COMPILER2\n+  size_t sum = 0;\n+  for (int phaseid = 0; phaseid < phase_trc_id_max; phaseid++) {\n+    for (int arena_tag = 0; arena_tag < arena_tag_max; arena_tag ++) {\n+      sum += _counters_at_global_peak.at(phaseid, arena_tag);\n+    }\n@@ -158,0 +429,4 @@\n+  assert(sum == _peak, \"per phase counter mismatch - %zu, expected %zu\", sum, _peak);\n+#endif\n+}\n+#endif \/\/ ASSERT\n@@ -159,5 +434,0 @@\n-  static unsigned compute_hash(const FullMethodName& n) {\n-    return Symbol::compute_hash(n._k) ^\n-        Symbol::compute_hash(n._m) ^\n-        Symbol::compute_hash(n._s);\n-  }\n@@ -165,15 +435,1 @@\n-  char* as_C_string(char* buf, size_t len) const {\n-    stringStream ss(buf, len);\n-    ResourceMark rm;\n-    ss.print_raw(_k->as_C_string());\n-    ss.print_raw(\"::\");\n-    ss.print_raw(_m->as_C_string());\n-    ss.put('(');\n-    ss.print_raw(_s->as_C_string());\n-    ss.put(')');\n-    return buf;\n-  }\n-  bool operator== (const FullMethodName& b) const {\n-    return _k == b._k && _m == b._m && _s == b._s;\n-  }\n-};\n+class MemStatEntry : public CHeapObj<mtCompiler> {\n@@ -181,4 +437,3 @@\n-\/\/ Note: not mtCompiler since we don't want to change what we measure\n-class MemStatEntry : public CHeapObj<mtInternal> {\n-  const FullMethodName _method;\n-  CompilerType _comptype;\n+  FullMethodName _fmn;\n+  CompilerType _comp_type;\n+  int _comp_id;\n@@ -186,2 +441,0 @@\n-  \/\/ How often this has been recompiled.\n-  int _num_recomp;\n@@ -192,7 +445,3 @@\n-\n-  \/\/ peak usage, bytes, over all arenas\n-  size_t _total;\n-  \/\/ usage per arena tag when total peaked\n-  ArenaCountersByTag _peak_by_tag;\n-  \/\/ number of nodes (c2 only) when total peaked\n-  unsigned _live_nodes_at_peak;\n+  \/\/ true if the compilation hit the limit\n+  bool _hit_limit;\n+  \/\/ result as reported by compiler\n@@ -201,0 +450,16 @@\n+  \/\/ Bytes total at global peak\n+  size_t _peak;\n+  \/\/ Bytes per arena tag.\n+  size_t _peak_composition_per_arena_tag[arena_tag_max];\n+  \/\/ Number of live nodes at global peak (C2 only)\n+  unsigned _live_nodes_at_global_peak;\n+\n+  struct Details {\n+    ArenaCounterTable counters_at_global_peak;\n+    FootprintTimeline timeline;\n+  };\n+\n+  Details* _detail_stats;\n+\n+  MemStatEntry(const MemStatEntry& e); \/\/ deny\n+\n@@ -203,6 +468,5 @@\n-  MemStatEntry(FullMethodName method)\n-    : _method(method), _comptype(compiler_c1),\n-      _time(0), _num_recomp(0), _thread(nullptr), _limit(0),\n-      _total(0), _live_nodes_at_peak(0),\n-      _result(nullptr) {\n-    _peak_by_tag.clear();\n+  MemStatEntry()\n+    : _comp_type(compiler_none), _comp_id(-1),\n+      _time(0), _thread(nullptr), _limit(0), _hit_limit(false),\n+      _result(nullptr), _peak(0), _live_nodes_at_global_peak(0),\n+      _detail_stats(nullptr) {\n@@ -211,1 +475,6 @@\n-  void set_comptype(CompilerType comptype) { _comptype = comptype; }\n+  ~MemStatEntry() {\n+    clean_details();\n+  }\n+\n+  void set_comp_id(int comp_id) { _comp_id = comp_id; }\n+  void set_comptype(CompilerType comptype) { _comp_type = comptype; }\n@@ -215,1 +484,0 @@\n-  void inc_recompilation() { _num_recomp++; }\n@@ -217,3 +485,18 @@\n-  void set_total(size_t n) { _total = n; }\n-  void set_peak_by_tag(ArenaCountersByTag peak_by_tag) { _peak_by_tag = peak_by_tag; }\n-  void set_live_nodes_at_peak(unsigned n) { _live_nodes_at_peak = n; }\n+  void set_from_state(const ArenaStatCounter* state, bool store_details) {\n+    _fmn = state->fmn();\n+    _comp_type = state->comp_type();\n+    _comp_id = state->comp_id();\n+    _limit = state->limit();\n+    _hit_limit = state->hit_limit();\n+    _peak = state->peak();\n+    _live_nodes_at_global_peak = state->live_nodes_at_global_peak();\n+    state->counters_at_global_peak().summarize(_peak_composition_per_arena_tag);\n+#ifdef COMPILER2\n+    assert(_detail_stats == nullptr, \"should have been cleaned\");\n+    if (store_details) {\n+      _detail_stats = NEW_C_HEAP_OBJ(Details, mtCompiler);\n+      _detail_stats->counters_at_global_peak.copy_from(state->counters_at_global_peak());\n+      _detail_stats->timeline.copy_from(state->timeline());\n+    }\n+#endif \/\/ COMPILER2\n+  }\n@@ -221,1 +504,15 @@\n-  void set_result(const char* s) { _result = s; }\n+  void clean_details() {\n+    if (_detail_stats != nullptr) {\n+      FREE_C_HEAP_ARRAY(Details, _detail_stats);\n+      _detail_stats = nullptr;\n+    }\n+  }\n+\n+  void reset() {\n+    clean_details();\n+    _comp_type = CompilerType::compiler_none;\n+    _comp_id = -1;\n+    _limit = _peak = 0;\n+    _live_nodes_at_global_peak = 0;\n+    memset(_peak_composition_per_arena_tag, 0, sizeof(_peak_composition_per_arena_tag));\n+  }\n@@ -223,1 +520,5 @@\n-  size_t total() const { return _total; }\n+  void set_result(const char* s)  { _result = s; }\n+\n+  size_t peak() const { return _peak; }\n+  bool is_c1() const { return _comp_type == CompilerType::compiler_c1; }\n+  bool is_c2() const { return _comp_type == CompilerType::compiler_c2; }\n@@ -228,2 +529,3 @@\n-    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"total\", \"memory allocated via arenas while compiling\");\n-    for (int tag = 0; tag < Arena::tag_count(); tag++) {\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"ctype\", \"compiler type\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"total\", \"peak memory allocated via arenas while compiling\");\n+    for (int tag = 0; tag < arena_tag_max; tag++) {\n@@ -232,1 +534,0 @@\n-    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"result\", \"Result: 'ok' finished successfully, 'oom' hit memory limit, 'err' compilation failed\");\n@@ -234,4 +535,4 @@\n-    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"limit\", \"memory limit, if set\");\n-    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"time\", \"time taken for last compilation (sec)\");\n-    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"type\", \"compiler type\");\n-    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"#rc\", \"how often recompiled\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"result\", \"Result reported by compiler\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"limit\", \"memory limit; followed by \\\"*\\\" if the limit was hit\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"time\", \"timestamp\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"id\", \"compile id\");\n@@ -243,0 +544,2 @@\n+    st->print(\"%-6s\", \"ctyp\");\n+\n@@ -245,1 +548,1 @@\n-    for (int tag = 0; tag < Arena::tag_count(); tag++) {\n+    for (int tag = 0; tag < arena_tag_max; tag++) {\n@@ -248,2 +551,2 @@\n-#define HDR_FMT1 \"%-8s%-8s%-8s%-8s\"\n-#define HDR_FMT2 \"%-6s%-4s%-19s%s\"\n+#define HDR_FMT1 \"%-8s%-8s%-10s%-8s\"\n+#define HDR_FMT2 \"%-6s%-19s%s\"\n@@ -251,3 +554,2 @@\n-    st->print(HDR_FMT1, \"result\", \"#nodes\", \"limit\", \"time\");\n-    st->print(HDR_FMT2, \"type\", \"#rc\", \"thread\", \"method\");\n-    st->print_cr(\"\");\n+    st->print(HDR_FMT1, \"#nodes\", \"result\", \"limit\", \"time\");\n+    st->print(HDR_FMT2, \"id\", \"thread\", \"method\");\n@@ -256,2 +558,6 @@\n-  void print_on(outputStream* st, bool human_readable) const {\n-    int col = 0;\n+  void print_brief_oneline(outputStream* st) const {\n+    int col = st->indentation();\n+\n+    \/\/ Type\n+    st->print(\"%2s \", compilertype2name(_comp_type));\n+    col += 6; st->fill_to(col);\n@@ -260,5 +566,2 @@\n-    if (human_readable) {\n-      st->print(PROPERFMT \" \", PROPERFMTARGS(_total));\n-    } else {\n-      st->print(\"%zu \", _total);\n-    }\n+    size_t v = _peak;\n+    st->print(\"%zu \", v);\n@@ -267,6 +570,3 @@\n-    for (int tag = 0; tag < Arena::tag_count(); tag++) {\n-      if (human_readable) {\n-        st->print(PROPERFMT \" \", PROPERFMTARGS(_peak_by_tag.counter(tag)));\n-      } else {\n-        st->print(\"%zu \", _peak_by_tag.counter(tag));\n-      }\n+    for (int tag = 0; tag < arena_tag_max; tag++) {\n+      v = _peak_composition_per_arena_tag[tag];\n+      st->print(\"%zu \", v);\n@@ -276,4 +576,0 @@\n-    \/\/ result?\n-    st->print(\"%s \", _result ? _result : \"\");\n-    col += 8; st->fill_to(col);\n-\n@@ -281,2 +577,2 @@\n-    if (_live_nodes_at_peak > 0) {\n-      st->print(\"%u \", _live_nodes_at_peak);\n+    if (_live_nodes_at_global_peak > 0) {\n+      st->print(\"%u \", _live_nodes_at_global_peak);\n@@ -288,0 +584,4 @@\n+    \/\/ result?\n+    st->print(\"%s \", _result ? _result : \"\");\n+    col += 8; st->fill_to(col);\n+\n@@ -290,1 +590,1 @@\n-      st->print(PROPERFMT \" \", PROPERFMTARGS(_limit));\n+      st->print(\"%zu%s \", _limit, _hit_limit ? \"*\" : \"\");\n@@ -294,1 +594,1 @@\n-    col += 8; st->fill_to(col);\n+    col += 10; st->fill_to(col);\n@@ -300,2 +600,2 @@\n-    \/\/ Type\n-    st->print(\"%s \", compilertype2name(_comptype));\n+    \/\/ Compile ID\n+    st->print(\"%d \", _comp_id);\n@@ -304,4 +604,0 @@\n-    \/\/ Recomp\n-    st->print(\"%u \", _num_recomp);\n-    col += 4; st->fill_to(col);\n-\n@@ -313,1 +609,2 @@\n-    st->print(\"%s \", _method.as_C_string(buf, sizeof(buf)));\n+    st->print(\"%s \", _fmn.as_C_string(buf, sizeof(buf)));\n+\n@@ -317,4 +614,43 @@\n-  int compare_by_size(const MemStatEntry* b) const {\n-    const size_t x1 = b->_total;\n-    const size_t x2 = _total;\n-    return x1 < x2 ? -1 : x1 == x2 ? 0 : 1;\n+  void print_detailed(outputStream* st) const {\n+    int col = 0;\n+\n+    constexpr int indent1 = 40;\n+    constexpr int indent2 = 50;\n+\n+    char buf[1024];\n+    st->print_cr(\"Method              : %s\", _fmn.as_C_string(buf, sizeof(buf)));\n+    st->print_cr(\"Compiler            : %2s\", compilertype2name(_comp_type));\n+    st->print(   \"Arena Usage at peak : %zu\", _peak);\n+    if (_peak > M) {\n+      st->print(\" (%.2fM)\", ((double)_peak\/(double)M));\n+    }\n+    st->cr();\n+    if (_comp_type == CompilerType::compiler_c2) {\n+      st->print_cr(\"Nodes at peak       : %u\", _live_nodes_at_global_peak);\n+    }\n+    st->print_cr(\"Compile ID          : %d\", _comp_id);\n+    st->print(   \"Result              : %s\", _result);\n+    if (strcmp(_result, \"oom\") == 0) {\n+      st->print(\" (memory limit was: %zu)\", _limit);\n+    }\n+    st->cr();\n+    st->print_cr(\"Thread              : \" PTR_FORMAT, p2i(_thread));\n+    st->print_cr(\"Timestamp           : %.3f\", _time);\n+\n+    if (_detail_stats != nullptr) {\n+      st->cr();\n+      st->print_cr(\"Arena Usage by Arena Type and compilation phase, at arena usage peak of %zu:\", _peak);\n+      _detail_stats->counters_at_global_peak.print_on(st);\n+      st->cr();\n+      st->print_cr(\"Allocation timelime by phase:\");\n+      _detail_stats->timeline.print_on(st);\n+    } else {\n+      st->cr();\n+      st->print_cr(\"Arena Usage by Arena Type, at arena usage peak of %zu:\", _peak);\n+      for (int tag = 0; tag < arena_tag_max; tag++) {\n+        const size_t v = _peak_composition_per_arena_tag[tag];\n+        if (v > 0) {\n+          st->print_cr(\"%-36s: %zu \", Arena::tag_desc[tag], v);\n+        }\n+      }\n+    }\n@@ -324,6 +660,1 @@\n-\/\/ The MemStatTable contains records of memory usage of all compilations. It is printed,\n-\/\/ as memory summary, either with jcmd Compiler.memory, or - if the \"print\" suboption has\n-\/\/ been given with the MemStat compile command - as summary printout at VM exit.\n-\/\/ For any given compiled method, we only keep the memory statistics of the most recent\n-\/\/ compilation, but on a per-compiler basis. If one needs statistics of prior compilations,\n-\/\/ one needs to look into the log produced by the \"print\" suboption.\n+class MemStatStore : public CHeapObj<mtCompiler> {\n@@ -331,10 +662,23 @@\n-class MemStatTableKey {\n-  const FullMethodName _fmn;\n-  const CompilerType _comptype;\n-public:\n-  MemStatTableKey(FullMethodName fmn, CompilerType comptype) :\n-    _fmn(fmn), _comptype(comptype) {}\n-  MemStatTableKey(const MemStatTableKey& o) :\n-    _fmn(o._fmn), _comptype(o._comptype) {}\n-  bool operator== (const MemStatTableKey& other) const {\n-    return _fmn == other._fmn && _comptype == other._comptype;\n+  \/\/ Total number of entries. Reaching this limit, we discard the least interesting (smallest allocation size) first.\n+  static constexpr int max_entries = 64;\n+\n+  struct {\n+    size_t s; MemStatEntry* e;\n+  } _entries[max_entries];\n+\n+  struct iteration_result { unsigned num, num_c1, num_c2, num_filtered_out; };\n+  template<typename F>\n+  void iterate_sorted_filtered(F f, size_t minsize, int max_num_printed, iteration_result& result) const {\n+    assert_lock_strong(NMTCompilationCostHistory_lock);\n+    const unsigned stop_after = max_num_printed == -1 ? UINT_MAX : (unsigned)max_num_printed;\n+    result.num = result.num_c1 = result.num_c2 = result.num_filtered_out = 0;\n+    for (int i = 0; _entries[i].e != nullptr && i < max_entries && result.num < stop_after; i++) {\n+      if (_entries[i].s >= minsize) {\n+        f(_entries[i].e);\n+        result.num++;\n+        result.num_c1 += _entries[i].e->is_c1() ? 1 : 0;\n+        result.num_c2 += _entries[i].e->is_c2() ? 1 : 0;\n+      } else {\n+        result.num_filtered_out++;\n+      }\n+    }\n@@ -342,2 +686,10 @@\n-  static unsigned compute_hash(const MemStatTableKey& n) {\n-    return FullMethodName::compute_hash(n._fmn) + (unsigned)n._comptype;\n+\n+  void print_footer(outputStream* st, size_t minsize, const iteration_result& result) const {\n+    if (result.num > 0) {\n+      st->print_cr(\"Total: %u (C1: %u, C2: %u)\", result.num, result.num_c1, result.num_c2);\n+    } else {\n+      st->print_cr(\"No entries.\");\n+    }\n+    if (result.num_filtered_out > 0) {\n+      st->print_cr(\" (%d compilations smaller than %zu omitted)\", result.num_filtered_out, minsize);\n+    }\n@@ -345,1 +697,0 @@\n-};\n@@ -347,4 +698,0 @@\n-class MemStatTable :\n-    public ResourceHashtable<MemStatTableKey, MemStatEntry*, 7919, AnyObj::C_HEAP,\n-                             mtInternal, MemStatTableKey::compute_hash>\n-{\n@@ -353,14 +700,15 @@\n-  void add(const FullMethodName& fmn, CompilerType comptype,\n-           size_t total, ArenaCountersByTag peak_by_tag,\n-           unsigned live_nodes_at_peak, size_t limit, const char* result) {\n-    assert_lock_strong(NMTCompilationCostHistory_lock);\n-    MemStatTableKey key(fmn, comptype);\n-    MemStatEntry** pe = get(key);\n-    MemStatEntry* e = nullptr;\n-    if (pe == nullptr) {\n-      e = new MemStatEntry(fmn);\n-      put(key, e);\n-    } else {\n-      \/\/ Update existing entry\n-      e = *pe;\n-      assert(e != nullptr, \"Sanity\");\n+  MemStatStore() {\n+    memset(_entries, 0, sizeof(_entries));\n+  }\n+\n+  void add(const ArenaStatCounter* state, const char* result) {\n+\n+    const size_t size = state->peak();\n+\n+    \/\/ search insert point\n+    int i = 0;\n+    while (i < max_entries && _entries[i].s > size) {\n+      i++;\n+    }\n+    if (i == max_entries) {\n+      return;\n@@ -368,0 +716,7 @@\n+    MemStatEntry* e = _entries[max_entries - 1].e; \/\/ recycle last one\n+    if (e == nullptr) {\n+      e = new MemStatEntry();\n+    }\n+    memmove(_entries + i + 1, _entries + i, sizeof(_entries[0]) * (max_entries - i - 1));\n+\n+    e->reset();\n@@ -370,6 +725,0 @@\n-    e->set_comptype(comptype);\n-    e->inc_recompilation();\n-    e->set_total(total);\n-    e->set_peak_by_tag(peak_by_tag);\n-    e->set_live_nodes_at_peak(live_nodes_at_peak);\n-    e->set_limit(limit);\n@@ -377,0 +726,7 @@\n+\n+    \/\/ Since we don't have phases in C1, for now we just avoid saving details for C1.\n+    const bool save_details = state->comp_type() == CompilerType::compiler_c2;\n+    e->set_from_state(state, save_details);\n+\n+    _entries[i].s = e->peak();\n+    _entries[i].e = e;\n@@ -379,3 +735,1 @@\n-  \/\/ Returns a C-heap-allocated SortMe array containing all entries from the table,\n-  \/\/ optionally filtered by entry size\n-  MemStatEntry** calc_flat_array(int& num, size_t min_size) {\n+  void print_table(outputStream* st, bool legend, size_t minsize, int max_num_printed) const {\n@@ -384,15 +738,3 @@\n-    const int num_all = number_of_entries();\n-    MemStatEntry** flat = NEW_C_HEAP_ARRAY(MemStatEntry*, num_all, mtInternal);\n-    int i = 0;\n-    auto do_f = [&] (const MemStatTableKey& ignored, MemStatEntry* e) {\n-      if (e->total() >= min_size) {\n-        flat[i] = e;\n-        assert(i < num_all, \"Sanity\");\n-        i ++;\n-      }\n-    };\n-    iterate_all(do_f);\n-    if (min_size == 0) {\n-      assert(i == num_all, \"Sanity\");\n-    } else {\n-      assert(i <= num_all, \"Sanity\");\n+    if (legend) {\n+      MemStatEntry::print_legend(st);\n+      st->cr();\n@@ -400,2 +742,22 @@\n-    num = i;\n-    return flat;\n+\n+    MemStatEntry::print_header(st);\n+    st->cr();\n+\n+    iteration_result itres;\n+    auto printer = [&](const MemStatEntry* e) {\n+      e->print_brief_oneline(st);\n+    };\n+    iterate_sorted_filtered(printer, minsize, max_num_printed, itres);\n+    print_footer(st, minsize, itres);\n+  }\n+\n+  void print_details(outputStream* st, size_t minsize, int max_num_printed) const {\n+    assert_lock_strong(NMTCompilationCostHistory_lock);\n+    iteration_result itres;\n+    auto printer = [&](const MemStatEntry* e) {\n+      e->print_detailed(st);\n+      st->cr();\n+      st->print_cr(\"------------------------\");\n+      st->cr();\n+    };\n+    iterate_sorted_filtered(printer, minsize, max_num_printed, itres);\n@@ -406,2 +768,1 @@\n-\n-static MemStatTable* _the_table = nullptr;\n+static MemStatStore* _the_store = nullptr;\n@@ -410,2 +771,2 @@\n-  assert(_enabled == false && _the_table == nullptr, \"Only once\");\n-  _the_table = new (mtCompiler) MemStatTable;\n+  assert(_enabled == false && _the_store == nullptr, \"Only once\");\n+  _the_store = new MemStatStore;\n@@ -418,0 +779,3 @@\n+  assert(directive->should_collect_memstat(), \"Don't call if not needed\");\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  CompileTask* const task = th->task();\n@@ -419,1 +783,10 @@\n-  Thread::current()->as_Compiler_thread()->arena_stat()->start(limit);\n+  \/\/ Create new ArenaStat object and hook it into the thread\n+  assert(th->arena_stat() == nullptr, \"Sanity\");\n+  ArenaStatCounter* const arena_stat = new ArenaStatCounter(task, limit);\n+  th->set_arenastat(arena_stat);\n+  \/\/ Start a \"root\" phase\n+  PhaseInfo info;\n+  info.id = phase_trc_id_none;\n+  info.num = 0;\n+  info.text = \"(outside)\";\n+  arena_stat->on_phase_start(info);\n@@ -424,1 +797,0 @@\n-  ResourceMark rm;\n@@ -427,0 +799,11 @@\n+  if (arena_stat == nullptr) { \/\/ not started\n+    return;\n+  }\n+\n+  \/\/ Mark end of compilation by clearing out the arena state object in the CompilerThread.\n+  \/\/ Do this before the final \"phase end\".\n+  th->set_arenastat(nullptr);\n+\n+  \/\/ End final outer phase.\n+  arena_stat->on_phase_end();\n+\n@@ -428,1 +811,1 @@\n-  const CompilerType ct = task->compiler()->type();\n+  assert(task->compile_id() == arena_stat->comp_id(), \"Different compilation?\");\n@@ -431,2 +814,0 @@\n-  FullMethodName fmn(m);\n-  fmn.make_permanent();\n@@ -441,1 +822,1 @@\n-  \/\/ Store result\n+  \/\/ Store result (ok, failed, oom...)\n@@ -456,8 +837,2 @@\n-    assert(_the_table != nullptr, \"not initialized\");\n-\n-    _the_table->add(fmn, ct,\n-                    arena_stat->peak(), \/\/ total\n-                    arena_stat->peak_by_tag(),\n-                    arena_stat->live_nodes_at_peak(),\n-                    arena_stat->limit(),\n-                    result);\n+    assert(_the_store != nullptr, \"not initialized\");\n+    _the_store->add(arena_stat, result);\n@@ -465,0 +840,1 @@\n+\n@@ -466,5 +842,8 @@\n-    char buf[1024];\n-    fmn.as_C_string(buf, sizeof(buf));\n-    tty->print(\"%s Arena usage %s: \", compilertype2name(ct), buf);\n-    arena_stat->print_on(tty);\n-    tty->cr();\n+    \/\/ Pre-assemble string to prevent tearing\n+    stringStream ss;\n+    StreamAutoIndentor sai(&ss);\n+    ss.print(\"%s (%d) (%s) Arena usage \", compilertype2name(arena_stat->comp_type()), arena_stat->comp_id(), result);\n+    arena_stat->fmn().print_on(&ss);\n+    ss.print_raw(\": \");\n+    arena_stat->print_peak_state_on(&ss);\n+    tty->print_raw(ss.base());\n@@ -473,1 +852,1 @@\n-  arena_stat->end(); \/\/ reset things\n+  delete arena_stat;\n@@ -511,1 +890,2 @@\n-void CompilationMemoryStatistic::on_arena_change(ssize_t diff, const Arena* arena) {\n+void CompilationMemoryStatistic::on_arena_chunk_allocation(size_t size, int arena_tag, uint64_t* stamp) {\n+\n@@ -513,1 +893,1 @@\n-  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  assert(arena_tag >= 0 && arena_tag < arena_tag_max, \"Arena Tag OOB (%d)\", arena_tag_max);\n@@ -515,0 +895,1 @@\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n@@ -516,2 +897,3 @@\n-  if (arena_stat->limit_in_process()) {\n-    return; \/\/ avoid recursion on limit hit\n+  if (arena_stat == nullptr ||           \/\/ not started\n+      arena_stat->limit_in_process()) {  \/\/ limit handling in process, prevent recursion\n+    return;\n@@ -520,1 +902,2 @@\n-  bool hit_limit_before = arena_stat->hit_limit();\n+  \/\/ Compiler can be slow to bailout, so we may hit memlimit more than once\n+  const bool hit_limit_before = arena_stat->hit_limit();\n@@ -522,1 +905,1 @@\n-  if (arena_stat->is_active() && arena_stat->account(diff, (int)arena->get_tag())) { \/\/ new peak?\n+  if (arena_stat->on_arena_chunk_allocation(size, arena_tag, stamp)) { \/\/ new peak?\n@@ -527,4 +910,3 @@\n-      bool print = false;\n-      bool crash = false;\n-      CompilerType ct = compiler_none;\n-\n+      const CompilerType ct = arena_stat->comp_type();\n+      const bool print = arena_stat->should_print_memstat();\n+      const bool crash = arena_stat->should_crash_on_memlimit();\n@@ -532,0 +914,3 @@\n+      arena_stat->fmn().as_C_string(name, sizeof(name));\n+\n+      inform_compilation_about_oom(ct);\n@@ -533,10 +918,6 @@\n-      \/\/ get some more info\n-      const CompileTask* const task = th->task();\n-      if (task != nullptr) {\n-        ct = task->compiler()->type();\n-        const DirectiveSet* directive = task->directive();\n-        print = directive->should_print_memstat();\n-        crash = directive->should_crash_at_mem_limit();\n-        const Method* m = th->task()->method();\n-        if (m != nullptr) {\n-          FullMethodName(m).as_C_string(name, sizeof(name));\n+      if (crash) {\n+        \/\/ Store this ArenaStat. If other threads also run into OOMs, let them sleep.\n+        \/\/ We will never return, so the global store will not contain this info. We will\n+        \/\/ print the stored ArenaStat in hs-err (see print_error_report)\n+        if (Atomic::cmpxchg(&_arenastat_oom_crash, (ArenaStatCounter*) nullptr, arena_stat) != nullptr) {\n+          os::infinite_sleep();\n@@ -546,1 +927,1 @@\n-      char message[1024] = \"\";\n+      stringStream short_msg;\n@@ -548,1 +929,3 @@\n-      \/\/ build up message if we need it later\n+      \/\/ We print to tty if either print is enabled or if we are to crash on MemLimit hit.\n+      \/\/ If printing\/crashing are not enabled, we just quietly abort the compilation. The\n+      \/\/ compilation is marked as \"oom\" in the compilation memory result store.\n@@ -550,5 +933,2 @@\n-        stringStream ss(message, sizeof(message));\n-        if (ct != compiler_none && name[0] != '\\0') {\n-          ss.print(\"%s %s: \", compilertype2name(ct), name);\n-        }\n-        ss.print(\"Hit MemLimit %s(limit: %zu now: %zu)\",\n+        short_msg.print(\"%s (%d) %s: \", compilertype2name(ct), arena_stat->comp_id(), name);\n+        short_msg.print(\"Hit MemLimit %s- limit: %zu now: %zu\",\n@@ -557,5 +937,1 @@\n-      }\n-\n-      \/\/ log if needed\n-      if (print) {\n-        tty->print_raw(message);\n+        tty->print_raw(short_msg.base());\n@@ -565,1 +941,0 @@\n-      \/\/ Crash out if needed\n@@ -567,3 +942,11 @@\n-        report_fatal(OOM_HOTSPOT_ARENA, __FILE__, __LINE__, \"%s\", message);\n-      } else {\n-        inform_compilation_about_oom(ct);\n+        \/\/ Before crashing, if C2, end current phase. That causes its info (which is the most important) to\n+        \/\/ be added to the phase timeline.\n+        if (arena_stat->comp_type() == CompilerType::compiler_c2) {\n+          arena_stat->on_phase_end();\n+        }\n+        \/\/ print extended message to tty (mirrors the one that should show up in the hs-err file, just for good measure)\n+        tty->print_cr(\"Details:\");\n+        arena_stat->print_peak_state_on(tty);\n+        tty->cr();\n+        \/\/ abort VM\n+        report_fatal(OOM_HOTSPOT_ARENA, __FILE__, __LINE__, \"%s\", short_msg.base());\n@@ -573,1 +956,1 @@\n-    }\n+    } \/\/ end Limit handling\n@@ -577,5 +960,10 @@\n-static inline ssize_t diff_entries_by_size(const MemStatEntry* e1, const MemStatEntry* e2) {\n-  return e1->compare_by_size(e2);\n-}\n-\n-void CompilationMemoryStatistic::print_all_by_size(outputStream* st, bool human_readable, size_t min_size) {\n+void CompilationMemoryStatistic::on_arena_chunk_deallocation(size_t size, uint64_t stamp) {\n+  assert(enabled(), \"Not enabled?\");\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  ArenaStatCounter* const arena_stat = th->arena_stat();\n+  if (arena_stat == nullptr) { \/\/ not started\n+    return;\n+  }\n+  if (arena_stat->limit_in_process()) {\n+    return; \/\/ avoid recursion on limit hit\n+  }\n@@ -583,1 +971,2 @@\n-  MutexLocker ml(NMTCompilationCostHistory_lock, Mutex::_no_safepoint_check_flag);\n+  arena_stat->on_arena_chunk_deallocation(size, stamp);\n+}\n@@ -585,2 +974,14 @@\n-  st->cr();\n-  st->print_cr(\"Compilation memory statistics\");\n+void CompilationMemoryStatistic::on_phase_start(int phase_trc_id, const char* text) {\n+  assert(enabled(), \"Not enabled?\");\n+  assert(phase_trc_id >= 0 && phase_trc_id < phase_trc_id_max, \"Phase trace id OOB (%d)\", phase_trc_id);\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  ArenaStatCounter* const arena_stat = th->arena_stat();\n+  if (arena_stat == nullptr) { \/\/ not started\n+    return;\n+  }\n+  PhaseInfo info;\n+  info.id = phase_trc_id;\n+  info.num = arena_stat->advance_phase_counter();\n+  info.text = text;\n+  arena_stat->on_phase_start(info);\n+}\n@@ -588,2 +989,5 @@\n-  if (!enabled()) {\n-    st->print_cr(\"(unavailable)\");\n+void CompilationMemoryStatistic::on_phase_end() {\n+  assert(enabled(), \"Not enabled?\");\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  ArenaStatCounter* const arena_stat = th->arena_stat();\n+  if (arena_stat == nullptr) { \/\/ not started\n@@ -592,0 +996,2 @@\n+  arena_stat->on_phase_end();\n+}\n@@ -593,1 +999,11 @@\n-  st->cr();\n+static bool check_before_reporting(outputStream* st) {\n+  if (!CompilationMemoryStatistic::enabled()) {\n+    st->print_cr(\"Compilation memory statistics disabled.\");\n+    return false;\n+  }\n+  if (_the_store == nullptr) {\n+    st->print_cr(\"Compilation memory statistics not yet initialized. \");\n+    return false;\n+  }\n+  return true;\n+}\n@@ -595,2 +1011,3 @@\n-  MemStatEntry::print_legend(st);\n-  st->cr();\n+bool CompilationMemoryStatistic::in_oom_crash() {\n+  return Atomic::load(&_arenastat_oom_crash) != nullptr;\n+}\n@@ -598,2 +1015,3 @@\n-  if (min_size > 0) {\n-    st->print_cr(\" (cutoff: %zu bytes)\", min_size);\n+void CompilationMemoryStatistic::print_error_report(outputStream* st) {\n+  if (!check_before_reporting(st)) {\n+    return;\n@@ -601,1 +1019,15 @@\n-  st->cr();\n+  StreamAutoIndentor sai(tty);\n+  streamIndentor si(tty, 4);\n+  const ArenaStatCounter* const oom_stats = Atomic::load(&_arenastat_oom_crash);\n+  if (oom_stats != nullptr) {\n+    \/\/ we crashed due to a compiler limit hit. Lead with a printout of the offending stats\n+    \/\/ in detail.\n+    st->print_cr(\"Compiler Memory Statistic, hit OOM limit; offending compilation:\");\n+    oom_stats->fmn().print_on(st);\n+    st->cr();\n+    oom_stats->print_peak_state_on(st);\n+    st->cr();\n+  }\n+  st->print_cr(\"Compiler Memory Statistic, 10 most expensive compilations:\");\n+  print_all_by_size(st, false, false, 0, 10);\n+}\n@@ -603,1 +1035,9 @@\n-  MemStatEntry::print_header(st);\n+void CompilationMemoryStatistic::print_final_report(outputStream* st) {\n+  if (!check_before_reporting(st)) {\n+    return;\n+  }\n+  st->print_cr(\"Compiler Memory Statistic, 10 most expensive compilations:\");\n+  StreamAutoIndentor sai(st);\n+  streamIndentor si(st, 4);\n+  print_all_by_size(st, false, false, 0, 10);\n+}\n@@ -605,1 +1045,9 @@\n-  MemStatEntry** filtered = nullptr;\n+void CompilationMemoryStatistic::print_jcmd_report(outputStream* st, bool verbose, bool legend, size_t minsize) {\n+  if (!check_before_reporting(st)) {\n+    return;\n+  }\n+  st->print_cr(\"Compiler Memory Statistic\");\n+  StreamAutoIndentor sai(st);\n+  streamIndentor si(st, 4);\n+  print_all_by_size(st, verbose, legend, minsize, -1);\n+}\n@@ -607,16 +1055,4 @@\n-  if (_the_table != nullptr) {\n-    \/\/ We sort with quicksort\n-    int num = 0;\n-    filtered = _the_table->calc_flat_array(num, min_size);\n-    if (min_size > 0) {\n-      st->print_cr(\"(%d\/%d)\", num, _the_table->number_of_entries());\n-    }\n-    if (num > 0) {\n-      QuickSort::sort(filtered, num, diff_entries_by_size);\n-      \/\/ Now print. Has to happen under lock protection too, since entries may be changed.\n-      for (int i = 0; i < num; i ++) {\n-        filtered[i]->print_on(st, human_readable);\n-      }\n-    } else {\n-      st->print_cr(\"No entries.\");\n-    }\n+void CompilationMemoryStatistic::print_all_by_size(outputStream* st, bool verbose, bool legend, size_t minsize, int max_num_printed) {\n+  MutexLocker ml(NMTCompilationCostHistory_lock, Mutex::_no_safepoint_check_flag);\n+  if (verbose) {\n+    _the_store->print_details(st, minsize, max_num_printed);\n@@ -624,1 +1060,1 @@\n-    st->print_cr(\"Not initialized.\");\n+    _the_store->print_table(st, legend, minsize, max_num_printed);\n@@ -626,3 +1062,0 @@\n-  st->cr();\n-\n-  FREE_C_HEAP_ARRAY(Entry, filtered);\n@@ -636,0 +1069,37 @@\n+#ifdef ASSERT\n+void CompilationMemoryStatistic::do_test_allocations() {\n+\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  ArenaStatCounter* const arena_stat = th->arena_stat();\n+  if (arena_stat == nullptr || !arena_stat->is_test_class()) { \/\/ not started or not the JTREG test\n+    return;\n+  }\n+  const CompilerType ctyp = th->task()->compiler()->type();\n+\n+  \/\/ Note: all allocations in here need to be tagged as mtCompiler to be recognized\n+  \/\/ by the compilation memstat. ResourceArea in a CompilerThread is already tagged\n+  \/\/ mtCompiler (special handling for compiler threads).\n+\n+#ifdef COMPILER2\n+  if (ctyp == CompilerType::compiler_c2) {\n+    {\n+      Compile::TracePhase tp(Phase::_t_testPhase1);\n+      Arena ar(MemTag::mtCompiler, Arena::Tag::tag_reglive);\n+      ar.Amalloc(2 * M); \/\/ phase-local peak\n+    }\n+    {\n+      Compile::TracePhase tp(Phase::_t_testPhase2);\n+      NEW_RESOURCE_ARRAY(char, 32 * M); \/\/ leaked (until compilation end)\n+    }\n+  } \/\/ C2\n+#endif \/\/ COMPILER2\n+\n+#ifdef COMPILER1\n+  if (ctyp == CompilerType::compiler_c1) {\n+    NEW_RESOURCE_ARRAY(char, 32 * M); \/\/ leaked (until compilation end)\n+  }\n+#endif \/\/ COMPILER2\n+\n+}\n+#endif \/\/ ASSERT\n+\n@@ -642,0 +1112,1 @@\n+\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":816,"deletions":345,"binary":false,"changes":1161,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc. and\/or its affiliates.\n@@ -29,1 +29,0 @@\n-#include \"compiler\/compilerDefinitions.hpp\"\n@@ -32,1 +31,0 @@\n-#include \"memory\/arena.hpp\"\n@@ -35,2 +33,0 @@\n-class outputStream;\n-class Symbol;\n@@ -38,0 +34,1 @@\n+class outputStream;\n@@ -39,66 +36,3 @@\n-\/\/ Helper class to wrap the array of arena tags for easier processing\n-class ArenaCountersByTag {\n-private:\n-  size_t _counter[Arena::tag_count()];\n-\n-public:\n-  int element_count() const { return Arena::tag_count(); }\n-  const char* tag_name(int tag) const { return Arena::tag_name[tag]; }\n-\n-  size_t  counter(int tag) const {\n-    assert(tag < element_count(), \"invalid tag %d\", tag);\n-    return _counter[tag];\n-  }\n-\n-  void add(int tag, size_t value) {\n-    assert(tag < element_count(), \"invalid tag %d\", tag);\n-    _counter[tag] += value;\n-  }\n-\n-  void clear() {\n-    memset(_counter, 0, sizeof(size_t) * element_count());\n-  }\n-};\n-\n-\/\/ Counters for allocations from arenas during compilation\n-class ArenaStatCounter : public CHeapObj<mtCompiler> {\n-  \/\/ Current bytes, total\n-  size_t _current;\n-  \/\/ bytes at last peak, total\n-  size_t _peak;\n-  \/\/ Current bytes used by arenas per tag\n-  ArenaCountersByTag _current_by_tag;\n-  \/\/ Peak composition:\n-  ArenaCountersByTag _peak_by_tag;\n-  \/\/ MemLimit handling\n-  size_t _limit;\n-  bool _hit_limit;\n-  bool _limit_in_process;\n-\n-  \/\/ When to start accounting\n-  bool _active;\n-\n-  \/\/ Number of live nodes when total peaked (c2 only)\n-  unsigned _live_nodes_at_peak;\n-\n-  void update_c2_node_count();\n-\n-  void reset();\n-\n-public:\n-  ArenaStatCounter();\n-\n-  \/\/ Size of peak since last compilation\n-  size_t peak() const { return _peak; }\n-\n-  \/\/ Peak details\n-  ArenaCountersByTag peak_by_tag() const { return _peak_by_tag; }\n-  unsigned live_nodes_at_peak() const { return _live_nodes_at_peak; }\n-\n-  \/\/ Mark the start and end of a compilation.\n-  void start(size_t limit);\n-  void end();\n-\n-  \/\/ Account an arena allocation or de-allocation.\n-  \/\/ Returns true if new peak reached\n-  bool account(ssize_t delta, int tag);\n+class CompilationMemoryStatistic : public AllStatic {\n+  friend class CompilationMemoryStatisticMark;\n+  static bool _enabled; \/\/ set to true if memstat is active for any method.\n@@ -106,1 +40,2 @@\n-  void set_live_nodes_at_peak(unsigned i) { _live_nodes_at_peak = i; }\n+  \/\/ Private, should only be called via CompilationMemoryStatisticMark\n+  static void on_start_compilation(const DirectiveSet* directive);\n@@ -108,1 +43,2 @@\n-  void print_on(outputStream* st) const;\n+  \/\/ Private, should only be called via CompilationMemoryStatisticMark\n+  static void on_end_compilation();\n@@ -110,6 +46,1 @@\n-  size_t limit() const              { return _limit; }\n-  bool   hit_limit() const          { return _hit_limit; }\n-  bool   limit_in_process() const     { return _limit_in_process; }\n-  void   set_limit_in_process(bool v) { _limit_in_process = v; }\n-  bool   is_active() const          { return _active; }\n-};\n+  static void print_all_by_size(outputStream* st, bool verbose, bool legend, size_t minsize, int max_num_printed);\n@@ -117,2 +48,0 @@\n-class CompilationMemoryStatistic : public AllStatic {\n-  static bool _enabled;\n@@ -123,1 +52,11 @@\n-  static void on_start_compilation(const DirectiveSet* directive);\n+  \/\/ true if we are in a fatal error inited by hitting the MemLimit\n+  static bool in_oom_crash();\n+\n+  static void on_phase_start(int phase_trc_id, const char* text);\n+  static void on_phase_end();\n+  static void on_arena_chunk_allocation(size_t size, int arenatag, uint64_t* stamp);\n+  static void on_arena_chunk_deallocation(size_t size, uint64_t stamp);\n+\n+  static void print_final_report(outputStream* st);\n+  static void print_error_report(outputStream* st);\n+  static void print_jcmd_report(outputStream* st, bool verbose, bool legend, size_t minsize);\n@@ -125,6 +64,0 @@\n-  \/\/ Called at end of compilation. Records the arena usage peak. Also takes over\n-  \/\/ status information from ciEnv (compilation failed, oom'ed or went okay). ciEnv::_failure_reason\n-  \/\/ must be set at this point (so place CompilationMemoryStatisticMark correctly).\n-  static void on_end_compilation();\n-  static void on_arena_change(ssize_t diff, const Arena* arena);\n-  static void print_all_by_size(outputStream* st, bool human_readable, size_t minsize);\n@@ -133,0 +66,2 @@\n+\n+  DEBUG_ONLY(static void do_test_allocations();)\n@@ -136,1 +71,1 @@\n-class CompilationMemoryStatisticMark {\n+class CompilationMemoryStatisticMark : public StackObj {\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.hpp","additions":25,"deletions":90,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -43,1 +42,1 @@\n-  _arena_stat = CompilationMemoryStatistic::enabled() ? new ArenaStatCounter : nullptr;\n+  _arena_stat = nullptr;\n@@ -53,1 +52,2 @@\n-  delete _arena_stat;\n+  \/\/ arenastat should have been deleted at the end of the compilation\n+  assert(_arena_stat == nullptr, \"Should be null\");\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+  void set_arenastat(ArenaStatCounter* v)        { _arena_stat = v; }\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-#define ARENA_TAG_STRING(name, str, desc) XSTR(name),\n+#define ARENA_TAG_STRING(name, desc) XSTR(name),\n@@ -54,1 +54,1 @@\n-#define ARENA_TAG_DESC(name, str, desc) XSTR(desc),\n+#define ARENA_TAG_DESC(name, desc) XSTR(desc),\n@@ -121,1 +121,1 @@\n-  static Chunk* allocate_chunk(size_t length, AllocFailType alloc_failmode);\n+  static Chunk* allocate_chunk(Arena* arena, size_t length, AllocFailType alloc_failmode);\n@@ -125,1 +125,9 @@\n-Chunk* ChunkPool::allocate_chunk(size_t length, AllocFailType alloc_failmode) {\n+static bool on_compiler_thread() {\n+#if defined(COMPILER1) || defined(COMPILER2)\n+  return Thread::current_or_null() != nullptr &&\n+         Thread::current()->is_Compiler_thread();\n+#endif \/\/ COMPILER1 || COMPILER2\n+  return false;\n+}\n+\n+Chunk* ChunkPool::allocate_chunk(Arena* arena, size_t length, AllocFailType alloc_failmode) {\n@@ -167,0 +175,9 @@\n+\n+  if (CompilationMemoryStatistic::enabled() && on_compiler_thread()) {\n+    uint64_t stamp = 0;\n+    CompilationMemoryStatistic::on_arena_chunk_allocation(chunk->length(), (int)arena->get_tag(), &stamp);\n+    chunk->set_stamp(stamp);\n+  } else {\n+    chunk->set_stamp(0);\n+  }\n+\n@@ -171,0 +188,8 @@\n+\n+  \/\/ Inform compilation memstat\n+  if (CompilationMemoryStatistic::enabled() && c->stamp() != 0) {\n+    assert(on_compiler_thread(), \"we stamped this chunk\");\n+    CompilationMemoryStatistic::on_arena_chunk_deallocation(c->length(), c->stamp());\n+    c->set_stamp(0);\n+  }\n+\n@@ -203,2 +228,2 @@\n-Chunk::Chunk(size_t length) : _len(length) {\n-  _next = nullptr;         \/\/ Chain on the linked list\n+Chunk::Chunk(size_t length) :\n+    _next(nullptr), _len(length), _stamp(0) {\n@@ -230,1 +255,1 @@\n-  _chunk = ChunkPool::allocate_chunk(init_size, AllocFailStrategy::EXIT_OOM);\n+  _chunk = ChunkPool::allocate_chunk(this, init_size, AllocFailStrategy::EXIT_OOM);\n@@ -261,6 +286,0 @@\n-    if (CompilationMemoryStatistic::enabled() && _mem_tag == mtCompiler) {\n-      Thread* const t = Thread::current();\n-      if (t != nullptr && t->is_Compiler_thread()) {\n-        CompilationMemoryStatistic::on_arena_change(delta, this);\n-      }\n-    }\n@@ -292,1 +311,1 @@\n-  _chunk = ChunkPool::allocate_chunk(len, alloc_failmode);\n+  _chunk = ChunkPool::allocate_chunk(this, len, alloc_failmode);\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,3 @@\n+  \/\/ Used for Compilation Memory Statistic\n+  uint64_t _stamp;\n+\n@@ -69,1 +72,2 @@\n-    size       = 32*K  - slack  \/\/ Default size of an Arena chunk (following the first)\n+    size       = 32*K  - slack, \/\/ Default size of an Arena chunk (following the first)\n+    max_default_size = size     \/\/ Largest default size\n@@ -84,0 +88,3 @@\n+\n+  void set_stamp(uint64_t v) { _stamp = v; }\n+  uint64_t stamp() const     { return _stamp; }\n@@ -86,0 +93,1 @@\n+\/\/ Arena types (for Compilation Memory Statistic)\n@@ -87,4 +95,9 @@\n-  FN(other, Others, Other arenas) \\\n-  FN(ra, RA, Resource areas) \\\n-  FN(ha, HA, Handle area) \\\n-  FN(node, NA, Node arena) \\\n+  FN(ra,          Resource areas) \\\n+  FN(node,        C2 Node arena) \\\n+  FN(comp,        C2 Compile arena) \\\n+  FN(type,        C2 Type arena) \\\n+  FN(reglive,     C2 Register Allocation Live Arena) \\\n+  FN(regsplit,    C2 Register Allocation Split Arena) \\\n+  FN(cienv,       CI Env Arena) \\\n+  FN(ha,          Handle area) \\\n+  FN(other,       Other arenas) \\\n@@ -96,1 +109,1 @@\n-#define ARENA_TAG_ENUM(name, str, desc) tag_##name,\n+#define ARENA_TAG_ENUM(name, desc) tag_##name,\n@@ -195,0 +208,1 @@\n+  MemTag get_mem_tag() const { return _mem_tag; }\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+  ResourceArea(MemTag mem_tag, Arena::Tag arena_tag) :\n+    Arena(mem_tag, arena_tag) DEBUG_ONLY(COMMA _nesting(0)) {\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -369,2 +369,2 @@\n-  ResourceArea split_arena(mtCompiler);     \/\/ Arena for Split local resources\n-  ResourceArea live_arena(mtCompiler);      \/\/ Arena for liveness & IFG info\n+  ResourceArea split_arena(mtCompiler, Arena::Tag::tag_regsplit);     \/\/ Arena for Split local resources\n+  ResourceArea live_arena(mtCompiler, Arena::Tag::tag_reglive);     \/\/ Arena for liveness & IFG info\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -638,1 +639,1 @@\n-      _comp_arena(mtCompiler),\n+      _comp_arena(mtCompiler, Arena::Tag::tag_comp),\n@@ -915,1 +916,1 @@\n-      _comp_arena(mtCompiler),\n+      _comp_arena(mtCompiler, Arena::Tag::tag_comp),\n@@ -927,2 +928,2 @@\n-      _node_arena_one(mtCompiler),\n-      _node_arena_two(mtCompiler),\n+      _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+      _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n@@ -3013,0 +3014,7 @@\n+#ifdef ASSERT\n+  {\n+    CompilationMemoryStatistic::do_test_allocations();\n+    if (failing()) return;\n+  }\n+#endif\n+\n@@ -4313,0 +4321,1 @@\n+  assert(id != PhaseTraceId::_t_none, \"Don't use none\");\n@@ -4321,0 +4330,5 @@\n+\n+  \/\/ Inform memory statistic, if enabled\n+  if (CompilationMemoryStatistic::enabled()) {\n+    CompilationMemoryStatistic::on_phase_start((int)id, name);\n+  }\n@@ -4327,0 +4341,6 @@\n+\n+  \/\/ Inform memory statistic, if enabled\n+  if (CompilationMemoryStatistic::enabled()) {\n+    CompilationMemoryStatistic::on_phase_end();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,1 +241,1 @@\n-    Compile*    _compile;\n+    Compile* const _compile;\n@@ -243,1 +243,1 @@\n-    bool _dolog;\n+    const bool _dolog;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+class Compile;\n+class ciMethod;\n@@ -68,0 +70,1 @@\n+    f(   _t_none,                    \"none\")                     \\\n@@ -121,1 +124,3 @@\n-    f(   _t_temporaryTimer2,         \"tempTimer2\")\n+    f(   _t_temporaryTimer2,         \"tempTimer2\")               \\\n+    f(   _t_testPhase1,              \"testPhase1\")               \\\n+    f(   _t_testPhase2,              \"testPhase2\")\n","filename":"src\/hotspot\/share\/opto\/phase.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -270,0 +271,1 @@\n+  CompilationMemoryStatisticMark cmsm(directive);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -443,1 +443,1 @@\n-  Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);\n+  Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler, Arena::Tag::tag_type);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1402,0 +1402,3 @@\n+  product(bool, PrintCompilerMemoryStatisticsAtExit, false, DIAGNOSTIC,     \\\n+          \"Print compiler memory statistics upon VM exit.\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -355,2 +355,2 @@\n-  if (CompilerOracle::should_print_final_memstat_report()) {\n-    CompilationMemoryStatistic::print_all_by_size(tty, false, 0);\n+  if (PrintCompilerMemoryStatisticsAtExit || CompilerOracle::should_print_final_memstat_report()) {\n+    CompilationMemoryStatistic::print_final_report(tty);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1148,3 +1148,4 @@\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n-  _minsize(\"-s\", \"Minimum memory size\", \"MEMORY SIZE\", false, \"0\") {\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _verbose(\"verbose\", \"Print detailed information\", \"BOOLEAN\", false, \"false\"),\n+  _legend(\"legend\", \"Table mode: print legend\", \"BOOLEAN\", false, \"false\"),\n+  _minsize(\"minsize\", \"Minimum memory size\", \"MEMORY SIZE\", false, \"0\") {\n+  _dcmdparser.add_dcmd_option(&_verbose);\n@@ -1152,0 +1153,1 @@\n+  _dcmdparser.add_dcmd_option(&_legend);\n@@ -1155,1 +1157,0 @@\n-  const bool human_readable = _human_readable.value();\n@@ -1157,1 +1158,1 @@\n-  CompilationMemoryStatistic::print_all_by_size(output(), human_readable, minsize);\n+  CompilationMemoryStatistic::print_jcmd_report(output(), _verbose.value(), _legend.value(), minsize);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -808,1 +808,2 @@\n-  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<bool> _verbose;\n+  DCmdArgument<bool> _legend;\n@@ -811,1 +812,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 3; }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+#define PROPERFMT_W(width)    \"%\" #width \"zu%s\"\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -215,1 +215,2 @@\n-  if (count < 0)  return;\n+  put(' ', count);\n+}\n@@ -217,0 +218,5 @@\n+void outputStream::put(char ch, int count) {\n+  assert(ch != 0, \"please fix call site\");\n+  if (count < 0)  return;\n+  char tmp[8];\n+  memset(tmp, ch, sizeof(tmp));\n@@ -219,1 +225,1 @@\n-    this->write(\"        \", nw);\n+    this->write(tmp, nw);\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,1 @@\n+   void put(char c, int count);\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -1003,0 +1004,5 @@\n+  if (CompilationMemoryStatistic::enabled() && CompilationMemoryStatistic::in_oom_crash()) {\n+    st->cr();\n+    st->print_cr(\">> Please see below for a detailed breakdown of compiler memory usage.\");\n+    st->cr();\n+  }\n@@ -1263,0 +1269,4 @@\n+  STEP_IF(\"printing compiler memory info, if any\", _verbose)\n+    CompilationMemoryStatistic::print_error_report(st);\n+    st->cr();\n+\n@@ -1439,1 +1449,0 @@\n-\n@@ -1443,0 +1452,3 @@\n+  \/\/ STEP(\"Compiler Memory Statistic\")\n+  CompilationMemoryStatistic::print_final_report(st);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, 2024, Red Hat, Inc. All rights reserved.\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Checks that -XX:CompileCommand=MemLimit,...,crash causes C1 to crash\n+ * @summary Checks that -XX:CompileCommand=MemLimit,...,xx~crash causes C1 to crash\n@@ -30,1 +30,1 @@\n- * @run driver compiler.print.CompileCommandMemLimit crash false\n+ * @run driver compiler.print.CompileCommandMemLimit c1 crash\n@@ -36,1 +36,1 @@\n- * @summary Checks that -XX:CompileCommand=MemLimit,...,crash causes C2 to crash\n+ * @summary Checks that -XX:CompileCommand=MemLimit,...,xx~crash causes C2 to crash\n@@ -38,1 +38,1 @@\n- * @run driver compiler.print.CompileCommandMemLimit crash true\n+ * @run driver compiler.print.CompileCommandMemLimit c2 crash\n@@ -44,1 +44,1 @@\n- * @summary Checks that -XX:CompileCommand=MemLimit,...,stop causes C1 to stop\n+ * @summary Checks that -XX:CompileCommand=MemLimit,...,xx causes C1 to bail out from the compilation\n@@ -46,1 +46,1 @@\n- * @run driver compiler.print.CompileCommandMemLimit stop false\n+ * @run driver compiler.print.CompileCommandMemLimit c1 stop\n@@ -52,1 +52,1 @@\n- * @summary Checks that -XX:CompileCommand=MemLimit,...,stop causes C2 to stop\n+ * @summary Checks that -XX:CompileCommand=MemLimit,...,xx causes C2 to bail out from the compilation\n@@ -54,1 +54,1 @@\n- * @run driver compiler.print.CompileCommandMemLimit stop true\n+ * @run driver compiler.print.CompileCommandMemLimit c2 stop\n@@ -76,2 +76,2 @@\n-    static boolean c2;\n-    static boolean test_crash;\n+    enum TestMode { crash, stop };\n+    enum CompilerType { c1, c2 };\n@@ -80,6 +80,2 @@\n-        switch (args[0]) {\n-            case \"crash\" : test_crash = true; break;\n-            case \"stop\" : test_crash = false; break;\n-            default: throw new RuntimeException(\"invalid argument\");\n-        }\n-        c2 = Boolean.parseBoolean(args[1]);\n+        CompilerType ctyp = CompilerType.valueOf(args[0]);\n+        TestMode mode = TestMode.valueOf(args[1]);\n@@ -95,9 +91,29 @@\n-        options.add(\"-XX:CompileCommand=MemStat,*.*,print\");\n-\n-        \/\/ We limit method 2 to a very small limit that is guaranteed to trigger\n-        options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(METHOD2) + \",4k\" + (test_crash ? \"~crash\" : \"\"));\n-\n-        \/\/ We disable any limit set on method 3\n-        options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(METHOD3) + \",0\");\n-\n-        if (c2) {\n+        options.add(\"-XX:CompileCommand=MemStat,\" + getTestMethod(METHOD2) + \",print\");\n+\n+        String suffix = mode == TestMode.crash ? \"~crash\" : \"\";\n+\n+        \/\/ About the limit:\n+        \/\/\n+        \/\/ In the debug JVM, for this test class, compilers will allocate (near the very end of the compilation)\n+        \/\/ 32MB of arena memory.\n+        \/\/\n+        \/\/ C1 will allocate them in a single step from RA, leaked until end of compilation.\n+        \/\/\n+        \/\/ C2 will allocate them in two steps: first 2MB inside phase \"testPhase1\" in a temporary arena\n+        \/\/ that will be gone by phase end. So, in the phase timeline these 2MB must show up as\n+        \/\/ \"significant temporary peak\".\n+        \/\/ In a second phase \"testPhase2\", we allocate 32MB from resource area, which is leaked until\n+        \/\/ the end of the compilation. This means that these 32MB will show up as permanent memory\n+        \/\/ increase in the per-phase-timeline.\n+        \/\/\n+        \/\/ We then set the limit to 31MB (just shy of the 32MB we allocate), which should reliably trigger the mem limit.\n+        \/\/ The 32MB are deliberately chosen to be large, because this will harden the test against normal allocation fluctuations\n+        \/\/ (the methods are tiny, so compiling them should accrue normally only a few dozen KB).\n+        \/\/\n+        \/\/ In the release JVM, we just use a very tiny memlimit that we are sure to hit every time.\n+\n+        long limit = Platform.isDebugBuild() ? (1024 * 1024 * 31) : 4096;\n+\n+        options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(METHOD2) + \",\" + limit + suffix);\n+\n+        if (ctyp == CompilerType.c2) {\n@@ -108,0 +124,1 @@\n+\n@@ -117,1 +134,1 @@\n-        String ct = c2 ? \"c2\" : \"c1\";\n+        String limitHitRegex = ctyp + \" \\\\(\\\\d+\\\\) compiler\/print\/CompileCommandMemLimit\\\\$TestMain::method2.*: Hit MemLimit - limit: \" + limit + \" now: \\\\d+\";\n@@ -119,1 +136,1 @@\n-        if (test_crash) {\n+        if (mode == TestMode.crash) {\n@@ -124,1 +141,1 @@\n-            oa.shouldMatch(\"# *fatal error: \" + ct + \" *\" + method2regex + \".*: Hit MemLimit .*limit: 4096.*\");\n+            oa.shouldMatch(\"# *fatal error: \" + limitHitRegex);\n@@ -146,7 +163,0 @@\n-            \/\/ In debug builds we have an inbuilt MemLimit. It is very high, so we don't expect it to fire in this test.\n-            \/\/ But it will still show up in the final report.\n-            String implicitMemoryLimit = Platform.isDebugBuild() ? \"1024M\" : \"-\";\n-\n-            \/\/ With C2, we print number of nodes, with C1 we don't\n-            String numberNodesRegex = c2 ? \"\\\\d+\" : \"-\";\n-\n@@ -154,1 +164,4 @@\n-            oa.shouldMatch(ct + \" \" + method2regex + \".*: Hit MemLimit \\\\(limit: 4096 now: \\\\d+\\\\)\");\n+            oa.shouldMatch(limitHitRegex);\n+\n+            \/\/ Compilation should have been aborted and marked as oom\n+            oa.shouldMatch(ctyp + \" \\\\(\\\\d+\\\\) \\\\(oom\\\\) Arena usage \" + method2regex + \".*\\\\d+.*\");\n@@ -159,0 +172,1 @@\n+        }\n@@ -160,15 +174,9 @@\n-            \/\/ Final report:\n-            \/\/ Method 1 should show up as \"ok\" and with the default limit, e.g.\n-            \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n-            \/\/ 32728     0         32728     ok     -       1024M   0.045   c1    1   0x000000011b019c10  compiler\/print\/CompileCommandMemLimit$TestMain::method1(()J)\n-            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +\" + numberNodesRegex + \" +\" + implicitMemoryLimit + \" +.* +\" + method1regex);\n-\n-            \/\/ Method 2 should show up as \"oom\" and with its tiny limit, e.g.\n-            \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n-            \/\/ 32728     0         32728     oom     -       4096B   0.045   c1    1   0x000000011b019c10  compiler\/print\/CompileCommandMemLimit$TestMain::method1(()J)\n-            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +oom +\" + numberNodesRegex + \" +4096B +.* +\" + method2regex);\n-\n-            \/\/ Method 3 should show up as \"ok\", and with no limit, even in debug builds, e.g.\n-            \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n-            \/\/ 32728     0         32728     ok     -       -        0.045   c1    1   0x000000011b019c10  compiler\/print\/CompileCommandMemLimit$TestMain::method1(()J)\n-            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +\" + numberNodesRegex + \" +- +.* +\" + method3regex);\n+        \/\/ In C2, analyze phase timeline and per-phase accumulation\n+        if (ctyp == CompilerType.c2) {\n+            oa.shouldMatch(\"--- Arena Usage by Arena Type and compilation phase, at arena usage peak of \\\\d+ ---\");\n+            oa.shouldContain(\"--- Allocation timelime by phase ---\");\n+            if (Platform.isDebugBuild()) {\n+                oa.shouldMatch(\".*testPhase2 +33554432 +33554432 +0 +0 +0 +0 +0.*\");\n+                oa.shouldMatch(\" +>\\\\d+ +testPhase1.*significant temporary peak: \\\\d+ \\\\(\\\\+2098136\\\\)\");\n+                oa.shouldMatch(\" +>\\\\d+ +testPhase2 +\\\\d+ +\\\\(\\\\+33554432\\\\).*\");\n+            }\n@@ -176,0 +184,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandMemLimit.java","additions":62,"deletions":53,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, 2024, Red Hat, Inc. All rights reserved.\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,3 @@\n- * @test\n- * @summary Checks that -XX:CompileCommand=PrintMemStat,... works\n- * @requires vm.compiler1.enabled | vm.compiler2.enabled\n+ * @test id=c2\n+ * @summary Checks that -XX:CompileCommand=MemStat,...,print works with C2\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n@@ -30,1 +30,9 @@\n- * @run driver compiler.print.CompileCommandPrintMemStat\n+ * @run driver compiler.print.CompileCommandPrintMemStat c2\n+ *\/\n+\n+\/*\n+ * @test id=c1\n+ * @summary Checks that -XX:CompileCommand=MemStat,...,print works with C1\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @library \/test\/lib\n+ * @run driver compiler.print.CompileCommandPrintMemStat c1\n@@ -47,0 +55,4 @@\n+    enum CompType {\n+        c1, c2\n+    }\n+\n@@ -48,2 +60,8 @@\n-        test(METHOD1, METHOD2);\n-        test(METHOD2, METHOD1);\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Missing Args\");\n+        }\n+        CompType ctyp = CompType.valueOf(args[0]);\n+        test(METHOD1, METHOD2, ctyp);\n+        test(METHOD2, METHOD1, ctyp);\n+        test(METHOD1, METHOD2, ctyp);\n+        test(METHOD2, METHOD1, ctyp);\n@@ -52,1 +70,1 @@\n-    private static void test(String include, String exclude) throws Exception {\n+    private static void test(String include, String exclude, CompType ctyp) throws Exception {\n@@ -55,1 +73,0 @@\n-        options.add(\"-XX:-Inline\");\n@@ -57,0 +74,6 @@\n+        options.add(\"-XX:-Inline\");\n+        if (ctyp.equals(CompType.c2)) {\n+            options.add(\"-XX:-TieredCompilation\");\n+        } else {\n+            options.add(\"-XX:TieredStopAtLevel=1\");\n+        }\n@@ -61,0 +84,1 @@\n+        oa.reportDiagnosticSummary();\n@@ -62,1 +86,1 @@\n-        \/\/ We expect two printouts for \"PrintMemStat\". A line at compilation time, and a line in a summary report\n+        \/\/ We expect two printouts for \"MemStat\". A line at compilation time, and a line in a summary report\n@@ -72,4 +96,1 @@\n-        \/\/ Should see trace output when methods are compiled\n-        oa.shouldHaveExitValue(0).\n-                shouldMatch(\"Arena usage.*\" + expectedNameIncl + \".*\").\n-                shouldNotMatch(\"Arena usage.*\" + expectedNameExcl + \".*\");\n+        oa.shouldHaveExitValue(0);\n@@ -77,0 +98,5 @@\n+        if (ctyp == CompType.c1) {\n+            \/\/ Example output for a C1 compilation output:\n+            \/\/ c1 (885) (ok) Arena usage java\/util\/zip\/ZipFile$Source::get((Ljava\/io\/File;ZLjava\/util\/zip\/ZipCoder;)Ljava\/util\/zip\/ZipFile$Source;): 752744 [ra 687288, cienv 65456]\n+            oa.shouldMatch(\"c1.*Arena usage \" + expectedNameIncl + \".*: \\\\d+.*\");\n+        }\n@@ -78,8 +104,20 @@\n-        \/\/ Should see final report\n-        \/\/ Looks like this:\n-        \/\/ total     Others    RA        HA        NA        result  #nodes  limit   time    type  #rc thread             method\n-        \/\/ 523648    32728     490920    0         0         ok      -       -       0.250   c1    1   0x00007f4ec00d4ac0 java\/lang\/Class::descriptorString(()Ljava\/lang\/String;)\n-        \/\/ or\n-        \/\/ 1898600   853176    750872    0         294552    ok      934     -       1.501   c2    1   0x00007f4ec00d3330 java\/lang\/String::replace((CC)Ljava\/lang\/String;)\n-        oa.shouldMatch(\"total.*method\");\n-        oa.shouldMatch(\"\\\\d+ +(\\\\d+ +){4}ok +(\\\\d+|-) +.*\" + expectedNameIncl + \".*\");\n+        \/\/ In C2, analyze phase timeline and per-phase accumulation\n+        if (ctyp == CompType.c2) {\n+            oa.shouldMatch(\"c2.*Arena usage \" + expectedNameIncl + \".*: \\\\d+.*\");\n+            oa.shouldMatch(\"--- Arena Usage by Arena Type and compilation phase, at arena usage peak of \\\\d+ ---\");\n+            oa.shouldContain(\"--- Allocation timelime by phase ---\");\n+            if (Platform.isDebugBuild()) {\n+                oa.shouldMatch(\".*testPhase2 +33554432 +33554432 +0 +0 +0 +0 +0.*\");\n+                oa.shouldMatch(\" +>\\\\d+ +testPhase1.*significant temporary peak: \\\\d+ \\\\(\\\\+2098136\\\\)\");\n+                oa.shouldMatch(\" +>\\\\d+ +testPhase2 +\\\\d+ +\\\\(\\\\+33554432\\\\).*\");\n+            }\n+        }\n+\n+        \/\/ We also print a final report to tty if print is enabled. Looks like this:\n+        \/\/\n+        \/\/ Compilation Memory usage:\n+        \/\/    ctyp  total     ra        node      comp      type      index     reglive   regsplit  cienv     other     #nodes  codesz  result  limit   time    id    thread             method\n+        \/\/    c1    14104176  13776896  0         0         0         0         0         0         327280    0         -       0       oom     10240K  0,547   412   0x00007fb14c1fb640 jdk\/internal\/classfile\/impl\/StackMapGenerator::processBlock((Ljdk\/internal\/classfile\/impl\/RawBytecodeHelper;)Z)\n+        \/\/    c2    5058384   4499056   262808    197352    0         0         0         0         32728     66440     293     1464    ok      10240K  0,200   191   0x00007fb14c1f9bb0 java\/lang\/StringLatin1::lastIndexOf(([BII)I)\n+        oa.shouldMatch(\"\\\\s+ctyp\\\\s+total.*method.*\");\n+        oa.shouldMatch(\"\\\\s+c(1|2)\\\\s+\\\\d+.*\" + expectedNameIncl + \".*\");\n@@ -88,5 +126,3 @@\n-        \/\/ expect to see all methods, not just the one we specified on the command line.\n-        if (Platform.isDebugBuild()) {\n-            oa.shouldMatch(\"\\\\d+ +(\\\\d+ +){4}ok +(\\\\d+|-) +.*\" + expectedNameExcl + \".*\");\n-        } else {\n-            oa.shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+        \/\/ may see the other method also.\n+        if (!Platform.isDebugBuild()) {\n+            oa.shouldNotContain(expectedNameExcl);\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintMemStat.java","additions":64,"deletions":28,"binary":false,"changes":92,"status":"modified"}]}