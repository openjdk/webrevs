{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -92,97 +93,0 @@\n-\n-\/\/\n-\/\/ class GrowableCache - private methods\n-\/\/\n-\n-void GrowableCache::recache() {\n-  int len = _elements->length();\n-\n-  FREE_C_HEAP_ARRAY(address, _cache);\n-  _cache = NEW_C_HEAP_ARRAY(address,len+1, mtInternal);\n-\n-  for (int i=0; i<len; i++) {\n-    _cache[i] = _elements->at(i)->getCacheValue();\n-    \/\/\n-    \/\/ The cache entry has gone bad. Without a valid frame pointer\n-    \/\/ value, the entry is useless so we simply delete it in product\n-    \/\/ mode. The call to remove() will rebuild the cache again\n-    \/\/ without the bad entry.\n-    \/\/\n-    if (_cache[i] == nullptr) {\n-      assert(false, \"cannot recache null elements\");\n-      remove(i);\n-      return;\n-    }\n-  }\n-  _cache[len] = nullptr;\n-\n-  _listener_fun(_this_obj,_cache);\n-}\n-\n-\/\/\n-\/\/ class GrowableCache - public methods\n-\/\/\n-\n-GrowableCache::GrowableCache() {\n-  _this_obj       = nullptr;\n-  _listener_fun   = nullptr;\n-  _elements       = nullptr;\n-  _cache          = nullptr;\n-}\n-\n-GrowableCache::~GrowableCache() {\n-  clear();\n-  delete _elements;\n-  FREE_C_HEAP_ARRAY(address, _cache);\n-}\n-\n-void GrowableCache::initialize(void *this_obj, void listener_fun(void *, address*) ) {\n-  _this_obj       = this_obj;\n-  _listener_fun   = listener_fun;\n-  _elements       = new (mtServiceability) GrowableArray<GrowableElement*>(5, mtServiceability);\n-  recache();\n-}\n-\n-\/\/ number of elements in the collection\n-int GrowableCache::length() {\n-  return _elements->length();\n-}\n-\n-\/\/ get the value of the index element in the collection\n-GrowableElement* GrowableCache::at(int index) {\n-  GrowableElement *e = (GrowableElement *) _elements->at(index);\n-  assert(e != nullptr, \"e != nullptr\");\n-  return e;\n-}\n-\n-int GrowableCache::find(const GrowableElement* e) const {\n-  return _elements->find_if([&](const GrowableElement* other_e) { return e->equals(other_e); });\n-}\n-\n-\/\/ append a copy of the element to the end of the collection\n-void GrowableCache::append(GrowableElement* e) {\n-  GrowableElement *new_e = e->clone();\n-  _elements->append(new_e);\n-  recache();\n-}\n-\n-\/\/ remove the element at index\n-void GrowableCache::remove (int index) {\n-  GrowableElement *e = _elements->at(index);\n-  assert(e != nullptr, \"e != nullptr\");\n-  _elements->remove(e);\n-  delete e;\n-  recache();\n-}\n-\n-\/\/ clear out all elements, release all heap space and\n-\/\/ let our listener know that things have changed.\n-void GrowableCache::clear() {\n-  int len = _elements->length();\n-  for (int i=0; i<len; i++) {\n-    delete _elements->at(i);\n-  }\n-  _elements->clear();\n-  recache();\n-}\n-\n@@ -197,1 +101,1 @@\n-  oop class_holder_oop  = _method->method_holder()->klass_holder();\n+  oop class_holder_oop = _method->method_holder()->klass_holder();\n@@ -201,2 +105,3 @@\n-JvmtiBreakpoint::~JvmtiBreakpoint() {\n-  _class_holder.release(JvmtiExport::jvmti_oop_storage());\n+JvmtiBreakpoint::JvmtiBreakpoint(const JvmtiBreakpoint& bp)\n+    : _method(bp._method), _bci(bp._bci) {\n+  _class_holder = OopHandle(JvmtiExport::jvmti_oop_storage(), bp._class_holder.resolve());\n@@ -205,4 +110,2 @@\n-void JvmtiBreakpoint::copy(JvmtiBreakpoint& bp) {\n-  _method   = bp._method;\n-  _bci      = bp._bci;\n-  _class_holder = OopHandle(JvmtiExport::jvmti_oop_storage(), bp._class_holder.resolve());\n+JvmtiBreakpoint::~JvmtiBreakpoint() {\n+  _class_holder.release(JvmtiExport::jvmti_oop_storage());\n@@ -304,2 +207,2 @@\n-JvmtiBreakpoints::JvmtiBreakpoints(void listener_fun(void *,address *)) {\n-  _bps.initialize(this,listener_fun);\n+JvmtiBreakpoints::JvmtiBreakpoints()\n+    : _elements(5, mtServiceability) {\n@@ -315,3 +218,3 @@\n-  int n = _bps.length();\n-  for (int i=0; i<n; i++) {\n-    JvmtiBreakpoint& bp = _bps.at(i);\n+  int n = length();\n+  for (int i = 0; i < n; i++) {\n+    JvmtiBreakpoint& bp = at(i);\n@@ -329,1 +232,1 @@\n-  int i = _bps.find(bp);\n+  int i = find(bp);\n@@ -331,1 +234,1 @@\n-    _bps.append(bp);\n+    append(bp);\n@@ -339,1 +242,1 @@\n-  int i = _bps.find(bp);\n+  int i = find(bp);\n@@ -341,1 +244,1 @@\n-    _bps.remove(i);\n+    remove(i);\n@@ -346,2 +249,0 @@\n-int JvmtiBreakpoints::length() { return _bps.length(); }\n-\n@@ -349,2 +250,2 @@\n-  if ( _bps.find(bp) != -1) {\n-     return JVMTI_ERROR_DUPLICATE;\n+  if (find(bp) != -1) {\n+    return JVMTI_ERROR_DUPLICATE;\n@@ -358,2 +259,2 @@\n-  if ( _bps.find(bp) == -1) {\n-     return JVMTI_ERROR_NOT_FOUND;\n+  if (find(bp) == -1) {\n+    return JVMTI_ERROR_NOT_FOUND;\n@@ -368,21 +269,8 @@\n-  bool changed = true;\n-  \/\/ We are going to run thru the list of bkpts\n-  \/\/ and delete some.  This deletion probably alters\n-  \/\/ the list in some implementation defined way such\n-  \/\/ that when we delete entry i, the next entry might\n-  \/\/ no longer be at i+1.  To be safe, each time we delete\n-  \/\/ an entry, we'll just start again from the beginning.\n-  \/\/ We'll stop when we make a pass thru the whole list without\n-  \/\/ deleting anything.\n-  while (changed) {\n-    int len = _bps.length();\n-    changed = false;\n-    for (int i = 0; i < len; i++) {\n-      JvmtiBreakpoint& bp = _bps.at(i);\n-      if (bp.method()->method_holder() == klass) {\n-        bp.clear();\n-        _bps.remove(i);\n-        \/\/ This changed 'i' so we have to start over.\n-        changed = true;\n-        break;\n-      }\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be at safepoint\");\n+\n+  \/\/ Go backwards because this removes entries that are freed.\n+  for (int i = length() - 1; i >= 0; i--) {\n+    JvmtiBreakpoint& bp = at(i);\n+    if (bp.method()->method_holder() == klass) {\n+      bp.clear();\n+      remove(i);\n@@ -398,2 +286,0 @@\n-address *         JvmtiCurrentBreakpoints::_breakpoint_list    = nullptr;\n-\n@@ -402,3 +288,7 @@\n-  if (_jvmti_breakpoints != nullptr) return (*_jvmti_breakpoints);\n-  _jvmti_breakpoints = new JvmtiBreakpoints(listener_fun);\n-  assert(_jvmti_breakpoints != nullptr, \"_jvmti_breakpoints != nullptr\");\n+  if (_jvmti_breakpoints == nullptr) {\n+    JvmtiBreakpoints* breakpoints = new JvmtiBreakpoints();\n+    if (!Atomic::replace_if_null(&_jvmti_breakpoints, breakpoints)) {\n+      \/\/ already created concurently\n+      delete breakpoints;\n+    }\n+  }\n@@ -408,9 +298,0 @@\n-void  JvmtiCurrentBreakpoints::listener_fun(void *this_obj, address *cache) {\n-  JvmtiBreakpoints *this_jvmti = (JvmtiBreakpoints *) this_obj;\n-  assert(this_jvmti != nullptr, \"this_jvmti != nullptr\");\n-\n-  debug_only(int n = this_jvmti->length(););\n-  assert(cache[n] == nullptr, \"cache must be null terminated\");\n-\n-  set_breakpoint_list(cache);\n-}\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":36,"deletions":155,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,104 +39,0 @@\n-\/\/\n-\/\/ Forward Declarations\n-\/\/\n-\n-class JvmtiBreakpoint;\n-class JvmtiBreakpoints;\n-\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\n-\/\/ class GrowableCache, GrowableElement\n-\/\/ Used by              : JvmtiBreakpointCache\n-\/\/ Used by JVMTI methods: none directly.\n-\/\/\n-\/\/ GrowableCache is a permanent CHeap growable array of <GrowableElement *>\n-\/\/\n-\/\/ In addition, the GrowableCache maintains a null terminated cache array of type address\n-\/\/ that's created from the element array using the function:\n-\/\/     address GrowableElement::getCacheValue().\n-\/\/\n-\/\/ Whenever the GrowableArray changes size, the cache array gets recomputed into a new C_HEAP allocated\n-\/\/ block of memory. Additionally, every time the cache changes its position in memory, the\n-\/\/    void (*_listener_fun)(void *this_obj, address* cache)\n-\/\/ gets called with the cache's new address. This gives the user of the GrowableCache a callback\n-\/\/ to update its pointer to the address cache.\n-\/\/\n-\n-class GrowableElement : public CHeapObj<mtInternal> {\n-public:\n-  virtual ~GrowableElement() {}\n-  virtual address getCacheValue()                     =0;\n-  virtual bool equals(const GrowableElement* e) const =0;\n-  virtual GrowableElement* clone()                    =0;\n-};\n-\n-class GrowableCache {\n-\n-private:\n-  \/\/ Object pointer passed into cache & listener functions.\n-  void *_this_obj;\n-\n-  \/\/ Array of elements in the collection\n-  GrowableArray<GrowableElement *> *_elements;\n-\n-  \/\/ Parallel array of cached values\n-  address *_cache;\n-\n-  \/\/ Listener for changes to the _cache field.\n-  \/\/ Called whenever the _cache field has it's value changed\n-  \/\/ (but NOT when cached elements are recomputed).\n-  void (*_listener_fun)(void *, address*);\n-\n-  \/\/ recache all elements after size change, notify listener\n-  void recache();\n-\n-public:\n-   GrowableCache();\n-   ~GrowableCache();\n-\n-  void initialize(void *this_obj, void listener_fun(void *, address*) );\n-\n-  \/\/ number of elements in the collection\n-  int length();\n-  \/\/ get the value of the index element in the collection\n-  GrowableElement* at(int index);\n-  \/\/ find the index of the element, -1 if it doesn't exist\n-  int find(const GrowableElement* e) const;\n-  \/\/ append a copy of the element to the end of the collection, notify listener\n-  void append(GrowableElement* e);\n-  \/\/ remove the element at index, notify listener\n-  void remove (int index);\n-  \/\/ clear out all elements and release all heap space, notify listener\n-  void clear();\n-};\n-\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\n-\/\/ class JvmtiBreakpointCache\n-\/\/ Used by              : JvmtiBreakpoints\n-\/\/ Used by JVMTI methods: none directly.\n-\/\/ Note   : typesafe wrapper for GrowableCache of JvmtiBreakpoint\n-\/\/\n-\n-class JvmtiBreakpointCache : public CHeapObj<mtInternal> {\n-\n-private:\n-  GrowableCache _cache;\n-\n-public:\n-  JvmtiBreakpointCache()  {}\n-  ~JvmtiBreakpointCache() {}\n-\n-  void initialize(void *this_obj, void listener_fun(void *, address*) ) {\n-    _cache.initialize(this_obj, listener_fun);\n-  }\n-\n-  int length()                          { return _cache.length(); }\n-  JvmtiBreakpoint& at(int index)        { return (JvmtiBreakpoint&) *(_cache.at(index)); }\n-  int find(JvmtiBreakpoint& e)          { return _cache.find((GrowableElement *) &e); }\n-  void append(JvmtiBreakpoint& e)       { _cache.append((GrowableElement *) &e); }\n-  void remove (int index)               { _cache.remove(index); }\n-};\n-\n@@ -147,3 +43,0 @@\n-\/\/ Used by              : JvmtiBreakpoints\n-\/\/ Used by JVMTI methods: SetBreakpoint, ClearBreakpoint, ClearAllBreakpoints\n-\/\/ Note: Extends GrowableElement for use in a GrowableCache\n@@ -156,1 +49,1 @@\n-class JvmtiBreakpoint : public GrowableElement {\n+class JvmtiBreakpoint : public CHeapObj<mtInternal> {\n@@ -163,1 +56,0 @@\n-  JvmtiBreakpoint() : _method(nullptr), _bci(0) {}\n@@ -165,0 +57,1 @@\n+  JvmtiBreakpoint(const JvmtiBreakpoint& bp);\n@@ -167,1 +60,0 @@\n-  void copy(JvmtiBreakpoint& bp);\n@@ -174,11 +66,1 @@\n-  Method* method() { return _method; }\n-\n-  \/\/ GrowableElement implementation\n-  address getCacheValue()         { return getBcp(); }\n-  bool equals(const GrowableElement* e) const { return equals((const JvmtiBreakpoint&) *e); }\n-\n-  GrowableElement *clone()        {\n-    JvmtiBreakpoint *bp = new JvmtiBreakpoint();\n-    bp->copy(*this);\n-    return bp;\n-  }\n+  Method* method() const { return _method; }\n@@ -187,1 +69,0 @@\n-\n@@ -191,9 +72,0 @@\n-\/\/ Used by              : JvmtiCurrentBreakpoints\n-\/\/ Used by JVMTI methods: none directly\n-\/\/ Note: A Helper class\n-\/\/\n-\/\/ JvmtiBreakpoints is a GrowableCache of JvmtiBreakpoint.\n-\/\/ All changes to the GrowableCache occur at a safepoint using VM_ChangeBreakpoints.\n-\/\/\n-\/\/ Because _bps is only modified at safepoints, its possible to always use the\n-\/\/ cached byte code pointers from _bps without doing any synchronization (see JvmtiCurrentBreakpoints).\n@@ -201,2 +73,2 @@\n-\/\/ It would be possible to make JvmtiBreakpoints a static class, but I've made it\n-\/\/ CHeap allocated to emphasize its similarity to JvmtiFramePops.\n+\/\/ Contains growable array of JvmtiBreakpoint.\n+\/\/ All changes to the array occur at a safepoint.\n@@ -207,0 +79,1 @@\n+  GrowableArray<JvmtiBreakpoint*> _elements;\n@@ -208,1 +81,15 @@\n-  JvmtiBreakpointCache _bps;\n+  int length() { return _elements.length(); }\n+  JvmtiBreakpoint& at(int index) { return *_elements.at(index); }\n+  int find(JvmtiBreakpoint& e) {\n+    return _elements.find_if([&](const JvmtiBreakpoint * other_e) { return e.equals(*other_e); });\n+  }\n+  void append(JvmtiBreakpoint& e) {\n+    JvmtiBreakpoint* new_e = new JvmtiBreakpoint(e);\n+    _elements.append(new_e);\n+  }\n+  void remove(int index) {\n+    JvmtiBreakpoint* e = _elements.at(index);\n+    assert(e != nullptr, \"e != nullptr\");\n+    _elements.remove_at(index);\n+    delete e;\n+  }\n@@ -210,6 +97,2 @@\n-  \/\/ These should only be used by VM_ChangeBreakpoints\n-  \/\/ to insure they only occur at safepoints.\n-  \/\/ Todo: add checks for safepoint\n-  friend class VM_ChangeBreakpoints;\n-  void set_at_safepoint(JvmtiBreakpoint& bp);\n-  void clear_at_safepoint(JvmtiBreakpoint& bp);\n+  friend class JvmtiCurrentBreakpoints;\n+  JvmtiBreakpoints(); \/\/ accessible only for JvmtiCurrentBreakpoints\n@@ -218,1 +101,0 @@\n-  JvmtiBreakpoints(void listener_fun(void *, address *));\n@@ -221,1 +103,0 @@\n-  int length();\n@@ -226,0 +107,5 @@\n+\n+  \/\/ used by VM_ChangeBreakpoints\n+  void set_at_safepoint(JvmtiBreakpoint& bp);\n+  void clear_at_safepoint(JvmtiBreakpoint& bp);\n+  \/\/ used by VM_RedefineClasses\n@@ -229,1 +115,0 @@\n-\n@@ -234,6 +119,2 @@\n-\/\/ A static wrapper class for the JvmtiBreakpoints that provides:\n-\/\/ 1. a fast inlined function to check if a byte code pointer is a breakpoint (is_breakpoint).\n-\/\/ 2. a function for lazily creating the JvmtiBreakpoints class (this is not strictly necessary,\n-\/\/    but I'm copying the code from JvmtiThreadState which needs to lazily initialize\n-\/\/    JvmtiFramePops).\n-\/\/ 3. An oops_do entry point for GC'ing the breakpoint array.\n+\/\/ A static wrapper class for the JvmtiBreakpoints that provides\n+\/\/ a function for lazily creating the JvmtiBreakpoints class.\n@@ -243,1 +124,0 @@\n-\n@@ -245,1 +125,0 @@\n-\n@@ -249,9 +128,0 @@\n-  \/\/ null terminated cache of byte-code pointers corresponding to current breakpoints.\n-  \/\/ Updated only at safepoints (with listener_fun) when the cache is moved.\n-  \/\/ It exists only to make is_breakpoint fast.\n-  static address          *_breakpoint_list;\n-  static inline void set_breakpoint_list(address *breakpoint_list) { _breakpoint_list = breakpoint_list; }\n-\n-  \/\/ Listener for the GrowableCache in _jvmti_breakpoints, updates _breakpoint_list.\n-  static void listener_fun(void *this_obj, address *cache);\n-\n@@ -259,4 +129,1 @@\n-  static void initialize();\n-  static void destroy();\n-\n-  \/\/ lazily create _jvmti_breakpoints and _breakpoint_list\n+  \/\/ lazily create _jvmti_breakpoints\n@@ -268,5 +135,0 @@\n-\/\/ class VM_ChangeBreakpoints\n-\/\/ Used by              : JvmtiBreakpoints\n-\/\/ Used by JVMTI methods: none directly.\n-\/\/ Note: A Helper class.\n-\/\/\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":32,"deletions":170,"binary":false,"changes":202,"status":"modified"}]}