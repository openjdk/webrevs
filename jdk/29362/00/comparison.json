{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -584,1 +584,1 @@\n-void Compile::print_ideal_ir(const char* phase_name) {\n+void Compile::print_ideal_ir(const char* compile_phase_name) const {\n@@ -596,1 +596,1 @@\n-    ss.print_cr(\"AFTER: %s\", phase_name);\n+    ss.print_cr(\"AFTER: %s\", compile_phase_name);\n@@ -613,1 +613,1 @@\n-               phase_name);\n+               compile_phase_name);\n@@ -674,1 +674,1 @@\n-          _unique(0),\n+      _unique(0),\n@@ -868,1 +868,1 @@\n-    print_ideal_ir(\"print_ideal\");\n+    print_ideal_ir(\"PrintIdeal\");\n@@ -941,1 +941,1 @@\n-          _unique(0),\n+      _unique(0),\n@@ -5168,1 +5168,1 @@\n-void Compile::print_method(CompilerPhaseType cpt, int level, Node* n) {\n+void Compile::print_method(CompilerPhaseType compile_phase, int level, Node* n) {\n@@ -5172,1 +5172,1 @@\n-    CompilerEvent::PhaseEvent::post(event, C->_latest_stage_start_counter, cpt, C->_compile_id, level);\n+    CompilerEvent::PhaseEvent::post(event, C->_latest_stage_start_counter, compile_phase, C->_compile_id, level);\n@@ -5177,2 +5177,2 @@\n-  ss.print_raw(CompilerPhaseTypeHelper::to_description(cpt));\n-  int iter = ++_igv_phase_iter[cpt];\n+  ss.print_raw(CompilerPhaseTypeHelper::to_description(compile_phase));\n+  int iter = ++_igv_phase_iter[compile_phase];\n@@ -5206,2 +5206,2 @@\n-  if (should_print_ideal_phase(cpt)) {\n-    print_ideal_ir(CompilerPhaseTypeHelper::to_name(cpt));\n+  if (should_print_ideal_phase(compile_phase)) {\n+    print_ideal_ir(CompilerPhaseTypeHelper::to_name(compile_phase));\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -669,1 +669,1 @@\n-  void          print_ideal_ir(const char* phase_name);\n+  void          print_ideal_ir(const char* compile_phase_name) const;\n@@ -683,1 +683,1 @@\n-  void print_method(CompilerPhaseType cpt, int level, Node* n = nullptr);\n+  void print_method(CompilerPhaseType compile_phase, int level, Node* n = nullptr);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-                PHASES_BY_PARSED_NAME.put(\"print_ideal\", phase);\n+                PHASES_BY_PARSED_NAME.put(\"PrintIdeal\", phase);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    private boolean isAllowNotCompilable = false;\n+    private boolean allowNotCompilable = false;\n@@ -501,1 +501,1 @@\n-        this.isAllowNotCompilable = true;\n+        this.allowNotCompilable = true;\n@@ -724,1 +724,1 @@\n-        System.out.println(\"\");\n+        System.out.println();\n@@ -863,2 +863,2 @@\n-                                   .collect(Collectors.toList());\n-        List<String> nonWhiteListedFlags = new ArrayList();\n+                                   .toList();\n+        List<String> nonWhiteListedFlags = new ArrayList<>();\n@@ -880,1 +880,1 @@\n-                                                        isAllowNotCompilable, testClassesOnBootClassPath);\n+                                                        allowNotCompilable, testClassesOnBootClassPath);\n@@ -883,1 +883,1 @@\n-                TestClassParser testClassParser = new TestClassParser(testClass, isAllowNotCompilable);\n+                TestClassParser testClassParser = new TestClassParser(testClass, allowNotCompilable);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.stream.Collectors;\n@@ -111,1 +110,1 @@\n-        List<String> jtregVMFlags = Arrays.stream(Utils.getTestJavaOpts()).filter(s -> !s.contains(\"CompileThreshold\")).collect(Collectors.toList());\n+        List<String> jtregVMFlags = Arrays.stream(Utils.getTestJavaOpts()).filter(s -> !s.contains(\"CompileThreshold\")).toList();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import compiler.lib.ir_framework.driver.network.testvm.java.IRRuleIds;\n@@ -56,1 +57,1 @@\n-    public IRMethod(Method method, int[] ruleIds, IR[] irAnnos, Compilation compilation, VMInfo vmInfo) {\n+    public IRMethod(Method method, IRRuleIds irRuleIds, IR[] irAnnos, Compilation compilation, VMInfo vmInfo) {\n@@ -58,1 +59,1 @@\n-        this.matcher = new MatchableMatcher(createIRRules(method, ruleIds, irAnnos, compilation, vmInfo));\n+        this.matcher = new MatchableMatcher(createIRRules(method, irRuleIds, irAnnos, compilation, vmInfo));\n@@ -61,1 +62,1 @@\n-    private List<Matchable> createIRRules(Method method, int[] ruleIds, IR[] irAnnos, Compilation compilation, VMInfo vmInfo) {\n+    private List<Matchable> createIRRules(Method method, IRRuleIds irRuleIds, IR[] irAnnos, Compilation compilation, VMInfo vmInfo) {\n@@ -63,1 +64,1 @@\n-        for (int ruleId : ruleIds) {\n+        for (int ruleId : irRuleIds) {\n@@ -92,1 +93,0 @@\n-        List<MatchResult> match;\n@@ -94,1 +94,1 @@\n-            match = matcher.match();\n+            matcher.match();\n@@ -98,1 +98,1 @@\n-        match = matcher.match();\n+        List<MatchResult> match = matcher.match();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/IRMethod.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-import compiler.lib.ir_framework.Run;\n-import compiler.lib.ir_framework.RunMode;\n+import compiler.lib.ir_framework.Test;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NotCompilableIRMethod.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n-import compiler.lib.ir_framework.Run;\n-import compiler.lib.ir_framework.RunMode;\n+import compiler.lib.ir_framework.Test;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NotCompilableIRMethodMatchResult.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import compiler.lib.ir_framework.driver.network.testvm.java.IRRuleIds;\n@@ -34,0 +35,1 @@\n+import java.util.ArrayList;\n@@ -35,0 +37,1 @@\n+import java.util.List;\n@@ -78,1 +81,1 @@\n-        Map<String, int[]> irRulesMap = parseApplicableIRRules(applicableIRRules);\n+        Map<String, IRRuleIds> irRulesMap = parseApplicableIRRules(applicableIRRules);\n@@ -85,2 +88,2 @@\n-    private Map<String, int[]> parseApplicableIRRules(String applicableIRRules) {\n-        Map<String, int[]> irRulesMap = new HashMap<>();\n+    private Map<String, IRRuleIds> parseApplicableIRRules(String applicableIRRules) {\n+        Map<String, IRRuleIds> irRulesMap = new HashMap<>();\n@@ -95,2 +98,2 @@\n-            int[] irRulesIdx = getRuleIndexes(splitLine);\n-            irRulesMap.put(testName, irRulesIdx);\n+            IRRuleIds irRuleIds = parseIrRulesIds(splitLine);\n+            irRulesMap.put(testName, irRuleIds);\n@@ -119,2 +122,2 @@\n-    private int[] getRuleIndexes(String[] splitLine) {\n-        int[] irRulesIdx = new int[splitLine.length - 1];\n+    private IRRuleIds parseIrRulesIds(String[] splitLine) {\n+        List<Integer> irRuleIds = new ArrayList<>();\n@@ -123,1 +126,1 @@\n-                irRulesIdx[i - 1] = Integer.parseInt(splitLine[i]);\n+                irRuleIds.add(Integer.parseInt(splitLine[i]));\n@@ -128,1 +131,1 @@\n-        return irRulesIdx;\n+        return new IRRuleIds(irRuleIds);\n@@ -131,1 +134,1 @@\n-    private void createTestMethodsWithApplicableIRRules(Class<?> testClass, Map<String, int[]> irRulesMap) {\n+    private void createTestMethodsWithApplicableIRRules(Class<?> testClass, Map<String, IRRuleIds> irRulesMap) {\n@@ -136,1 +139,1 @@\n-                int[] irRuleIds = irRulesMap.get(m.getName());\n+                IRRuleIds irRuleIds = irRulesMap.get(m.getName());\n@@ -145,5 +148,5 @@\n-    private void validateIRRuleIds(Method m, IR[] irAnnos, int[] ids) {\n-        TestFramework.check(ids != null, \"Should find method name in validIrRulesMap for \" + m);\n-        TestFramework.check(ids.length > 0, \"Did not find any rule indices for \" + m);\n-        TestFramework.check((ids[0] >= 1 || ids[0] == ApplicableIRRulesPrinter.NO_RULE_APPLIED)\n-                            && ids[ids.length - 1] <= irAnnos.length,\n+    private void validateIRRuleIds(Method m, IR[] irAnnos, IRRuleIds irRuleIds) {\n+        TestFramework.check(irRuleIds != null, \"Should find method name in validIrRulesMap for \" + m);\n+        TestFramework.check(!irRuleIds.isEmpty(), \"Did not find any rule indices for \" + m);\n+        TestFramework.check((irRuleIds.first() >= 1 || irRuleIds.first() == ApplicableIRRulesPrinter.NO_RULE_APPLIED)\n+                            && irRuleIds.last() <= irAnnos.length,\n@@ -156,2 +159,2 @@\n-    private boolean hasAnyApplicableIRRules(int[] irRuleIds) {\n-        return irRuleIds[0] != ApplicableIRRulesPrinter.NO_RULE_APPLIED;\n+    private boolean hasAnyApplicableIRRules(IRRuleIds irRuleIds) {\n+        return irRuleIds.first() != ApplicableIRRulesPrinter.NO_RULE_APPLIED;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/ApplicableIRRulesParser.java","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-                return new NotCompilableIRMethod(testMethod.method(), testMethod.irRuleIds().length);\n+                return new NotCompilableIRMethod(testMethod.method(), testMethod.irRuleIds().count());\n@@ -76,1 +76,1 @@\n-                return new NotCompiledIRMethod(testMethod.method(), testMethod.irRuleIds().length);\n+                return new NotCompiledIRMethod(testMethod.method(), testMethod.irRuleIds().count());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IRMethodBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import compiler.lib.ir_framework.driver.network.testvm.java.IRRuleIds;\n@@ -43,1 +44,1 @@\n-    private final int[] irRuleIds;\n+    private final IRRuleIds irRuleIds;\n@@ -45,1 +46,1 @@\n-    public TestMethod(Method m, IR[] irAnnos, int[] irRuleIds) {\n+    public TestMethod(Method m, IR[] irAnnos, IRRuleIds irRuleIds) {\n@@ -59,1 +60,1 @@\n-    public int[] irRuleIds() {\n+    public IRRuleIds irRuleIds() {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/TestMethod.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.network.testvm.java;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Class to hold the indices of the applicable {@link IR @IR} rules of an {@link IRMethod}.\n+ *\/\n+public class IRRuleIds implements Iterable<Integer> {\n+    private final List<Integer> ruleIds;\n+\n+    public IRRuleIds(List<Integer> ruleIds) {\n+        this.ruleIds = ruleIds;\n+    }\n+\n+    public int first() {\n+        return ruleIds.getFirst();\n+    }\n+\n+    public int last() {\n+        return ruleIds.getLast();\n+    }\n+\n+    public boolean isEmpty() {\n+        return ruleIds.isEmpty();\n+    }\n+\n+    public int count() {\n+        return ruleIds.size();\n+    }\n+\n+    @Override\n+    public Iterator<Integer> iterator() {\n+        return ruleIds.iterator();\n+    }\n+\n+    public Stream<Integer> stream() {\n+        return ruleIds.stream();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/network\/testvm\/java\/IRRuleIds.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -95,1 +95,1 @@\n-    private static final boolean PRINT_TIMES = Boolean.getBoolean(\"PrintTimes\");\n+    private static final boolean PRINT_TIMES = Boolean.getBoolean(\"PrintTimes\") || VERBOSE;\n@@ -826,1 +826,1 @@\n-                                   + System.lineSeparator() + builder.toString());\n+                                   + System.lineSeparator() + builder);\n@@ -870,1 +870,1 @@\n-                builder.append(test.toString()).append(\":\").append(System.lineSeparator()).append(sw.toString())\n+                builder.append(test).append(\":\").append(System.lineSeparator()).append(sw)\n@@ -874,1 +874,1 @@\n-            if (PRINT_TIMES || VERBOSE) {\n+            if (PRINT_TIMES) {\n@@ -889,1 +889,1 @@\n-        if (VERBOSE || PRINT_TIMES) {\n+        if (PRINT_TIMES) {\n@@ -901,1 +901,1 @@\n-            throw new TestRunException(msg + System.lineSeparator() + builder.toString());\n+            throw new TestRunException(msg + System.lineSeparator() + builder);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,0 +183,6 @@\n+\n+    static class BadCheckedTestException extends RuntimeException {\n+        BadCheckedTestException(String s) {\n+            super(s);\n+        }\n+    }\n@@ -227,6 +233,0 @@\n-\n-class BadCheckedTestException extends RuntimeException {\n-    BadCheckedTestException(String s) {\n-        super(s);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestCheckedTests.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import compiler.lib.ir_framework.shared.TestRunException;\n@@ -363,1 +362,0 @@\n-}\n@@ -365,3 +363,5 @@\n-class BadCheckedTestException extends RuntimeException {\n-    BadCheckedTestException(String s) {\n-        super(s);\n+\n+    static class BadCheckedTestException extends RuntimeException {\n+        BadCheckedTestException(String s) {\n+            super(s);\n+        }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestSetupTests.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}