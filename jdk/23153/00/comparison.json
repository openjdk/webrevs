{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,5 +146,0 @@\n-        \/\/ Since LinkedHashMap was introduced in SE 1.4, it's conceivable even\n-        \/\/ if very unlikely that we might be the server of a 1.3 client.  In\n-        \/\/ that case you'll need to set this property.  See CR 6334663.\n-        boolean useHashMap = Boolean.getBoolean(\"jmx.tabular.data.hash.map\");\n-\n@@ -153,3 +148,1 @@\n-        this.dataMap = useHashMap ?\n-            new HashMap<>(initialCapacity, loadFactor) :\n-            new LinkedHashMap<>(initialCapacity, loadFactor);\n+        this.dataMap = new LinkedHashMap<>(initialCapacity, loadFactor);\n","filename":"src\/java.management\/share\/classes\/javax\/management\/openmbean\/TabularDataSupport.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,0 @@\n-    private static final String COMPAT_PROP_NAME = \"jmx.tabular.data.hash.map\";\n-\n@@ -132,38 +130,0 @@\n-        \/\/ Now test the undocumented property that causes HashMap to be used\n-        \/\/ instead of LinkedHashMap, in case serializing to a 1.3 client.\n-        \/\/ We serialize and deserialize in case the implementation handles\n-        \/\/ this at serialization time.  Then we look at object fields; that's\n-        \/\/ not guaranteed to work but at worst it will fail spuriously and\n-        \/\/ we'll have to update the test.\n-        System.out.println(\"Testing compatible behaviour\");\n-        System.setProperty(COMPAT_PROP_NAME, \"true\");\n-        td = makeTable();\n-        System.out.println(td);\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        ObjectOutputStream oout = new ObjectOutputStream(bout);\n-        oout.writeObject(td);\n-        oout.close();\n-        byte[] bytes = bout.toByteArray();\n-        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n-        ObjectInputStream oin = new ObjectInputStream(bin);\n-        td = (TabularData) oin.readObject();\n-        boolean found = false;\n-        for (Field f : td.getClass().getDeclaredFields()) {\n-            if (Modifier.isStatic(f.getModifiers()))\n-                continue;\n-            f.setAccessible(true);\n-            Object x = f.get(td);\n-            if (x != null && x.getClass() == HashMap.class) {\n-                found = true;\n-                System.out.println(\n-                        x.getClass().getName() + \" TabularDataSupport.\" +\n-                        f.getName() + \" = \" + x);\n-                break;\n-            }\n-        }\n-        if (!found) {\n-            fail(\"TabularDataSupport does not contain HashMap though \" +\n-                    COMPAT_PROP_NAME + \"=true\");\n-        }\n-        System.clearProperty(COMPAT_PROP_NAME);\n-\n","filename":"test\/jdk\/javax\/management\/openmbean\/TabularDataOrderTest.java","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"}]}