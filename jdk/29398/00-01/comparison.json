{"files":[{"patch":"@@ -118,6 +118,20 @@\n-   private boolean isValidFrame(Address nextCFA, boolean isNative) {\n-     \/\/ CFA should never be null.\n-     \/\/ nextCFA must be greater than current CFA, if frame is native.\n-     \/\/ Java interpreter frames can share the CFA (frame pointer).\n-     return nextCFA != null &&\n-         (!isNative || (isNative && nextCFA.greaterThanOrEqual(cfa)));\n+   private boolean isValidFrame(Address nextCFA, Address nextRBP) {\n+     \/\/ Both CFA and RBP must not be null.\n+     if (nextCFA == null && nextRBP == null) {\n+       return false;\n+     }\n+\n+     \/\/ RBP must not be null if CFA is null - it happens between Java frame and Native frame.\n+     \/\/ We cannot validate RBP value because it might be used as GPR. Thus returns true\n+     \/\/ if RBP is not null.\n+     if (nextCFA == null && nextRBP != null) {\n+       return true;\n+     }\n+\n+     \/\/ nextCFA must be greater than current CFA.\n+     if (nextCFA != null && nextCFA.greaterThanOrEqual(cfa)) {\n+       return true;\n+     }\n+\n+     \/\/ Otherwise, the frame is not valid.\n+     return false;\n@@ -132,42 +146,0 @@\n-   private Address getNextCFA(DwarfParser nextDwarf, Address senderFP, Address senderPC) {\n-     Address nextCFA;\n-     boolean isNative = false;\n-\n-     if (nextDwarf == null) { \/\/ Next frame is Java\n-       return null;\n-     } else { \/\/ Next frame is Native\n-       if (dwarf == null) { \/\/ Current frame is Java\n-         int nextCFAReg = nextDwarf.getCFARegister();\n-         if (nextCFAReg == AMD64ThreadContext.RBP) {\n-           nextCFA = nextDwarf.isBPOffsetAvailable()\n-                       ? rbp.getAddressAt(0) \/\/ We can use cfa as BP in Java frame\n-                            .addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA())\n-                       : rbp;\n-         } else if (nextCFAReg == AMD64ThreadContext.RSP) {\n-           nextCFA = senderFP.addOffsetTo(2 * ADDRESS_SIZE) \/\/ skip BP and RA to get caller SP\n-                             .addOffsetTo(nextDwarf.getCFAOffset());\n-         } else {\n-           throw new DebuggerException(\"Unsupported CFA register: \" + nextCFAReg);\n-         }\n-       } else { \/\/ Current frame is Native\n-         isNative = true;\n-         int nextCFAReg = nextDwarf.getCFARegister();\n-         if (nextCFAReg == AMD64ThreadContext.RBP) {\n-           Address nextRBP = getNextRBP(senderFP);\n-           nextCFA = nextRBP.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n-         } else if (nextCFAReg == AMD64ThreadContext.RSP) {\n-           nextCFA = getNextRSP().addOffsetTo(nextDwarf.getCFAOffset());\n-         } else {\n-           throw new DebuggerException(\"Unsupported CFA register: \" + nextCFAReg);\n-         }\n-       }\n-     }\n-\n-     if (dbg.isSignalTrampoline(senderPC)) {\n-       \/\/ Return without frame check if sender is signal trampoline.\n-       return nextCFA;\n-     } else {\n-       return isValidFrame(nextCFA, isNative) ? nextCFA : null;\n-     }\n-   }\n-\n@@ -186,0 +158,15 @@\n+   private Address getNextCFA(DwarfParser nextDwarf, Address senderFP, Address senderPC) {\n+     if (nextDwarf == null) { \/\/ Next frame is Java\n+       \/\/ CFA is not available on Java frame\n+       return null;\n+     }\n+\n+     \/\/ Next frame is Native\n+     int nextCFAReg = nextDwarf.getCFARegister();\n+     return switch(nextCFAReg){\n+       case AMD64ThreadContext.RBP -> getNextRBP(senderFP).addOffsetTo(nextDwarf.getCFAOffset());\n+       case AMD64ThreadContext.RSP -> getNextRSP().addOffsetTo(nextDwarf.getCFAOffset());\n+       default -> throw new DebuggerException(\"Unsupported CFA register: \" + nextCFAReg);\n+     };\n+   }\n+\n@@ -232,6 +219,13 @@\n-       return (nextCFA == null && nextRBP == null)\n-         ? null\n-         : new LinuxAMD64CFrame(dbg, nextRSP, nextRBP, nextCFA, nextPC, nextDwarf, fallback);\n-     } catch (DebuggerException _) {\n-       return nextRBP == null ? null\n-                              : new LinuxAMD64CFrame(dbg, nextRSP, nextRBP, null, nextPC, null, fallback);\n+       return isValidFrame(nextCFA, nextRBP)\n+         ? new LinuxAMD64CFrame(dbg, nextRSP, nextRBP, nextCFA, nextPC, nextDwarf, fallback)\n+         : null;\n+     } catch (DebuggerException e) {\n+       if (dbg.isSignalTrampoline(nextPC)) {\n+         \/\/ We can through the caller frame if it is signal trampoline.\n+         \/\/ getNextCFA() might fail because DwarfParser cannot find out CFA register.\n+         return new LinuxAMD64CFrame(dbg, nextRSP, nextRBP, null, nextPC, nextDwarf, fallback);\n+       }\n+\n+       \/\/ Rethrow the original exception if getNextCFA() failed\n+       \/\/ and the caller is not signal trampoline.\n+       throw e;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/amd64\/LinuxAMD64CFrame.java","additions":48,"deletions":54,"binary":false,"changes":102,"status":"modified"}]}