{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2021, NTT DATA.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, NTT DATA.\n@@ -222,13 +222,0 @@\n-\n-\/*\n- * Class:     sun_jvm_hotspot_debugger_linux_amd64_DwarfParser\n- * Method:    isBPOffsetAvailable\n- * Signature: ()Z\n- *\/\n-extern \"C\"\n-JNIEXPORT jboolean JNICALL Java_sun_jvm_hotspot_debugger_linux_amd64_DwarfParser_isBPOffsetAvailable\n-  (JNIEnv *env, jobject this_obj) {\n-  DwarfParser *parser = reinterpret_cast<DwarfParser *>(get_dwarf_context(env, this_obj));\n-  return parser->is_bp_offset_available();\n-}\n-\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/DwarfParser.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, NTT DATA.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, NTT DATA.\n@@ -102,1 +102,1 @@\n-  _cfa_reg = RSP;\n+  _cfa_reg = MAX_VALUE;\n@@ -105,3 +105,2 @@\n-  _ra_cfa_offset = 0;\n-  _bp_cfa_offset = 0;\n-  _bp_offset_available = false;\n+  _ra_cfa_offset = 8;\n+  _bp_cfa_offset = INT_MAX;\n@@ -122,2 +121,2 @@\n-  int rem_ra_cfa_offset = 0;\n-  int rem_bp_cfa_offset = 0;\n+  int rem_ra_cfa_offset = 8;\n+  int rem_bp_cfa_offset = INT_MAX;\n@@ -150,1 +149,0 @@\n-          _bp_offset_available = true;\n@@ -187,0 +185,8 @@\n+      case 0x07: { \/\/ DW_CFA_undefined\n+        enum DWARF_Register reg = static_cast<enum DWARF_Register>(read_leb(false));\n+        \/\/ We are only interested in BP here because CFA and RA should not be undefined.\n+        if (reg == RBP) {\n+          _bp_cfa_offset = INT_MAX;\n+        }\n+        break;\n+      }\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/dwarf.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, NTT DATA.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, NTT DATA.\n@@ -76,1 +76,0 @@\n-    bool _bp_offset_available;\n@@ -89,1 +88,1 @@\n-                                 _cfa_reg(RSP),\n+                                 _cfa_reg(MAX_VALUE),\n@@ -95,3 +94,2 @@\n-                                 _ra_cfa_offset(0),\n-                                 _bp_cfa_offset(0),\n-                                 _bp_offset_available(false) {};\n+                                 _ra_cfa_offset(8),\n+                                 _bp_cfa_offset(INT_MAX) {};\n@@ -105,1 +103,0 @@\n-    bool is_bp_offset_available() { return _bp_offset_available; }\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/dwarf.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,5 +84,1 @@\n-       Address sp  = context.getRegisterAsAddress(AMD64ThreadContext.RSP);\n-       if (sp == null) return null;\n-       Address pc  = context.getRegisterAsAddress(AMD64ThreadContext.RIP);\n-       if (pc == null) return null;\n-       return LinuxAMD64CFrame.getTopFrame(dbg, sp, pc, context);\n+       return LinuxAMD64CFrame.getTopFrame(dbg, context);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxCDebugger.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, NTT DATA.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, NTT DATA.\n@@ -69,0 +69,7 @@\n+  \/**\n+   * @return true if BP offset is declared in DWARF instructions.\n+   *\/\n+  public boolean isBPOffsetAvailable() {\n+    return getBasePointerOffsetFromCFA() != Integer.MAX_VALUE;\n+  }\n+\n@@ -73,1 +80,0 @@\n-  public native boolean isBPOffsetAvailable();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/amd64\/DwarfParser.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+      Address rbp = getreg.apply(AMD64ThreadContext.RBP);\n@@ -44,1 +45,1 @@\n-      Address cfa = getreg.apply(AMD64ThreadContext.RBP);\n+      Address cfa = null;\n@@ -55,1 +56,1 @@\n-          return new LinuxAMD64CFrame(dbg, rsp, cfa, rip, dwarf, true);\n+          return new LinuxAMD64CFrame(dbg, rsp, rbp, cfa, rip, dwarf, true);\n@@ -62,2 +63,3 @@\n-      return (cfa == null) ? null\n-                           : new LinuxAMD64CFrame(dbg, rsp, cfa, rip, dwarf);\n+      return (rbp == null && cfa == null)\n+        ? null\n+        : new LinuxAMD64CFrame(dbg, rsp, rbp, cfa, rip, dwarf);\n@@ -66,1 +68,1 @@\n-   public static LinuxAMD64CFrame getTopFrame(LinuxDebugger dbg, Address rip, ThreadContext context) {\n+   public static LinuxAMD64CFrame getTopFrame(LinuxDebugger dbg, ThreadContext context) {\n@@ -70,30 +72,2 @@\n-   public static LinuxAMD64CFrame getTopFrame(LinuxDebugger dbg, Address rsp, Address rip, ThreadContext context) {\n-      Address libptr = dbg.findLibPtrByAddress(rip);\n-      Address cfa = context.getRegisterAsAddress(AMD64ThreadContext.RBP);\n-      DwarfParser dwarf = null;\n-\n-      if (libptr != null) { \/\/ Native frame\n-        dwarf = new DwarfParser(libptr);\n-        try {\n-          dwarf.processDwarf(rip);\n-        } catch (DebuggerException e) {\n-          \/\/ DWARF processing should succeed when the frame is native\n-          \/\/ but it might fail if Common Information Entry (CIE) has language\n-          \/\/ personality routine and\/or Language Specific Data Area (LSDA).\n-          return new LinuxAMD64CFrame(dbg, rsp, cfa, rip, dwarf, true);\n-        }\n-\n-        cfa = context.getRegisterAsAddress(dwarf.getCFARegister())\n-                     .addOffsetTo(dwarf.getCFAOffset());\n-      }\n-\n-      return (cfa == null) ? null\n-                           : new LinuxAMD64CFrame(dbg, rsp, cfa, rip, dwarf);\n-   }\n-\n-   private LinuxAMD64CFrame(LinuxDebugger dbg, Address rsp, Address cfa, Address rip, DwarfParser dwarf) {\n-      this(dbg, rsp, cfa, rip, dwarf, false);\n-   }\n-\n-   private LinuxAMD64CFrame(LinuxDebugger dbg, Address rsp, Address cfa, Address rip, DwarfParser dwarf, boolean finalFrame) {\n-      this(dbg, rsp, cfa, rip, dwarf, finalFrame, false);\n+   private LinuxAMD64CFrame(LinuxDebugger dbg, Address rsp, Address rbp, Address cfa, Address rip, DwarfParser dwarf) {\n+      this(dbg, rsp, rbp, cfa, rip, dwarf, false);\n@@ -102,1 +76,1 @@\n-   private LinuxAMD64CFrame(LinuxDebugger dbg, Address rsp, Address cfa, Address rip, DwarfParser dwarf, boolean finalFrame, boolean use1ByteBeforeToLookup) {\n+   private LinuxAMD64CFrame(LinuxDebugger dbg, Address rsp, Address rbp, Address cfa, Address rip, DwarfParser dwarf, boolean use1ByteBeforeToLookup) {\n@@ -105,0 +79,1 @@\n+      this.rbp = rbp;\n@@ -109,1 +84,0 @@\n-      this.finalFrame = finalFrame;\n@@ -129,1 +103,3 @@\n-      return cfa;\n+      return (dwarf != null && dwarf.isBPOffsetAvailable())\n+        ? cfa.addOffsetTo(dwarf.getBasePointerOffsetFromCFA())\n+        : rbp;\n@@ -132,1 +108,1 @@\n-   private Address getNextPC(boolean useDwarf) {\n+   private Address getNextPC() {\n@@ -134,3 +110,3 @@\n-       long offs = useDwarf ? dwarf.getReturnAddressOffsetFromCFA()\n-                            : ADDRESS_SIZE;\n-       return cfa.getAddressAt(offs);\n+       return dwarf == null\n+         ? rbp.getAddressAt(ADDRESS_SIZE) \/\/ Java frame\n+         : cfa.getAddressAt(dwarf.getReturnAddressOffsetFromCFA()); \/\/ Native frame\n@@ -142,6 +118,20 @@\n-   private boolean isValidFrame(Address nextCFA, boolean isNative) {\n-     \/\/ CFA should never be null.\n-     \/\/ nextCFA must be greater than current CFA, if frame is native.\n-     \/\/ Java interpreter frames can share the CFA (frame pointer).\n-     return nextCFA != null &&\n-         (!isNative || (isNative && nextCFA.greaterThan(cfa)));\n+   private boolean isValidFrame(Address nextCFA, Address nextRBP) {\n+     \/\/ Both CFA and RBP must not be null.\n+     if (nextCFA == null && nextRBP == null) {\n+       return false;\n+     }\n+\n+     \/\/ RBP must not be null if CFA is null - it happens between Java frame and Native frame.\n+     \/\/ We cannot validate RBP value because it might be used as GPR. Thus returns true\n+     \/\/ if RBP is not null.\n+     if (nextCFA == null && nextRBP != null) {\n+       return true;\n+     }\n+\n+     \/\/ nextCFA must be greater than current CFA.\n+     if (nextCFA != null && nextCFA.greaterThanOrEqual(cfa)) {\n+       return true;\n+     }\n+\n+     \/\/ Otherwise, the frame is not valid.\n+     return false;\n@@ -151,4 +141,3 @@\n-     \/\/ next RSP should be previous slot of return address.\n-     var bp = dwarf == null ? cfa.addOffsetTo(ADDRESS_SIZE) \/\/ top of BP points callser BP\n-                            : cfa.addOffsetTo(dwarf.getReturnAddressOffsetFromCFA());\n-     return bp.addOffsetTo(ADDRESS_SIZE);\n+     return dwarf == null ? rbp.addOffsetTo(2 * ADDRESS_SIZE) \/\/ Java frame - skip saved BP and RA\n+                          : cfa.addOffsetTo(dwarf.getReturnAddressOffsetFromCFA())\n+                               .addOffsetTo(ADDRESS_SIZE); \/\/ Native frame\n@@ -157,32 +146,9 @@\n-   private Address getNextCFA(DwarfParser nextDwarf, ThreadContext context, Address senderFP, Address senderPC) {\n-     Address nextCFA;\n-     boolean isNative = false;\n-\n-     if (senderFP == null) {\n-       senderFP = cfa.getAddressAt(0);  \/\/ RBP by default\n-     }\n-\n-     if (VM.getVM().getCodeCache().contains(senderPC)) { \/\/ Next frame is Java\n-       nextCFA = (dwarf == null) ? senderFP \/\/ Current frame is Java\n-                                 : cfa.getAddressAt(dwarf.getBasePointerOffsetFromCFA()); \/\/ Current frame is Native\n-     } else { \/\/ Next frame is Native\n-       if (VM.getVM().getCodeCache().contains(pc())) { \/\/ Current frame is Java\n-         nextCFA = senderFP.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n-       } else { \/\/ Current frame is Native\n-         if (nextDwarf == null) { \/\/ maybe runtime entrypoint (_start())\n-           throw new DebuggerException(\"nextDwarf is null even though native call\");\n-         }\n-\n-         isNative = true;\n-         int nextCFAReg = nextDwarf.getCFARegister();\n-         if (nextCFAReg == AMD64ThreadContext.RBP) {\n-           Address rbp = dwarf.isBPOffsetAvailable() ? cfa.addOffsetTo(dwarf.getBasePointerOffsetFromCFA())\n-                                                     : context.getRegisterAsAddress(AMD64ThreadContext.RBP);\n-           Address nextRBP = rbp.getAddressAt(0);\n-           nextCFA = nextRBP.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n-         } else if (nextCFAReg == AMD64ThreadContext.RSP) {\n-           nextCFA = getNextRSP().addOffsetTo(nextDwarf.getCFAOffset());\n-         } else {\n-           throw new DebuggerException(\"Unsupported CFA register: \" + nextCFAReg);\n-         }\n-       }\n+   private Address getNextRBP(Address senderFP) {\n+     if (senderFP != null) {\n+       return senderFP;\n+     } else if (dwarf == null) { \/\/ Current frame is Java\n+       return rbp.getAddressAt(0);\n+     } else { \/\/ Current frame is Native\n+       return dwarf.isBPOffsetAvailable()\n+         ? cfa.getAddressAt(dwarf.getBasePointerOffsetFromCFA())\n+         : rbp;\n@@ -190,0 +156,1 @@\n+   }\n@@ -191,5 +158,3 @@\n-     \/\/ Sanity check for next CFA address\n-     try {\n-       nextCFA.getAddressAt(0);\n-     } catch (Exception e) {\n-       \/\/ return null if next CFA address is invalid\n+   private Address getNextCFA(DwarfParser nextDwarf, Address senderFP, Address senderPC) {\n+     if (nextDwarf == null) { \/\/ Next frame is Java\n+       \/\/ CFA is not available on Java frame\n@@ -199,6 +164,7 @@\n-     if (dbg.isSignalTrampoline(senderPC)) {\n-       \/\/ Return without frame check if sender is signal trampoline.\n-       return nextCFA;\n-     } else {\n-       return isValidFrame(nextCFA, isNative) ? nextCFA : null;\n-     }\n+     \/\/ Next frame is Native\n+     int nextCFAReg = nextDwarf.getCFARegister();\n+     return switch(nextCFAReg){\n+       case AMD64ThreadContext.RBP -> getNextRBP(senderFP).addOffsetTo(nextDwarf.getCFAOffset());\n+       case AMD64ThreadContext.RSP -> getNextRSP().addOffsetTo(nextDwarf.getCFAOffset());\n+       default -> throw new DebuggerException(\"Unsupported CFA register: \" + nextCFAReg);\n+     };\n@@ -214,4 +180,0 @@\n-     if (finalFrame) {\n-       return null;\n-     }\n-\n@@ -230,2 +192,1 @@\n-\n-     Address nextPC = pc != null ? pc : getNextPC(dwarf != null);\n+     Address nextPC = pc != null ? pc : getNextPC();\n@@ -254,0 +215,2 @@\n+     Address nextRBP = getNextRBP(fp);\n+\n@@ -255,4 +218,14 @@\n-       Address nextCFA = getNextCFA(nextDwarf, context, fp, nextPC);\n-       return new LinuxAMD64CFrame(dbg, nextRSP, nextCFA, nextPC, nextDwarf, false, fallback);\n-     } catch (DebuggerException _) {\n-       return null;\n+       Address nextCFA = getNextCFA(nextDwarf, fp, nextPC);\n+       return isValidFrame(nextCFA, nextRBP)\n+         ? new LinuxAMD64CFrame(dbg, nextRSP, nextRBP, nextCFA, nextPC, nextDwarf, fallback)\n+         : null;\n+     } catch (DebuggerException e) {\n+       if (dbg.isSignalTrampoline(nextPC)) {\n+         \/\/ We can through the caller frame if it is signal trampoline.\n+         \/\/ getNextCFA() might fail because DwarfParser cannot find out CFA register.\n+         return new LinuxAMD64CFrame(dbg, nextRSP, nextRBP, null, nextPC, nextDwarf, fallback);\n+       }\n+\n+       \/\/ Rethrow the original exception if getNextCFA() failed\n+       \/\/ and the caller is not signal trampoline.\n+       throw e;\n@@ -282,1 +255,1 @@\n-     return new AMD64Frame(rsp, cfa, rip);\n+     return new AMD64Frame(rsp, localVariableBase(), rip);\n@@ -288,0 +261,1 @@\n+   private Address rbp;\n@@ -292,1 +266,0 @@\n-   private boolean finalFrame;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/amd64\/LinuxAMD64CFrame.java","additions":80,"deletions":107,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @bug 8374482\n+ * @bug 8374482 8376264\n@@ -64,0 +64,1 @@\n+        out.shouldContain(\"* jdk.test.lib.apps.LingeredApp.crash()\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackMixedCore.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}