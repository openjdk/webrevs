{"files":[{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/objectCountEventSender.hpp\"\n@@ -77,25 +76,0 @@\n-class ObjectCountEventSenderClosure : public KlassInfoClosure {\n-  const double _size_threshold_percentage;\n-  const size_t _total_size_in_words;\n-  const Ticks _timestamp;\n-\n- public:\n-  ObjectCountEventSenderClosure(size_t total_size_in_words, const Ticks& timestamp) :\n-    _size_threshold_percentage(ObjectCountCutOffPercent \/ 100),\n-    _total_size_in_words(total_size_in_words),\n-    _timestamp(timestamp)\n-  {}\n-\n-  virtual void do_cinfo(KlassInfoEntry* entry) {\n-    if (should_send_event(entry)) {\n-      ObjectCountEventSender::send(entry, _timestamp);\n-    }\n-  }\n-\n- private:\n-  bool should_send_event(const KlassInfoEntry* entry) const {\n-    double percentage_of_heap = ((double) entry->words()) \/ _total_size_in_words;\n-    return percentage_of_heap >= _size_threshold_percentage;\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/objectCountEventSender.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"memory\/heapInspection.hpp\"\n@@ -95,0 +97,27 @@\n+#if INCLUDE_SERVICES\n+class ObjectCountEventSenderClosure : public KlassInfoClosure {\n+  const double _size_threshold_percentage;\n+  const size_t _total_size_in_words;\n+  const Ticks _timestamp;\n+\n+ public:\n+  ObjectCountEventSenderClosure(size_t total_size_in_words, const Ticks& timestamp) :\n+    _size_threshold_percentage(ObjectCountCutOffPercent \/ 100),\n+    _total_size_in_words(total_size_in_words),\n+    _timestamp(timestamp)\n+  {}\n+\n+  virtual void do_cinfo(KlassInfoEntry* entry) {\n+    if (should_send_event(entry)) {\n+      ObjectCountEventSender::send(entry, _timestamp);\n+    }\n+  }\n+\n+ private:\n+  bool should_send_event(const KlassInfoEntry* entry) const {\n+    double percentage_of_heap = ((double) entry->words()) \/ _total_size_in_words;\n+    return percentage_of_heap >= _size_threshold_percentage;\n+  }\n+};\n+#endif \/\/ INCLUDE_SERVICES\n+\n@@ -107,0 +136,4 @@\n+  \/\/ Report object count without performing a heap inspection. This method will\n+  \/\/ only work if there's a global KlassInfoTable in the heap.\n+  template <typename T>\n+  void report_object_count() NOT_SERVICES_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.hpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+#ifndef SHARE_GC_SHARED_GCTRACE_INLINE_HPP\n+#define SHARE_GC_SHARED_GCTRACE_INLINE_HPP\n+\n+#include \"gc\/shared\/gcTrace.hpp\"\n+#include \"memory\/heapInspection.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#if INCLUDE_SERVICES\n+template <typename T>\n+void GCTracer::report_object_count() {\n+  if (!ObjectCountEventSender::should_send_event()) {\n+    return;\n+  }\n+\n+  T* heap = T::heap();\n+  KlassInfoTable* cit = heap->get_cit();\n+\n+  if (!cit->allocation_failed()) {\n+    ObjectCountEventSenderClosure event_sender(cit->size_of_instances_in_words(), Ticks::now());\n+    cit->iterate(&event_sender);\n+  }\n+}\n+#endif \/\/ INCLUDE_SERVICES\n+\n+#endif \/\/ SHARE_GC_SHARED_GCTRACE_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.inline.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/objectCountEventSender.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shared\/gcTrace.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"memory\/heapInspection.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/objectCountEventSender.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectCountClosure.hpp\"\n@@ -76,1 +77,2 @@\n-  void work(T *p);\n+  \/\/ Return true if object was not previously marked strong by another thread.\n+  bool work(T *p);\n@@ -109,0 +111,23 @@\n+#if INCLUDE_JFR\n+template <ShenandoahGenerationType GENERATION>\n+class ShenandoahMarkRefsAndCountClosure : public ShenandoahMarkRefsSuperClosure {\n+private:\n+  ShenandoahObjectCountClosure* _count;\n+  template <class T>\n+  inline void do_oop_work(T* p) {\n+    \/\/ Count newly marked strong references to avoid double counting.\n+    const bool newly_marked_strong = work<T, GENERATION>(p);\n+    if (newly_marked_strong) {\n+      _count->do_oop(p);\n+    }\n+  }\n+\n+public:\n+  ShenandoahMarkRefsAndCountClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q, ShenandoahObjectCountClosure* count) :\n+          ShenandoahMarkRefsSuperClosure(q, rp, old_q), _count(count) {};\n+\n+  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n+  virtual void do_oop(oop* p)       { do_oop_work(p); }\n+};\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.hpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -80,2 +80,2 @@\n-inline void ShenandoahMarkRefsSuperClosure::work(T* p) {\n-  ShenandoahMark::mark_through_ref<T, GENERATION>(p, _queue, _old_queue, _mark_context, _weak);\n+inline bool ShenandoahMarkRefsSuperClosure::work(T* p) {\n+  return ShenandoahMark::mark_through_ref<T, GENERATION>(p, _queue, _old_queue, _mark_context, _weak);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gcTrace.inline.hpp\"\n@@ -317,0 +318,3 @@\n+  \/\/ Do not report object count during a safepoint\n+  assert(!ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Should not be at safepoint\");\n+  heap->tracer()->report_object_count<ShenandoahHeap>();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-\n+#include \"gc\/shared\/objectCountEventSender.hpp\"\n@@ -36,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectCountClosure.hpp\"\n@@ -48,0 +49,1 @@\n+\n@@ -173,2 +175,18 @@\n-  ShenandoahMarkRefsClosure<GENERATION> cl(q, _rp, old_q);\n-  _root_scanner.roots_do(&cl, worker_id);\n+\n+#if INCLUDE_JFR\n+  \/\/ Use object counting closure if ObjectCount or ObjectCountAfterGC event is enabled.\n+  const bool object_count_enabled = ObjectCountEventSender::should_send_event();\n+  if (object_count_enabled && !ShenandoahHeap::heap()->mode()->is_generational()) {\n+    KlassInfoTable* const global_cit = ShenandoahHeap::heap()->get_cit();\n+    KlassInfoTable local_cit(false);\n+    ShenandoahIsAliveClosure is_alive;\n+    ShenandoahObjectCountClosure count(&local_cit, &is_alive);\n+    ShenandoahMarkRefsAndCountClosure<GENERATION> cl(q, _rp, old_q, &count);\n+    _root_scanner.roots_do(&cl, worker_id);\n+    count.merge_table(global_cit);\n+  } else\n+#endif \/\/ INCLUDE_JFR\n+  {\n+    ShenandoahMarkRefsClosure<GENERATION> cl(q, _rp, old_q);\n+    _root_scanner.roots_do(&cl, worker_id);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -128,0 +128,6 @@\n+      \/\/ Create the KlassInfoTable for Shenandoah only if JFR is enabled.\n+#if INCLUDE_JFR\n+      KlassInfoTable cit(false);\n+      heap->set_cit(&cit);\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -227,0 +233,1 @@\n+      JFR_ONLY(heap->set_cit(nullptr));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -536,0 +536,1 @@\n+  _cit(nullptr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"memory\/heapInspection.hpp\"\n@@ -231,1 +232,2 @@\n-\n+  \/\/ Used for JFR object count event support.\n+  KlassInfoTable* _cit;\n@@ -255,0 +257,4 @@\n+  \/\/ Setter & accessor for class histogram\n+  inline void set_cit(KlassInfoTable* cit);\n+  inline KlassInfoTable* get_cit();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"memory\/heapInspection.hpp\"\n@@ -650,0 +651,11 @@\n+inline void ShenandoahHeap::set_cit(KlassInfoTable* cit) {\n+  assert(_cit == nullptr || cit == nullptr, \"Overwriting an existing histogram\");\n+  assert(_cit != nullptr || cit != nullptr, \"Already cleared\");\n+  _cit = cit;\n+}\n+\n+inline KlassInfoTable* ShenandoahHeap::get_cit() {\n+  assert(_cit != nullptr, \"KlassInfoTable is null\");\n+  return _cit;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-\n+#include \"gc\/shared\/objectCountEventSender.hpp\"\n@@ -72,3 +72,19 @@\n-    using Closure = ShenandoahMarkRefsClosure<GENERATION>;\n-    Closure cl(q, rp, old_q);\n-    mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n+#if INCLUDE_JFR\n+    \/\/ Use object counting closure if ObjectCount or ObjectCountAfterGC event is enabled.\n+    const bool object_count_enabled = ObjectCountEventSender::should_send_event();\n+    if (object_count_enabled && !ShenandoahHeap::heap()->mode()->is_generational()) {\n+      KlassInfoTable* const global_cit = ShenandoahHeap::heap()->get_cit();\n+      KlassInfoTable local_cit(false);\n+      ShenandoahIsAliveClosure is_alive;\n+      ShenandoahObjectCountClosure count(&local_cit, &is_alive);\n+      using Closure = ShenandoahMarkRefsAndCountClosure<GENERATION>;\n+      Closure cl(q, rp, old_q, &count);\n+      mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n+      count.merge_table(global_cit);\n+    } else\n+#endif \/\/ INCLUDE_JFR\n+    {\n+      using Closure = ShenandoahMarkRefsClosure<GENERATION>;\n+      Closure cl(q, rp, old_q);\n+      mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  \/\/ Returns true if object was strongly marked.\n@@ -60,1 +61,1 @@\n-  static inline void mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak);\n+  static inline bool mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak);\n@@ -101,0 +102,1 @@\n+  \/\/ Returns true if object was strongly marked.\n@@ -102,1 +104,1 @@\n-  static void mark_non_generational_ref(T *p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak);\n+  static bool mark_non_generational_ref(T *p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak);\n@@ -104,1 +106,2 @@\n-  static void mark_ref(ShenandoahObjToScanQueue* q,\n+  \/\/ Returns true if object was strongly marked.\n+  static bool mark_ref(ShenandoahObjToScanQueue* q,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-inline void ShenandoahMark::mark_through_ref(T *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+inline bool ShenandoahMark::mark_through_ref(T *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n@@ -300,0 +300,1 @@\n+  bool strongly_marked = false;\n@@ -308,1 +309,1 @@\n-      mark_ref(q, mark_context, weak, obj);\n+      strongly_marked = mark_ref(q, mark_context, weak, obj);\n@@ -319,1 +320,1 @@\n-      mark_ref(old_q, mark_context, weak, obj);\n+      strongly_marked = mark_ref(old_q, mark_context, weak, obj);\n@@ -329,0 +330,1 @@\n+  return strongly_marked;\n@@ -332,2 +334,2 @@\n-inline void ShenandoahMark::mark_through_ref<oop, ShenandoahGenerationType::NON_GEN>(oop *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n-  mark_non_generational_ref(p, q, mark_context, weak);\n+inline bool ShenandoahMark::mark_through_ref<oop, ShenandoahGenerationType::NON_GEN>(oop *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+  return mark_non_generational_ref(p, q, mark_context, weak);\n@@ -337,2 +339,2 @@\n-inline void ShenandoahMark::mark_through_ref<narrowOop, ShenandoahGenerationType::NON_GEN>(narrowOop *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n-  mark_non_generational_ref(p, q, mark_context, weak);\n+inline bool ShenandoahMark::mark_through_ref<narrowOop, ShenandoahGenerationType::NON_GEN>(narrowOop *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+  return mark_non_generational_ref(p, q, mark_context, weak);\n@@ -342,1 +344,1 @@\n-inline void ShenandoahMark::mark_non_generational_ref(T* p, ShenandoahObjToScanQueue* q,\n+inline bool ShenandoahMark::mark_non_generational_ref(T* p, ShenandoahObjToScanQueue* q,\n@@ -345,0 +347,1 @@\n+  bool strongly_marked = false;\n@@ -351,1 +354,1 @@\n-    mark_ref(q, mark_context, weak, obj);\n+    strongly_marked = mark_ref(q, mark_context, weak, obj);\n@@ -355,0 +358,1 @@\n+  return strongly_marked;\n@@ -357,1 +361,1 @@\n-inline void ShenandoahMark::mark_ref(ShenandoahObjToScanQueue* q,\n+inline bool ShenandoahMark::mark_ref(ShenandoahObjToScanQueue* q,\n@@ -362,0 +366,1 @@\n+  bool strongly_marked = false;\n@@ -366,0 +371,1 @@\n+    strongly_marked = marked;\n@@ -371,0 +377,1 @@\n+  return strongly_marked;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,22 @@\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahObjectCountClosure.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+\n+#if INCLUDE_JFR\n+\n+void ShenandoahObjectCountClosure::merge_table(KlassInfoTable* global_cit) {\n+  assert(_cit != nullptr, \"The thread-local KlassInfoTable is not initialized\");\n+  assert(global_cit != nullptr, \"Shenandoah KlassInfoTable is not initialized\");\n+  MutexLocker x(ObjectCountMerge_lock, Mutex::_no_safepoint_check_flag);\n+  bool success = global_cit->merge(_cit);\n+\n+  \/\/ Clear the _cit in the closure to ensure it won't be used again.\n+  _cit = nullptr;\n+  assert(success, \"Failed to merge thread-local table\");\n+}\n+\n+bool ShenandoahObjectCountClosure::should_visit(oop o) {\n+  return _filter->do_object_b(o);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectCountClosure.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTCOUNTCLOSURE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTCOUNTCLOSURE_HPP\n+\n+#include \"memory\/heapInspection.hpp\"\n+#include \"oops\/access.hpp\"\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+\n+#if INCLUDE_JFR\n+\n+class ShenandoahIsAliveClosure;\n+\n+class ShenandoahObjectCountClosure {\n+private:\n+  KlassInfoTable* _cit;\n+  ShenandoahIsAliveClosure* _filter;\n+\n+  template <class T>\n+  inline void do_oop_work(T* p) {\n+    assert(p != nullptr, \"Object is null\");\n+    T o = RawAccess<>::oop_load(p);\n+    assert(!CompressedOops::is_null(o), \"CompressOops is null\");\n+    oop obj = CompressedOops::decode_not_null(o);\n+    assert(_cit != nullptr, \"KlassInfoTable is null\");\n+    if (should_visit(obj)) {\n+      _cit->record_instance(obj);\n+    }\n+  }\n+\n+public:\n+  ShenandoahObjectCountClosure(KlassInfoTable* cit, ShenandoahIsAliveClosure* is_alive) : _cit(cit), _filter(is_alive) {}\n+  \/\/ Record the object's instance in the KlassInfoTable\n+  inline void do_oop(narrowOop* o) { do_oop_work(o); }\n+  \/\/ Record the object's instance in the KlassInfoTable\n+  inline void do_oop(oop* o) { do_oop_work(o); }\n+  inline KlassInfoTable* get_table() { return _cit; }\n+<<<<<<< HEAD\n+\n+  bool should_visit(oop o);\n+\n+=======\n+  \n+  bool should_visit(oop o);\n+  \n+>>>>>>> 774f4e2b8592424f74d3fea4c509d1fc95a20c39\n+  \/\/ Merges the heap's KlassInfoTable with the thread's KlassInfoTable.\n+  \/\/ Clears the thread's table, so it won't be used again.\n+  void merge_table(KlassInfoTable* global_cit);\n+};\n+\n+#endif \/\/ INCLUDE_JFR\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTCOUNTCLOSURE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectCountClosure.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-\n+#include \"gc\/shared\/objectCountEventSender.hpp\"\n@@ -35,0 +35,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectCountClosure.hpp\"\n@@ -125,2 +126,17 @@\n-      ShenandoahMarkRefsClosure<NON_GEN> init_mark(queue, rp, nullptr);\n-      _root_scanner.roots_do(&init_mark, worker_id);\n+#if INCLUDE_JFR\n+      \/\/ Use object counting closure if ObjectCount or ObjectCountAfterGC event is enabled.\n+      const bool object_count_enabled = ObjectCountEventSender::should_send_event();\n+      if (object_count_enabled) {\n+        KlassInfoTable* const global_cit = ShenandoahHeap::heap()->get_cit();\n+        KlassInfoTable local_cit(false);\n+        ShenandoahIsAliveClosure is_alive;\n+        ShenandoahObjectCountClosure count(&local_cit, &is_alive);\n+        ShenandoahMarkRefsAndCountClosure<NON_GEN> init_mark(queue, rp, nullptr, &count);\n+        _root_scanner.roots_do(&init_mark, worker_id);\n+        count.merge_table(global_cit);\n+      } else\n+#endif \/\/ INCLUDE_JFR\n+      {\n+        ShenandoahMarkRefsClosure<NON_GEN> init_mark(queue, rp, nullptr);\n+        _root_scanner.roots_do(&init_mark, worker_id);\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/mutex.hpp\"\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+Mutex*   ObjectCountMerge_lock        = nullptr;\n@@ -249,0 +250,1 @@\n+  MUTEX_DEFN(ObjectCountMerge_lock           , PaddedMutex  , nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+extern Mutex*   ObjectCountMerge_lock;           \/\/ a lock used to synchronize merging a thread-local object count histogram into a global one\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,17 @@\n+package jdk.jfr.event.gc.objectcount;\n+import jdk.test.lib.jfr.GCHelper;\n+\n+\/**\n+ * @test\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @requires (vm.gc == \"Shenandoah\" | vm.gc == null)\n+ *           & vm.opt.ExplicitGCInvokesConcurrent != true\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:-UseFastUnorderedTimeStamps -XX:+UseShenandoahGC -XX:MarkSweepDeadRatio=0 -XX:-UseCompressedOops -XX:-UseCompressedClassPointers -XX:+IgnoreUnrecognizedVMOptions jdk.jfr.event.gc.objectcount.TestObjectCountAfterGCEventWithShenandoah\n+ *\/\n+public class TestObjectCountAfterGCEventWithShenandoah {\n+    public static void main(String[] args) throws Exception {\n+        ObjectCountAfterGCEvent.test(GCHelper.gcShenandoah);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/objectcount\/TestObjectCountAfterGCEventWithShenandoah.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -77,0 +77,1 @@\n+    public static final String gcShenandoah = \"Shenandoah\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/GCHelper.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}