{"files":[{"patch":"@@ -27,4 +27,4 @@\n-import jdk.jpackage.internal.model.LinuxPackage;\n-import jdk.jpackage.internal.model.LinuxLauncher;\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.Launcher;\n+import static jdk.jpackage.internal.ApplicationImageUtils.createLauncherIconResource;\n+import static jdk.jpackage.internal.model.LauncherShortcut.toRequest;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -48,1 +48,0 @@\n-import static jdk.jpackage.internal.ApplicationImageUtils.createLauncherIconResource;\n@@ -50,0 +49,3 @@\n+import jdk.jpackage.internal.model.LinuxLauncher;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.Package;\n@@ -53,1 +55,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -80,1 +81,1 @@\n-        boolean withDesktopFile = !associations.isEmpty() || launcher.shortcut().orElse(false);\n+        boolean withDesktopFile = !associations.isEmpty() || toRequest(launcher.shortcut()).orElse(false);\n@@ -135,1 +136,1 @@\n-                return l.shortcut().orElse(true);\n+                return toRequest(l.shortcut()).orElse(true);\n@@ -228,0 +229,3 @@\n+\n+        var installedLayout = pkg.asInstalledPackageApplicationLayout().orElseThrow();\n+\n@@ -235,2 +239,1 @@\n-                pkg.asInstalledPackageApplicationLayout().orElseThrow().launchersDirectory().resolve(\n-                        launcher.executableNameWithSuffix()).toString()));\n+                installedLayout.launchersDirectory().resolve(launcher.executableNameWithSuffix()).toString()));\n@@ -484,1 +487,1 @@\n-    private final Launcher launcher;\n+    private final LinuxLauncher launcher;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import static jdk.jpackage.internal.FromParams.findLauncherShortcut;\n@@ -33,1 +34,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n@@ -40,2 +40,0 @@\n-import java.util.Optional;\n-import java.util.stream.Stream;\n@@ -54,0 +52,1 @@\n+\n@@ -56,3 +55,1 @@\n-            final var shortcut = Stream.of(SHORTCUT_HINT, LINUX_SHORTCUT_HINT).map(param -> {\n-                return param.findIn(launcherParams);\n-            }).filter(Optional::isPresent).map(Optional::get).findFirst();\n+            final var shortcut = findLauncherShortcut(LINUX_SHORTCUT_HINT, params, launcherParams);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.HashMap;\n@@ -39,3 +40,5 @@\n-        return shortcut().map(v -> {\n-            return Map.of(\"shortcut\", Boolean.toString(v));\n-        }).orElseGet(Map::of);\n+        Map<String, String> map = new HashMap<>();\n+        shortcut().ifPresent(shortcut -> {\n+            shortcut.store(SHORTCUT_ID, map::put);\n+        });\n+        return map;\n@@ -55,0 +58,2 @@\n+\n+    public static final String SHORTCUT_ID = \"linux-shortcut\";\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxLauncher.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-     * Gets the start menu shortcut setting of this application launcher.\n+     * Gets the start menu shortcut of this application launcher.\n@@ -37,8 +37,4 @@\n-     * Returns <code>true<\/code> if this application launcher was requested to have\n-     * the start menu shortcut.\n-     * <p>\n-     * Returns <code>false<\/code> if this application launcher was requested not to\n-     * have the start menu shortcut.\n-     * <p>\n-     * Returns an empty {@link Optional} instance if there was no request about the\n-     * start menu shortcut for this application launcher.\n+     * Returns a non-empty {@link Optional} instance if a request about the start\n+     * menu shortcut for this application launcher was made and an empty\n+     * {@link Optional} instance if there was no request about the start menu\n+     * shortcut for this application launcher.\n@@ -46,1 +42,1 @@\n-     * @return the start menu shortcut setting of this application launcher\n+     * @return the start menu shortcut of this application launcher\n@@ -48,1 +44,1 @@\n-    Optional<Boolean> shortcut();\n+    Optional<LauncherShortcut> shortcut();\n@@ -53,1 +49,1 @@\n-    record Stub(Optional<Boolean> shortcut) implements LinuxLauncherMixin {\n+    record Stub(Optional<LauncherShortcut> shortcut) implements LinuxLauncherMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxLauncherMixin.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n@@ -138,1 +136,1 @@\n-            Arguments.putUnlessNull(bundleParams, SHORTCUT_HINT.getID(),\n+            Arguments.putUnlessNull(bundleParams, CLIOptions.WIN_SHORTCUT_HINT.getId(),\n@@ -140,1 +138,1 @@\n-            Arguments.putUnlessNull(bundleParams, MENU_HINT.getID(),\n+            Arguments.putUnlessNull(bundleParams, CLIOptions.WIN_MENU_HINT.getId(),\n@@ -147,1 +145,1 @@\n-            Arguments.putUnlessNull(bundleParams, SHORTCUT_HINT.getID(),\n+            Arguments.putUnlessNull(bundleParams, CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AddLauncherArguments.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import static jdk.jpackage.internal.Arguments.CLIOptions.LINUX_SHORTCUT_HINT;\n+import static jdk.jpackage.internal.Arguments.CLIOptions.WIN_MENU_HINT;\n+import static jdk.jpackage.internal.Arguments.CLIOptions.WIN_SHORTCUT_HINT;\n@@ -66,0 +69,2 @@\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n@@ -168,0 +173,26 @@\n+    static Optional<LauncherShortcut> findLauncherShortcut(\n+            BundlerParamInfo<Boolean> shortcutParam,\n+            Map<String, ? super Object> mainParams,\n+            Map<String, ? super Object> launcherParams) {\n+\n+        Optional<Boolean> launcherValue;\n+        if (launcherParams == mainParams) {\n+            \/\/ The main launcher\n+            launcherValue = Optional.empty();\n+        } else {\n+            launcherValue = shortcutParam.findIn(launcherParams);\n+        }\n+\n+        return launcherValue.map(withShortcut -> {\n+            if (withShortcut) {\n+                return Optional.of(LauncherShortcutStartupDirectory.DEFAULT);\n+            } else {\n+                return Optional.<LauncherShortcutStartupDirectory>empty();\n+            }\n+        }).or(() -> {\n+            return shortcutParam.findIn(mainParams).map(_ -> {\n+                return Optional.of(LauncherShortcutStartupDirectory.DEFAULT);\n+            });\n+        }).map(LauncherShortcut::new);\n+    }\n+\n@@ -198,2 +229,3 @@\n-        return AddLauncherArguments.merge(mainParams, launcherParams, ICON.getID(), ADD_LAUNCHERS\n-                .getID(), FILE_ASSOCIATIONS.getID());\n+        return AddLauncherArguments.merge(mainParams, launcherParams, ICON.getID(),\n+                ADD_LAUNCHERS.getID(), FILE_ASSOCIATIONS.getID(), WIN_MENU_HINT.getId(),\n+                WIN_SHORTCUT_HINT.getId(), LINUX_SHORTCUT_HINT.getId());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -310,18 +310,0 @@\n-    static final BundlerParamInfo<Boolean> SHORTCUT_HINT  =\n-            new BundlerParamInfo<>(\n-                    \"shortcut-hint\", \/\/ not directly related to a CLI option\n-                    Boolean.class,\n-                    params -> true,  \/\/ defaults to true\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                            true : Boolean.valueOf(s)\n-            );\n-\n-    static final BundlerParamInfo<Boolean> MENU_HINT  =\n-            new BundlerParamInfo<>(\n-                    \"menu-hint\", \/\/ not directly related to a CLI option\n-                    Boolean.class,\n-                    params -> true,  \/\/ defaults to true\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                            true : Boolean.valueOf(s)\n-            );\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+\n+\/**\n+ * A shortcut to launch an application launcher.\n+ *\/\n+public record LauncherShortcut(Optional<LauncherShortcutStartupDirectory> startupDirectory) {\n+\n+    public LauncherShortcut {\n+        Objects.requireNonNull(startupDirectory);\n+    }\n+\n+    public LauncherShortcut(LauncherShortcutStartupDirectory startupDirectory) {\n+        this(Optional.of(startupDirectory));\n+    }\n+\n+    public LauncherShortcut() {\n+        this(Optional.empty());\n+    }\n+\n+    void store(String propertyName, BiConsumer<String, String> sink) {\n+        Objects.requireNonNull(propertyName);\n+        Objects.requireNonNull(sink);\n+        if (startupDirectory.isEmpty()) {\n+            sink.accept(propertyName, Boolean.FALSE.toString());\n+        } else {\n+            startupDirectory.ifPresent(v -> {\n+                sink.accept(propertyName, v.asStringValue());\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Converts the given shortcut into a shortcut request.\n+     * <p>\n+     * Returns <code>true<\/code> if shortcut was explicitly requested.\n+     * <p>\n+     * Returns <code>false<\/code> if no shortcut was explicitly requested.\n+     * <p>\n+     * Returns an empty {@link Optional} instance if there was no shortcut request.\n+     *\n+     * @return shortcut request\n+     *\/\n+    public static Optional<Boolean> toRequest(Optional<LauncherShortcut> shortcut) {\n+        return shortcut.map(v -> v.startupDirectory().isPresent());\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherShortcut.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * The directory in which to run an application launcher when it is started from\n+ * a shortcut.\n+ *\/\n+public enum LauncherShortcutStartupDirectory {\n+\n+    \/**\n+     * Platform-specific default value.\n+     * <p>\n+     * On Windows, it indicates that the startup directory should be the package's\n+     * installation directory.\n+     * <p>\n+     * On Linux, it indicates that a shortcut doesn't have the startup directory\n+     * configured explicitly.\n+     *\/\n+    DEFAULT(\"true\");\n+\n+    LauncherShortcutStartupDirectory(String stringValue) {\n+        this.stringValue = Objects.requireNonNull(stringValue);\n+    }\n+\n+    public String asStringValue() {\n+        return stringValue;\n+    }\n+\n+    private final String stringValue;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherShortcutStartupDirectory.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import static java.util.stream.Collectors.toSet;\n@@ -34,1 +33,1 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;\n+import static jdk.jpackage.internal.FromParams.findLauncherShortcut;\n@@ -36,1 +35,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n@@ -39,2 +37,0 @@\n-import static jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut.WIN_SHORTCUT_DESKTOP;\n-import static jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut.WIN_SHORTCUT_START_MENU;\n@@ -44,1 +40,0 @@\n-import java.util.List;\n@@ -66,3 +61,1 @@\n-            final var shortcuts = Map.of(WIN_SHORTCUT_DESKTOP, List.of(SHORTCUT_HINT,\n-                WIN_SHORTCUT_HINT), WIN_SHORTCUT_START_MENU, List.of(MENU_HINT,\n-                        WIN_MENU_HINT)).entrySet().stream().filter(e -> {\n+            final var startMenuShortcut = findLauncherShortcut(WIN_MENU_HINT, params, launcherParams);\n@@ -70,1 +63,1 @@\n-                    final var shortcutParams = e.getValue();\n+            final var desktopShortcut = findLauncherShortcut(WIN_SHORTCUT_HINT, params, launcherParams);\n@@ -72,6 +65,1 @@\n-                    return shortcutParams.get(0).findIn(launcherParams).orElseGet(() -> {\n-                        return shortcutParams.get(1).findIn(launcherParams).orElse(false);\n-                    });\n-                }).map(Map.Entry::getKey).collect(toSet());\n-\n-            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, shortcuts));\n+            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, startMenuShortcut, desktopShortcut));\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,6 +28,3 @@\n-import jdk.jpackage.internal.model.WinLauncher;\n-import jdk.jpackage.internal.model.WinMsiPackage;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.DottedVersion;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-import jdk.jpackage.internal.util.PathGroup;\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.util.CollectionUtils.toCollection;\n+\n@@ -53,1 +50,0 @@\n-import static java.util.stream.Collectors.toMap;\n@@ -63,2 +59,0 @@\n-import static jdk.jpackage.internal.util.CollectionUtils.toCollection;\n-import jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut;\n@@ -67,0 +61,2 @@\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -68,0 +64,5 @@\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.WinLauncher;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+import jdk.jpackage.internal.util.PathGroup;\n@@ -69,1 +70,0 @@\n-import jdk.jpackage.internal.util.XmlUtils;\n@@ -71,1 +71,1 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import jdk.jpackage.internal.util.XmlUtils;\n@@ -355,1 +355,1 @@\n-    };\n+    }\n@@ -472,1 +472,12 @@\n-                    String componentId = addShortcutComponent(xml, launcherPath, folder);\n+                    var workDirectory = folder.shortcut(launcher).startupDirectory().map(v -> {\n+                        switch (v) {\n+                            case DEFAULT -> {\n+                                return INSTALLDIR;\n+                            }\n+                            default -> {\n+                                throw new AssertionError();\n+                            }\n+                        }\n+                    }).orElseThrow();\n+\n+                    String componentId = addShortcutComponent(xml, launcherPath, folder, workDirectory);\n@@ -502,1 +513,1 @@\n-            ShortcutsFolder folder) throws XMLStreamException, IOException {\n+            ShortcutsFolder folder, Path shortcutWorkDir) throws XMLStreamException, IOException {\n@@ -509,0 +520,4 @@\n+        if (!INSTALLDIR.equals(shortcutWorkDir.getName(0))) {\n+            throw throwInvalidPathException(shortcutWorkDir);\n+        }\n+\n@@ -515,1 +530,1 @@\n-            xml.writeAttribute(\"WorkingDirectory\", INSTALLDIR.toString());\n+            xml.writeAttribute(\"WorkingDirectory\", Id.Folder.of(shortcutWorkDir));\n@@ -517,2 +532,1 @@\n-            xml.writeAttribute(\"Target\", String.format(\"[#%s]\",\n-                    Component.File.idOf(launcherPath)));\n+            xml.writeAttribute(\"Target\", String.format(\"[#%s]\", Id.File.of(launcherPath)));\n@@ -909,1 +923,1 @@\n-        ProgramMenu(PROGRAM_MENU_PATH, WinShortcut.WIN_SHORTCUT_START_MENU,\n+        ProgramMenu(PROGRAM_MENU_PATH, WinLauncher::startMenuShortcut,\n@@ -911,1 +925,1 @@\n-        Desktop(DESKTOP_PATH, WinShortcut.WIN_SHORTCUT_DESKTOP,\n+        Desktop(DESKTOP_PATH, WinLauncher::desktopShortcut,\n@@ -914,1 +928,1 @@\n-        private ShortcutsFolder(Path root, WinShortcut shortcutId,\n+        private ShortcutsFolder(Path root, Function<WinLauncher, Optional<LauncherShortcut>> shortcut,\n@@ -917,1 +931,1 @@\n-            this.shortcutId = shortcutId;\n+            this.shortcut = shortcut;\n@@ -930,1 +944,5 @@\n-            return launcher.shortcuts().contains(shortcutId);\n+            return LauncherShortcut.toRequest(shortcut.apply(launcher)).orElse(false);\n+        }\n+\n+        LauncherShortcut shortcut(WinLauncher launcher) {\n+            return shortcut.apply(launcher).orElseThrow();\n@@ -950,1 +968,1 @@\n-        private final WinShortcut shortcutId;\n+        private final Function<WinLauncher, Optional<LauncherShortcut>> shortcut;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":41,"deletions":23,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import static java.util.stream.Collectors.toMap;\n-\n@@ -30,0 +28,1 @@\n+import java.util.HashMap;\n@@ -50,1 +49,8 @@\n-        return shortcuts().stream().collect(toMap(WinShortcut::name, v -> Boolean.toString(true)));\n+        Map<String, String> map = new HashMap<>();\n+        desktopShortcut().ifPresent(shortcut -> {\n+            shortcut.store(SHORTCUT_DESKTOP_ID, map::put);\n+        });\n+        startMenuShortcut().ifPresent(shortcut -> {\n+            shortcut.store(SHORTCUT_START_MENU_ID, map::put);\n+        });\n+        return map;\n@@ -56,0 +62,3 @@\n+\n+    public static final String SHORTCUT_START_MENU_ID = \"win-menu\";\n+    public static final String SHORTCUT_DESKTOP_ID = \"win-shortcut\";\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinLauncher.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.util.Set;\n+import java.util.Optional;\n@@ -33,19 +33,26 @@\n-    enum WinShortcut {\n-        WIN_SHORTCUT_DESKTOP(\"shortcut\"),\n-        WIN_SHORTCUT_START_MENU(\"menu\"),\n-        ;\n-\n-        WinShortcut(String name) {\n-            this.name = name;\n-        }\n-\n-        public String getName() {\n-            return name;\n-        }\n-\n-        private final String name;\n-    }\n-\n-    Set<WinShortcut> shortcuts();\n-\n-    record Stub(boolean isConsole, Set<WinShortcut> shortcuts) implements WinLauncherMixin {\n+    \/**\n+     * Gets the start menu shortcut of this application launcher.\n+     * <p>\n+     * Returns a non-empty {@link Optional} instance if a request about the start\n+     * menu shortcut for this application launcher was made and an empty\n+     * {@link Optional} instance if there was no request about the start menu\n+     * shortcut for this application launcher.\n+     *\n+     * @return the start menu shortcut of this application launcher\n+     *\/\n+    Optional<LauncherShortcut> startMenuShortcut();\n+\n+    \/**\n+     * Gets the desktop shortcut of this application launcher.\n+     * <p>\n+     * Returns a non-empty {@link Optional} instance if a request about the desktop\n+     * shortcut for this application launcher was made and an empty {@link Optional}\n+     * instance if there was no request about the desktop shortcut for this\n+     * application launcher.\n+     *\n+     * @return the start menu shortcut of this application launcher\n+     *\/\n+    Optional<LauncherShortcut> desktopShortcut();\n+\n+    record Stub(boolean isConsole, Optional<LauncherShortcut> startMenuShortcut,\n+            Optional<LauncherShortcut> desktopShortcut) implements WinLauncherMixin {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinLauncherMixin.java","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        return propertyName.substring(propertyName.indexOf('-') + 1);\n+        return propertyName;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherShortcut.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,5 @@\n+        VERIFY_APP_IMAGE_FILE((verifier, cmd) -> {\n+            if (cmd.isImagePackageType()) {\n+                verifier.verifyInAppImageFile(cmd);\n+            }\n+        }),\n@@ -94,1 +99,1 @@\n-                VERIFY_ICON, VERIFY_DESCRIPTION, VERIFY_INSTALLED\n+                VERIFY_ICON, VERIFY_DESCRIPTION, VERIFY_INSTALLED, VERIFY_APP_IMAGE_FILE\n@@ -282,0 +287,39 @@\n+    private void verifyInAppImageFile(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.IMAGE);\n+        if (!isMainLauncher()) {\n+            Stream<LauncherShortcut> shortcuts;\n+            if (TKit.isWindows()) {\n+                shortcuts = Stream.of(LauncherShortcut.WIN_DESKTOP_SHORTCUT, LauncherShortcut.WIN_START_MENU_SHORTCUT);\n+            } else if (TKit.isLinux()) {\n+                shortcuts = Stream.of(LauncherShortcut.LINUX_SHORTCUT);\n+            } else {\n+                shortcuts = Stream.of();\n+            }\n+\n+            var aif = AppImageFile.load(cmd.outputBundle());\n+            var aifFileName = AppImageFile.getPathInAppImage(Path.of(\"\")).getFileName();\n+\n+            var aifProps = Objects.requireNonNull(aif.addLaunchers().get(name));\n+\n+            shortcuts.forEach(shortcut -> {\n+                var recordedShortcut = aifProps.get(shortcut.appImageFilePropertyName());\n+                properties.flatMap(props -> {\n+                    return props.findProperty(shortcut.propertyName());\n+                }).ifPresentOrElse(expectedShortcut -> {\n+                    TKit.assertNotNull(recordedShortcut, String.format(\n+                            \"Check shortcut [%s] of launcher [%s] is recorded in %s file\",\n+                            shortcut, name, aifFileName));\n+                    TKit.assertEquals(\n+                            StartupDirectory.parse(expectedShortcut),\n+                            StartupDirectory.parse(recordedShortcut),\n+                            String.format(\"Check the value of shortcut [%s] of launcher [%s] recorded in %s file\",\n+                                    shortcut, name, aifFileName));\n+                }, () -> {\n+                    TKit.assertNull(recordedShortcut, String.format(\n+                            \"Check shortcut [%s] of launcher [%s] is NOT recorded in %s file\",\n+                            shortcut, name, aifFileName));\n+                });\n+            });\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"}]}