{"files":[{"patch":"@@ -1049,0 +1049,19 @@\n+\/\/ Traverses a chain of VectorMaskCast and returns the first non VectorMaskCast node.\n+\/\/\n+\/\/ Due to the unique nature of vector masks, for specific IR patterns,\n+\/\/ VectorMaskCast does not affect the output results. For example:\n+\/\/   (VectorStoreMask (VectorMaskCast ... (VectorLoadMask x))) => (x)\n+\/\/   x remains to be a bool vector with no changes.\n+\/\/ This function can be used to eliminate the VectorMaskCast in such patterns.\n+Node* VectorNode::uncast_mask(Node* n) {\n+  while (n->Opcode() == Op_VectorMaskCast) {\n+    Node* in1 = n->in(1);\n+    if (!in1->isa_Vector()) {\n+      break;\n+    }\n+    assert(n->as_Vector()->length() == in1->as_Vector()->length(), \"vector length must match\");\n+    n = in1;\n+  }\n+  return n;\n+}\n+\n@@ -1455,1 +1474,1 @@\n-  \/\/   VectorStoreMask (VectorLoadMask bv) elem_size ==> bv\n+  \/\/   VectorStoreMask (VectorMaskCast ... VectorLoadMask bv) elem_size ==> bv\n@@ -1457,2 +1476,3 @@\n-  if (in(1)->Opcode() == Op_VectorLoadMask) {\n-    return in(1)->in(1);\n+  Node* in1 = VectorNode::uncast_mask(in(1));\n+  if (in1->Opcode() == Op_VectorLoadMask && length() == in1->as_Vector()->length()) {\n+    return in1->in(1);\n@@ -1888,5 +1908,6 @@\n-  Node* in1 = in(1);\n-  \/\/ VectorMaskCast (VectorMaskCast x) => x\n-  if (in1->Opcode() == Op_VectorMaskCast &&\n-      vect_type()->eq(in1->in(1)->bottom_type())) {\n-      return in1->in(1);\n+  \/\/ (VectorMaskCast (VectorMaskCast ... x)) => (x)\n+  \/\/ If the types of the input and output nodes in a VectorMaskCast chain are\n+  \/\/ exactly the same, the intermediate VectorMaskCast nodes can be eliminated.\n+  Node* n = VectorNode::uncast_mask(this);\n+  if (vect_type()->eq(n->bottom_type())) {\n+      return n;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+  static Node* uncast_mask(Node* n);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-* @bug 8356760\n+* @bug 8356760 8370863\n@@ -28,1 +28,1 @@\n-* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n+* @summary test VectorMaskCast Identity() optimizations\n@@ -52,1 +52,4 @@\n-    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" }, applyIfCPUFeatureOr = {\"asimd\", \"true\"})\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" },\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -55,0 +58,2 @@\n+        \/\/ On NEON, VectorMaskCast nodes are eliminated by optimization pattern\n+        \/\/ (VectorStoreMask (VectorMaskCast ... (VectorLoadMask x))) => x\n@@ -69,1 +74,4 @@\n-    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" },\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -86,1 +94,2 @@\n-    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n@@ -89,1 +98,1 @@\n-        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n@@ -98,1 +107,1 @@\n-        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n@@ -103,1 +112,2 @@\n-    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 1\" },\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n@@ -106,3 +116,3 @@\n-        VectorMask<Float> mFloat128 = VectorMask.fromArray(FloatVector.SPECIES_128, mr, 0).not();\n-        VectorMask<Integer> mInt128 = mFloat128.cast(IntVector.SPECIES_128);\n-        return mInt128.trueCount();\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n+        VectorMask<Short> mShort64 = mInt128.cast(ShortVector.SPECIES_64);\n+        return mShort64.trueCount();\n@@ -114,1 +124,18 @@\n-        VectorMask<Float> mInt128 = VectorMask.fromArray(FloatVector.SPECIES_128, mr, 0).not();\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n+        Asserts.assertEquals(count, mInt128.trueCount());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static int testOneCastToSameType() {\n+        \/\/ The types before and after the only cast are the same, the cast will be eliminated.\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n+        mInt128 = mInt128.cast(IntVector.SPECIES_128);\n+        return mInt128.trueCount();\n+    }\n+\n+    @Run(test = \"testOneCastToSameType\")\n+    public static void testOneCastToSameType_runner() {\n+        int count = testOneCastToSameType();\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastIdentityTest.java","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n@@ -79,1 +80,2 @@\n-        return v.cast(ShortVector.SPECIES_128);\n+        \/\/ A not operation is introduced to prevent the cast from being optimized away.\n+        return v.not().cast(ShortVector.SPECIES_128);\n@@ -86,0 +88,1 @@\n+        mByte64 = mByte64.not();\n@@ -93,1 +96,1 @@\n-        return v.cast(IntVector.SPECIES_256);\n+        return v.not().cast(IntVector.SPECIES_256);\n@@ -100,0 +103,1 @@\n+        mByte64 = mByte64.not();\n@@ -107,1 +111,1 @@\n-        return v.cast(FloatVector.SPECIES_256);\n+        return v.not().cast(FloatVector.SPECIES_256);\n@@ -114,0 +118,1 @@\n+        mByte64 = mByte64.not();\n@@ -121,1 +126,1 @@\n-        return v.cast(LongVector.SPECIES_512);\n+        return v.not().cast(LongVector.SPECIES_512);\n@@ -128,0 +133,1 @@\n+        mByte64 = mByte64.not();\n@@ -135,1 +141,1 @@\n-       return v.cast(DoubleVector.SPECIES_512);\n+       return v.not().cast(DoubleVector.SPECIES_512);\n@@ -142,0 +148,1 @@\n+        mByte64 = mByte64.not();\n@@ -149,1 +156,1 @@\n-        return v.cast(ShortVector.SPECIES_256);\n+        return v.not().cast(ShortVector.SPECIES_256);\n@@ -156,0 +163,1 @@\n+        mByte128 = mByte128.not();\n@@ -163,1 +171,1 @@\n-        return v.cast(IntVector.SPECIES_512);\n+        return v.not().cast(IntVector.SPECIES_512);\n@@ -170,0 +178,1 @@\n+        mByte128 = mByte128.not();\n@@ -177,1 +186,1 @@\n-        return v.cast(FloatVector.SPECIES_512);\n+        return v.not().cast(FloatVector.SPECIES_512);\n@@ -184,0 +193,1 @@\n+        mByte128 = mByte128.not();\n@@ -191,1 +201,1 @@\n-        return v.cast(ShortVector.SPECIES_512);\n+        return v.not().cast(ShortVector.SPECIES_512);\n@@ -198,0 +208,1 @@\n+        mByte256 = mByte256.not();\n@@ -206,1 +217,1 @@\n-        return v.cast(IntVector.SPECIES_128);\n+        return v.not().cast(IntVector.SPECIES_128);\n@@ -213,0 +224,1 @@\n+        mShort64 = mShort64.not();\n@@ -220,1 +232,1 @@\n-        return v.cast(FloatVector.SPECIES_128);\n+        return v.not().cast(FloatVector.SPECIES_128);\n@@ -227,0 +239,1 @@\n+        mShort64 = mShort64.not();\n@@ -234,1 +247,1 @@\n-        return v.cast(LongVector.SPECIES_256);\n+        return v.not().cast(LongVector.SPECIES_256);\n@@ -241,0 +254,1 @@\n+        mShort64 = mShort64.not();\n@@ -248,1 +262,1 @@\n-        return v.cast(DoubleVector.SPECIES_256);\n+        return v.not().cast(DoubleVector.SPECIES_256);\n@@ -255,0 +269,1 @@\n+        mShort64 = mShort64.not();\n@@ -262,1 +277,1 @@\n-        return v.cast(ByteVector.SPECIES_64);\n+        return v.not().cast(ByteVector.SPECIES_64);\n@@ -269,0 +284,1 @@\n+        mShort128 = mShort128.not();\n@@ -276,1 +292,1 @@\n-        return v.cast(IntVector.SPECIES_256);\n+        return v.not().cast(IntVector.SPECIES_256);\n@@ -283,0 +299,1 @@\n+        mShort128 = mShort128.not();\n@@ -290,1 +307,1 @@\n-        return v.cast(FloatVector.SPECIES_256);\n+        return v.not().cast(FloatVector.SPECIES_256);\n@@ -297,0 +314,1 @@\n+        mShort128 = mShort128.not();\n@@ -304,1 +322,1 @@\n-        return v.cast(LongVector.SPECIES_512);\n+        return v.not().cast(LongVector.SPECIES_512);\n@@ -311,0 +329,1 @@\n+        mShort128 = mShort128.not();\n@@ -318,1 +337,1 @@\n-        return v.cast(DoubleVector.SPECIES_512);\n+        return v.not().cast(DoubleVector.SPECIES_512);\n@@ -325,0 +344,1 @@\n+        mShort128 = mShort128.not();\n@@ -332,1 +352,1 @@\n-       return v.cast(ByteVector.SPECIES_128);\n+       return v.not().cast(ByteVector.SPECIES_128);\n@@ -339,0 +359,1 @@\n+        mShort256 = mShort256.not();\n@@ -346,1 +367,1 @@\n-        return v.cast(IntVector.SPECIES_512);\n+        return v.not().cast(IntVector.SPECIES_512);\n@@ -353,0 +374,1 @@\n+        mShort256 = mShort256.not();\n@@ -360,1 +382,1 @@\n-        return v.cast(FloatVector.SPECIES_512);\n+        return v.not().cast(FloatVector.SPECIES_512);\n@@ -367,0 +389,1 @@\n+        mShort256 = mShort256.not();\n@@ -374,1 +397,1 @@\n-        return v.cast(ByteVector.SPECIES_256);\n+        return v.not().cast(ByteVector.SPECIES_256);\n@@ -381,0 +404,1 @@\n+        mShort512 = mShort512.not();\n@@ -389,1 +413,1 @@\n-        return v.cast(LongVector.SPECIES_128);\n+        return v.not().cast(LongVector.SPECIES_128);\n@@ -396,0 +420,1 @@\n+        mInt64 = mInt64.not();\n@@ -403,1 +428,1 @@\n-        return v.cast(DoubleVector.SPECIES_128);\n+        return v.not().cast(DoubleVector.SPECIES_128);\n@@ -410,0 +435,1 @@\n+        mInt64 = mInt64.not();\n@@ -417,1 +443,1 @@\n-        return v.cast(ShortVector.SPECIES_64);\n+        return v.not().cast(ShortVector.SPECIES_64);\n@@ -424,0 +450,1 @@\n+        mInt128 = mInt128.not();\n@@ -431,1 +458,1 @@\n-        return v.cast(LongVector.SPECIES_256);\n+        return v.not().cast(LongVector.SPECIES_256);\n@@ -438,0 +465,1 @@\n+        mInt128 = mInt128.not();\n@@ -445,1 +473,1 @@\n-        return v.cast(DoubleVector.SPECIES_256);\n+        return v.not().cast(DoubleVector.SPECIES_256);\n@@ -452,0 +480,1 @@\n+        mInt128 = mInt128.not();\n@@ -459,1 +488,1 @@\n-        return v.cast(ShortVector.SPECIES_128);\n+        return v.not().cast(ShortVector.SPECIES_128);\n@@ -466,0 +495,1 @@\n+        mInt256 = mInt256.not();\n@@ -473,1 +503,1 @@\n-    return v.cast(ByteVector.SPECIES_64);\n+    return v.not().cast(ByteVector.SPECIES_64);\n@@ -480,0 +510,1 @@\n+        mInt256 = mInt256.not();\n@@ -487,1 +518,1 @@\n-        return v.cast(LongVector.SPECIES_512);\n+        return v.not().cast(LongVector.SPECIES_512);\n@@ -494,0 +525,1 @@\n+        mInt256 = mInt256.not();\n@@ -501,1 +533,1 @@\n-        return v.cast(DoubleVector.SPECIES_512);\n+        return v.not().cast(DoubleVector.SPECIES_512);\n@@ -508,0 +540,1 @@\n+        mInt256 = mInt256.not();\n@@ -515,1 +548,1 @@\n-        return v.cast(ShortVector.SPECIES_256);\n+        return v.not().cast(ShortVector.SPECIES_256);\n@@ -522,0 +555,1 @@\n+        mInt512 = mInt512.not();\n@@ -529,1 +563,1 @@\n-        return v.cast(ByteVector.SPECIES_128);\n+        return v.not().cast(ByteVector.SPECIES_128);\n@@ -536,0 +570,1 @@\n+        mInt512 = mInt512.not();\n@@ -544,1 +579,1 @@\n-        return v.cast(LongVector.SPECIES_128);\n+        return v.not().cast(LongVector.SPECIES_128);\n@@ -551,0 +586,1 @@\n+        mFloat64 = mFloat64.not();\n@@ -558,1 +594,1 @@\n-        return v.cast(DoubleVector.SPECIES_128);\n+        return v.not().cast(DoubleVector.SPECIES_128);\n@@ -565,0 +601,1 @@\n+        mFloat64 = mFloat64.not();\n@@ -572,1 +609,1 @@\n-        return v.cast(ShortVector.SPECIES_64);\n+        return v.not().cast(ShortVector.SPECIES_64);\n@@ -579,0 +616,1 @@\n+        mFloat128 = mFloat128.not();\n@@ -586,1 +624,1 @@\n-        return v.cast(LongVector.SPECIES_256);\n+        return v.not().cast(LongVector.SPECIES_256);\n@@ -593,0 +631,1 @@\n+        mFloat128 = mFloat128.not();\n@@ -600,1 +639,1 @@\n-        return v.cast(DoubleVector.SPECIES_256);\n+        return v.not().cast(DoubleVector.SPECIES_256);\n@@ -607,0 +646,1 @@\n+        mFloat128 = mFloat128.not();\n@@ -614,1 +654,1 @@\n-        return v.cast(ShortVector.SPECIES_128);\n+        return v.not().cast(ShortVector.SPECIES_128);\n@@ -621,0 +661,1 @@\n+        mFloat256 = mFloat256.not();\n@@ -628,1 +669,1 @@\n-        return v.cast(ByteVector.SPECIES_64);\n+        return v.not().cast(ByteVector.SPECIES_64);\n@@ -635,0 +676,1 @@\n+        mFloat256 = mFloat256.not();\n@@ -642,1 +684,1 @@\n-        return v.cast(LongVector.SPECIES_512);\n+        return v.not().cast(LongVector.SPECIES_512);\n@@ -649,0 +691,1 @@\n+        mFloat256 = mFloat256.not();\n@@ -656,1 +699,1 @@\n-        return v.cast(DoubleVector.SPECIES_512);\n+        return v.not().cast(DoubleVector.SPECIES_512);\n@@ -663,0 +706,1 @@\n+        mFloat256 = mFloat256.not();\n@@ -670,1 +714,1 @@\n-        return v.cast(ShortVector.SPECIES_256);\n+        return v.not().cast(ShortVector.SPECIES_256);\n@@ -677,0 +721,1 @@\n+        mFloat512 = mFloat512.not();\n@@ -684,1 +729,1 @@\n-        return v.cast(ByteVector.SPECIES_128);\n+        return v.not().cast(ByteVector.SPECIES_128);\n@@ -691,0 +736,1 @@\n+        mFloat512 = mFloat512.not();\n@@ -699,1 +745,1 @@\n-        return v.cast(IntVector.SPECIES_64);\n+        return v.not().cast(IntVector.SPECIES_64);\n@@ -706,0 +752,1 @@\n+        mLong128 = mLong128.not();\n@@ -713,1 +760,1 @@\n-        return v.cast(FloatVector.SPECIES_64);\n+        return v.not().cast(FloatVector.SPECIES_64);\n@@ -720,0 +767,1 @@\n+        mLong128 = mLong128.not();\n@@ -727,1 +775,1 @@\n-        return v.cast(IntVector.SPECIES_128);\n+        return v.not().cast(IntVector.SPECIES_128);\n@@ -734,0 +782,1 @@\n+        mLong256 = mLong256.not();\n@@ -741,1 +790,1 @@\n-        return v.cast(FloatVector.SPECIES_128);\n+        return v.not().cast(FloatVector.SPECIES_128);\n@@ -748,0 +797,1 @@\n+        mLong256 = mLong256.not();\n@@ -755,1 +805,1 @@\n-       return v.cast(ShortVector.SPECIES_64);\n+       return v.not().cast(ShortVector.SPECIES_64);\n@@ -762,0 +812,1 @@\n+        mLong256 = mLong256.not();\n@@ -769,1 +820,1 @@\n-        return v.cast(IntVector.SPECIES_256);\n+        return v.not().cast(IntVector.SPECIES_256);\n@@ -776,0 +827,1 @@\n+        mLong512 = mLong512.not();\n@@ -783,1 +835,1 @@\n-        return v.cast(FloatVector.SPECIES_256);\n+        return v.not().cast(FloatVector.SPECIES_256);\n@@ -790,0 +842,1 @@\n+        mLong512 = mLong512.not();\n@@ -797,1 +850,1 @@\n-        return v.cast(ShortVector.SPECIES_128);\n+        return v.not().cast(ShortVector.SPECIES_128);\n@@ -804,0 +857,1 @@\n+        mLong512 = mLong512.not();\n@@ -811,1 +865,1 @@\n-        return v.cast(ByteVector.SPECIES_64);\n+        return v.not().cast(ByteVector.SPECIES_64);\n@@ -818,0 +872,1 @@\n+        mLong512 = mLong512.not();\n@@ -826,1 +881,1 @@\n-        return v.cast(IntVector.SPECIES_64);\n+        return v.not().cast(IntVector.SPECIES_64);\n@@ -833,0 +888,1 @@\n+        mDouble128 = mDouble128.not();\n@@ -840,1 +896,1 @@\n-        return v.cast(FloatVector.SPECIES_64);\n+        return v.not().cast(FloatVector.SPECIES_64);\n@@ -847,0 +903,1 @@\n+        mDouble128 = mDouble128.not();\n@@ -854,1 +911,1 @@\n-        return v.cast(IntVector.SPECIES_128);\n+        return v.not().cast(IntVector.SPECIES_128);\n@@ -861,0 +918,1 @@\n+        mDouble256 = mDouble256.not();\n@@ -868,1 +926,1 @@\n-        return v.cast(FloatVector.SPECIES_128);\n+        return v.not().cast(FloatVector.SPECIES_128);\n@@ -875,0 +933,1 @@\n+        mDouble256 = mDouble256.not();\n@@ -882,1 +941,1 @@\n-        return v.cast(ShortVector.SPECIES_64);\n+        return v.not().cast(ShortVector.SPECIES_64);\n@@ -889,0 +948,1 @@\n+        mDouble256 = mDouble256.not();\n@@ -896,1 +956,1 @@\n-        return v.cast(IntVector.SPECIES_256);\n+        return v.not().cast(IntVector.SPECIES_256);\n@@ -903,0 +963,1 @@\n+        mDouble512 = mDouble512.not();\n@@ -910,1 +971,1 @@\n-        return v.cast(FloatVector.SPECIES_256);\n+        return v.not().cast(FloatVector.SPECIES_256);\n@@ -917,0 +978,1 @@\n+        mDouble512 = mDouble512.not();\n@@ -924,1 +986,1 @@\n-        return v.cast(ShortVector.SPECIES_128);\n+        return v.not().cast(ShortVector.SPECIES_128);\n@@ -931,0 +993,1 @@\n+        mDouble512 = mDouble512.not();\n@@ -938,1 +1001,1 @@\n-        return v.cast(ByteVector.SPECIES_64);\n+        return v.not().cast(ByteVector.SPECIES_64);\n@@ -945,0 +1008,1 @@\n+        mDouble512 = mDouble512.not();\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastTest.java","additions":126,"deletions":62,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -240,0 +240,3 @@\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeature = { \"svebitperm\", \"true\" })\n@@ -242,1 +245,4 @@\n-        applyIfCPUFeatureOr = { \"svebitperm\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n@@ -254,0 +260,3 @@\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeature = { \"svebitperm\", \"true\" })\n@@ -256,1 +265,4 @@\n-        applyIfCPUFeatureOr = { \"svebitperm\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LONG_TO_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 0\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskToLongTest.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8370863\n+* @library \/test\/lib \/\n+* @summary VectorStoreMaskNode Identity optimization tests\n+* @modules jdk.incubator.vector\n+*\n+* @run driver compiler.vectorapi.VectorStoreMaskIdentityTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+public class VectorStoreMaskIdentityTest {\n+    private static final int LENGTH = 256; \/\/ large enough\n+    private static boolean[] mask_in;\n+    private static boolean[] mask_out;\n+    static {\n+        mask_in = new boolean[LENGTH];\n+        mask_out = new boolean[LENGTH];\n+        for (int i = 0; i < LENGTH; i++) {\n+            mask_in[i] = (i & 3) == 0;\n+        }\n+    }\n+\n+    @ForceInline\n+    private static void testOneCastKernel(VectorSpecies<?> from_species,\n+                                          VectorSpecies<?> to_species) {\n+        VectorMask.fromArray(from_species, mask_in, 0)\n+                  .cast(to_species).intoArray(mask_out, 0);\n+    }\n+\n+    @ForceInline\n+    private static void testTwoCastsKernel(VectorSpecies<?> from_species,\n+                                           VectorSpecies<?> to_species1,\n+                                           VectorSpecies<?> to_species2) {\n+        VectorMask.fromArray(from_species, mask_in, 0)\n+                  .cast(to_species1)\n+                  .cast(to_species2).intoArray(mask_out, 0);\n+    }\n+\n+    @ForceInline\n+    private static void testThreeCastsKernel(VectorSpecies<?> from_species,\n+                                             VectorSpecies<?> to_species1,\n+                                             VectorSpecies<?> to_species2,\n+                                             VectorSpecies<?> to_species3) {\n+        VectorMask.fromArray(from_species, mask_in, 0)\n+                  .cast(to_species1)\n+                  .cast(to_species2)\n+                  .cast(to_species3).intoArray(mask_out, 0);\n+    }\n+\n+    @DontInline\n+    private static void verifyResult(int vlen) {\n+        for (int i = 0; i < vlen; i++) {\n+            Asserts.assertEquals(mask_in[i], mask_out[i], \"index \" + i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\" })\n+    public static void testVectorMaskStoreIdentityByte() {\n+        testOneCastKernel(ByteVector.SPECIES_64, ShortVector.SPECIES_128);\n+        verifyResult(ByteVector.SPECIES_64.length());\n+\n+        testTwoCastsKernel(ByteVector.SPECIES_64, ShortVector.SPECIES_128, ByteVector.SPECIES_64);\n+        verifyResult(ByteVector.SPECIES_64.length());\n+\n+        testThreeCastsKernel(ByteVector.SPECIES_64, ShortVector.SPECIES_128, ByteVector.SPECIES_64, ShortVector.SPECIES_128);\n+        verifyResult(ByteVector.SPECIES_64.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\" },\n+        applyIf = { \"MaxVectorSize\", \">16\" })\n+    public static void testVectorMaskStoreIdentityByte256() {\n+        testOneCastKernel(ByteVector.SPECIES_64, IntVector.SPECIES_256);\n+        verifyResult(ByteVector.SPECIES_64.length());\n+\n+        testTwoCastsKernel(ByteVector.SPECIES_64, ShortVector.SPECIES_128, IntVector.SPECIES_256);\n+        verifyResult(ByteVector.SPECIES_64.length());\n+\n+        testThreeCastsKernel(ByteVector.SPECIES_64, ShortVector.SPECIES_128, FloatVector.SPECIES_256, IntVector.SPECIES_256);\n+        verifyResult(ByteVector.SPECIES_64.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\" })\n+    public static void testVectorMaskStoreIdentityShort() {\n+        testOneCastKernel(ShortVector.SPECIES_128, ByteVector.SPECIES_64);\n+        verifyResult(ShortVector.SPECIES_128.length());\n+\n+        testTwoCastsKernel(ShortVector.SPECIES_64, IntVector.SPECIES_128, ShortVector.SPECIES_64);\n+        verifyResult(ShortVector.SPECIES_64.length());\n+\n+        testThreeCastsKernel(ShortVector.SPECIES_128, ByteVector.SPECIES_64, ShortVector.SPECIES_128, ByteVector.SPECIES_64);\n+        verifyResult(ShortVector.SPECIES_128.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\" },\n+        applyIf = { \"MaxVectorSize\", \">16\" })\n+    public static void testVectorMaskStoreIdentityShort256() {\n+        testOneCastKernel(ShortVector.SPECIES_128, IntVector.SPECIES_256);\n+        verifyResult(ShortVector.SPECIES_128.length());\n+\n+        testTwoCastsKernel(ShortVector.SPECIES_64, IntVector.SPECIES_128, LongVector.SPECIES_256);\n+        verifyResult(ShortVector.SPECIES_64.length());\n+\n+        testThreeCastsKernel(ShortVector.SPECIES_128, ByteVector.SPECIES_64, FloatVector.SPECIES_256, IntVector.SPECIES_256);\n+        verifyResult(ShortVector.SPECIES_128.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\" })\n+    public static void testVectorMaskStoreIdentityInt() {\n+        testOneCastKernel(IntVector.SPECIES_MAX, FloatVector.SPECIES_MAX);\n+        verifyResult(IntVector.SPECIES_MAX.length());\n+\n+        testTwoCastsKernel(IntVector.SPECIES_128, ShortVector.SPECIES_64, FloatVector.SPECIES_128);\n+        verifyResult(IntVector.SPECIES_128.length());\n+\n+        testThreeCastsKernel(IntVector.SPECIES_128, ShortVector.SPECIES_64, FloatVector.SPECIES_128, ShortVector.SPECIES_64);\n+        verifyResult(IntVector.SPECIES_128.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\" },\n+        applyIf = { \"MaxVectorSize\", \">16\" })\n+    public static void testVectorMaskStoreIdentityInt256() {\n+        testOneCastKernel(IntVector.SPECIES_MAX, FloatVector.SPECIES_MAX);\n+        verifyResult(IntVector.SPECIES_MAX.length());\n+\n+        testTwoCastsKernel(IntVector.SPECIES_128, ShortVector.SPECIES_64, LongVector.SPECIES_256);\n+        verifyResult(IntVector.SPECIES_128.length());\n+\n+        testThreeCastsKernel(IntVector.SPECIES_128, ShortVector.SPECIES_64, FloatVector.SPECIES_128, LongVector.SPECIES_256);\n+        verifyResult(IntVector.SPECIES_128.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\" })\n+    public static void testVectorMaskStoreIdentityLong() {\n+        testOneCastKernel(LongVector.SPECIES_MAX, DoubleVector.SPECIES_MAX);\n+        verifyResult(LongVector.SPECIES_MAX.length());\n+\n+        testTwoCastsKernel(LongVector.SPECIES_128, IntVector.SPECIES_64, DoubleVector.SPECIES_128);\n+        verifyResult(LongVector.SPECIES_128.length());\n+\n+        testThreeCastsKernel(LongVector.SPECIES_128, IntVector.SPECIES_64, DoubleVector.SPECIES_128, IntVector.SPECIES_64);\n+        verifyResult(LongVector.SPECIES_128.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\" },\n+        applyIf = { \"MaxVectorSize\", \">16\" })\n+    public static void testVectorMaskStoreIdentityLong256() {\n+        testOneCastKernel(LongVector.SPECIES_MAX, DoubleVector.SPECIES_MAX);\n+        verifyResult(LongVector.SPECIES_MAX.length());\n+\n+        testTwoCastsKernel(LongVector.SPECIES_256, IntVector.SPECIES_128, ShortVector.SPECIES_64);\n+        verifyResult(LongVector.SPECIES_256.length());\n+\n+        testThreeCastsKernel(LongVector.SPECIES_256, IntVector.SPECIES_128, FloatVector.SPECIES_128, ShortVector.SPECIES_64);\n+        verifyResult(LongVector.SPECIES_256.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\" })\n+    public static void testVectorMaskStoreIdentityFloat() {\n+        testOneCastKernel(FloatVector.SPECIES_MAX, IntVector.SPECIES_MAX);\n+        verifyResult(FloatVector.SPECIES_MAX.length());\n+\n+        testTwoCastsKernel(FloatVector.SPECIES_128, ShortVector.SPECIES_64, IntVector.SPECIES_128);\n+        verifyResult(FloatVector.SPECIES_128.length());\n+\n+        testThreeCastsKernel(FloatVector.SPECIES_128, ShortVector.SPECIES_64, IntVector.SPECIES_128, ShortVector.SPECIES_64);\n+        verifyResult(FloatVector.SPECIES_128.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\" },\n+        applyIf = { \"MaxVectorSize\", \">16\" })\n+    public static void testVectorMaskStoreIdentityFloat256() {\n+        testOneCastKernel(FloatVector.SPECIES_MAX, IntVector.SPECIES_MAX);\n+        verifyResult(FloatVector.SPECIES_MAX.length());\n+\n+        testTwoCastsKernel(FloatVector.SPECIES_128, ShortVector.SPECIES_64, LongVector.SPECIES_256);\n+        verifyResult(FloatVector.SPECIES_128.length());\n+\n+        testThreeCastsKernel(FloatVector.SPECIES_128, ShortVector.SPECIES_64, IntVector.SPECIES_128, LongVector.SPECIES_256);\n+        verifyResult(FloatVector.SPECIES_128.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\" })\n+    public static void testVectorMaskStoreIdentityDouble() {\n+        testOneCastKernel(DoubleVector.SPECIES_MAX, LongVector.SPECIES_MAX);\n+        verifyResult(DoubleVector.SPECIES_MAX.length());\n+\n+        testTwoCastsKernel(DoubleVector.SPECIES_128, IntVector.SPECIES_64, LongVector.SPECIES_128);\n+        verifyResult(DoubleVector.SPECIES_128.length());\n+\n+        testThreeCastsKernel(DoubleVector.SPECIES_128, IntVector.SPECIES_64, LongVector.SPECIES_128, IntVector.SPECIES_64);\n+        verifyResult(DoubleVector.SPECIES_128.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n+                   IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 0\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\" },\n+        applyIf = { \"MaxVectorSize\", \">16\" })\n+    public static void testVectorMaskStoreIdentityDouble256() {\n+        testOneCastKernel(DoubleVector.SPECIES_MAX, LongVector.SPECIES_MAX);\n+        verifyResult(DoubleVector.SPECIES_MAX.length());\n+\n+        testTwoCastsKernel(DoubleVector.SPECIES_256, ShortVector.SPECIES_64, IntVector.SPECIES_128);\n+        verifyResult(DoubleVector.SPECIES_256.length());\n+\n+        testThreeCastsKernel(DoubleVector.SPECIES_256, ShortVector.SPECIES_64, LongVector.SPECIES_256, IntVector.SPECIES_128);\n+        verifyResult(DoubleVector.SPECIES_256.length());\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorStoreMaskIdentityTest.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ *  Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 1, jvmArgs = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorStoreMaskBenchmark {\n+    static final int LENGTH = 256;\n+    static final boolean[] mask_arr = new boolean[LENGTH];\n+    static {\n+        for (int i = 0; i < LENGTH; i++) {\n+            mask_arr[i] = (i & 1) == 0;\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public <E, F> void maskLoadCastStoreKernel(VectorSpecies<E> species_from, VectorSpecies<F> species_to) {\n+        for (int i = 0; i < LENGTH; i += species_from.length()) {\n+            VectorMask<E> mask_from = VectorMask.fromArray(species_from, mask_arr, i);\n+            VectorMask<F> mask_to = mask_from.cast(species_to);\n+            mask_to.intoArray(mask_arr, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microMaskLoadCastStoreByte64() {\n+        maskLoadCastStoreKernel(ByteVector.SPECIES_64, ShortVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public void microMaskLoadCastStoreShort64() {\n+        maskLoadCastStoreKernel(ShortVector.SPECIES_64, IntVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public void microMaskLoadCastStoreInt128() {\n+        maskLoadCastStoreKernel(IntVector.SPECIES_128, ShortVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public void microMaskLoadCastStoreLong128() {\n+        maskLoadCastStoreKernel(LongVector.SPECIES_128, IntVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public void microMaskLoadCastStoreFloat128() {\n+        maskLoadCastStoreKernel(FloatVector.SPECIES_128, ShortVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public void microMaskLoadCastStoreDouble128() {\n+        maskLoadCastStoreKernel(DoubleVector.SPECIES_128, IntVector.SPECIES_64);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorStoreMaskBenchmark.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}