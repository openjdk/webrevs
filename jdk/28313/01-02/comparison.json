{"files":[{"patch":"@@ -51,21 +51,2 @@\n-    @Test\n-    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" },\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 0\" },\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    public static int testTwoCastToDifferentType() {\n-        \/\/ The types before and after the two casts are not the same, so the cast cannot be eliminated.\n-        \/\/ On NEON, VectorMaskCast nodes are eliminated by optimization pattern\n-        \/\/ (VectorStoreMask (VectorMaskCast ... (VectorLoadMask x))) => x\n-        VectorMask<Float> mFloat64 = VectorMask.fromArray(FloatVector.SPECIES_64, mr, 0);\n-        VectorMask<Double> mDouble128 = mFloat64.cast(DoubleVector.SPECIES_128);\n-        VectorMask<Integer> mInt64 = mDouble128.cast(IntVector.SPECIES_64);\n-        return mInt64.trueCount();\n-    }\n-\n-    @Run(test = \"testTwoCastToDifferentType\")\n-    public static void testTwoCastToDifferentType_runner() {\n-        int count = testTwoCastToDifferentType();\n-        VectorMask<Float> mFloat64 = VectorMask.fromArray(FloatVector.SPECIES_64, mr, 0);\n-        Asserts.assertEquals(count, mFloat64.trueCount());\n-    }\n+    \/\/ The types before and after the cast sequence are the same,\n+    \/\/ so the casts will be eliminated.\n@@ -74,2 +55,0 @@\n-    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" },\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -77,3 +56,3 @@\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    public static int testTwoCastToDifferentType2() {\n-        \/\/ The types before and after the two casts are not the same, so the cast cannot be eliminated.\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\" },\n+        applyIf = { \"MaxVectorSize\", \">= 16\" })\n+    public static int testOneCastToSameType() {\n@@ -81,3 +60,4 @@\n-        VectorMask<Double> mDouble256 = mInt128.cast(DoubleVector.SPECIES_256);\n-        VectorMask<Short>  mShort64 = mDouble256.cast(ShortVector.SPECIES_64);\n-        return mShort64.trueCount();\n+        mInt128 = mInt128.cast(IntVector.SPECIES_128);\n+        \/\/ Insert a not() to prevent the casts being optimized by the optimization:\n+        \/\/ (VectorStoreMask (VectorMaskCast ... (VectorLoadMask x))) => x\n+        return mInt128.not().trueCount();\n@@ -86,3 +66,3 @@\n-    @Run(test = \"testTwoCastToDifferentType2\")\n-    public static void testTwoCastToDifferentType2_runner() {\n-        int count = testTwoCastToDifferentType2();\n+    @Run(test = \"testOneCastToSameType\")\n+    public static void testOneCastToSameType_runner() {\n+        int count = testOneCastToSameType();\n@@ -90,1 +70,1 @@\n-        Asserts.assertEquals(count, mInt128.trueCount());\n+        Asserts.assertEquals(count, mInt128.not().trueCount());\n@@ -95,1 +75,2 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\" },\n+        applyIf = { \"MaxVectorSize\", \">= 16\" })\n@@ -97,2 +78,1 @@\n-        \/\/ The types before and after the two casts are the same, so the cast will be eliminated.\n-        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n@@ -101,1 +81,1 @@\n-        return mInt128_2.trueCount();\n+        return mInt128_2.not().trueCount();\n@@ -107,2 +87,2 @@\n-        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n-        Asserts.assertEquals(count, mInt128.trueCount());\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        Asserts.assertEquals(count, mInt128.not().trueCount());\n@@ -111,0 +91,3 @@\n+    \/\/ The types before and after the cast sequence are different,\n+    \/\/ so the casts will not be eliminated.\n+\n@@ -113,1 +96,2 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\" },\n+        applyIf = { \"MaxVectorSize\", \">= 16\" })\n@@ -115,2 +99,1 @@\n-        \/\/ The types before and after the only cast are different, the cast will not be eliminated.\n-        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n@@ -118,1 +101,1 @@\n-        return mShort64.trueCount();\n+        return mShort64.not().trueCount();\n@@ -124,2 +107,2 @@\n-        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n-        Asserts.assertEquals(count, mInt128.trueCount());\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0);\n+        Asserts.assertEquals(count, mInt128.not().trueCount());\n@@ -129,7 +112,8 @@\n-    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 0\" },\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    public static int testOneCastToSameType() {\n-        \/\/ The types before and after the only cast are the same, the cast will be eliminated.\n-        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n-        mInt128 = mInt128.cast(IntVector.SPECIES_128);\n-        return mInt128.trueCount();\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\" },\n+        applyIf = { \"MaxVectorSize\", \">= 16\" })\n+    public static int testTwoCastToDifferentType() {\n+        VectorMask<Short> mShort64 = VectorMask.fromArray(ShortVector.SPECIES_64, mr, 0);\n+        VectorMask<Float> mFloat128 = mShort64.cast(FloatVector.SPECIES_128);\n+        VectorMask<Integer> mInt128 = mFloat128.cast(IntVector.SPECIES_128);\n+        return mInt128.not().trueCount();\n@@ -138,5 +122,5 @@\n-    @Run(test = \"testOneCastToSameType\")\n-    public static void testOneCastToSameType_runner() {\n-        int count = testOneCastToSameType();\n-        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mr, 0).not();\n-        Asserts.assertEquals(count, mInt128.trueCount());\n+    @Run(test = \"testTwoCastToDifferentType\")\n+    public static void testTwoCastToDifferentType_runner() {\n+        int count = testTwoCastToDifferentType();\n+        VectorMask<Short> mShort64 = VectorMask.fromArray(ShortVector.SPECIES_64, mr, 0);\n+        Asserts.assertEquals(count, mShort64.not().trueCount());\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastIdentityTest.java","additions":41,"deletions":57,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -239,0 +239,13 @@\n+    \/\/ Test VectorMask.fromLong().toLong() with Float species.\n+    \/\/ For floating-point types, VectorMaskCast is inserted between fromLong and toLong to convert\n+    \/\/ between float and integer types. There are two relevant optimizations:\n+    \/\/   1. (VectorStoreMask (VectorMaskCast ... (VectorLoadMask x))) => (x)\n+    \/\/   2. (VectorMaskToLong (VectorLongToMask x)) => (x)\n+    \/\/ The optimization behavior varies by architecture:\n+    \/\/ - SVE with bitperm: IR chain is (VectorMaskToLong (VectorStoreMask (VectorMaskCast\n+    \/\/   (VectorLoadMask (VectorLongToMask x))))), so both optimizations are triggered.\n+    \/\/ - AVX-512\/RVV: IR pattern is (VectorMaskToLong (VectorMaskCast (VectorLongToMask x))),\n+    \/\/   so neither optimization is triggered.\n+    \/\/ - AVX2: Same as SVE with bitperm, both optimizations are triggered.\n+    \/\/ - ASIMD (without SVE bitperm): VectorLongToMaskNode is not supported,\n+    \/\/   so neither optimization is triggered.\n@@ -259,0 +272,2 @@\n+    \/\/ Test VectorMask.fromLong().toLong() with Double species.\n+    \/\/ Same as testFromLongToLongFloat() - see comments there for detailed explanation.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskToLongTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}