{"files":[{"patch":"@@ -1142,9 +1142,11 @@\n-        \/\/ If there is an old version we're done with it\n-        nmethod* old = method->code();\n-        if (TraceMethodReplacement && old != nullptr) {\n-          ResourceMark rm;\n-          char *method_name = method->name_and_sig_as_C_string();\n-          tty->print_cr(\"Replacing method %s\", method_name);\n-        }\n-        if (old != nullptr) {\n-          old->make_not_used();\n+        if (TieredCompilation) {\n+          \/\/ If there is an old version we're done with it\n+          nmethod* old = method->code();\n+          if (TraceMethodReplacement && old != nullptr) {\n+            ResourceMark rm;\n+            char *method_name = method->name_and_sig_as_C_string();\n+            tty->print_cr(\"Replacing method %s\", method_name);\n+          }\n+          if (old != nullptr) {\n+            old->make_not_used();\n+          }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"compiler\/compilerDirectives.hpp\"\n@@ -1333,61 +1332,0 @@\n-void CodeCache::mark_directives_matches(bool top_only) {\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  Thread *thread = Thread::current();\n-  HandleMark hm(thread);\n-\n-  NMethodIterator iter(NMethodIterator::not_unloading);\n-  while(iter.next()) {\n-    nmethod* nm = iter.method();\n-    methodHandle mh(thread, nm->method());\n-    if (DirectivesStack::hasMatchingDirectives(mh, top_only)) {\n-      ResourceMark rm;\n-      log_trace(codecache)(\"Mark because of matching directives %s\", mh->external_name());\n-      mh->set_has_matching_directives();\n-    }\n-  }\n-}\n-\n-void CodeCache::recompile_marked_directives_matches() {\n-  Thread *thread = Thread::current();\n-  HandleMark hm(thread);\n-\n-  \/\/ Try the max level and let the directives be applied during the compilation.\n-  int comp_level = CompilationPolicy::highest_compile_level();\n-  RelaxedNMethodIterator iter(RelaxedNMethodIterator::not_unloading);\n-  while(iter.next()) {\n-    nmethod* nm = iter.method();\n-    methodHandle mh(thread, nm->method());\n-    if (mh->has_matching_directives()) {\n-      ResourceMark rm;\n-      mh->clear_directive_flags();\n-      bool deopt = false;\n-\n-      if (!nm->is_osr_method()) {\n-        log_trace(codecache)(\"Recompile to level %d because of matching directives %s\",\n-                             comp_level, mh->external_name());\n-        nmethod * comp_nm = CompileBroker::compile_method(mh, InvocationEntryBci, comp_level,\n-                                                          methodHandle(), 0,\n-                                                          CompileTask::Reason_DirectivesChanged,\n-                                                          (JavaThread*)thread);\n-        if (comp_nm == nullptr) {\n-          log_trace(codecache)(\"Recompilation to level %d failed, deoptimize %s\",\n-                               comp_level, mh->external_name());\n-          deopt = true;\n-        }\n-      } else {\n-        log_trace(codecache)(\"Deoptimize OSR %s\", mh->external_name());\n-        deopt = true;\n-      }\n-      \/\/ For some reason the method cannot be compiled by C2, e.g. the new directives forbid it.\n-      \/\/ Deoptimize the method and let the usual hotspot logic do the rest.\n-      if (deopt) {\n-        if (!nm->has_been_deoptimized() && nm->can_be_deoptimized()) {\n-          nm->make_not_entrant();\n-          nm->make_deoptimized();\n-        }\n-      }\n-      gc_on_allocation(); \/\/ Flush unused methods from CodeCache if required.\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -298,3 +298,0 @@\n-  static void mark_directives_matches(bool top_only = false);\n-  static void recompile_marked_directives_matches();\n-\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1175,7 +1175,5 @@\n-  if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n-    \/\/ A request has been made for compilation.  Before we do any\n-    \/\/ real work, check to see if the method has been compiled\n-    \/\/ in the meantime with a definitive result.\n-    if (compilation_is_complete(method, osr_bci, comp_level)) {\n-      return;\n-    }\n+  \/\/ A request has been made for compilation.  Before we do any\n+  \/\/ real work, check to see if the method has been compiled\n+  \/\/ in the meantime with a definitive result.\n+  if (compilation_is_complete(method, osr_bci, comp_level)) {\n+    return;\n@@ -1226,7 +1224,5 @@\n-    if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n-      \/\/ We need to check again to see if the compilation has\n-      \/\/ completed.  A previous compilation may have registered\n-      \/\/ some result.\n-      if (compilation_is_complete(method, osr_bci, comp_level)) {\n-        return;\n-      }\n+    \/\/ We need to check again to see if the compilation has\n+    \/\/ completed.  A previous compilation may have registered\n+    \/\/ some result.\n+    if (compilation_is_complete(method, osr_bci, comp_level)) {\n+      return;\n@@ -1381,1 +1377,1 @@\n-    if (method_code != nullptr && (compile_reason != CompileTask::Reason_DirectivesChanged)) {\n+    if (method_code != nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-      Reason_DirectivesChanged, \/\/ Changed CompilerDirectivesStack\n@@ -78,2 +77,1 @@\n-      \"bootstrap\",\n-      \"directives_changed\"\n+      \"bootstrap\"\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -750,19 +750,0 @@\n-bool DirectivesStack::hasMatchingDirectives(const methodHandle& method, bool top_only) {\n-  assert(_depth > 0, \"Must never be empty\");\n-  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n-\n-  CompilerDirectives* dir = _top;\n-  assert(dir != nullptr, \"Must be initialized\");\n-\n-  while (dir != nullptr) {\n-    if (!dir->is_default_directive() && dir->match(method)) {\n-      return true;\n-    }\n-    if (top_only) {\n-      break;\n-    }\n-    dir = dir->next();\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-  static bool hasMatchingDirectives(const methodHandle& method, bool top_only = false);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -814,8 +814,0 @@\n-  \/\/ Clear the flags related to compiler directives that were set by the compilerBroker,\n-  \/\/ because the directives can be updated.\n-  void clear_directive_flags() {\n-    set_has_matching_directives(false);\n-    clear_is_not_c1_compilable();\n-    clear_is_not_c2_compilable();\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-   status(has_matching_directives     , 1 << 16) \/* Temporary mark, used only when methods are to be refreshed to reflect a compiler directives update *\/ \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+  MUTEX_DEFN(DirectivesStack_lock            , PaddedMutex  , nosafepoint);\n@@ -328,1 +329,0 @@\n-  MUTEX_DEFL(DirectivesStack_lock           , PaddedMutex  , CodeCache_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,0 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesReplaceDCmd>(full_export, true, false));\n@@ -927,3 +926,1 @@\n-  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n+  _filename(\"filename\",\"Name of the directives file\", \"STRING\",true) {\n@@ -931,1 +928,0 @@\n-  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -936,37 +932,0 @@\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches(true);\n-    CodeCache::recompile_marked_directives_matches();\n-  }\n-}\n-\n-CompilerDirectivesReplaceDCmd::CompilerDirectivesReplaceDCmd(outputStream* output, bool heap) :\n-                           DCmdWithParser(output, heap),\n-  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n-  _dcmdparser.add_dcmd_argument(&_filename);\n-  _dcmdparser.add_dcmd_option(&_refresh);\n-}\n-\n-void CompilerDirectivesReplaceDCmd::execute(DCmdSource source, TRAPS) {\n-  \/\/ Need to mark the methods twice, to account for the method that doesn't match\n-  \/\/ the directives anymore\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches();\n-\n-    DirectivesStack::clear();\n-    DirectivesParser::parse_from_file(_filename.value(), output(), true);\n-\n-    CodeCache::mark_directives_matches();\n-    CodeCache::recompile_marked_directives_matches();\n-  } else {\n-    DirectivesStack::clear();\n-    DirectivesParser::parse_from_file(_filename.value(), output(), true);\n-  }\n-}\n-\n-CompilerDirectivesRemoveDCmd::CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) :\n-                           DCmdWithParser(output, heap),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n-  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -976,14 +935,1 @@\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches(true);\n-    DirectivesStack::pop(1);\n-    CodeCache::recompile_marked_directives_matches();\n-  } else {\n-    DirectivesStack::pop(1);\n-  }\n-}\n-\n-CompilerDirectivesClearDCmd::CompilerDirectivesClearDCmd(outputStream* output, bool heap) :\n-                           DCmdWithParser(output, heap),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n-  _dcmdparser.add_dcmd_option(&_refresh);\n+  DirectivesStack::pop(1);\n@@ -993,7 +939,1 @@\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches();\n-    DirectivesStack::clear();\n-    CodeCache::recompile_marked_directives_matches();\n-  } else {\n-    DirectivesStack::clear();\n-  }\n+  DirectivesStack::clear();\n@@ -1001,1 +941,0 @@\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":64,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -691,3 +691,1 @@\n-class CompilerDirectivesRemoveDCmd : public DCmdWithParser {\n-protected:\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n+class CompilerDirectivesRemoveDCmd : public DCmd {\n@@ -695,2 +693,1 @@\n-  static int num_arguments() { return 1; }\n-  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap);\n+  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n@@ -717,1 +714,0 @@\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n@@ -719,1 +715,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 1; }\n@@ -738,27 +734,1 @@\n-class CompilerDirectivesReplaceDCmd : public DCmdWithParser {\n-protected:\n-  DCmdArgument<char*> _filename;\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n-public:\n-  static int num_arguments() { return 2; }\n-  CompilerDirectivesReplaceDCmd(outputStream* output, bool heap);\n-  static const char* name() {\n-    return \"Compiler.directives_replace\";\n-  }\n-  static const char* description() {\n-    return \"Clear directives stack, and load new compiler directives from file.\";\n-  }\n-  static const char* impact() {\n-    return \"Low\";\n-  }\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", NULL};\n-    return p;\n-  }\n-  virtual void execute(DCmdSource source, TRAPS);\n-};\n-\n-class CompilerDirectivesClearDCmd : public DCmdWithParser {\n-protected:\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n+class CompilerDirectivesClearDCmd : public DCmd {\n@@ -766,2 +736,1 @@\n-  static int num_arguments() { return 1; }\n-  CompilerDirectivesClearDCmd(outputStream* output, bool heap);\n+  CompilerDirectivesClearDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":5,"deletions":36,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,8 +95,0 @@\n-        if (count != 3) {\n-            Assert.fail(\"Expected three directives - found \" + count);\n-        }\n-\n-        \/\/ Test replacement with some directives from file\n-        output = executor.execute(\"Compiler.directives_replace \" + filename);\n-        output = executor.execute(\"Compiler.directives_print\");\n-        count = find(output, \"Directive:\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerDirectivesDCMDTest.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2023, BELLSOFT. All rights reserved.\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test DirectivesRefreshTest\n- * @summary Test of forced recompile after compiler directives changes by diagnostic command\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *                   -XX:-BackgroundCompilation\n- *                   serviceability.dcmd.compiler.DirectivesRefreshTest\n- *\/\n-\n-package serviceability.dcmd.compiler;\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.dcmd.CommandExecutor;\n-import jdk.test.lib.dcmd.JMXExecutor;\n-\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.lang.reflect.Method;\n-import java.util.Random;\n-\n-import static jdk.test.lib.Asserts.assertEQ;\n-\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_NONE;\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE;\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n-\n-public class DirectivesRefreshTest {\n-\n-    static Path cmdPath = Paths.get(System.getProperty(\"test.src\", \".\"), \"refresh_control.txt\");\n-    static WhiteBox wb = WhiteBox.getWhiteBox();\n-    static Random random = new Random();\n-\n-    static Method method;\n-    static CommandExecutor executor;\n-\n-    static int callable() {\n-        int result = 0;\n-        for (int i = 0; i < 100; i++) {\n-            result += random.nextInt(100);\n-        }\n-        return result;\n-    }\n-\n-    static void checkCompilationLevel(Method method, int level) {\n-        assertEQ(wb.getMethodCompilationLevel(method), level, \"Compilation level\");\n-    }\n-\n-    static void setup() throws Exception {\n-        method = DirectivesRefreshTest.class.getDeclaredMethod(\"callable\");\n-        executor = new JMXExecutor();\n-\n-        System.out.println(\"Compilation with C2\");\n-\n-        \/\/ Happens with fairly hot methods.\n-        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-    }\n-\n-    static void testDirectivesAddRefresh() {\n-        System.out.println(\"Force forbid C2 via directive, method deoptimized\");\n-\n-        var output = executor.execute(\"Compiler.directives_add -r \" + cmdPath.toString());\n-        output.stderrShouldBeEmpty().shouldContain(\"1 compiler directives added\");\n-        \/\/ Current handling of 'Exclude' for '-r' clears flags.\n-        checkCompilationLevel(method, COMP_LEVEL_NONE);\n-\n-        System.out.println(\"C2 is excluded, re-compilation with C1\");\n-\n-        \/\/ Sanity check for the directive.\n-        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-        checkCompilationLevel(method, COMP_LEVEL_NONE);\n-\n-        \/\/ Happens with fairly hot methods.\n-        wb.enqueueMethodForCompilation(method, COMP_LEVEL_SIMPLE);\n-        checkCompilationLevel(method, COMP_LEVEL_SIMPLE);\n-    }\n-\n-    static void testDirectivesClearRefresh() {\n-        System.out.println(\"Re-compilation with C2 due to removed restriction\");\n-\n-        var output = executor.execute(\"Compiler.directives_clear -r\");\n-        output.stderrShouldBeEmpty().stdoutShouldBeEmpty();\n-\n-        \/\/ No need to enqueue the method, \"immediate\" effect of '-r' without deoptimization.\n-        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-    }\n-\n-    static void testDirectivesAddRegular() {\n-        System.out.println(\"No changes if the restriction is not forced\");\n-\n-        \/\/ According to original JEP 165, the directive will be handled\n-        \/\/ \"when a method is submitted for a compilation\".\n-        var output = executor.execute(\"Compiler.directives_add \" + cmdPath.toString());\n-        output.stderrShouldBeEmpty().shouldContain(\"1 compiler directives added\");\n-\n-        \/\/ In this program the method is not called, and here it is not enqueued.\n-        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        setup();\n-        testDirectivesAddRefresh();\n-        testDirectivesClearRefresh();\n-        testDirectivesAddRegular();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/DirectivesRefreshTest.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-[\n-  {\n-    match: \"serviceability.dcmd.compiler.DirectivesRefreshTest::callable\",\n-    c2: {\n-      Exclude: true\n-    }\n-  }\n-]\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/refresh_control.txt","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"}]}