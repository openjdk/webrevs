{"files":[{"patch":"@@ -2032,1 +2032,1 @@\n-    Label L_fill_elements, L_exit1;\n+    Label L_fill_elements;\n@@ -2038,0 +2038,3 @@\n+        \/\/ Short arrays (< 8 bytes) fill by element\n+        __ mv(tmp_reg, 8 >> shift);\n+        __ bltu(count, tmp_reg, L_fill_elements);\n@@ -2042,2 +2045,1 @@\n-        __ mv(tmp_reg, value);\n-        __ slli(tmp_reg, tmp_reg, 8);\n+        __ slli(tmp_reg, value, 8);\n@@ -2047,2 +2049,1 @@\n-        __ mv(tmp_reg, value);\n-        __ slli(tmp_reg, tmp_reg, 16);\n+        __ slli(tmp_reg, value, 16);\n@@ -2050,3 +2051,0 @@\n-\n-        __ mv(tmp_reg, 8 >> shift); \/\/ Short arrays (< 8 bytes) fill by element\n-        __ bltu(count, tmp_reg, L_fill_elements);\n@@ -2056,0 +2054,4 @@\n+        \/\/ Short arrays (< 8 bytes) fill by element\n+        __ mv(tmp_reg, 8 >> shift);\n+        __ bltu(count, tmp_reg, L_fill_elements);\n+\n@@ -2059,2 +2061,1 @@\n-        __ mv(tmp_reg, value);\n-        __ slli(tmp_reg, tmp_reg, 16);\n+        __ slli(tmp_reg, value, 16);\n@@ -2062,4 +2063,0 @@\n-\n-        \/\/ Short arrays (< 8 bytes) fill by element\n-        __ mv(tmp_reg, 8 >> shift);\n-        __ bltu(count, tmp_reg, L_fill_elements);\n@@ -2069,1 +2066,0 @@\n-\n@@ -2128,14 +2124,2 @@\n-    \/\/ Remaining count is less than 8 bytes. Fill it by a single store.\n-    \/\/ Note that the total length is no less than 8 bytes.\n-    if (!AvoidUnalignedAccesses && (t == T_BYTE || t == T_SHORT)) {\n-      __ beqz(count, L_exit1);\n-      __ shadd(to, count, to, tmp_reg, shift); \/\/ points to the end\n-      __ sd(value, Address(to, -8)); \/\/ overwrite some elements\n-      __ bind(L_exit1);\n-      __ leave();\n-      __ ret();\n-    }\n-\n-    \/\/ Handle copies less than 8 bytes.\n-    Label L_fill_2, L_fill_4, L_exit2;\n-    __ bind(L_fill_elements);\n+    \/\/ Remaining count is less than 8 bytes and address is heapword aligned.\n+    Label L_fill_2, L_fill_4, L_exit1;\n@@ -2155,1 +2139,1 @@\n-        __ beqz(t0, L_exit2);\n+        __ beqz(t0, L_exit1);\n@@ -2165,1 +2149,5 @@\n-        __ beqz(t0, L_exit2);\n+        __ beqz(t0, L_exit1);\n+        __ sw(value, Address(to, 0));\n+        break;\n+      case T_INT:\n+        __ beqz(count, L_exit1);\n@@ -2168,0 +2156,25 @@\n+      default: ShouldNotReachHere();\n+    }\n+    __ bind(L_exit1);\n+    __ leave();\n+    __ ret();\n+\n+    \/\/ Handle copies less than 8 bytes.\n+    Label L_loop1, L_loop2, L_exit2;\n+    __ bind(L_fill_elements);\n+    __ beqz(count, L_exit2);\n+    switch (t) {\n+      case T_BYTE:\n+        __ bind(L_loop1);\n+        __ sb(value, Address(to, 0));\n+        __ addi(to, to, 1);\n+        __ subiw(count, count, 1);\n+        __ bnez(count, L_loop1);\n+        break;\n+      case T_SHORT:\n+        __ bind(L_loop2);\n+        __ sh(value, Address(to, 0));\n+        __ addi(to, to, 2);\n+        __ subiw(count, count, 2 >> shift);\n+        __ bnez(count, L_loop2);\n+        break;\n@@ -2169,1 +2182,0 @@\n-        __ beqz(count, L_exit2);\n@@ -2177,0 +2189,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":45,"deletions":32,"binary":false,"changes":77,"status":"modified"}]}