{"files":[{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -81,1 +82,1 @@\n-  return 3; \/\/ 2 in emit_to_interp_stub + 1 in emit_call\n+  return 4; \/\/ 3 in emit_to_interp_stub + 1 in emit_call\n@@ -89,1 +90,3 @@\n-  NativeStaticCallStub* stub_holder = NativeStaticCallStub_at(stub);\n+  NativeMovConstReg* method_holder\n+    = nativeMovConstReg_at(stub + NativeInstruction::instruction_size);\n+\n@@ -91,2 +94,4 @@\n-  _call->verify();\n-  stub_holder->verify_static_stub(callee, entry);\n+  NativeJump* jump = MacroAssembler::codestub_branch_needs_far_jump()\n+                         ? nativeGeneralJump_at(method_holder->next_instruction_address())\n+                         : nativeJump_at(method_holder->next_instruction_address());\n+  verify_mt_safe(callee, entry, method_holder, jump);\n@@ -94,1 +99,76 @@\n-  stub_holder->set_metadata_and_destination((intptr_t)callee(), entry);\n+\n+  \/\/ Update stub.\n+  method_holder->set_data((intptr_t)callee());\n+  MacroAssembler::pd_patch_instruction(method_holder->next_instruction_address(), entry);\n+  ICache::invalidate_range(stub, to_interp_stub_size());\n+\n+  \/\/ If the executing thread observes the updated direct branch at a call site,\n+  \/\/ it is guaranteed to also observe the updated instructions in the static call\n+  \/\/ stub, provided the stub is entered only via the direct jump.\n+  \/\/\n+  \/\/ AArch64 stub_via_BL\n+  \/\/ {\n+  \/\/ 0:X0=instr:\"MOV w0, #2\";\n+  \/\/ 0:X1=instr:\"BL .+16\";\n+  \/\/ 0:X10=P1:new;\n+  \/\/ 0:X11=P1:L0;\n+  \/\/ }\n+  \/\/\n+  \/\/ P0              |  P1            ;\n+  \/\/ STR W0, [X10]   |L0:             ;\n+  \/\/ DC CVAU, X10    |  BL old        ;\n+  \/\/ DSB ISH         |  B end         ;\n+  \/\/ IC IVAU, X10    |old:            ;\n+  \/\/ DSB ISH         |  MOV w0, #0    ;\n+  \/\/                 |  RET           ;\n+  \/\/ STR W1, [X11]   |new:            ;\n+  \/\/                 |  MOV w0, #1    ;\n+  \/\/                 |  RET           ;\n+  \/\/                 |end:            ;\n+  \/\/ forall(1:X0=0 \\\/ 1:X0=2)\n+  \/\/\n+  \/\/ However, the static call stub can also be reached via an indirect branch\n+  \/\/ from the trampoline stub. In that case, the above guarantee does not apply,\n+  \/\/ so directly removing the 'isb' would not ensure visibility of the updated\n+  \/\/ instructions when the static call stub is reached through the trampoline stub.\n+  \/\/\n+  \/\/ To ensure correctness, we patch 'isb' to 'nop'. Before doing so, we already update\n+  \/\/ the 'MOV' instructions and enforce coherence between data writes and\n+  \/\/ instruction fetches within the same shareability domain by invoking\n+  \/\/ ICache::invalidate_range(). As confirmed by the litmus test below, when the\n+  \/\/ executing thread reaches the static call stub:\n+  \/\/   - If it observes the 'nop', it will also observe the updated 'MOV's (similarly\n+  \/\/     to the case above where the thread reaches patched code via a patched direct\n+  \/\/     branch).\n+  \/\/   - Otherwise, it will execute the 'isb' - the instruction fetch ensures the\n+  \/\/     updated 'MOV's are observed.\n+  \/\/\n+  \/\/ AArch64 stub_via_BR\n+  \/\/ {\n+  \/\/ [target] = P1:old;\n+  \/\/\n+  \/\/                               1:X0 = 0;\n+  \/\/ 0:X1 = instr:\"MOV X0, #3\";\n+  \/\/ 0:X2 = instr:\"nop\";\n+  \/\/ 0:X3 = target;                1:X3 = target;\n+  \/\/ 0:X4 = P1:new;\n+  \/\/ 0:X5 = P1:patch;\n+  \/\/ }\n+  \/\/\n+  \/\/ P0                          | P1                        ;\n+  \/\/ STR W1, [X5]                |  LDR X2, [X3]             ;\n+  \/\/ DC CVAU, X5                 |  BR X2                    ;\n+  \/\/ DSB ISH                     |new:                       ;\n+  \/\/ IC IVAU, X5                 |  ISB                      ;\n+  \/\/ DSB ISH                     |patch:                     ;\n+  \/\/ STR W2, [X4]                |  MOV X0, #2               ;\n+  \/\/ STR X4, [X3]                |  B end                    ;\n+  \/\/                             |old:                       ;\n+  \/\/                             |  MOV X0, #1               ;\n+  \/\/                             |  B end                    ;\n+  \/\/                             |end:                       ;\n+  \/\/ forall (1:X0=1 \\\/ 1:X0=3)\n+  CodeBuffer stub_first_instruction(stub, Assembler::instruction_size);\n+  Assembler assembler(&stub_first_instruction);\n+  assembler.nop();\n+\n@@ -104,0 +184,4 @@\n+  \/\/ Patch 'nop' to 'isb'.\n+  CodeBuffer stub_first_instruction(stub, Assembler::instruction_size);\n+  Assembler assembler(&stub_first_instruction);\n+  assembler.isb();\n@@ -105,2 +189,5 @@\n-  NativeStaticCallStub* stub_holder = NativeStaticCallStub_at(stub);\n-  stub_holder->set_metadata_and_destination(0, 0);\n+  NativeMovConstReg* method_holder\n+    = nativeMovConstReg_at(stub + NativeInstruction::instruction_size);\n+  method_holder->set_data(0);\n+  NativeJump* jump = nativeJump_at(method_holder->next_instruction_address());\n+  jump->set_jump_destination((address)-1);\n@@ -122,1 +209,3 @@\n-  NativeStaticCallStub* stub_holder = NativeStaticCallStub_at(stub);\n+  NativeMovConstReg* method_holder\n+    = nativeMovConstReg_at(stub + NativeInstruction::instruction_size);\n+  NativeJump* jump = nativeJump_at(method_holder->next_instruction_address());\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":97,"deletions":8,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -945,0 +945,3 @@\n+  isb();\n+  mov_metadata(rmethod, nullptr);\n+\n@@ -946,13 +949,6 @@\n-  const int stub_start_offset = offset();\n-  Label far_jump_metadata, far_jump_entry;\n-  ldr(rmethod, far_jump_metadata);\n-  ldr(rscratch1, far_jump_entry);\n-  br(rscratch1);\n-  bind(far_jump_metadata);\n-  assert(offset() - stub_start_offset == NativeStaticCallStub::far_jump_metadata_offset,\n-         \"should be\");\n-  emit_int64(0);\n-  bind(far_jump_entry);\n-  assert(offset() - stub_start_offset == NativeStaticCallStub::far_jump_entrypoint_offset,\n-         \"should be\");\n-  emit_int64(0);\n+  if (codestub_branch_needs_far_jump()) {\n+    movptr(rscratch1, 0);\n+    br(rscratch1);\n+  } else {\n+    b(pc());\n+  }\n@@ -962,2 +958,6 @@\n-  \/\/ ldr; ldr; br; zero; zero; zero; zero;\n-  return 7 * NativeInstruction::instruction_size;\n+  if (!codestub_branch_needs_far_jump()) {\n+    \/\/ isb; movk; movz; movz; b\n+    return 5 * NativeInstruction::instruction_size;\n+  }\n+  \/\/ isb; movk; movz; movz; movk; movz; movz; br\n+  return 8 * NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -393,23 +393,0 @@\n-#ifndef PRODUCT\n-\/\/ Mirror the logic in CompiledDirectCall::verify_mt_safe().\n-void NativeStaticCallStub::verify_static_stub(const methodHandle& callee, address entry) {\n-  intptr_t metadata = intptr_at(far_jump_metadata_offset);\n-  address entrypoint = ptr_at(far_jump_entrypoint_offset);\n-  CompiledDirectCall::verify_mt_safe_helper(callee, entry, metadata, entrypoint);\n-}\n-#endif\n-\n-void NativeStaticCallStub::set_metadata_and_destination(intptr_t callee, address entry) {\n-  set_intptr_at(far_jump_metadata_offset, callee);\n-  set_ptr_at(far_jump_entrypoint_offset, entry);\n-  OrderAccess::release();\n-}\n-\n-void NativeStaticCallStub::verify_instruction_sequence() {\n-  if (! (nativeInstruction_at(addr_at(0))->is_ldr_literal() &&\n-         nativeInstruction_at(addr_at(NativeInstruction::instruction_size))->is_ldr_literal() &&\n-         nativeInstruction_at(addr_at(NativeInstruction::instruction_size * 2))->is_blr())) {\n-    fatal(\"Not expected instructions in static call stub\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-\/\/ - - NativeStaticCallStub\n@@ -98,1 +97,0 @@\n-  intptr_t intptr_at(int offset) const { return *(intptr_t*)addr_at(offset); }\n@@ -105,1 +103,0 @@\n-  void set_intptr_at(int offset, intptr_t iptr) { *(intptr_t*)addr_at(offset) = iptr; }\n@@ -459,21 +456,0 @@\n-\/\/ Static call stubs.\n-class NativeStaticCallStub : public NativeInstruction {\n-public:\n-\n-  enum AArch64_specific_constants {\n-    far_jump_metadata_offset      =   3 * 4,\n-    far_jump_entrypoint_offset    =   5 * 4\n-  };\n-\n-  void set_metadata_and_destination(intptr_t callee, address entry);\n-  void verify_static_stub(const methodHandle& callee, address entry) PRODUCT_RETURN;\n-  void verify_instruction_sequence();\n-  inline friend NativeStaticCallStub* NativeStaticCallStub_at(address addr);\n-};\n-\n-inline NativeStaticCallStub* NativeStaticCallStub_at(address addr) {\n-  NativeStaticCallStub* test = (NativeStaticCallStub*)addr;\n-  DEBUG_ONLY(test->verify_instruction_sequence());\n-  return test;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -432,2 +432,4 @@\n-void CompiledDirectCall::verify_mt_safe_helper(const methodHandle& callee, address entry,\n-                                               intptr_t metadata, address destination) {\n+void CompiledDirectCall::verify_mt_safe(const methodHandle& callee, address entry,\n+                                        NativeMovConstReg* method_holder,\n+                                        NativeJump* jump) {\n+  _call->verify();\n@@ -438,1 +440,1 @@\n-  Method* old_method = reinterpret_cast<Method*>(metadata);\n+  Method* old_method = reinterpret_cast<Method*>(method_holder->data());\n@@ -445,0 +447,1 @@\n+  address destination = jump->jump_destination();\n@@ -450,7 +453,0 @@\n-\n-void CompiledDirectCall::verify_mt_safe(const methodHandle& callee, address entry,\n-                                        NativeMovConstReg* method_holder,\n-                                        NativeJump* jump) {\n-  _call->verify();\n-  verify_mt_safe_helper(callee, entry, method_holder->data(), jump->jump_destination());\n-}\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,2 +229,0 @@\n-  static void verify_mt_safe_helper(const methodHandle& callee, address entry,\n-                                    intptr_t metadata, address destination) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.aarch64;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.*;\n+\n+\/*\n+ * @test\n+ * @summary Calls to c2i interface stubs should be generated with near branches\n+ * for segmented code cache up to 250MB\n+ * @library \/test\/lib \/\n+ *\n+ * @requires vm.flagless\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.debug == false\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run driver compiler.c2.aarch64.TestStaticCallStub\n+ *\/\n+public class TestStaticCallStub {\n+\n+    static String[] nearStaticCallOpcodeSeq = {\"isb\", \"mov\", \"movk\", \"movk\", \"b\"};\n+    static String[] farStaticCallOpcodeSeq = {\"isb\", \"mov\", \"movk\", \"movk\", \"mov\", \"movk\", \"movk\", \"br\"};\n+\n+    static String extractOpcode(String line) {\n+        line = line.trim();\n+        int semicolonIndex = line.indexOf(';');\n+        if (semicolonIndex != -1) {\n+            line = line.substring(0, semicolonIndex).trim();\n+        }\n+\n+        String[] words = line.split(\"\\\\s+\");\n+        if (words.length > 1) {\n+            return words[1];\n+        }\n+\n+        return \"\";\n+    }\n+\n+    static List<String> extractOpcodesN(ListIterator<String> itr, int n) {\n+        List<String> extractedOpcodes = new ArrayList<>();\n+\n+        while (itr.hasNext() && extractedOpcodes.size() < n) {\n+            String opcode = extractOpcode(itr.next());\n+            if (!opcode.isEmpty()) {\n+                extractedOpcodes.add(opcode);\n+            }\n+        }\n+\n+        return extractedOpcodes;\n+    }\n+\n+    static void verifyNearStaticCall(ListIterator<String> itr) {\n+        List<String> extractedOpcodes = extractOpcodesN(itr, nearStaticCallOpcodeSeq.length);\n+\n+        if (!Arrays.asList(nearStaticCallOpcodeSeq).equals(extractedOpcodes)) {\n+            throw new RuntimeException(\"for code cache < 250MB the static call stub is expected to be implemented using near branch\");\n+        }\n+\n+        return;\n+    }\n+\n+    static void verifyFarStaticCall(ListIterator<String> itr) {\n+        List<String> extractedOpcodes = extractOpcodesN(itr, farStaticCallOpcodeSeq.length);\n+\n+        if (!Arrays.asList(farStaticCallOpcodeSeq).equals(extractedOpcodes)) {\n+            throw new RuntimeException(\"for code cache > 250MB the static call stub is expected to be implemented using far branch\");\n+        }\n+\n+        return;\n+    }\n+\n+    static void runVM(boolean bigCodeCache) throws Exception {\n+        String className = TestStaticCallStub.class.getName();\n+        String[] procArgs = {\n+            \"-XX:-Inline\",\n+            \"-Xcomp\",\n+            \"-Xbatch\",\n+            \"-XX:+TieredCompilation\",\n+            \"-XX:+SegmentedCodeCache\",\n+            \"-XX:ReservedCodeCacheSize=\" + (bigCodeCache ? \"256M\" : \"200M\"),\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:CompileCommand=option,\" + className + \"::main,bool,PrintAssembly,true\",\n+            className};\n+\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(procArgs);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        List<String> lines = output.asLines();\n+\n+        ListIterator<String> itr = lines.listIterator();\n+        while (itr.hasNext()) {\n+            String line = itr.next();\n+            if (line.contains(\"{static_stub}\")) {\n+                itr.previous();\n+                if (bigCodeCache) {\n+                    verifyFarStaticCall(itr);\n+                } else {\n+                    verifyNearStaticCall(itr);\n+                }\n+                return;\n+            }\n+        }\n+        throw new RuntimeException(\"Assembly output: static call stub is not found\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            \/\/ Main VM: fork VM with options\n+            runVM(true);\n+            runVM(false);\n+            return;\n+        }\n+        if (args.length > 0) {\n+            \/\/ We are in a forked VM. Just exit\n+            System.out.println(\"Ok\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestStaticCallStub.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/StaticCallStub.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}