{"files":[{"patch":"@@ -81,1 +81,1 @@\n-  return 4; \/\/ 3 in emit_to_interp_stub + 1 in emit_call\n+  return 3; \/\/ 2 in emit_to_interp_stub + 1 in emit_call\n@@ -89,3 +89,1 @@\n-  NativeMovConstReg* method_holder\n-    = nativeMovConstReg_at(stub + NativeInstruction::instruction_size);\n-\n+  NativeStaticCallStub* stub_holder = NativeStaticCallStub_at(stub);\n@@ -93,4 +91,2 @@\n-  NativeJump* jump = MacroAssembler::codestub_branch_needs_far_jump()\n-                         ? nativeGeneralJump_at(method_holder->next_instruction_address())\n-                         : nativeJump_at(method_holder->next_instruction_address());\n-  verify_mt_safe(callee, entry, method_holder, jump);\n+  _call->verify();\n+  stub_holder->verify_static_stub(callee, entry);\n@@ -98,5 +94,1 @@\n-\n-  \/\/ Update stub.\n-  method_holder->set_data((intptr_t)callee());\n-  MacroAssembler::pd_patch_instruction(method_holder->next_instruction_address(), entry);\n-  ICache::invalidate_range(stub, to_interp_stub_size());\n+  stub_holder->set_metadata_and_destination((intptr_t)callee(), entry);\n@@ -113,5 +105,2 @@\n-  NativeMovConstReg* method_holder\n-    = nativeMovConstReg_at(stub + NativeInstruction::instruction_size);\n-  method_holder->set_data(0);\n-  NativeJump* jump = nativeJump_at(method_holder->next_instruction_address());\n-  jump->set_jump_destination((address)-1);\n+  NativeStaticCallStub* stub_holder = NativeStaticCallStub_at(stub);\n+  stub_holder->set_metadata_and_destination(0, 0);\n@@ -133,3 +122,1 @@\n-  NativeMovConstReg* method_holder\n-    = nativeMovConstReg_at(stub + NativeInstruction::instruction_size);\n-  NativeJump* jump = nativeJump_at(method_holder->next_instruction_address());\n+  NativeStaticCallStub* stub_holder = NativeStaticCallStub_at(stub);\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":8,"deletions":21,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -983,3 +983,0 @@\n-  isb();\n-  mov_metadata(rmethod, nullptr);\n-\n@@ -987,6 +984,13 @@\n-  if (codestub_branch_needs_far_jump()) {\n-    movptr(rscratch1, 0);\n-    br(rscratch1);\n-  } else {\n-    b(pc());\n-  }\n+  const int stub_start_offset = offset();\n+  Label far_jump_metadata, far_jump_entry;\n+  ldr(rmethod, far_jump_metadata);\n+  ldr(rscratch1, far_jump_entry);\n+  br(rscratch1);\n+  bind(far_jump_metadata);\n+  assert(offset() - stub_start_offset == NativeStaticCallStub::far_jump_metadata_offset,\n+         \"should be\");\n+  emit_int64(0);\n+  bind(far_jump_entry);\n+  assert(offset() - stub_start_offset == NativeStaticCallStub::far_jump_entrypoint_offset,\n+         \"should be\");\n+  emit_int64(0);\n@@ -996,6 +1000,2 @@\n-  if (!codestub_branch_needs_far_jump()) {\n-    \/\/ isb; movk; movz; movz; b\n-    return 5 * NativeInstruction::instruction_size;\n-  }\n-  \/\/ isb; movk; movz; movz; movk; movz; movz; br\n-  return 8 * NativeInstruction::instruction_size;\n+  \/\/ ldr; ldr; br; zero; zero; zero; zero;\n+  return 7 * NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -393,0 +393,23 @@\n+#ifndef PRODUCT\n+\/\/ Mirror the logic in CompiledDirectCall::verify_mt_safe().\n+void NativeStaticCallStub::verify_static_stub(const methodHandle& callee, address entry) {\n+  intptr_t metadata = intptr_at(far_jump_metadata_offset);\n+  address entrypoint = ptr_at(far_jump_entrypoint_offset);\n+  CompiledDirectCall::verify_mt_safe_helper(callee, entry, metadata, entrypoint);\n+}\n+#endif\n+\n+void NativeStaticCallStub::set_metadata_and_destination(intptr_t callee, address entry) {\n+  set_intptr_at(far_jump_metadata_offset, callee);\n+  set_ptr_at(far_jump_entrypoint_offset, entry);\n+  OrderAccess::release();\n+}\n+\n+void NativeStaticCallStub::verify_instruction_sequence() {\n+  if (! (nativeInstruction_at(addr_at(0))->is_ldr_literal() &&\n+         nativeInstruction_at(addr_at(NativeInstruction::instruction_size))->is_ldr_literal() &&\n+         nativeInstruction_at(addr_at(NativeInstruction::instruction_size * 2))->is_blr())) {\n+    fatal(\"Not expected instructions in static call stub\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+\/\/ - - NativeStaticCallStub\n@@ -97,0 +98,1 @@\n+  intptr_t intptr_at(int offset) const { return *(intptr_t*)addr_at(offset); }\n@@ -103,0 +105,1 @@\n+  void set_intptr_at(int offset, intptr_t iptr) { *(intptr_t*)addr_at(offset) = iptr; }\n@@ -456,0 +459,21 @@\n+\/\/ Static call stubs.\n+class NativeStaticCallStub : public NativeInstruction {\n+public:\n+\n+  enum AArch64_specific_constants {\n+    far_jump_metadata_offset      =   3 * 4,\n+    far_jump_entrypoint_offset    =   5 * 4\n+  };\n+\n+  void set_metadata_and_destination(intptr_t callee, address entry);\n+  void verify_static_stub(const methodHandle& callee, address entry) PRODUCT_RETURN;\n+  void verify_instruction_sequence();\n+  inline friend NativeStaticCallStub* NativeStaticCallStub_at(address addr);\n+};\n+\n+inline NativeStaticCallStub* NativeStaticCallStub_at(address addr) {\n+  NativeStaticCallStub* test = (NativeStaticCallStub*)addr;\n+  DEBUG_ONLY(test->verify_instruction_sequence());\n+  return test;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -432,4 +432,2 @@\n-void CompiledDirectCall::verify_mt_safe(const methodHandle& callee, address entry,\n-                                        NativeMovConstReg* method_holder,\n-                                        NativeJump* jump) {\n-  _call->verify();\n+void CompiledDirectCall::verify_mt_safe_helper(const methodHandle& callee, address entry,\n+                                               intptr_t metadata, address destination) {\n@@ -440,1 +438,1 @@\n-  Method* old_method = reinterpret_cast<Method*>(method_holder->data());\n+  Method* old_method = reinterpret_cast<Method*>(metadata);\n@@ -447,1 +445,0 @@\n-  address destination = jump->jump_destination();\n@@ -453,0 +450,7 @@\n+\n+void CompiledDirectCall::verify_mt_safe(const methodHandle& callee, address entry,\n+                                        NativeMovConstReg* method_holder,\n+                                        NativeJump* jump) {\n+  _call->verify();\n+  verify_mt_safe_helper(callee, entry, method_holder->data(), jump->jump_destination());\n+}\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,0 +229,2 @@\n+  static void verify_mt_safe_helper(const methodHandle& callee, address entry,\n+                                    intptr_t metadata, address destination) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package compiler.c2.aarch64;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.*;\n-\n-\/*\n- * @test\n- * @summary Calls to c2i interface stubs should be generated with near branches\n- * for segmented code cache up to 250MB\n- * @library \/test\/lib \/\n- *\n- * @requires vm.flagless\n- * @requires os.arch==\"aarch64\"\n- * @requires vm.debug == false\n- * @requires vm.compiler2.enabled\n- *\n- * @run driver compiler.c2.aarch64.TestStaticCallStub\n- *\/\n-public class TestStaticCallStub {\n-\n-    static String[] nearStaticCallOpcodeSeq = {\"isb\", \"mov\", \"movk\", \"movk\", \"b\"};\n-    static String[] farStaticCallOpcodeSeq = {\"isb\", \"mov\", \"movk\", \"movk\", \"mov\", \"movk\", \"movk\", \"br\"};\n-\n-    static String extractOpcode(String line) {\n-        line = line.trim();\n-        int semicolonIndex = line.indexOf(';');\n-        if (semicolonIndex != -1) {\n-            line = line.substring(0, semicolonIndex).trim();\n-        }\n-\n-        String[] words = line.split(\"\\\\s+\");\n-        if (words.length > 1) {\n-            return words[1];\n-        }\n-\n-        return \"\";\n-    }\n-\n-    static List<String> extractOpcodesN(ListIterator<String> itr, int n) {\n-        List<String> extractedOpcodes = new ArrayList<>();\n-\n-        while (itr.hasNext() && extractedOpcodes.size() < n) {\n-            String opcode = extractOpcode(itr.next());\n-            if (!opcode.isEmpty()) {\n-                extractedOpcodes.add(opcode);\n-            }\n-        }\n-\n-        return extractedOpcodes;\n-    }\n-\n-    static void verifyNearStaticCall(ListIterator<String> itr) {\n-        List<String> extractedOpcodes = extractOpcodesN(itr, nearStaticCallOpcodeSeq.length);\n-\n-        if (!Arrays.asList(nearStaticCallOpcodeSeq).equals(extractedOpcodes)) {\n-            throw new RuntimeException(\"for code cache < 250MB the static call stub is expected to be implemented using near branch\");\n-        }\n-\n-        return;\n-    }\n-\n-    static void verifyFarStaticCall(ListIterator<String> itr) {\n-        List<String> extractedOpcodes = extractOpcodesN(itr, farStaticCallOpcodeSeq.length);\n-\n-        if (!Arrays.asList(farStaticCallOpcodeSeq).equals(extractedOpcodes)) {\n-            throw new RuntimeException(\"for code cache > 250MB the static call stub is expected to be implemented using far branch\");\n-        }\n-\n-        return;\n-    }\n-\n-    static void runVM(boolean bigCodeCache) throws Exception {\n-        String className = TestStaticCallStub.class.getName();\n-        String[] procArgs = {\n-            \"-XX:-Inline\",\n-            \"-Xcomp\",\n-            \"-Xbatch\",\n-            \"-XX:+TieredCompilation\",\n-            \"-XX:+SegmentedCodeCache\",\n-            \"-XX:ReservedCodeCacheSize=\" + (bigCodeCache ? \"256M\" : \"200M\"),\n-            \"-XX:+UnlockDiagnosticVMOptions\",\n-            \"-XX:CompileCommand=option,\" + className + \"::main,bool,PrintAssembly,true\",\n-            className};\n-\n-\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(procArgs);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        List<String> lines = output.asLines();\n-\n-        ListIterator<String> itr = lines.listIterator();\n-        while (itr.hasNext()) {\n-            String line = itr.next();\n-            if (line.contains(\"{static_stub}\")) {\n-                itr.previous();\n-                if (bigCodeCache) {\n-                    verifyFarStaticCall(itr);\n-                } else {\n-                    verifyNearStaticCall(itr);\n-                }\n-                return;\n-            }\n-        }\n-        throw new RuntimeException(\"Assembly output: static call stub is not found\");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            \/\/ Main VM: fork VM with options\n-            runVM(true);\n-            runVM(false);\n-            return;\n-        }\n-        if (args.length > 0) {\n-            \/\/ We are in a forked VM. Just exit\n-            System.out.println(\"Ok\");\n-        }\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestStaticCallStub.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 3)\n+@State(Scope.Thread)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 10, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+public class StaticCallStub {\n+    @Param({\"1000\", \"10000\", \"100000\"})\n+    public static int length;\n+    public static int val;\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    public static void callInterpreted(int i) {\n+        val = i;\n+    }\n+\n+    @Benchmark\n+    public void callCompiled() {\n+        for (int i = 0; i < length; i++)\n+            callInterpreted(i); \/\/ Make sure this is excluded from compilation\n+    }\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+SegmentedCodeCache -XX:ReservedCodeCacheSize=200M\"\n+    })\n+    public static class StaticCallStubNear extends StaticCallStub {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+SegmentedCodeCache -XX:ReservedCodeCacheSize=256M\"\n+    })\n+    public static class StaticCallStubFar extends StaticCallStub {}\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/StaticCallStub.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}