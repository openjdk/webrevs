{"files":[{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -103,0 +104,71 @@\n+\n+  \/\/ If the executing thread observes the updated direct branch at a call site,\n+  \/\/ it is guaranteed to also observe the updated instructions in the static call\n+  \/\/ stub, provided the stub is entered only via the direct jump.\n+  \/\/\n+  \/\/ AArch64 stub_via_BL\n+  \/\/ {\n+  \/\/ 0:X0=instr:\"MOV w0, #2\";\n+  \/\/ 0:X1=instr:\"BL .+16\";\n+  \/\/ 0:X10=P1:new;\n+  \/\/ 0:X11=P1:L0;\n+  \/\/ }\n+  \/\/\n+  \/\/ P0              |  P1            ;\n+  \/\/ STR W0, [X10]   |L0:             ;\n+  \/\/ DC CVAU, X10    |  BL old        ;\n+  \/\/ DSB ISH         |  B end         ;\n+  \/\/ IC IVAU, X10    |old:            ;\n+  \/\/ DSB ISH         |  MOV w0, #0    ;\n+  \/\/                 |  RET           ;\n+  \/\/ STR W1, [X11]   |new:            ;\n+  \/\/                 |  MOV w0, #1    ;\n+  \/\/                 |  RET           ;\n+  \/\/                 |end:            ;\n+  \/\/ forall(1:X0=0 \\\/ 1:X0=2)\n+  \/\/\n+  \/\/ However, the static call stub can also be reached via an indirect branch\n+  \/\/ from the trampoline stub. In that case, the above guarantee does not apply,\n+  \/\/ so directly removing the 'isb' would not ensure visibility of the updated\n+  \/\/ instructions when the static call stub is reached through the trampoline stub.\n+  \/\/\n+  \/\/ To ensure correctness, we patch 'isb' to 'nop'. Before doing so, we already update\n+  \/\/ the 'MOV' instructions and enforce coherence between data writes and\n+  \/\/ instruction fetches within the same shareability domain by invoking\n+  \/\/ ICache::invalidate_range(). As confirmed by the litmus test below, when the\n+  \/\/ executing thread reaches the static call stub:\n+  \/\/   - If it observes the 'nop', it will also observe the updated 'MOV's (similarly\n+  \/\/     to the case above where the thread reaches patched code via a patched direct\n+  \/\/     branch).\n+  \/\/   - Otherwise, it will execute the 'isb' - the instruction fetch ensures the\n+  \/\/     updated 'MOV's are observed.\n+  \/\/\n+  \/\/ AArch64 stub_via_BR\n+  \/\/ {\n+  \/\/ [target] = P1:old;\n+  \/\/\n+  \/\/                               1:X0 = 0;\n+  \/\/ 0:X1 = instr:\"MOV X0, #3\";\n+  \/\/ 0:X2 = instr:\"nop\";\n+  \/\/ 0:X3 = target;                1:X3 = target;\n+  \/\/ 0:X4 = P1:new;\n+  \/\/ 0:X5 = P1:patch;\n+  \/\/ }\n+  \/\/\n+  \/\/ P0                          | P1                        ;\n+  \/\/ STR W1, [X5]                |  LDR X2, [X3]             ;\n+  \/\/ DC CVAU, X5                 |  BR X2                    ;\n+  \/\/ DSB ISH                     |new:                       ;\n+  \/\/ IC IVAU, X5                 |  ISB                      ;\n+  \/\/ DSB ISH                     |patch:                     ;\n+  \/\/ STR W2, [X4]                |  MOV X0, #2               ;\n+  \/\/ STR X4, [X3]                |  B end                    ;\n+  \/\/                             |old:                       ;\n+  \/\/                             |  MOV X0, #1               ;\n+  \/\/                             |  B end                    ;\n+  \/\/                             |end:                       ;\n+  \/\/ forall (1:X0=1 \\\/ 1:X0=3)\n+  CodeBuffer stub_first_instruction(stub, Assembler::instruction_size);\n+  Assembler assembler(&stub_first_instruction);\n+  assembler.nop();\n+\n@@ -112,0 +184,4 @@\n+  \/\/ Patch 'nop' to 'isb'.\n+  CodeBuffer stub_first_instruction(stub, Assembler::instruction_size);\n+  Assembler assembler(&stub_first_instruction);\n+  assembler.isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 3)\n+@State(Scope.Thread)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 10, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+public class StaticCallStub {\n+    @Param({\"1000\", \"10000\", \"100000\"})\n+    public static int length;\n+    public static int val;\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    public static void callInterpreted(int i) {\n+        val = i;\n+    }\n+\n+    @Benchmark\n+    public void callCompiled() {\n+        for (int i = 0; i < length; i++)\n+            callInterpreted(i); \/\/ Make sure this is excluded from compilation\n+    }\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+SegmentedCodeCache -XX:ReservedCodeCacheSize=200M\"\n+    })\n+    public static class StaticCallStubNear extends StaticCallStub {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+SegmentedCodeCache -XX:ReservedCodeCacheSize=256M\"\n+    })\n+    public static class StaticCallStubFar extends StaticCallStub {}\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/StaticCallStub.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}