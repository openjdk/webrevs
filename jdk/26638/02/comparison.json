{"files":[{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -103,0 +104,77 @@\n+\n+  \/\/ If the executing thread observes the updated direct branch at a call site,\n+  \/\/ it is guaranteed to also observe the updated instructions in the static call\n+  \/\/ stub, provided the stub is entered only via the direct jump.\n+  \/\/\n+  \/\/ AArch64 stub_via_BL\n+  \/\/ {\n+  \/\/ 0:X0=instr:\"MOV w0, #2\";\n+  \/\/ 0:X1=instr:\"BL .+16\";\n+  \/\/ 0:X10=P1:new;\n+  \/\/ 0:X11=P1:L0;\n+  \/\/ }\n+  \/\/\n+  \/\/ P0              |  P1            ;\n+  \/\/ STR W0, [X10]   |L0:             ;\n+  \/\/ DC CVAU, X10    |  BL old        ;\n+  \/\/ DSB ISH         |  B end         ;\n+  \/\/ IC IVAU, X10    |old:            ;\n+  \/\/ DSB ISH         |  MOV w0, #0    ;\n+  \/\/                 |  RET           ;\n+  \/\/ STR W1, [X11]   |new:            ;\n+  \/\/                 |  MOV w0, #1    ;\n+  \/\/                 |  RET           ;\n+  \/\/                 |end:            ;\n+  \/\/ forall(1:X0=0 \\\/ 1:X0=2)\n+  \/\/\n+  \/\/ Generally, we keep the trampoline destination and the call destination\n+  \/\/ the same, which means the static call stub is also reachable via an\n+  \/\/ indirect branch from the trampoline stub. In that case, the above\n+  \/\/ guarantee does not apply, so directly removing the 'isb' would not\n+  \/\/ ensure visibility of the updated instructions when the static call\n+  \/\/ stub is reached through the trampoline stub.\n+  \/\/\n+  \/\/ To ensure correctness, we patch 'isb' to 'b .+4'. Before doing so, we already\n+  \/\/ update the 'MOV' instructions and enforce coherence between data writes and\n+  \/\/ instruction fetches within the same shareability domain by invoking\n+  \/\/ ICache::invalidate_range(). As confirmed by the litmus test below, when the\n+  \/\/ executing thread reaches the static call stub:\n+  \/\/   - If it observes the 'b .+4', it will also observe the updated 'MOV's (similarly\n+  \/\/     to the case above where the thread reaches patched code via a patched direct\n+  \/\/     branch).\n+  \/\/   - Otherwise, it will execute the 'isb' - the instruction fetch ensures the\n+  \/\/     updated 'MOV's are observed.\n+  \/\/\n+  \/\/ AArch64 stub_via_BR\n+  \/\/ {\n+  \/\/ [target] = P1:old;\n+  \/\/\n+  \/\/                               1:X0 = 0;\n+  \/\/ 0:X1 = instr:\"MOV X0, #3\";\n+  \/\/ 0:X2 = instr:\"b .+4\";\n+  \/\/ 0:X3 = target;                1:X3 = target;\n+  \/\/ 0:X4 = P1:new;\n+  \/\/ 0:X5 = P1:patch;\n+  \/\/ }\n+  \/\/\n+  \/\/ P0                          | P1                        ;\n+  \/\/ STR W1, [X5]                |  LDR X2, [X3]             ;\n+  \/\/ DC CVAU, X5                 |  BR X2                    ;\n+  \/\/ DSB ISH                     |new:                       ;\n+  \/\/ IC IVAU, X5                 |  ISB                      ;\n+  \/\/ DSB ISH                     |patch:                     ;\n+  \/\/ STR W2, [X4]                |  MOV X0, #2               ;\n+  \/\/ STR X4, [X3]                |  B end                    ;\n+  \/\/                             |old:                       ;\n+  \/\/                             |  MOV X0, #1               ;\n+  \/\/                             |  B end                    ;\n+  \/\/                             |end:                       ;\n+  \/\/ forall (1:X0=1 \\\/ 1:X0=3)\n+\n+  NativeJump::insert(stub, stub + NativeJump::instruction_size);\n+\n+  address trampoline_stub_addr = _call->get_trampoline();\n+  if (trampoline_stub_addr != nullptr) {\n+    nativeCallTrampolineStub_at(trampoline_stub_addr)->set_destination(stub);\n+  }\n+\n@@ -104,1 +182,1 @@\n-  set_destination_mt_safe(stub);\n+  _call->set_destination(stub);\n@@ -112,0 +190,4 @@\n+  \/\/ Patch 'b .+4' to 'isb'.\n+  CodeBuffer stub_first_instruction(stub, Assembler::instruction_size);\n+  Assembler assembler(&stub_first_instruction);\n+  assembler.isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":83,"deletions":1,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -241,0 +241,8 @@\n+\/\/ Atomic insertion of jump to target.\n+void NativeJump::insert(address code_pos, address target) {\n+  intptr_t offset = target - code_pos;\n+  uint32_t insn = 0b000101 << 26;\n+  Instruction_aarch64::spatch((address)&insn, 25, 0, offset >> 2);\n+  AtomicAccess::store((volatile uint32_t*)code_pos, insn);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 3)\n+@State(Scope.Thread)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 10, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+public class StaticCallStub {\n+    @Param({\"1000\", \"10000\", \"100000\"})\n+    public static int length;\n+    public static int val;\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    public static void callInterpreted(int i) {\n+        val = i;\n+    }\n+\n+    @Benchmark\n+    public void callCompiled() {\n+        for (int i = 0; i < length; i++)\n+            callInterpreted(i); \/\/ Make sure this is excluded from compilation\n+    }\n+\n+    @Fork(value = 1, jvmArgs = { \"-XX:+SegmentedCodeCache\", \"-XX:ReservedCodeCacheSize=200M\"})\n+    public static class NearJump extends StaticCallStub {}\n+\n+    @Fork(value = 1, jvmArgs = {\"-XX:+SegmentedCodeCache\", \"-XX:ReservedCodeCacheSize=256M\"})\n+    public static class FarJump extends StaticCallStub {}\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/StaticCallStub.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"}]}