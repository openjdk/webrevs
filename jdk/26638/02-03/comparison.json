{"files":[{"patch":"@@ -105,3 +105,12 @@\n-  \/\/ If the executing thread observes the updated direct branch at a call site,\n-  \/\/ it is guaranteed to also observe the updated instructions in the static call\n-  \/\/ stub, provided the stub is entered only via the direct jump.\n+  \/\/ This code is executed while other threads are running. We must\n+  \/\/ ensure that at all times the execution path is valid. A racing\n+  \/\/ thread either observes a call (possibly via a trampoline) to\n+  \/\/ SharedRuntime::resolve_static_call_C or a complete call to the\n+  \/\/ interpreter.\n+  \/\/\n+  \/\/ If a racing thread observes an updated direct branch at a call\n+  \/\/ site, it must also observe all of the updated instructions in the\n+  \/\/ static call stub.\n+  \/\/\n+  \/\/ To ensure this, we first update the static call stub, then the\n+  \/\/ trampoline, and finally the direct branch at the call site.\n@@ -130,6 +139,15 @@\n-  \/\/ Generally, we keep the trampoline destination and the call destination\n-  \/\/ the same, which means the static call stub is also reachable via an\n-  \/\/ indirect branch from the trampoline stub. In that case, the above\n-  \/\/ guarantee does not apply, so directly removing the 'isb' would not\n-  \/\/ ensure visibility of the updated instructions when the static call\n-  \/\/ stub is reached through the trampoline stub.\n+  \/\/ We maintain an invariant: every call site either points directly\n+  \/\/ to the call destination or to the call site's trampoline. The\n+  \/\/ trampoline points to the call destination. Even if the trampoline\n+  \/\/ is not in use, and therefore not reachable, it still points to\n+  \/\/ the call destination.\n+  \/\/\n+  \/\/ If a racing thread reaches the static call stub via the trampoline,\n+  \/\/ we must ensure that it observes the fully updated 'MOV' instructions.\n+  \/\/ Initially we place an ISB at the start of the static call stub.\n+  \/\/ After updating the 'MOV's, we rewrite the ISB with 'B .+4'. A racing\n+  \/\/ thread either observes the ISB or the branch. Once the stub has been\n+  \/\/ rewritten and the instruction and data caches have been synchronized\n+  \/\/ to the point of unification by ICache::invalidate_range, either\n+  \/\/ observation is sufficient to ensure that the subsequent instructions\n+  \/\/ are observed.\n@@ -137,10 +155,5 @@\n-  \/\/ To ensure correctness, we patch 'isb' to 'b .+4'. Before doing so, we already\n-  \/\/ update the 'MOV' instructions and enforce coherence between data writes and\n-  \/\/ instruction fetches within the same shareability domain by invoking\n-  \/\/ ICache::invalidate_range(). As confirmed by the litmus test below, when the\n-  \/\/ executing thread reaches the static call stub:\n-  \/\/   - If it observes the 'b .+4', it will also observe the updated 'MOV's (similarly\n-  \/\/     to the case above where the thread reaches patched code via a patched direct\n-  \/\/     branch).\n-  \/\/   - Otherwise, it will execute the 'isb' - the instruction fetch ensures the\n-  \/\/     updated 'MOV's are observed.\n+  \/\/ As confirmed by the litmus test below, when a racing executing\n+  \/\/ thread reaches the static call stub:\n+  \/\/   - If it observes the 'B .+4', it will also observe the updated 'MOV's.\n+  \/\/   - Or, it will execute the 'ISB' - the instruction fetch ensures\n+  \/\/     the updated 'MOV's are observed.\n@@ -173,1 +186,0 @@\n-\n@@ -175,1 +187,0 @@\n-\n@@ -180,1 +191,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"}]}