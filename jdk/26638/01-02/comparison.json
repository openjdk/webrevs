{"files":[{"patch":"@@ -130,4 +130,6 @@\n-  \/\/ However, the static call stub can also be reached via an indirect branch\n-  \/\/ from the trampoline stub. In that case, the above guarantee does not apply,\n-  \/\/ so directly removing the 'isb' would not ensure visibility of the updated\n-  \/\/ instructions when the static call stub is reached through the trampoline stub.\n+  \/\/ Generally, we keep the trampoline destination and the call destination\n+  \/\/ the same, which means the static call stub is also reachable via an\n+  \/\/ indirect branch from the trampoline stub. In that case, the above\n+  \/\/ guarantee does not apply, so directly removing the 'isb' would not\n+  \/\/ ensure visibility of the updated instructions when the static call\n+  \/\/ stub is reached through the trampoline stub.\n@@ -135,2 +137,2 @@\n-  \/\/ To ensure correctness, we patch 'isb' to 'nop'. Before doing so, we already update\n-  \/\/ the 'MOV' instructions and enforce coherence between data writes and\n+  \/\/ To ensure correctness, we patch 'isb' to 'b .+4'. Before doing so, we already\n+  \/\/ update the 'MOV' instructions and enforce coherence between data writes and\n@@ -140,1 +142,1 @@\n-  \/\/   - If it observes the 'nop', it will also observe the updated 'MOV's (similarly\n+  \/\/   - If it observes the 'b .+4', it will also observe the updated 'MOV's (similarly\n@@ -152,1 +154,1 @@\n-  \/\/ 0:X2 = instr:\"nop\";\n+  \/\/ 0:X2 = instr:\"b .+4\";\n@@ -171,3 +173,7 @@\n-  CodeBuffer stub_first_instruction(stub, Assembler::instruction_size);\n-  Assembler assembler(&stub_first_instruction);\n-  assembler.nop();\n+\n+  NativeJump::insert(stub, stub + NativeJump::instruction_size);\n+\n+  address trampoline_stub_addr = _call->get_trampoline();\n+  if (trampoline_stub_addr != nullptr) {\n+    nativeCallTrampolineStub_at(trampoline_stub_addr)->set_destination(stub);\n+  }\n@@ -176,1 +182,1 @@\n-  set_destination_mt_safe(stub);\n+  _call->set_destination(stub);\n@@ -184,1 +190,1 @@\n-  \/\/ Patch 'nop' to 'isb'.\n+  \/\/ Patch 'b .+4' to 'isb'.\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -241,0 +241,8 @@\n+\/\/ Atomic insertion of jump to target.\n+void NativeJump::insert(address code_pos, address target) {\n+  intptr_t offset = target - code_pos;\n+  uint32_t insn = 0b000101 << 26;\n+  Instruction_aarch64::spatch((address)&insn, 25, 0, offset >> 2);\n+  AtomicAccess::store((volatile uint32_t*)code_pos, insn);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,4 +62,2 @@\n-    @Fork(value = 1, jvmArgs = {\n-        \"-XX:+SegmentedCodeCache -XX:ReservedCodeCacheSize=200M\"\n-    })\n-    public static class StaticCallStubNear extends StaticCallStub {}\n+    @Fork(value = 1, jvmArgs = { \"-XX:+SegmentedCodeCache\", \"-XX:ReservedCodeCacheSize=200M\"})\n+    public static class NearJump extends StaticCallStub {}\n@@ -67,4 +65,2 @@\n-    @Fork(value = 1, jvmArgs = {\n-        \"-XX:+SegmentedCodeCache -XX:ReservedCodeCacheSize=256M\"\n-    })\n-    public static class StaticCallStubFar extends StaticCallStub {}\n+    @Fork(value = 1, jvmArgs = {\"-XX:+SegmentedCodeCache\", \"-XX:ReservedCodeCacheSize=256M\"})\n+    public static class FarJump extends StaticCallStub {}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/StaticCallStub.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"}]}