{"files":[{"patch":"@@ -43,1 +43,3 @@\n-ContiguousSpace::ContiguousSpace(): Space(),\n+ContiguousSpace::ContiguousSpace():\n+  _bottom(nullptr),\n+  _end(nullptr),\n@@ -104,1 +106,1 @@\n-void Space::print_short() const { print_short_on(tty); }\n+void ContiguousSpace::print_short() const { print_short_on(tty); }\n@@ -106,1 +108,1 @@\n-void Space::print_short_on(outputStream* st) const {\n+void ContiguousSpace::print_short_on(outputStream* st) const {\n@@ -111,7 +113,1 @@\n-void Space::print() const { print_on(tty); }\n-\n-void Space::print_on(outputStream* st) const {\n-  print_short_on(st);\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-                p2i(bottom()), p2i(end()));\n-}\n+void ContiguousSpace::print() const { print_on(tty); }\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-class Space;\n@@ -54,0 +53,1 @@\n+class GenSpaceMangler;\n@@ -55,4 +55,2 @@\n-\/\/ A Space describes a heap area. Class Space is an abstract\n-\/\/ base class.\n-\/\/\n-\/\/ Space supports allocation, size computation and GC support is provided.\n+\/\/ A space in which the free area is contiguous.  It therefore supports\n+\/\/ faster allocation, and compaction.\n@@ -63,2 +61,1 @@\n-\n-class Space: public CHeapObj<mtGC> {\n+class ContiguousSpace: public CHeapObj<mtGC> {\n@@ -66,1 +63,2 @@\n- protected:\n+\n+private:\n@@ -73,2 +71,15 @@\n-  Space():\n-    _bottom(nullptr), _end(nullptr) { }\n+  ContiguousSpace* _next_compaction_space;\n+\n+  HeapWord* _top;\n+  \/\/ A helper for mangling the unused area of the space in debug builds.\n+  GenSpaceMangler* _mangler;\n+\n+  GenSpaceMangler* mangler() { return _mangler; }\n+\n+  \/\/ Allocation helpers (return null if full).\n+  inline HeapWord* allocate_impl(size_t word_size);\n+  inline HeapWord* par_allocate_impl(size_t word_size);\n+\n+public:\n+  ContiguousSpace();\n+  ~ContiguousSpace();\n@@ -76,1 +87,0 @@\n- public:\n@@ -85,4 +95,0 @@\n-  \/\/ Returns a subregion of the space containing only the allocated objects in\n-  \/\/ the space.\n-  virtual MemRegion used_region() const = 0;\n-\n@@ -101,7 +107,0 @@\n-  \/\/ For detecting GC bugs.  Should only be called at GC boundaries, since\n-  \/\/ some unused space may be used as scratch space during GC's.\n-  \/\/ We also call this when expanding a space to satisfy an allocation\n-  \/\/ request. See bug #4668531\n-  virtual void mangle_unused_area() = 0;\n-  virtual void mangle_unused_area_complete() = 0;\n-\n@@ -126,16 +125,3 @@\n-  size_t capacity()     const { return byte_size(bottom(), end()); }\n-  virtual size_t used() const = 0;\n-  virtual size_t free() const = 0;\n-\n-  \/\/ If \"p\" is in the space, returns the address of the start of the\n-  \/\/ \"block\" that contains \"p\".  We say \"block\" instead of \"object\" since\n-  \/\/ some heaps may not pack objects densely; a chunk may either be an\n-  \/\/ object or a non-object.  If \"p\" is not in the space, return null.\n-  virtual HeapWord* block_start_const(const void* p) const = 0;\n-\n-  \/\/ Allocation (return null if full).  Assumes the caller has established\n-  \/\/ mutually exclusive access to the space.\n-  virtual HeapWord* allocate(size_t word_size) = 0;\n-\n-  \/\/ Allocation (return null if full).  Enforces mutual exclusion internally.\n-  virtual HeapWord* par_allocate(size_t word_size) = 0;\n+  size_t capacity() const { return byte_size(bottom(), end()); }\n+  size_t used()     const { return byte_size(bottom(), top()); }\n+  size_t free()     const { return byte_size(top(),    end()); }\n@@ -147,26 +133,0 @@\n-};\n-\n-class GenSpaceMangler;\n-\n-\/\/ A space in which the free area is contiguous.  It therefore supports\n-\/\/ faster allocation, and compaction.\n-class ContiguousSpace: public Space {\n-  friend class VMStructs;\n-\n-private:\n-  ContiguousSpace* _next_compaction_space;\n-\n-protected:\n-  HeapWord* _top;\n-  \/\/ A helper for mangling the unused area of the space in debug builds.\n-  GenSpaceMangler* _mangler;\n-\n-  GenSpaceMangler* mangler() { return _mangler; }\n-\n-  \/\/ Allocation helpers (return null if full).\n-  inline HeapWord* allocate_impl(size_t word_size);\n-  inline HeapWord* par_allocate_impl(size_t word_size);\n-\n- public:\n-  ContiguousSpace();\n-  ~ContiguousSpace();\n@@ -209,3 +169,0 @@\n-  \/\/ In debug mode mangle (write it with a particular bit\n-  \/\/ pattern) the unused part of a space.\n-\n@@ -217,0 +174,4 @@\n+  \/\/ For detecting GC bugs.  Should only be called at GC boundaries, since\n+  \/\/ some unused space may be used as scratch space during GC's.\n+  \/\/ We also call this when expanding a space to satisfy an allocation\n+  \/\/ request. See bug #4668531\n@@ -219,1 +180,1 @@\n-  void mangle_unused_area() override PRODUCT_RETURN;\n+  void mangle_unused_area() PRODUCT_RETURN;\n@@ -221,1 +182,1 @@\n-  void mangle_unused_area_complete() override PRODUCT_RETURN;\n+  void mangle_unused_area_complete() PRODUCT_RETURN;\n@@ -229,7 +190,1 @@\n-  \/\/ Size computations: sizes in bytes.\n-  size_t used() const override   { return byte_size(bottom(), top()); }\n-  size_t free() const override   { return byte_size(top(),    end()); }\n-\n-  \/\/ In a contiguous space we have a more obvious bound on what parts\n-  \/\/ contain objects.\n-  MemRegion used_region() const override { return MemRegion(bottom(), top()); }\n+  MemRegion used_region() const { return MemRegion(bottom(), top()); }\n@@ -237,3 +192,5 @@\n-  \/\/ Allocation (return null if full)\n-  HeapWord* allocate(size_t word_size) override;\n-  HeapWord* par_allocate(size_t word_size) override;\n+  \/\/ Allocation (return null if full).  Assumes the caller has established\n+  \/\/ mutually exclusive access to the space.\n+  virtual HeapWord* allocate(size_t word_size);\n+  \/\/ Allocation (return null if full).  Enforces mutual exclusion internally.\n+  virtual HeapWord* par_allocate(size_t word_size);\n@@ -254,2 +211,5 @@\n-  \/\/ Very inefficient implementation.\n-  HeapWord* block_start_const(const void* p) const override;\n+  \/\/ If \"p\" is in the space, returns the address of the start of the\n+  \/\/ \"block\" that contains \"p\".  We say \"block\" instead of \"object\" since\n+  \/\/ some heaps may not pack objects densely; a chunk may either be an\n+  \/\/ object or a non-object.  If \"p\" is not in the space, return null.\n+  virtual HeapWord* block_start_const(const void* p) const;\n@@ -260,2 +220,0 @@\n-  void print_on(outputStream* st) const override;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":41,"deletions":83,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+  nonstatic_field(ContiguousSpace,             _bottom,                                       HeapWord*)                             \\\n+  nonstatic_field(ContiguousSpace,             _end,                                          HeapWord*)                             \\\n@@ -105,4 +107,1 @@\n-  nonstatic_field(MemRegion,                   _word_size,                                    size_t)                                \\\n-                                                                                                                                     \\\n-  nonstatic_field(Space,                       _bottom,                                       HeapWord*)                             \\\n-  nonstatic_field(Space,                       _end,                                          HeapWord*)\n+  nonstatic_field(MemRegion,                   _word_size,                                    size_t)\n@@ -138,2 +137,1 @@\n-  declare_toplevel_type(Space)                                            \\\n-           declare_type(ContiguousSpace,             Space)               \\\n+  declare_toplevel_type(ContiguousSpace)                                  \\\n@@ -167,1 +165,0 @@\n-  declare_toplevel_type(Space*)                                           \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-  private static GenerationFactory genFactory;\n-\n@@ -64,2 +62,0 @@\n-\n-    genFactory = new GenerationFactory();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/SerialHeap.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,11 @@\n-public class ContiguousSpace extends Space implements LiveRegionsProvider {\n+\/** <P> A ContiguousSpace describes a heap area. <\/P>\n+\n+    <P> Invariant: bottom() and end() are on page_size boundaries and: <\/P>\n+\n+    <P> bottom() <= top() <= end() <\/P>\n+\n+    <P> top() is inclusive and end() is exclusive. <\/P> *\/\n+\n+public class ContiguousSpace extends VMObject implements LiveRegionsProvider {\n+  private static AddressField bottomField;\n+  private static AddressField endField;\n@@ -51,0 +61,2 @@\n+    bottomField = type.getAddressField(\"_bottom\");\n+    endField    = type.getAddressField(\"_end\");\n@@ -58,3 +70,3 @@\n-  public Address top() {\n-    return topField.getValue(addr);\n-  }\n+  public Address bottom() { return bottomField.getValue(addr); }\n+  public Address end()    { return endField.getValue(addr);    }\n+  public Address top()    { return topField.getValue(addr);    }\n@@ -62,3 +74,5 @@\n-  \/** In bytes *\/\n-  public long capacity() {\n-    return end().minus(bottom());\n+  \/** Support for iteration over heap -- not sure how this will\n+      interact with GC in reflective system, but necessary for the\n+      debugging mechanism *\/\n+  public OopHandle bottomAsOopHandle() {\n+    return bottomField.getOopHandle(addr);\n@@ -67,3 +81,5 @@\n-  \/** In bytes *\/\n-  public long used() {\n-    return top().minus(bottom());\n+  \/** Support for iteration over heap -- not sure how this will\n+      interact with GC in reflective system, but necessary for the\n+      debugging mechanism *\/\n+  public OopHandle nextOopHandle(OopHandle handle, long size) {\n+    return handle.addOffsetToAsOopHandle(size);\n@@ -72,4 +88,6 @@\n-  \/** In bytes *\/\n-  public long free() {\n-    return end().minus(top());\n-  }\n+  \/** Returned value is in bytes *\/\n+  public long capacity() { return end().minus(bottom()); }\n+  public long used()     { return top().minus(bottom()); }\n+  public long free()     { return end().minus(top());    }\n+\n+  public void print() { printOn(System.out); }\n@@ -98,1 +116,5 @@\n-    super.printOn(tty);\n+    tty.print(\" space capacity = \");\n+    tty.print(capacity());\n+    tty.print(\", \");\n+    tty.print((double) used() * 100.0\/ capacity());\n+    tty.print(\" used\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/ContiguousSpace.java","additions":37,"deletions":15,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.shared;\n-\n-import java.util.*;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.gc.serial.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-\/** Factory containing a VirtualConstructor suitable for instantiating\n-    wrapper objects for all types of generations *\/\n-\n-public class GenerationFactory {\n-  private static VirtualConstructor ctor;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    ctor = new VirtualConstructor(db);\n-\n-    ctor.addMapping(\"DefNewGeneration\", DefNewGeneration.class);\n-    ctor.addMapping(\"TenuredGeneration\", TenuredGeneration.class);\n-  }\n-\n-  public static Generation newObject(Address addr) {\n-      try {\n-          return (Generation) ctor.instantiateWrapperFor(addr);\n-      } catch (WrongTypeException e) {\n-          return new Generation(addr) {\n-                  public String name() {\n-                      return \"unknown generation type\";\n-                  }\n-                  public void spaceIterate(SpaceClosure blk, boolean usedOnly) {\n-                  }\n-                  public void liveRegionsIterate(LiveRegionsClosure closure) {\n-                  }\n-                  public void printOn(java.io.PrintStream tty) {\n-                      tty.println(\"unknown subtype of Generation @ \" + getAddress() + \" (\" +\n-                                  virtualSpace().low() + \",\" + virtualSpace().high() + \")\");\n-                  }\n-                  public long used() {\n-                      return 0;\n-                  }\n-                  public long free() {\n-                      return 0;\n-                  }\n-                  public long capacity() {\n-                      return 0;\n-                  }\n-                  public long contiguousAvailable() {\n-                      return 0;\n-                  }\n-\n-              };\n-      }\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/GenerationFactory.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.shared;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.memory.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-\/** <P> A Space describes a heap area. Class Space is an abstract base\n-    class. <\/P>\n-\n-    <P> Space supports allocation, size computation and GC support is\n-    provided. <\/P>\n-\n-    <P> Invariant: bottom() and end() are on page_size boundaries and: <\/P>\n-\n-    <P> bottom() <= top() <= end() <\/P>\n-\n-    <P> top() is inclusive and end() is exclusive. <\/P> *\/\n-\n-public abstract class Space extends VMObject {\n-  private static AddressField bottomField;\n-  private static AddressField endField;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"Space\");\n-\n-    bottomField = type.getAddressField(\"_bottom\");\n-    endField    = type.getAddressField(\"_end\");\n-  }\n-\n-  public Space(Address addr) {\n-    super(addr);\n-  }\n-\n-  public Address   bottom()       { return bottomField.getValue(addr); }\n-  public Address   end()          { return endField.getValue(addr);    }\n-\n-  \/** Returns a subregion of the space containing all the objects in\n-      the space. *\/\n-  public MemRegion usedRegion() {\n-    return new MemRegion(bottom(), end());\n-  }\n-\n-  \/** Support for iteration over heap -- not sure how this will\n-      interact with GC in reflective system, but necessary for the\n-      debugging mechanism *\/\n-  public OopHandle bottomAsOopHandle() {\n-    return bottomField.getOopHandle(addr);\n-  }\n-\n-  \/** Support for iteration over heap -- not sure how this will\n-      interact with GC in reflective system, but necessary for the\n-      debugging mechanism *\/\n-  public OopHandle nextOopHandle(OopHandle handle, long size) {\n-    return handle.addOffsetToAsOopHandle(size);\n-  }\n-\n-  \/** Returned value is in bytes *\/\n-  public long capacity() { return end().minus(bottom()); }\n-  \/** Returned value is in bytes *\/\n-  public abstract long used();\n-  \/** Returned value is in bytes *\/\n-  public abstract long free();\n-\n-  \/** Testers *\/\n-  public boolean contains(Address p) {\n-    return (bottom().lessThanOrEqual(p) && end().greaterThan(p));\n-  }\n-\n-  public void print() { printOn(System.out); }\n-  public void printOn(PrintStream tty) {\n-    tty.print(\" space capacity = \");\n-    tty.print(capacity());\n-    tty.print(\", \");\n-    tty.print((double) used() * 100.0\/ capacity());\n-    tty.print(\" used\");\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/Space.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.shared;\n-\n-public interface SpaceClosure {\n-  public void doSpace(Space s);\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/SpaceClosure.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"}]}