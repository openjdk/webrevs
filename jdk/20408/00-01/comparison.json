{"files":[{"patch":"@@ -378,1 +378,1 @@\n-  __ ldrw(rscratch2, Address(rscratch1, ClassLoaderData::strongly_reachable_offset()));\n+  __ ldrw(rscratch2, Address(rscratch1, ClassLoaderData::keep_alive_ref_count_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  __ lwz(tmp2, in_bytes(ClassLoaderData::strongly_reachable_offset()), tmp1_class_loader_data);\n+  __ lwz(tmp2, in_bytes(ClassLoaderData::keep_alive_ref_count_offset()), tmp1_class_loader_data);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-  __ lwu(t1, Address(t0, ClassLoaderData::strongly_reachable_offset()));\n+  __ lwu(t1, Address(t0, ClassLoaderData::keep_alive_ref_count_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-  __ cmpl(Address(tmp1, ClassLoaderData::strongly_reachable_offset()), 0);\n+  __ cmpl(Address(tmp1, ClassLoaderData::keep_alive_ref_count_offset()), 0);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  _strongly_reachable((has_class_mirror_holder || h_class_loader.is_null()) ? 1 : 0),\n+  _keep_alive_ref_count((has_class_mirror_holder || h_class_loader.is_null()) ? 1 : 0),\n@@ -348,2 +348,2 @@\n-\/\/ it is being defined, therefore _strongly_reachable is not volatile or atomic.\n-void ClassLoaderData::inc_strongly_reachable() {\n+\/\/ it is being defined, therefore _keep_alive_ref_count is not volatile or atomic.\n+void ClassLoaderData::inc_keep_alive_ref_count() {\n@@ -351,2 +351,2 @@\n-    assert(_strongly_reachable > 0, \"Invalid keep alive increment count\");\n-    _strongly_reachable++;\n+    assert(_keep_alive_ref_count > 0, \"Invalid keep alive increment count\");\n+    _keep_alive_ref_count++;\n@@ -356,1 +356,1 @@\n-void ClassLoaderData::dec_strongly_reachable() {\n+void ClassLoaderData::dec_keep_alive_ref_count() {\n@@ -358,3 +358,3 @@\n-    assert(_strongly_reachable > 0, \"Invalid keep alive decrement count\");\n-    if (_strongly_reachable == 1) {\n-      \/\/ When the strongly_reachable counter is 1, the oop handle area is a strong root,\n+    assert(_keep_alive_ref_count > 0, \"Invalid keep alive decrement count\");\n+    if (_keep_alive_ref_count == 1) {\n+      \/\/ When the keep_alive_ref_count counter is 1, the oop handle area is a strong root,\n@@ -367,1 +367,1 @@\n-    _strongly_reachable--;\n+    _keep_alive_ref_count--;\n@@ -683,2 +683,2 @@\n-  bool alive = is_strongly_reachable() \/\/ null class loader and incomplete non-strong hidden class.\n-      || (_holder.peek() != nullptr);  \/\/ and not cleaned by the GC weak handle processing.\n+  bool alive = (_keep_alive_ref_count > 0) \/\/ null class loader and incomplete non-strong hidden class.\n+      || (_holder.peek() != nullptr);      \/\/ and not cleaned by the GC weak handle processing.\n@@ -1012,1 +1012,1 @@\n-  out->print_cr(\" - is_strongly_reachable %d\", _strongly_reachable);\n+  out->print_cr(\" - _keep_alive_ref_count %d\", _keep_alive_ref_count);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -128,4 +128,4 @@\n-  int _strongly_reachable; \/\/ if this CLD should not be considered eligible for unloading.\n-                           \/\/ Used for non-strong hidden classes and the\n-                           \/\/ boot class loader. _strongly_reachable does not need to be volatile or\n-                           \/\/ atomic since there is one unique CLD per non-strong hidden class.\n+  int _keep_alive_ref_count; \/\/ if this CLD should not be considered eligible for unloading.\n+                             \/\/ Used for non-strong hidden classes and the\n+                             \/\/ boot class loader. _keep_alive_ref_count does not need to be volatile or\n+                             \/\/ atomic since there is one unique CLD per non-strong hidden class.\n@@ -215,1 +215,1 @@\n-  bool is_strongly_reachable() const { return _strongly_reachable > 0; }\n+  bool keep_alive_ref_count() const { return _keep_alive_ref_count; }\n@@ -308,2 +308,2 @@\n-  void inc_strongly_reachable();\n-  void dec_strongly_reachable();\n+  void inc_keep_alive_ref_count();\n+  void dec_keep_alive_ref_count();\n@@ -341,1 +341,1 @@\n-  static ByteSize strongly_reachable_offset() { return byte_offset_of(ClassLoaderData, _strongly_reachable); }\n+  static ByteSize keep_alive_ref_count_offset() { return byte_offset_of(ClassLoaderData, _keep_alive_ref_count); }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-    CLDClosure* closure = cld->is_strongly_reachable() ? strong : weak;\n+    CLDClosure* closure = (cld->keep_alive_ref_count() > 0) ? strong : weak;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-        k->class_loader_data()->inc_strongly_reachable();\n+        k->class_loader_data()->inc_keep_alive_ref_count();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -708,1 +708,1 @@\n-    k->class_loader_data()->dec_strongly_reachable();\n+    k->class_loader_data()->dec_keep_alive_ref_count();\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1035,1 +1035,1 @@\n-    ik->class_loader_data()->dec_strongly_reachable();\n+    ik->class_loader_data()->dec_keep_alive_ref_count();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}