{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,1 @@\n-  __ ldrw(rscratch2, Address(rscratch1, ClassLoaderData::keep_alive_offset()));\n+  __ ldrw(rscratch2, Address(rscratch1, ClassLoaderData::keep_alive_ref_count_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,1 +241,1 @@\n-  __ lwz(tmp2, in_bytes(ClassLoaderData::keep_alive_offset()), tmp1_class_loader_data);\n+  __ lwz(tmp2, in_bytes(ClassLoaderData::keep_alive_ref_count_offset()), tmp1_class_loader_data);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -329,1 +329,1 @@\n-  __ lwu(t1, Address(t0, ClassLoaderData::keep_alive_offset()));\n+  __ lwu(t1, Address(t0, ClassLoaderData::keep_alive_ref_count_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -426,1 +426,1 @@\n-  __ cmpl(Address(tmp1, ClassLoaderData::keep_alive_offset()), 0);\n+  __ cmpl(Address(tmp1, ClassLoaderData::keep_alive_ref_count_offset()), 0);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  _keep_alive((has_class_mirror_holder || h_class_loader.is_null()) ? 1 : 0),\n+  _keep_alive_ref_count((has_class_mirror_holder || h_class_loader.is_null()) ? 1 : 0),\n@@ -348,2 +348,2 @@\n-\/\/ it is being defined, therefore _keep_alive is not volatile or atomic.\n-void ClassLoaderData::inc_keep_alive() {\n+\/\/ it is being defined, therefore _keep_alive_ref_count is not volatile or atomic.\n+void ClassLoaderData::inc_keep_alive_ref_count() {\n@@ -351,2 +351,2 @@\n-    assert(_keep_alive > 0, \"Invalid keep alive increment count\");\n-    _keep_alive++;\n+    assert(_keep_alive_ref_count > 0, \"Invalid keep alive increment count\");\n+    _keep_alive_ref_count++;\n@@ -356,1 +356,1 @@\n-void ClassLoaderData::dec_keep_alive() {\n+void ClassLoaderData::dec_keep_alive_ref_count() {\n@@ -358,3 +358,3 @@\n-    assert(_keep_alive > 0, \"Invalid keep alive decrement count\");\n-    if (_keep_alive == 1) {\n-      \/\/ When the keep_alive counter is 1, the oop handle area is a strong root,\n+    assert(_keep_alive_ref_count > 0, \"Invalid keep alive decrement count\");\n+    if (_keep_alive_ref_count == 1) {\n+      \/\/ When the keep_alive_ref_count counter is 1, the oop handle area is a strong root,\n@@ -367,1 +367,1 @@\n-    _keep_alive--;\n+    _keep_alive_ref_count--;\n@@ -683,2 +683,2 @@\n-  bool alive = keep_alive()         \/\/ null class loader and incomplete non-strong hidden class.\n-      || (_holder.peek() != nullptr);  \/\/ and not cleaned by the GC weak handle processing.\n+  bool alive = (_keep_alive_ref_count > 0) \/\/ null class loader and incomplete non-strong hidden class.\n+      || (_holder.peek() != nullptr);      \/\/ and not cleaned by the GC weak handle processing.\n@@ -1012,1 +1012,1 @@\n-  out->print_cr(\" - keep alive          %d\", _keep_alive);\n+  out->print_cr(\" - _keep_alive_ref_count %d\", _keep_alive_ref_count);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,4 +128,4 @@\n-  int _keep_alive;         \/\/ if this CLD is kept alive.\n-                           \/\/ Used for non-strong hidden classes and the\n-                           \/\/ boot class loader. _keep_alive does not need to be volatile or\n-                           \/\/ atomic since there is one unique CLD per non-strong hidden class.\n+  int _keep_alive_ref_count; \/\/ if this CLD should not be considered eligible for unloading.\n+                             \/\/ Used for non-strong hidden classes and the\n+                             \/\/ boot class loader. _keep_alive_ref_count does not need to be volatile or\n+                             \/\/ atomic since there is one unique CLD per non-strong hidden class.\n@@ -208,0 +208,1 @@\n+  \/\/ Resolving the holder keeps this CLD alive for the current GC cycle.\n@@ -209,0 +210,1 @@\n+  void keep_alive() const { (void)holder(); }\n@@ -213,1 +215,1 @@\n-  bool keep_alive() const       { return _keep_alive > 0; }\n+  int keep_alive_ref_count() const { return _keep_alive_ref_count; }\n@@ -305,3 +307,4 @@\n-  \/\/ Used to refcount a non-strong hidden class's s CLD in order to indicate their aliveness.\n-  void inc_keep_alive();\n-  void dec_keep_alive();\n+  \/\/ Used to refcount a non-strong hidden class's CLD in order to force its aliveness during\n+  \/\/ loading, when gc tracing may not find this CLD alive through the holder.\n+  void inc_keep_alive_ref_count();\n+  void dec_keep_alive_ref_count();\n@@ -338,2 +341,2 @@\n-  static ByteSize holder_offset()     { return byte_offset_of(ClassLoaderData, _holder); }\n-  static ByteSize keep_alive_offset() { return byte_offset_of(ClassLoaderData, _keep_alive); }\n+  static ByteSize holder_offset() { return byte_offset_of(ClassLoaderData, _holder); }\n+  static ByteSize keep_alive_ref_count_offset() { return byte_offset_of(ClassLoaderData, _keep_alive_ref_count); }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,1 @@\n-    CLDClosure* closure = cld->keep_alive() ? strong : weak;\n+    CLDClosure* closure = (cld->keep_alive_ref_count() > 0) ? strong : weak;\n@@ -312,2 +312,1 @@\n-    \/\/ Keep the holder alive.\n-    (void)cld->holder();\n+    cld->keep_alive();\n@@ -337,2 +336,1 @@\n-    \/\/ Keep the holder alive.\n-    (void)cld->holder();\n+    cld->keep_alive();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-        k->class_loader_data()->inc_keep_alive();\n+        k->class_loader_data()->inc_keep_alive_ref_count();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -708,1 +708,1 @@\n-    k->class_loader_data()->dec_keep_alive();\n+    k->class_loader_data()->dec_keep_alive_ref_count();\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1035,1 +1035,1 @@\n-    ik->class_loader_data()->dec_keep_alive();\n+    ik->class_loader_data()->dec_keep_alive_ref_count();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}