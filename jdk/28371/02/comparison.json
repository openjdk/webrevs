{"files":[{"patch":"@@ -152,0 +152,4 @@\n+\n+  \/\/ Fetch Klass::access_flags.\n+  jint                   access_flags() { return flags().as_int(); }\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -219,9 +219,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciKlass::access_flags\n-jint ciKlass::access_flags() {\n-  assert(is_loaded(), \"not loaded\");\n-  GUARDED_VM_ENTRY(\n-    return get_Klass()->access_flags().as_unsigned_short();\n-  )\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -125,3 +125,0 @@\n-  \/\/ Fetch Klass::access_flags.\n-  jint                   access_flags();\n-\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-    Klass* method_holder = _selected_target->method_holder();\n+    InstanceKlass* method_holder = _selected_target->method_holder();\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1096,2 +1096,1 @@\n-  assert(!k->is_array_klass() || k->access_flags().as_unsigned_short() == 0, \"access flags are not set for arrays\");\n-  set_raw_access_flags(mirror(), k->access_flags().as_unsigned_short());\n+  set_raw_access_flags(mirror(), k->is_array_klass() ? 0 : InstanceKlass::cast(k)->access_flags().as_unsigned_short());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2171,3 +2171,4 @@\n-  return klass->is_public() &&\n-         (InstanceKlass::cast(klass)->is_same_class_package(vmClasses::Object_klass()) ||       \/\/ java.lang\n-          InstanceKlass::cast(klass)->is_same_class_package(vmClasses::MethodHandle_klass()));  \/\/ java.lang.invoke\n+  InstanceKlass* ik = InstanceKlass::cast(klass);\n+  return ik->is_public() &&\n+         (ik->is_same_class_package(vmClasses::Object_klass()) ||       \/\/ java.lang\n+          ik->is_same_class_package(vmClasses::MethodHandle_klass()));  \/\/ java.lang.invoke\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -225,0 +225,1 @@\n+  nonstatic_field(InstanceKlass,               _access_flags,                                 AccessFlags)                           \\\n@@ -284,1 +285,0 @@\n-  nonstatic_field(Klass,                       _access_flags,                                 AccessFlags)                           \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,2 @@\n-  set_is_cloneable(); \/\/ All arrays are considered to be cloneable (See JLS 20.1.5)\n+  \/\/ All arrays are considered to be cloneable (See JLS 20.1.5)\n+  set_is_cloneable_fast();\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/accessFlags.hpp\"\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -555,0 +555,11 @@\n+void InstanceKlass::set_is_cloneable() {\n+  if (name() == vmSymbols::java_lang_invoke_MemberName()) {\n+    assert(is_final(), \"no subclasses allowed\");\n+    \/\/ MemberName cloning should not be intrinsified and always happen in JVM_Clone.\n+  } else if (reference_type() != REF_NONE) {\n+    \/\/ Reference cloning should not be intrinsified and always happen in JVM_Clone.\n+  } else {\n+    set_is_cloneable_fast();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -232,1 +232,3 @@\n-  u1              _reference_type;                \/\/ reference type\n+  u1                 _reference_type;                \/\/ reference type\n+\n+  AccessFlags        _access_flags;    \/\/ Access flags. The class\/interface distinction is stored here.\n@@ -308,0 +310,16 @@\n+  \/\/ Access flags\n+  AccessFlags access_flags() const         { return _access_flags;  }\n+  void set_access_flags(AccessFlags flags) { _access_flags = flags; }\n+\n+  bool is_public() const                { return _access_flags.is_public(); }\n+  bool is_final() const                 { return _access_flags.is_final(); }\n+  bool is_interface() const             { return _access_flags.is_interface(); }\n+  bool is_abstract() const              { return _access_flags.is_abstract(); }\n+  bool is_super() const                 { return _access_flags.is_super(); }\n+  bool is_synthetic() const             { return _access_flags.is_synthetic(); }\n+  void set_is_synthetic()               { _access_flags.set_is_synthetic(); }\n+\n+  static ByteSize access_flags_offset() { return byte_offset_of(InstanceKlass, _access_flags); }\n+\n+  void set_is_cloneable();\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -71,11 +71,0 @@\n-void Klass::set_is_cloneable() {\n-  if (name() == vmSymbols::java_lang_invoke_MemberName()) {\n-    assert(is_final(), \"no subclasses allowed\");\n-    \/\/ MemberName cloning should not be intrinsified and always happen in JVM_Clone.\n-  } else if (is_instance_klass() && InstanceKlass::cast(this)->reference_type() != REF_NONE) {\n-    \/\/ Reference cloning should not be intrinsified and always happen in JVM_Clone.\n-  } else {\n-    _misc_flags.set_is_cloneable_fast(true);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"utilities\/accessFlags.hpp\"\n@@ -123,3 +122,2 @@\n-  AccessFlags _access_flags;    \/\/ Access flags. The class\/interface distinction is stored here.\n-                                \/\/ Some flags created by the JVM, not in the class file itself,\n-                                \/\/ are in _misc_flags below.\n+  \/\/ Some flags created by the JVM, not in the class file itself,\n+  \/\/ are in _misc_flags below.\n@@ -456,1 +454,0 @@\n-  static ByteSize access_flags_offset()          { return byte_offset_of(Klass, _access_flags); }\n@@ -710,11 +707,4 @@\n-  \/\/ Access flags\n-  AccessFlags access_flags() const         { return _access_flags;  }\n-  void set_access_flags(AccessFlags flags) { _access_flags = flags; }\n-\n-  bool is_public() const                { return _access_flags.is_public(); }\n-  bool is_final() const                 { return _access_flags.is_final(); }\n-  bool is_interface() const             { return _access_flags.is_interface(); }\n-  bool is_abstract() const              { return _access_flags.is_abstract(); }\n-  bool is_super() const                 { return _access_flags.is_super(); }\n-  bool is_synthetic() const             { return _access_flags.is_synthetic(); }\n-  void set_is_synthetic()               { _access_flags.set_is_synthetic(); }\n+\n+  virtual bool is_interface() const     { return false; }\n+  virtual bool is_abstract() const      { return false; }\n+\n@@ -733,1 +723,1 @@\n-  void set_is_cloneable();\n+  void set_is_cloneable_fast() { _misc_flags.set_is_cloneable_fast(true); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1729,1 +1729,1 @@\n-      if (flat->offset() == in_bytes(Klass::access_flags_offset()))\n+      if (flat->isa_instklassptr() && flat->offset() == in_bytes(InstanceKlass::access_flags_offset()))\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3988,1 +3988,1 @@\n-                                    Klass::access_flags_offset(), TypeInt::CHAR, T_CHAR);\n+                                    InstanceKlass::access_flags_offset(), TypeInt::CHAR, T_CHAR);\n@@ -4100,3 +4100,0 @@\n-    if (generate_interface_guard(kls, region) != nullptr)\n-      \/\/ A guard was added.  If the guard is taken, it was an interface.\n-      phi->add_req(null());\n@@ -4106,0 +4103,3 @@\n+    if (generate_interface_guard(kls, region) != nullptr)\n+      \/\/ A guard was added.  If the guard is taken, it was an interface.\n+      phi->add_req(null());\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1982,2 +1982,3 @@\n-  if (tkls->offset() == in_bytes(Klass::access_flags_offset())) {\n-    \/\/ The field is Klass::_access_flags.  Return its (constant) value.\n+\n+  if (tkls->isa_instklassptr() && tkls->offset() == in_bytes(InstanceKlass::access_flags_offset())) {\n+    \/\/ The field is InstanceKlass::_access_flags.  Return its (constant) value.\n@@ -1985,1 +1986,2 @@\n-    return TypeInt::make(klass->access_flags());\n+    ciInstanceKlass* iklass = tkls->is_instklassptr()->instance_klass();\n+    return TypeInt::make(iklass->access_flags());\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+  nonstatic_field(InstanceKlass,               _access_flags,                                 AccessFlags)                           \\\n@@ -225,1 +226,0 @@\n-  nonstatic_field(Klass,                       _access_flags,                                 AccessFlags)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  friend class Klass;\n+  friend class InstanceKlass;\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,10 @@\n+  public long     getAccessFlags()      { return            accessFlags.getValue(this);  }\n+  \/\/ Convenience routine\n+  public AccessFlags getAccessFlagsObj(){ return new AccessFlags(getAccessFlags());      }\n+\n+  public boolean isPublic()                 { return getAccessFlagsObj().isPublic(); }\n+  public boolean isFinal()                  { return getAccessFlagsObj().isFinal(); }\n+  public boolean isInterface()              { return getAccessFlagsObj().isInterface(); }\n+  public boolean isAbstract()               { return getAccessFlagsObj().isAbstract(); }\n+  public boolean isSuper()                  { return getAccessFlagsObj().isSuper(); }\n+  public boolean isSynthetic()              { return getAccessFlagsObj().isSynthetic(); }\n@@ -91,0 +101,1 @@\n+    accessFlags  = new CIntField(type.getCIntegerField(\"_access_flags\"), 0);\n@@ -153,0 +164,1 @@\n+  private static CIntField accessFlags;\n@@ -502,1 +514,1 @@\n-  public boolean implementsInterface(Klass k) {\n+  public boolean implementsInterface(InstanceKlass k) {\n@@ -514,1 +526,1 @@\n-  boolean computeSubtypeOf(Klass k) {\n+  boolean computeSubtypeOf(InstanceKlass k) {\n@@ -538,0 +550,1 @@\n+      visitor.doCInt(accessFlags, true);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-    accessFlags  = new CIntField(type.getCIntegerField(\"_access_flags\"), 0);\n@@ -98,1 +97,0 @@\n-  private static CIntField accessFlags;\n@@ -120,3 +118,0 @@\n-  public long     getAccessFlags()      { return            accessFlags.getValue(this);  }\n-  \/\/ Convenience routine\n-  public AccessFlags getAccessFlagsObj(){ return new AccessFlags(getAccessFlags());      }\n@@ -178,1 +173,0 @@\n-      visitor.doCInt(accessFlags, true);\n@@ -208,8 +202,0 @@\n-\n-  \/\/ Convenience routines\n-  public boolean isPublic()                 { return getAccessFlagsObj().isPublic(); }\n-  public boolean isFinal()                  { return getAccessFlagsObj().isFinal(); }\n-  public boolean isInterface()              { return getAccessFlagsObj().isInterface(); }\n-  public boolean isAbstract()               { return getAccessFlagsObj().isAbstract(); }\n-  public boolean isSuper()                  { return getAccessFlagsObj().isSuper(); }\n-  public boolean isSynthetic()              { return getAccessFlagsObj().isSynthetic(); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Klass.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-  public void iterateObjectsOfKlass(HeapVisitor visitor, final Klass k, boolean includeSubtypes) {\n+  public void iterateObjectsOfKlass(HeapVisitor visitor, final InstanceKlass k, boolean includeSubtypes) {\n@@ -127,1 +127,1 @@\n-  public void iterateObjectsOfKlass(HeapVisitor visitor, final Klass k) {\n+  public void iterateObjectsOfKlass(HeapVisitor visitor, final InstanceKlass k) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ObjectHeap.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-        Klass absOwnSyncKlass = sysDict.getAbstractOwnableSynchronizerKlass();\n+        InstanceKlass absOwnSyncKlass = sysDict.getAbstractOwnableSynchronizerKlass();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ConcurrentLocksPrinter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-      Klass classLoaderKlass = vm.getSystemDictionary().getClassLoaderKlass();\n+      InstanceKlass classLoaderKlass = vm.getSystemDictionary().getClassLoaderKlass();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/ClassLoaderStats.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,2 +168,6 @@\n-        HotSpotVMConfig config = config();\n-        return UNSAFE.getInt(getKlassPointer() + config.klassAccessFlagsOffset);\n+        if (isArray()) {\n+            return 0; \/\/ Array Metadata doesn't set access_flags\n+        } else {\n+            HotSpotVMConfig config = config();\n+            return UNSAFE.getInt(getKlassPointer() + config.instanceKlassAccessFlagsOffset);\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-    final int klassAccessFlagsOffset = getFieldOffset(\"Klass::_access_flags\", Integer.class, \"AccessFlags\");\n@@ -96,0 +95,1 @@\n+    final int instanceKlassAccessFlagsOffset = getFieldOffset(\"InstanceKlass::_access_flags\", Integer.class, \"AccessFlags\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}