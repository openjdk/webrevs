{"files":[{"patch":"@@ -152,1 +152,2 @@\n-    assert(locals < caller->fp() + frame::interpreter_frame_initial_sp_offset, \"bad placement\");\n+    assert(locals <= caller->interpreter_frame_expression_stack(), \"bad placement\");\n+    assert(locals >= interpreter_frame->sender_sp() + max_locals - 1, \"bad placement\");\n","filename":"src\/hotspot\/cpu\/aarch64\/abstractInterpreter_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,0 +134,9 @@\n+#ifdef ASSERT\n+  if (caller->is_interpreted_frame()) {\n+    assert(locals <= caller->interpreter_frame_expression_stack(), \"bad placement\");\n+    \/\/ Test exact placement on top of caller args\n+    intptr_t* l2 = caller->interpreter_frame_last_sp() + caller_actual_parameters - 1;\n+    assert(l2 >= locals, \"bad placement\");\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/arm\/abstractInterpreter_arm.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -131,0 +131,9 @@\n+#ifdef ASSERT\n+  if (caller->is_interpreted_frame()) {\n+    assert(locals_base <= caller->interpreter_frame_expression_stack(), \"bad placement\");\n+    \/\/ Test caller-aligned placement vs callee-aligned\n+    intptr_t* l2 = caller->sp() + method->max_locals() - 1 + (frame::java_abi_size \/ Interpreter::stackElementSize);\n+    assert(l2 >= locals_base, \"bad placement\");\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/ppc\/abstractInterpreter_ppc.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -144,1 +144,2 @@\n-    assert(locals < caller->fp() + frame::interpreter_frame_initial_sp_offset, \"bad placement\");\n+    assert(locals <= caller->interpreter_frame_expression_stack(), \"bad placement\");\n+    assert(locals >= interpreter_frame->sender_sp() + max_locals - 1, \"bad placement\");\n","filename":"src\/hotspot\/cpu\/riscv\/abstractInterpreter_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -185,0 +185,7 @@\n+#ifdef ASSERT\n+    assert(locals_base <= caller->interpreter_frame_expression_stack(), \"bad placement\");\n+    \/\/ Test caller-aligned placement vs callee-aligned\n+    intptr_t* l2 = (caller->sp() + method->max_locals() - 1 +\n+      frame::z_parent_ijava_frame_abi_size \/ Interpreter::stackElementSize);\n+    assert(l2 >= locals_base, \"bad placement\");\n+#endif\n","filename":"src\/hotspot\/cpu\/s390\/abstractInterpreter_s390.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -90,1 +90,4 @@\n-    assert(locals < caller->fp() + frame::interpreter_frame_initial_sp_offset, \"bad placement\");\n+    assert(locals <= caller->interpreter_frame_expression_stack(), \"bad placement\");\n+    \/\/ Test exact placement on top of caller args\n+    intptr_t* l2 = caller->interpreter_frame_last_sp() + caller_actual_parameters - 1;\n+    assert(l2 >= locals, \"bad placement\");\n","filename":"src\/hotspot\/cpu\/x86\/abstractInterpreter_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -644,5 +644,6 @@\n-    Bytecode_invoke cur = Bytecode_invoke_check(method, deopt_sender.interpreter_frame_bci());\n-    if (cur.is_invokedynamic() || cur.is_invokehandle()) {\n-      \/\/ Method handle invokes may involve fairly arbitrary chains of\n-      \/\/ calls so it's impossible to know how much actual space the\n-      \/\/ caller has for locals.\n+    Bytecode_invoke cur(method, deopt_sender.interpreter_frame_bci());\n+    if (!cur.is_invokedynamic() && MethodHandles::has_member_arg(cur.klass(), cur.name())) {\n+      \/\/ This should cover all real-world cases.  One exception is a pathological chain of\n+      \/\/ MH.linkToXXX() linker calls, which only trusted code could do anyway.  To handle that case, we\n+      \/\/ would need to get the size from the resolved method entry.  Another exception would\n+      \/\/ be an invokedynamic with an adapter that is really a MethodHandle linker.\n@@ -751,0 +752,5 @@\n+  int caller_actual_parameters = -1; \/\/ value not used except for interpreted frames, see below\n+  if (deopt_sender.is_interpreted_frame()) {\n+    caller_actual_parameters = callee_parameters + (caller_was_method_handle ? 1 : 0);\n+  }\n+\n@@ -753,1 +759,1 @@\n-                                      caller_was_method_handle ? 0 : callee_parameters,\n+                                      caller_actual_parameters,\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.jsr292;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+\/*\n+ * @test\n+ * @bug 8336042\n+ * @library \/test\/lib \/\n+ *\n+ * @run main\/bootclasspath\/othervm -Xbatch -XX:-TieredCompilation compiler.jsr292.MHDeoptTest\n+ *\n+ *\/\n+public class MHDeoptTest {\n+\n+    static int xx = 0;\n+\n+    public static void main(String[] args) throws Throwable {\n+        MethodHandle mh1 = MethodHandles.lookup().findStatic(MHDeoptTest.class, \"body1\", MethodType.methodType(int.class));\n+        MethodHandle mh2 = MethodHandles.lookup().findStatic(MHDeoptTest.class, \"body2\", MethodType.methodType(int.class));\n+        MethodHandle[] arr = new MethodHandle[] {mh2, mh1};\n+\n+        for (MethodHandle mh : arr) {\n+            for (int i = 1; i < 50_000; i++) {\n+                xx = i;\n+                mainLink(mh);\n+            }\n+        }\n+\n+    }\n+\n+    static int mainLink(MethodHandle mh) throws Throwable {\n+        return (int)mh.invokeExact();\n+    }\n+\n+    static int cnt = 1000;\n+\n+    static int body1() {\n+        int limit = 0x7fff;\n+        \/\/ uncommon trap\n+        if (xx == limit) {\n+            \/\/ OSR\n+            for (int i = 0; i < 50_000; i++) {\n+            }\n+            ++cnt;\n+            ++xx;\n+        }\n+        if (xx == limit + 1) {\n+            return cnt + 1;\n+        }\n+        return cnt;\n+    }\n+\n+    static int body2() {\n+        int limit = 0x7fff;\n+        int dummy = 0;\n+        \/\/ uncommon trap\n+        if (xx == limit) {\n+            \/\/ OSR\n+            for (int i = 0; i < 50_000; i++) {\n+            }\n+            ++cnt;\n+            ++xx;\n+        }\n+        if (xx == limit + 1) {\n+            return cnt + 1;\n+        }\n+        return cnt;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/MHDeoptTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}