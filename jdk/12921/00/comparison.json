{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -158,2 +159,1 @@\n-STATIC_ASSERT(sizeof(MallocHeader) == (sizeof(uint64_t) * 2));\n-\n+STATIC_ASSERT(is_aligned(sizeof(MallocHeader), minimum_malloc_alignment));\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1305,0 +1305,10 @@\n+\/\/ The minimum natural alignment malloc should guarantee\n+\/\/ Note that in practice libc's will typically use higher alignments\n+\/\/ (typically 8 for 32-bit, 16 for 64-bit) but that's not guaranteed.\n+union AllTheBigTypes {\n+  void* p;\n+  uint64_t i64;\n+  long double d;\n+};\n+constexpr int minimum_malloc_alignment = alignof(AllTheBigTypes);\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -198,0 +198,6 @@\n+\n+TEST(Align, test_minimum_malloc_alignment) {\n+  \/\/ Test for reasonable values (ranges can go from 4 to 16 on our platforms)\n+  ASSERT_GT(minimum_malloc_alignment, 0);\n+  ASSERT_LE(minimum_malloc_alignment, 16);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_align.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}