{"files":[{"patch":"@@ -669,1 +669,1 @@\n-   tools\/sincechecker\/testjavabase\/CheckSince_javaBase.java\n\\ No newline at end of file\n+   tools\/sincechecker\/testjavabase\/CheckSince_javaBase.java\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.File;\n@@ -51,3 +52,4 @@\n-- This checker checks the values of the `@since` tag found in the documentation comment for an element against the release in which the element first appeared.\n-- The source code containing the documentation comments is read from `src.zip` in the release of JDK used to run the test.\n-- The releases used to determine the expected value of `@since` tags are taken from the historical data built into `javac`.\n+This checker checks the values of the `@since` tag found in the documentation comment for an element against\n+the release in which the element first appeared.\n+The source code containing the documentation comments is read from `src.zip` in the release of JDK used to run the test.\n+The releases used to determine the expected value of `@since` tags are taken from the historical data built into `javac`.\n@@ -56,2 +58,4 @@\n-- In the first step, we process JDKs 9-current, only classfiles, producing a map `<unique-Element-ID`> => `<version(s)-where-it-was-introduced>`.\n-    - \"version(s)\", because we handle versioning of Preview API, so there may be two versions (we use a class with two fields for preview and stable),\n+In the first step, we process JDKs 9-current, only classfiles,\n+  producing a map `<unique-Element-ID`> => `<version(s)-where-it-was-introduced>`.\n+    - \"version(s)\", because we handle versioning of Preview API, so there may be two versions\n+     (we use a class with two fields for preview and stable),\n@@ -59,1 +63,2 @@\n-    - For each Element, we compute the unique ID, look into the map, and if there's nothing, record the current version as the originating version.\n+    - For each Element, we compute the unique ID, look into the map, and if there's nothing,\n+     record the current version as the originating version.\n@@ -62,3 +67,6 @@\n-- In the second step, we look at \"effective\" `@since` tags in the mainline sources, from `src.zip` (if the test run doesn't have it, we throw a `jtreg.SkippedException`)\n-    - We only check the specific MODULE whose name was passed as an argument in the test. In that module, we look for unqualified exports and test those packages.\n-    -The `@since` checker verifies that for every API element, the real since value and the effective since value are the same, and reports an error if they are not.\n+In the second step, we look at \"effective\" `@since` tags in the mainline sources, from `src.zip`\n+ (if the test run doesn't have it, we throw a `jtreg.SkippedException`)\n+    - We only check the specific MODULE whose name was passed as an argument in the test.\n+      In that module, we look for unqualified exports and test those packages.\n+    - The `@since` checker verifies that for every API element, the real since value and\n+      the effective since value are the same, and reports an error if they are not.\n@@ -66,2 +74,2 @@\n-Important note : We only check code written since JDK 9 as the releases used to determine the expected value of @since tags\n-                 are taken from the historical data built into javac which only goes back that far\n+Important note : We only check code written since JDK 9 as the releases used to determine the expected value\n+                 of @since tags are taken from the historical data built into javac which only goes back that far\n@@ -71,1 +79,2 @@\n-Real since value of an API element is computed as the oldest release in which the given API element was introduced. That is:\n+Real since value of an API element is computed as the oldest release in which the given API element was introduced.\n+That is:\n@@ -74,1 +83,2 @@\n-- for methods and fields, the release in which the given method or field with the given VM descriptor became a member of its enclosing class or interface, whether direct or inherited\n+- for methods and fields, the release in which the given method or field with the given VM descriptor became a member\n+  of its enclosing class or interface, whether direct or inherited\n@@ -85,2 +95,4 @@\n-note on legacy preview: Until JDK 14, the preview APIs were not marked in any machine-understandable way. It was deprecated, and had a comment in the javadoc.\n-                        and the use of `@PreviewFeature` only became standard in JDK 17. So the checker has an explicit knowledge of these preview elements.\n+note on legacy preview: Until JDK 14, the preview APIs were not marked in any machine-understandable way.\n+                        It was deprecated, and had a comment in the javadoc.\n+                        and the use of `@PreviewFeature` only became standard in JDK 17.\n+                        So the checker has an explicit knowledge of these preview elements.\n@@ -88,2 +100,4 @@\n-note: The `<unique-Element-ID>` for methods looks like `method: <erased-return-descriptor> <binary-name-of-enclosing-class>.<method-name>(<ParameterDescriptor>)`.\n-it is somewhat inspired from the VM Method Descriptors. But we use the erased return so that methods that were later generified remain the same.\n+note: The `<unique-Element-ID>` for methods looks like\n+      `method: <erased-return-descriptor> <binary-name-of-enclosing-class>.<method-name>(<ParameterDescriptor>)`.\n+it is somewhat inspired from the VM Method Descriptors. But we use the erased return so that methods\n+that were later generified remain the same.\n@@ -106,1 +120,1 @@\n-            throw new SkippedException(\"Test module not specified\");\n+            throw new IllegalArgumentException(\"Test module not specified\");\n@@ -131,1 +145,1 @@\n-            persistElement(moduleElement, moduleElement, ct.getTypes(), releaseVersion);\n+            processElement(moduleElement, moduleElement, ct.getTypes(), releaseVersion);\n@@ -139,1 +153,1 @@\n-        persistElement(pe, pe, ct.getTypes(), releaseVersion);\n+        processElement(pe, pe, ct.getTypes(), releaseVersion);\n@@ -164,1 +178,1 @@\n-        persistElement(te.getEnclosingElement(), te, types, version);\n+        processElement(te.getEnclosingElement(), te, types, version);\n@@ -168,1 +182,1 @@\n-                .forEach(element -> persistElement(te, element, types, version));\n+                .forEach(element -> processElement(te, element, types, version));\n@@ -175,1 +189,1 @@\n-    public void persistElement(Element explicitOwner, Element element, Types types, String version) {\n+    public void processElement(Element explicitOwner, Element element, Types types, String version) {\n@@ -223,1 +237,1 @@\n-                Path packagePath = root.resolve(moduleName);\n+                Path moduleDirectory = root.resolve(moduleName);\n@@ -236,1 +250,1 @@\n-                        processModuleCheck(elements.getModuleElement(moduleName), ct, packagePath, javadocHelper);\n+                        processModuleCheck(elements.getModuleElement(moduleName), ct, moduleDirectory, javadocHelper);\n@@ -239,1 +253,1 @@\n-                        error(\"Initiating javadocHelperFailed \" + e.getMessage());\n+                        error(\"Initiating javadocHelperFailed \" + e);\n@@ -249,1 +263,1 @@\n-    private void processModuleCheck(ModuleElement moduleElement, JavacTask ct, Path packagePath, EffectiveSourceSinceHelper javadocHelper) {\n+    private void processModuleCheck(ModuleElement moduleElement, JavacTask ct, Path moduleDirectory, EffectiveSourceSinceHelper javadocHelper) {\n@@ -254,1 +268,1 @@\n-        String moduleVersion = getModuleVersionFromFile(packagePath);\n+        String moduleVersion = getModuleVersionFromFile(moduleDirectory);\n@@ -258,1 +272,1 @@\n-                String packageVersion = getPackageVersionFromFile(packagePath, ed);\n+                String packageVersion = getPackageVersionFromFile(moduleDirectory, ed);\n@@ -280,2 +294,2 @@\n-    private String getModuleVersionFromFile(Path packagePath) {\n-        Path moduleInfoFile = packagePath.resolve(\"module-info.java\");\n+    private String getModuleVersionFromFile(Path moduleDirectory) {\n+        Path moduleInfoFile = moduleDirectory.resolve(\"module-info.java\");\n@@ -296,2 +310,2 @@\n-    private String getPackageVersionFromFile(Path packagePath, ModuleElement.ExportsDirective ed) {\n-        Path pkgInfo = packagePath.resolve(ed.getPackage()\n+    private String getPackageVersionFromFile(Path moduleDirectory, ModuleElement.ExportsDirective ed) {\n+        Path pkgInfo = moduleDirectory.resolve(ed.getPackage()\n@@ -300,1 +314,1 @@\n-                        .replaceAll(\"\\\\.\", \"\/\")\n+                        .replace(\".\", File.separator)\n@@ -828,1 +842,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/tools\/sincechecker\/SinceChecker.java","additions":49,"deletions":35,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- *\/\n\\ No newline at end of file\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/testjavabase\/CheckSince_javaBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}