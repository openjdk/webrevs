{"files":[{"patch":"@@ -94,1 +94,2 @@\n-    :jdk_jpackage\n+    :jdk_jpackage \\\n+    :jdk_since_check\n@@ -664,1 +665,5 @@\n-   -:jdk_security\n\\ No newline at end of file\n+   -:jdk_security\n+\n+# Set of tests for `@since` checks in source code documentation\n+jdk_since_check = \\\n+   tools\/sincechecker\/testjavabase\/CheckSince_javaBase.java\n","filename":"test\/jdk\/TEST.groups","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,842 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.Runtime.Version;\n+import java.net.URI;\n+import java.nio.file.*;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n+import javax.tools.*;\n+import javax.tools.JavaFileManager.Location;\n+import com.sun.source.tree.*;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.util.Pair;\n+import jtreg.SkippedException;\n+\n+\n+\/*\n+This checker checks the values of the `@since` tag found in the documentation comment for an element against\n+the release in which the element first appeared.\n+The source code containing the documentation comments is read from `src.zip` in the release of JDK used to run the test.\n+The releases used to determine the expected value of `@since` tags are taken from the historical data built into `javac`.\n+\n+The `@since` checker works as a two-step process:\n+In the first step, we process JDKs 9-current, only classfiles,\n+  producing a map `<unique-Element-ID`> => `<version(s)-where-it-was-introduced>`.\n+    - \"version(s)\", because we handle versioning of Preview API, so there may be two versions\n+     (we use a class with two fields for preview and stable),\n+    one when it was introduced as a preview, and one when it went out of preview. More on that below.\n+    - For each Element, we compute the unique ID, look into the map, and if there's nothing,\n+     record the current version as the originating version.\n+    - At the end of this step we have a map of the Real since values\n+\n+In the second step, we look at \"effective\" `@since` tags in the mainline sources, from `src.zip`\n+ (if the test run doesn't have it, we throw a `jtreg.SkippedException`)\n+    - We only check the specific MODULE whose name was passed as an argument in the test.\n+      In that module, we look for unqualified exports and test those packages.\n+    - The `@since` checker verifies that for every API element, the real since value and\n+      the effective since value are the same, and reports an error if they are not.\n+\n+Important note : We only check code written since JDK 9 as the releases used to determine the expected value\n+                 of @since tags are taken from the historical data built into javac which only goes back that far\n+\n+note on rules for Real and effective `@since:\n+\n+Real since value of an API element is computed as the oldest release in which the given API element was introduced.\n+That is:\n+- for modules, classes and interfaces, the release in which the element with the given qualified name was introduced\n+- for constructors, the release in which the constructor with the given VM descriptor was introduced\n+- for methods and fields, the release in which the given method or field with the given VM descriptor became a member\n+  of its enclosing class or interface, whether direct or inherited\n+\n+Effective since value of an API element is computed as follows:\n+- if the given element has a @since tag in its javadoc, it is used\n+- in all other cases, return the effective since value of the enclosing element\n+\n+\n+Special Handling for preview method, as per JEP 12:\n+- When an element is still marked as preview, the `@since` should be the first JDK release where the element was added.\n+- If the element is no longer marked as preview, the `@since` should be the first JDK release where it was no longer preview.\n+\n+note on legacy preview: Until JDK 14, the preview APIs were not marked in any machine-understandable way.\n+                        It was deprecated, and had a comment in the javadoc.\n+                        and the use of `@PreviewFeature` only became standard in JDK 17.\n+                        So the checker has an explicit knowledge of these preview elements.\n+\n+note: The `<unique-Element-ID>` for methods looks like\n+      `method: <erased-return-descriptor> <binary-name-of-enclosing-class>.<method-name>(<ParameterDescriptor>)`.\n+it is somewhat inspired from the VM Method Descriptors. But we use the erased return so that methods\n+that were later generified remain the same.\n+*\/\n+\n+\n+public class SinceChecker {\n+    private final Map<String, Set<String>> LEGACY_PREVIEW_METHODS = new HashMap<>();\n+    private final Map<String, IntroducedIn> classDictionary = new HashMap<>();\n+    private final JavaCompiler tool;\n+    private int errorCount = 0;\n+\n+    public static class IntroducedIn {\n+        public String introducedPreview;\n+        public String introducedStable;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            throw new IllegalArgumentException(\"Test module not specified\");\n+        }\n+        SinceChecker sinceCheckerTestHelper = new SinceChecker();\n+        sinceCheckerTestHelper.checkModule(args[0]);\n+    }\n+\n+    private SinceChecker() throws IOException {\n+        tool = ToolProvider.getSystemJavaCompiler();\n+        for (int i = 9; i <= Runtime.version().feature(); i++) {\n+            JavacTask ct = (JavacTask) tool.getTask(null, null, null,\n+                    List.of(\"--release\", String.valueOf(i)),\n+                    null,\n+                    Collections.singletonList(SimpleJavaFileObject.forSource(URI.create(\"myfo:\/Test.java\"), \"\")));\n+            ct.analyze();\n+\n+            String version = String.valueOf(i);\n+            Elements elements = ct.getElements();\n+            elements.getModuleElement(\"java.base\"); \/\/ forces module graph to be instantiated\n+            elements.getAllModuleElements().forEach(me ->\n+                    processModuleElement(me, version, ct));\n+        }\n+    }\n+\n+    private void processModuleElement(ModuleElement moduleElement, String releaseVersion, JavacTask ct) {\n+        for (ModuleElement.ExportsDirective ed : ElementFilter.exportsIn(moduleElement.getDirectives())) {\n+            processElement(moduleElement, moduleElement, ct.getTypes(), releaseVersion);\n+            if (ed.getTargetModules() == null) {\n+                processPackageElement(ed.getPackage(), releaseVersion, ct);\n+            }\n+        }\n+    }\n+\n+    private void processPackageElement(PackageElement pe, String releaseVersion, JavacTask ct) {\n+        processElement(pe, pe, ct.getTypes(), releaseVersion);\n+        List<TypeElement> typeElements = ElementFilter.typesIn(pe.getEnclosedElements());\n+        for (TypeElement te : typeElements) {\n+            processClassElement(te, releaseVersion, ct.getTypes(), ct.getElements());\n+        }\n+    }\n+\n+    \/\/\/ JDK documentation only contains public and protected declarations\n+    private boolean isDocumented(Element te) {\n+        Set<Modifier> mod = te.getModifiers();\n+        return mod.contains(Modifier.PUBLIC) || mod.contains(Modifier.PROTECTED);\n+    }\n+\n+    private boolean isMember(Element e) {\n+        var kind = e.getKind();\n+        return kind.isField() || switch (kind) {\n+            case METHOD, CONSTRUCTOR -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private void processClassElement(TypeElement te, String version, Types types, Elements elements) {\n+        if (!isDocumented(te)) {\n+            return;\n+        }\n+        processElement(te.getEnclosingElement(), te, types, version);\n+        elements.getAllMembers(te).stream()\n+                .filter(this::isDocumented)\n+                .filter(this::isMember)\n+                .forEach(element -> processElement(te, element, types, version));\n+        te.getEnclosedElements().stream()\n+                .filter(element -> element.getKind().isDeclaredType())\n+                .map(TypeElement.class::cast)\n+                .forEach(nestedClass -> processClassElement(nestedClass, version, types, elements));\n+    }\n+\n+    public void processElement(Element explicitOwner, Element element, Types types, String version) {\n+        String uniqueId = getElementName(explicitOwner, element, types);\n+        IntroducedIn introduced = classDictionary.computeIfAbsent(uniqueId, i -> new IntroducedIn());\n+        if (isPreview(element, uniqueId, version)) {\n+            if (introduced.introducedPreview == null) {\n+                introduced.introducedPreview = version;\n+            }\n+        } else {\n+            if (introduced.introducedStable == null) {\n+                introduced.introducedStable = version;\n+            }\n+        }\n+    }\n+\n+    private boolean isPreview(Element el, String uniqueId, String currentVersion) {\n+        while (el != null) {\n+            Symbol s = (Symbol) el;\n+            if ((s.flags() & Flags.PREVIEW_API) != 0) {\n+                return true;\n+            }\n+            el = el.getEnclosingElement();\n+        }\n+\n+        return LEGACY_PREVIEW_METHODS.containsKey(currentVersion)\n+                && LEGACY_PREVIEW_METHODS.get(currentVersion).contains(uniqueId);\n+    }\n+\n+    void error(String message) {\n+        System.err.println(message);\n+        errorCount++;\n+    }\n+\n+    private void checkModule(String moduleName) throws Exception {\n+        Path home = Paths.get(System.getProperty(\"java.home\"));\n+        Path srcZip = home.resolve(\"lib\").resolve(\"src.zip\");\n+        if (Files.notExists(srcZip)) {\n+            \/\/possibly running over an exploded JDK build, attempt to find a\n+            \/\/co-located full JDK image with src.zip:\n+            Path testJdk = Paths.get(System.getProperty(\"test.jdk\"));\n+            srcZip = testJdk.getParent().resolve(\"images\").resolve(\"jdk\").resolve(\"lib\").resolve(\"src.zip\");\n+        }\n+        if (!Files.exists(srcZip) && !Files.isDirectory(srcZip)) {\n+            throw new SkippedException(\"Skipping Test because src.zip wasn't found\");\n+        }\n+        if (Files.isReadable(srcZip)) {\n+            URI uri = URI.create(\"jar:\" + srcZip.toUri());\n+            try (FileSystem zipFO = FileSystems.newFileSystem(uri, Collections.emptyMap())) {\n+                Path root = zipFO.getRootDirectories().iterator().next();\n+                Path moduleDirectory = root.resolve(moduleName);\n+                try (StandardJavaFileManager fm =\n+                             tool.getStandardFileManager(null, null, null)) {\n+                    JavacTask ct = (JavacTask) tool.getTask(null,\n+                            fm,\n+                            null,\n+                            List.of(\"--add-modules\", moduleName, \"-d\", \".\"),\n+                            null,\n+                            Collections.singletonList(SimpleJavaFileObject.forSource(URI.create(\"myfo:\/Test.java\"), \"\")));\n+                    ct.analyze();\n+                    Elements elements = ct.getElements();\n+                    elements.getModuleElement(\"java.base\");\n+                    try (EffectiveSourceSinceHelper javadocHelper = EffectiveSourceSinceHelper.create(ct, List.of(root), this)) {\n+                        processModuleCheck(elements.getModuleElement(moduleName), ct, moduleDirectory, javadocHelper);\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                        error(\"Initiating javadocHelperFailed \" + e);\n+                    }\n+                    if (errorCount > 0) {\n+                        throw new Exception(\"The `@since` checker found \" + errorCount + \" problems\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void processModuleCheck(ModuleElement moduleElement, JavacTask ct, Path moduleDirectory, EffectiveSourceSinceHelper javadocHelper) {\n+        if (moduleElement == null) {\n+            error(\"Module element: was null because `elements.getModuleElement(moduleName)` returns null.\" +\n+                    \"fixes are needed for this Module\");\n+        }\n+        String moduleVersion = getModuleVersionFromFile(moduleDirectory);\n+        checkModuleOrPackage(moduleVersion, moduleElement, ct, \"Module: \");\n+        for (ModuleElement.ExportsDirective ed : ElementFilter.exportsIn(moduleElement.getDirectives())) {\n+            if (ed.getTargetModules() == null) {\n+                String packageVersion = getPackageVersionFromFile(moduleDirectory, ed);\n+                checkModuleOrPackage(packageVersion, ed.getPackage(), ct, \"Package: \");\n+                analyzePackageCheck(ed.getPackage(), ct, javadocHelper);\n+            }\n+        }\n+    }\n+\n+    private void checkModuleOrPackage(String moduleVersion, Element moduleElement, JavacTask ct, String elementCategory) {\n+        String id = getElementName(moduleElement, moduleElement, ct.getTypes());\n+        var elementInfo = classDictionary.get(id);\n+        if (elementInfo == null) {\n+            error(\"Element :\" + id + \" was not mapped\");\n+            return;\n+        }\n+        String version = elementInfo.introducedStable;\n+        if (moduleVersion == null) {\n+            error(\"Unable to retrieve `@since` for \" + elementCategory + id);\n+        } else {\n+            checkEquals(moduleVersion, version, id);\n+        }\n+    }\n+\n+    private String getModuleVersionFromFile(Path moduleDirectory) {\n+        Path moduleInfoFile = moduleDirectory.resolve(\"module-info.java\");\n+        String version = null;\n+        if (Files.exists(moduleInfoFile)) {\n+            try {\n+                String moduleInfoContent = Files.readString(moduleInfoFile);\n+                version = extractSinceVersionFromText(moduleInfoContent).toString();\n+            } catch (IOException e) {\n+                error(\"module-info.java not found or couldn't be opened AND this module has no unqualified exports\");\n+            } catch (NullPointerException e) {\n+                error(\"module-info.java does not contain an `@since`\");\n+            }\n+        }\n+        return version;\n+    }\n+\n+    private String getPackageVersionFromFile(Path moduleDirectory, ModuleElement.ExportsDirective ed) {\n+        Path pkgInfo = moduleDirectory.resolve(ed.getPackage()\n+                        .getQualifiedName()\n+                        .toString()\n+                        .replace(\".\", File.separator)\n+                )\n+                .resolve(\"package-info.java\");\n+\n+        String packageTopVersion = null;\n+        if (Files.exists(pkgInfo)) {\n+            try {\n+                String packageContent = Files.readString(pkgInfo);\n+                packageTopVersion = extractSinceVersionFromText(packageContent).toString();\n+            } catch (IOException e) {\n+                error(ed.getPackage().getQualifiedName() + \": package-info.java not found or couldn't be opened\");\n+            } catch (NullPointerException e) {\n+                error(ed.getPackage().getQualifiedName() + \": package-info.java  does not contain an `@since`\");\n+            }\n+        }\n+        return packageTopVersion;\n+    }\n+\n+\n+    private void analyzePackageCheck(PackageElement pe, JavacTask ct, EffectiveSourceSinceHelper javadocHelper) {\n+        List<TypeElement> typeElements = ElementFilter.typesIn(pe.getEnclosedElements());\n+        for (TypeElement te : typeElements) {\n+            analyzeClassCheck(te, null, javadocHelper, ct.getTypes(), ct.getElements());\n+        }\n+    }\n+\n+    private void analyzeClassCheck(TypeElement te, String version, EffectiveSourceSinceHelper javadocHelper,\n+                                   Types types, Elements elementUtils) {\n+        String currentjdkVersion = String.valueOf(Runtime.version().feature());\n+        if (!isDocumented(te)) {\n+            return;\n+        }\n+        checkElement(te.getEnclosingElement(), te, types, javadocHelper, version, elementUtils);\n+        te.getEnclosedElements().stream().filter(this::isDocumented)\n+                .filter(this::isMember)\n+                .forEach(element -> checkElement(te, element, types, javadocHelper, version, elementUtils));\n+        te.getEnclosedElements().stream()\n+                .filter(element -> element.getKind().isDeclaredType())\n+                .map(TypeElement.class::cast)\n+                .forEach(nestedClass -> analyzeClassCheck(nestedClass, currentjdkVersion, javadocHelper, types, elementUtils));\n+    }\n+\n+\n+    private void checkElement(Element explicitOwner, Element element, Types types,\n+                              EffectiveSourceSinceHelper javadocHelper, String currentVersion, Elements elementUtils) {\n+        String uniqueId = getElementName(explicitOwner, element, types);\n+\n+        if (element.getKind() == ElementKind.METHOD &&\n+                element.getEnclosingElement().getKind() == ElementKind.ENUM &&\n+                (uniqueId.contains(\".values()\") || uniqueId.contains(\".valueOf(java.lang.String)\"))) {\n+            \/\/mandated enum type methods\n+            return;\n+        }\n+        String sinceVersion = javadocHelper.effectiveSinceVersion(explicitOwner, element, types, elementUtils).toString();\n+        IntroducedIn mappedVersion = classDictionary.get(uniqueId);\n+        if (mappedVersion == null) {\n+            error(\"Element :\" + uniqueId + \" was not mapped\");\n+            return;\n+        }\n+        String realMappedVersion = null;\n+        try {\n+            realMappedVersion = isPreview(element, uniqueId, currentVersion) ?\n+                    mappedVersion.introducedPreview :\n+                    mappedVersion.introducedStable;\n+        } catch (Exception e) {\n+            error(\"For element \" + element + \"mappedVersion\" + mappedVersion + \" is null \" + e);\n+        }\n+        checkEquals(sinceVersion, realMappedVersion, uniqueId);\n+    }\n+\n+    private Version extractSinceVersionFromText(String documentation) {\n+        Pattern pattern = Pattern.compile(\"@since\\\\s+(\\\\d+(?:\\\\.\\\\d+)?)\");\n+        Matcher matcher = pattern.matcher(documentation);\n+        if (matcher.find()) {\n+            String versionString = matcher.group(1);\n+            try {\n+                if (versionString.equals(\"1.0\")) {\n+                    versionString = \"1\"; \/\/ended up being necessary\n+                } else if (versionString.startsWith(\"1.\")) {\n+                    versionString = versionString.substring(2);\n+                }\n+                return Version.parse(versionString);\n+            } catch (NumberFormatException ex) {\n+                error(\"`@since` value that cannot be parsed: \" + versionString);\n+                return null;\n+            }\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private void checkEquals(String sinceVersion, String mappedVersion, String name) {\n+        if (sinceVersion == null || mappedVersion == null) {\n+            error(name + \": NULL value for either real or effective `@since` . real\/mapped version is=\"\n+                    + mappedVersion + \" while the `@since` in the source code is= \" + sinceVersion);\n+            return;\n+        }\n+        if (Integer.parseInt(sinceVersion) < 9) {\n+            sinceVersion = \"9\";\n+        }\n+        if (!sinceVersion.equals(mappedVersion)) {\n+            String message = getWrongSinceMessage(sinceVersion, mappedVersion, name);\n+            error(message);\n+        }\n+    }\n+\n+    private static String getWrongSinceMessage(String sinceVersion, String mappedVersion, String elementSimpleName) {\n+        String message;\n+        if (mappedVersion.equals(\"9\")) {\n+            message = elementSimpleName + \": `@since` version is \" + sinceVersion + \" but the element exists before JDK 10\";\n+        } else {\n+            message = elementSimpleName + \": `@since` version is \" + sinceVersion + \" instead of \" + mappedVersion;\n+        }\n+        return message;\n+    }\n+\n+    private static String getElementName(Element owner, Element element, Types types) {\n+        String prefix = \"\";\n+        String suffix = \"\";\n+        ElementKind kind = element.getKind();\n+        if (kind.isField()) {\n+            TypeElement te = (TypeElement) owner;\n+            prefix = \"field\";\n+            suffix = \": \" + te.getQualifiedName() + \":\" + element.getSimpleName();\n+        } else if (kind == ElementKind.METHOD || kind == ElementKind.CONSTRUCTOR) {\n+            prefix = \"method\";\n+            TypeElement te = (TypeElement) owner;\n+            ExecutableElement executableElement = (ExecutableElement) element;\n+            String returnType = types.erasure(executableElement.getReturnType()).toString();\n+            String methodName = executableElement.getSimpleName().toString();\n+            String descriptor = executableElement.getParameters().stream()\n+                    .map(p -> types.erasure(p.asType()).toString())\n+                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n+            suffix = \": \" + returnType + \" \" + te.getQualifiedName() + \".\" + methodName + descriptor;\n+        } else if (kind.isDeclaredType()) {\n+            if (kind.isClass()) {\n+                prefix = \"class\";\n+            } else if (kind.isInterface()) {\n+                prefix = \"interface\";\n+            }\n+            suffix = \": \" + ((TypeElement) element).getQualifiedName();\n+        } else if (kind == ElementKind.PACKAGE) {\n+            prefix = \"package\";\n+            suffix = \": \" + ((PackageElement) element).getQualifiedName();\n+        } else if (kind == ElementKind.MODULE) {\n+            prefix = \"module\";\n+            suffix = \": \" + ((ModuleElement) element).getQualifiedName();\n+        }\n+        return prefix + suffix;\n+    }\n+\n+    \/\/these were preview in before the introduction of the @PreviewFeature\n+    {\n+        LEGACY_PREVIEW_METHODS.put(\"12\", Set.of(\n+                \"method: com.sun.source.tree.ExpressionTree com.sun.source.tree.BreakTree.getValue()\",\n+                \"method: java.util.List com.sun.source.tree.CaseTree.getExpressions()\",\n+                \"method: com.sun.source.tree.Tree com.sun.source.tree.CaseTree.getBody()\",\n+                \"method: com.sun.source.tree.CaseTree.CaseKind com.sun.source.tree.CaseTree.getCaseKind()\",\n+                \"class: com.sun.source.tree.CaseTree.CaseKind\",\n+                \"field: com.sun.source.tree.Tree.Kind:SWITCH_EXPRESSION\",\n+                \"interface: com.sun.source.tree.SwitchExpressionTree\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.TreeScanner.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.SimpleTreeVisitor.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\"\n+        ));\n+\n+        LEGACY_PREVIEW_METHODS.put(\"13\", Set.of(\n+                \"method: java.util.List com.sun.source.tree.CaseTree.getExpressions()\",\n+                \"method: com.sun.source.tree.Tree com.sun.source.tree.CaseTree.getBody()\",\n+                \"method: com.sun.source.tree.CaseTree.CaseKind com.sun.source.tree.CaseTree.getCaseKind()\",\n+                \"class: com.sun.source.tree.CaseTree.CaseKind\",\n+                \"field: com.sun.source.tree.Tree.Kind:SWITCH_EXPRESSION\",\n+                \"interface: com.sun.source.tree.SwitchExpressionTree\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.TreeScanner.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.SimpleTreeVisitor.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\",\n+                \"method: java.lang.String java.lang.String.stripIndent()\",\n+                \"method: java.lang.String java.lang.String.translateEscapes()\",\n+                \"method: java.lang.String java.lang.String.formatted(java.lang.Object[])\",\n+                \"class: javax.swing.plaf.basic.motif.MotifLookAndFeel\",\n+                \"field: com.sun.source.tree.Tree.Kind:YIELD\",\n+                \"interface: com.sun.source.tree.YieldTree\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitYield(com.sun.source.tree.YieldTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.SimpleTreeVisitor.visitYield(com.sun.source.tree.YieldTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.TreeScanner.visitYield(com.sun.source.tree.YieldTree,java.lang.Object)\"\n+        ));\n+\n+        LEGACY_PREVIEW_METHODS.put(\"14\", Set.of(\n+                \"class: javax.swing.plaf.basic.motif.MotifLookAndFeel\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitYield(com.sun.source.tree.YieldTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.SimpleTreeVisitor.visitYield(com.sun.source.tree.YieldTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.TreeScanner.visitYield(com.sun.source.tree.YieldTree,java.lang.Object)\",\n+                \"field: jdk.jshell.Snippet.SubKind:RECORD_SUBKIND\",\n+                \"class: javax.lang.model.element.RecordComponentElement\",\n+                \"method: javax.lang.model.type.TypeMirror javax.lang.model.element.RecordComponentElement.asType()\",\n+                \"method: java.lang.Object javax.lang.model.element.ElementVisitor.visitRecordComponent(javax.lang.model.element.RecordComponentElement,java.lang.Object)\",\n+                \"class: javax.lang.model.util.ElementScanner14\",\n+                \"class: javax.lang.model.util.AbstractElementVisitor14\",\n+                \"class: javax.lang.model.util.SimpleElementVisitor14\",\n+                \"method: java.lang.Object javax.lang.model.util.ElementKindVisitor6.visitTypeAsRecord(javax.lang.model.element.TypeElement,java.lang.Object)\",\n+                \"class: javax.lang.model.util.ElementKindVisitor14\",\n+                \"method: javax.lang.model.element.RecordComponentElement javax.lang.model.util.Elements.recordComponentFor(javax.lang.model.element.ExecutableElement)\",\n+                \"method: java.util.List javax.lang.model.util.ElementFilter.recordComponentsIn(java.lang.Iterable)\",\n+                \"method: java.util.Set javax.lang.model.util.ElementFilter.recordComponentsIn(java.util.Set)\",\n+                \"method: java.util.List javax.lang.model.element.TypeElement.getRecordComponents()\",\n+                \"field: javax.lang.model.element.ElementKind:RECORD\",\n+                \"field: javax.lang.model.element.ElementKind:RECORD_COMPONENT\",\n+                \"field: javax.lang.model.element.ElementKind:BINDING_VARIABLE\",\n+                \"field: com.sun.source.tree.Tree.Kind:RECORD\",\n+                \"field: sun.reflect.annotation.TypeAnnotation.TypeAnnotationTarget:RECORD_COMPONENT\",\n+                \"class: java.lang.reflect.RecordComponent\",\n+                \"class: java.lang.runtime.ObjectMethods\",\n+                \"field: java.lang.annotation.ElementType:RECORD_COMPONENT\",\n+                \"method: boolean java.lang.Class.isRecord()\",\n+                \"method: java.lang.reflect.RecordComponent[] java.lang.Class.getRecordComponents()\",\n+                \"class: java.lang.Record\",\n+                \"interface: com.sun.source.tree.PatternTree\",\n+                \"field: com.sun.source.tree.Tree.Kind:BINDING_PATTERN\",\n+                \"method: com.sun.source.tree.PatternTree com.sun.source.tree.InstanceOfTree.getPattern()\",\n+                \"interface: com.sun.source.tree.BindingPatternTree\"\n+        ));\n+\n+        LEGACY_PREVIEW_METHODS.put(\"15\", Set.of(\n+                \"field: jdk.jshell.Snippet.SubKind:RECORD_SUBKIND\",\n+                \"class: javax.lang.model.element.RecordComponentElement\",\n+                \"method: javax.lang.model.type.TypeMirror javax.lang.model.element.RecordComponentElement.asType()\",\n+                \"method: java.lang.Object javax.lang.model.element.ElementVisitor.visitRecordComponent(javax.lang.model.element.RecordComponentElement,java.lang.Object)\",\n+                \"class: javax.lang.model.util.ElementScanner14\",\n+                \"class: javax.lang.model.util.AbstractElementVisitor14\",\n+                \"class: javax.lang.model.util.SimpleElementVisitor14\",\n+                \"method: java.lang.Object javax.lang.model.util.ElementKindVisitor6.visitTypeAsRecord(javax.lang.model.element.TypeElement,java.lang.Object)\",\n+                \"class: javax.lang.model.util.ElementKindVisitor14\",\n+                \"method: javax.lang.model.element.RecordComponentElement javax.lang.model.util.Elements.recordComponentFor(javax.lang.model.element.ExecutableElement)\",\n+                \"method: java.util.List javax.lang.model.util.ElementFilter.recordComponentsIn(java.lang.Iterable)\",\n+                \"method: java.util.Set javax.lang.model.util.ElementFilter.recordComponentsIn(java.util.Set)\",\n+                \"method: java.util.List javax.lang.model.element.TypeElement.getRecordComponents()\",\n+                \"field: javax.lang.model.element.ElementKind:RECORD\",\n+                \"field: javax.lang.model.element.ElementKind:RECORD_COMPONENT\",\n+                \"field: javax.lang.model.element.ElementKind:BINDING_VARIABLE\",\n+                \"field: com.sun.source.tree.Tree.Kind:RECORD\",\n+                \"field: sun.reflect.annotation.TypeAnnotation.TypeAnnotationTarget:RECORD_COMPONENT\",\n+                \"class: java.lang.reflect.RecordComponent\",\n+                \"class: java.lang.runtime.ObjectMethods\",\n+                \"field: java.lang.annotation.ElementType:RECORD_COMPONENT\",\n+                \"class: java.lang.Record\",\n+                \"method: boolean java.lang.Class.isRecord()\",\n+                \"method: java.lang.reflect.RecordComponent[] java.lang.Class.getRecordComponents()\",\n+                \"field: javax.lang.model.element.Modifier:SEALED\",\n+                \"field: javax.lang.model.element.Modifier:NON_SEALED\",\n+                \"method: javax.lang.model.element.TypeElement:getPermittedSubclasses:()\",\n+                \"method: java.util.List com.sun.source.tree.ClassTree.getPermitsClause()\",\n+                \"method: boolean java.lang.Class.isSealed()\",\n+                \"method: java.lang.constant.ClassDesc[] java.lang.Class.permittedSubclasses()\",\n+                \"interface: com.sun.source.tree.PatternTree\",\n+                \"field: com.sun.source.tree.Tree.Kind:BINDING_PATTERN\",\n+                \"method: com.sun.source.tree.PatternTree com.sun.source.tree.InstanceOfTree.getPattern()\",\n+                \"interface: com.sun.source.tree.BindingPatternTree\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitBindingPattern(com.sun.source.tree.BindingPatternTree,java.lang.Object)\"\n+        ));\n+\n+        LEGACY_PREVIEW_METHODS.put(\"16\", Set.of(\n+                \"field: jdk.jshell.Snippet.SubKind:RECORD_SUBKIND\",\n+                \"field: javax.lang.model.element.Modifier:SEALED\",\n+                \"field: javax.lang.model.element.Modifier:NON_SEALED\",\n+                \"method: javax.lang.model.element.TypeElement:getPermittedSubclasses:()\",\n+                \"method: java.util.List com.sun.source.tree.ClassTree.getPermitsClause()\",\n+                \"method: boolean java.lang.Class.isSealed()\",\n+                \"method: java.lang.constant.ClassDesc[] java.lang.Class.permittedSubclasses()\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitBindingPattern(com.sun.source.tree.BindingPatternTree,java.lang.Object)\"\n+        ));\n+\n+        \/\/ java.lang.foreign existed since JDK 19 and wasn't annotated - went out of preview in JDK 22\n+        LEGACY_PREVIEW_METHODS.put(\"19\", Set.of(\n+                \"package: java.lang.foreign\"\n+        ));\n+        LEGACY_PREVIEW_METHODS.put(\"20\", Set.of(\n+                \"package: java.lang.foreign\"\n+        ));\n+        LEGACY_PREVIEW_METHODS.put(\"21\", Set.of(\n+                \"package: java.lang.foreign\"\n+        ));\n+    }\n+\n+    \/**\n+     * Helper to find javadoc and resolve @inheritDoc and the effective since version.\n+     *\/\n+\n+    private final class EffectiveSourceSinceHelper implements AutoCloseable {\n+        private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        private final JavaFileManager baseFileManager;\n+        private final StandardJavaFileManager fm;\n+        private final Set<String> seenLookupElements = new HashSet<>();\n+        private final Map<String, Version> signature2Source = new HashMap<>();\n+\n+        \/**\n+         * Create the helper.\n+         *\n+         * @param mainTask JavacTask from which the further Elements originate\n+         * @param sourceLocations paths where source files should be searched\n+         * @param validator enclosing class of the helper, typically the object invoking this method\n+         * @return a EffectiveSourceSinceHelper\n+         *\/\n+\n+        public static EffectiveSourceSinceHelper create(JavacTask mainTask, Collection<? extends Path> sourceLocations, SinceChecker validator) {\n+            StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null);\n+            try {\n+                fm.setLocationFromPaths(StandardLocation.MODULE_SOURCE_PATH, sourceLocations);\n+                return validator.new EffectiveSourceSinceHelper(mainTask, fm);\n+            } catch (IOException ex) {\n+                try {\n+                    fm.close();\n+                } catch (IOException closeEx) {\n+                    ex.addSuppressed(closeEx);\n+                }\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private EffectiveSourceSinceHelper(JavacTask mainTask, StandardJavaFileManager fm) {\n+            this.baseFileManager = ((JavacTaskImpl) mainTask).getContext().get(JavaFileManager.class);\n+            this.fm = fm;\n+        }\n+\n+        public Version effectiveSinceVersion(Element owner, Element element, Types typeUtils, Elements elementUtils) {\n+            String handle = getElementName(owner, element, typeUtils);\n+            Version since = signature2Source.get(handle);\n+\n+            if (since == null) {\n+                try {\n+                    Element lookupElement = switch (element.getKind()) {\n+                        case MODULE, PACKAGE -> element;\n+                        default -> elementUtils.getOutermostTypeElement(element);\n+                    };\n+\n+                    if (lookupElement == null)\n+                        return null;\n+\n+                    String lookupHandle = getElementName(owner, element, typeUtils);\n+\n+                    if (!seenLookupElements.add(lookupHandle)) {\n+                        \/\/we've already processed this top-level, don't try to compute\n+                        \/\/the values again:\n+                        return null;\n+                    }\n+\n+                    Pair<JavacTask, CompilationUnitTree> source = findSource(lookupElement, elementUtils);\n+\n+                    if (source == null)\n+                        return null;\n+\n+                    fillElementCache(source.fst, source.snd, source.fst.getTypes(), source.fst.getElements());\n+                    since = signature2Source.get(handle);\n+\n+\n+                } catch (IOException ex) {\n+                    error(\"JavadocHelper failed for \" + element);\n+                }\n+            }\n+\n+            return since;\n+        }\n+\n+        \/\/where:\n+        private void fillElementCache(JavacTask task, CompilationUnitTree cut, Types typeUtils, Elements elementUtils) {\n+            Trees trees = Trees.instance(task);\n+\n+            new TreePathScanner<Void, Void>() {\n+                @Override\n+                public Void visitMethod(MethodTree node, Void p) {\n+                    handleDeclaration();\n+                    return null;\n+                }\n+\n+                @Override\n+                public Void visitClass(ClassTree node, Void p) {\n+                    handleDeclaration();\n+                    return super.visitClass(node, p);\n+                }\n+\n+                @Override\n+                public Void visitVariable(VariableTree node, Void p) {\n+                    handleDeclaration();\n+                    return null;\n+                }\n+\n+                @Override\n+                public Void visitModule(ModuleTree node, Void p) {\n+                    handleDeclaration();\n+                    return null;\n+                }\n+\n+                @Override\n+                public Void visitBlock(BlockTree node, Void p) {\n+                    return null;\n+                }\n+\n+                @Override\n+                public Void visitPackage(PackageTree node, Void p) {\n+                    if (cut.getSourceFile().isNameCompatible(\"package-info\", JavaFileObject.Kind.SOURCE)) {\n+                        handleDeclaration();\n+                    }\n+                    return super.visitPackage(node, p);\n+                }\n+\n+                private void handleDeclaration() {\n+                    Element currentElement = trees.getElement(getCurrentPath());\n+\n+                    if (currentElement != null) {\n+                        signature2Source.put(getElementName(currentElement.getEnclosingElement(), currentElement, typeUtils), computeSinceVersion(currentElement, typeUtils, elementUtils));\n+                    }\n+                }\n+            }.scan(cut, null);\n+        }\n+\n+        private Version computeSinceVersion(Element element, Types types,\n+                                            Elements elementUtils) {\n+            String docComment = elementUtils.getDocComment(element);\n+            Version version = null;\n+            if (docComment != null) {\n+                version = extractSinceVersionFromText(docComment);\n+            }\n+\n+            if (version != null) {\n+                return version; \/\/explicit @since has an absolute priority\n+            }\n+\n+            if (element.getKind() != ElementKind.MODULE) {\n+                version = effectiveSinceVersion(element.getEnclosingElement().getEnclosingElement(), element.getEnclosingElement(), types, elementUtils);\n+            }\n+            if (version == null) {\n+                \/\/may be null for private elements\n+            }\n+            return version;\n+\n+        }\n+\n+        private Pair<JavacTask, CompilationUnitTree> findSource(Element forElement, Elements elementUtils) throws IOException {\n+            String moduleName = elementUtils.getModuleOf(forElement).getQualifiedName().toString();\n+            String binaryName = switch (forElement.getKind()) {\n+                case MODULE -> \"module-info\";\n+                case PACKAGE -> ((QualifiedNameable) forElement).getQualifiedName() + \".package-info\";\n+                default -> elementUtils.getBinaryName((TypeElement) forElement).toString();\n+            };\n+            Location packageLocationForModule = fm.getLocationForModule(StandardLocation.MODULE_SOURCE_PATH, moduleName);\n+            JavaFileObject jfo = fm.getJavaFileForInput(packageLocationForModule,\n+                    binaryName,\n+                    JavaFileObject.Kind.SOURCE);\n+\n+            if (jfo == null)\n+                return null;\n+\n+            List<JavaFileObject> jfos = Arrays.asList(jfo);\n+            JavaFileManager patchFM = moduleName != null\n+                    ? new PatchModuleFileManager(baseFileManager, jfo, moduleName)\n+                    : baseFileManager;\n+            JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, patchFM, d -> {\n+            }, null, null, jfos);\n+            Iterable<? extends CompilationUnitTree> cuts = task.parse();\n+\n+            task.enter();\n+\n+            return Pair.of(task, cuts.iterator().next());\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            fm.close();\n+        }\n+\n+        \/**\n+         * Manages files within a patch module.\n+         * Provides custom behavior for handling file locations within a patch module.\n+         * Includes methods to specify module locations, infer module names and determine\n+         * if a location belongs to the patch module path.\n+         *\/\n+        private static final class PatchModuleFileManager\n+                extends ForwardingJavaFileManager<JavaFileManager> {\n+\n+            private final JavaFileObject file;\n+            private final String moduleName;\n+\n+            public PatchModuleFileManager(JavaFileManager fileManager,\n+                                          JavaFileObject file,\n+                                          String moduleName) {\n+                super(fileManager);\n+                this.file = file;\n+                this.moduleName = moduleName;\n+            }\n+\n+            @Override\n+            public Location getLocationForModule(Location location,\n+                                                 JavaFileObject fo) throws IOException {\n+                return fo == file\n+                        ? PATCH_LOCATION\n+                        : super.getLocationForModule(location, fo);\n+            }\n+\n+            @Override\n+            public String inferModuleName(Location location) throws IOException {\n+                return location == PATCH_LOCATION\n+                        ? moduleName\n+                        : super.inferModuleName(location);\n+            }\n+\n+            @Override\n+            public boolean hasLocation(Location location) {\n+                return location == StandardLocation.PATCH_MODULE_PATH ||\n+                        super.hasLocation(location);\n+            }\n+\n+            private static final Location PATCH_LOCATION = new Location() {\n+                @Override\n+                public String getName() {\n+                    return \"PATCH_LOCATION\";\n+                }\n+\n+                @Override\n+                public boolean isOutputLocation() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public boolean isModuleOrientedLocation() {\n+                    return false;\n+                }\n+            };\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/sincechecker\/SinceChecker.java","additions":842,"deletions":0,"binary":false,"changes":842,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331051\n+ * @summary Test for `@since` for java.base module\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/tools\/sincechecker\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ * @run main SinceChecker java.base\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/testjavabase\/CheckSince_javaBase.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}