{"files":[{"patch":"@@ -60,0 +60,2 @@\n+    boolean upgrade;\n+    boolean upgraded;\n@@ -73,0 +75,1 @@\n+    private static final String GET = \"GET\";\n@@ -98,0 +101,1 @@\n+        this.upgrade = isUpgradeRequest(reqHdrs);\n@@ -132,0 +136,9 @@\n+    \/\/ check if Upgrade connection\n+    private boolean isUpgradeRequest(Headers headers) {\n+        var values = headers.get(\"Connection\");\n+        return values != null\n+            && headers.get(\"Upgrade\") != null\n+            && GET.equals(getRequestMethod())\n+            && values.stream().filter(\"Upgrade\"::equalsIgnoreCase).findAny().isPresent();\n+    }\n+\n@@ -165,1 +178,3 @@\n-        if (reqContentLen == -1L) {\n+        if (upgrade) {\n+            uis_orig = new UpgradeInputStream(this, ris);\n+        } else if (reqContentLen == -1L) {\n@@ -167,1 +182,0 @@\n-            uis = uis_orig;\n@@ -170,1 +184,0 @@\n-            uis = uis_orig;\n@@ -172,0 +185,1 @@\n+        uis = uis_orig;\n@@ -224,1 +238,2 @@\n-        \/* check for response type that is not allowed to send a body *\/\n+        \/* check for connection upgrade *\/\n+        if (rCode == 101) {\n@@ -226,3 +241,10 @@\n-        if ((rCode>=100 && rCode <200) \/* informational *\/\n-            ||(rCode == 204)           \/* no content *\/\n-            ||(rCode == 304))          \/* not modified *\/\n+            if (contentLen != 0) {\n+                logger.log(\n+                    Level.WARNING,\n+                    () -> \"sendResponseHeaders: rCode = \" + rCode + \": forcing contentLen = 0\");\n+            }\n+            contentLen = 0;\n+        \/* check for response type that is not allowed to send a body *\/\n+        } else if (rCode >= 100 && rCode < 200 \/* informational *\/\n+            || rCode == 204           \/* no content *\/\n+            || rCode == 304)          \/* not modified *\/\n@@ -256,0 +278,3 @@\n+                } else if (upgrade && rCode == 101) {\n+                    o.setWrappedStream (new UpgradeOutputStream (this, ros));\n+                    close = true;\n@@ -294,0 +319,3 @@\n+        } else if (upgrade && rCode == 101) {\n+            upgraded = true;\n+            ros.flush();\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ExchangeImpl.java","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+\/**\n+ * A class which allows the caller to read the underlying stream for an upgrade request.\n+ * close() does not close the underlying stream\n+ *\/\n+class UpgradeInputStream extends LeftOverInputStream {\n+\n+    UpgradeInputStream(ExchangeImpl t, InputStream src) {\n+        super(t, src);\n+    }\n+\n+    @Override\n+    protected int readImpl(byte[] b, int off, int len) throws IOException {\n+        if (!t.upgraded) {\n+            return -1;\n+        }\n+        return in.read(b, off, len);\n+    }\n+\n+    @Override\n+    public int available() throws IOException {\n+        if (!t.upgraded) {\n+            return 0;\n+        }\n+        return in.available();\n+    }\n+\n+    @Override\n+    public void reset() throws IOException {\n+        throw new IOException(\"mark\/reset not supported\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        closed = true;\n+        t.getServerImpl().requestCompleted(t.getConnection());\n+    }\n+\n+    @Override\n+    public byte[] readAllBytes() throws IOException {\n+        if (!t.upgraded) {\n+          return new byte[0];\n+        }\n+        throw new IOException(\"readAllBytes not supported for upgraded requests\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/UpgradeInputStream.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.Objects;\n+\n+\/**\n+ * a class which allows the caller to write an indefinite number of bytes to an underlying stream.\n+ * Used for upgraded connections only.\n+ *\/\n+class UpgradeOutputStream extends FilterOutputStream {\n+    private boolean closed = false;\n+    ExchangeImpl t;\n+\n+    UpgradeOutputStream(ExchangeImpl t, OutputStream src) {\n+        super(src);\n+        this.t = t;\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        if (closed) {\n+            throw new IOException(\"stream closed\");\n+        }\n+        out.write(b);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0) {\n+            return;\n+        }\n+        if (closed) {\n+            throw new IOException(\"stream closed\");\n+        }\n+        out.write(b, off, len);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        flush();\n+        LeftOverInputStream is = t.getOriginalInputStream();\n+        if (!is.isClosed()) {\n+            is.close();\n+        }\n+        Event e = new Event.WriteFinished(t);\n+        t.getHttpContext().getServerImpl().addEvent(e);\n+        out.close();\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/UpgradeOutputStream.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=default\n+ * @bug 8368695\n+ * @summary Test 101 switching protocal response handling\n+ * @run junit\/othervm SwitchingProtocolTest\n+ *\/\n+\/**\n+ * @test id=preferIPv6\n+ * @bug 8368695\n+ * @summary Test 101 switching protocal response handling ipv6\n+ * @run junit\/othervm -Djava.net.preferIPv6Addresses=true SwitchingProtocolTest\n+ *\/\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.net.httpserver.HttpServer;\n+\n+public class SwitchingProtocolTest {\n+\n+    private static final String RESPONSE_BODY = \"Here is my reply!\";\n+    private static final String REQUEST_BODY = \"I will send all the data.\";\n+    private static final int REQUEST_LENGTH = REQUEST_BODY.getBytes().length;\n+    private static final int msgCode = 101;\n+    private static final String someContext = \"\/context\";\n+\n+    static {\n+        Logger.getLogger(\"\").setLevel(Level.ALL);\n+        Logger.getLogger(\"\").getHandlers()[0].setLevel(Level.ALL);\n+    }\n+\n+    @Test\n+    public void testSendResponse() throws Exception {\n+        System.out.println(\"testSendResponse()\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer server = HttpServer.create(new InetSocketAddress(8080), 0);\n+        HttpServer.create(new InetSocketAddress(loopback, 0), 0);\n+        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();\n+        server.setExecutor(executor);\n+        try {\n+            server.createContext(\n+                someContext,\n+                msg -> {\n+                    byte[] reply = RESPONSE_BODY.getBytes(UTF_8);\n+                    System.err.println(\"Handling request: \" + msg.getRequestURI());\n+                    try {\n+                        assertEquals(-1, msg.getRequestBody().read());\n+                        assertEquals(0, msg.getRequestBody().readAllBytes().length);\n+                        msg.sendResponseHeaders(msgCode, -1);\n+                        \/\/ Read and assert request body\n+                        byte[] requestBytes = msg.getRequestBody().readNBytes(REQUEST_LENGTH);\n+                        String requestBody = new String(requestBytes, UTF_8);\n+                        assertEquals(REQUEST_BODY, requestBody);\n+                        msg.getResponseBody().write(reply);\n+                        msg.getResponseBody().flush();\n+                    } finally {\n+                        \/\/ don't close the exchange and don't close any stream\n+                        \/\/ to trigger the assertion.\n+                        System.err.println(\"Request handled: \" + msg.getRequestURI());\n+                    }\n+                });\n+            server.start();\n+            System.out.println(\"Server started at port \" + server.getAddress().getPort());\n+\n+            runRawSocketHttpClient(loopback, server.getAddress().getPort());\n+        } finally {\n+            System.out.println(\"shutting server down\");\n+            executor.shutdown();\n+            server.stop(0);\n+        }\n+        System.out.println(\"Server finished.\");\n+    }\n+\n+    @Test\n+    public void testCloseOutputStream() throws Exception {\n+        System.out.println(\"testCloseOutputStream()\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer server = HttpServer.create(new InetSocketAddress(loopback, 0), 0);\n+        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();\n+        server.setExecutor(executor);\n+        try {\n+            server.createContext(\n+                someContext,\n+                msg -> {\n+                    System.err.println(\"Handling request: \" + msg.getRequestURI());\n+                    byte[] reply = RESPONSE_BODY.getBytes(UTF_8);\n+                    try {\n+                        try {\n+                            msg.sendResponseHeaders(msgCode, -1);\n+                            msg.getResponseBody().write(reply);\n+                            msg.getResponseBody().flush();\n+                            \/\/ Read and assert request body\n+                            byte[] requestBytes = msg.getRequestBody().readNBytes(REQUEST_LENGTH);\n+                            String requestBody = new String(requestBytes, UTF_8);\n+                            assertEquals(REQUEST_BODY, requestBody);\n+                            msg.getResponseBody().close();\n+                            Thread.sleep(50);\n+                        } catch (IOException | InterruptedException ie) {\n+                            ie.printStackTrace();\n+                        }\n+                    } finally {\n+                        System.err.println(\"Request handled: \" + msg.getRequestURI());\n+                    }\n+                });\n+            server.start();\n+            System.out.println(\"Server started at port \" + server.getAddress().getPort());\n+\n+            runRawSocketHttpClient(loopback, server.getAddress().getPort());\n+        } finally {\n+            System.out.println(\"shutting server down\");\n+            executor.shutdown();\n+            server.stop(0);\n+        }\n+        System.out.println(\"Server finished.\");\n+    }\n+\n+\n+    @Test\n+    public void testException() throws Exception {\n+        System.out.println(\"testException()\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer server = HttpServer.create(new InetSocketAddress(loopback, 0), 0);\n+        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();\n+        server.setExecutor(executor);\n+        try {\n+            server.createContext(\n+                someContext,\n+                msg -> {\n+                    msg.sendResponseHeaders(msgCode, -1);\n+                    throw new RuntimeException(\"Simulated exception\");\n+                });\n+            server.start();\n+            System.out.println(\"Server started at port \" + server.getAddress().getPort());\n+\n+            runRawSocketHttpClient(loopback, server.getAddress().getPort(), true);\n+        } finally {\n+            System.out.println(\"shutting server down\");\n+            executor.shutdown();\n+            server.stop(0);\n+        }\n+        System.out.println(\"Server finished.\");\n+    }\n+\n+    static void runRawSocketHttpClient(InetAddress address, int port) throws Exception {\n+        runRawSocketHttpClient(address, port, false);\n+    }\n+\n+    static void runRawSocketHttpClient(InetAddress address, int port, boolean exception)\n+        throws Exception {\n+        Socket socket = null;\n+        PrintWriter writer = null;\n+        BufferedReader reader = null;\n+        final String CRLF = \"\\r\\n\";\n+        try {\n+            socket = new Socket(address, port);\n+            writer = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));\n+            System.out.println(\"Client connected by socket: \" + socket);\n+            String body = REQUEST_BODY;\n+            var contentLength = body.getBytes(UTF_8).length;\n+\n+            writer.print(\"GET \" + someContext + \"\/ HTTP\/1.1\" + CRLF);\n+            writer.print(\"User-Agent: Java\/\" + System.getProperty(\"java.version\") + CRLF);\n+            writer.print(\"Host: \" + address.getHostName() + CRLF);\n+            writer.print(\"Accept: *\/*\" + CRLF);\n+            writer.print(\"Content-Length: \" + contentLength + CRLF);\n+            writer.print(\"Connection: keep-alive\" + CRLF);\n+            writer.print(\"Connection: Upgrade\" + CRLF);\n+            writer.print(\"Upgrade: custom\" + CRLF);\n+            writer.print(CRLF); \/\/ Important, else the server will expect that\n+            \/\/ there's more into the request.\n+            writer.flush();\n+            System.out.println(\"Client wrote request to socket: \" + socket);\n+\n+            System.out.println(\"Client wrote body to socket: \" + socket);\n+\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            System.out.println(\"Client start reading from server:\");\n+            String line = reader.readLine();\n+            StringBuilder responseBody = new StringBuilder();\n+            for (; line != null; line = reader.readLine()) {\n+                if (line.isEmpty()) {\n+                    break;\n+                }\n+                System.out.println(\"\\\"\" + line + \"\\\"\");\n+            }\n+            \/\/ Write request body after headers\n+            writer.print(body);\n+            writer.flush();\n+            \/\/ Read response body\n+            char[] buf = new char[RESPONSE_BODY.length()];\n+            int read = reader.read(buf);\n+            if (read > 0) {\n+                responseBody.append(buf, 0, read);\n+            }\n+            String actualResponse = responseBody.toString();\n+            assertEquals(RESPONSE_BODY, actualResponse, \"Response body does not match\");\n+            System.out.println(\"Client finished reading from server\");\n+        } catch (SocketException se) {\n+            if (!exception) {\n+                fail(\"Unexpected exception: \" + se);\n+            }\n+            assertEquals(\"Connection reset\", se.getMessage());\n+        } finally {\n+            if (writer != null) {\n+                writer.close();\n+            }\n+            if (reader != null)\n+                try {\n+                    reader.close();\n+                } catch (IOException logOrIgnore) {\n+                    logOrIgnore.printStackTrace();\n+                }\n+            if (socket != null) {\n+                try {\n+                    socket.close();\n+                } catch (IOException logOrIgnore) {\n+                    logOrIgnore.printStackTrace();\n+                }\n+            }\n+        }\n+        System.out.println(\"Client finished.\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/SwitchingProtocolTest.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"}]}