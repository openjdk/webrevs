{"files":[{"patch":"@@ -203,0 +203,133 @@\n+ * <h2><a id=decimalToBinaryConversion>Decimal &harr; Binary Conversion Issues<\/a><\/h2>\n+ *\n+ * Many surprising aspects of binary floating-point arithmetic trace\n+ * back to aspects of decimal to binary conversion and binary to\n+ * decimal conversion. While integer values can be exactly represented\n+ * in any base, which fractional values can be exactly represented is\n+ * a function of the base. For example, in base 10, 1\/3 is a repeating\n+ * fraction (0.33333....); but in base 3, 1\/3 is exactly\n+ * 0.1<sub>(3)<\/sub>, that is 1&nbsp;&times;&nbsp;3<sup>-1<\/sup>.\n+ * Similarly, in base 10, 1\/10 is exactly representable as 0.1, but in\n+ * base 2, it is a repeating fraction\n+ * (0.0001100110011...<sub>(2)<\/sub>).\n+ *\n+ * <p>Values of the {@code float} type have {@value Float#PRECISION}\n+ * bits of precision and values of the {@code double} type have\n+ * {@value Double#PRECISION} bits of precision. Therefore, since 0.1\n+ * is a repeating fraction in base 2 with a four-bit repeat, {@code\n+ * 0.1f} != {@code 0.1d}. In more detail, including hexadecimal\n+ * floating-point literals:\n+ *\n+ * <ul>\n+ * <li>The exact numerical value of {@code 0.1f} ({@code 0x1.99999a0000000p-4f}) is\n+ *     0.100000001490116119384765625.\n+ * <li>The exact numerical value of {@code 0.1d} ({@code 0x1.999999999999ap-4d}) is\n+ *     0.1000000000000000055511151231257827021181583404541015625.\n+ * <\/ul>\n+ *\n+ * These are the closest {@code float} and {@code double} values,\n+ * respectively, to the numerical value of 0.1.  These results are\n+ * consistent with a {@code float} value having the equivalent of 6 to\n+ * 9 digits of decimal precision and a {@code double} value having the\n+ * equivalent of 15 to 17 digits of decimal precision. (The\n+ * equivalent precision varies according to the different relative\n+ * densities of binary and decimal values at different points along the\n+ * real number line).\n+ *\n+ * <p>This representation hazard of decimal fractions is one reason to\n+ * use caution when storing monetary values as {@code float} or {@code\n+ * double}. Alternatives include using an integer type and storing\n+ * cents or mills or using {@link java.math.BigDecimal BigDecimal} to\n+ * store decimal fraction values exactly.\n+ *\n+ * <p>For each finite floating-point value and a given floating-point\n+ * type, there is a contiguous region of the real number line which\n+ * maps to that value. Under the default round to nearest rounding\n+ * policy (JLS {@jls 15.4}), this contiguous region for a value is\n+ * typically one {@linkplain Math#ulp ulp} (unit in the last place)\n+ * wide and centered around the exactly representable value. (At\n+ * exponent boundaries, the region is asymmetrical and larger on the\n+ * side with the larger exponent.) For example, for {@code 0.1f}, the\n+ * region can be computed as follows:\n+ *\n+ * <br>\/\/ Numeric values listed are exact values\n+ * <br>oneTenthApproxAsFloat = 0.100000001490116119384765625;\n+ * <br>ulpOfoneTenthApproxAsFloat = Math.ulp(0.1f) = 7.450580596923828125E-9;\n+ * <br>\/\/ Numeric range that is converted to the float closest to 0.1, _excludes_ endpoints\n+ * <br>(oneTenthApproxAsFloat - &frac12;ulpOfoneTenthApproxAsFloat, oneTenthApproxAsFloat + &frac12;ulpOfoneTenthApproxAsFloat) =\n+ * <br>(0.0999999977648258209228515625, 0.1000000052154064178466796875)\n+ *\n+ * <p>In particular, a correctly rounded decimal to binary conversion\n+ * of any string representing a number in this range, say by {@link\n+ * Float#valueOf(String)}, will be converted to the same value:\n+ *\n+ * {@snippet lang=\"java\" :\n+ * Float.valueOf(\"0.0999999977648258209228515625000001\"); \/\/ rounds up to oneTenthApproxAsFloat\n+ * Float.valueOf(\"0.099999998\");                          \/\/ rounds up to oneTenthApproxAsFloat\n+ * Float.valueOf(\"0.1\");                                  \/\/ rounds up to oneTenthApproxAsFloat\n+ * Float.valueOf(\"0.100000001490116119384765625\");        \/\/ exact conversion\n+ * Float.valueOf(\"0.100000005215406417846679687\");        \/\/ rounds down to oneTenthApproxAsFloat\n+ * Float.valueOf(\"0.100000005215406417846679687499999\");  \/\/ rounds down to oneTenthApproxAsFloat\n+ * }\n+ *\n+ * <p>An analogous range can be constructed similarly for the {@code\n+ * double} type based on the exact value of {@code double}\n+ * approximation to {@code 0.1d} and the numerical value of {@code\n+ * Math.ulp(0.1d)} and likewise for other particular numerical values\n+ * in the {@code float} and {@code double} types.\n+ *\n+ * <p>As seen in the above conversions, compared to the exact result\n+ * the same floating-point value as a result can be:\n+ * <ul>\n+ * <li>greater than the exact result\n+ * <li>less than the exact result\n+ * <li>equal to the exact result\n+ * <\/ul>\n+ *\n+ * A floating-point value doesn't \"know\" if it was the result of\n+ * rounding up, or rounding down, or an exact operation; it contains\n+ * no history of how it was computed. Consequently, the sum of\n+ * {@snippet lang=\"java\" :\n+ * 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f;\n+ * \/\/ Numerical value of computed sum: 1.00000011920928955078125,\n+ * \/\/ the next floating-point value larger than 1.0f, equal to Math.nextUp(1.0f).\n+ * }\n+ * or\n+ * {@snippet lang=\"java\" :\n+ * 0.1d + 0.1d + 0.1d + 0.1d + 0.1d + 0.1d + 0.1d + 0.1d + 0.1d + 0.1d;\n+ * \/\/ Numerical value of computed sum: 0.99999999999999988897769753748434595763683319091796875,\n+ * \/\/ the next floating-point value smaller than 1.0d, equal to Math.nextDown(1.0d).\n+ * }\n+ *\n+ * should <em>not<\/em> be expected to be exactly equal to 1.0, but\n+ * only close to 1.0. Consequently the following code is an infinite loop:\n+ *\n+ * {@snippet lang=\"java\" :\n+ * double d = 0.0;\n+ * while(d != 1.0) { \/\/ Surprising infinite loop\n+ *   d += 0.1; \/\/ Sum never _exactly_ equals 1.0\n+ * }\n+ * }\n+ *\n+ * Instead, for counted loops, use an integer loop count:\n+ *\n+ * {@snippet lang=\"java\" :\n+ * double d = 0.0;\n+ * for(int i = 0; i < 10; i++) {\n+ *   d += 0.1;\n+ * } \/\/ Value of d is equal to Math.nextDown(1.0).\n+ * }\n+ *\n+ * or test against a floating-point limit using ordered comparisons (&lt;, &lt;=, &gt;, &gt;=):\n+ *\n+ * {@snippet lang=\"java\" :\n+ *  double d = 0.0;\n+ *  while(d <= 1.0) {\n+ *    d += 0.1;\n+ *  } \/\/ Value of d approximately 1.0999999999999999\n+ *  }\n+ *\n+ * Certain aspects of floating-point arithmetic may be surprising, but\n+ * IEEE 754 floating-point arithmetic follows a principled design and\n+ * its behavior is predictable on the Java platform.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"modified"}]}