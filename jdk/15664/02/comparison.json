{"files":[{"patch":"@@ -231,1 +231,4 @@\n-            connections.values().forEach(this::close);\n+            for (var entry : connections.entrySet()) {\n+                connections.values().forEach(this::close);\n+                connections.remove(entry.getKey(), entry.getValue());\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,0 +164,3 @@\n+    \/\/ Only accessed in all method calls from incoming(), no need for volatile\n+    private boolean endStreamSeen;\n+\n@@ -190,1 +193,7 @@\n-                    handleReset(rf, subscriber);\n+                    if (endStreamReceived()) {\n+                        \/\/ If END_STREAM is already received, we should not receive any new RST_STREAM frames and\n+                        \/\/ close the connection gracefully by processing all remaining frames in the inputQ.\n+                        requestBodyCF.complete(null);\n+                    } else {\n+                        handleReset(rf, subscriber);\n+                    }\n@@ -204,1 +213,1 @@\n-                    sched.stop();\n+                    if (inputQ.isEmpty()) sched.stop();\n@@ -223,1 +232,1 @@\n-                        sched.stop();\n+                        if (inputQ.isEmpty()) sched.stop();\n@@ -475,0 +484,1 @@\n+\/\/        endStreamSeen = endStreamSeen || frame.getFlag(HeaderFrame.END_STREAM);\n@@ -481,0 +491,1 @@\n+                endStreamSeen = true;\n@@ -485,0 +496,1 @@\n+            if (df.getFlag(DataFrame.END_STREAM)) endStreamSeen = true;\n@@ -568,0 +580,2 @@\n+    \/\/ Logic here starts checking roughly in reverse order of the Stream's life-cycle i.e. check if closed, check if\n+    \/\/ closing or done sending, response received or waiting for expect continue, receiving reset on active stream...\n@@ -570,1 +584,3 @@\n-        if (endStreamReceived()) {\n+        Flow.Subscriber<?> subscriber = responseSubscriber == null ? pendingResponseSubscriber : responseSubscriber;\n+        if (endStreamReceived() && requestBodyCF.isDone()) {\n+            \/\/ END_STREAM flag may have been seen in the queue before processing this ResetFrame\n@@ -574,0 +590,6 @@\n+        } else if (subscriber == null && !endStreamSeen) {\n+            handleReset(frame, null);\n+        } else if (!requestBodyCF.isDone()) {\n+            incompleteRequestBodyReset(frame, subscriber);\n+        } else if (response == null || !finalResponseCodeReceived) {\n+            handleReset(frame, null);\n@@ -575,19 +597,17 @@\n-            Flow.Subscriber<?> subscriber =\n-                    responseSubscriber == null ? pendingResponseSubscriber : responseSubscriber;\n-            if (!requestBodyCF.isDone()) {\n-                \/\/ If a RST_STREAM is received, complete the requestBody. This will allow the\n-                \/\/ response to be read before the Reset is handled in the case where the client's\n-                \/\/ input stream is partially consumed or not consumed at all by the server.\n-                if (frame.getErrorCode() != ResetFrame.NO_ERROR) {\n-                    if (debug.on()) {\n-                        debug.log(\"completing requestBodyCF exceptionally due to received\" +\n-                                \" RESET(%s) (stream=%s)\", frame.getErrorCode(), streamid);\n-                    }\n-                    requestBodyCF.completeExceptionally(new IOException(\"RST_STREAM received\"));\n-                } else {\n-                    if (debug.on()) {\n-                        debug.log(\"completing requestBodyCF normally due to received\" +\n-                                \" RESET(NO_ERROR) (stream=%s)\", streamid);\n-                    }\n-                    requestBodyCF.complete(null);\n-                }\n+            \/\/ Put ResetFrame into inputQ. Any frames already in the queue will be processed before the ResetFrame.\n+            receiveResetFrame(frame);\n+            Log.logTrace(\"RST_STREAM pushed in queue for stream {0}\", streamid);\n+        }\n+    }\n+\n+    void incompleteRequestBodyReset(ResetFrame frame, Flow.Subscriber<?> subscriber) {\n+        if (frame.getErrorCode() != ResetFrame.NO_ERROR) {\n+            if (debug.on()) {\n+                debug.log(\"completing requestBodyCF exceptionally due to received\" +\n+                        \" RESET(%s) (stream=%s)\", frame.getErrorCode(), streamid);\n+            }\n+            requestBodyCF.completeExceptionally(new IOException(\"RST_STREAM received\"));\n+        } else {\n+            if (debug.on()) {\n+                debug.log(\"completing requestBodyCF normally due to received\" +\n+                        \" RESET(NO_ERROR) (stream=%s)\", streamid);\n@@ -595,4 +615,3 @@\n-            if ((response == null || !finalResponseCodeReceived) && subscriber == null) {\n-                \/\/ we haven't received the headers yet, and won't receive any!\n-                \/\/ handle reset now.\n-                handleReset(frame, null);\n+            if (!endStreamSeen) {\n+                \/\/ If no END_STREAM flag seen, any RST_STREAM should be handled here immediately\n+                handleReset(frame, subscriber);\n@@ -600,10 +619,1 @@\n-                \/\/ put it in the input queue in order to read all\n-                \/\/ pending data frames first. Indeed, a server may send\n-                \/\/ RST_STREAM after sending END_STREAM, in which case we should\n-                \/\/ ignore it. However, we won't know if we have received END_STREAM\n-                \/\/ or not until all pending data frames are read.\n-                receiveResetFrame(frame);\n-                \/\/ RST_STREAM was pushed to the queue. It will be handled by\n-                \/\/ asyncReceive after all pending data frames have been\n-                \/\/ processed.\n-                Log.logTrace(\"RST_STREAM pushed in queue for stream {0}\", streamid);\n+                requestBodyCF.complete(null);\n@@ -625,1 +635,1 @@\n-                stateLock.lock();\n+                stateLock.unlock();\n@@ -638,0 +648,1 @@\n+                    if (debug.on()) debug.log(\"\\nHERE\");\n@@ -641,0 +652,1 @@\n+                    if (debug.on()) debug.log(\"\\nALSO HERE\");\n@@ -1078,0 +1090,1 @@\n+                \/\/ TODO: Maybe throw exception here to fix intermittent error?\n@@ -1099,0 +1112,1 @@\n+        \/\/ TODO: We could put the check for END_STREAM received here?\n@@ -1378,1 +1392,3 @@\n-            if (responseSubscriber != null || pendingResponseSubscriber != null) {\n+            var subscriber = this.responseSubscriber;\n+            if (subscriber == null) subscriber = this.pendingResponseSubscriber;\n+            if (subscriber != null) {\n@@ -1382,0 +1398,5 @@\n+                if (subscriber instanceof Http2StreamResponseSubscriber<?> rs) {\n+                    \/\/ make sure the subscriber is stopped.\n+                    if (debug.on()) debug.log(\"closing response subscriber stream %s\", streamid);\n+                    rs.complete(errorRef.get());\n+                }\n@@ -1385,1 +1406,1 @@\n-                        streamid, (Object)errorRef.get());\n+                            streamid, (Object)errorRef.get());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":61,"deletions":40,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -26,3 +26,1 @@\n- * @summary Tests that when the httpclient sends a 100 Expect Continue header and receives\n- *          a response code of 417 Expectation Failed, that the client does not hang\n- *          indefinitely and closes the connection.\n+ * @summary Tests basic handling of Partial Responses by the HttpClient\n@@ -32,1 +30,1 @@\n- * @run testng\/othervm -Djdk.internal.httpclient.debug=err ExpectContinueTest\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true -Djdk.httpclient.HttpClient.log=errors ExpectContinueTest\n@@ -36,0 +34,9 @@\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeImpl;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import org.testng.TestException;\n@@ -42,0 +49,1 @@\n+import javax.net.ssl.SSLSession;\n@@ -49,0 +57,1 @@\n+import java.io.PrintStream;\n@@ -58,0 +67,1 @@\n+import java.net.http.HttpHeaders;\n@@ -61,0 +71,1 @@\n+import java.util.concurrent.CancellationException;\n@@ -62,0 +73,2 @@\n+import java.util.concurrent.ExecutionException;\n+\n@@ -67,1 +80,1 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.*;\n@@ -73,1 +86,1 @@\n-    HttpTestServer http2TestServer; \/\/ HTTP\/2\n+    Http2TestServer http2TestServer; \/\/ HTTP\/2\n@@ -75,6 +88,2 @@\n-    URI getUri;\n-    URI postUri;\n-    URI hangUri;\n-    URI h2getUri;\n-    URI h2postUri;\n-    URI h2hangUri;\n+    URI getUri, postUri, hangUri;\n+    URI h2postUri, h2hangUri, h2endStreamUri, h2warmupURI;\n@@ -82,0 +91,2 @@\n+    static PrintStream err = new PrintStream(System.err);\n+    static PrintStream out = new PrintStream(System.out);\n@@ -84,0 +95,39 @@\n+    @DataProvider(name = \"uris\")\n+    public Object[][] urisData() {\n+        return new Object[][]{\n+                \/\/ URI, Expected Status Code, Will finish with Exception, Protocol Version\n+                { postUri, 200, false, HTTP_1_1 },\n+                { hangUri, 417, false, HTTP_1_1},\n+                { h2postUri, 200, false, HTTP_2 },\n+                { h2hangUri, 417, false, HTTP_2 },\n+                { h2endStreamUri, 200, true, HTTP_2 }, \/\/ Error\n+        };\n+    }\n+    @Test(dataProvider = \"uris\")\n+    public void test(URI uri, int expectedStatusCode, boolean exceptionally, HttpClient.Version version)\n+            throws CancellationException, InterruptedException, ExecutionException, IOException {\n+\n+        err.printf(\"\\nTesting with Version: %s, URI: %s, exceptionally: %b\\n\", version, uri, exceptionally);\n+        try (HttpClient client = HttpClient.newBuilder().proxy(Builder.NO_PROXY).version(version).build()) {\n+            HttpResponse<String> resp = null;\n+            Throwable testThrowable = null;\n+            if (!version.equals(HTTP_1_1)) {\n+                err.printf(\"Performing warmup request to %s\", h2warmupURI);\n+                client.send(HttpRequest.newBuilder(h2warmupURI).GET().version(version).build(), HttpResponse.BodyHandlers.discarding());\n+            }\n+            HttpRequest postRequest = HttpRequest.newBuilder(uri)\n+                    .version(version)\n+                    .POST(HttpRequest.BodyPublishers.ofString(\"Sample Post\"))\n+                    .expectContinue(true)\n+                    .build();\n+            err.printf(\"Sending request (%s): %s%n\", version, postRequest);\n+            CompletableFuture<HttpResponse<String>> cf = client.sendAsync(postRequest, HttpResponse.BodyHandlers.ofString());\n+            try {\n+                resp = cf.get();\n+            } catch (Exception e) {\n+                testThrowable = e.getCause();\n+            }\n+            verifyRequest(expectedStatusCode, resp, exceptionally, testThrowable);\n+        }\n+    }\n+\n@@ -87,1 +137,0 @@\n-\n@@ -94,1 +143,1 @@\n-        \/\/ Due to limitations of the above Http1 Server, a manual approach is taken to test the hanging with the\n+        \/\/ Due to limitations of the above Http1 Test Server, a manual approach is taken to test the hanging with the\n@@ -99,0 +148,6 @@\n+        http2TestServer = new Http2TestServer(false, 0);\n+        http2TestServer.setExchangeSupplier(ExpectContinueTestExchangeImpl::new);\n+        http2TestServer.addHandler(new GetHandler().toHttp2Handler(), \"\/http2\/warmup\");\n+        http2TestServer.addHandler(new PostHandler().toHttp2Handler(), \"\/http2\/post\");\n+        http2TestServer.addHandler(new PostHandlerCantContinue().toHttp2Handler(), \"\/http2\/hang\");\n+        http2TestServer.addHandler(new PostHandlerHttp2(), \"\/http2\/endStream\");\n@@ -100,5 +155,1 @@\n-        http2TestServer = HttpTestServer.create(HTTP_2);\n-        http2TestServer.addHandler(new GetHandler(), \"\/http2\/get\");\n-        http2TestServer.addHandler(new PostHandler(), \"\/http2\/post\");\n-        http2TestServer.addHandler(new PostHandlerCantContinue(), \"\/http2\/hang\");\n-        h2getUri = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/get\");\n+        h2warmupURI = new URI(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/warmup\");\n@@ -107,0 +158,1 @@\n+        h2endStreamUri = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/endStream\");\n@@ -108,3 +160,3 @@\n-        System.out.println(\"HTTP\/1.1 server listening at: \" + http1TestServer.serverAuthority());\n-        System.out.println(\"HTTP\/1.1 hang server listening at: \" + hangUri.getRawAuthority());\n-        System.out.println(\"HTTP\/2 clear server listening at: \" + http2TestServer.serverAuthority());\n+        out.printf(\"HTTP\/1.1 server listening at: %s\", http1TestServer.serverAuthority());\n+        out.printf(\"HTTP\/1.1 hang server listening at: %s\", hangUri.getRawAuthority());\n+        out.printf(\"HTTP\/2 clear server listening at: %s\", http2TestServer.serverAuthority());\n@@ -116,1 +168,0 @@\n-\n@@ -128,6 +179,3 @@\n-            try (InputStream is = exchange.getRequestBody();\n-                 OutputStream os = exchange.getResponseBody()) {\n-                System.err.println(\"Server reading body\");\n-                is.readAllBytes();\n-                byte[] bytes = \"RESPONSE_BODY\".getBytes(UTF_8);\n-                System.err.println(\"Server sending 200  (length=\"+bytes.length+\")\");\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                byte[] bytes = \"Response Body\".getBytes(UTF_8);\n+                err.printf(\"Server sending 200  (length=%s)\", bytes.length);\n@@ -135,0 +183,1 @@\n+                err.println(\"Server sending Response Body\");\n@@ -147,1 +196,1 @@\n-                System.err.println(\"Server sending 100 (length = 0)\");\n+                err.println(\"Server sending 100 (length = 0)\");\n@@ -152,3 +201,2 @@\n-            try (InputStream is = exchange.getRequestBody();\n-                OutputStream os = exchange.getResponseBody()) {\n-                System.err.println(\"Server reading body\");\n+            try (InputStream is = exchange.getRequestBody()) {\n+                err.println(\"Server reading body\");\n@@ -156,1 +204,1 @@\n-                System.err.println(\"Server send 200 (length=0)\");\n+                err.println(\"Server send 200 (length=0)\");\n@@ -162,1 +210,1 @@\n-    static class PostHandlerCantContinue implements HttpTestHandler {\n+    static class PostHandlerHttp2 implements Http2Handler {\n@@ -164,0 +212,9 @@\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            if (exchange instanceof ExpectContinueTestExchangeImpl impl) {\n+                impl.sendEndStreamHeaders();\n+            }\n+        }\n+    }\n+\n+    static class PostHandlerCantContinue implements HttpTestHandler {\n@@ -167,2 +224,1 @@\n-            try (InputStream is = exchange.getRequestBody();\n-                 OutputStream os = exchange.getResponseBody()) {\n+            try (OutputStream os = exchange.getResponseBody()) {\n@@ -170,1 +226,1 @@\n-                System.err.println(\"Server send 417 (length=\"+bytes.length+\")\");\n+                err.println(\"Server send 417 (length=\"+bytes.length+\")\");\n@@ -172,0 +228,1 @@\n+                err.println(\"Server sending Response Body\");\n@@ -177,0 +234,19 @@\n+    static class ExpectContinueTestExchangeImpl extends Http2TestExchangeImpl {\n+\n+        public ExpectContinueTestExchangeImpl(int streamid, String method, HttpHeaders reqheaders, HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is, SSLSession sslSession, BodyOutputStream os, Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+        }\n+\n+        private void sendEndStreamHeaders() throws IOException {\n+            this.responseLength = 0;\n+            rspheadersBuilder.setHeader(\":status\", Integer.toString(100));\n+            HttpHeaders headers = rspheadersBuilder.build();\n+            Http2TestServerConnection.ResponseHeaders response\n+                    = new Http2TestServerConnection.ResponseHeaders(headers);\n+            response.streamid(streamid);\n+            response.setFlag(HeaderFrame.END_HEADERS);\n+            response.setFlag(HeaderFrame.END_STREAM);\n+            sendResponseHeaders(response);\n+        }\n+    }\n+\n@@ -225,1 +301,1 @@\n-                                        && version.equals(\"HTTP\/1.1\");\n+                            && version.equals(\"HTTP\/1.1\");\n@@ -264,53 +340,12 @@\n-    @DataProvider(name = \"uris\")\n-    public Object[][] urisData() {\n-        return new Object[][]{\n-                { getUri,   postUri, hangUri, HTTP_1_1 },\n-                { h2getUri,  h2postUri, h2hangUri, HTTP_2 }\n-        };\n-    }\n-\n-    @Test(dataProvider = \"uris\")\n-    public void test(URI getUri, URI postUri, URI hangUri, HttpClient.Version version) throws IOException, InterruptedException {\n-        System.out.println(\"Testing with version: \" + version);\n-        HttpClient client = HttpClient.newBuilder()\n-                .proxy(Builder.NO_PROXY)\n-                .version(version)\n-                .build();\n-\n-        HttpRequest getRequest = HttpRequest.newBuilder(getUri)\n-                .GET()\n-                .build();\n-\n-        HttpRequest postRequest = HttpRequest.newBuilder(postUri)\n-                .POST(HttpRequest.BodyPublishers.ofString(\"Sample Post\"))\n-                .expectContinue(true)\n-                .build();\n-\n-        HttpRequest hangRequest = HttpRequest.newBuilder(hangUri)\n-                .POST(HttpRequest.BodyPublishers.ofString(\"Sample Post\"))\n-                .expectContinue(true)\n-                .build();\n-\n-        System.out.printf(\"Sending request (%s): %s%n\", version, getRequest);\n-        System.err.println(\"Sending request: \" + getRequest);\n-        CompletableFuture<HttpResponse<String>> cf = client.sendAsync(getRequest, HttpResponse.BodyHandlers.ofString());\n-        HttpResponse<String> resp = cf.join();\n-        System.err.println(\"Response Headers: \" + resp.headers());\n-        System.err.println(\"Response Status Code: \" + resp.statusCode());\n-        assertEquals(resp.statusCode(), 200);\n-\n-        System.out.printf(\"Sending request (%s): %s%n\", version, postRequest);\n-        System.err.println(\"Sending request: \" + postRequest);\n-        cf = client.sendAsync(postRequest, HttpResponse.BodyHandlers.ofString());\n-        resp = cf.join();\n-        System.err.println(\"Response Headers: \" + resp.headers());\n-        System.err.println(\"Response Status Code: \" + resp.statusCode());\n-        assertEquals(resp.statusCode(), 200);\n-\n-        System.out.printf(\"Sending request (%s): %s%n\", version, hangRequest);\n-        System.err.println(\"Sending request: \" + hangRequest);\n-        cf = client.sendAsync(hangRequest, HttpResponse.BodyHandlers.ofString());\n-        resp = cf.join();\n-        System.err.println(\"Response Headers: \" + resp.headers());\n-        System.err.println(\"Response Status Code: \" + resp.statusCode());\n-        assertEquals(resp.statusCode(), 417);\n+    private void verifyRequest(int expectedStatusCode, HttpResponse<String> resp, boolean exceptionally, Throwable testThrowable) {\n+        if (exceptionally && testThrowable != null) {\n+            err.println(testThrowable);\n+            assertEquals(IOException.class, testThrowable.getClass());\n+        } else if (exceptionally) {\n+            throw new TestException(\"Expected case to finish with an IOException but testException is null\");\n+        } else if (resp != null) {\n+            assertEquals(resp.statusCode(), expectedStatusCode);\n+            err.println(\"Request completed successfully\");\n+            err.println(\"Response Headers: \" + resp.headers());\n+            err.println(\"Response Status Code: \" + resp.statusCode());\n+        }\n@@ -318,1 +353,0 @@\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueTest.java","additions":127,"deletions":93,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verifies that the client reacts correctly to receiving RST_STREAM at various stages of\n+ *          a Partial Response.\n+ * @bug 8309118\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run testng\/othervm\/timeout=40  -Djdk.internal.httpclient.debug=true -Djdk.httpclient.HttpClient.log=trace,errors,headers\n+ *                              ExpectContinueResetTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeImpl;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.ResetFrame;\n+import org.testng.TestException;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLSession;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.Iterator;\n+import java.util.concurrent.ExecutionException;\n+\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.*;\n+\n+public class ExpectContinueResetTest {\n+\n+    Http2TestServer http2TestServer;\n+    \/\/ \"NoError\" urls complete with an exception. \"NoError\" or \"Error\" here refers to the error code in the RST_STREAM frame\n+    \/\/ and not the outcome of the test.\n+    URI warmup, partialResponseResetNoError, partialResponseResetError, fullResponseResetNoError, fullResponseResetError;\n+\n+    static PrintStream err = new PrintStream(System.err);\n+\n+    @DataProvider(name = \"testDataUnconsumedBody\")\n+    public Object[][] testDataUnconsumedBody() {\n+        \/\/ Not consuming the InputStream in the server's handler results in different handling of RST_STREAM client-side\n+        return new Object[][] {\n+                { partialResponseResetNoError },\n+                { partialResponseResetError },  \/\/ Checks RST_STREAM is processed if client sees no END_STREAM\n+                { fullResponseResetNoError },\n+                { fullResponseResetError }\n+        };\n+    }\n+\n+\n+    @Test(dataProvider = \"testDataUnconsumedBody\")\n+    public void testUnconsumedBody(URI uri) {\n+        err.printf(\"\\nTesting with Version: %s, URI: %s\\n\", HTTP_2, uri.toASCIIString());\n+        Iterable<byte[]> iterable = EndlessDataChunks::new;\n+        HttpRequest.BodyPublisher testPub = HttpRequest.BodyPublishers.ofByteArrays(iterable);\n+        Throwable testThrowable = null;\n+        try {\n+            performRequest(testPub, uri);\n+        } catch (Exception e) {\n+            testThrowable = e.getCause();\n+        }\n+        assertNotNull(testThrowable, \"Request should have completed exceptionally but testThrowable is null\");\n+        assertEquals(testThrowable.getClass(), IOException.class, \"Test should have closed with an IOException\");\n+        testThrowable.printStackTrace();\n+    }\n+\n+    static public class EndlessDataChunks implements Iterator<byte[]> {\n+\n+        byte[] data = new byte[16];\n+        @Override\n+        public boolean hasNext() {\n+            return true;\n+        }\n+        @Override\n+        public byte[] next() {\n+            return data;\n+        }\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        http2TestServer = new Http2TestServer(false, 0);\n+        http2TestServer.setExchangeSupplier(ExpectContinueResetTestExchangeImpl::new);\n+        http2TestServer.addHandler(new GetHandler().toHttp2Handler(), \"\/warmup\");\n+        http2TestServer.addHandler(new NoEndStreamOnPartialResponse(), \"\/partialResponse\/codeNoError\");\n+        http2TestServer.addHandler(new NoEndStreamOnPartialResponse(), \"\/partialResponse\/codeError\");\n+        http2TestServer.addHandler(new NoEndStreamOnFullResponse(), \"\/fullResponse\/codeNoError\");\n+        http2TestServer.addHandler(new NoEndStreamOnFullResponse(), \"\/fullResponse\/codeError\");\n+\n+        warmup = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/warmup\");\n+        partialResponseResetNoError = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/partialResponse\/codeNoError\");\n+        partialResponseResetError = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/partialResponse\/codeError\");\n+        fullResponseResetNoError = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/fullResponse\/codeNoError\");\n+        fullResponseResetError = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/fullResponse\/codeError\");\n+        http2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() {\n+        http2TestServer.stop();\n+    }\n+\n+    private void performRequest(HttpRequest.BodyPublisher bodyPublisher, URI uri)\n+            throws IOException, InterruptedException, ExecutionException {\n+        try (HttpClient client = HttpClient.newBuilder().proxy(HttpClient.Builder.NO_PROXY).version(HTTP_2).build()) {\n+            err.printf(\"Performing warmup request to %s\", warmup);\n+            client.send(HttpRequest.newBuilder(warmup).GET().version(HTTP_2).build(), HttpResponse.BodyHandlers.discarding());\n+            HttpRequest postRequest = HttpRequest.newBuilder(uri)\n+                    .version(HTTP_2)\n+                    .POST(bodyPublisher)\n+                    .expectContinue(true)\n+                    .build();\n+            err.printf(\"Sending request (%s): %s%n\", HTTP_2, postRequest);\n+            \/\/ TODO: when test is stable and complete, see then if fromSubscriber makes our subscriber non null\n+            client.sendAsync(postRequest, HttpResponse.BodyHandlers.ofString()).get();\n+        }\n+    }\n+\n+    static class GetHandler implements HttpServerAdapters.HttpTestHandler {\n+\n+        @Override\n+        public void handle(HttpServerAdapters.HttpTestExchange exchange) throws IOException {\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                byte[] bytes = \"Response Body\".getBytes(UTF_8);\n+                err.printf(\"Server sending 200  (length=%s)\", bytes.length);\n+                exchange.sendResponseHeaders(200, bytes.length);\n+                err.println(\"Server sending Response Body\");\n+                os.write(bytes);\n+            }\n+        }\n+    }\n+\n+    static class NoEndStreamOnPartialResponse implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            err.println(\"Sending 100\");\n+            exchange.sendResponseHeaders(100, 0);\n+            if (exchange instanceof ExpectContinueResetTestExchangeImpl testExchange) {\n+                err.println(\"Sending Reset\");\n+                err.println(exchange.getRequestURI().getPath());\n+                switch (exchange.getRequestURI().getPath()) {\n+                    case \"\/partialResponse\/codeNoError\" -> testExchange.addResetToOutputQ(ResetFrame.NO_ERROR);\n+                    case \"\/partialResponse\/codeError\" -> testExchange.addResetToOutputQ(ResetFrame.PROTOCOL_ERROR);\n+                    default -> throw new TestException(\"Invalid Request Path\");\n+                }\n+            } else {\n+                throw new TestException(\"Wrong Exchange type used\");\n+            }\n+        }\n+    }\n+\n+    static class NoEndStreamOnFullResponse implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            err.println(\"Sending 100\");\n+            exchange.sendResponseHeaders(100, 0);\n+            err.println(\"Sending 200\");\n+            exchange.sendResponseHeaders(200, 0);\n+            if (exchange instanceof ExpectContinueResetTestExchangeImpl testExchange) {\n+                err.println(\"Sending Reset\");\n+                switch (exchange.getRequestURI().getPath()) {\n+                    case \"\/fullResponse\/codeNoError\" -> testExchange.addResetToOutputQ(ResetFrame.NO_ERROR);\n+                    case \"\/fullResponse\/codeError\" -> testExchange.addResetToOutputQ(ResetFrame.PROTOCOL_ERROR);\n+                    default -> throw new TestException(\"Invalid Request Path\");\n+                }\n+            } else {\n+                throw new TestException(\"Wrong Exchange type used\");\n+            }\n+        }\n+    }\n+\n+    static class ExpectContinueResetTestExchangeImpl extends Http2TestExchangeImpl {\n+\n+        public ExpectContinueResetTestExchangeImpl(int streamid, String method, HttpHeaders reqheaders, HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is, SSLSession sslSession, BodyOutputStream os, Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+        }\n+\n+        public void addResetToOutputQ(int code) throws IOException {\n+            ResetFrame rf = new ResetFrame(streamid, code);\n+            this.conn.addToOutputQ(rf);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ExpectContinueResetTest.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection.ResponseHeaders;\n@@ -148,2 +149,2 @@\n-        Http2TestServerConnection.ResponseHeaders response\n-                = new Http2TestServerConnection.ResponseHeaders(headers);\n+        ResponseHeaders response\n+                = new ResponseHeaders(headers);\n@@ -156,1 +157,1 @@\n-            conn.outputQ.put(response);\n+            sendResponseHeaders(response);\n@@ -164,1 +165,1 @@\n-            conn.outputQ.put(response);\n+            sendResponseHeaders(response);\n@@ -170,0 +171,4 @@\n+    public void sendResponseHeaders(ResponseHeaders response) throws IOException {\n+        conn.outputQ.put(response);\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1244,1 +1244,1 @@\n-    static class ResponseHeaders extends Http2Frame {\n+    public static class ResponseHeaders extends Http2Frame {\n@@ -1247,1 +1247,1 @@\n-        ResponseHeaders(HttpHeaders headers) {\n+        public ResponseHeaders(HttpHeaders headers) {\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}