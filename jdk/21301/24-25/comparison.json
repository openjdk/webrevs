{"files":[{"patch":"@@ -3482,2 +3482,6 @@\n-        return scale <= 0 || signum() == 0\n-                || stripZerosToMatchScale(intVal, intCompact, scale, 0L).scale == 0;\n+        if (scale <= 0 || signum() == 0)\n+            return true;\n+\n+        \/\/ Get an upper bound of precision() without using big powers of 10 (see bigDigitLength())\n+        int digitLen = intVal == null ? precision() : (digitLengthLower(intVal) + 1);\n+        return digitLen > scale && stripZerosToMatchScale(intVal, intCompact, scale, 0L).scale == 0;\n@@ -4623,2 +4627,2 @@\n-        int r = (int)((((long)b.bitLength() + 1) * 646456993) >>> 31);\n-        return b.compareMagnitude(bigTenToThe(r)) < 0? r : r+1;\n+        int r = digitLengthLower(b);\n+        return b.compareMagnitude(bigTenToThe(r)) < 0 ? r : r + 1;\n@@ -4627,0 +4631,6 @@\n+    \/**\n+     * @return an integer {@code r} such that {@code 10^(r-1) <= b < 10^(r+1)}.\n+     *\/\n+    private int digitLengthLower(BigInteger b) {\n+        return (int) (((b.bitLength() + 1L) * 646456993L) >>> 31);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"}]}