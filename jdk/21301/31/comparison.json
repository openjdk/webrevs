{"files":[{"patch":"@@ -2148,50 +2148,7 @@\n-        int signum = signum();\n-        if (signum == 1) {\n-            \/*\n-             * The following code draws on the algorithm presented in\n-             * \"Properly Rounded Variable Precision Square Root,\" Hull and\n-             * Abrham, ACM Transactions on Mathematical Software, Vol 11,\n-             * No. 3, September 1985, Pages 229-237.\n-             *\n-             * The BigDecimal computational model differs from the one\n-             * presented in the paper in several ways: first BigDecimal\n-             * numbers aren't necessarily normalized, second many more\n-             * rounding modes are supported, including UNNECESSARY, and\n-             * exact results can be requested.\n-             *\n-             * The main steps of the algorithm below are as follows,\n-             * first argument reduce the value to the numerical range\n-             * [1, 10) using the following relations:\n-             *\n-             * x = y * 10 ^ exp\n-             * sqrt(x) = sqrt(y) * 10^(exp \/ 2) if exp is even\n-             * sqrt(x) = sqrt(y\/10) * 10 ^((exp+1)\/2) is exp is odd\n-             *\n-             * Then use Newton's iteration on the reduced value to compute\n-             * the numerical digits of the desired result.\n-             *\n-             * Finally, scale back to the desired exponent range and\n-             * perform any adjustment to get the preferred scale in the\n-             * representation.\n-             *\/\n-\n-            \/\/ The code below favors relative simplicity over checking\n-            \/\/ for special cases that could run faster.\n-\n-            int preferredScale = this.scale()\/2;\n-            BigDecimal zeroWithFinalPreferredScale = valueOf(0L, preferredScale);\n-\n-            \/\/ First phase of numerical normalization, strip trailing\n-            \/\/ zeros and check for even powers of 10.\n-            BigDecimal stripped = this.stripTrailingZeros();\n-            int strippedScale = stripped.scale();\n-\n-            \/\/ Numerically sqrt(10^2N) = 10^N\n-            if (stripped.isPowerOfTen() &&\n-                strippedScale % 2 == 0) {\n-                BigDecimal result = valueOf(1L, strippedScale\/2);\n-                if (result.scale() != preferredScale) {\n-                    \/\/ Adjust to requested precision and preferred\n-                    \/\/ scale as appropriate.\n-                    result = result.add(zeroWithFinalPreferredScale, mc);\n-                }\n+        final int signum = signum();\n+        if (signum != 1) {\n+            switch (signum) {\n+            case -1 -> throw new ArithmeticException(\"Attempted square root of negative BigDecimal\");\n+            case 0 -> {\n+                BigDecimal result = valueOf(0L, scale\/2);\n+                assert squareRootResultAssertions(result, mc);\n@@ -2200,0 +2157,40 @@\n+            default -> throw new AssertionError(\"Bad value from signum\");\n+            }\n+        }\n+        \/*\n+         * The main steps of the algorithm below are as follows,\n+         * first argument reduce the value to an integer\n+         * using the following relations:\n+         *\n+         * x = y * 10 ^ exp\n+         * sqrt(x) = sqrt(y) * 10^(exp \/ 2) if exp is even\n+         * sqrt(x) = sqrt(y*10) * 10^((exp-1)\/2) is exp is odd\n+         *\n+         * Then use BigInteger.sqrt() on the reduced value to compute\n+         * the numerical digits of the desired result.\n+         *\n+         * Finally, scale back to the desired exponent range and\n+         * perform any adjustment to get the preferred scale in the\n+         * representation.\n+         *\/\n+\n+        \/\/ The code below favors relative simplicity over checking\n+        \/\/ for special cases that could run faster.\n+        final int preferredScale = this.scale\/2;\n+\n+        BigDecimal result;\n+        if (mc.roundingMode == RoundingMode.UNNECESSARY || mc.precision == 0) { \/\/ Exact result requested\n+            \/\/ To avoid trailing zeros in the result, strip trailing zeros.\n+            final BigDecimal stripped = this.stripTrailingZeros();\n+            final int strippedScale = stripped.scale;\n+\n+            if ((strippedScale & 1) != 0) \/\/ 10*stripped.unscaledValue() can't be an exact square\n+                throw new ArithmeticException(\"Computed square root not exact.\");\n+\n+            \/\/ Check for even powers of 10. Numerically sqrt(10^2N) = 10^N\n+            if (stripped.isPowerOfTen()) {\n+                result = valueOf(1L, strippedScale >> 1);\n+                \/\/ Adjust to requested precision and preferred\n+                \/\/ scale as appropriate.\n+                return result.adjustToPreferredScale(preferredScale, mc.precision);\n+            }\n@@ -2206,127 +2203,3 @@\n-            \/\/ precision for the cohort of the numerical value. To\n-            \/\/ allow binary floating-point hardware to be used to get\n-            \/\/ approximately a 15 digit approximation to the square\n-            \/\/ root, it is helpful to instead normalize this so that\n-            \/\/ the significand portion is to right of the decimal\n-            \/\/ point by roughly (scale() - precision() + 1).\n-\n-            \/\/ Now the precision \/ scale adjustment\n-            int scaleAdjust = 0;\n-            int scale = stripped.scale() - stripped.precision() + 1;\n-            if (scale % 2 == 0) {\n-                scaleAdjust = scale;\n-            } else {\n-                scaleAdjust = scale - 1;\n-            }\n-\n-            BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);\n-\n-            assert  \/\/ Verify 0.1 <= working < 10\n-                ONE_TENTH.compareTo(working) <= 0 && working.compareTo(TEN) < 0;\n-\n-            \/\/ Use good ole' Math.sqrt to get the initial guess for\n-            \/\/ the Newton iteration, good to at least 15 decimal\n-            \/\/ digits. This approach does incur the cost of a\n-            \/\/\n-            \/\/ BigDecimal -> double -> BigDecimal\n-            \/\/\n-            \/\/ conversion cycle, but it avoids the need for several\n-            \/\/ Newton iterations in BigDecimal arithmetic to get the\n-            \/\/ working answer to 15 digits of precision. If many fewer\n-            \/\/ than 15 digits were needed, it might be faster to do\n-            \/\/ the loop entirely in BigDecimal arithmetic.\n-            \/\/\n-            \/\/ (A double value might have as many as 17 decimal\n-            \/\/ digits of precision; it depends on the relative density\n-            \/\/ of binary and decimal numbers at different regions of\n-            \/\/ the number line.)\n-            \/\/\n-            \/\/ (It would be possible to check for certain special\n-            \/\/ cases to avoid doing any Newton iterations. For\n-            \/\/ example, if the BigDecimal -> double conversion was\n-            \/\/ known to be exact and the rounding mode had a\n-            \/\/ low-enough precision, the post-Newton rounding logic\n-            \/\/ could be applied directly.)\n-\n-            BigDecimal guess = new BigDecimal(Math.sqrt(working.doubleValue()));\n-            int guessPrecision = 15;\n-            int originalPrecision = mc.getPrecision();\n-            int targetPrecision;\n-\n-            \/\/ If an exact value is requested, it must only need about\n-            \/\/ half of the input digits to represent since multiplying\n-            \/\/ an N digit number by itself yield a 2N-1 digit or 2N\n-            \/\/ digit result.\n-            if (originalPrecision == 0) {\n-                targetPrecision = stripped.precision()\/2 + 1;\n-            } else {\n-                \/*\n-                 * To avoid the need for post-Newton fix-up logic, in\n-                 * the case of half-way rounding modes, double the\n-                 * target precision so that the \"2p + 2\" property can\n-                 * be relied on to accomplish the final rounding.\n-                 *\/\n-                switch (mc.getRoundingMode()) {\n-                case HALF_UP:\n-                case HALF_DOWN:\n-                case HALF_EVEN:\n-                    targetPrecision = 2 * originalPrecision;\n-                    if (targetPrecision < 0) \/\/ Overflow\n-                        targetPrecision = Integer.MAX_VALUE - 2;\n-                    break;\n-\n-                default:\n-                    targetPrecision = originalPrecision;\n-                    break;\n-                }\n-            }\n-\n-            \/\/ When setting the precision to use inside the Newton\n-            \/\/ iteration loop, take care to avoid the case where the\n-            \/\/ precision of the input exceeds the requested precision\n-            \/\/ and rounding the input value too soon.\n-            BigDecimal approx = guess;\n-            int workingPrecision = working.precision();\n-            do {\n-                int tmpPrecision = Math.max(Math.max(guessPrecision, targetPrecision + 2),\n-                                           workingPrecision);\n-                MathContext mcTmp = new MathContext(tmpPrecision, RoundingMode.HALF_EVEN);\n-                \/\/ approx = 0.5 * (approx + fraction \/ approx)\n-                approx = ONE_HALF.multiply(approx.add(working.divide(approx, mcTmp), mcTmp));\n-                guessPrecision *= 2;\n-            } while (guessPrecision < targetPrecision + 2);\n-\n-            BigDecimal result;\n-            RoundingMode targetRm = mc.getRoundingMode();\n-            if (targetRm == RoundingMode.UNNECESSARY || originalPrecision == 0) {\n-                RoundingMode tmpRm =\n-                    (targetRm == RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;\n-                MathContext mcTmp = new MathContext(targetPrecision, tmpRm);\n-                result = approx.scaleByPowerOfTen(-scaleAdjust\/2).round(mcTmp);\n-\n-                \/\/ If result*result != this numerically, the square\n-                \/\/ root isn't exact\n-                if (this.subtract(result.square()).compareTo(ZERO) != 0) {\n-                    throw new ArithmeticException(\"Computed square root not exact.\");\n-                }\n-            } else {\n-                result = approx.scaleByPowerOfTen(-scaleAdjust\/2).round(mc);\n-\n-                switch (targetRm) {\n-                case DOWN:\n-                case FLOOR:\n-                    \/\/ Check if too big\n-                    if (result.square().compareTo(this) > 0) {\n-                        BigDecimal ulp = result.ulp();\n-                        \/\/ Adjust increment down in case of 1.0 = 10^0\n-                        \/\/ since the next smaller number is only 1\/10\n-                        \/\/ as far way as the next larger at exponent\n-                        \/\/ boundaries. Test approx and *not* result to\n-                        \/\/ avoid having to detect an arbitrary power\n-                        \/\/ of ten.\n-                        if (approx.compareTo(ONE) == 0) {\n-                            ulp = ulp.multiply(ONE_TENTH);\n-                        }\n-                        result = result.subtract(ulp);\n-                    }\n-                    break;\n+            \/\/ precision for the cohort of the numerical value and the scale is even.\n+            BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n+            result = new BigDecimal(sqrtRem[0], strippedScale >> 1);\n@@ -2334,23 +2207,4 @@\n-                case UP:\n-                case CEILING:\n-                    \/\/ Check if too small\n-                    if (result.square().compareTo(this) < 0) {\n-                        result = result.add(result.ulp());\n-                    }\n-                    break;\n-\n-                default:\n-                    \/\/ No additional work, rely on \"2p + 2\" property\n-                    \/\/ for correct rounding. Alternatively, could\n-                    \/\/ instead run the Newton iteration to around p\n-                    \/\/ digits and then do tests and fix-ups on the\n-                    \/\/ rounded value. One possible set of tests and\n-                    \/\/ fix-ups is given in the Hull and Abrham paper;\n-                    \/\/ however, additional half-way cases can occur\n-                    \/\/ for BigDecimal given the more varied\n-                    \/\/ combinations of input and output precisions\n-                    \/\/ supported.\n-                    break;\n-                }\n-\n-            }\n+            \/\/ If result*result != this numerically or requires too high precision,\n+            \/\/ the square root isn't exact\n+            if (sqrtRem[1].signum != 0 || mc.precision != 0 && result.precision() > mc.precision)\n+                throw new ArithmeticException(\"Computed square root not exact.\");\n@@ -2361,11 +2215,46 @@\n-            if (result.scale() != preferredScale) {\n-                \/\/ The preferred scale of an add is\n-                \/\/ max(addend.scale(), augend.scale()). Therefore, if\n-                \/\/ the scale of the result is first minimized using\n-                \/\/ stripTrailingZeros(), adding a zero of the\n-                \/\/ preferred scale rounding to the correct precision\n-                \/\/ will perform the proper scale vs precision\n-                \/\/ tradeoffs.\n-                result = result.stripTrailingZeros().\n-                    add(zeroWithFinalPreferredScale,\n-                        new MathContext(originalPrecision, RoundingMode.UNNECESSARY));\n+            \/\/ Adjust to requested precision and preferred\n+            \/\/ scale as appropriate.\n+            return result.adjustToPreferredScale(preferredScale, mc.precision);\n+        }\n+        \/\/ To allow BigInteger.sqrt() to be used to get the square\n+        \/\/ root, it is necessary to normalize the input so that\n+        \/\/ its integer part is sufficient to get the square root\n+        \/\/ with the desired precision.\n+\n+        final boolean halfWay = isHalfWay(mc.roundingMode);\n+        \/\/ To obtain a square root with N digits,\n+        \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n+        final long minWorkingPrec = ((mc.precision + (halfWay ? 1L : 0L)) << 1) - 1L;\n+        \/\/ normScale is the number of digits to take from the fraction of the input\n+        long normScale = minWorkingPrec - this.precision() + this.scale;\n+        normScale += normScale & 1L; \/\/ the scale for normalizing must be even\n+\n+        final long workingScale = this.scale - normScale;\n+        if (workingScale != (int) workingScale)\n+            throw new ArithmeticException(\"Overflow\");\n+\n+        BigDecimal working = new BigDecimal(this.intVal, this.intCompact, (int) workingScale, this.precision);\n+        BigInteger workingInt = working.toBigInteger();\n+\n+        BigInteger sqrt;\n+        long resultScale = normScale >> 1;\n+        \/\/ Round sqrt with the specified settings\n+        if (halfWay) { \/\/ half-way rounding\n+            BigInteger workingSqrt = workingInt.sqrt();\n+            \/\/ remove the one-tenth digit\n+            BigInteger[] quotRem10 = workingSqrt.divideAndRemainder(BigInteger.TEN);\n+            sqrt = quotRem10[0];\n+            resultScale--;\n+\n+            boolean increment = false;\n+            int digit = quotRem10[1].intValue();\n+            if (digit > 5) {\n+                increment = true;\n+            } else if (digit == 5) {\n+                if (mc.roundingMode == RoundingMode.HALF_UP\n+                        || mc.roundingMode == RoundingMode.HALF_EVEN && sqrt.testBit(0)\n+                        \/\/ Check if remainder is non-zero\n+                        || !workingInt.equals(workingSqrt.multiply(workingSqrt))\n+                        || !working.isInteger()) {\n+                    increment = true;\n+                }\n@@ -2373,1 +2262,3 @@\n-            return result;\n+\n+            if (increment)\n+                sqrt = sqrt.add(1L);\n@@ -2375,9 +2266,10 @@\n-            BigDecimal result = null;\n-            switch (signum) {\n-            case -1:\n-                throw new ArithmeticException(\"Attempted square root \" +\n-                                              \"of negative BigDecimal\");\n-            case 0:\n-                result = valueOf(0L, scale()\/2);\n-                assert squareRootResultAssertions(result, mc);\n-                return result;\n+            switch (mc.roundingMode) {\n+            case DOWN, FLOOR -> sqrt = workingInt.sqrt(); \/\/ No need to round\n+\n+            case UP, CEILING -> {\n+                BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n+                sqrt = sqrtRem[0];\n+                \/\/ Check if remainder is non-zero\n+                if (sqrtRem[1].signum != 0 || !working.isInteger())\n+                    sqrt = sqrt.add(1L);\n+            }\n@@ -2385,2 +2277,1 @@\n-            default:\n-                throw new AssertionError(\"Bad value from signum\");\n+            default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n@@ -2389,0 +2280,39 @@\n+\n+        result = new BigDecimal(sqrt, checkScale(sqrt, resultScale), mc); \/\/ mc ensures no increase of precision\n+        \/\/ Test numerical properties at full precision before any\n+        \/\/ scale adjustments.\n+        assert squareRootResultAssertions(result, mc);\n+        \/\/ Adjust to requested precision and preferred\n+        \/\/ scale as appropriate.\n+        if (result.scale > preferredScale) \/\/ else can't increase the result's precision to fit the preferred scale\n+            result = stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Assumes {@code (precision() <= maxPrecision || maxPrecision == 0) && this != 0}.\n+     * @param preferredScale the scale to reach\n+     * @param maxPrecision the largest precision the result can have.\n+     *        {@code maxPrecision == 0} means that the result can have arbitrary precision.\n+     * @return a BigDecimal numerically equivalent to {@code this}, whose precision\n+     *         does not exceed {@code maxPrecision} and whose scale is the closest\n+     *         to {@code preferredScale}.\n+     *\/\n+    private BigDecimal adjustToPreferredScale(int preferredScale, int maxPrecision) {\n+        BigDecimal result = this;\n+        if (result.scale > preferredScale) {\n+            result = stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);\n+        } else if (result.scale < preferredScale) {\n+            int maxScale = maxPrecision == 0 ?\n+                preferredScale : (int) Math.min(preferredScale, result.scale + (long) (maxPrecision - result.precision()));\n+            result = result.setScale(maxScale);\n+        }\n+        return result;\n+    }\n+\n+    private static boolean isHalfWay(RoundingMode m) {\n+        return switch (m) {\n+            case HALF_DOWN, HALF_UP, HALF_EVEN -> true;\n+            case FLOOR, CEILING, DOWN, UP, UNNECESSARY -> false;\n+        };\n@@ -3556,0 +3486,13 @@\n+    \/**\n+     * @return {@code true} if and only if {@code this == this.toBigInteger()}\n+     *\/\n+    boolean isInteger() {\n+        if (scale <= 0 || signum() == 0)\n+            return true;\n+\n+        \/\/ Get an upper bound of precision() without using big powers of 10 (see bigDigitLength())\n+        int digitLen = precision != 0 ? precision\n+            : (intCompact != INFLATED ? precision() : (digitLengthLower(unscaledValue()) + 1));\n+        return digitLen > scale && stripZerosToMatchScale(intVal, intCompact, scale, 0L).scale == 0;\n+    }\n+\n@@ -4605,2 +4548,9 @@\n-        int r = (int)((((long)b.bitLength() + 1) * 646456993) >>> 31);\n-        return b.compareMagnitude(bigTenToThe(r)) < 0? r : r+1;\n+        int r = digitLengthLower(b);\n+        return b.compareMagnitude(bigTenToThe(r)) < 0 ? r : r + 1;\n+    }\n+\n+    \/**\n+     * @return an integer {@code r} such that {@code 10^(r-1) <= abs(b) < 10^(r+1)}.\n+     *\/\n+    private static int digitLengthLower(BigInteger b) {\n+        return (int) (((b.abs().bitLength() + 1L) * 646456993L) >>> 31);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":175,"deletions":225,"binary":false,"changes":400,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4851777 8233452\n+ * @bug 4851777 8233452 8341402\n@@ -63,0 +63,2 @@\n+        failures += exactResultTests();\n+        failures += scaleOverflowTest();\n@@ -174,0 +176,87 @@\n+    private static int exactResultTests() {\n+        int failures = 0;\n+        MathContext unnecessary = new MathContext(1, RoundingMode.UNNECESSARY);\n+        MathContext arbitrary = new MathContext(0, RoundingMode.CEILING);\n+\n+        BigDecimal[] errCases = {\n+                \/\/ (strippedScale & 1) != 0\n+                BigDecimal.TEN,\n+                \/\/ (strippedScale & 1) == 0 && !stripped.isPowerOfTen() && sqrtRem[1].signum != 0\n+                BigDecimal.TWO,\n+        };\n+\n+        for (BigDecimal input : errCases) {\n+            BigDecimal result;\n+            \/\/ mc.roundingMode == RoundingMode.UNNECESSARY\n+            try {\n+                result = input.sqrt(unnecessary);\n+                System.err.println(\"Unexpected sqrt with UNNECESSARY RoundingMode: (\" + input + \").sqrt() = \" + result);\n+                failures += 1;\n+            } catch (ArithmeticException e) {\n+                \/\/ Expected\n+            }\n+\n+            \/\/ mc.roundingMode != RoundingMode.UNNECESSARY && mc.precision == 0\n+            try {\n+                result = input.sqrt(arbitrary);\n+                System.err.println(\"Unexpected sqrt with mc.precision == 0: (\" + input + \").sqrt() = \" + result);\n+                failures += 1;\n+            } catch (ArithmeticException e) {\n+                \/\/ Expected\n+            }\n+        }\n+\n+        \/\/ (strippedScale & 1) == 0\n+\n+        \/\/ !stripped.isPowerOfTen() && sqrtRem[1].signum == 0 && (mc.precision != 0 && result.precision() > mc.precision)\n+        try {\n+            BigDecimal input = BigDecimal.valueOf(121);\n+            BigDecimal result = input.sqrt(unnecessary);\n+            System.err.println(\"Unexpected sqrt with result.precision() > mc.precision: (\"\n+                    + input + \").sqrt() = \" + result);\n+            failures += 1;\n+        } catch (ArithmeticException e) {\n+            \/\/ Expected\n+        }\n+\n+        BigDecimal four = BigDecimal.valueOf(4);\n+        Object[][] cases = {\n+                \/\/ stripped.isPowerOfTen() && mc.roundingMode == RoundingMode.UNNECESSARY\n+                { BigDecimal.ONE, unnecessary, BigDecimal.ONE },\n+                \/\/ stripped.isPowerOfTen() && mc.roundingMode != RoundingMode.UNNECESSARY && mc.precision == 0\n+                { BigDecimal.ONE, arbitrary, BigDecimal.ONE },\n+                \/\/ !stripped.isPowerOfTen() && mc.roundingMode == RoundingMode.UNNECESSARY\n+                \/\/ && sqrtRem[1].signum == 0 && mc.precision == 0\n+                { four, new MathContext(0, RoundingMode.UNNECESSARY), BigDecimal.TWO },\n+                \/\/ !stripped.isPowerOfTen() && mc.roundingMode != RoundingMode.UNNECESSARY\n+                \/\/ && sqrtRem[1].signum == 0 && mc.precision == 0\n+                { four, arbitrary, BigDecimal.TWO },\n+                \/\/ !stripped.isPowerOfTen() && sqrtRem[1].signum == 0\n+                \/\/ && (mc.precision != 0 && result.precision() <= mc.precision)\n+                { four, unnecessary, BigDecimal.TWO },\n+        };\n+\n+        for (Object[] testCase : cases) {\n+            BigDecimal expected = (BigDecimal) testCase[2];\n+            BigDecimal result = ((BigDecimal) testCase[0]).sqrt((MathContext) testCase[1]);\n+            failures += compare(expected, result, true, \"Exact results\");\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int scaleOverflowTest() {\n+        int failures = 0;\n+\n+        try {\n+            BigDecimal.valueOf(1, -1).sqrt(new MathContext((1 << 30) + 1, RoundingMode.UP));\n+            System.err.println(\"ArithmeticException expected: possible overflow undetected \"\n+                    + \"or the range of supported values for the algorithm has extended.\");\n+            failures += 1;\n+        } catch (ArithmeticException e) {\n+            \/\/ Expected\n+        }\n+\n+        return failures;\n+    }\n+\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SquareRootTests.java","additions":91,"deletions":2,"binary":false,"changes":93,"status":"modified"}]}