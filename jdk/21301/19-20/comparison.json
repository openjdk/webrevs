{"files":[{"patch":"@@ -2177,2 +2177,1 @@\n-                    result = result.adjustToPreferredScale(preferredScale, mc.precision);\n-                    return result;\n+                    return result.adjustToPreferredScale(preferredScale, mc.precision);\n@@ -2200,35 +2199,42 @@\n-                result = result.adjustToPreferredScale(preferredScale, mc.precision);\n-            } else {\n-                \/\/ To allow BigInteger.sqrt() to be used to get the square\n-                \/\/ root, it is necessary to normalize the input so that\n-                \/\/ its integer part is sufficient to get the square root\n-                \/\/ with the desired precision.\n-\n-                final boolean halfWay = isHalfWay(mc.roundingMode);\n-                \/\/ To obtain a square root with N digits,\n-                \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n-                final long minWorkingPrec = ((mc.precision + (halfWay ? 1L : 0L)) << 1) - 1L;\n-                \/\/ normScale is the number of digits to take from the fraction of the input\n-                long normScale = minWorkingPrec - this.precision() + this.scale;\n-                normScale += normScale & 1L; \/\/ the scale for normalizing must be even\n-\n-                final long workingScale = this.scale - normScale;\n-                if (workingScale != (int) workingScale)\n-                    throw new ArithmeticException(\"Overflow\");\n-\n-                BigDecimal working = new BigDecimal(this.intVal, this.intCompact, (int) workingScale, this.precision);\n-                BigInteger workingInt = working.toBigInteger();\n-\n-                BigInteger sqrt;\n-                long resultScale = normScale >> 1;\n-                \/\/ Round sqrt with the specified settings\n-                if (halfWay) { \/\/ half-way rounding\n-                    BigInteger workingSqrt = workingInt.sqrt();\n-                    \/\/ remove the one-tenth digit\n-                    BigInteger[] quotRem10 = workingSqrt.divideAndRemainder(BigInteger.TEN);\n-                    sqrt = quotRem10[0];\n-                    resultScale--;\n-\n-                    boolean increment = false;\n-                    int digit = quotRem10[1].intValue();\n-                    if (digit > 5) {\n+                return result.adjustToPreferredScale(preferredScale, mc.precision);\n+            }\n+            \/\/ To allow BigInteger.sqrt() to be used to get the square\n+            \/\/ root, it is necessary to normalize the input so that\n+            \/\/ its integer part is sufficient to get the square root\n+            \/\/ with the desired precision.\n+\n+            final boolean halfWay = isHalfWay(mc.roundingMode);\n+            \/\/ To obtain a square root with N digits,\n+            \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n+            final long minWorkingPrec = ((mc.precision + (halfWay ? 1L : 0L)) << 1) - 1L;\n+            \/\/ normScale is the number of digits to take from the fraction of the input\n+            long normScale = minWorkingPrec - this.precision() + this.scale;\n+            normScale += normScale & 1L; \/\/ the scale for normalizing must be even\n+\n+            final long workingScale = this.scale - normScale;\n+            if (workingScale != (int) workingScale)\n+                throw new ArithmeticException(\"Overflow\");\n+\n+            BigDecimal working = new BigDecimal(this.intVal, this.intCompact, (int) workingScale, this.precision);\n+            BigInteger workingInt = working.toBigInteger();\n+\n+            BigInteger sqrt;\n+            long resultScale = normScale >> 1;\n+            \/\/ Round sqrt with the specified settings\n+            if (halfWay) { \/\/ half-way rounding\n+                BigInteger workingSqrt = workingInt.sqrt();\n+                \/\/ remove the one-tenth digit\n+                BigInteger[] quotRem10 = workingSqrt.divideAndRemainder(BigInteger.TEN);\n+                sqrt = quotRem10[0];\n+                resultScale--;\n+\n+                boolean increment = false;\n+                int digit = quotRem10[1].intValue();\n+                if (digit > 5) {\n+                    increment = true;\n+                } else if (digit == 5) {\n+                    if (mc.roundingMode == RoundingMode.HALF_UP\n+                            || mc.roundingMode == RoundingMode.HALF_EVEN && sqrt.testBit(0)\n+                            \/\/ Check if remainder is non-zero\n+                            || !workingInt.equals(workingSqrt.multiply(workingSqrt))\n+                            || working.compareTo(new BigDecimal(workingInt)) != 0) {\n@@ -2236,8 +2242,0 @@\n-                    } else if (digit == 5) {\n-                        if (mc.roundingMode == RoundingMode.HALF_UP\n-                                || mc.roundingMode == RoundingMode.HALF_EVEN && sqrt.testBit(0)\n-                                \/\/ Check if remainder is non-zero\n-                                || !workingInt.equals(workingSqrt.multiply(workingSqrt))\n-                                || working.compareTo(new BigDecimal(workingInt)) != 0) {\n-                            increment = true;\n-                        }\n@@ -2245,0 +2243,1 @@\n+                }\n@@ -2246,1 +2245,11 @@\n-                    if (increment)\n+                if (increment)\n+                    sqrt = sqrt.add(1L);\n+            } else {\n+                switch (mc.roundingMode) {\n+                case DOWN, FLOOR -> sqrt = workingInt.sqrt(); \/\/ No need to round\n+\n+                case UP, CEILING -> {\n+                    BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n+                    sqrt = sqrtRem[0];\n+                    \/\/ Check if remainder is non-zero\n+                    if (sqrtRem[1].signum != 0 || working.compareTo(new BigDecimal(workingInt)) != 0)\n@@ -2248,14 +2257,0 @@\n-                } else {\n-                    switch (mc.roundingMode) {\n-                    case DOWN, FLOOR -> sqrt = workingInt.sqrt(); \/\/ No need to round\n-\n-                    case UP, CEILING -> {\n-                        BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n-                        sqrt = sqrtRem[0];\n-                        \/\/ Check if remainder is non-zero\n-                        if (sqrtRem[1].signum != 0 || working.compareTo(new BigDecimal(workingInt)) != 0)\n-                            sqrt = sqrt.add(1L);\n-                    }\n-\n-                    default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n-                    }\n@@ -2264,8 +2259,2 @@\n-                result = new BigDecimal(sqrt, checkScale(sqrt, resultScale), mc); \/\/ mc ensures no increase of precision\n-                \/\/ Test numerical properties at full precision before any\n-                \/\/ scale adjustments.\n-                assert squareRootResultAssertions(result, mc);\n-                \/\/ Adjust to requested precision and preferred\n-                \/\/ scale as appropriate.\n-                if (result.scale > preferredScale) \/\/ else can't increase the result's precision to fit the preferred scale\n-                    result = stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);\n+                default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n+                }\n@@ -2273,0 +2262,10 @@\n+\n+            result = new BigDecimal(sqrt, checkScale(sqrt, resultScale), mc); \/\/ mc ensures no increase of precision\n+            \/\/ Test numerical properties at full precision before any\n+            \/\/ scale adjustments.\n+            assert squareRootResultAssertions(result, mc);\n+            \/\/ Adjust to requested precision and preferred\n+            \/\/ scale as appropriate.\n+            if (result.scale > preferredScale) \/\/ else can't increase the result's precision to fit the preferred scale\n+                result = stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);\n+\n@@ -2274,10 +2273,1 @@\n-        } else {\n-            BigDecimal result = null;\n-            switch (signum) {\n-            case -1:\n-                throw new ArithmeticException(\"Attempted square root \" +\n-                                              \"of negative BigDecimal\");\n-            case 0:\n-                result = valueOf(0L, scale\/2);\n-                assert squareRootResultAssertions(result, mc);\n-                return result;\n+        }\n@@ -2285,3 +2275,8 @@\n-            default:\n-                throw new AssertionError(\"Bad value from signum\");\n-            }\n+        switch (signum) {\n+        case -1 -> throw new ArithmeticException(\"Attempted square root of negative BigDecimal\");\n+        case 0 -> {\n+            BigDecimal result = valueOf(0L, scale\/2);\n+            assert squareRootResultAssertions(result, mc);\n+            return result;\n+        }\n+        default -> throw new AssertionError(\"Bad value from signum\");\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":76,"deletions":81,"binary":false,"changes":157,"status":"modified"}]}