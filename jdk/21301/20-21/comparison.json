{"files":[{"patch":"@@ -2140,18 +2140,28 @@\n-        int signum = signum();\n-        if (signum == 1) {\n-            \/*\n-             * The main steps of the algorithm below are as follows,\n-             * first argument reduce the value to an integer\n-             * using the following relations:\n-             *\n-             * x = y * 10 ^ exp\n-             * sqrt(x) = sqrt(y) * 10^(exp \/ 2) if exp is even\n-             * sqrt(x) = sqrt(y*10) * 10^((exp-1)\/2) is exp is odd\n-             *\n-             * Then use BigInteger.sqrt() on the reduced value to compute\n-             * the numerical digits of the desired result.\n-             *\n-             * Finally, scale back to the desired exponent range and\n-             * perform any adjustment to get the preferred scale in the\n-             * representation.\n-             *\/\n+        final int signum = signum();\n+        if (signum != 1) {\n+            switch (signum) {\n+            case -1 -> throw new ArithmeticException(\"Attempted square root of negative BigDecimal\");\n+            case 0 -> {\n+                BigDecimal result = valueOf(0L, scale\/2);\n+                assert squareRootResultAssertions(result, mc);\n+                return result;\n+            }\n+            default -> throw new AssertionError(\"Bad value from signum\");\n+            }\n+        }\n+        \/*\n+         * The main steps of the algorithm below are as follows,\n+         * first argument reduce the value to an integer\n+         * using the following relations:\n+         *\n+         * x = y * 10 ^ exp\n+         * sqrt(x) = sqrt(y) * 10^(exp \/ 2) if exp is even\n+         * sqrt(x) = sqrt(y*10) * 10^((exp-1)\/2) is exp is odd\n+         *\n+         * Then use BigInteger.sqrt() on the reduced value to compute\n+         * the numerical digits of the desired result.\n+         *\n+         * Finally, scale back to the desired exponent range and\n+         * perform any adjustment to get the preferred scale in the\n+         * representation.\n+         *\/\n@@ -2159,20 +2169,3 @@\n-            \/\/ The code below favors relative simplicity over checking\n-            \/\/ for special cases that could run faster.\n-            final int preferredScale = this.scale\/2;\n-\n-            BigDecimal result;\n-            if (mc.roundingMode == RoundingMode.UNNECESSARY || mc.precision == 0) { \/\/ Exact result requested\n-                \/\/ To avoid trailing zeros in the result, strip trailing zeros.\n-                final BigDecimal stripped = this.stripTrailingZeros();\n-                final int strippedScale = stripped.scale;\n-\n-                if ((strippedScale & 1) != 0) \/\/ 10*stripped.unscaledValue() can't be an exact square\n-                    throw new ArithmeticException(\"Computed square root not exact.\");\n-\n-                \/\/ Check for even powers of 10. Numerically sqrt(10^2N) = 10^N\n-                if (stripped.isPowerOfTen()) {\n-                    result = valueOf(1L, strippedScale >> 1);\n-                    \/\/ Adjust to requested precision and preferred\n-                    \/\/ scale as appropriate.\n-                    return result.adjustToPreferredScale(preferredScale, mc.precision);\n-                }\n+        \/\/ The code below favors relative simplicity over checking\n+        \/\/ for special cases that could run faster.\n+        final int preferredScale = this.scale\/2;\n@@ -2180,17 +2173,12 @@\n-                \/\/ After stripTrailingZeros, the representation is normalized as\n-                \/\/\n-                \/\/ unscaledValue * 10^(-scale)\n-                \/\/\n-                \/\/ where unscaledValue is an integer with the minimum\n-                \/\/ precision for the cohort of the numerical value and the scale is even.\n-                BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n-                result = new BigDecimal(sqrtRem[0], strippedScale >> 1);\n-\n-                \/\/ If result*result != this numerically or requires too high precision,\n-                \/\/ the square root isn't exact\n-                if (sqrtRem[1].signum != 0 || mc.precision != 0 && result.precision() > mc.precision)\n-                    throw new ArithmeticException(\"Computed square root not exact.\");\n-\n-                \/\/ Test numerical properties at full precision before any\n-                \/\/ scale adjustments.\n-                assert squareRootResultAssertions(result, mc);\n+        BigDecimal result;\n+        if (mc.roundingMode == RoundingMode.UNNECESSARY || mc.precision == 0) { \/\/ Exact result requested\n+            \/\/ To avoid trailing zeros in the result, strip trailing zeros.\n+            final BigDecimal stripped = this.stripTrailingZeros();\n+            final int strippedScale = stripped.scale;\n+\n+            if ((strippedScale & 1) != 0) \/\/ 10*stripped.unscaledValue() can't be an exact square\n+                throw new ArithmeticException(\"Computed square root not exact.\");\n+\n+            \/\/ Check for even powers of 10. Numerically sqrt(10^2N) = 10^N\n+            if (stripped.isPowerOfTen()) {\n+                result = valueOf(1L, strippedScale >> 1);\n@@ -2201,43 +2189,0 @@\n-            \/\/ To allow BigInteger.sqrt() to be used to get the square\n-            \/\/ root, it is necessary to normalize the input so that\n-            \/\/ its integer part is sufficient to get the square root\n-            \/\/ with the desired precision.\n-\n-            final boolean halfWay = isHalfWay(mc.roundingMode);\n-            \/\/ To obtain a square root with N digits,\n-            \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n-            final long minWorkingPrec = ((mc.precision + (halfWay ? 1L : 0L)) << 1) - 1L;\n-            \/\/ normScale is the number of digits to take from the fraction of the input\n-            long normScale = minWorkingPrec - this.precision() + this.scale;\n-            normScale += normScale & 1L; \/\/ the scale for normalizing must be even\n-\n-            final long workingScale = this.scale - normScale;\n-            if (workingScale != (int) workingScale)\n-                throw new ArithmeticException(\"Overflow\");\n-\n-            BigDecimal working = new BigDecimal(this.intVal, this.intCompact, (int) workingScale, this.precision);\n-            BigInteger workingInt = working.toBigInteger();\n-\n-            BigInteger sqrt;\n-            long resultScale = normScale >> 1;\n-            \/\/ Round sqrt with the specified settings\n-            if (halfWay) { \/\/ half-way rounding\n-                BigInteger workingSqrt = workingInt.sqrt();\n-                \/\/ remove the one-tenth digit\n-                BigInteger[] quotRem10 = workingSqrt.divideAndRemainder(BigInteger.TEN);\n-                sqrt = quotRem10[0];\n-                resultScale--;\n-\n-                boolean increment = false;\n-                int digit = quotRem10[1].intValue();\n-                if (digit > 5) {\n-                    increment = true;\n-                } else if (digit == 5) {\n-                    if (mc.roundingMode == RoundingMode.HALF_UP\n-                            || mc.roundingMode == RoundingMode.HALF_EVEN && sqrt.testBit(0)\n-                            \/\/ Check if remainder is non-zero\n-                            || !workingInt.equals(workingSqrt.multiply(workingSqrt))\n-                            || working.compareTo(new BigDecimal(workingInt)) != 0) {\n-                        increment = true;\n-                    }\n-                }\n@@ -2245,13 +2190,8 @@\n-                if (increment)\n-                    sqrt = sqrt.add(1L);\n-            } else {\n-                switch (mc.roundingMode) {\n-                case DOWN, FLOOR -> sqrt = workingInt.sqrt(); \/\/ No need to round\n-\n-                case UP, CEILING -> {\n-                    BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n-                    sqrt = sqrtRem[0];\n-                    \/\/ Check if remainder is non-zero\n-                    if (sqrtRem[1].signum != 0 || working.compareTo(new BigDecimal(workingInt)) != 0)\n-                        sqrt = sqrt.add(1L);\n-                }\n+            \/\/ After stripTrailingZeros, the representation is normalized as\n+            \/\/\n+            \/\/ unscaledValue * 10^(-scale)\n+            \/\/\n+            \/\/ where unscaledValue is an integer with the minimum\n+            \/\/ precision for the cohort of the numerical value and the scale is even.\n+            BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n+            result = new BigDecimal(sqrtRem[0], strippedScale >> 1);\n@@ -2259,3 +2199,4 @@\n-                default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n-                }\n-            }\n+            \/\/ If result*result != this numerically or requires too high precision,\n+            \/\/ the square root isn't exact\n+            if (sqrtRem[1].signum != 0 || mc.precision != 0 && result.precision() > mc.precision)\n+                throw new ArithmeticException(\"Computed square root not exact.\");\n@@ -2263,1 +2204,0 @@\n-            result = new BigDecimal(sqrt, checkScale(sqrt, resultScale), mc); \/\/ mc ensures no increase of precision\n@@ -2269,4 +2209,1 @@\n-            if (result.scale > preferredScale) \/\/ else can't increase the result's precision to fit the preferred scale\n-                result = stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);\n-\n-            return result;\n+            return result.adjustToPreferredScale(preferredScale, mc.precision);\n@@ -2274,0 +2211,43 @@\n+        \/\/ To allow BigInteger.sqrt() to be used to get the square\n+        \/\/ root, it is necessary to normalize the input so that\n+        \/\/ its integer part is sufficient to get the square root\n+        \/\/ with the desired precision.\n+\n+        final boolean halfWay = isHalfWay(mc.roundingMode);\n+        \/\/ To obtain a square root with N digits,\n+        \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n+        final long minWorkingPrec = ((mc.precision + (halfWay ? 1L : 0L)) << 1) - 1L;\n+        \/\/ normScale is the number of digits to take from the fraction of the input\n+        long normScale = minWorkingPrec - this.precision() + this.scale;\n+        normScale += normScale & 1L; \/\/ the scale for normalizing must be even\n+\n+        final long workingScale = this.scale - normScale;\n+        if (workingScale != (int) workingScale)\n+            throw new ArithmeticException(\"Overflow\");\n+\n+        BigDecimal working = new BigDecimal(this.intVal, this.intCompact, (int) workingScale, this.precision);\n+        BigInteger workingInt = working.toBigInteger();\n+\n+        BigInteger sqrt;\n+        long resultScale = normScale >> 1;\n+        \/\/ Round sqrt with the specified settings\n+        if (halfWay) { \/\/ half-way rounding\n+            BigInteger workingSqrt = workingInt.sqrt();\n+            \/\/ remove the one-tenth digit\n+            BigInteger[] quotRem10 = workingSqrt.divideAndRemainder(BigInteger.TEN);\n+            sqrt = quotRem10[0];\n+            resultScale--;\n+\n+            boolean increment = false;\n+            int digit = quotRem10[1].intValue();\n+            if (digit > 5) {\n+                increment = true;\n+            } else if (digit == 5) {\n+                if (mc.roundingMode == RoundingMode.HALF_UP\n+                        || mc.roundingMode == RoundingMode.HALF_EVEN && sqrt.testBit(0)\n+                        \/\/ Check if remainder is non-zero\n+                        || !workingInt.equals(workingSqrt.multiply(workingSqrt))\n+                        || working.compareTo(new BigDecimal(workingInt)) != 0) {\n+                    increment = true;\n+                }\n+            }\n@@ -2275,8 +2255,16 @@\n-        switch (signum) {\n-        case -1 -> throw new ArithmeticException(\"Attempted square root of negative BigDecimal\");\n-        case 0 -> {\n-            BigDecimal result = valueOf(0L, scale\/2);\n-            assert squareRootResultAssertions(result, mc);\n-            return result;\n-        }\n-        default -> throw new AssertionError(\"Bad value from signum\");\n+            if (increment)\n+                sqrt = sqrt.add(1L);\n+        } else {\n+            switch (mc.roundingMode) {\n+            case DOWN, FLOOR -> sqrt = workingInt.sqrt(); \/\/ No need to round\n+\n+            case UP, CEILING -> {\n+                BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n+                sqrt = sqrtRem[0];\n+                \/\/ Check if remainder is non-zero\n+                if (sqrtRem[1].signum != 0 || working.compareTo(new BigDecimal(workingInt)) != 0)\n+                    sqrt = sqrt.add(1L);\n+            }\n+\n+            default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n+            }\n@@ -2284,0 +2272,11 @@\n+\n+        result = new BigDecimal(sqrt, checkScale(sqrt, resultScale), mc); \/\/ mc ensures no increase of precision\n+        \/\/ Test numerical properties at full precision before any\n+        \/\/ scale adjustments.\n+        assert squareRootResultAssertions(result, mc);\n+        \/\/ Adjust to requested precision and preferred\n+        \/\/ scale as appropriate.\n+        if (result.scale > preferredScale) \/\/ else can't increase the result's precision to fit the preferred scale\n+            result = stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);\n+\n+        return result;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":126,"deletions":127,"binary":false,"changes":253,"status":"modified"}]}