{"files":[{"patch":"@@ -2143,11 +2143,0 @@\n-             * The following code draws on the algorithm presented in\n-             * \"Properly Rounded Variable Precision Square Root,\" Hull and\n-             * Abrham, ACM Transactions on Mathematical Software, Vol 11,\n-             * No. 3, September 1985, Pages 229-237.\n-             *\n-             * The BigDecimal computational model differs from the one\n-             * presented in the paper in several ways: first BigDecimal\n-             * numbers aren't necessarily normalized, second many more\n-             * rounding modes are supported, including UNNECESSARY, and\n-             * exact results can be requested.\n-             *\n@@ -2155,2 +2144,2 @@\n-             * first argument reduce the value to the numerical range\n-             * [1, 10) using the following relations:\n+             * first argument reduce the value to an integer\n+             * using the following relations:\n@@ -2160,1 +2149,1 @@\n-             * sqrt(x) = sqrt(y\/10) * 10 ^((exp+1)\/2) is exp is odd\n+             * sqrt(x) = sqrt(y*10) * 10^((exp-1)\/2) is exp is odd\n@@ -2162,1 +2151,1 @@\n-             * Then use Newton's iteration on the reduced value to compute\n+             * Then use BigInteger.sqrt() on the reduced value to compute\n@@ -2172,0 +2161,1 @@\n+            final int preferredScale = this.scale\/2;\n@@ -2173,2 +2163,5 @@\n-            int preferredScale = this.scale()\/2;\n-            BigDecimal zeroWithFinalPreferredScale = valueOf(0L, preferredScale);\n+            BigDecimal result;\n+            if (mc.roundingMode == RoundingMode.UNNECESSARY || mc.precision == 0) { \/\/ Exact result requested\n+                \/\/ To avoid trailing zeros in the result, strip trailing zeros.\n+                final BigDecimal stripped = this.stripTrailingZeros();\n+                final int strippedScale = stripped.scale;\n@@ -2176,4 +2169,2 @@\n-            \/\/ First phase of numerical normalization, strip trailing\n-            \/\/ zeros and check for even powers of 10.\n-            BigDecimal stripped = this.stripTrailingZeros();\n-            int strippedScale = stripped.scale();\n+                if ((strippedScale & 1) != 0) \/\/ 10*stripped.unscaledValue() can't be an exact square\n+                    throw new ArithmeticException(\"Computed square root not exact.\");\n@@ -2181,5 +2172,3 @@\n-            \/\/ Numerically sqrt(10^2N) = 10^N\n-            if (stripped.isPowerOfTen() &&\n-                strippedScale % 2 == 0) {\n-                BigDecimal result = valueOf(1L, strippedScale\/2);\n-                if (result.scale() != preferredScale) {\n+                \/\/ Check for even powers of 10. Numerically sqrt(10^2N) = 10^N\n+                if (stripped.isPowerOfTen()) {\n+                    result = valueOf(1L, strippedScale >> 1);\n@@ -2188,85 +2177,2 @@\n-                    result = result.add(zeroWithFinalPreferredScale, mc);\n-                }\n-                return result;\n-            }\n-\n-            \/\/ After stripTrailingZeros, the representation is normalized as\n-            \/\/\n-            \/\/ unscaledValue * 10^(-scale)\n-            \/\/\n-            \/\/ where unscaledValue is an integer with the minimum\n-            \/\/ precision for the cohort of the numerical value. To\n-            \/\/ allow binary floating-point hardware to be used to get\n-            \/\/ approximately a 15 digit approximation to the square\n-            \/\/ root, it is helpful to instead normalize this so that\n-            \/\/ the significand portion is to right of the decimal\n-            \/\/ point by roughly (scale() - precision() + 1).\n-\n-            \/\/ Now the precision \/ scale adjustment\n-            int scaleAdjust = 0;\n-            int scale = stripped.scale() - stripped.precision() + 1;\n-            if (scale % 2 == 0) {\n-                scaleAdjust = scale;\n-            } else {\n-                scaleAdjust = scale - 1;\n-            }\n-\n-            BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);\n-\n-            assert  \/\/ Verify 0.1 <= working < 10\n-                ONE_TENTH.compareTo(working) <= 0 && working.compareTo(TEN) < 0;\n-\n-            \/\/ Use good ole' Math.sqrt to get the initial guess for\n-            \/\/ the Newton iteration, good to at least 15 decimal\n-            \/\/ digits. This approach does incur the cost of a\n-            \/\/\n-            \/\/ BigDecimal -> double -> BigDecimal\n-            \/\/\n-            \/\/ conversion cycle, but it avoids the need for several\n-            \/\/ Newton iterations in BigDecimal arithmetic to get the\n-            \/\/ working answer to 15 digits of precision. If many fewer\n-            \/\/ than 15 digits were needed, it might be faster to do\n-            \/\/ the loop entirely in BigDecimal arithmetic.\n-            \/\/\n-            \/\/ (A double value might have as many as 17 decimal\n-            \/\/ digits of precision; it depends on the relative density\n-            \/\/ of binary and decimal numbers at different regions of\n-            \/\/ the number line.)\n-            \/\/\n-            \/\/ (It would be possible to check for certain special\n-            \/\/ cases to avoid doing any Newton iterations. For\n-            \/\/ example, if the BigDecimal -> double conversion was\n-            \/\/ known to be exact and the rounding mode had a\n-            \/\/ low-enough precision, the post-Newton rounding logic\n-            \/\/ could be applied directly.)\n-\n-            BigDecimal guess = new BigDecimal(Math.sqrt(working.doubleValue()));\n-            int guessPrecision = 15;\n-            int originalPrecision = mc.getPrecision();\n-            int targetPrecision;\n-\n-            \/\/ If an exact value is requested, it must only need about\n-            \/\/ half of the input digits to represent since multiplying\n-            \/\/ an N digit number by itself yield a 2N-1 digit or 2N\n-            \/\/ digit result.\n-            if (originalPrecision == 0) {\n-                targetPrecision = stripped.precision()\/2 + 1;\n-            } else {\n-                \/*\n-                 * To avoid the need for post-Newton fix-up logic, in\n-                 * the case of half-way rounding modes, double the\n-                 * target precision so that the \"2p + 2\" property can\n-                 * be relied on to accomplish the final rounding.\n-                 *\/\n-                switch (mc.getRoundingMode()) {\n-                case HALF_UP:\n-                case HALF_DOWN:\n-                case HALF_EVEN:\n-                    targetPrecision = 2 * originalPrecision;\n-                    if (targetPrecision < 0) \/\/ Overflow\n-                        targetPrecision = Integer.MAX_VALUE - 2;\n-                    break;\n-\n-                default:\n-                    targetPrecision = originalPrecision;\n-                    break;\n+                    result = result.adjustToPreferredScale(preferredScale, mc.precision);\n+                    return result;\n@@ -2274,1 +2180,0 @@\n-            }\n@@ -2276,26 +2181,12 @@\n-            \/\/ When setting the precision to use inside the Newton\n-            \/\/ iteration loop, take care to avoid the case where the\n-            \/\/ precision of the input exceeds the requested precision\n-            \/\/ and rounding the input value too soon.\n-            BigDecimal approx = guess;\n-            int workingPrecision = working.precision();\n-            do {\n-                int tmpPrecision = Math.max(Math.max(guessPrecision, targetPrecision + 2),\n-                                           workingPrecision);\n-                MathContext mcTmp = new MathContext(tmpPrecision, RoundingMode.HALF_EVEN);\n-                \/\/ approx = 0.5 * (approx + fraction \/ approx)\n-                approx = ONE_HALF.multiply(approx.add(working.divide(approx, mcTmp), mcTmp));\n-                guessPrecision *= 2;\n-            } while (guessPrecision < targetPrecision + 2);\n-\n-            BigDecimal result;\n-            RoundingMode targetRm = mc.getRoundingMode();\n-            if (targetRm == RoundingMode.UNNECESSARY || originalPrecision == 0) {\n-                RoundingMode tmpRm =\n-                    (targetRm == RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;\n-                MathContext mcTmp = new MathContext(targetPrecision, tmpRm);\n-                result = approx.scaleByPowerOfTen(-scaleAdjust\/2).round(mcTmp);\n-\n-                \/\/ If result*result != this numerically, the square\n-                \/\/ root isn't exact\n-                if (this.subtract(result.square()).compareTo(ZERO) != 0) {\n+                \/\/ After stripTrailingZeros, the representation is normalized as\n+                \/\/\n+                \/\/ unscaledValue * 10^(-scale)\n+                \/\/\n+                \/\/ where unscaledValue is an integer with the minimum\n+                \/\/ precision for the cohort of the numerical value and the scale is even.\n+                BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n+                result = new BigDecimal(sqrtRem[0], strippedScale >> 1);\n+\n+                \/\/ If result*result != this numerically or requires too high precision,\n+                \/\/ the square root isn't exact\n+                if (sqrtRem[1].signum != 0 || mc.precision != 0 && result.precision() > mc.precision)\n@@ -2303,1 +2194,7 @@\n-                }\n+\n+                \/\/ Test numerical properties at full precision before any\n+                \/\/ scale adjustments.\n+                assert squareRootResultAssertions(result, mc);\n+                \/\/ Adjust to requested precision and preferred\n+                \/\/ scale as appropriate.\n+                result = result.adjustToPreferredScale(preferredScale, mc.precision);\n@@ -2305,16 +2202,41 @@\n-                result = approx.scaleByPowerOfTen(-scaleAdjust\/2).round(mc);\n-\n-                switch (targetRm) {\n-                case DOWN:\n-                case FLOOR:\n-                    \/\/ Check if too big\n-                    if (result.square().compareTo(this) > 0) {\n-                        BigDecimal ulp = result.ulp();\n-                        \/\/ Adjust increment down in case of 1.0 = 10^0\n-                        \/\/ since the next smaller number is only 1\/10\n-                        \/\/ as far way as the next larger at exponent\n-                        \/\/ boundaries. Test approx and *not* result to\n-                        \/\/ avoid having to detect an arbitrary power\n-                        \/\/ of ten.\n-                        if (approx.compareTo(ONE) == 0) {\n-                            ulp = ulp.multiply(ONE_TENTH);\n+                \/\/ To allow BigInteger.sqrt() to be used to get the square\n+                \/\/ root, it is necessary to normalize the input so that\n+                \/\/ its integer part is sufficient to get the square root\n+                \/\/ with the desired precision.\n+\n+                final boolean halfWay = isHalfWay(mc.roundingMode);\n+                \/\/ To obtain a square root with N digits,\n+                \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n+                final long minWorkingPrec = ((mc.precision + (halfWay ? 1L : 0L)) << 1) - 1L;\n+                \/\/ normScale is the number of digits to take from the fraction of the input\n+                long normScale = minWorkingPrec - this.precision() + this.scale;\n+                normScale += normScale & 1L; \/\/ the scale for normalizing must be even\n+\n+                final long workingScale = this.scale - normScale;\n+                if (workingScale != (int) workingScale)\n+                    throw new ArithmeticException(\"Overflow\");\n+\n+                BigDecimal working = new BigDecimal(this.intVal, this.intCompact, (int) workingScale, this.precision);\n+                BigInteger workingInt = working.toBigInteger();\n+\n+                BigInteger sqrt;\n+                long resultScale = normScale >> 1;\n+                \/\/ Round sqrt with the specified settings\n+                if (halfWay) { \/\/ half-way rounding\n+                    BigInteger workingSqrt = workingInt.sqrt();\n+                    \/\/ remove the one-tenth digit\n+                    BigInteger[] quotRem10 = workingSqrt.divideAndRemainder(BigInteger.TEN);\n+                    sqrt = quotRem10[0];\n+                    resultScale--;\n+\n+                    boolean increment = false;\n+                    int digit = quotRem10[1].intValue();\n+                    if (digit > 5) {\n+                        increment = true;\n+                    } else if (digit == 5) {\n+                        if (mc.roundingMode == RoundingMode.HALF_UP\n+                                || mc.roundingMode == RoundingMode.HALF_EVEN && sqrt.testBit(0)\n+                                \/\/ Check if remainder is non-zero\n+                                || !workingInt.equals(workingSqrt.multiply(workingSqrt))\n+                                || working.compareTo(new BigDecimal(workingInt)) != 0) {\n+                            increment = true;\n@@ -2322,1 +2244,0 @@\n-                        result = result.subtract(ulp);\n@@ -2324,1 +2245,0 @@\n-                    break;\n@@ -2326,5 +2246,12 @@\n-                case UP:\n-                case CEILING:\n-                    \/\/ Check if too small\n-                    if (result.square().compareTo(this) < 0) {\n-                        result = result.add(result.ulp());\n+                    if (increment)\n+                        sqrt = sqrt.add(1L);\n+                } else {\n+                    switch (mc.roundingMode) {\n+                    case DOWN, FLOOR -> sqrt = workingInt.sqrt(); \/\/ No need to round\n+\n+                    case UP, CEILING -> {\n+                        BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n+                        sqrt = sqrtRem[0];\n+                        \/\/ Check if remainder is non-zero\n+                        if (sqrtRem[1].signum != 0 || working.compareTo(new BigDecimal(workingInt)) != 0)\n+                            sqrt = sqrt.add(1L);\n@@ -2332,15 +2259,0 @@\n-                    break;\n-\n-                default:\n-                    \/\/ No additional work, rely on \"2p + 2\" property\n-                    \/\/ for correct rounding. Alternatively, could\n-                    \/\/ instead run the Newton iteration to around p\n-                    \/\/ digits and then do tests and fix-ups on the\n-                    \/\/ rounded value. One possible set of tests and\n-                    \/\/ fix-ups is given in the Hull and Abrham paper;\n-                    \/\/ however, additional half-way cases can occur\n-                    \/\/ for BigDecimal given the more varied\n-                    \/\/ combinations of input and output precisions\n-                    \/\/ supported.\n-                    break;\n-                }\n@@ -2348,1 +2260,3 @@\n-            }\n+                    default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n+                    }\n+                }\n@@ -2350,14 +2264,8 @@\n-            \/\/ Test numerical properties at full precision before any\n-            \/\/ scale adjustments.\n-            assert squareRootResultAssertions(result, mc);\n-            if (result.scale() != preferredScale) {\n-                \/\/ The preferred scale of an add is\n-                \/\/ max(addend.scale(), augend.scale()). Therefore, if\n-                \/\/ the scale of the result is first minimized using\n-                \/\/ stripTrailingZeros(), adding a zero of the\n-                \/\/ preferred scale rounding to the correct precision\n-                \/\/ will perform the proper scale vs precision\n-                \/\/ tradeoffs.\n-                result = result.stripTrailingZeros().\n-                    add(zeroWithFinalPreferredScale,\n-                        new MathContext(originalPrecision, RoundingMode.UNNECESSARY));\n+                result = new BigDecimal(sqrt, checkScale(sqrt, resultScale), mc); \/\/ mc ensures no increase of precision\n+                \/\/ Test numerical properties at full precision before any\n+                \/\/ scale adjustments.\n+                assert squareRootResultAssertions(result, mc);\n+                \/\/ Adjust to requested precision and preferred\n+                \/\/ scale as appropriate.\n+                if (result.scale > preferredScale) \/\/ else can't increase the result's precision to fit the preferred scale\n+                    result = stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);\n@@ -2373,1 +2281,1 @@\n-                result = valueOf(0L, scale()\/2);\n+                result = valueOf(0L, scale\/2);\n@@ -2383,0 +2291,28 @@\n+    \/**\n+     * Assumes {@code (precision() <= maxPrecision || maxPrecision == 0) && this != 0}.\n+     * @param preferredScale the scale to reach\n+     * @param maxPrecision the largest precision the result can have.\n+     *        {@code maxPrecision == 0} means that the result can have arbitrary precision.\n+     * @return a BigDecimal numerically equivalent to {@code this}, whose precision\n+     *         does not exceed {@code maxPrecision} and whose scale is the closest\n+     *         to {@code preferredScale}.\n+     *\/\n+    private BigDecimal adjustToPreferredScale(int preferredScale, int maxPrecision) {\n+        BigDecimal result = this;\n+        if (result.scale > preferredScale) {\n+            result = stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);\n+        } else if (result.scale < preferredScale) {\n+            int maxScale = maxPrecision == 0 ?\n+                preferredScale : (int) Math.min(preferredScale, result.scale + (long) (maxPrecision - result.precision()));\n+            result = result.setScale(maxScale);\n+        }\n+        return result;\n+    }\n+\n+    private static boolean isHalfWay(RoundingMode m) {\n+        return switch (m) {\n+            case HALF_DOWN, HALF_UP, HALF_EVEN -> true;\n+            case FLOOR, CEILING, DOWN, UP, UNNECESSARY -> false;\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":129,"deletions":193,"binary":false,"changes":322,"status":"modified"}]}