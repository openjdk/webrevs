{"files":[{"patch":"@@ -2167,2 +2167,2 @@\n-                final BigDecimal stripped = this.stripZerosToEvenScale();\n-                final int strippedScale = stripped.scale; \/\/ strippedScale is even by construction\n+                final BigDecimal stripped = this.stripTrailingZeros();\n+                final int strippedScale = stripped.scale;\n@@ -2171,1 +2171,1 @@\n-                if (stripped.isPowerOfTen()) {\n+                if (stripped.isPowerOfTen() && (strippedScale & 1) == 0) {\n@@ -2180,1 +2180,1 @@\n-                \/\/ After stripTrailingZerosToEvenScale, the representation is normalized as\n+                \/\/ After stripTrailingZeros, the representation is normalized as\n@@ -2185,1 +2185,9 @@\n-                \/\/ precision for the cohort of the numerical value such that scale is even.\n+                \/\/ precision for the cohort of the numerical value.\n+                BigInteger working = stripped.unscaledValue();\n+                final int resultScale;\n+                if ((strippedScale & 1) == 0) {\n+                    resultScale = strippedScale >> 1;\n+                } else {\n+                    working = working.multiply(10L);\n+                    resultScale = (int) ((strippedScale + 1L) >> 1);\n+                }\n@@ -2187,2 +2195,2 @@\n-                BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n-                result = new BigDecimal(sqrtRem[0], strippedScale >> 1);\n+                BigInteger[] sqrtRem = working.sqrtAndRemainder();\n+                result = new BigDecimal(sqrtRem[0], resultScale);\n@@ -2278,78 +2286,0 @@\n-    \/**\n-     * Remove or append insignificant trailing zeros from this\n-     * {@code BigDecimal} value to reach an even scale, until no\n-     * more zeros can be removed.\n-     * <p> Assumes {@code this != 0}.\n-     *\n-     * @return the {@code BigDecimal} numerically equal to this one\n-     * that has even scale and unscaled value with minimum magnitude.\n-     * @throws ArithmeticException if scale overflows.\n-     *\/\n-    private BigDecimal stripZerosToEvenScale() {\n-        if (this.intCompact != INFLATED) {\n-            long intCompact = this.intCompact;\n-            int scale = this.scale;\n-\n-            \/\/ Try to make the scale even if it isn't by stripping a zero\n-            boolean even = (scale & 1) == 0;\n-            if (!even && intCompact % 10L == 0L) {\n-                intCompact \/= 10L;\n-                scale = checkScale(intCompact, scale - 1L); \/\/ could Overflow\n-                even = true;\n-            }\n-\n-            if (even) {\n-                \/\/ Strip remaining zeros while maintaining the scale even\n-                while (intCompact % 100L == 0L) { \/\/ zero remainder\n-                    intCompact \/= 100L;\n-                    scale = checkScale(intCompact, scale - 2L); \/\/ could Overflow\n-                }\n-\n-                return valueOf(intCompact, scale, 0);\n-            } else { \/\/ No trailing zeros but odd scale\n-                final long intValTenfold = intCompact * 10L;\n-\n-                if (intValTenfold \/ 10L == intCompact) { \/\/ See Math.multiplyExact(long, long)\n-                    scale = checkScale(intValTenfold, scale + 1L); \/\/ could Overflow\n-                    return valueOf(intValTenfold, scale, 0);\n-                } else { \/\/ intCompact * 10L overflows\n-                    BigInteger intValTenfoldBig = BigInteger.valueOf(intCompact).multiply(10L);\n-                    scale = checkScale(intValTenfoldBig, scale + 1L); \/\/ could Overflow\n-                    return valueOf(intValTenfoldBig, scale, 0);\n-                }\n-            }\n-        } else {\n-            BigInteger intVal = this.intVal == null ? INFLATED_BIGINT : this.intVal;\n-            int scale = this.scale;\n-            BigInteger[] qr; \/\/ quotient-remainder pair\n-\n-            \/\/ Try to make the scale even if it isn't by stripping a zero\n-            boolean even = (scale & 1) == 0;\n-            if (!even && !intVal.testBit(0)) { \/\/ odd number cannot end in 0\n-                qr = intVal.divideAndRemainder(BigInteger.TEN);\n-                if (qr[1].signum == 0) { \/\/ zero remainder\n-                    intVal = qr[0];\n-                    scale = checkScale(intVal, scale - 1L); \/\/ could Overflow\n-                    even = true;\n-                }\n-            }\n-\n-            if (even) {\n-                \/\/ Strip remaining zeros while maintaining the scale even\n-                final BigInteger hundred = BigInteger.valueOf(100L);\n-                while ((intVal.mag[intVal.mag.length - 1] & 3) == 0) { \/\/ non-multiple of 4 cannot end in 00\n-                    qr = intVal.divideAndRemainder(hundred);\n-                    if (qr[1].signum != 0) \/\/ non-0 remainder\n-                        break;\n-                    intVal = qr[0];\n-                    scale = checkScale(intVal, scale - 2L); \/\/ could Overflow\n-                }\n-            } else { \/\/ No trailing zeros but odd scale\n-                intVal = intVal.multiply(10L);\n-                scale = checkScale(intVal, scale + 1L); \/\/ could Overflow\n-            }\n-\n-            return valueOf(intVal, scale, 0);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":15,"deletions":85,"binary":false,"changes":100,"status":"modified"}]}