{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.concurrent.Callable;\n@@ -353,2 +354,1 @@\n-            throw new IllegalArgumentException(\n-                    \"'maxConcurrency' must be greater than 0\");\n+            throw new IllegalArgumentException(\"'maxConcurrency' must be greater than 0\");\n@@ -358,11 +358,5 @@\n-        class State {\n-            \/\/ ArrayDeque default initial size is 16\n-            final ArrayDeque<Future<R>> window =\n-                    new ArrayDeque<>(Math.min(maxConcurrency, 16));\n-            final Semaphore windowLock = new Semaphore(maxConcurrency);\n-\n-            final boolean integrate(T element,\n-                                    Downstream<? super R> downstream) {\n-                if (!downstream.isRejecting())\n-                    createTaskFor(element);\n-                return flush(0, downstream);\n+        final class MapConcurrentTask extends FutureTask<R> {\n+            final Thread thread;\n+            private MapConcurrentTask(Callable<R> callable) {\n+                super(callable);\n+                this.thread = Thread.ofVirtual().unstarted(this);\n@@ -370,0 +364,1 @@\n+        }\n@@ -371,2 +366,3 @@\n-            final void createTaskFor(T element) {\n-                windowLock.acquireUninterruptibly();\n+        final class State {\n+            private final ArrayDeque<MapConcurrentTask> wip =\n+                new ArrayDeque<>(Math.min(maxConcurrency, 16));\n@@ -374,7 +370,7 @@\n-                var task = new FutureTask<R>(() -> {\n-                    try {\n-                        return mapper.apply(element);\n-                    } finally {\n-                        windowLock.release();\n-                    }\n-                });\n+            boolean integrate(T element, Downstream<? super R> downstream) {\n+                \/\/ Prepare the next task and add it to the work-in-progress\n+                final var task = new MapConcurrentTask(() -> mapper.apply(element));\n+                wip.addLast(task);\n+\n+                assert wip.peekLast() == task;\n+                assert wip.size() <= maxConcurrency;\n@@ -382,2 +378,2 @@\n-                var wasAddedToWindow = window.add(task);\n-                assert wasAddedToWindow;\n+                \/\/ Start the next task\n+                task.thread.start();\n@@ -385,1 +381,2 @@\n-                Thread.startVirtualThread(task);\n+                \/\/ Flush at least 1 element if we're at capacity\n+                return flush(wip.size() < maxConcurrency ? 0 : 1, downstream);\n@@ -388,4 +385,2 @@\n-            final boolean flush(long atLeastN,\n-                                Downstream<? super R> downstream) {\n-                boolean proceed = !downstream.isRejecting();\n-                boolean interrupted = false;\n+            boolean flush(long atLeastN, Downstream<? super R> downstream) {\n+                boolean success = false, interrupted = false;\n@@ -393,1 +388,2 @@\n-                    Future<R> current;\n+                    boolean proceed = !downstream.isRejecting();\n+                    MapConcurrentTask current;\n@@ -395,3 +391,15 @@\n-                            && (current = window.peek()) != null\n-                                && (current.isDone() || atLeastN > 0)) {\n-                        proceed &= downstream.push(current.get());\n+                        && (current = wip.peekFirst()) != null\n+                        && (current.isDone() || atLeastN > 0)) {\n+                        R result;\n+\n+                        \/\/ Ensure that the task is done before proceeding\n+                        for(;;) {\n+                            try {\n+                                result = current.get();\n+                                break;\n+                            } catch (InterruptedException ie) {\n+                                interrupted = true; \/\/ ignore for now, and restore later\n+                            }\n+                        }\n+\n+                        proceed &= downstream.push(result);\n@@ -400,1 +408,1 @@\n-                        var correctRemoval = window.pop() == current;\n+                        final var correctRemoval = wip.pollFirst() == current;\n@@ -403,3 +411,1 @@\n-                } catch(InterruptedException ie) {\n-                    proceed = false;\n-                    interrupted = true;\n+                    return (success = proceed); \/\/ Ensure that cleanup occurs if needed\n@@ -407,1 +413,0 @@\n-                    proceed = false; \/\/ Ensure cleanup\n@@ -413,5 +418,16 @@\n-                    \/\/ Clean up\n-                    if (!proceed) {\n-                        Future<R> next;\n-                        while ((next = window.pollFirst()) != null) {\n-                            next.cancel(true);\n+                    \/\/ Clean up work-in-progress\n+                    if (!success && !wip.isEmpty()) {\n+                        \/\/ First signal cancellation for all tasks in progress\n+                        for(var task : wip)\n+                            task.cancel(true);\n+\n+                        \/\/ Then wait for all in progress task Threads to exit\n+                        MapConcurrentTask next;\n+                        while ((next = wip.pollFirst()) != null) {\n+                            while(next.thread.isAlive()) {\n+                                try {\n+                                    next.thread.join();\n+                                } catch (InterruptedException ie) {\n+                                    interrupted = true; \/\/ ignore, for now, and restore later\n+                                }\n+                            }\n@@ -420,4 +436,0 @@\n-                }\n-\n-                if (interrupted)\n-                    Thread.currentThread().interrupt();\n@@ -425,1 +437,5 @@\n-                return proceed;\n+                    \/\/ integrate(..) could be called from different threads each time\n+                    \/\/ so we need to restore the interrupt on the calling thread\n+                    if (interrupted)\n+                        Thread.currentThread().interrupt();\n+                }\n@@ -430,3 +446,3 @@\n-                State::new,\n-                Integrator.<State, T, R>ofGreedy(State::integrate),\n-                (state, downstream) -> state.flush(Long.MAX_VALUE, downstream)\n+            State::new,\n+            Integrator.<State, T, R>ofGreedy(State::integrate),\n+            (state, downstream) -> state.flush(Long.MAX_VALUE, downstream)\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Gatherers.java","additions":68,"deletions":52,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.function.Function;\n@@ -316,0 +319,56 @@\n+\n+    @ParameterizedTest\n+    @MethodSource(\"concurrencyConfigurations\")\n+    public void behavesAsExpectedWhenCallerIsInterrupted(ConcurrencyConfig cc) {\n+        final var limitTo = Math.max(cc.config().streamSize() \/ 2, 1);\n+\n+        final var expectedResult = cc.config().stream()\n+            .map(x -> x * x)\n+            .limit(limitTo)\n+            .toList();\n+\n+        \/\/ Ensure calling thread is interrupted\n+        Thread.currentThread().interrupt();\n+\n+        final var result = cc.config().stream()\n+            .gather(Gatherers.mapConcurrent(cc.concurrencyLevel(), x -> {\n+                LockSupport.parkNanos(10000); \/\/ 10 us\n+                return x * x;\n+            }))\n+            .limit(limitTo)\n+            .toList();\n+\n+        \/\/ Ensure calling thread remains interrupted\n+        assertEquals(true, Thread.interrupted());\n+\n+        assertEquals(expectedResult, result);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"concurrencyConfigurations\")\n+    public void behavesAsExpectedWhenHeadOfLineBlocking(ConcurrencyConfig cc) {\n+        final var elementNum = new AtomicLong(0);\n+        final var wipCount = new AtomicLong(0);\n+        final var limitTo = Math.max(cc.config().streamSize() \/ 2, 1);\n+\n+        final var expectedResult = cc.config().stream()\n+            .map(x -> x * x)\n+            .limit(limitTo)\n+            .toList();\n+\n+        Function<Integer, Integer> fun = x -> {\n+            if (wipCount.incrementAndGet() > cc.concurrencyLevel)\n+                throw new IllegalStateException(\"Too much wip!\");\n+            if (elementNum.getAndIncrement() == 0)\n+                LockSupport.parkNanos(500_000_000); \/\/ 500 ms\n+            return x * x;\n+        };\n+\n+        final var result = cc.config().stream()\n+            .gather(Gatherers.mapConcurrent(cc.concurrencyLevel(), fun))\n+            .gather(Gatherer.of((v, e, d) -> wipCount.decrementAndGet() >= 0 && d.push(e)))\n+            .limit(limitTo)\n+            .toList();\n+\n+        assertEquals(expectedResult, result);\n+    }\n","filename":"test\/jdk\/java\/util\/stream\/GatherersMapConcurrentTest.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"}]}