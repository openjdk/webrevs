{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.file.Files;\n@@ -43,0 +44,1 @@\n+import static jdk.jpackage.internal.ShortPathUtils.adjustPath;\n@@ -115,1 +117,1 @@\n-            Path target, UpdateResourceAction action) throws IOException {\n+            final Path target, UpdateResourceAction action) throws IOException {\n@@ -128,1 +130,2 @@\n-            long resourceLock = lockResource(target.toString());\n+            var shortTargetPath = ShortPathUtils.toShortPath(target);\n+            long resourceLock = lockResource(shortTargetPath.orElse(target).toString());\n@@ -131,1 +134,1 @@\n-                    I18N.getString(\"error.lock-resource\"), target));\n+                    I18N.getString(\"error.lock-resource\"), shortTargetPath.orElse(target)));\n@@ -147,0 +150,8 @@\n+                    if (shortTargetPath.isPresent()) {\n+                        \/\/ Windows will rename the excuatble in the unlock operation.\n+                        \/\/ Should restore executable's name.\n+                        var tmpPath = target.getParent().resolve(\n+                                target.getFileName().toString() + \".restore\");\n+                        Files.move(shortTargetPath.get(), tmpPath);\n+                        Files.move(tmpPath, target);\n+                    }\n@@ -239,0 +250,1 @@\n+        iconTarget = adjustPath(iconTarget);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/ExecutableRebrander.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.MessageFormat;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\n+@SuppressWarnings(\"restricted\")\n+final class ShortPathUtils {\n+    static String adjustPath(String path) {\n+        return toShortPath(path).orElse(path);\n+    }\n+\n+    static Path adjustPath(Path path) {\n+        return toShortPath(path).orElse(path);\n+    }\n+\n+    static Optional<String> toShortPath(String path) {\n+        Objects.requireNonNull(path);\n+        return toShortPath(Path.of(path)).map(Path::toString);\n+    }\n+\n+    static Optional<Path> toShortPath(Path path) {\n+        if (!Files.exists(path)) {\n+            throw new IllegalArgumentException(String.format(\"[%s] path does not exist\", path));\n+        }\n+\n+        var normPath = path.normalize().toAbsolutePath().toString();\n+        if (normPath.length() > MAX_PATH) {\n+            return Optional.of(Path.of(getShortPathWrapper(normPath)));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static String getShortPathWrapper(final String longPath) {\n+        String effectivePath;\n+        if (!longPath.startsWith(LONG_PATH_PREFIX)) {\n+            effectivePath = LONG_PATH_PREFIX + longPath;\n+        } else {\n+            effectivePath = longPath;\n+        }\n+\n+        return Optional.ofNullable(getShortPath(effectivePath)).orElseThrow(\n+                () -> new ShortPathException(MessageFormat.format(I18N.getString(\n+                        \"error.short-path-conv-fail\"), effectivePath)));\n+    }\n+\n+    static final class ShortPathException extends RuntimeException {\n+\n+        ShortPathException(String msg) {\n+            super(msg);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    private static native String getShortPath(String longPath);\n+\n+    private static final int MAX_PATH = 240;\n+    \/\/ See https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/api\/fileapi\/nf-fileapi-getshortpathnamew\n+    private static final String LONG_PATH_PREFIX = \"\\\\\\\\?\\\\\";\n+\n+    static {\n+        System.loadLibrary(\"jpackage\");\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/ShortPathUtils.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -529,3 +529,4 @@\n-        WixPipeline wixPipeline = new WixPipeline()\n-                .setToolset(wixToolset)\n-                .setWixObjDir(TEMP_ROOT.fetchFrom(params).resolve(\"wixobj\"))\n+        var wixObjDir = TEMP_ROOT.fetchFrom(params).resolve(\"wixobj\");\n+\n+        var wixPipeline = WixPipeline.build()\n+                .setWixObjDir(wixObjDir)\n@@ -608,1 +609,1 @@\n-            wixPipeline.addLightOptions(\"-loc\", wxl.toAbsolutePath().normalize().toString());\n+            wixPipeline.addLightOptions(\"-loc\", wxl.toString());\n@@ -614,1 +615,1 @@\n-            wixPipeline.addLightOptions(\"-loc\", wxl.toAbsolutePath().normalize().toString());\n+            wixPipeline.addLightOptions(\"-loc\", wxl.toString());\n@@ -641,1 +642,2 @@\n-        wixPipeline.buildMsi(msiOut.toAbsolutePath());\n+        Files.createDirectories(wixObjDir);\n+        wixPipeline.create(wixToolset).buildMsi(msiOut.toAbsolutePath());\n@@ -681,1 +683,1 @@\n-                        wxlPath.toAbsolutePath()));\n+                        wxlPath.toAbsolutePath().normalize()));\n@@ -688,1 +690,1 @@\n-                    \"error.read-wix-l10n-file\"), wxlPath.toAbsolutePath()), ex);\n+                    \"error.read-wix-l10n-file\"), wxlPath.toAbsolutePath().normalize()), ex);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    void configureWixPipeline(WixPipeline wixPipeline) {\n+    void configureWixPipeline(WixPipeline.Builder wixPipeline) {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixFragmentBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.HashMap;\n@@ -36,0 +37,1 @@\n+import java.util.Set;\n@@ -37,0 +39,1 @@\n+import java.util.function.UnaryOperator;\n@@ -39,0 +42,1 @@\n+import static jdk.jpackage.internal.ShortPathUtils.adjustPath;\n@@ -44,5 +48,1 @@\n-public class WixPipeline {\n-    WixPipeline() {\n-        sources = new ArrayList<>();\n-        lightOptions = new ArrayList<>();\n-    }\n+final class WixPipeline {\n@@ -50,4 +50,3 @@\n-    WixPipeline setToolset(WixToolset v) {\n-        toolset = v;\n-        return this;\n-    }\n+    static final class Builder {\n+        Builder() {\n+        }\n@@ -55,4 +54,7 @@\n-    WixPipeline setWixVariables(Map<String, String> v) {\n-        wixVariables = v;\n-        return this;\n-    }\n+        WixPipeline create(WixToolset toolset) {\n+            Objects.requireNonNull(toolset);\n+            Objects.requireNonNull(workDir);\n+            Objects.requireNonNull(wixObjDir);\n+            if (sources.isEmpty()) {\n+                throw new IllegalArgumentException(\"no sources\");\n+            }\n@@ -60,4 +62,41 @@\n-    WixPipeline setWixObjDir(Path v) {\n-        wixObjDir = v;\n-        return this;\n-    }\n+            final var absWorkDir = workDir.normalize().toAbsolutePath();\n+\n+            final UnaryOperator<Path> normalizePath = path -> {\n+                return path.normalize().toAbsolutePath();\n+            };\n+\n+            final var absObjWorkDir = normalizePath.apply(wixObjDir);\n+\n+            var relSources = sources.stream().map(source -> {\n+                return source.overridePath(normalizePath.apply(source.path));\n+            }).toList();\n+\n+            return new WixPipeline(toolset, adjustPath(absWorkDir), absObjWorkDir,\n+                    wixVariables, mapLightOptions(normalizePath), relSources);\n+        }\n+\n+        Builder setWixObjDir(Path v) {\n+            wixObjDir = v;\n+            return this;\n+        }\n+\n+        Builder setWorkDir(Path v) {\n+            workDir = v;\n+            return this;\n+        }\n+\n+        Builder setWixVariables(Map<String, String> v) {\n+            wixVariables.clear();\n+            wixVariables.putAll(v);\n+            return this;\n+        }\n+\n+        Builder addSource(Path source, Map<String, String> wixVariables) {\n+            sources.add(new WixSource(source, wixVariables));\n+            return this;\n+        }\n+\n+        Builder addLightOptions(String ... v) {\n+            lightOptions.addAll(List.of(v));\n+            return this;\n+        }\n@@ -65,3 +104,21 @@\n-    WixPipeline setWorkDir(Path v) {\n-        workDir = v;\n-        return this;\n+        private List<String> mapLightOptions(UnaryOperator<Path> normalizePath) {\n+            var pathOptions = Set.of(\"-b\", \"-loc\");\n+            List<String> reply = new ArrayList<>();\n+            boolean convPath = false;\n+            for (var opt : lightOptions) {\n+                if (convPath) {\n+                    opt = normalizePath.apply(Path.of(opt)).toString();\n+                    convPath = false;\n+                } else if (pathOptions.contains(opt)) {\n+                    convPath = true;\n+                }\n+                reply.add(opt);\n+            }\n+            return reply;\n+        }\n+\n+        private Path workDir;\n+        private Path wixObjDir;\n+        private final Map<String, String> wixVariables = new HashMap<>();\n+        private final List<String> lightOptions = new ArrayList<>();\n+        private final List<WixSource> sources = new ArrayList<>();\n@@ -70,6 +127,2 @@\n-    WixPipeline addSource(Path source, Map<String, String> wixVariables) {\n-        WixSource entry = new WixSource();\n-        entry.source = source;\n-        entry.variables = wixVariables;\n-        sources.add(entry);\n-        return this;\n+    static Builder build() {\n+        return new Builder();\n@@ -78,3 +131,9 @@\n-    WixPipeline addLightOptions(String ... v) {\n-        lightOptions.addAll(List.of(v));\n-        return this;\n+    private WixPipeline(WixToolset toolset, Path workDir, Path wixObjDir,\n+            Map<String, String> wixVariables, List<String> lightOptions,\n+            List<WixSource> sources) {\n+        this.toolset = toolset;\n+        this.workDir = workDir;\n+        this.wixObjDir = wixObjDir;\n+        this.wixVariables = wixVariables;\n+        this.lightOptions = lightOptions;\n+        this.sources = sources;\n@@ -86,0 +145,4 @@\n+        \/\/ Use short path to the output msi to workaround\n+        \/\/ WiX limitations of handling long paths.\n+        var transientMsi = wixObjDir.resolve(\"a.msi\");\n+\n@@ -87,2 +150,2 @@\n-            case Wix3 -> buildMsiWix3(msi);\n-            case Wix4 -> buildMsiWix4(msi);\n+            case Wix3 -> buildMsiWix3(transientMsi);\n+            case Wix4 -> buildMsiWix4(transientMsi);\n@@ -91,0 +154,2 @@\n+\n+        IOUtils.copyFile(workDir.resolve(transientMsi), msi);\n@@ -144,1 +209,1 @@\n-                \"-intermediatefolder\", wixObjDir.toAbsolutePath().toString(),\n+                \"-intermediatefolder\", wixObjDir.toString(),\n@@ -154,1 +219,1 @@\n-            return wixSource.source.toAbsolutePath().toString();\n+            return wixSource.path.toString();\n@@ -185,1 +250,1 @@\n-                IOUtils.getFileName(wixSource.source), \".wixobj\"));\n+                wixSource.path.getFileName(), \".wixobj\"));\n@@ -190,1 +255,1 @@\n-                wixSource.source.toAbsolutePath().toString(),\n+                wixSource.path.toString(),\n@@ -193,1 +258,1 @@\n-                \"-out\", wixObj.toAbsolutePath().toString()\n+                \"-out\", wixObj.toString()\n@@ -204,2 +269,1 @@\n-        Executor.of(new ProcessBuilder(cmdline).directory(workDir.toFile())).\n-                executeExpectSuccess();\n+        Executor.of(new ProcessBuilder(cmdline).directory(workDir.toFile())).executeExpectSuccess();\n@@ -208,3 +272,4 @@\n-    private static final class WixSource {\n-        Path source;\n-        Map<String, String> variables;\n+    private record WixSource(Path path, Map<String, String> variables) {\n+        WixSource overridePath(Path path) {\n+            return new WixSource(path, variables);\n+        }\n@@ -213,6 +278,6 @@\n-    private WixToolset toolset;\n-    private Map<String, String> wixVariables;\n-    private List<String> lightOptions;\n-    private Path wixObjDir;\n-    private Path workDir;\n-    private List<WixSource> sources;\n+    private final WixToolset toolset;\n+    private final Map<String, String> wixVariables;\n+    private final List<String> lightOptions;\n+    private final Path wixObjDir;\n+    private final Path workDir;\n+    private final List<WixSource> sources;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixPipeline.java","additions":112,"deletions":47,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    void configureWixPipeline(WixPipeline wixPipeline) {\n+    void configureWixPipeline(WixPipeline.Builder wixPipeline) {\n@@ -521,1 +521,1 @@\n-        void addToWixPipeline(WixPipeline wixPipeline) {\n+        void addToWixPipeline(WixPipeline.Builder wixPipeline) {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixUiFragmentBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+error.short-path-conv-fail=Failed to get short version of \"{0}\" path\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+error.short-path-conv-fail=Failed to get short version of \"{0}\" path\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_de.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+error.short-path-conv-fail=Failed to get short version of \"{0}\" path\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_ja.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+error.short-path-conv-fail=Failed to get short version of \"{0}\" path\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_zh_CN.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -671,0 +671,19 @@\n+tstring toShortPath(const tstring& path) {\n+    const DWORD len = GetShortPathName(path.c_str(), nullptr, 0);\n+    if (0 == len) {\n+        JP_THROW(SysError(tstrings::any() << \"GetShortPathName(\"\n+                << path << \") failed\", GetShortPathName));\n+    }\n+\n+    std::vector<TCHAR> buf;\n+    buf.resize(len);\n+    const DWORD copied = GetShortPathName(path.c_str(), buf.data(),\n+                                            static_cast<DWORD>(buf.size()));\n+    if (copied != buf.size() - 1) {\n+        JP_THROW(SysError(tstrings::any() << \"GetShortPathName(\"\n+                << path << \") failed\", GetShortPathName));\n+    }\n+\n+    return tstring(buf.data(), buf.size() - 1);\n+}\n+\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinFileUtils.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -318,0 +318,2 @@\n+\n+    tstring toShortPath(const tstring& path);\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinFileUtils.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"FileUtils.h\"\n+#include \"WinFileUtils.h\"\n@@ -165,0 +167,21 @@\n+    \/*\n+     * Class:     jdk_jpackage_internal_ShortPathUtils\n+     * Method:    getShortPath\n+     * Signature: (Ljava\/lang\/String;)Ljava\/lang\/String;\n+     *\/\n+    JNIEXPORT jstring JNICALL\n+        Java_jdk_jpackage_internal_ShortPathUtils_getShortPath(\n+            JNIEnv *pEnv, jclass c, jstring jLongPath) {\n+\n+        JP_TRY;\n+\n+        const std::wstring longPath = jni::toUnicodeString(pEnv, jLongPath);\n+        std::wstring shortPath = FileUtils::toShortPath(longPath);\n+\n+        return jni::toJString(pEnv, shortPath);\n+\n+        JP_CATCH_ALL;\n+\n+        return NULL;\n+    }\n+\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/jpackage.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        removePath = false;\n+        removePathEnvVar = false;\n@@ -88,2 +88,2 @@\n-    public Executor setRemovePath(boolean value) {\n-        removePath = value;\n+    public Executor setRemovePathEnvVar(boolean value) {\n+        removePathEnvVar = value;\n@@ -351,1 +351,1 @@\n-        if (removePath) {\n+        if (removePathEnvVar) {\n@@ -481,1 +481,1 @@\n-    private boolean removePath;\n+    private boolean removePathEnvVar;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-                removePath(true);\n+                removePathEnvVar(true);\n@@ -361,2 +361,2 @@\n-        public AppOutputVerifier removePath(boolean v) {\n-            removePath = v;\n+        public AppOutputVerifier removePathEnvVar(boolean v) {\n+            removePathEnvVar = v;\n@@ -458,1 +458,1 @@\n-            final Path executablePath;\n+            Path executablePath;\n@@ -466,0 +466,9 @@\n+            if (TKit.isWindows()) {\n+                var absExecutablePath = executablePath.toAbsolutePath().normalize();\n+                var shortPath = WindowsHelper.toShortPath(absExecutablePath);\n+                if (shortPath.isPresent()) {\n+                    TKit.trace(String.format(\"Will run [%s] as [%s]\", executablePath, shortPath.get()));\n+                    executablePath = shortPath.get();\n+                }\n+            }\n+\n@@ -471,1 +480,1 @@\n-                    .setRemovePath(removePath)\n+                    .setRemovePathEnvVar(removePathEnvVar)\n@@ -477,1 +486,1 @@\n-        private boolean removePath;\n+        private boolean removePathEnvVar;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.reflect.Method;\n@@ -39,0 +40,1 @@\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n@@ -40,0 +42,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n@@ -97,0 +100,1 @@\n+            var msiPath = TransientMsi.create(cmd).path();\n@@ -98,1 +102,1 @@\n-                    install ? \"\/i\" : \"\/x\").addArgument(cmd.outputBundle().normalize()));\n+                    install ? \"\/i\" : \"\/x\").addArgument(msiPath));\n@@ -115,0 +119,2 @@\n+            final Path msiPath = TransientMsi.create(cmd).path();\n+\n@@ -124,1 +130,1 @@\n-                    String.format(\"\\\"%s\\\"\", cmd.outputBundle().normalize()),\n+                    String.format(\"\\\"%s\\\"\", msiPath),\n@@ -158,0 +164,43 @@\n+    record TransientMsi(Path path) {\n+        static TransientMsi create(JPackageCommand cmd) {\n+            var outputMsiPath = cmd.outputBundle().normalize();\n+            if (isPathTooLong(outputMsiPath)) {\n+                return toSupplier(() -> {\n+                    var transientMsiPath = TKit.createTempDirectory(\"msi-copy\").resolve(\"a.msi\").normalize();\n+                    TKit.trace(String.format(\"Copy [%s] to [%s]\", outputMsiPath, transientMsiPath));\n+                    Files.copy(outputMsiPath, transientMsiPath);\n+                    return new TransientMsi(transientMsiPath);\n+                }).get();\n+            } else {\n+                return new TransientMsi(outputMsiPath);\n+            }\n+        }\n+    }\n+\n+    public enum WixType {\n+        WIX3,\n+        WIX4\n+    }\n+\n+    public static WixType getWixTypeFromVerboseJPackageOutput(Executor.Result result) {\n+        return result.getOutput().stream().map(str -> {\n+            if (str.contains(\"[light.exe]\")) {\n+                return WixType.WIX3;\n+            } else if (str.contains(\"[wix.exe]\")) {\n+                return WixType.WIX4;\n+            } else {\n+                return null;\n+            }\n+        }).filter(Objects::nonNull).reduce((a, b) -> {\n+            throw new IllegalArgumentException(\"Invalid input: multiple invocations of WiX tools\");\n+        }).orElseThrow(() -> new IllegalArgumentException(\"Invalid input: no invocations of WiX tools\"));\n+    }\n+\n+    static Optional<Path> toShortPath(Path path) {\n+        if (isPathTooLong(path)) {\n+            return Optional.of(ShortPathUtils.toShortPath(path));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n@@ -306,0 +355,4 @@\n+    private static boolean isPathTooLong(Path path) {\n+        return path.toString().length() > WIN_MAX_PATH;\n+    }\n+\n@@ -528,0 +581,26 @@\n+    private static final class ShortPathUtils {\n+        private ShortPathUtils() {\n+            try {\n+                var shortPathUtilsClass = Class.forName(\"jdk.jpackage.internal.ShortPathUtils\");\n+\n+                getShortPathWrapper = shortPathUtilsClass.getDeclaredMethod(\n+                        \"getShortPathWrapper\", String.class);\n+                \/\/ Note: this reflection call requires\n+                \/\/ --add-opens jdk.jpackage\/jdk.jpackage.internal=ALL-UNNAMED\n+                getShortPathWrapper.setAccessible(true);\n+            } catch (ClassNotFoundException | NoSuchMethodException\n+                    | SecurityException ex) {\n+                throw rethrowUnchecked(ex);\n+            }\n+        }\n+\n+        static Path toShortPath(Path path) {\n+            return Path.of(toSupplier(() -> (String) INSTANCE.getShortPathWrapper.invoke(\n+                    null, path.toString())).get());\n+        }\n+\n+        private final Method getShortPathWrapper;\n+\n+        private static final ShortPathUtils INSTANCE = new ShortPathUtils();\n+    }\n+\n@@ -543,0 +622,2 @@\n+\n+    private static final int WIN_MAX_PATH = 260;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":83,"deletions":2,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import static jdk.jpackage.test.WindowsHelper.WixType.WIX3;\n+import static jdk.jpackage.test.WindowsHelper.getWixTypeFromVerboseJPackageOutput;\n@@ -112,1 +114,1 @@\n-    private static Stream<String> getBuildCommandLine(Executor.Result result) {\n+    private static Stream<String> getWixCommandLine(Executor.Result result) {\n@@ -118,1 +120,1 @@\n-        return result.getOutput().stream().anyMatch(createToolCommandLinePredicate(\"light\"));\n+        return getWixTypeFromVerboseJPackageOutput(result) == WIX3;\n@@ -130,1 +132,1 @@\n-    private static List<TKit.TextStreamVerifier> createDefaultL10nFilesLocVerifiers(Path tempDir) {\n+    private static List<TKit.TextStreamVerifier> createDefaultL10nFilesLocVerifiers(Path wixSrcDir) {\n@@ -132,2 +134,2 @@\n-                TKit.assertTextStream(\"-loc \" + tempDir.resolve(\n-                        String.format(\"config\/MsiInstallerStrings_%s.wxl\", loc)).normalize()))\n+                TKit.assertTextStream(\"-loc \" + wixSrcDir.resolve(\n+                        String.format(\"MsiInstallerStrings_%s.wxl\", loc))))\n@@ -186,0 +188,4 @@\n+            final List<String> wixCmdline = getWixCommandLine(result).toList();\n+\n+            final var isWix3 = isWix3(result);\n+\n@@ -188,1 +194,1 @@\n-                if (isWix3(result)) {\n+                if (isWix3) {\n@@ -195,1 +201,1 @@\n-                TKit.assertTextStream(expected).apply(getBuildCommandLine(result));\n+                TKit.assertTextStream(expected).apply(wixCmdline.stream());\n@@ -204,1 +210,2 @@\n-                var wixSrcDir = Path.of(cmd.getArgumentValue(\"--temp\")).resolve(\"config\");\n+                var wixSrcDir = Path.of(cmd.getArgumentValue(\"--temp\")).resolve(\n+                        \"config\").normalize().toAbsolutePath();\n@@ -209,1 +216,1 @@\n-                            v.createCmdOutputVerifier(wixSrcDir).apply(getBuildCommandLine(result));\n+                            v.createCmdOutputVerifier(wixSrcDir).apply(wixCmdline.stream());\n@@ -212,3 +219,3 @@\n-                    var tempDir = Path.of(cmd.getArgumentValue(\"--temp\")).toAbsolutePath();\n-                    for (var v : createDefaultL10nFilesLocVerifiers(tempDir)) {\n-                        v.apply(getBuildCommandLine(result));\n+\n+                    for (var v : createDefaultL10nFilesLocVerifiers(wixSrcDir)) {\n+                        v.apply(wixCmdline.stream());\n@@ -221,2 +228,3 @@\n-                    TKit.assertFalse(getBuildCommandLine(result).findAny().isPresent(),\n-                            \"Check light.exe was not invoked\");\n+                    TKit.assertTrue(wixCmdline.stream().findAny().isEmpty(),\n+                            String.format(\"Check %s.exe was not invoked\",\n+                                    isWix3 ? \"light\" : \"wix\"));\n@@ -279,1 +287,1 @@\n-                TKit.TextStreamVerifier createCmdOutputVerifier(Path root) {\n+                TKit.TextStreamVerifier createCmdOutputVerifier(Path wixSrcDir) {\n@@ -281,2 +289,1 @@\n-                            \"Failed to parse %s file\",\n-                            root.resolve(\"b.wxl\").toAbsolutePath()));\n+                            \"Failed to parse %s file\", wixSrcDir.resolve(\"b.wxl\")));\n@@ -300,3 +307,2 @@\n-        TKit.TextStreamVerifier createCmdOutputVerifier(Path root) {\n-            return TKit.assertTextStream(\n-                    \"-loc \" + root.resolve(name).toAbsolutePath().normalize());\n+        TKit.TextStreamVerifier createCmdOutputVerifier(Path wixSrcDir) {\n+            return TKit.assertTextStream(\"-loc \" + wixSrcDir.resolve(name));\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinL10nTest.java","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+\/* @test\n+ * @bug 8289771\n+ * @summary jpackage with long paths on windows\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @requires (os.family == \"windows\")\n+ * @compile WinLongPathTest.java\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-space-subst=*\n+ *  --jpt-exclude=WinLongPathTest(false,*--temp)\n+ *  --jpt-run=WinLongPathTest\n+ *\/\n+\n+public record WinLongPathTest(Boolean appImage, String optionName) {\n+\n+    @Parameters\n+    public static List<Object[]> input() {\n+        List<Object[]> data = new ArrayList<>();\n+        for (var appImage : List.of(Boolean.TRUE, Boolean.FALSE)) {\n+            for (var option : List.of(\"--dest\", \"--temp\")) {\n+                data.add(new Object[]{appImage, option});\n+            }\n+        }\n+        return data;\n+    }\n+\n+    @Test\n+    public void test() throws IOException {\n+        if (appImage) {\n+            var cmd = JPackageCommand.helloAppImage();\n+            setOptionLongPath(cmd, optionName);\n+            cmd.executeAndAssertHelloAppImageCreated();\n+        } else {\n+            new PackageTest()\n+                    .forTypes(PackageType.WINDOWS)\n+                    .configureHelloApp()\n+                    .addInitializer(cmd -> setOptionLongPath(cmd, optionName))\n+                    .run(Action.CREATE_AND_UNPACK);\n+        }\n+    }\n+\n+    private static void setOptionLongPath(JPackageCommand cmd, String option) throws IOException {\n+        var root = TKit.createTempDirectory(\"long-path\");\n+        \/\/ 261 characters in total, which alone is above the 260 threshold\n+        var longPath = root.resolve(Path.of(\"a\".repeat(80), \"b\".repeat(90), \"c\".repeat(91)));\n+        Files.createDirectories(longPath);\n+        cmd.setArgumentValue(option, longPath);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinLongPathTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"}]}