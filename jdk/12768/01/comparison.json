{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/g1\/g1FullGCResetMetadataTask.hpp\"\n@@ -120,0 +121,1 @@\n+    _has_compaction_targets(false),\n@@ -210,1 +212,2 @@\n-  phase3_adjust_pointers();\n+  if (has_compaction_targets()) {\n+    phase3_adjust_pointers();\n@@ -212,1 +215,6 @@\n-  phase4_do_compaction();\n+    phase4_do_compaction();\n+  } else {\n+    log_info(gc, phases) (\"No Regions selected for compaction. Skipping Phase 3: Adjust pointers and Phase 4: Compact heap\");\n+  }\n+\n+  phase5_reset_metadata();\n@@ -325,0 +333,5 @@\n+  if (!has_compaction_targets()) {\n+    log_debug(gc, phases)(\"Phase 2: No compaction targets\");\n+    return;\n+  }\n+\n@@ -360,5 +373,0 @@\n-  if (lowest_current == (uint)-1) {\n-    \/\/ worker compaction points are empty\n-    return lowest_current;\n-  }\n-\n@@ -389,3 +397,1 @@\n-  if (start_serial >= _heap->max_reserved_regions()) {\n-    return;\n-  }\n+  assert(start_serial < _heap->max_reserved_regions(), \"Called on empty parallel compaction queues\");\n@@ -434,0 +440,7 @@\n+void G1FullCollector::phase5_reset_metadata() {\n+  \/\/ Clear region metadata that is invalid after GC for all regions.\n+  GCTraceTime(Info, gc, phases) info(\"Phase 5: Reset Metadata\", scope()->timer());\n+  G1FullGCResetMetadataTask task(this);\n+  run_task(&task);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  bool                      _has_compaction_targets;\n@@ -140,0 +141,3 @@\n+  inline void set_has_compaction_targets();\n+  inline bool has_compaction_targets() const;\n+\n@@ -152,0 +156,1 @@\n+  void phase5_reset_metadata();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,10 @@\n+void G1FullCollector::set_has_compaction_targets() {\n+  if (!_has_compaction_targets) {\n+    _has_compaction_targets = true;\n+  }\n+}\n+\n+bool G1FullCollector::has_compaction_targets() const {\n+  return _has_compaction_targets;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,37 +37,0 @@\n-\/\/ Do work for all skip-compacting regions.\n-class G1ResetSkipCompactingClosure : public HeapRegionClosure {\n-  G1FullCollector* _collector;\n-\n-public:\n-  G1ResetSkipCompactingClosure(G1FullCollector* collector) : _collector(collector) { }\n-\n-  bool do_heap_region(HeapRegion* r) {\n-    uint region_index = r->hrm_index();\n-    \/\/ Only for skip-compaction regions; early return otherwise.\n-    if (!_collector->is_skip_compacting(region_index)) {\n-      return false;\n-    }\n-#ifdef ASSERT\n-    if (r->is_humongous()) {\n-      oop obj = cast_to_oop(r->humongous_start_region()->bottom());\n-      assert(_collector->mark_bitmap()->is_marked(obj), \"must be live\");\n-    } else if (r->is_open_archive()) {\n-      bool is_empty = (_collector->live_words(r->hrm_index()) == 0);\n-      assert(!is_empty, \"should contain at least one live obj\");\n-    } else if (r->is_closed_archive()) {\n-      \/\/ should early-return above\n-      ShouldNotReachHere();\n-    } else {\n-      assert(_collector->live_words(region_index) > _collector->scope()->region_compaction_threshold(),\n-             \"should be quite full\");\n-    }\n-#endif\n-    assert(_collector->compaction_top(r) == nullptr,\n-           \"region %u compaction_top \" PTR_FORMAT \" must not be different from bottom \" PTR_FORMAT,\n-           r->hrm_index(), p2i(_collector->compaction_top(r)), p2i(r->bottom()));\n-\n-    r->reset_skip_compacting_after_full_gc();\n-    return false;\n-  }\n-};\n-\n@@ -127,4 +90,0 @@\n-\n-  G1ResetSkipCompactingClosure hc(collector());\n-  G1CollectedHeap::heap()->heap_region_par_iterate_from_worker_offset(&hc, &_claimer, worker_id);\n-  log_task(\"Compaction task\", worker_id, start);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":1,"deletions":42,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,6 +98,0 @@\n-\n-  \/\/ Clear region metadata that is invalid after GC for all regions.\n-  {\n-    G1ResetMetadataClosure closure(collector());\n-    G1CollectedHeap::heap()->heap_region_par_iterate_from_start(&closure, &_hrclaimer);\n-  }\n@@ -114,24 +108,0 @@\n-G1FullGCPrepareTask::G1ResetMetadataClosure::G1ResetMetadataClosure(G1FullCollector* collector) :\n-  _g1h(G1CollectedHeap::heap()),\n-  _collector(collector) { }\n-\n-void G1FullGCPrepareTask::G1ResetMetadataClosure::reset_region_metadata(HeapRegion* hr) {\n-  hr->rem_set()->clear();\n-  hr->clear_cardtable();\n-}\n-\n-bool G1FullGCPrepareTask::G1ResetMetadataClosure::do_heap_region(HeapRegion* hr) {\n-  uint const region_idx = hr->hrm_index();\n-  if (!_collector->is_compaction_target(region_idx)) {\n-    assert(!hr->is_free(), \"all free regions should be compaction targets\");\n-    assert(_collector->is_skip_compacting(region_idx) || hr->is_closed_archive(), \"must be\");\n-    if (hr->needs_scrubbing_during_full_gc()) {\n-      scrub_skip_compacting_region(hr, hr->is_young());\n-    }\n-  }\n-\n-  \/\/ Reset data structures not valid after Full GC.\n-  reset_region_metadata(hr);\n-\n-  return false;\n-}\n@@ -154,28 +124,0 @@\n-\n-void G1FullGCPrepareTask::G1ResetMetadataClosure::scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live) {\n-  assert(hr->needs_scrubbing_during_full_gc(), \"must be\");\n-\n-  HeapWord* limit = hr->top();\n-  HeapWord* current_obj = hr->bottom();\n-  G1CMBitMap* bitmap = _collector->mark_bitmap();\n-\n-  while (current_obj < limit) {\n-    if (bitmap->is_marked(current_obj)) {\n-      oop current = cast_to_oop(current_obj);\n-      size_t size = current->size();\n-      if (update_bot_for_live) {\n-        hr->update_bot_for_block(current_obj, current_obj + size);\n-      }\n-      current_obj += size;\n-      continue;\n-    }\n-    \/\/ Found dead object, which is potentially unloaded, scrub to next\n-    \/\/ marked object.\n-    HeapWord* scrub_start = current_obj;\n-    HeapWord* scrub_end = bitmap->get_next_marked_addr(scrub_start, limit);\n-    assert(scrub_start != scrub_end, \"must advance\");\n-    hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n-\n-    current_obj = scrub_end;\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":1,"deletions":59,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -93,16 +93,0 @@\n-  class G1ResetMetadataClosure : public HeapRegionClosure {\n-    G1CollectedHeap* _g1h;\n-    G1FullCollector* _collector;\n-\n-    void reset_region_metadata(HeapRegion* hr);\n-    \/\/ Scrub all runs of dead objects within the given region by putting filler\n-    \/\/ objects and updating the corresponding BOT. If update_bot_for_live is true,\n-    \/\/ also update the BOT for live objects.\n-    void scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live);\n-\n-  public:\n-    G1ResetMetadataClosure(G1FullCollector* collector);\n-\n-    bool do_heap_region(HeapRegion* hr);\n-  };\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+  _collector->set_has_compaction_targets();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1FullCollector.inline.hpp\"\n+#include \"gc\/g1\/g1FullGCResetMetadataTask.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+G1FullGCResetMetadataTask::G1ResetMetadataClosure::G1ResetMetadataClosure(G1FullCollector* collector) :\n+  _g1h(G1CollectedHeap::heap()),\n+  _collector(collector) { }\n+\n+void G1FullGCResetMetadataTask::G1ResetMetadataClosure::reset_region_metadata(HeapRegion* hr) {\n+  hr->rem_set()->clear();\n+  hr->clear_cardtable();\n+}\n+\n+bool G1FullGCResetMetadataTask::G1ResetMetadataClosure::do_heap_region(HeapRegion* hr) {\n+  uint const region_idx = hr->hrm_index();\n+  if (!_collector->is_compaction_target(region_idx)) {\n+    assert(!hr->is_free(), \"all free regions should be compaction targets\");\n+    assert(_collector->is_skip_compacting(region_idx) || hr->is_closed_archive(), \"must be\");\n+    if (hr->needs_scrubbing_during_full_gc()) {\n+      scrub_skip_compacting_region(hr, hr->is_young());\n+    }\n+    if (_collector->is_skip_compacting(region_idx)) {\n+      reset_skip_compacting(hr);\n+    }\n+  }\n+  \/\/ Reset data structures not valid after Full GC.\n+  reset_region_metadata(hr);\n+\n+  return false;\n+}\n+\n+void G1FullGCResetMetadataTask::G1ResetMetadataClosure::scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live) {\n+  assert(hr->needs_scrubbing_during_full_gc(), \"must be\");\n+\n+  HeapWord* limit = hr->top();\n+  HeapWord* current_obj = hr->bottom();\n+  G1CMBitMap* bitmap = _collector->mark_bitmap();\n+\n+  while (current_obj < limit) {\n+    if (bitmap->is_marked(current_obj)) {\n+      oop current = cast_to_oop(current_obj);\n+      size_t size = current->size();\n+      if (update_bot_for_live) {\n+        hr->update_bot_for_block(current_obj, current_obj + size);\n+      }\n+      current_obj += size;\n+      continue;\n+    }\n+    \/\/ Found dead object, which is potentially unloaded, scrub to next\n+    \/\/ marked object.\n+    HeapWord* scrub_start = current_obj;\n+    HeapWord* scrub_end = bitmap->get_next_marked_addr(scrub_start, limit);\n+    assert(scrub_start != scrub_end, \"must advance\");\n+    hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n+\n+    current_obj = scrub_end;\n+  }\n+}\n+\n+void G1FullGCResetMetadataTask::G1ResetMetadataClosure::reset_skip_compacting(HeapRegion* hr) {\n+#ifdef ASSERT\n+  uint region_index = hr->hrm_index();\n+  assert(_collector->is_skip_compacting(region_index), \"Only call on is_skip_compacting regions\");\n+\n+  if (hr->is_humongous()) {\n+    oop obj = cast_to_oop(hr->humongous_start_region()->bottom());\n+    assert(_collector->mark_bitmap()->is_marked(obj), \"must be live\");\n+  } else if (hr->is_open_archive()) {\n+    bool is_empty = (_collector->live_words(hr->hrm_index()) == 0);\n+    assert(!is_empty, \"should contain at least one live obj\");\n+  } else if (hr->is_closed_archive()) {\n+    \/\/ should early-return above\n+    ShouldNotReachHere();\n+  } else {\n+    assert(_collector->live_words(region_index) > _collector->scope()->region_compaction_threshold(),\n+           \"should be quite full\");\n+  }\n+\n+  assert(_collector->compaction_top(hr) == nullptr,\n+         \"region %u compaction_top \" PTR_FORMAT \" must not be different from bottom \" PTR_FORMAT,\n+         hr->hrm_index(), p2i(_collector->compaction_top(hr)), p2i(hr->bottom()));\n+#endif\n+  hr->reset_skip_compacting_after_full_gc();\n+}\n+\n+void G1FullGCResetMetadataTask::work(uint worker_id) {\n+  Ticks start = Ticks::now();\n+  G1ResetMetadataClosure hc(collector());\n+  G1CollectedHeap::heap()->heap_region_par_iterate_from_worker_offset(&hc, &_claimer, worker_id);\n+\n+  log_task(\"Reset Metadata task\", worker_id, start);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.cpp","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1FULLGCRESETMETADATATASK_HPP\n+#define SHARE_GC_G1_G1FULLGCRESETMETADATATASK_HPP\n+#include \"gc\/g1\/g1FullGCTask.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+\n+class G1FullGCResetMetadataTask : public G1FullGCTask {\n+  G1FullCollector* _collector;\n+  HeapRegionClaimer _claimer;\n+\n+  class G1ResetMetadataClosure : public HeapRegionClosure {\n+    G1CollectedHeap* _g1h;\n+    G1FullCollector* _collector;\n+\n+    void reset_region_metadata(HeapRegion* hr);\n+    \/\/ Scrub all runs of dead objects within the given region by putting filler\n+    \/\/ objects and updating the corresponding BOT. If update_bot_for_live is true,\n+    \/\/ also update the BOT for live objects.\n+    void scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live);\n+\n+    void reset_skip_compacting(HeapRegion* r);\n+\n+  public:\n+    G1ResetMetadataClosure(G1FullCollector* collector);\n+\n+    bool do_heap_region(HeapRegion* hr);\n+  };\n+\n+public:\n+  G1FullGCResetMetadataTask(G1FullCollector* collector) :\n+    G1FullGCTask(\"G1 Reset Metadata Task\", collector),\n+    _collector(collector),\n+    _claimer(collector->workers()) { }\n+\n+  void work(uint worker_id);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1FULLGCRESETMETADATATASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.hpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}