{"files":[{"patch":"@@ -130,0 +130,11 @@\n+\n+void VMError::check_narrow_klass_protzone_violation(outputStream* st, const void* siginfo) {\n+  if (UseCompressedClassPointers && CompressedKlassPointers::base() != nullptr && siginfo != nullptr) {\n+    const siginfo_t* const si = (siginfo_t*)siginfo;\n+    if (si->si_signo == SIGBUS || si->si_signo == SIGSEGV) {\n+      if ((address) si->si_addr == CompressedKlassPointers::base()) {\n+          st->print(\"Fault address is narrow Klass base - dereferencing a zero nKlass?\");\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -64,0 +64,11 @@\n+void VMError::check_narrow_klass_protzone_violation(outputStream* st, const void* siginfo) {\n+  if (UseCompressedClassPointers && CompressedKlassPointers::base() != nullptr && siginfo != nullptr) {\n+    const EXCEPTION_RECORD* const er = (const EXCEPTION_RECORD*)siginfo;\n+    if (er->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {\n+      if ((address)(er->ExceptionInformation[1]) == CompressedKlassPointers::base()) {\n+          st->print(\"Fault address is narrow Klass base - dereferencing a zero nKlass?\");\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -386,3 +386,9 @@\n-    \/\/ We don't want any valid object to be at the very bottom of the archive.\n-    \/\/ See ArchivePtrMarker::mark_pointer().\n-    rw_region()->allocate(16);\n+    \/\/ At runtime, the start of the archive will be mapped to the start of the\n+    \/\/ encoding range. We don't want any valid Klass to be mapped at the very\n+    \/\/ bottom of the archive, since its address would translate to a narrow Klass\n+    \/\/ id of 0 (null).\n+    \/\/ In addition to that, we want to catch accidental dereferences of a decoded\n+    \/\/ narrow Klass id of 0. Therefore, we will protect the first page of the\n+    \/\/ archive, and here, we need to leave space for it.\n+    \/\/ See also ArchivePtrMarker::mark_pointer().\n+    rw_region()->allocate_protzone();\n@@ -1364,1 +1370,2 @@\n-  mapinfo->write_region(region_idx, dump_region->base(), dump_region->used(), read_only, allow_exec);\n+  mapinfo->write_region(region_idx, dump_region->base(), dump_region->used(),\n+                        read_only, allow_exec, dump_region->has_protzone());\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -253,0 +253,13 @@\n+void DumpRegion::allocate_protzone() {\n+  assert(_base == _top, \"must be the first allocation in this region\");\n+  \/\/ We allocate a protection zone of core alignment size, not page size. The reason\n+  \/\/ is that the page size may differ between dump- and runtime, and the job of\n+  \/\/ core alignment is to hide this difference at runtime. See also \"compatible-cds-alignment\".\n+  const size_t protzone_size = MetaspaceShared::core_region_alignment();\n+  char* const p = allocate(protzone_size);\n+  assert(p != nullptr, \"failed to allocate no-access zone\");\n+  log_debug(cds)(\"Allocated protection zone at top of dump region (\" RANGEFMT \")\",\n+                 RANGEFMTARGS(p, protzone_size));\n+  _has_protzone = true;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+  bool _has_protzone;\n@@ -159,1 +160,2 @@\n-      _max_delta(max_delta), _is_packed(false) {}\n+      _max_delta(max_delta), _is_packed(false),\n+      _has_protzone(0), _rs(nullptr), _vs(nullptr) {}\n@@ -175,0 +177,2 @@\n+  bool has_protzone() const { return _has_protzone; }\n+  void allocate_protzone();\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1438,1 +1438,1 @@\n-                         bool allow_exec, int crc) {\n+                         bool allow_exec, bool has_protzone, int crc) {\n@@ -1445,0 +1445,1 @@\n+  _has_protzone = has_protzone;\n@@ -1514,0 +1515,1 @@\n+  st->print_cr(\"- has_protzone:                   %d\", _has_protzone);\n@@ -1528,1 +1530,1 @@\n-                               bool read_only, bool allow_exec) {\n+                               bool read_only, bool allow_exec, bool has_protzone) {\n@@ -1563,3 +1565,4 @@\n-                   \" bytes, addr \" INTPTR_FORMAT \" file offset 0x%08\" PRIxPTR\n-                   \" crc 0x%08x\",\n-                   region_name(region), region, size, p2i(requested_base), _file_offset, crc);\n+                   \" bytes, addr \" INTPTR_FORMAT \", file offset 0x%08\" PRIxPTR \",\"\n+                   \" exec %d, protzone %d, crc 0x%08x\",\n+                   region_name(region), region, size, p2i(requested_base), _file_offset,\n+                   allow_exec, has_protzone, crc);\n@@ -1568,1 +1571,1 @@\n-  r->init(region, mapping_offset, size, read_only, allow_exec, crc);\n+  r->init(region, mapping_offset, size, read_only, allow_exec, has_protzone, crc);\n@@ -1643,1 +1646,2 @@\n-  write_region(MetaspaceShared::bm, (char*)buffer, size_in_bytes, \/*read_only=*\/true, \/*allow_exec=*\/false);\n+  write_region(MetaspaceShared::bm, (char*)buffer,\n+               size_in_bytes, \/*read_only=*\/true, \/*allow_exec=*\/false, \/*has_protzone=*\/false);\n@@ -1650,1 +1654,1 @@\n-  write_region(MetaspaceShared::hp, buffer_start, buffer_size, false, false);\n+  write_region(MetaspaceShared::hp, buffer_start, buffer_size, false, false, false);\n@@ -1826,0 +1830,1 @@\n+  assert(mapped_base_address != nullptr, \"sanity\");\n@@ -1858,1 +1863,0 @@\n-      return MAP_ARCHIVE_SUCCESS;\n@@ -1880,0 +1884,1 @@\n+  }\n@@ -1881,1 +1886,7 @@\n-    return MAP_ARCHIVE_SUCCESS;\n+  \/\/ After mapping successfully, protect no-access zone if one exists\n+  if (r->has_protzone()) {\n+    assert(requested_addr == mapped_base_address,\n+           \"This should only happen for the very first region in the archive\");\n+    const size_t protzone_len = MetaspaceShared::core_region_alignment();\n+    os::protect_memory(requested_addr, protzone_len, os::MEM_PROT_NONE, true);\n+    log_info(cds)(\"Protected no-access zone (CDS): \" RANGEFMT, RANGEFMTARGS(requested_addr, protzone_len));\n@@ -1883,0 +1894,2 @@\n+\n+  return MAP_ARCHIVE_SUCCESS;\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+  bool   has_protzone()             const { return _has_protzone != 0; }\n@@ -168,1 +169,1 @@\n-            bool allow_exec, int crc);\n+            bool allow_exec, bool has_protzone, int crc);\n@@ -447,1 +448,1 @@\n-                     bool read_only, bool allow_exec);\n+                     bool read_only, bool allow_exec, bool has_protzone);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  int     _has_protzone;      \/\/ does the region have a leading protection zone?\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"memory\/metaspace\/metachunk.hpp\"\n@@ -68,0 +69,1 @@\n+using metaspace::Metachunk;\n@@ -715,3 +717,4 @@\n-    \/\/ If any of the archived space fails to map, UseSharedSpaces\n-    \/\/ is reset to false.\n-  }\n+    \/\/ If CDS initialization failed, UseSharedSpaces will have been reset to false,\n+    \/\/ no class space initialization will have happened, and we will execute the\n+    \/\/ branch below as fallback (proceeding without loading CDS archives).\n+  } \/\/ End: case (a)\n@@ -725,1 +728,1 @@\n-    \/\/ case (b) (No CDS)\n+    \/\/ case (b) (No CDS, or dumping archive)\n@@ -770,1 +773,1 @@\n-    \/\/ Mark class space as such\n+    \/\/ NMT: Mark class space as such\n@@ -778,1 +781,22 @@\n-  }\n+\n+    \/\/ At this point, narrow Klass encoding has been initialized, so we know the encoding\n+    \/\/ base. If we don't run zero-based, we must prevent a Klass from being placed at the\n+    \/\/ very start of the class space, since its nKlass would be 0, which is a reserved value.\n+    \/\/ We also protect the first page of this range, to easily catch accidental nKlass=0\n+    \/\/ dereferences.\n+    if (CompressedKlassPointers::base() != nullptr) {\n+      const size_t protzone_size = os::vm_page_size();\n+      const size_t protzone_wordsize = protzone_size \/ BytesPerWord;\n+      const metaspace::chunklevel_t lvl = metaspace::chunklevel::level_fitting_word_size(protzone_wordsize);\n+      \/\/ allocate chunk\n+      Metachunk* const chunk = MetaspaceContext::context_class()->cm()->get_chunk(lvl);\n+      const address protzone_base = (address) chunk->base();\n+      assert(protzone_base == CompressedKlassPointers::base(), \"Very first chunk should be located at class space\"\n+             \"start, hence at decoding base (\" PTR_FORMAT \")\", p2i(protzone_base));\n+      assert(chunk->word_size() == protzone_wordsize, \"Chunk should be exactly one page sized\");\n+      const bool prot = os::protect_memory((char*)protzone_base, protzone_size, os::MEM_PROT_NONE, false);\n+      assert(prot, \"Failed to memprotect the first page of metaspace\");\n+      log_info(metaspace)(\"Protected no-access zone (class space): \" RANGEFMT, RANGEFMTARGS(protzone_base, protzone_size));\n+    }\n+\n+  } \/\/ End: case (b)\n@@ -787,14 +811,0 @@\n-  \/\/ We must prevent the very first address of the ccs from being used to store\n-  \/\/ metadata, since that address would translate to a narrow pointer of 0, and the\n-  \/\/ VM does not distinguish between \"narrow 0 as in null\" and \"narrow 0 as in start\n-  \/\/  of ccs\".\n-  \/\/ Before Elastic Metaspace that did not happen due to the fact that every Metachunk\n-  \/\/ had a header and therefore could not allocate anything at offset 0.\n-#ifdef _LP64\n-  if (using_class_space()) {\n-    \/\/ The simplest way to fix this is to allocate a tiny dummy chunk right at the\n-    \/\/ start of ccs and do not use it for anything.\n-    MetaspaceContext::context_class()->cm()->get_chunk(metaspace::chunklevel::HIGHEST_CHUNK_LEVEL);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":30,"deletions":20,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1057,0 +1057,4 @@\n+  STEP_IF(\"suspected zero nKlass access\", _verbose && _siginfo != nullptr)\n+    check_narrow_klass_protzone_violation(st, _siginfo);\n+    st->cr();\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,0 +132,4 @@\n+  \/\/ Write a hint to the stream in case siginfo indicates an access to the\n+  \/\/ protection zone of the narrow Klass range.\n+  static void check_narrow_klass_protzone_violation(outputStream* st, const void* siginfo);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=with-cds\n+ * @summary Test that the start of the narrow Klass range is protected with a no-access zone\n+ * @requires vm.bits == 64\n+ * @requires vm.flagless\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver KlassRangeProtZoneTest true\n+ *\/\n+\n+\/*\n+ * @test id=no-cds\n+ * @summary Test that the start of the narrow Klass range is protected with a no-access zone\n+ * @requires vm.bits == 64\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver KlassRangeProtZoneTest false\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+\n+public class KlassRangeProtZoneTest {\n+\n+    private static void do_test_no_cds() throws IOException {\n+        \/\/ In the non-CDS case, we fix the position of the class space to one that inhibits\n+        \/\/ zero-based encoding, (only then a protection zone is established.\n+        long tryAddresses[] = {\n+                0x8_0000_0000L, 0x10_0000_0000L, 0x80_0000_0000L\n+        };\n+\n+        boolean reservedOk = false;\n+\n+        for (long base : tryAddresses) {\n+            String hexBase = \"0x\" + String.format(\"%1$016x\", base);\n+            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                    \"-Xshare:off\",\n+                    \"-Xmx128m\",\n+                    \"-XX:CompressedClassSpaceBaseAddress=\" + hexBase,\n+                    \"-Xlog:metaspace*\",\n+                    \"-version\");\n+            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            reservedOk = output.contains(\"Successfully forced class space address to \" + hexBase);\n+            if (reservedOk) {\n+                \/\/ Example Output:\n+                \/\/ [0.015s][info][metaspace] Successfully forced class space address to 0x0000008000000000\n+                \/\/ [0.015s][info][metaspace] Protected no-access zone (class space): [0x0000008000000000 - 0x0000008000004000), (16384 bytes)\n+                \/\/ [0.015s][info][gc,metaspace] CDS archive(s) not mapped\n+                \/\/ [0.015s][info][gc,metaspace] Compressed class space mapped at: 0x0000008000000000-0x0000008040000000, reserved size: 1073741824\n+                \/\/ [0.015s][info][gc,metaspace] Narrow klass base: 0x0000008000000000, Narrow klass shift: 0, Narrow klass range: 0x40000000\n+                output.shouldContain(\"Protected no-access zone (class space): [\" + hexBase);\n+                output.shouldContain(\"Narrow klass base: \" + hexBase);\n+                \/\/ We are done.\n+                break;\n+            }\n+        }\n+    }\n+\n+    private static void do_test_cds() throws IOException {\n+        \/\/ In the non-CDS case, CompressedClassSpaceBaseAddress won't work, nor would it be necessary, since\n+        \/\/ with CDS we never do zero-based encoding. We must, however, monitor which address (randomly chosen)\n+        \/\/ CDS attaches the archive to.\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-Xshare:on\",\n+                \"-Xmx128m\",\n+                \"-Xlog:metaspace*\",\n+                \"-Xlog:cds\",\n+                \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        \/\/ Example Output:\n+        \/\/ [0.021s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x000007f000000000-0x000007f000d78000-0x000007f000d78000), size 14123008, SharedBaseAddress: 0x000007f000000000, ArchiveRelocationMode: 1.\n+        \/\/ [0.021s][info   ][gc,metaspace] Compressed class space mapped at: 0x000007f001000000-0x000007f041000000, reserved size: 1073741824\n+        \/\/ [0.021s][info   ][gc,metaspace] Narrow klass base: 0x000007f000000000, Narrow klass shift: 0, Narrow klass range: 0x100000000\n+        String hexBase = output.firstMatch(\"CDS archive\\\\(s\\\\) mapped at: \\\\[(0x[\\\\w]+)\", 1);\n+        output.shouldContain(\"Protected no-access zone (CDS): [\" + hexBase);\n+        output.shouldContain(\"Narrow klass base: \" + hexBase);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Expected 1 argument\");\n+        }\n+        boolean with_cds = Boolean.parseBoolean(args[0]);\n+        if (with_cds) {\n+            do_test_cds();\n+        } else {\n+            do_test_no_cds();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/KlassRangeProtZoneTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}