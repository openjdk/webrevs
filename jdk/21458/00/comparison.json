{"files":[{"patch":"@@ -45,0 +45,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -491,0 +493,2 @@\n+        requireNonNull(className);\n+        requireNonNull(constantName);\n@@ -509,0 +513,1 @@\n+        requireNonNull(className);\n@@ -525,0 +530,1 @@\n+        requireNonNull(value);\n@@ -541,0 +547,1 @@\n+        requireNonNull(value);\n@@ -557,0 +564,1 @@\n+        requireNonNull(value);\n@@ -573,0 +581,1 @@\n+        requireNonNull(value);\n@@ -589,0 +598,1 @@\n+        requireNonNull(value);\n@@ -605,0 +615,1 @@\n+        requireNonNull(value);\n@@ -621,0 +632,1 @@\n+        requireNonNull(value);\n@@ -637,0 +649,1 @@\n+        requireNonNull(value);\n@@ -653,0 +666,1 @@\n+        requireNonNull(value);\n@@ -670,0 +684,1 @@\n+        requireNonNull(value);\n@@ -787,1 +802,1 @@\n-        throw new IllegalArgumentException(\"Illegal annotation constant value type \" + (value == null ? null : value.getClass()));\n+        throw new IllegalArgumentException(\"Illegal annotation constant value type \" + requireNonNull(value).getClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -61,0 +63,1 @@\n+        requireNonNull(attr);\n@@ -79,0 +82,1 @@\n+        requireNonNull(attr);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AttributedElement.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -109,0 +111,1 @@\n+        requireNonNull(other);\n@@ -173,1 +176,1 @@\n-        return new ClassHierarchyImpl.ResourceParsingClassHierarchyResolver(classStreamResolver);\n+        return new ClassHierarchyImpl.ResourceParsingClassHierarchyResolver(requireNonNull(classStreamResolver));\n@@ -184,0 +187,1 @@\n+        requireNonNull(loader);\n@@ -213,0 +217,1 @@\n+        requireNonNull(loader);\n@@ -235,0 +240,1 @@\n+        requireNonNull(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassHierarchyResolver.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -66,1 +68,1 @@\n-        return new TransformImpl.SupplierClassTransform(supplier);\n+        return new TransformImpl.SupplierClassTransform(requireNonNull(supplier));\n@@ -77,0 +79,1 @@\n+        requireNonNull(finisher);\n@@ -98,0 +101,1 @@\n+        requireNonNull(filter);\n@@ -114,1 +118,1 @@\n-        return new TransformImpl.ClassMethodTransform(xform, filter);\n+        return new TransformImpl.ClassMethodTransform(requireNonNull(xform), requireNonNull(filter));\n@@ -125,1 +129,1 @@\n-        return transformingMethods(mm -> true, xform);\n+        return transformingMethods(_ -> true, xform);\n@@ -160,1 +164,1 @@\n-        return new TransformImpl.ClassFieldTransform(xform, f -> true);\n+        return new TransformImpl.ClassFieldTransform(requireNonNull(xform), _ -> true);\n@@ -172,1 +176,1 @@\n-        return new TransformImpl.ChainedClassTransform(this, t);\n+        return new TransformImpl.ChainedClassTransform(this, requireNonNull(t));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassTransform.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -64,1 +66,1 @@\n-        return new TransformImpl.SupplierCodeTransform(supplier);\n+        return new TransformImpl.SupplierCodeTransform(requireNonNull(supplier));\n@@ -75,0 +77,1 @@\n+        requireNonNull(finisher);\n@@ -97,1 +100,1 @@\n-        return new TransformImpl.ChainedCodeTransform(this, t);\n+        return new TransformImpl.ChainedCodeTransform(this, requireNonNull(t));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeTransform.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -65,1 +67,1 @@\n-        return new TransformImpl.SupplierFieldTransform(supplier);\n+        return new TransformImpl.SupplierFieldTransform(requireNonNull(supplier));\n@@ -76,0 +78,1 @@\n+        requireNonNull(finisher);\n@@ -97,0 +100,1 @@\n+        requireNonNull(filter);\n@@ -112,1 +116,1 @@\n-        return new TransformImpl.ChainedFieldTransform(this, t);\n+        return new TransformImpl.ChainedFieldTransform(this, requireNonNull(t));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldTransform.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -65,0 +67,1 @@\n+        requireNonNull(supplier);\n@@ -76,0 +79,1 @@\n+        requireNonNull(finisher);\n@@ -97,0 +101,1 @@\n+        requireNonNull(filter);\n@@ -111,1 +116,1 @@\n-        return new TransformImpl.MethodCodeTransform(xform);\n+        return new TransformImpl.MethodCodeTransform(requireNonNull(xform));\n@@ -123,1 +128,1 @@\n-        return new TransformImpl.ChainedMethodTransform(this, t);\n+        return new TransformImpl.ChainedMethodTransform(this, requireNonNull(t));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodTransform.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -67,0 +69,1 @@\n+        requireNonNull(classMap);\n@@ -78,1 +81,1 @@\n-        return new ClassRemapperImpl(mapFunction);\n+        return new ClassRemapperImpl(requireNonNull(mapFunction));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/ClassRemapper.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -65,0 +67,1 @@\n+        requireNonNull(map);\n@@ -75,1 +78,1 @@\n-        return new CodeRelabelerImpl(mapFunction);\n+        return new CodeRelabelerImpl(requireNonNull(mapFunction));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/CodeRelabeler.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import jdk.internal.loader.ClassLoaders;\n@@ -374,1 +375,2 @@\n-        return ClassFile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader)))\n+        return ClassFile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader == null ?\n+                        ClassLoaders.platformClassLoader() : loader)))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -250,0 +252,3 @@\n+        public SwitchCaseImpl {\n+            requireNonNull(target);\n+        }\n@@ -895,1 +900,1 @@\n-            this.target = target;\n+            this.target = requireNonNull(target);\n@@ -922,1 +927,1 @@\n-            this.defaultTarget = defaultTarget;\n+            this.defaultTarget = requireNonNull(defaultTarget);\n@@ -958,1 +963,1 @@\n-            this.defaultTarget = defaultTarget;\n+            this.defaultTarget = requireNonNull(defaultTarget);\n@@ -1033,1 +1038,1 @@\n-            this.fieldEntry = fieldEntry;\n+            this.fieldEntry = requireNonNull(fieldEntry);\n@@ -1058,1 +1063,1 @@\n-            this.methodEntry = methodEntry;\n+            this.methodEntry = requireNonNull(methodEntry);\n@@ -1098,1 +1103,1 @@\n-            this.indyEntry = indyEntry;\n+            this.indyEntry = requireNonNull(indyEntry);\n@@ -1123,1 +1128,1 @@\n-            this.classEntry = classEntry;\n+            this.classEntry = requireNonNull(classEntry);\n@@ -1148,1 +1153,1 @@\n-            this.typeKind = typeKind;\n+            this.typeKind = requireNonNull(typeKind);\n@@ -1173,1 +1178,1 @@\n-            this.componentTypeEntry = componentTypeEntry;\n+            this.componentTypeEntry = requireNonNull(componentTypeEntry);\n@@ -1200,1 +1205,1 @@\n-            this.arrayTypeEntry = arrayTypeEntry;\n+            this.arrayTypeEntry = requireNonNull(arrayTypeEntry);\n@@ -1258,1 +1263,1 @@\n-            this.typeEntry = typeEntry;\n+            this.typeEntry = requireNonNull(typeEntry);\n@@ -1360,1 +1365,1 @@\n-            this.constant = constant;\n+            this.constant = requireNonNull(constant);\n@@ -1408,1 +1413,1 @@\n-            this.target = target;\n+            this.target = requireNonNull(target);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -442,1 +444,1 @@\n-                    return stringValue.equals(s);\n+                    return stringValue.equals(requireNonNull(s));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -58,3 +60,3 @@\n-            this.handler = handler;\n-            this.tryStart = tryStart;\n-            this.tryEnd = tryEnd;\n+            this.handler = requireNonNull(handler);\n+            this.tryStart = requireNonNull(tryStart);\n+            this.tryEnd = requireNonNull(tryEnd);\n@@ -65,4 +67,1 @@\n-            this.catchTypeEntry = catchTypeEntry.orElse(null);\n-            this.handler = handler;\n-            this.tryStart = tryStart;\n-            this.tryEnd = tryEnd;\n+            this(handler, tryStart, tryEnd, catchTypeEntry.orElse(null));\n@@ -118,2 +117,2 @@\n-            this.startScope = startScope;\n-            this.endScope = endScope;\n+            this.startScope = requireNonNull(startScope);\n+            this.endScope = requireNonNull(endScope);\n@@ -168,4 +167,4 @@\n-            this.name = name;\n-            this.descriptor = descriptor;\n-            this.startScope = startScope;\n-            this.endScope = endScope;\n+            this.name = requireNonNull(name);\n+            this.descriptor = requireNonNull(descriptor);\n+            this.startScope = requireNonNull(startScope);\n+            this.endScope = requireNonNull(endScope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -35,0 +37,1 @@\n+        requireNonNull(className);\n@@ -53,0 +56,5 @@\n+        public AnnotationElementImpl {\n+            requireNonNull(name);\n+            requireNonNull(value);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -83,1 +85,1 @@\n-        parent.with(element);\n+        parent.with(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -124,1 +126,1 @@\n-        elements.add(element);\n+        elements.add(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -52,2 +54,2 @@\n-        this.name = name;\n-        this.desc = type;\n+        this.name = requireNonNull(name);\n+        this.desc = requireNonNull(type);\n@@ -64,1 +66,1 @@\n-        elements.add(element);\n+        elements.add(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -66,2 +68,2 @@\n-        this.name = nameInfo;\n-        this.desc = typeInfo;\n+        this.name = requireNonNull(nameInfo);\n+        this.desc = requireNonNull(typeInfo);\n@@ -74,1 +76,1 @@\n-        elements.add(element);\n+        elements.add(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -466,1 +467,1 @@\n-        Objects.requireNonNull(opcode);\n+        requireNonNull(opcode);\n@@ -554,1 +555,1 @@\n-        throw new UnsupportedOperationException(\"not yet: \" + constantValue);\n+        throw new UnsupportedOperationException(\"not yet: \" + requireNonNull(constantValue));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -50,1 +52,1 @@\n-        consumer.accept(element);\n+        consumer.accept(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -62,1 +64,1 @@\n-        consumer.accept(element);\n+        consumer.accept(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedCodeBuilder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -53,1 +55,1 @@\n-        consumer.accept(element);\n+        consumer.accept(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedFieldBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -51,1 +53,1 @@\n-        consumer.accept(element);\n+        consumer.accept(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedMethodBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -126,1 +128,1 @@\n-                throw new IllegalArgumentException(\"Invalid option: \" + o);\n+                throw new IllegalArgumentException(\"Invalid option: \" + requireNonNull(o));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-                map.put(e.getKey(), ClassHierarchyInfo.ofClass(e.getValue()));\n+                map.put(requireNonNull(e.getKey()), ClassHierarchyInfo.ofClass(e.getValue()));\n@@ -210,1 +210,1 @@\n-                map.put(i, ClassHierarchyInfo.ofInterface());\n+                map.put(requireNonNull(i), ClassHierarchyInfo.ofInterface());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -567,0 +568,1 @@\n+        requireNonNull(verbosity); \/\/ we are using == checks in implementations\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,0 @@\n-        if (desc == null) return null;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -31,3 +30,0 @@\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.reflect.AccessFlag;\n-import java.util.ArrayList;\n@@ -53,0 +49,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -90,1 +88,1 @@\n-            writeAttribute((CustomAttribute<?>) element);\n+            writeAttribute((CustomAttribute<?>) requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -150,1 +151,1 @@\n-            writeAttribute((CustomAttribute<?>) element);\n+            writeAttribute((CustomAttribute<?>) requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -51,2 +53,2 @@\n-        this.name = name;\n-        this.desc = type;\n+        this.name = requireNonNull(name);\n+        this.desc = requireNonNull(type);\n@@ -61,1 +63,1 @@\n-            writeAttribute((CustomAttribute<?>) element);\n+            writeAttribute((CustomAttribute<?>) requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -58,2 +60,2 @@\n-        this.name = nameInfo;\n-        this.desc = typeInfo;\n+        this.name = requireNonNull(nameInfo);\n+        this.desc = requireNonNull(typeInfo);\n@@ -117,1 +119,1 @@\n-            writeAttribute((CustomAttribute<?>) element);\n+            writeAttribute((CustomAttribute<?>) requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -125,0 +126,1 @@\n+        requireNonNull(other);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -252,0 +253,3 @@\n+        public ObjectVerificationTypeInfoImpl {\n+            requireNonNull(className);\n+        }\n@@ -277,0 +281,3 @@\n+        public UninitializedVerificationTypeInfoImpl {\n+            requireNonNull(newTarget);\n+        }\n@@ -299,0 +306,1 @@\n+            requireNonNull(target);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Objects;\n@@ -40,1 +39,0 @@\n-        Objects.requireNonNull(targetType);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TargetInfoImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import java.util.Objects;\n@@ -190,0 +191,1 @@\n+        Objects.requireNonNull(constantPool);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,0 +95,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -152,1 +154,1 @@\n-            this.entry = entry;\n+            this.entry = requireNonNull(entry);\n@@ -185,1 +187,1 @@\n-            this.signature = signature;\n+            this.signature = requireNonNull(signature);\n@@ -217,1 +219,1 @@\n-            this.annotationDefault = annotationDefault;\n+            this.annotationDefault = requireNonNull(annotationDefault);\n@@ -232,1 +234,1 @@\n-            this.sourceFile = sourceFile;\n+            this.sourceFile = requireNonNull(sourceFile);\n@@ -297,1 +299,1 @@\n-            this.classEntry = classEntry;\n+            this.classEntry = requireNonNull(classEntry);\n@@ -335,1 +337,1 @@\n-            this.moduleTarget = moduleTarget;\n+            this.moduleTarget = requireNonNull(moduleTarget);\n@@ -351,1 +353,1 @@\n-            this.mainClass = mainClass;\n+            this.mainClass = requireNonNull(mainClass);\n@@ -368,1 +370,1 @@\n-            this.algorithm = algorithm;\n+            this.algorithm = requireNonNull(algorithm);\n@@ -454,1 +456,1 @@\n-            this.hostEntry = hostEntry;\n+            this.hostEntry = requireNonNull(hostEntry);\n@@ -470,1 +472,1 @@\n-            this.idEntry = idEntry;\n+            this.idEntry = requireNonNull(idEntry);\n@@ -486,1 +488,1 @@\n-            this.idEntry = idEntry;\n+            this.idEntry = requireNonNull(idEntry);\n@@ -502,1 +504,1 @@\n-            this.contents = contents;\n+            this.contents = requireNonNull(contents);\n@@ -614,1 +616,7 @@\n-            this.elements = List.copyOf(elements);\n+            \/\/ deep copy\n+            var array = elements.toArray().clone();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = List.copyOf((List<?>) array[i]);\n+            }\n+\n+            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n@@ -687,1 +695,7 @@\n-            implements InnerClassInfo {}\n+            implements InnerClassInfo {\n+        public UnboundInnerClassInfo {\n+            requireNonNull(innerClass);\n+            requireNonNull(outerClass);\n+            requireNonNull(innerName);\n+        }\n+    }\n@@ -696,1 +710,6 @@\n-            implements LocalVariableInfo { }\n+            implements LocalVariableInfo {\n+        public UnboundLocalVariableInfo {\n+            requireNonNull(name);\n+            requireNonNull(type);\n+        }\n+    }\n@@ -702,1 +721,6 @@\n-            implements LocalVariableTypeInfo { }\n+            implements LocalVariableTypeInfo {\n+        public UnboundLocalVariableTypeInfo {\n+            requireNonNull(name);\n+            requireNonNull(signature);\n+        }\n+    }\n@@ -705,1 +729,5 @@\n-            implements MethodParameterInfo {}\n+            implements MethodParameterInfo {\n+        public UnboundMethodParameterInfo {\n+            requireNonNull(name);\n+        }\n+    }\n@@ -711,5 +739,3 @@\n-        public UnboundModuleExportInfo(PackageEntry exportedPackage, int exportsFlagsMask,\n-                                       List<ModuleEntry> exportsTo) {\n-            this.exportedPackage = exportedPackage;\n-            this.exportsFlagsMask = exportsFlagsMask;\n-            this.exportsTo = List.copyOf(exportsTo);\n+        public UnboundModuleExportInfo {\n+            requireNonNull(exportedPackage);\n+            exportsTo = List.copyOf(exportsTo);\n@@ -720,1 +746,6 @@\n-                                        byte[] hash) implements ModuleHashInfo { }\n+                                        byte[] hash) implements ModuleHashInfo {\n+        public UnboundModuleHashInfo {\n+            requireNonNull(moduleName);\n+            requireNonNull(hash);\n+        }\n+    }\n@@ -725,5 +756,3 @@\n-        public UnboundModuleOpenInfo(PackageEntry openedPackage, int opensFlagsMask,\n-                                     List<ModuleEntry> opensTo) {\n-            this.openedPackage = openedPackage;\n-            this.opensFlagsMask = opensFlagsMask;\n-            this.opensTo = List.copyOf(opensTo);\n+        public UnboundModuleOpenInfo {\n+            requireNonNull(openedPackage);\n+            opensTo = List.copyOf(opensTo);\n@@ -736,3 +765,3 @@\n-        public UnboundModuleProvideInfo(ClassEntry provides, List<ClassEntry> providesWith) {\n-            this.provides = provides;\n-            this.providesWith = List.copyOf(providesWith);\n+        public UnboundModuleProvideInfo {\n+            requireNonNull(provides);\n+            providesWith = List.copyOf(providesWith);\n@@ -744,1 +773,6 @@\n-            implements ModuleRequireInfo {}\n+            implements ModuleRequireInfo {\n+        public UnboundModuleRequiresInfo {\n+            requireNonNull(requires);\n+            requireNonNull(requiresVersion);\n+        }\n+    }\n@@ -750,4 +784,4 @@\n-        public UnboundRecordComponentInfo(Utf8Entry name, Utf8Entry descriptor, List<Attribute<?>> attributes) {\n-            this.name = name;\n-            this.descriptor = descriptor;\n-            this.attributes = List.copyOf(attributes);\n+        public UnboundRecordComponentInfo {\n+            requireNonNull(name);\n+            requireNonNull(descriptor);\n+            attributes = List.copyOf(attributes);\n@@ -762,0 +796,1 @@\n+            requireNonNull(targetInfo);\n@@ -763,0 +798,1 @@\n+            requireNonNull(annotation);\n@@ -789,1 +825,1 @@\n-            this.moduleName = moduleName;\n+            this.moduleName = requireNonNull(moduleName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":73,"deletions":37,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -0,0 +1,937 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8317356\n+ * @build testdata.* CorpusTest\n+ * @run junit\/othervm NullHostileTest\n+ *\/\n+\n+import java.io.*;\n+import java.lang.classfile.*;\n+import java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.CustomAttribute;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.components.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.*;\n+import java.lang.invoke.*;\n+import java.lang.reflect.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.*;\n+import java.util.*;\n+import java.util.Optional;\n+import java.util.function.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static jdk.internal.classfile.impl.ClassPrinterImpl.Style.FLOW;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.internal.classfile.impl.*;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.parallel.Execution;\n+import org.junit.jupiter.api.parallel.ExecutionMode;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+\/**\n+ * This test makes sure that public API classes under {@link java.lang.classfile} throws NPEs whenever\n+ * nulls are provided. The test looks at all the public methods in all the listed classes, and injects\n+ * values automatically. If an API takes a reference, the test will try to inject nulls. For APIs taking\n+ * either reference arrays, or collections, the framework will also generate additional <em>replacements<\/em>\n+ * (e.g. other than just replacing the array, or collection with null), such as an array or collection\n+ * with null elements. The test can be customized by adding\/removing classes to the {@link #CLASSES} array,\n+ * by adding\/removing default mappings for standard carrier types (see {@link #DEFAULT_VALUES} or by\n+ * adding\/removing custom replacements (see {@link #REPLACEMENT_VALUES}).\n+ * <p>\n+ *\/\n+@Execution(ExecutionMode.CONCURRENT)\n+class NullHostileTest {\n+\n+    private static final Set<String> OBJECT_METHODS = Stream.of(Object.class.getMethods())\n+            .map(Method::getName)\n+            .collect(Collectors.toSet());\n+\n+    private static final Set<String> TRANSFORM_USER_METHODS = Set.of(\"accept\", \"atStart\", \"atEnd\");\n+\n+    private static final Map<Class<?>, Object> DEFAULT_VALUES = new HashMap<>();\n+    private static final Map<Class<?>, Object[]> REPLACEMENT_VALUES = new HashMap<>();\n+\n+    static <Z> void addDefaultMapping(Class<Z> carrier, Z value) {\n+        DEFAULT_VALUES.putIfAbsent(carrier, value);\n+    }\n+\n+    @SafeVarargs\n+    static <Z> void addReplacements(Class<Z> carrier, Z... value) {\n+        REPLACEMENT_VALUES.putIfAbsent(carrier, value);\n+    }\n+\n+    static final Class<?>[] CLASSES = new Class<?>[]{\n+            AccessFlags.class,\n+            Annotation.class,\n+            AnnotationElement.class,\n+            AnnotationValue.class,\n+            AnnotationValue.OfEnum.class,\n+            AnnotationValue.OfClass.class,\n+            AnnotationValue.OfString.class,\n+            AnnotationValue.OfDouble.class,\n+            AnnotationValue.OfFloat.class,\n+            AnnotationValue.OfLong.class,\n+            AnnotationValue.OfInt.class,\n+            AnnotationValue.OfShort.class,\n+            AnnotationValue.OfChar.class,\n+            AnnotationValue.OfByte.class,\n+            AnnotationValue.OfBoolean.class,\n+            AnnotationValue.OfArray.class,\n+            AnnotationValue.OfConstant.class,\n+            AnnotationValue.OfAnnotation.class,\n+            Attribute.class,\n+            AttributeMapper.class,\n+            AttributeMapper.AttributeStability.class,\n+            AttributedElement.class,\n+            Attributes.class,\n+            BootstrapMethodEntry.class,\n+            BufWriter.class,\n+            ClassBuilder.class,\n+            ClassElement.class,\n+            ClassFile.class,\n+            Option.class,\n+            AttributesProcessingOption.class,\n+            ClassFile.StackMapsOption.class,\n+            ClassFile.ShortJumpsOption.class,\n+            LineNumbersOption.class,\n+            DebugElementsOption.class,\n+            DeadLabelsOption.class,\n+            DeadCodeOption.class,\n+            ConstantPoolSharingOption.class,\n+            ClassHierarchyResolverOption.class,\n+            AttributeMapperOption.class,\n+            ClassFileBuilder.class,\n+            ClassFileElement.class,\n+            ClassFileTransform.class,\n+            ClassFileVersion.class,\n+            ClassHierarchyResolver.class,\n+            ClassHierarchyResolver.ClassHierarchyInfo.class,\n+            ClassModel.class,\n+            ClassReader.class,\n+            ClassSignature.class,\n+            ClassTransform.class,\n+            CodeBuilder.class,\n+            CodeBuilder.CatchBuilder.class,\n+            CodeBuilder.BlockCodeBuilder.class,\n+            CodeElement.class,\n+            CodeModel.class,\n+            CodeTransform.class,\n+            CompoundElement.class,\n+            CustomAttribute.class,\n+            FieldBuilder.class,\n+            FieldElement.class,\n+            FieldModel.class,\n+            FieldTransform.class,\n+            Instruction.class,\n+            Interfaces.class,\n+            Label.class,\n+            MethodBuilder.class,\n+            MethodElement.class,\n+            MethodModel.class,\n+            MethodSignature.class,\n+            MethodTransform.class,\n+            Opcode.class,\n+            Opcode.Kind.class,\n+            PseudoInstruction.class,\n+            Signature.class,\n+            Signature.ArrayTypeSig.class,\n+            Signature.BaseTypeSig.class,\n+            Signature.TypeArg.class,\n+            Signature.TypeArg.Bounded.class,\n+            Signature.TypeArg.Bounded.WildcardIndicator.class,\n+            Signature.TypeArg.Unbounded.class,\n+            Signature.ClassTypeSig.class,\n+            Signature.ThrowableSig.class,\n+            Signature.TypeParam.class,\n+            Signature.TypeVarSig.class,\n+            Signature.RefTypeSig.class,\n+            Superclass.class,\n+            TypeAnnotation.class,\n+            TypeAnnotation.TargetInfo.class,\n+            TypeAnnotation.TypePathComponent.class,\n+            TypeAnnotation.TypePathComponent.Kind.class,\n+            TypeAnnotation.TypeArgumentTarget.class,\n+            TypeAnnotation.OffsetTarget.class,\n+            TypeAnnotation.CatchTarget.class,\n+            TypeAnnotation.LocalVarTargetInfo.class,\n+            TypeAnnotation.LocalVarTarget.class,\n+            TypeAnnotation.ThrowsTarget.class,\n+            TypeAnnotation.FormalParameterTarget.class,\n+            TypeAnnotation.EmptyTarget.class,\n+            TypeAnnotation.TypeParameterBoundTarget.class,\n+            TypeAnnotation.SupertypeTarget.class,\n+            TypeAnnotation.TypeParameterTarget.class,\n+            TypeAnnotation.TargetType.class,\n+            TypeKind.class,\n+            AnnotationDefaultAttribute.class,\n+            BootstrapMethodsAttribute.class,\n+            CharacterRangeInfo.class,\n+            CharacterRangeTableAttribute.class,\n+            CodeAttribute.class,\n+            CompilationIDAttribute.class,\n+            ConstantValueAttribute.class,\n+            DeprecatedAttribute.class,\n+            EnclosingMethodAttribute.class,\n+            ExceptionsAttribute.class,\n+            InnerClassInfo.class,\n+            InnerClassesAttribute.class,\n+            LineNumberInfo.class,\n+            LineNumberTableAttribute.class,\n+            LocalVariableInfo.class,\n+            LocalVariableTableAttribute.class,\n+            LocalVariableTypeInfo.class,\n+            LocalVariableTypeTableAttribute.class,\n+            MethodParameterInfo.class,\n+            ModuleAttribute.class,\n+            ModuleAttribute.ModuleAttributeBuilder.class,\n+            ModuleExportInfo.class,\n+            ModuleHashInfo.class,\n+            ModuleHashesAttribute.class,\n+            ModuleMainClassAttribute.class,\n+            ModuleOpenInfo.class,\n+            ModulePackagesAttribute.class,\n+            ModuleProvideInfo.class,\n+            ModuleRequireInfo.class,\n+            ModuleResolutionAttribute.class,\n+            ModuleTargetAttribute.class,\n+            NestHostAttribute.class,\n+            NestMembersAttribute.class,\n+            PermittedSubclassesAttribute.class,\n+            RecordAttribute.class,\n+            RecordComponentInfo.class,\n+            RuntimeInvisibleAnnotationsAttribute.class,\n+            RuntimeInvisibleParameterAnnotationsAttribute.class,\n+            RuntimeInvisibleTypeAnnotationsAttribute.class,\n+            RuntimeVisibleAnnotationsAttribute.class,\n+            RuntimeVisibleParameterAnnotationsAttribute.class,\n+            RuntimeVisibleTypeAnnotationsAttribute.class,\n+            SignatureAttribute.class,\n+            SourceDebugExtensionAttribute.class,\n+            SourceFileAttribute.class,\n+            SourceIDAttribute.class,\n+            StackMapFrameInfo.class,\n+            StackMapFrameInfo.UninitializedVerificationTypeInfo.class,\n+            StackMapFrameInfo.ObjectVerificationTypeInfo.class,\n+            StackMapFrameInfo.SimpleVerificationTypeInfo.class,\n+            StackMapFrameInfo.VerificationTypeInfo.class,\n+            StackMapTableAttribute.class,\n+            SyntheticAttribute.class,\n+            UnknownAttribute.class,\n+            ClassPrinter.class,\n+            ClassPrinter.Verbosity.class,\n+            ClassPrinter.MapNode.class,\n+            ClassPrinter.ListNode.class,\n+            ClassPrinter.LeafNode.class,\n+            ClassPrinter.Node.class,\n+            ClassRemapper.class,\n+            CodeLocalsShifter.class,\n+            CodeRelabeler.class,\n+            CodeStackTracker.class,\n+            AnnotationConstantValueEntry.class,\n+            ClassEntry.class,\n+            ConstantDynamicEntry.class,\n+            ConstantPool.class,\n+            ConstantPoolBuilder.class,\n+            ConstantPoolException.class,\n+            ConstantValueEntry.class,\n+            DoubleEntry.class,\n+            DynamicConstantPoolEntry.class,\n+            FieldRefEntry.class,\n+            FloatEntry.class,\n+            IntegerEntry.class,\n+            InterfaceMethodRefEntry.class,\n+            InvokeDynamicEntry.class,\n+            LoadableConstantEntry.class,\n+            LongEntry.class,\n+            MemberRefEntry.class,\n+            MethodHandleEntry.class,\n+            MethodRefEntry.class,\n+            MethodTypeEntry.class,\n+            ModuleEntry.class,\n+            NameAndTypeEntry.class,\n+            PackageEntry.class,\n+            PoolEntry.class,\n+            StringEntry.class,\n+            Utf8Entry.class,\n+            ArrayLoadInstruction.class,\n+            ArrayStoreInstruction.class,\n+            BranchInstruction.class,\n+            CharacterRange.class,\n+            ConstantInstruction.class,\n+            ConstantInstruction.LoadConstantInstruction.class,\n+            ConstantInstruction.ArgumentConstantInstruction.class,\n+            ConstantInstruction.IntrinsicConstantInstruction.class,\n+            ConvertInstruction.class,\n+            DiscontinuedInstruction.class,\n+            DiscontinuedInstruction.RetInstruction.class,\n+            DiscontinuedInstruction.JsrInstruction.class,\n+            ExceptionCatch.class,\n+            FieldInstruction.class,\n+            IncrementInstruction.class,\n+            InvokeDynamicInstruction.class,\n+            LabelTarget.class,\n+            LineNumber.class,\n+            LoadInstruction.class,\n+            LocalVariable.class,\n+            LocalVariableType.class,\n+            LookupSwitchInstruction.class,\n+            MonitorInstruction.class,\n+            NewMultiArrayInstruction.class,\n+            NewObjectInstruction.class,\n+            NewPrimitiveArrayInstruction.class,\n+            NewReferenceArrayInstruction.class,\n+            NopInstruction.class,\n+            OperatorInstruction.class,\n+            ReturnInstruction.class,\n+            StackInstruction.class,\n+            StoreInstruction.class,\n+            SwitchCase.class,\n+            TableSwitchInstruction.class,\n+            ThrowInstruction.class,\n+            TypeCheckInstruction.class\n+    };\n+\n+    private static final Set<String> EXCLUDE_LIST = Set.of(\n+            \/\/ explicit null-ok methods\n+            \"java.lang.classfile.CodeBuilder\/exceptionCatch(java.lang.classfile.Label,java.lang.classfile.Label,java.lang.classfile.Label,java.lang.classfile.constantpool.ClassEntry)\/3\/0\",\n+            \"java.lang.classfile.CodeBuilder$BlockCodeBuilder\/exceptionCatch(java.lang.classfile.Label,java.lang.classfile.Label,java.lang.classfile.Label,java.lang.classfile.constantpool.ClassEntry)\/3\/0\",\n+            \"java.lang.classfile.CodeBuilder$CatchBuilder\/catching(java.lang.constant.ClassDesc,java.util.function.Consumer)\/0\/0\",\n+            \"java.lang.classfile.CodeBuilder\/loadConstant(java.lang.constant.ConstantDesc)\/0\/0\",\n+            \"java.lang.classfile.CodeBuilder$BlockCodeBuilder\/loadConstant(java.lang.constant.ConstantDesc)\/0\/0\",\n+            \"java.lang.classfile.ClassHierarchyResolver$ClassHierarchyInfo\/ofClass(java.lang.constant.ClassDesc)\/0\/0\",\n+            \"java.lang.classfile.attribute.ModuleAttribute$ModuleAttributeBuilder\/moduleVersion(java.lang.String)\/0\/0\",\n+            \"java.lang.classfile.attribute.ModuleAttribute$ModuleAttributeBuilder\/requires(java.lang.constant.ModuleDesc,java.util.Collection,java.lang.String)\/2\/0\",\n+            \"java.lang.classfile.attribute.ModuleAttribute$ModuleAttributeBuilder\/requires(java.lang.constant.ModuleDesc,int,java.lang.String)\/2\/0\",\n+            \"java.lang.classfile.attribute.ModuleAttribute\/of(java.lang.classfile.constantpool.ModuleEntry,int,java.lang.classfile.constantpool.Utf8Entry,java.util.Collection,java.util.Collection,java.util.Collection,java.util.Collection,java.util.Collection)\/2\/0\",\n+            \"java.lang.classfile.attribute.ModuleRequireInfo\/of(java.lang.classfile.constantpool.ModuleEntry,int,java.lang.classfile.constantpool.Utf8Entry)\/2\/0\",\n+            \"java.lang.classfile.attribute.ModuleRequireInfo\/of(java.lang.constant.ModuleDesc,java.util.Collection,java.lang.String)\/2\/0\",\n+            \"java.lang.classfile.attribute.ModuleRequireInfo\/of(java.lang.constant.ModuleDesc,int,java.lang.String)\/2\/0\",\n+            \"java.lang.classfile.attribute.ModuleRequireInfo\/of(java.lang.classfile.constantpool.ModuleEntry,java.util.Collection,java.lang.classfile.constantpool.Utf8Entry)\/2\/0\",\n+            \"java.lang.classfile.Signature$ClassTypeSig\/of(java.lang.classfile.Signature$ClassTypeSig,java.lang.constant.ClassDesc,java.lang.classfile.Signature$TypeArg[])\/0\/0\",\n+            \"java.lang.classfile.Signature$ClassTypeSig\/of(java.lang.classfile.Signature$ClassTypeSig,java.lang.String,java.lang.classfile.Signature$TypeArg[])\/0\/0\",\n+            \"java.lang.classfile.Signature$TypeParam\/of(java.lang.String,java.lang.classfile.Signature$RefTypeSig,java.lang.classfile.Signature$RefTypeSig[])\/1\/0\",\n+            \"java.lang.classfile.BufWriter\/writeIndexOrZero(java.lang.classfile.constantpool.PoolEntry)\/0\/0\",\n+\n+            \/\/ only called by ClassFile API, users don't need to check nulls\n+            \"java.lang.classfile.AttributeMapper\/readAttribute(java.lang.classfile.AttributedElement,java.lang.classfile.ClassReader,int)\/0\/0\",\n+            \"java.lang.classfile.AttributeMapper\/readAttribute(java.lang.classfile.AttributedElement,java.lang.classfile.ClassReader,int)\/1\/0\",\n+\n+            \/\/ inherited Collection methods\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/remove(java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object,java.lang.Object)\/2\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/remove(java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/get(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/put(java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/put(java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/putAll(java.util.Map)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/putIfAbsent(java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/remove(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/sort(java.util.Comparator)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/indexOf(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/lastIndexOf(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/add(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/add(int,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/toArray(java.lang.Object[])\/0\/1\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/contains(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/addAll(int,java.util.Collection)\/1\/1\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/addAll(java.util.Collection)\/0\/1\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/remove(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/putIfAbsent(java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/compute(java.lang.Object,java.util.function.BiFunction)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/containsKey(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/computeIfAbsent(java.lang.Object,java.util.function.Function)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/containsValue(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/getOrDefault(java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/getOrDefault(java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/computeIfPresent(java.lang.Object,java.util.function.BiFunction)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/set(int,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/addFirst(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/addLast(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/removeAll(java.util.Collection)\/0\/1\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/retainAll(java.util.Collection)\/0\/1\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/containsAll(java.util.Collection)\/0\/1\",\n+            \/\/ inherited Throwable methods\n+            \"java.lang.classfile.constantpool.ConstantPoolException\/initCause(java.lang.Throwable)\/0\/0\"\n+    );\n+\n+    static {\n+        addDefaultMapping(char.class, (char) 0);\n+        addDefaultMapping(byte.class, (byte) 0);\n+        addDefaultMapping(short.class, (short) 0);\n+        addDefaultMapping(int.class, 0);\n+        addDefaultMapping(float.class, 0f);\n+        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(double.class, 0d);\n+        addDefaultMapping(boolean.class, true);\n+        addDefaultMapping(Enum.class, ClassFileFormatVersion.RELEASE_24);\n+        addDefaultMapping(Path.class, Path.of(\"nonExistent\"));\n+        addDefaultMapping(UnaryOperator.class, UnaryOperator.identity());\n+        addDefaultMapping(String.class, \"Hello!\");\n+        addDefaultMapping(Class.class, String.class);\n+        addDefaultMapping(Object.class, new Object());\n+        addDefaultMapping(List.class, List.of());\n+        addDefaultMapping(Consumer.class, _ -> {});\n+        addDefaultMapping(Supplier.class, () -> null);\n+        addDefaultMapping(ClassLoader.class, NullHostileTest.class.getClassLoader());\n+        addDefaultMapping(Function.class, Function.identity());\n+        addDefaultMapping(CharSequence.class, \"c\");\n+        addDefaultMapping(Collection.class, new ArrayList<>());\n+        addDefaultMapping(Map.class, Map.of());\n+        addDefaultMapping(MethodHandles.Lookup.class, MethodHandles.publicLookup());\n+        addDefaultMapping(Predicate.class, Predicate.not(_ -> false));\n+        BiFunction<Object, Object, Object> func = (_, _) -> 0;\n+        addDefaultMapping(BiFunction.class, func);\n+        addDefaultMapping(BiConsumer.class, (_, _) -> {});\n+        addDefaultMapping(IntFunction.class, _ -> 0);\n+        addDefaultMapping(PrintWriter.class, new PrintWriter(System.out,true));\n+        addDefaultMapping(PrintStream.class, new PrintStream(System.out,true));\n+    }\n+\n+    static {\n+        addReplacements(Collection.class, null, Stream.of(new Object[]{null}).collect(Collectors.toList()));\n+        addReplacements(List.class, null, Stream.of(new Object[]{null}).collect(Collectors.toList()));\n+        addReplacements(Set.class, null, Stream.of(new Object[]{null}).collect(Collectors.toSet()));\n+    }\n+\n+    @BeforeAll\n+    public static void getDefaultValues() throws IOException, URISyntaxException {\n+        for (var file : CorpusTest.corpus()) {\n+            var b = Files.readAllBytes(file);\n+            try {\n+                populateClassFileMappings(b);\n+            } catch (Exception e) {\n+                \/\/do nothing - some complains about Unmatched bit position 0x in some inner final classes\n+            }\n+        }\n+    }\n+    @ParameterizedTest\n+    @MethodSource(\"cases\")\n+    void testNulls(String testName, Method meth, Object receiver, Object[] args) {\n+        try {\n+            meth.invoke(receiver, args);\n+            fail(\"Method invocation completed normally\");\n+        } catch (InvocationTargetException ex) {\n+            var cause = ex.getCause();\n+            if (!(cause instanceof NullPointerException) && !(cause instanceof IllegalArgumentException)) {\n+                \/\/ sometimes default arguments are invalid, such as Opcode with bad type or primitive ClassDesc\n+                fail(\"Expected NPE or IAE but got others\", cause);\n+            }\n+        } catch (Throwable ex) {\n+            fail(\"Unexpected exception: \" + ex);\n+        }\n+    }\n+\n+    static Iterator<Object[]> cases() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (Class<?> clazz : CLASSES) {\n+            for (Method m : clazz.getMethods()) {\n+                if (OBJECT_METHODS.contains(m.getName())) continue;\n+                if (ClassFileTransform.class.isAssignableFrom(clazz) && TRANSFORM_USER_METHODS.contains(m.getName())) continue;\n+                if (Modifier.isStatic(m.getModifiers()) && m.getDeclaringClass() != clazz) continue; \/\/ parent class static methods\n+                boolean isStatic = (m.getModifiers() & Modifier.STATIC) != 0;\n+                List<Integer> refIndices = new ArrayList<>();\n+                var params = m.getParameters();\n+                for (int i = 0; i < m.getParameterCount(); i++) {\n+                    Class<?> param = params[i].getType();\n+                    if (!param.isPrimitive()) {\n+                        refIndices.add(i);\n+                    }\n+                }\n+                for (int i : refIndices) {\n+                    Object[] replacements = replacements(params[i].getType());\n+                    for (int r = 0; r < replacements.length; r++) {\n+                        String testName = clazz.getName() + \"\/\" + shortSig(m) + \"\/\" + i + \"\/\" + r;\n+                        if (EXCLUDE_LIST.contains(testName)) continue;\n+                        Object[] args = new Object[params.length];\n+                        for (int j = 0; j < params.length; j++) {\n+                            args[j] = defaultValue(params[j]);\n+                        }\n+                        args[i] = replacements[r];\n+                        Object receiver = isStatic ? null : defaultValue(clazz);\n+                        cases.add(new Object[]{testName, m, receiver, args});\n+                    }\n+                }\n+            }\n+        }\n+        return cases.iterator();\n+    }\n+\n+    static String shortSig(Method m) {\n+        StringJoiner sj = new StringJoiner(\",\", m.getName() + \"(\", \")\");\n+        for (Class<?> parameterType : m.getParameterTypes()) {\n+            sj.add(parameterType.getTypeName());\n+        }\n+        return sj.toString();\n+    }\n+\n+    static Object defaultValue(Class<?> carrier) {\n+        if (carrier.isArray()) {\n+            return Array.newInstance(carrier.componentType(), 0);\n+        }\n+        Object value = DEFAULT_VALUES.get(carrier);\n+        if (value == null) {\n+            throw new UnsupportedOperationException(carrier.getName());\n+        }\n+        return value;\n+    }\n+\n+    static Object defaultValue(Parameter param) {\n+        Class<?> carrier = param.getType();\n+        boolean optionalWrap = carrier == Optional.class;\n+        if (optionalWrap) {\n+            var generic = (ParameterizedType) param.getParameterizedType();\n+            var arg = generic.getActualTypeArguments()[0];\n+            carrier = (Class<?>) arg;\n+        }\n+        Object value = defaultValue(carrier);\n+        if (optionalWrap)\n+            value = Optional.of(value);\n+        return value;\n+    }\n+\n+    static Object[] replacements(Class<?> carrier) {\n+        if (carrier.isArray() && !carrier.getComponentType().isPrimitive()) {\n+            Object arr = Array.newInstance(carrier.componentType(), 1);\n+            Array.set(arr, 0, null);\n+            return new Object[]{null, arr};\n+        }\n+        return REPLACEMENT_VALUES.getOrDefault(carrier, new Object[]{null});\n+    }\n+\n+    public static List<String> findAllClassFiles() throws IOException, URISyntaxException {\n+        FileSystem fs = FileSystems.getFileSystem(new URI(\"jrt:\/\"));\n+        Path dir = fs.getPath(\"\/modules\");\n+        try (final Stream<Path> paths = Files.walk(dir)) {\n+            \/\/ each path is in the form: \/modules\/<modname>\/<pkg>\/<pkg>\/...\/name.class\n+            return paths\n+                    .filter(path -> path.getNameCount() > 2)\n+                    .map(Path::toString)\n+                    .filter(name -> name.endsWith(\".class\"))\n+                    .collect(Collectors.toList());\n+        }\n+    }\n+\n+    private static void populateClassFileMappings(byte[] classFileBytes) throws IOException {\n+\n+        ClassModel cm = ClassFile.of().parse(classFileBytes);\n+        addDefaultMapping(ClassFile.class, ClassFile.of());\n+        addDefaultMapping(ConstantPool.class, cm.constantPool());\n+        addDefaultMapping(ClassReader.class, (ClassReader) cm.constantPool());\n+\n+        var node = ClassPrinter.toTree(cm, ClassPrinter.Verbosity.TRACE_ALL);\n+        addDefaultMapping(ClassPrinter.MapNode.class, node);\n+        addDefaultMapping(ClassPrinter.Node.class, node);\n+        addDefaultMapping(ClassPrinter.Verbosity.class, ClassPrinter.Verbosity.MEMBERS_ONLY);\n+        addDefaultMapping(TypeKind.class, TypeKind.BOOLEAN);\n+        addDefaultMapping(ConstantPoolBuilder.class, ConstantPoolBuilder.of(cm));\n+        addDefaultMapping(ClassModel.class, cm);\n+        addDefaultMapping(ClassRemapper.class, ClassRemapper.of(Map.of()));\n+        addDefaultMapping(ClassHierarchyResolver.class, ClassHierarchyResolver.defaultResolver());\n+        addDefaultMapping(ClassTransform.class, ClassFileBuilder::with);\n+        addDefaultMapping(MethodTransform.class, (_, _) -> {});\n+        addDefaultMapping(FieldTransform.class, (_, _) -> {});\n+        addDefaultMapping(ClassPrinter.LeafNode.class, new ClassPrinterImpl.LeafNodeImpl(ConstantDescs.CD_Class, ConstantDescs.INIT_NAME));\n+        addDefaultMapping(ClassFileTransform.class, (ClassTransform) (_, _) -> {});\n+        addDefaultMapping(ConstantDesc.class, ConstantDescs.NULL);\n+        addDefaultMapping(CodeStackTracker.class, CodeStackTracker.of());\n+        addDefaultMapping(CodeRelabeler.class, CodeRelabeler.of());\n+        addDefaultMapping(CodeTransform.class, (_, _) -> {});\n+        addDefaultMapping(AttributesProcessingOption.class, ClassFile.AttributesProcessingOption.PASS_ALL_ATTRIBUTES);\n+        addDefaultMapping(TypeAnnotation.TargetInfo.class, TypeAnnotation.TargetInfo.ofField());\n+        addDefaultMapping(StackMapsOption.class, ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+        addDefaultMapping(ShortJumpsOption.class, ClassFile.ShortJumpsOption.FIX_SHORT_JUMPS);\n+        addDefaultMapping(LineNumbersOption.class, ClassFile.LineNumbersOption.PASS_LINE_NUMBERS);\n+        addDefaultMapping(DebugElementsOption.class, ClassFile.DebugElementsOption.PASS_DEBUG);\n+        addDefaultMapping(DeadLabelsOption.class, ClassFile.DeadLabelsOption.FAIL_ON_DEAD_LABELS);\n+        addDefaultMapping(DeadCodeOption.class, ClassFile.DeadCodeOption.PATCH_DEAD_CODE);\n+        addDefaultMapping(TypeAnnotation.TargetInfo.class, TypeAnnotation.TargetInfo.ofField());\n+        addDefaultMapping(TypeAnnotation.TargetType.class, TypeAnnotation.TargetInfo.ofField().targetType());\n+        addDefaultMapping(TypeAnnotation.TypePathComponent.Kind.class, TypeAnnotation.TypePathComponent.Kind.INNER_TYPE);\n+        addDefaultMapping(ConstantPoolSharingOption.class, ClassFile.ConstantPoolSharingOption.SHARED_POOL);\n+        addDefaultMapping(PackageDesc.class, PackageDesc.of(\"java.lang.classfile\"));\n+        addDefaultMapping(ModuleDesc.class, ModuleDesc.of(\"java.base\"));\n+        addDefaultMapping(Signature.ClassTypeSig.class, Signature.ClassTypeSig.of(ClassDesc.of(\"java.util.Iterator\")));\n+        addDefaultMapping(Signature.TypeArg.Bounded.WildcardIndicator.class, Signature.TypeArg.Bounded.WildcardIndicator.NONE);\n+        addDefaultMapping(Signature.RefTypeSig.class, Signature.ClassTypeSig.of(ClassDesc.of(\"java.util.Iterator\")));\n+        addDefaultMapping(StackMapFrameInfo.SimpleVerificationTypeInfo.class, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE);\n+        addDefaultMapping(MethodSignature.class, MethodSignature.parseFrom(\"<T::Ljava\/lang\/annotation\/Annotation;>(Ljava\/lang\/Class<TT;>;)[TT;^Ljava\/lang\/IOException;^Ljava\/lang\/IllegalAccessError;\"));\n+        addDefaultMapping(ClassSignature.class, ClassSignature.parseFrom(\"Ljava\/util\/LinkedHashMap<TK;TV;>.LinkedHashIterator;Ljava\/util\/Iterator<Ljava\/util\/Map$Entry<TK;TV;>;>;\"));\n+        addDefaultMapping(Opcode.Kind.class, Opcode.Kind.CONSTANT);\n+\n+        cm.flags().flags().stream().findFirst().ifPresent(flag -> addDefaultMapping(AccessFlag.class, flag));\n+        try {\n+            Runnable runnable = () -> ClassFile.of().parse(new byte[]{(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE,\n+                    0, 0, 0, 0, 0, 2, PoolEntry.TAG_METHODREF, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}).thisClass();\n+            runnable.run();\n+        } catch (ConstantPoolException e) {\n+            addDefaultMapping(ConstantPoolException.class, e);\n+            addDefaultMapping(Throwable.class, e);\n+        }\n+\n+        try {\n+            addDefaultMapping(BootstrapMethodEntry.class, cm.constantPool().bootstrapMethodEntry(0));\n+            addDefaultMapping(LoadableConstantEntry.class, cm.constantPool().bootstrapMethodEntry(0).arguments().getFirst());\n+        } catch (Exception e) {\n+            \/\/ skip\n+        }\n+\n+        for (ClassFileElement ce : cm) {\n+            if (ce instanceof AttributedElement ae) {\n+                addDefaultMapping(ClassFileElement.class, ce);\n+                addDefaultMapping(AttributedElement.class, ae);\n+\n+            }\n+            if (Objects.requireNonNull(ce) instanceof CompoundElement<?> comp) {\n+                addDefaultMapping(CompoundElement.class, comp);\n+            }\n+        }\n+\n+        ModuleDesc modName = ModuleDesc.of(\"some.module.structure\");\n+        String modVsn = \"ab75\";\n+        ModuleDesc require1 = ModuleDesc.of(\"1require.some.mod\");\n+        String vsn1 = \"1the.best.version\";\n+        ModuleDesc require2 = ModuleDesc.of(\"2require.some.mod\");\n+        String vsn2 = \"2the.best.version\";\n+        ModuleDesc[] et1 = new ModuleDesc[]{ModuleDesc.of(\"1t1\"), ModuleDesc.of(\"1t2\")};\n+        ModuleDesc[] et2 = new ModuleDesc[]{ModuleDesc.of(\"2t1\")};\n+        ModuleDesc[] et3 = new ModuleDesc[]{ModuleDesc.of(\"3t1\"), ModuleDesc.of(\"3t2\"), ModuleDesc.of(\"3t3\")};\n+        ModuleDesc[] ot3 = new ModuleDesc[]{ModuleDesc.of(\"t1\"), ModuleDesc.of(\"t2\")};\n+\n+\n+        var classFile = ClassFile.of();\n+        byte[] modInfo = classFile.buildModule(\n+                ModuleAttribute.of(modName, mb -> {\n+                    addDefaultMapping(ModuleAttribute.ModuleAttributeBuilder.class, mb);\n+                    mb.moduleVersion(modVsn)\n+                            .requires(require1, 77, vsn1)\n+                            .requires(require2, 99, vsn2)\n+                            .exports(PackageDesc.of(\"0\"), 0, et1)\n+                            .exports(PackageDesc.of(\"1\"), 1, et2)\n+                            .exports(PackageDesc.of(\"2\"), 2, et3)\n+                            .exports(PackageDesc.of(\"3\"), 3)\n+                            .exports(PackageDesc.of(\"4\"), 4)\n+                            .opens(PackageDesc.of(\"o0\"), 0)\n+                            .opens(PackageDesc.of(\"o1\"), 1)\n+                            .opens(PackageDesc.of(\"o2\"), 2, ot3)\n+                            .uses(ClassDesc.of(\"some.Service\"))\n+                            .uses(ClassDesc.of(\"another.Service\"))\n+                            .provides(ClassDesc.of(\"some.nice.Feature\"), ClassDesc.of(\"impl\"), ClassDesc.of(\"another.impl\"));\n+                }),\n+                clb -> clb.with(ModuleMainClassAttribute.of(ClassDesc.of(\"main.Class\")))\n+                        .with(ModulePackagesAttribute.ofNames(PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\")))\n+                        .with(ModuleMainClassAttribute.of(ClassDesc.of(\"overwritten.main.Class\")))\n+        );\n+\n+        final ClassModel moduleModel = classFile.parse(modInfo);\n+        final ModuleAttribute moduleAttribute = ((ModuleAttribute) moduleModel.attributes().stream()\n+                .filter(a -> a.attributeMapper() == Attributes.module())\n+                .findFirst()\n+                .orElseThrow());\n+        moduleModel.attributes().stream()\n+                .filter(a -> a.attributeMapper() == Attributes.module())\n+                .forEach(_ -> addDefaultMapping(AttributeMapper.AttributeStability.class, moduleAttribute.attributeMapper().stability()));\n+\n+        addDefaultMapping(ModuleAttribute.class, moduleAttribute);\n+        addDefaultMapping(ModuleOpenInfo.class, moduleAttribute.opens().getFirst());\n+        addDefaultMapping(ModuleRequireInfo.class, moduleAttribute.requires().getFirst());\n+        addDefaultMapping(ModuleExportInfo.class, moduleAttribute.exports().getFirst());\n+        addDefaultMapping(ModuleProvideInfo.class, moduleAttribute.provides().getFirst());\n+\n+\n+        ClassFile.of().transformClass(cm, (cb, ce) -> {\n+            addDefaultMapping(ClassBuilder.class, cb);\n+            addDefaultMapping(ClassFileBuilder.class, cb);\n+            switch (ce) {\n+                case MethodModel m -> cb.transformMethod(m, (mb, me) -> {\n+                    addDefaultMapping(MethodBuilder.class, mb);\n+                    if (!(me instanceof RuntimeVisibleAnnotationsAttribute || me instanceof RuntimeInvisibleAnnotationsAttribute))\n+                        mb.with(me);\n+                });\n+                case FieldModel f -> cb.transformField(f, (fb, fe) -> {\n+                    addDefaultMapping(FieldBuilder.class, fb);\n+                    if (!(fe instanceof RuntimeVisibleAnnotationsAttribute || fe instanceof RuntimeInvisibleAnnotationsAttribute))\n+                        fb.with(fe);\n+                });\n+                default -> cb.with(ce);\n+            }\n+        });\n+\n+\n+        var annotation = cm.findAttribute(Attributes.runtimeVisibleAnnotations());\n+        if (annotation.isPresent()) {\n+            addDefaultMapping(Annotation.class, annotation.get().annotations().getFirst());\n+            addDefaultMapping(ClassPrinter.ListNode.class, new ClassPrinterImpl.ListNodeImpl(FLOW, \"array\", cm.findAttribute(Attributes.runtimeVisibleAnnotations()).stream().map(\n+                    _ -> new ClassPrinterImpl.MapNodeImpl(FLOW, \"value\"))));\n+        }\n+\n+        for (var cpe : cm.constantPool()) {\n+            switch (cpe) {\n+                case DoubleEntry de -> {\n+                    addDefaultMapping(DoubleEntry.class, de);\n+                    addDefaultMapping(ConstantValueEntry.class, de);\n+                }\n+                case FloatEntry fe -> addDefaultMapping(FloatEntry.class, fe);\n+                case IntegerEntry ie -> {\n+                    addDefaultMapping(IntegerEntry.class, ie);\n+                    addDefaultMapping(PoolEntry.class, ie);\n+                }\n+                case LongEntry le -> addDefaultMapping(LongEntry.class, le);\n+                case Utf8Entry ue -> addDefaultMapping(Utf8Entry.class, ue);\n+                case ConstantDynamicEntry cde -> addDefaultMapping(ConstantDynamicEntry.class, cde);\n+                case InvokeDynamicEntry ide -> addDefaultMapping(InvokeDynamicEntry.class, ide);\n+                case ClassEntry ce -> addDefaultMapping(ClassEntry.class, ce);\n+                case MethodHandleEntry mhe -> {\n+                    addDefaultMapping(MethodHandleEntry.class, mhe);\n+                    addDefaultMapping(MemberRefEntry.class, mhe.reference());\n+                    addDefaultMapping(DirectMethodHandleDesc.class, mhe.asSymbol());\n+                    addDefaultMapping(DynamicConstantDesc.class, DynamicConstantDesc.of(mhe.asSymbol()));\n+                    addDefaultMapping(DynamicCallSiteDesc.class, DynamicCallSiteDesc.of(mhe.asSymbol(), cm.methods().getFirst().methodTypeSymbol()));\n+                }\n+                case FieldRefEntry fre -> addDefaultMapping(FieldRefEntry.class, fre);\n+                case InterfaceMethodRefEntry imre -> addDefaultMapping(InterfaceMethodRefEntry.class, imre);\n+                case MethodRefEntry mre -> addDefaultMapping(MethodRefEntry.class, mre);\n+                case ModuleEntry me -> addDefaultMapping(ModuleEntry.class, me);\n+                case NameAndTypeEntry nate -> addDefaultMapping(NameAndTypeEntry.class, nate);\n+                case PackageEntry pe -> addDefaultMapping(PackageEntry.class, pe);\n+                default -> {}\n+            }\n+        }\n+\n+        for (ClassElement ce : cm) {\n+            switch (ce) {\n+                case Attribute<?> a -> {\n+                    addDefaultMapping(AttributeMapper.class, a.attributeMapper());\n+                    addDefaultMapping(Attribute.class, a);\n+                }\n+                case AccessFlags af -> addDefaultMapping(AccessFlags.class, af);\n+                case FieldModel fm -> {\n+                    addDefaultMapping(FieldModel.class, fm);\n+                    addDefaultMapping(Utf8Entry.class, fm.fieldName());\n+                    addDefaultMapping(ClassDesc.class, fm.fieldTypeSymbol());\n+                    addDefaultMapping(Signature.class, Signature.of(fm.fieldTypeSymbol()));\n+                    addDefaultMapping(TypeDescriptor.OfField.class, fm.fieldTypeSymbol());\n+                    addDefaultMapping(AnnotationValue.class, AnnotationValue.of(fm.fieldTypeSymbol()));\n+                }\n+                case MethodModel mm -> {\n+                    addDefaultMapping(CodeLocalsShifter.class, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol()));\n+                    addDefaultMapping(MethodTypeDesc.class, mm.methodTypeSymbol());\n+                    addDefaultMapping(MethodModel.class, mm);\n+                    for (MethodElement me : mm) {\n+                        if (me instanceof CodeModel xm) {\n+                            addDefaultMapping(CodeModel.class, xm);\n+                            addDefaultMapping(CodeAttribute.class, (CodeAttribute) xm);\n+                            for (CodeElement e : xm) {\n+                                switch (e) {\n+                                    case BranchInstruction ii -> addDefaultMapping(Label.class, ii.target());\n+                                    case NewReferenceArrayInstruction c -> addDefaultMapping(Opcode.class, c.opcode());\n+                                    default -> {}\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                default -> {}\n+            }\n+        }\n+\n+        for (Attribute<?> a : cm.attributes()) {\n+            switch (a) {\n+                case ModuleAttribute attr -> addDefaultMapping(ModuleAttribute.class, attr);\n+                case RuntimeVisibleTypeAnnotationsAttribute attr ->\n+                        addDefaultMapping(RuntimeVisibleTypeAnnotationsAttribute.class, attr);\n+                case RuntimeInvisibleTypeAnnotationsAttribute attr ->\n+                        addDefaultMapping(RuntimeInvisibleTypeAnnotationsAttribute.class, attr);\n+                case RuntimeVisibleParameterAnnotationsAttribute attr ->\n+                        addDefaultMapping(RuntimeVisibleParameterAnnotationsAttribute.class, attr);\n+                case RuntimeInvisibleParameterAnnotationsAttribute attr ->\n+                        addDefaultMapping(RuntimeInvisibleParameterAnnotationsAttribute.class, attr);\n+                case SourceDebugExtensionAttribute attr -> addDefaultMapping(SourceDebugExtensionAttribute.class, attr);\n+                case SourceIDAttribute attr -> addDefaultMapping(SourceIDAttribute.class, attr);\n+                default -> {}\n+            }\n+        }\n+\n+        ClassFile.of().build(ClassDesc.of(\"C\"), cb -> cb.withMethod(\"main\", MethodTypeDesc.of(ConstantDescs.CD_String, ConstantDescs.CD_String.arrayType()),\n+                ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, mb -> mb.withCode(xb -> {\n+                    int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n+                    xb.loadConstant(\"S\");\n+                    xb.astore(stringSlot);\n+                    xb.trying(tb -> {\n+                        tb.aload(0);\n+                        tb.loadConstant(0);\n+                        \/\/ IndexOutOfBoundsException\n+                        tb.aaload();\n+                        \/\/ NullPointerException\n+                        tb.invokevirtual(ConstantDescs.CD_String, \"toString\", MethodType.methodType(String.class).describeConstable().get());\n+                        tb.astore(stringSlot);\n+                    }, catchBuilder -> {\n+                        catchBuilder.catching(IndexOutOfBoundsException.class.describeConstable().get(), tb -> {\n+                            tb.pop();\n+                            tb.ldc(\"IndexOutOfBoundsException\");\n+                            tb.areturn();\n+                        }).catchingAll(tb -> {\n+                            tb.pop();\n+                            tb.ldc(\"any\");\n+                            tb.areturn();\n+                        });\n+                        addDefaultMapping(CodeBuilder.CatchBuilder.class, catchBuilder);\n+                    });\n+                    xb.aload(stringSlot);\n+                    xb.areturn();\n+                })));\n+\n+\n+        ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS).build(cm.thisClass().asSymbol(), clb -> {\n+            for (var cle : cm) {\n+                switch (cle) {\n+                    case AccessFlags af -> clb.withFlags(af.flagsMask());\n+                    case Interfaces i ->\n+                            clb.withInterfaceSymbols(i.interfaces().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new));\n+                    case ClassFileVersion v -> clb.withVersion(v.majorVersion(), v.minorVersion());\n+                    case MethodModel mm ->\n+                            clb.withMethod(mm.methodName().stringValue(), mm.methodTypeSymbol(), mm.flags().flagsMask(), _ -> {\n+                                for (var me : mm) {\n+                                    if (Objects.requireNonNull(me) instanceof MethodParametersAttribute a) {\n+                                        var r = MethodParametersAttribute.of(\n+                                                        a.parameters().stream().map(\n+                                                                mp -> MethodParameterInfo.ofParameter(mp.name().map(Utf8Entry::stringValue), mp.flagsMask())\n+                                                        ).toArray(MethodParameterInfo[]::new)\n+                                                )\n+                                                .parameters()\n+                                                .getFirst();\n+                                        addDefaultMapping(MethodParameterInfo.class, r);\n+                                    }\n+                                }\n+                            });\n+                    case InnerClassesAttribute a ->\n+                            addDefaultMapping(InnerClassInfo.class, InnerClassesAttribute.of(a.classes().stream().map(ici -> InnerClassInfo.of(\n+                                            ici.innerClass().asSymbol(),\n+                                            ici.outerClass().map(ClassEntry::asSymbol),\n+                                            ici.innerName().map(Utf8Entry::stringValue),\n+                                            ici.flagsMask())).toArray(InnerClassInfo[]::new))\n+                                    .classes().getFirst());\n+                    case ModuleAttribute a -> clb.with(\n+                            ModuleAttribute.of(a.moduleName().asSymbol(), mob -> {\n+                                mob.moduleFlags(a.moduleFlagsMask());\n+                                a.moduleVersion().ifPresent(v -> mob.moduleVersion(v.stringValue()));\n+                                for (var req : a.requires())\n+                                    mob.requires(req.requires().asSymbol(), req.requiresFlagsMask(), req.requiresVersion().map(Utf8Entry::stringValue).orElse(\"placeholder\"));\n+                                for (var exp : a.exports())\n+                                    mob.exports(exp.exportedPackage().asSymbol(), exp.exportsFlagsMask(), exp.exportsTo().stream().map(ModuleEntry::asSymbol).toArray(ModuleDesc[]::new));\n+                                for (var opn : a.opens())\n+                                    mob.opens(opn.openedPackage().asSymbol(), opn.opensFlagsMask(), opn.opensTo().stream().map(ModuleEntry::asSymbol).toArray(ModuleDesc[]::new));\n+                                for (var use : a.uses()) mob.uses(use.asSymbol());\n+                                for (var prov : a.provides())\n+                                    mob.provides(prov.provides().asSymbol(), prov.providesWith().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new));\n+                            }));\n+                    case RecordAttribute a -> RecordAttribute.of(a.components().stream().map(rci -> {\n+                        var y = RecordComponentInfo.of(rci.name().stringValue(), rci.descriptorSymbol(), rci.attributes().stream().mapMulti((_, _) -> {\n+                        }).toArray(Attribute[]::new));\n+                        addDefaultMapping(RecordComponentInfo.class, y);\n+                        return RecordComponentInfo.of(rci.name().stringValue(), rci.descriptorSymbol(), rci.attributes().stream().mapMulti((_, _) -> {\n+                        }).toArray(Attribute[]::new));\n+                    }).toArray(RecordComponentInfo[]::new));\n+                    default -> {}\n+                }\n+            }\n+        });\n+\n+\n+        var testClass = \"JsrAndRetSample\";\n+        var testMethod = \"testMethod\";\n+        var cd_list = ArrayList.class.describeConstable().get();\n+        ClassFile.of().build(ClassDesc.of(testClass), clb -> clb\n+                .withVersion(ClassFile.JAVA_5_VERSION, 0)\n+                .withMethodBody(testMethod, MethodTypeDesc.of(ConstantDescs.CD_void, cd_list), ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, cob -> cob\n+                        .block(bb -> {\n+                            addDefaultMapping(CodeBuilder.BlockCodeBuilder.class, bb);\n+\n+                            bb.loadConstant(\"Hello\")\n+                                    .with(DiscontinuedInstruction.JsrInstruction.of(bb.breakLabel()));\n+                            bb.loadConstant(\"World\")\n+                                    .with(DiscontinuedInstruction.JsrInstruction.of(Opcode.JSR_W, bb.breakLabel()))\n+                                    .return_();\n+                        })\n+                        .astore(355)\n+                        .aload(0)\n+                        .swap()\n+                        .invokevirtual(cd_list, \"add\", MethodTypeDesc.of(ConstantDescs.CD_boolean, ConstantDescs.CD_Object))\n+                        .pop()\n+                        .with(DiscontinuedInstruction.RetInstruction.of(355))));\n+\n+\n+        var root = Paths.get(URI.create(NullHostileTest.class.getResource(\"NullHostileTest.class\").toString())).getParent();\n+        var cc = ClassFile.of();\n+        Files.write(root.resolve(\"testdata\/Pattern2-split.class\"), cc.transformClass(cc.parse(root.resolve(\"testdata\/Pattern2.class\")), ClassTransform.transformingMethodBodies((cob, coe) -> {\n+            addDefaultMapping(CodeBuilder.class, cob);\n+            var dcob = (DirectCodeBuilder) cob;\n+            var curPc = dcob.curPc();\n+            switch (coe) {\n+                case LineNumber ln ->\n+                        dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.lineNumberTable()) {\n+                            @Override\n+                            public void writeBody(BufWriterImpl b) {\n+                                addDefaultMapping(BufWriter.class, b);\n+                                b.writeU2(1);\n+                                b.writeU2(curPc);\n+                                b.writeU2(ln.line());\n+                            }\n+                        });\n+                case LocalVariable lv ->\n+                        dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTable()) {\n+                            @Override\n+                            public void writeBody(BufWriterImpl b) {\n+                                b.writeU2(1);\n+                                Util.writeLocalVariable(b, lv);\n+                            }\n+                        });\n+                case LocalVariableType lvt ->\n+                        dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTypeTable()) {\n+                            @Override\n+                            public void writeBody(BufWriterImpl b) {\n+                                b.writeU2(1);\n+                                Util.writeLocalVariable(b, lvt);\n+                            }\n+                        });\n+                default -> cob.with(coe);\n+            }\n+        })));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/classfile\/NullHostileTest.java","additions":937,"deletions":0,"binary":false,"changes":937,"status":"added"}]}