{"files":[{"patch":"@@ -37,2 +37,0 @@\n-import static java.util.Objects.requireNonNull;\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,0 +276,1 @@\n+        if (desc == null) return null;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,937 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8317356\n- * @build testdata.* CorpusTest\n- * @run junit\/othervm NullHostileTest\n- *\/\n-\n-import java.io.*;\n-import java.lang.classfile.*;\n-import java.lang.classfile.ClassFile.*;\n-import java.lang.classfile.CustomAttribute;\n-import java.lang.classfile.attribute.*;\n-import java.lang.classfile.components.*;\n-import java.lang.classfile.constantpool.*;\n-import java.lang.classfile.instruction.*;\n-import java.lang.constant.*;\n-import java.lang.invoke.*;\n-import java.lang.reflect.*;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.nio.file.FileSystem;\n-import java.nio.file.*;\n-import java.util.*;\n-import java.util.Optional;\n-import java.util.function.*;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static jdk.internal.classfile.impl.ClassPrinterImpl.Style.FLOW;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-import jdk.internal.classfile.impl.*;\n-\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.parallel.Execution;\n-import org.junit.jupiter.api.parallel.ExecutionMode;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-\/**\n- * This test makes sure that public API classes under {@link java.lang.classfile} throws NPEs whenever\n- * nulls are provided. The test looks at all the public methods in all the listed classes, and injects\n- * values automatically. If an API takes a reference, the test will try to inject nulls. For APIs taking\n- * either reference arrays, or collections, the framework will also generate additional <em>replacements<\/em>\n- * (e.g. other than just replacing the array, or collection with null), such as an array or collection\n- * with null elements. The test can be customized by adding\/removing classes to the {@link #CLASSES} array,\n- * by adding\/removing default mappings for standard carrier types (see {@link #DEFAULT_VALUES} or by\n- * adding\/removing custom replacements (see {@link #REPLACEMENT_VALUES}).\n- * <p>\n- *\/\n-@Execution(ExecutionMode.CONCURRENT)\n-class NullHostileTest {\n-\n-    private static final Set<String> OBJECT_METHODS = Stream.of(Object.class.getMethods())\n-            .map(Method::getName)\n-            .collect(Collectors.toSet());\n-\n-    private static final Set<String> TRANSFORM_USER_METHODS = Set.of(\"accept\", \"atStart\", \"atEnd\");\n-\n-    private static final Map<Class<?>, Object> DEFAULT_VALUES = new HashMap<>();\n-    private static final Map<Class<?>, Object[]> REPLACEMENT_VALUES = new HashMap<>();\n-\n-    static <Z> void addDefaultMapping(Class<Z> carrier, Z value) {\n-        DEFAULT_VALUES.putIfAbsent(carrier, value);\n-    }\n-\n-    @SafeVarargs\n-    static <Z> void addReplacements(Class<Z> carrier, Z... value) {\n-        REPLACEMENT_VALUES.putIfAbsent(carrier, value);\n-    }\n-\n-    static final Class<?>[] CLASSES = new Class<?>[]{\n-            AccessFlags.class,\n-            Annotation.class,\n-            AnnotationElement.class,\n-            AnnotationValue.class,\n-            AnnotationValue.OfEnum.class,\n-            AnnotationValue.OfClass.class,\n-            AnnotationValue.OfString.class,\n-            AnnotationValue.OfDouble.class,\n-            AnnotationValue.OfFloat.class,\n-            AnnotationValue.OfLong.class,\n-            AnnotationValue.OfInt.class,\n-            AnnotationValue.OfShort.class,\n-            AnnotationValue.OfChar.class,\n-            AnnotationValue.OfByte.class,\n-            AnnotationValue.OfBoolean.class,\n-            AnnotationValue.OfArray.class,\n-            AnnotationValue.OfConstant.class,\n-            AnnotationValue.OfAnnotation.class,\n-            Attribute.class,\n-            AttributeMapper.class,\n-            AttributeMapper.AttributeStability.class,\n-            AttributedElement.class,\n-            Attributes.class,\n-            BootstrapMethodEntry.class,\n-            BufWriter.class,\n-            ClassBuilder.class,\n-            ClassElement.class,\n-            ClassFile.class,\n-            Option.class,\n-            AttributesProcessingOption.class,\n-            ClassFile.StackMapsOption.class,\n-            ClassFile.ShortJumpsOption.class,\n-            LineNumbersOption.class,\n-            DebugElementsOption.class,\n-            DeadLabelsOption.class,\n-            DeadCodeOption.class,\n-            ConstantPoolSharingOption.class,\n-            ClassHierarchyResolverOption.class,\n-            AttributeMapperOption.class,\n-            ClassFileBuilder.class,\n-            ClassFileElement.class,\n-            ClassFileTransform.class,\n-            ClassFileVersion.class,\n-            ClassHierarchyResolver.class,\n-            ClassHierarchyResolver.ClassHierarchyInfo.class,\n-            ClassModel.class,\n-            ClassReader.class,\n-            ClassSignature.class,\n-            ClassTransform.class,\n-            CodeBuilder.class,\n-            CodeBuilder.CatchBuilder.class,\n-            CodeBuilder.BlockCodeBuilder.class,\n-            CodeElement.class,\n-            CodeModel.class,\n-            CodeTransform.class,\n-            CompoundElement.class,\n-            CustomAttribute.class,\n-            FieldBuilder.class,\n-            FieldElement.class,\n-            FieldModel.class,\n-            FieldTransform.class,\n-            Instruction.class,\n-            Interfaces.class,\n-            Label.class,\n-            MethodBuilder.class,\n-            MethodElement.class,\n-            MethodModel.class,\n-            MethodSignature.class,\n-            MethodTransform.class,\n-            Opcode.class,\n-            Opcode.Kind.class,\n-            PseudoInstruction.class,\n-            Signature.class,\n-            Signature.ArrayTypeSig.class,\n-            Signature.BaseTypeSig.class,\n-            Signature.TypeArg.class,\n-            Signature.TypeArg.Bounded.class,\n-            Signature.TypeArg.Bounded.WildcardIndicator.class,\n-            Signature.TypeArg.Unbounded.class,\n-            Signature.ClassTypeSig.class,\n-            Signature.ThrowableSig.class,\n-            Signature.TypeParam.class,\n-            Signature.TypeVarSig.class,\n-            Signature.RefTypeSig.class,\n-            Superclass.class,\n-            TypeAnnotation.class,\n-            TypeAnnotation.TargetInfo.class,\n-            TypeAnnotation.TypePathComponent.class,\n-            TypeAnnotation.TypePathComponent.Kind.class,\n-            TypeAnnotation.TypeArgumentTarget.class,\n-            TypeAnnotation.OffsetTarget.class,\n-            TypeAnnotation.CatchTarget.class,\n-            TypeAnnotation.LocalVarTargetInfo.class,\n-            TypeAnnotation.LocalVarTarget.class,\n-            TypeAnnotation.ThrowsTarget.class,\n-            TypeAnnotation.FormalParameterTarget.class,\n-            TypeAnnotation.EmptyTarget.class,\n-            TypeAnnotation.TypeParameterBoundTarget.class,\n-            TypeAnnotation.SupertypeTarget.class,\n-            TypeAnnotation.TypeParameterTarget.class,\n-            TypeAnnotation.TargetType.class,\n-            TypeKind.class,\n-            AnnotationDefaultAttribute.class,\n-            BootstrapMethodsAttribute.class,\n-            CharacterRangeInfo.class,\n-            CharacterRangeTableAttribute.class,\n-            CodeAttribute.class,\n-            CompilationIDAttribute.class,\n-            ConstantValueAttribute.class,\n-            DeprecatedAttribute.class,\n-            EnclosingMethodAttribute.class,\n-            ExceptionsAttribute.class,\n-            InnerClassInfo.class,\n-            InnerClassesAttribute.class,\n-            LineNumberInfo.class,\n-            LineNumberTableAttribute.class,\n-            LocalVariableInfo.class,\n-            LocalVariableTableAttribute.class,\n-            LocalVariableTypeInfo.class,\n-            LocalVariableTypeTableAttribute.class,\n-            MethodParameterInfo.class,\n-            ModuleAttribute.class,\n-            ModuleAttribute.ModuleAttributeBuilder.class,\n-            ModuleExportInfo.class,\n-            ModuleHashInfo.class,\n-            ModuleHashesAttribute.class,\n-            ModuleMainClassAttribute.class,\n-            ModuleOpenInfo.class,\n-            ModulePackagesAttribute.class,\n-            ModuleProvideInfo.class,\n-            ModuleRequireInfo.class,\n-            ModuleResolutionAttribute.class,\n-            ModuleTargetAttribute.class,\n-            NestHostAttribute.class,\n-            NestMembersAttribute.class,\n-            PermittedSubclassesAttribute.class,\n-            RecordAttribute.class,\n-            RecordComponentInfo.class,\n-            RuntimeInvisibleAnnotationsAttribute.class,\n-            RuntimeInvisibleParameterAnnotationsAttribute.class,\n-            RuntimeInvisibleTypeAnnotationsAttribute.class,\n-            RuntimeVisibleAnnotationsAttribute.class,\n-            RuntimeVisibleParameterAnnotationsAttribute.class,\n-            RuntimeVisibleTypeAnnotationsAttribute.class,\n-            SignatureAttribute.class,\n-            SourceDebugExtensionAttribute.class,\n-            SourceFileAttribute.class,\n-            SourceIDAttribute.class,\n-            StackMapFrameInfo.class,\n-            StackMapFrameInfo.UninitializedVerificationTypeInfo.class,\n-            StackMapFrameInfo.ObjectVerificationTypeInfo.class,\n-            StackMapFrameInfo.SimpleVerificationTypeInfo.class,\n-            StackMapFrameInfo.VerificationTypeInfo.class,\n-            StackMapTableAttribute.class,\n-            SyntheticAttribute.class,\n-            UnknownAttribute.class,\n-            ClassPrinter.class,\n-            ClassPrinter.Verbosity.class,\n-            ClassPrinter.MapNode.class,\n-            ClassPrinter.ListNode.class,\n-            ClassPrinter.LeafNode.class,\n-            ClassPrinter.Node.class,\n-            ClassRemapper.class,\n-            CodeLocalsShifter.class,\n-            CodeRelabeler.class,\n-            CodeStackTracker.class,\n-            AnnotationConstantValueEntry.class,\n-            ClassEntry.class,\n-            ConstantDynamicEntry.class,\n-            ConstantPool.class,\n-            ConstantPoolBuilder.class,\n-            ConstantPoolException.class,\n-            ConstantValueEntry.class,\n-            DoubleEntry.class,\n-            DynamicConstantPoolEntry.class,\n-            FieldRefEntry.class,\n-            FloatEntry.class,\n-            IntegerEntry.class,\n-            InterfaceMethodRefEntry.class,\n-            InvokeDynamicEntry.class,\n-            LoadableConstantEntry.class,\n-            LongEntry.class,\n-            MemberRefEntry.class,\n-            MethodHandleEntry.class,\n-            MethodRefEntry.class,\n-            MethodTypeEntry.class,\n-            ModuleEntry.class,\n-            NameAndTypeEntry.class,\n-            PackageEntry.class,\n-            PoolEntry.class,\n-            StringEntry.class,\n-            Utf8Entry.class,\n-            ArrayLoadInstruction.class,\n-            ArrayStoreInstruction.class,\n-            BranchInstruction.class,\n-            CharacterRange.class,\n-            ConstantInstruction.class,\n-            ConstantInstruction.LoadConstantInstruction.class,\n-            ConstantInstruction.ArgumentConstantInstruction.class,\n-            ConstantInstruction.IntrinsicConstantInstruction.class,\n-            ConvertInstruction.class,\n-            DiscontinuedInstruction.class,\n-            DiscontinuedInstruction.RetInstruction.class,\n-            DiscontinuedInstruction.JsrInstruction.class,\n-            ExceptionCatch.class,\n-            FieldInstruction.class,\n-            IncrementInstruction.class,\n-            InvokeDynamicInstruction.class,\n-            LabelTarget.class,\n-            LineNumber.class,\n-            LoadInstruction.class,\n-            LocalVariable.class,\n-            LocalVariableType.class,\n-            LookupSwitchInstruction.class,\n-            MonitorInstruction.class,\n-            NewMultiArrayInstruction.class,\n-            NewObjectInstruction.class,\n-            NewPrimitiveArrayInstruction.class,\n-            NewReferenceArrayInstruction.class,\n-            NopInstruction.class,\n-            OperatorInstruction.class,\n-            ReturnInstruction.class,\n-            StackInstruction.class,\n-            StoreInstruction.class,\n-            SwitchCase.class,\n-            TableSwitchInstruction.class,\n-            ThrowInstruction.class,\n-            TypeCheckInstruction.class\n-    };\n-\n-    private static final Set<String> EXCLUDE_LIST = Set.of(\n-            \/\/ explicit null-ok methods\n-            \"java.lang.classfile.CodeBuilder\/exceptionCatch(java.lang.classfile.Label,java.lang.classfile.Label,java.lang.classfile.Label,java.lang.classfile.constantpool.ClassEntry)\/3\/0\",\n-            \"java.lang.classfile.CodeBuilder$BlockCodeBuilder\/exceptionCatch(java.lang.classfile.Label,java.lang.classfile.Label,java.lang.classfile.Label,java.lang.classfile.constantpool.ClassEntry)\/3\/0\",\n-            \"java.lang.classfile.CodeBuilder$CatchBuilder\/catching(java.lang.constant.ClassDesc,java.util.function.Consumer)\/0\/0\",\n-            \"java.lang.classfile.CodeBuilder\/loadConstant(java.lang.constant.ConstantDesc)\/0\/0\",\n-            \"java.lang.classfile.CodeBuilder$BlockCodeBuilder\/loadConstant(java.lang.constant.ConstantDesc)\/0\/0\",\n-            \"java.lang.classfile.ClassHierarchyResolver$ClassHierarchyInfo\/ofClass(java.lang.constant.ClassDesc)\/0\/0\",\n-            \"java.lang.classfile.attribute.ModuleAttribute$ModuleAttributeBuilder\/moduleVersion(java.lang.String)\/0\/0\",\n-            \"java.lang.classfile.attribute.ModuleAttribute$ModuleAttributeBuilder\/requires(java.lang.constant.ModuleDesc,java.util.Collection,java.lang.String)\/2\/0\",\n-            \"java.lang.classfile.attribute.ModuleAttribute$ModuleAttributeBuilder\/requires(java.lang.constant.ModuleDesc,int,java.lang.String)\/2\/0\",\n-            \"java.lang.classfile.attribute.ModuleAttribute\/of(java.lang.classfile.constantpool.ModuleEntry,int,java.lang.classfile.constantpool.Utf8Entry,java.util.Collection,java.util.Collection,java.util.Collection,java.util.Collection,java.util.Collection)\/2\/0\",\n-            \"java.lang.classfile.attribute.ModuleRequireInfo\/of(java.lang.classfile.constantpool.ModuleEntry,int,java.lang.classfile.constantpool.Utf8Entry)\/2\/0\",\n-            \"java.lang.classfile.attribute.ModuleRequireInfo\/of(java.lang.constant.ModuleDesc,java.util.Collection,java.lang.String)\/2\/0\",\n-            \"java.lang.classfile.attribute.ModuleRequireInfo\/of(java.lang.constant.ModuleDesc,int,java.lang.String)\/2\/0\",\n-            \"java.lang.classfile.attribute.ModuleRequireInfo\/of(java.lang.classfile.constantpool.ModuleEntry,java.util.Collection,java.lang.classfile.constantpool.Utf8Entry)\/2\/0\",\n-            \"java.lang.classfile.Signature$ClassTypeSig\/of(java.lang.classfile.Signature$ClassTypeSig,java.lang.constant.ClassDesc,java.lang.classfile.Signature$TypeArg[])\/0\/0\",\n-            \"java.lang.classfile.Signature$ClassTypeSig\/of(java.lang.classfile.Signature$ClassTypeSig,java.lang.String,java.lang.classfile.Signature$TypeArg[])\/0\/0\",\n-            \"java.lang.classfile.Signature$TypeParam\/of(java.lang.String,java.lang.classfile.Signature$RefTypeSig,java.lang.classfile.Signature$RefTypeSig[])\/1\/0\",\n-            \"java.lang.classfile.BufWriter\/writeIndexOrZero(java.lang.classfile.constantpool.PoolEntry)\/0\/0\",\n-\n-            \/\/ only called by ClassFile API, users don't need to check nulls\n-            \"java.lang.classfile.AttributeMapper\/readAttribute(java.lang.classfile.AttributedElement,java.lang.classfile.ClassReader,int)\/0\/0\",\n-            \"java.lang.classfile.AttributeMapper\/readAttribute(java.lang.classfile.AttributedElement,java.lang.classfile.ClassReader,int)\/1\/0\",\n-\n-            \/\/ inherited Collection methods\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/remove(java.lang.Object,java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object,java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object,java.lang.Object)\/1\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object,java.lang.Object)\/2\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object)\/1\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/remove(java.lang.Object,java.lang.Object)\/1\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/get(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/put(java.lang.Object,java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/put(java.lang.Object,java.lang.Object)\/1\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/putAll(java.util.Map)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/putIfAbsent(java.lang.Object,java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/remove(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/sort(java.util.Comparator)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/indexOf(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/lastIndexOf(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/add(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/add(int,java.lang.Object)\/1\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/toArray(java.lang.Object[])\/0\/1\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/contains(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/addAll(int,java.util.Collection)\/1\/1\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/addAll(java.util.Collection)\/0\/1\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/remove(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/putIfAbsent(java.lang.Object,java.lang.Object)\/1\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/compute(java.lang.Object,java.util.function.BiFunction)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/containsKey(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/computeIfAbsent(java.lang.Object,java.util.function.Function)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/containsValue(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/getOrDefault(java.lang.Object,java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/getOrDefault(java.lang.Object,java.lang.Object)\/1\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$MapNode\/computeIfPresent(java.lang.Object,java.util.function.BiFunction)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/set(int,java.lang.Object)\/1\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/addFirst(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/addLast(java.lang.Object)\/0\/0\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/removeAll(java.util.Collection)\/0\/1\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/retainAll(java.util.Collection)\/0\/1\",\n-            \"java.lang.classfile.components.ClassPrinter$ListNode\/containsAll(java.util.Collection)\/0\/1\",\n-            \/\/ inherited Throwable methods\n-            \"java.lang.classfile.constantpool.ConstantPoolException\/initCause(java.lang.Throwable)\/0\/0\"\n-    );\n-\n-    static {\n-        addDefaultMapping(char.class, (char) 0);\n-        addDefaultMapping(byte.class, (byte) 0);\n-        addDefaultMapping(short.class, (short) 0);\n-        addDefaultMapping(int.class, 0);\n-        addDefaultMapping(float.class, 0f);\n-        addDefaultMapping(long.class, 0L);\n-        addDefaultMapping(double.class, 0d);\n-        addDefaultMapping(boolean.class, true);\n-        addDefaultMapping(Enum.class, ClassFileFormatVersion.RELEASE_24);\n-        addDefaultMapping(Path.class, Path.of(\"nonExistent\"));\n-        addDefaultMapping(UnaryOperator.class, UnaryOperator.identity());\n-        addDefaultMapping(String.class, \"Hello!\");\n-        addDefaultMapping(Class.class, String.class);\n-        addDefaultMapping(Object.class, new Object());\n-        addDefaultMapping(List.class, List.of());\n-        addDefaultMapping(Consumer.class, _ -> {});\n-        addDefaultMapping(Supplier.class, () -> null);\n-        addDefaultMapping(ClassLoader.class, NullHostileTest.class.getClassLoader());\n-        addDefaultMapping(Function.class, Function.identity());\n-        addDefaultMapping(CharSequence.class, \"c\");\n-        addDefaultMapping(Collection.class, new ArrayList<>());\n-        addDefaultMapping(Map.class, Map.of());\n-        addDefaultMapping(MethodHandles.Lookup.class, MethodHandles.publicLookup());\n-        addDefaultMapping(Predicate.class, Predicate.not(_ -> false));\n-        BiFunction<Object, Object, Object> func = (_, _) -> 0;\n-        addDefaultMapping(BiFunction.class, func);\n-        addDefaultMapping(BiConsumer.class, (_, _) -> {});\n-        addDefaultMapping(IntFunction.class, _ -> 0);\n-        addDefaultMapping(PrintWriter.class, new PrintWriter(System.out,true));\n-        addDefaultMapping(PrintStream.class, new PrintStream(System.out,true));\n-    }\n-\n-    static {\n-        addReplacements(Collection.class, null, Stream.of(new Object[]{null}).collect(Collectors.toList()));\n-        addReplacements(List.class, null, Stream.of(new Object[]{null}).collect(Collectors.toList()));\n-        addReplacements(Set.class, null, Stream.of(new Object[]{null}).collect(Collectors.toSet()));\n-    }\n-\n-    @BeforeAll\n-    public static void getDefaultValues() throws IOException, URISyntaxException {\n-        for (var file : CorpusTest.corpus()) {\n-            var b = Files.readAllBytes(file);\n-            try {\n-                populateClassFileMappings(b);\n-            } catch (Exception e) {\n-                \/\/do nothing - some complains about Unmatched bit position 0x in some inner final classes\n-            }\n-        }\n-    }\n-    @ParameterizedTest\n-    @MethodSource(\"cases\")\n-    void testNulls(String testName, Method meth, Object receiver, Object[] args) {\n-        try {\n-            meth.invoke(receiver, args);\n-            fail(\"Method invocation completed normally\");\n-        } catch (InvocationTargetException ex) {\n-            var cause = ex.getCause();\n-            if (!(cause instanceof NullPointerException) && !(cause instanceof IllegalArgumentException)) {\n-                \/\/ sometimes default arguments are invalid, such as Opcode with bad type or primitive ClassDesc\n-                fail(\"Expected NPE or IAE but got others\", cause);\n-            }\n-        } catch (Throwable ex) {\n-            fail(\"Unexpected exception: \" + ex);\n-        }\n-    }\n-\n-    static Iterator<Object[]> cases() {\n-        List<Object[]> cases = new ArrayList<>();\n-        for (Class<?> clazz : CLASSES) {\n-            for (Method m : clazz.getMethods()) {\n-                if (OBJECT_METHODS.contains(m.getName())) continue;\n-                if (ClassFileTransform.class.isAssignableFrom(clazz) && TRANSFORM_USER_METHODS.contains(m.getName())) continue;\n-                if (Modifier.isStatic(m.getModifiers()) && m.getDeclaringClass() != clazz) continue; \/\/ parent class static methods\n-                boolean isStatic = (m.getModifiers() & Modifier.STATIC) != 0;\n-                List<Integer> refIndices = new ArrayList<>();\n-                var params = m.getParameters();\n-                for (int i = 0; i < m.getParameterCount(); i++) {\n-                    Class<?> param = params[i].getType();\n-                    if (!param.isPrimitive()) {\n-                        refIndices.add(i);\n-                    }\n-                }\n-                for (int i : refIndices) {\n-                    Object[] replacements = replacements(params[i].getType());\n-                    for (int r = 0; r < replacements.length; r++) {\n-                        String testName = clazz.getName() + \"\/\" + shortSig(m) + \"\/\" + i + \"\/\" + r;\n-                        if (EXCLUDE_LIST.contains(testName)) continue;\n-                        Object[] args = new Object[params.length];\n-                        for (int j = 0; j < params.length; j++) {\n-                            args[j] = defaultValue(params[j]);\n-                        }\n-                        args[i] = replacements[r];\n-                        Object receiver = isStatic ? null : defaultValue(clazz);\n-                        cases.add(new Object[]{testName, m, receiver, args});\n-                    }\n-                }\n-            }\n-        }\n-        return cases.iterator();\n-    }\n-\n-    static String shortSig(Method m) {\n-        StringJoiner sj = new StringJoiner(\",\", m.getName() + \"(\", \")\");\n-        for (Class<?> parameterType : m.getParameterTypes()) {\n-            sj.add(parameterType.getTypeName());\n-        }\n-        return sj.toString();\n-    }\n-\n-    static Object defaultValue(Class<?> carrier) {\n-        if (carrier.isArray()) {\n-            return Array.newInstance(carrier.componentType(), 0);\n-        }\n-        Object value = DEFAULT_VALUES.get(carrier);\n-        if (value == null) {\n-            throw new UnsupportedOperationException(carrier.getName());\n-        }\n-        return value;\n-    }\n-\n-    static Object defaultValue(Parameter param) {\n-        Class<?> carrier = param.getType();\n-        boolean optionalWrap = carrier == Optional.class;\n-        if (optionalWrap) {\n-            var generic = (ParameterizedType) param.getParameterizedType();\n-            var arg = generic.getActualTypeArguments()[0];\n-            carrier = (Class<?>) arg;\n-        }\n-        Object value = defaultValue(carrier);\n-        if (optionalWrap)\n-            value = Optional.of(value);\n-        return value;\n-    }\n-\n-    static Object[] replacements(Class<?> carrier) {\n-        if (carrier.isArray() && !carrier.getComponentType().isPrimitive()) {\n-            Object arr = Array.newInstance(carrier.componentType(), 1);\n-            Array.set(arr, 0, null);\n-            return new Object[]{null, arr};\n-        }\n-        return REPLACEMENT_VALUES.getOrDefault(carrier, new Object[]{null});\n-    }\n-\n-    public static List<String> findAllClassFiles() throws IOException, URISyntaxException {\n-        FileSystem fs = FileSystems.getFileSystem(new URI(\"jrt:\/\"));\n-        Path dir = fs.getPath(\"\/modules\");\n-        try (final Stream<Path> paths = Files.walk(dir)) {\n-            \/\/ each path is in the form: \/modules\/<modname>\/<pkg>\/<pkg>\/...\/name.class\n-            return paths\n-                    .filter(path -> path.getNameCount() > 2)\n-                    .map(Path::toString)\n-                    .filter(name -> name.endsWith(\".class\"))\n-                    .collect(Collectors.toList());\n-        }\n-    }\n-\n-    private static void populateClassFileMappings(byte[] classFileBytes) throws IOException {\n-\n-        ClassModel cm = ClassFile.of().parse(classFileBytes);\n-        addDefaultMapping(ClassFile.class, ClassFile.of());\n-        addDefaultMapping(ConstantPool.class, cm.constantPool());\n-        addDefaultMapping(ClassReader.class, (ClassReader) cm.constantPool());\n-\n-        var node = ClassPrinter.toTree(cm, ClassPrinter.Verbosity.TRACE_ALL);\n-        addDefaultMapping(ClassPrinter.MapNode.class, node);\n-        addDefaultMapping(ClassPrinter.Node.class, node);\n-        addDefaultMapping(ClassPrinter.Verbosity.class, ClassPrinter.Verbosity.MEMBERS_ONLY);\n-        addDefaultMapping(TypeKind.class, TypeKind.BOOLEAN);\n-        addDefaultMapping(ConstantPoolBuilder.class, ConstantPoolBuilder.of(cm));\n-        addDefaultMapping(ClassModel.class, cm);\n-        addDefaultMapping(ClassRemapper.class, ClassRemapper.of(Map.of()));\n-        addDefaultMapping(ClassHierarchyResolver.class, ClassHierarchyResolver.defaultResolver());\n-        addDefaultMapping(ClassTransform.class, ClassFileBuilder::with);\n-        addDefaultMapping(MethodTransform.class, (_, _) -> {});\n-        addDefaultMapping(FieldTransform.class, (_, _) -> {});\n-        addDefaultMapping(ClassPrinter.LeafNode.class, new ClassPrinterImpl.LeafNodeImpl(ConstantDescs.CD_Class, ConstantDescs.INIT_NAME));\n-        addDefaultMapping(ClassFileTransform.class, (ClassTransform) (_, _) -> {});\n-        addDefaultMapping(ConstantDesc.class, ConstantDescs.NULL);\n-        addDefaultMapping(CodeStackTracker.class, CodeStackTracker.of());\n-        addDefaultMapping(CodeRelabeler.class, CodeRelabeler.of());\n-        addDefaultMapping(CodeTransform.class, (_, _) -> {});\n-        addDefaultMapping(AttributesProcessingOption.class, ClassFile.AttributesProcessingOption.PASS_ALL_ATTRIBUTES);\n-        addDefaultMapping(TypeAnnotation.TargetInfo.class, TypeAnnotation.TargetInfo.ofField());\n-        addDefaultMapping(StackMapsOption.class, ClassFile.StackMapsOption.DROP_STACK_MAPS);\n-        addDefaultMapping(ShortJumpsOption.class, ClassFile.ShortJumpsOption.FIX_SHORT_JUMPS);\n-        addDefaultMapping(LineNumbersOption.class, ClassFile.LineNumbersOption.PASS_LINE_NUMBERS);\n-        addDefaultMapping(DebugElementsOption.class, ClassFile.DebugElementsOption.PASS_DEBUG);\n-        addDefaultMapping(DeadLabelsOption.class, ClassFile.DeadLabelsOption.FAIL_ON_DEAD_LABELS);\n-        addDefaultMapping(DeadCodeOption.class, ClassFile.DeadCodeOption.PATCH_DEAD_CODE);\n-        addDefaultMapping(TypeAnnotation.TargetInfo.class, TypeAnnotation.TargetInfo.ofField());\n-        addDefaultMapping(TypeAnnotation.TargetType.class, TypeAnnotation.TargetInfo.ofField().targetType());\n-        addDefaultMapping(TypeAnnotation.TypePathComponent.Kind.class, TypeAnnotation.TypePathComponent.Kind.INNER_TYPE);\n-        addDefaultMapping(ConstantPoolSharingOption.class, ClassFile.ConstantPoolSharingOption.SHARED_POOL);\n-        addDefaultMapping(PackageDesc.class, PackageDesc.of(\"java.lang.classfile\"));\n-        addDefaultMapping(ModuleDesc.class, ModuleDesc.of(\"java.base\"));\n-        addDefaultMapping(Signature.ClassTypeSig.class, Signature.ClassTypeSig.of(ClassDesc.of(\"java.util.Iterator\")));\n-        addDefaultMapping(Signature.TypeArg.Bounded.WildcardIndicator.class, Signature.TypeArg.Bounded.WildcardIndicator.NONE);\n-        addDefaultMapping(Signature.RefTypeSig.class, Signature.ClassTypeSig.of(ClassDesc.of(\"java.util.Iterator\")));\n-        addDefaultMapping(StackMapFrameInfo.SimpleVerificationTypeInfo.class, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE);\n-        addDefaultMapping(MethodSignature.class, MethodSignature.parseFrom(\"<T::Ljava\/lang\/annotation\/Annotation;>(Ljava\/lang\/Class<TT;>;)[TT;^Ljava\/lang\/IOException;^Ljava\/lang\/IllegalAccessError;\"));\n-        addDefaultMapping(ClassSignature.class, ClassSignature.parseFrom(\"Ljava\/util\/LinkedHashMap<TK;TV;>.LinkedHashIterator;Ljava\/util\/Iterator<Ljava\/util\/Map$Entry<TK;TV;>;>;\"));\n-        addDefaultMapping(Opcode.Kind.class, Opcode.Kind.CONSTANT);\n-\n-        cm.flags().flags().stream().findFirst().ifPresent(flag -> addDefaultMapping(AccessFlag.class, flag));\n-        try {\n-            Runnable runnable = () -> ClassFile.of().parse(new byte[]{(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE,\n-                    0, 0, 0, 0, 0, 2, PoolEntry.TAG_METHODREF, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}).thisClass();\n-            runnable.run();\n-        } catch (ConstantPoolException e) {\n-            addDefaultMapping(ConstantPoolException.class, e);\n-            addDefaultMapping(Throwable.class, e);\n-        }\n-\n-        try {\n-            addDefaultMapping(BootstrapMethodEntry.class, cm.constantPool().bootstrapMethodEntry(0));\n-            addDefaultMapping(LoadableConstantEntry.class, cm.constantPool().bootstrapMethodEntry(0).arguments().getFirst());\n-        } catch (Exception e) {\n-            \/\/ skip\n-        }\n-\n-        for (ClassFileElement ce : cm) {\n-            if (ce instanceof AttributedElement ae) {\n-                addDefaultMapping(ClassFileElement.class, ce);\n-                addDefaultMapping(AttributedElement.class, ae);\n-\n-            }\n-            if (Objects.requireNonNull(ce) instanceof CompoundElement<?> comp) {\n-                addDefaultMapping(CompoundElement.class, comp);\n-            }\n-        }\n-\n-        ModuleDesc modName = ModuleDesc.of(\"some.module.structure\");\n-        String modVsn = \"ab75\";\n-        ModuleDesc require1 = ModuleDesc.of(\"1require.some.mod\");\n-        String vsn1 = \"1the.best.version\";\n-        ModuleDesc require2 = ModuleDesc.of(\"2require.some.mod\");\n-        String vsn2 = \"2the.best.version\";\n-        ModuleDesc[] et1 = new ModuleDesc[]{ModuleDesc.of(\"1t1\"), ModuleDesc.of(\"1t2\")};\n-        ModuleDesc[] et2 = new ModuleDesc[]{ModuleDesc.of(\"2t1\")};\n-        ModuleDesc[] et3 = new ModuleDesc[]{ModuleDesc.of(\"3t1\"), ModuleDesc.of(\"3t2\"), ModuleDesc.of(\"3t3\")};\n-        ModuleDesc[] ot3 = new ModuleDesc[]{ModuleDesc.of(\"t1\"), ModuleDesc.of(\"t2\")};\n-\n-\n-        var classFile = ClassFile.of();\n-        byte[] modInfo = classFile.buildModule(\n-                ModuleAttribute.of(modName, mb -> {\n-                    addDefaultMapping(ModuleAttribute.ModuleAttributeBuilder.class, mb);\n-                    mb.moduleVersion(modVsn)\n-                            .requires(require1, 77, vsn1)\n-                            .requires(require2, 99, vsn2)\n-                            .exports(PackageDesc.of(\"0\"), 0, et1)\n-                            .exports(PackageDesc.of(\"1\"), 1, et2)\n-                            .exports(PackageDesc.of(\"2\"), 2, et3)\n-                            .exports(PackageDesc.of(\"3\"), 3)\n-                            .exports(PackageDesc.of(\"4\"), 4)\n-                            .opens(PackageDesc.of(\"o0\"), 0)\n-                            .opens(PackageDesc.of(\"o1\"), 1)\n-                            .opens(PackageDesc.of(\"o2\"), 2, ot3)\n-                            .uses(ClassDesc.of(\"some.Service\"))\n-                            .uses(ClassDesc.of(\"another.Service\"))\n-                            .provides(ClassDesc.of(\"some.nice.Feature\"), ClassDesc.of(\"impl\"), ClassDesc.of(\"another.impl\"));\n-                }),\n-                clb -> clb.with(ModuleMainClassAttribute.of(ClassDesc.of(\"main.Class\")))\n-                        .with(ModulePackagesAttribute.ofNames(PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\")))\n-                        .with(ModuleMainClassAttribute.of(ClassDesc.of(\"overwritten.main.Class\")))\n-        );\n-\n-        final ClassModel moduleModel = classFile.parse(modInfo);\n-        final ModuleAttribute moduleAttribute = ((ModuleAttribute) moduleModel.attributes().stream()\n-                .filter(a -> a.attributeMapper() == Attributes.module())\n-                .findFirst()\n-                .orElseThrow());\n-        moduleModel.attributes().stream()\n-                .filter(a -> a.attributeMapper() == Attributes.module())\n-                .forEach(_ -> addDefaultMapping(AttributeMapper.AttributeStability.class, moduleAttribute.attributeMapper().stability()));\n-\n-        addDefaultMapping(ModuleAttribute.class, moduleAttribute);\n-        addDefaultMapping(ModuleOpenInfo.class, moduleAttribute.opens().getFirst());\n-        addDefaultMapping(ModuleRequireInfo.class, moduleAttribute.requires().getFirst());\n-        addDefaultMapping(ModuleExportInfo.class, moduleAttribute.exports().getFirst());\n-        addDefaultMapping(ModuleProvideInfo.class, moduleAttribute.provides().getFirst());\n-\n-\n-        ClassFile.of().transformClass(cm, (cb, ce) -> {\n-            addDefaultMapping(ClassBuilder.class, cb);\n-            addDefaultMapping(ClassFileBuilder.class, cb);\n-            switch (ce) {\n-                case MethodModel m -> cb.transformMethod(m, (mb, me) -> {\n-                    addDefaultMapping(MethodBuilder.class, mb);\n-                    if (!(me instanceof RuntimeVisibleAnnotationsAttribute || me instanceof RuntimeInvisibleAnnotationsAttribute))\n-                        mb.with(me);\n-                });\n-                case FieldModel f -> cb.transformField(f, (fb, fe) -> {\n-                    addDefaultMapping(FieldBuilder.class, fb);\n-                    if (!(fe instanceof RuntimeVisibleAnnotationsAttribute || fe instanceof RuntimeInvisibleAnnotationsAttribute))\n-                        fb.with(fe);\n-                });\n-                default -> cb.with(ce);\n-            }\n-        });\n-\n-\n-        var annotation = cm.findAttribute(Attributes.runtimeVisibleAnnotations());\n-        if (annotation.isPresent()) {\n-            addDefaultMapping(Annotation.class, annotation.get().annotations().getFirst());\n-            addDefaultMapping(ClassPrinter.ListNode.class, new ClassPrinterImpl.ListNodeImpl(FLOW, \"array\", cm.findAttribute(Attributes.runtimeVisibleAnnotations()).stream().map(\n-                    _ -> new ClassPrinterImpl.MapNodeImpl(FLOW, \"value\"))));\n-        }\n-\n-        for (var cpe : cm.constantPool()) {\n-            switch (cpe) {\n-                case DoubleEntry de -> {\n-                    addDefaultMapping(DoubleEntry.class, de);\n-                    addDefaultMapping(ConstantValueEntry.class, de);\n-                }\n-                case FloatEntry fe -> addDefaultMapping(FloatEntry.class, fe);\n-                case IntegerEntry ie -> {\n-                    addDefaultMapping(IntegerEntry.class, ie);\n-                    addDefaultMapping(PoolEntry.class, ie);\n-                }\n-                case LongEntry le -> addDefaultMapping(LongEntry.class, le);\n-                case Utf8Entry ue -> addDefaultMapping(Utf8Entry.class, ue);\n-                case ConstantDynamicEntry cde -> addDefaultMapping(ConstantDynamicEntry.class, cde);\n-                case InvokeDynamicEntry ide -> addDefaultMapping(InvokeDynamicEntry.class, ide);\n-                case ClassEntry ce -> addDefaultMapping(ClassEntry.class, ce);\n-                case MethodHandleEntry mhe -> {\n-                    addDefaultMapping(MethodHandleEntry.class, mhe);\n-                    addDefaultMapping(MemberRefEntry.class, mhe.reference());\n-                    addDefaultMapping(DirectMethodHandleDesc.class, mhe.asSymbol());\n-                    addDefaultMapping(DynamicConstantDesc.class, DynamicConstantDesc.of(mhe.asSymbol()));\n-                    addDefaultMapping(DynamicCallSiteDesc.class, DynamicCallSiteDesc.of(mhe.asSymbol(), cm.methods().getFirst().methodTypeSymbol()));\n-                }\n-                case FieldRefEntry fre -> addDefaultMapping(FieldRefEntry.class, fre);\n-                case InterfaceMethodRefEntry imre -> addDefaultMapping(InterfaceMethodRefEntry.class, imre);\n-                case MethodRefEntry mre -> addDefaultMapping(MethodRefEntry.class, mre);\n-                case ModuleEntry me -> addDefaultMapping(ModuleEntry.class, me);\n-                case NameAndTypeEntry nate -> addDefaultMapping(NameAndTypeEntry.class, nate);\n-                case PackageEntry pe -> addDefaultMapping(PackageEntry.class, pe);\n-                default -> {}\n-            }\n-        }\n-\n-        for (ClassElement ce : cm) {\n-            switch (ce) {\n-                case Attribute<?> a -> {\n-                    addDefaultMapping(AttributeMapper.class, a.attributeMapper());\n-                    addDefaultMapping(Attribute.class, a);\n-                }\n-                case AccessFlags af -> addDefaultMapping(AccessFlags.class, af);\n-                case FieldModel fm -> {\n-                    addDefaultMapping(FieldModel.class, fm);\n-                    addDefaultMapping(Utf8Entry.class, fm.fieldName());\n-                    addDefaultMapping(ClassDesc.class, fm.fieldTypeSymbol());\n-                    addDefaultMapping(Signature.class, Signature.of(fm.fieldTypeSymbol()));\n-                    addDefaultMapping(TypeDescriptor.OfField.class, fm.fieldTypeSymbol());\n-                    addDefaultMapping(AnnotationValue.class, AnnotationValue.of(fm.fieldTypeSymbol()));\n-                }\n-                case MethodModel mm -> {\n-                    addDefaultMapping(CodeLocalsShifter.class, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol()));\n-                    addDefaultMapping(MethodTypeDesc.class, mm.methodTypeSymbol());\n-                    addDefaultMapping(MethodModel.class, mm);\n-                    for (MethodElement me : mm) {\n-                        if (me instanceof CodeModel xm) {\n-                            addDefaultMapping(CodeModel.class, xm);\n-                            addDefaultMapping(CodeAttribute.class, (CodeAttribute) xm);\n-                            for (CodeElement e : xm) {\n-                                switch (e) {\n-                                    case BranchInstruction ii -> addDefaultMapping(Label.class, ii.target());\n-                                    case NewReferenceArrayInstruction c -> addDefaultMapping(Opcode.class, c.opcode());\n-                                    default -> {}\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                default -> {}\n-            }\n-        }\n-\n-        for (Attribute<?> a : cm.attributes()) {\n-            switch (a) {\n-                case ModuleAttribute attr -> addDefaultMapping(ModuleAttribute.class, attr);\n-                case RuntimeVisibleTypeAnnotationsAttribute attr ->\n-                        addDefaultMapping(RuntimeVisibleTypeAnnotationsAttribute.class, attr);\n-                case RuntimeInvisibleTypeAnnotationsAttribute attr ->\n-                        addDefaultMapping(RuntimeInvisibleTypeAnnotationsAttribute.class, attr);\n-                case RuntimeVisibleParameterAnnotationsAttribute attr ->\n-                        addDefaultMapping(RuntimeVisibleParameterAnnotationsAttribute.class, attr);\n-                case RuntimeInvisibleParameterAnnotationsAttribute attr ->\n-                        addDefaultMapping(RuntimeInvisibleParameterAnnotationsAttribute.class, attr);\n-                case SourceDebugExtensionAttribute attr -> addDefaultMapping(SourceDebugExtensionAttribute.class, attr);\n-                case SourceIDAttribute attr -> addDefaultMapping(SourceIDAttribute.class, attr);\n-                default -> {}\n-            }\n-        }\n-\n-        ClassFile.of().build(ClassDesc.of(\"C\"), cb -> cb.withMethod(\"main\", MethodTypeDesc.of(ConstantDescs.CD_String, ConstantDescs.CD_String.arrayType()),\n-                ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, mb -> mb.withCode(xb -> {\n-                    int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n-                    xb.loadConstant(\"S\");\n-                    xb.astore(stringSlot);\n-                    xb.trying(tb -> {\n-                        tb.aload(0);\n-                        tb.loadConstant(0);\n-                        \/\/ IndexOutOfBoundsException\n-                        tb.aaload();\n-                        \/\/ NullPointerException\n-                        tb.invokevirtual(ConstantDescs.CD_String, \"toString\", MethodType.methodType(String.class).describeConstable().get());\n-                        tb.astore(stringSlot);\n-                    }, catchBuilder -> {\n-                        catchBuilder.catching(IndexOutOfBoundsException.class.describeConstable().get(), tb -> {\n-                            tb.pop();\n-                            tb.ldc(\"IndexOutOfBoundsException\");\n-                            tb.areturn();\n-                        }).catchingAll(tb -> {\n-                            tb.pop();\n-                            tb.ldc(\"any\");\n-                            tb.areturn();\n-                        });\n-                        addDefaultMapping(CodeBuilder.CatchBuilder.class, catchBuilder);\n-                    });\n-                    xb.aload(stringSlot);\n-                    xb.areturn();\n-                })));\n-\n-\n-        ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS).build(cm.thisClass().asSymbol(), clb -> {\n-            for (var cle : cm) {\n-                switch (cle) {\n-                    case AccessFlags af -> clb.withFlags(af.flagsMask());\n-                    case Interfaces i ->\n-                            clb.withInterfaceSymbols(i.interfaces().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new));\n-                    case ClassFileVersion v -> clb.withVersion(v.majorVersion(), v.minorVersion());\n-                    case MethodModel mm ->\n-                            clb.withMethod(mm.methodName().stringValue(), mm.methodTypeSymbol(), mm.flags().flagsMask(), _ -> {\n-                                for (var me : mm) {\n-                                    if (Objects.requireNonNull(me) instanceof MethodParametersAttribute a) {\n-                                        var r = MethodParametersAttribute.of(\n-                                                        a.parameters().stream().map(\n-                                                                mp -> MethodParameterInfo.ofParameter(mp.name().map(Utf8Entry::stringValue), mp.flagsMask())\n-                                                        ).toArray(MethodParameterInfo[]::new)\n-                                                )\n-                                                .parameters()\n-                                                .getFirst();\n-                                        addDefaultMapping(MethodParameterInfo.class, r);\n-                                    }\n-                                }\n-                            });\n-                    case InnerClassesAttribute a ->\n-                            addDefaultMapping(InnerClassInfo.class, InnerClassesAttribute.of(a.classes().stream().map(ici -> InnerClassInfo.of(\n-                                            ici.innerClass().asSymbol(),\n-                                            ici.outerClass().map(ClassEntry::asSymbol),\n-                                            ici.innerName().map(Utf8Entry::stringValue),\n-                                            ici.flagsMask())).toArray(InnerClassInfo[]::new))\n-                                    .classes().getFirst());\n-                    case ModuleAttribute a -> clb.with(\n-                            ModuleAttribute.of(a.moduleName().asSymbol(), mob -> {\n-                                mob.moduleFlags(a.moduleFlagsMask());\n-                                a.moduleVersion().ifPresent(v -> mob.moduleVersion(v.stringValue()));\n-                                for (var req : a.requires())\n-                                    mob.requires(req.requires().asSymbol(), req.requiresFlagsMask(), req.requiresVersion().map(Utf8Entry::stringValue).orElse(\"placeholder\"));\n-                                for (var exp : a.exports())\n-                                    mob.exports(exp.exportedPackage().asSymbol(), exp.exportsFlagsMask(), exp.exportsTo().stream().map(ModuleEntry::asSymbol).toArray(ModuleDesc[]::new));\n-                                for (var opn : a.opens())\n-                                    mob.opens(opn.openedPackage().asSymbol(), opn.opensFlagsMask(), opn.opensTo().stream().map(ModuleEntry::asSymbol).toArray(ModuleDesc[]::new));\n-                                for (var use : a.uses()) mob.uses(use.asSymbol());\n-                                for (var prov : a.provides())\n-                                    mob.provides(prov.provides().asSymbol(), prov.providesWith().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new));\n-                            }));\n-                    case RecordAttribute a -> RecordAttribute.of(a.components().stream().map(rci -> {\n-                        var y = RecordComponentInfo.of(rci.name().stringValue(), rci.descriptorSymbol(), rci.attributes().stream().mapMulti((_, _) -> {\n-                        }).toArray(Attribute[]::new));\n-                        addDefaultMapping(RecordComponentInfo.class, y);\n-                        return RecordComponentInfo.of(rci.name().stringValue(), rci.descriptorSymbol(), rci.attributes().stream().mapMulti((_, _) -> {\n-                        }).toArray(Attribute[]::new));\n-                    }).toArray(RecordComponentInfo[]::new));\n-                    default -> {}\n-                }\n-            }\n-        });\n-\n-\n-        var testClass = \"JsrAndRetSample\";\n-        var testMethod = \"testMethod\";\n-        var cd_list = ArrayList.class.describeConstable().get();\n-        ClassFile.of().build(ClassDesc.of(testClass), clb -> clb\n-                .withVersion(ClassFile.JAVA_5_VERSION, 0)\n-                .withMethodBody(testMethod, MethodTypeDesc.of(ConstantDescs.CD_void, cd_list), ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, cob -> cob\n-                        .block(bb -> {\n-                            addDefaultMapping(CodeBuilder.BlockCodeBuilder.class, bb);\n-\n-                            bb.loadConstant(\"Hello\")\n-                                    .with(DiscontinuedInstruction.JsrInstruction.of(bb.breakLabel()));\n-                            bb.loadConstant(\"World\")\n-                                    .with(DiscontinuedInstruction.JsrInstruction.of(Opcode.JSR_W, bb.breakLabel()))\n-                                    .return_();\n-                        })\n-                        .astore(355)\n-                        .aload(0)\n-                        .swap()\n-                        .invokevirtual(cd_list, \"add\", MethodTypeDesc.of(ConstantDescs.CD_boolean, ConstantDescs.CD_Object))\n-                        .pop()\n-                        .with(DiscontinuedInstruction.RetInstruction.of(355))));\n-\n-\n-        var root = Paths.get(URI.create(NullHostileTest.class.getResource(\"NullHostileTest.class\").toString())).getParent();\n-        var cc = ClassFile.of();\n-        Files.write(root.resolve(\"testdata\/Pattern2-split.class\"), cc.transformClass(cc.parse(root.resolve(\"testdata\/Pattern2.class\")), ClassTransform.transformingMethodBodies((cob, coe) -> {\n-            addDefaultMapping(CodeBuilder.class, cob);\n-            var dcob = (DirectCodeBuilder) cob;\n-            var curPc = dcob.curPc();\n-            switch (coe) {\n-                case LineNumber ln ->\n-                        dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.lineNumberTable()) {\n-                            @Override\n-                            public void writeBody(BufWriterImpl b) {\n-                                addDefaultMapping(BufWriter.class, b);\n-                                b.writeU2(1);\n-                                b.writeU2(curPc);\n-                                b.writeU2(ln.line());\n-                            }\n-                        });\n-                case LocalVariable lv ->\n-                        dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTable()) {\n-                            @Override\n-                            public void writeBody(BufWriterImpl b) {\n-                                b.writeU2(1);\n-                                Util.writeLocalVariable(b, lv);\n-                            }\n-                        });\n-                case LocalVariableType lvt ->\n-                        dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTypeTable()) {\n-                            @Override\n-                            public void writeBody(BufWriterImpl b) {\n-                                b.writeU2(1);\n-                                Util.writeLocalVariable(b, lvt);\n-                            }\n-                        });\n-                default -> cob.with(coe);\n-            }\n-        })));\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/classfile\/NullHostileTest.java","additions":0,"deletions":937,"binary":false,"changes":937,"status":"deleted"}]}