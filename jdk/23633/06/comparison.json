{"files":[{"patch":"@@ -1385,0 +1385,168 @@\n+\/\/ Compare longwords\n+void C2_MacroAssembler::string_compare_long_same_encoding(Register result, Register str1, Register str2,\n+                                                  const bool isLL, Register cnt1, Register cnt2,\n+                                                  Register tmp1, Register tmp2, Register tmp3,\n+                                                  const int STUB_THRESHOLD, Label *STUB, Label *SHORT_STRING, Label *DONE) {\n+  Label TAIL_CHECK, TAIL, NEXT_WORD, DIFFERENCE;\n+\n+  const int base_offset = isLL ? arrayOopDesc::base_offset_in_bytes(T_BYTE)\n+                               : arrayOopDesc::base_offset_in_bytes(T_CHAR);\n+  assert((base_offset % (UseCompactObjectHeaders ? 4 :\n+                        (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n+\n+  const int minCharsInWord = isLL ? wordSize : wordSize \/ 2;\n+\n+  \/\/ load first parts of strings and finish initialization while loading\n+  beq(str1, str2, *DONE);\n+  \/\/ Alignment\n+  if (AvoidUnalignedAccesses && (base_offset % 8) != 0) {\n+    lwu(tmp1, Address(str1));\n+    lwu(tmp2, Address(str2));\n+    bne(tmp1, tmp2, DIFFERENCE);\n+    addi(str1, str1, 4);\n+    addi(str2, str2, 4);\n+    subi(cnt2, cnt2, minCharsInWord \/ 2);\n+\n+    \/\/ A very short string\n+    mv(t0, minCharsInWord);\n+    ble(cnt2, t0, *SHORT_STRING);\n+  }\n+#ifdef ASSERT\n+  if (AvoidUnalignedAccesses) {\n+    Label align_ok;\n+    orr(t0, str1, str2);\n+    andi(t0, t0, 0x7);\n+    beqz(t0, align_ok);\n+    stop(\"bad alignment\");\n+    bind(align_ok);\n+  }\n+#endif\n+  \/\/ load 8 bytes once to compare\n+  ld(tmp1, Address(str1));\n+  ld(tmp2, Address(str2));\n+  mv(t0, STUB_THRESHOLD);\n+  bge(cnt2, t0, *STUB);\n+  subi(cnt2, cnt2, minCharsInWord);\n+  beqz(cnt2, TAIL_CHECK);\n+  \/\/ convert cnt2 from characters to bytes\n+  if (!isLL) {\n+    slli(cnt2, cnt2, 1);\n+  }\n+  add(str2, str2, cnt2);\n+  add(str1, str1, cnt2);\n+  sub(cnt2, zr, cnt2);\n+  addi(cnt2, cnt2, 8);\n+  bne(tmp1, tmp2, DIFFERENCE);\n+  bgez(cnt2, TAIL);\n+\n+  \/\/ main loop\n+  bind(NEXT_WORD);\n+    \/\/ 8-byte aligned loads when AvoidUnalignedAccesses is enabled\n+    add(t0, str1, cnt2);\n+    ld(tmp1, Address(t0));\n+    add(t0, str2, cnt2);\n+    ld(tmp2, Address(t0));\n+    addi(cnt2, cnt2, 8);\n+    bne(tmp1, tmp2, DIFFERENCE);\n+    bltz(cnt2, NEXT_WORD);\n+\n+  bind(TAIL);\n+  load_long_misaligned(tmp1, Address(str1), tmp3, isLL ? 1 : 2);\n+  load_long_misaligned(tmp2, Address(str2), tmp3, isLL ? 1 : 2);\n+\n+  bind(TAIL_CHECK);\n+  beq(tmp1, tmp2, *DONE);\n+\n+  \/\/ Find the first different characters in the longwords and\n+  \/\/ compute their difference.\n+  bind(DIFFERENCE);\n+  xorr(tmp3, tmp1, tmp2);\n+  \/\/ count bits of trailing zero chars\n+  ctzc_bits(result, tmp3, isLL);\n+  srl(tmp1, tmp1, result);\n+  srl(tmp2, tmp2, result);\n+  if (isLL) {\n+    zext(tmp1, tmp1, 8);\n+    zext(tmp2, tmp2, 8);\n+  } else {\n+    zext(tmp1, tmp1, 16);\n+    zext(tmp2, tmp2, 16);\n+  }\n+  sub(result, tmp1, tmp2);\n+\n+  j(*DONE);\n+}\n+\n+\/\/ Compare longwords\n+void C2_MacroAssembler::string_compare_long_different_encoding(Register result, Register str1, Register str2,\n+                                               bool isLU, Register cnt1, Register cnt2,\n+                                               Register tmp1, Register tmp2, Register tmp3,\n+                                               const int STUB_THRESHOLD, Label *STUB, Label *DONE) {\n+  Label TAIL, NEXT_WORD, DIFFERENCE;\n+\n+  const int base_offset = arrayOopDesc::base_offset_in_bytes(T_CHAR);\n+  assert((base_offset % (UseCompactObjectHeaders ? 4 :\n+                          (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n+\n+  Register strL = isLU ? str1 : str2;\n+  Register strU = isLU ? str2 : str1;\n+  Register tmpL = tmp1, tmpU = tmp2;\n+\n+  \/\/ load first parts of strings and finish initialization while loading\n+  mv(t0, STUB_THRESHOLD);\n+  bge(cnt2, t0, *STUB);\n+  lwu(tmpL, Address(strL));\n+  load_long_misaligned(tmpU, Address(strU), tmp3, (base_offset % 8) != 0 ? 4 : 8);\n+  subi(cnt2, cnt2, 4);\n+  add(strL, strL, cnt2);\n+  sub(cnt1, zr, cnt2);\n+  slli(cnt2, cnt2, 1);\n+  add(strU, strU, cnt2);\n+  inflate_lo32(tmp3, tmpL);\n+  mv(tmpL, tmp3);\n+  sub(cnt2, zr, cnt2);\n+  addi(cnt1, cnt1, 4);\n+  addi(cnt2, cnt2, 8);\n+  bne(tmpL, tmpU, DIFFERENCE);\n+  bgez(cnt2, TAIL);\n+\n+  \/\/ main loop\n+  bind(NEXT_WORD);\n+    add(t0, strL, cnt1);\n+    lwu(tmpL, Address(t0));\n+    add(t0, strU, cnt2);\n+    load_long_misaligned(tmpU, Address(t0), tmp3, (base_offset % 8) != 0 ? 4 : 8);\n+    addi(cnt1, cnt1, 4);\n+    inflate_lo32(tmp3, tmpL);\n+    mv(tmpL, tmp3);\n+    addi(cnt2, cnt2, 8);\n+    bne(tmpL, tmpU, DIFFERENCE);\n+    bltz(cnt2, NEXT_WORD);\n+\n+  bind(TAIL);\n+  load_int_misaligned(tmpL, Address(strL), tmp3, false);\n+  load_long_misaligned(tmpU, Address(strU), tmp3, 2);\n+  inflate_lo32(tmp3, tmpL);\n+  mv(tmpL, tmp3);\n+\n+  beq(tmpL, tmpU, *DONE);\n+\n+  \/\/ Find the first different characters in the longwords and\n+  \/\/ compute their difference.\n+  bind(DIFFERENCE);\n+  xorr(tmp3, tmpL, tmpU);\n+  \/\/ count bits of trailing zero chars\n+  ctzc_bits(result, tmp3);\n+  srl(tmpL, tmpL, result);\n+  srl(tmpU, tmpU, result);\n+  zext(tmpL, tmpL, 16);\n+  zext(tmpU, tmpU, 16);\n+  if (isLU) {\n+    sub(result, tmpL, tmpU);\n+  } else {\n+    sub(result, tmpU, tmpL);\n+  }\n+\n+  j(*DONE);\n+}\n+\n@@ -1391,3 +1559,3 @@\n-  Label DONE, SHORT_LOOP, SHORT_STRING, SHORT_LAST, TAIL, STUB,\n-        DIFFERENCE, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,\n-        SHORT_LOOP_START, TAIL_CHECK, L;\n+  Label DONE, SHORT_LOOP, SHORT_STRING, SHORT_LAST, STUB,\n+        SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,\n+        SHORT_LOOP_START, L;\n@@ -1412,8 +1580,0 @@\n-  int base_offset1 = arrayOopDesc::base_offset_in_bytes(T_BYTE);\n-  int base_offset2 = arrayOopDesc::base_offset_in_bytes(T_CHAR);\n-\n-  assert((base_offset1 % (UseCompactObjectHeaders ? 4 :\n-                          (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n-  assert((base_offset2 % (UseCompactObjectHeaders ? 4 :\n-                          (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n-\n@@ -1437,18 +1597,0 @@\n-  \/\/ Load 4 bytes once to compare for alignment before main loop. Note that this\n-  \/\/ is only possible for LL\/UU case. We need to resort to load_long_misaligned\n-  \/\/ for both LU and UL cases.\n-  if (str1_isL == str2_isL) { \/\/ LL or UU\n-    beq(str1, str2, DONE);\n-    int base_offset = isLL ? base_offset1 : base_offset2;\n-    if (AvoidUnalignedAccesses && (base_offset % 8) != 0) {\n-      mv(t0, minCharsInWord \/ 2);\n-      ble(cnt2, t0, SHORT_STRING);\n-      lwu(tmp1, Address(str1));\n-      lwu(tmp2, Address(str2));\n-      bne(tmp1, tmp2, DIFFERENCE);\n-      addi(str1, str1, 4);\n-      addi(str2, str2, 4);\n-      subi(cnt2, cnt2, minCharsInWord \/ 2);\n-    }\n-  }\n-\n@@ -1460,1 +1602,0 @@\n-  \/\/ load first parts of strings and finish initialization while loading\n@@ -1463,84 +1604,9 @@\n-#ifdef ASSERT\n-      if (AvoidUnalignedAccesses) {\n-        Label align_ok;\n-        orr(t0, str1, str2);\n-        andi(t0, t0, 0x7);\n-        beqz(t0, align_ok);\n-        stop(\"bad alignment\");\n-        bind(align_ok);\n-      }\n-#endif\n-      \/\/ load 8 bytes once to compare\n-      ld(tmp1, Address(str1));\n-      ld(tmp2, Address(str2));\n-      mv(t0, STUB_THRESHOLD);\n-      bge(cnt2, t0, STUB);\n-      subi(cnt2, cnt2, minCharsInWord);\n-      beqz(cnt2, TAIL_CHECK);\n-      \/\/ convert cnt2 from characters to bytes\n-      if (!str1_isL) {\n-        slli(cnt2, cnt2, 1);\n-      }\n-      add(str2, str2, cnt2);\n-      add(str1, str1, cnt2);\n-      sub(cnt2, zr, cnt2);\n-    } else if (isLU) { \/\/ LU case\n-      mv(t0, STUB_THRESHOLD);\n-      bge(cnt2, t0, STUB);\n-      lwu(tmp1, Address(str1));\n-      load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n-      subi(cnt2, cnt2, 4);\n-      add(str1, str1, cnt2);\n-      sub(cnt1, zr, cnt2);\n-      slli(cnt2, cnt2, 1);\n-      add(str2, str2, cnt2);\n-      inflate_lo32(tmp3, tmp1);\n-      mv(tmp1, tmp3);\n-      sub(cnt2, zr, cnt2);\n-      addi(cnt1, cnt1, 4);\n-    } else { \/\/ UL case\n-      mv(t0, STUB_THRESHOLD);\n-      bge(cnt2, t0, STUB);\n-      load_long_misaligned(tmp1, Address(str1), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n-      lwu(tmp2, Address(str2));\n-      subi(cnt2, cnt2, 4);\n-      slli(t0, cnt2, 1);\n-      sub(cnt1, zr, t0);\n-      add(str1, str1, t0);\n-      add(str2, str2, cnt2);\n-      inflate_lo32(tmp3, tmp2);\n-      mv(tmp2, tmp3);\n-      sub(cnt2, zr, cnt2);\n-      addi(cnt1, cnt1, 8);\n-    }\n-    addi(cnt2, cnt2, isUL ? 4 : 8);\n-    bne(tmp1, tmp2, DIFFERENCE);\n-    bgez(cnt2, TAIL);\n-\n-    \/\/ main loop\n-    bind(NEXT_WORD);\n-    if (str1_isL == str2_isL) { \/\/ LL or UU\n-      \/\/ 8-byte aligned loads when AvoidUnalignedAccesses is enabled\n-      add(t0, str1, cnt2);\n-      ld(tmp1, Address(t0));\n-      add(t0, str2, cnt2);\n-      ld(tmp2, Address(t0));\n-      addi(cnt2, cnt2, 8);\n-    } else if (isLU) { \/\/ LU case\n-      add(t0, str1, cnt1);\n-      lwu(tmp1, Address(t0));\n-      add(t0, str2, cnt2);\n-      load_long_misaligned(tmp2, Address(t0), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n-      addi(cnt1, cnt1, 4);\n-      inflate_lo32(tmp3, tmp1);\n-      mv(tmp1, tmp3);\n-      addi(cnt2, cnt2, 8);\n-    } else { \/\/ UL case\n-      add(t0, str2, cnt2);\n-      lwu(tmp2, Address(t0));\n-      add(t0, str1, cnt1);\n-      load_long_misaligned(tmp1, Address(t0), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n-      inflate_lo32(tmp3, tmp2);\n-      mv(tmp2, tmp3);\n-      addi(cnt1, cnt1, 8);\n-      addi(cnt2, cnt2, 4);\n+      string_compare_long_same_encoding(result,\n+                                str1, str2, isLL,\n+                                cnt1, cnt2, tmp1, tmp2, tmp3,\n+                                STUB_THRESHOLD, &STUB, &SHORT_STRING, &DONE);\n+    } else { \/\/ LU or UL\n+      string_compare_long_different_encoding(result,\n+                                str1, str2, isLU,\n+                                cnt1, cnt2, tmp1, tmp2, tmp3,\n+                                STUB_THRESHOLD, &STUB, &DONE);\n@@ -1548,37 +1614,0 @@\n-    bne(tmp1, tmp2, DIFFERENCE);\n-    bltz(cnt2, NEXT_WORD);\n-    bind(TAIL);\n-    if (str1_isL == str2_isL) { \/\/ LL or UU\n-      load_long_misaligned(tmp1, Address(str1), tmp3, isLL ? 1 : 2);\n-      load_long_misaligned(tmp2, Address(str2), tmp3, isLL ? 1 : 2);\n-    } else if (isLU) { \/\/ LU case\n-      load_int_misaligned(tmp1, Address(str1), tmp3, false);\n-      load_long_misaligned(tmp2, Address(str2), tmp3, 2);\n-      inflate_lo32(tmp3, tmp1);\n-      mv(tmp1, tmp3);\n-    } else { \/\/ UL case\n-      load_int_misaligned(tmp2, Address(str2), tmp3, false);\n-      load_long_misaligned(tmp1, Address(str1), tmp3, 2);\n-      inflate_lo32(tmp3, tmp2);\n-      mv(tmp2, tmp3);\n-    }\n-    bind(TAIL_CHECK);\n-    beq(tmp1, tmp2, DONE);\n-\n-    \/\/ Find the first different characters in the longwords and\n-    \/\/ compute their difference.\n-    bind(DIFFERENCE);\n-    xorr(tmp3, tmp1, tmp2);\n-    \/\/ count bits of trailing zero chars\n-    ctzc_bits(result, tmp3, isLL);\n-    srl(tmp1, tmp1, result);\n-    srl(tmp2, tmp2, result);\n-    if (isLL) {\n-      zext(tmp1, tmp1, 8);\n-      zext(tmp2, tmp2, 8);\n-    } else {\n-      zext(tmp1, tmp1, 16);\n-      zext(tmp2, tmp2, 16);\n-    }\n-    sub(result, tmp1, tmp2);\n-    j(DONE);\n@@ -2641,1 +2670,1 @@\n-  BLOCK_COMMENT(\"string_compare {\");\n+  BLOCK_COMMENT(\"string_compare_v {\");\n@@ -2701,0 +2730,2 @@\n+\n+  BLOCK_COMMENT(\"} string_compare_v\");\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":183,"deletions":152,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -42,0 +42,9 @@\n+  void string_compare_long_same_encoding(Register result, Register str1, Register str2,\n+                                  const bool isLL, Register cnt1, Register cnt2,\n+                                  Register tmp1, Register tmp2, Register tmp3,\n+                                  const int STUB_THRESHOLD, Label *STUB, Label *SHORT_STRING, Label *DONE);\n+  void string_compare_long_different_encoding(Register result, Register str1, Register str2,\n+                                  bool isLU, Register cnt1, Register cnt2,\n+                                  Register tmp1, Register tmp2, Register tmp3,\n+                                  const int STUB_THRESHOLD, Label *STUB, Label *DONE);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2434,17 +2434,0 @@\n-  \/\/ code for comparing 16 bytes of strings with same encoding\n-  void compare_string_16_bytes_same(Label &DIFF1, Label &DIFF2) {\n-    const Register result = x10, str1 = x11, cnt1 = x12, str2 = x13, tmp1 = x28, tmp2 = x29, tmp4 = x7, tmp5 = x31;\n-    __ ld(tmp5, Address(str1));\n-    __ addi(str1, str1, 8);\n-    __ xorr(tmp4, tmp1, tmp2);\n-    __ ld(cnt1, Address(str2));\n-    __ addi(str2, str2, 8);\n-    __ bnez(tmp4, DIFF1);\n-    __ ld(tmp1, Address(str1));\n-    __ addi(str1, str1, 8);\n-    __ xorr(tmp4, tmp5, cnt1);\n-    __ ld(tmp2, Address(str2));\n-    __ addi(str2, str2, 8);\n-    __ bnez(tmp4, DIFF2);\n-  }\n-\n@@ -2705,1 +2688,14 @@\n-      compare_string_16_bytes_same(DIFF, DIFF2);\n+      \/\/ compare 16 bytes of strings with same encoding\n+      __ ld(tmp5, Address(str1));\n+      __ addi(str1, str1, 8);\n+      __ xorr(tmp4, tmp1, tmp2);\n+      __ ld(cnt1, Address(str2));\n+      __ addi(str2, str2, 8);\n+      __ bnez(tmp4, DIFF);\n+      __ ld(tmp1, Address(str1));\n+      __ addi(str1, str1, 8);\n+      __ xorr(tmp4, tmp5, cnt1);\n+      __ ld(tmp2, Address(str2));\n+      __ addi(str2, str2, 8);\n+      __ bnez(tmp4, DIFF2);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+                invokeAndCheck(m, '\\uff21' - 'A', \"ABCEFGHIJKLMNOPQRSTUVWXY\\uff21Z\", \"ABCEFGHIJKLMNOPQRSTUVWXYAZ\");\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringIntrinsics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}