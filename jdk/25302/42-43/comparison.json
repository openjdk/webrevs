{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"logging\/log.hpp\"\n@@ -169,2 +170,2 @@\n-  volatile bool _stop_signals;\n-  volatile int _active_signal_handlers;\n+  \/\/ top bit is used to indicate that no signal handler should proceed\n+  volatile u4 _active_signal_handlers;\n@@ -173,0 +174,2 @@\n+  static const u4 STOP_SIGNAL_BIT = 0x80000000;\n+\n@@ -192,0 +195,9 @@\n+  void stop_signal_handlers();\n+\n+  \/\/ returns false if the stop signal bit was set, true otherwise\n+  bool increment_signal_handler_count();\n+\n+  void decrement_signal_handler_count();\n+\n+  void allow_signal_handlers();\n+\n@@ -208,5 +220,0 @@\n-\/\/ we have two stop signals, to remove a data race\n-\/\/ and this works even when the _instance is null\n-static volatile bool _static_stop_signals = true;\n-\n-\n@@ -220,2 +227,1 @@\n-  _stop_signals(true),\n-  _active_signal_handlers(0),\n+  _active_signal_handlers(STOP_SIGNAL_BIT),\n@@ -271,2 +277,1 @@\n-    Atomic::release_store(&_static_stop_signals, false);\n-    Atomic::release_store(&_stop_signals, false);\n+    allow_signal_handlers();\n@@ -288,6 +293,1 @@\n-    Atomic::release_store(&_static_stop_signals, true);\n-    Atomic::release_store(&_stop_signals, true);\n-    while (Atomic::load_acquire(&_active_signal_handlers) > 0) {\n-      \/\/ wait for all signal handlers to finish\n-      os::naked_short_nanosleep(1000);\n-    }\n+    stop_signal_handlers();\n@@ -295,2 +295,0 @@\n-    Atomic::release_store(&_static_stop_signals, false);\n-    Atomic::release_store(&_stop_signals, false);\n@@ -482,3 +480,0 @@\n-  if (Atomic::load_acquire(&_static_stop_signals)) {\n-    return;\n-  }\n@@ -496,3 +491,2 @@\n-  Atomic::inc(&_sampler->_active_signal_handlers, memory_order_acq_rel);\n-  if (!Atomic::load_acquire(&_sampler->_stop_signals)) {\n-    _sampler->handle_timer_signal(info, context);\n+  if (!_sampler->increment_signal_handler_count()) {\n+    return;\n@@ -500,1 +494,2 @@\n-  Atomic::dec(&_sampler->_active_signal_handlers, memory_order_acq_rel);\n+  _sampler->handle_timer_signal(info, context);\n+  _sampler->decrement_signal_handler_count();\n@@ -602,0 +597,30 @@\n+\n+void JfrCPUSamplerThread::stop_signal_handlers() {\n+  \/\/ set the stop signal bit\n+  Atomic::or_then_fetch(&_active_signal_handlers, STOP_SIGNAL_BIT, memory_order_acq_rel);\n+  while (Atomic::load_acquire(&_active_signal_handlers) > STOP_SIGNAL_BIT) {\n+    \/\/ wait for all signal handlers to finish\n+    os::naked_short_nanosleep(1000);\n+  }\n+}\n+\n+\/\/ returns false if the stop signal bit was set, true otherwise\n+bool JfrCPUSamplerThread::increment_signal_handler_count() {\n+  \/\/ increment the count of active signal handlers\n+  u4 old_value = Atomic::fetch_then_add(&_active_signal_handlers, (u4)1, memory_order_acq_rel);\n+  if ((old_value & STOP_SIGNAL_BIT) != 0) {\n+    \/\/ if the stop signal bit was set, we are not allowed to increment\n+    Atomic::dec(&_active_signal_handlers, memory_order_acq_rel);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void JfrCPUSamplerThread::decrement_signal_handler_count() {\n+  Atomic::dec(&_active_signal_handlers, memory_order_acq_rel);\n+}\n+\n+void JfrCPUSamplerThread::allow_signal_handlers() {\n+  Atomic::release_store(&_active_signal_handlers, (u4)0);\n+}\n+\n@@ -622,0 +647,1 @@\n+    log_error(jfr)(\"Failed to install signal handler for CPU thread sampling, possibly because another profiler is active: %s\", os::strerror(os::get_last_error()));\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":52,"deletions":26,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -127,1 +127,0 @@\n-  \/\/ Trigger sampling while a thread is not in a safepoint, from a separate thread\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}