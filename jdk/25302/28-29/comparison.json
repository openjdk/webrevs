{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrThreadSampling.hpp\"\n@@ -54,1 +55,4 @@\n-  assert(raw_thread != nullptr, \"invariant\");\n+  if (raw_thread == nullptr) {\n+    \/\/ probably while shutting down\n+    return nullptr;\n+  }\n@@ -194,2 +198,0 @@\n-  void stackwalk_thread_in_native(JavaThread* thread);\n-\n@@ -328,2 +330,1 @@\n-      tl->set_do_async_processing_of_cpu_time_jfr_requests(false);\n-      stackwalk_thread_in_native(jt);\n+      JfrThreadSampling::process_cpu_time_request(jt, tl, false);\n@@ -335,34 +336,0 @@\n-static inline bool is_in_continuation(const frame& frame, JavaThread* jt) {\n-  return JfrThreadLocal::is_vthread(jt) &&\n-         (Continuation::is_frame_in_continuation(jt, frame) || Continuation::is_continuation_enterSpecial(frame));\n-}\n-\n-void JfrCPUTimeThreadSampler::stackwalk_thread_in_native(JavaThread* thread) {\n-  JfrThreadLocal* tl = thread->jfr_thread_local();\n-  assert(tl != nullptr, \"invariant\");\n-  JfrCPUTimeTraceQueue& queue = tl->cpu_time_jfr_queue();\n-  if (queue.is_empty()) {\n-    return;\n-  }\n-  const frame top_frame = thread->last_frame();\n-  bool in_continuation = is_in_continuation(top_frame, thread);\n-  for (u4 i = 0; i < queue.size(); i++) {\n-    JfrCPUTimeSampleRequest& request = queue.at(i);\n-    JfrStackTrace stacktrace;\n-    const traceid tid = in_continuation ? tl->vthread_id_with_epoch_update(thread) : JfrThreadLocal::jvm_thread_id(thread);\n-    if (!stacktrace.record_inner(thread, top_frame, in_continuation, 0)) {\n-      log_info(jfr)(\"Unable to record native stacktrace for thread %s in CPU time sampler\", thread->name());\n-      JfrCPUTimeThreadSampling::send_empty_event(request._request._sample_ticks, tid, request._cpu_time_period);\n-    } else {\n-      traceid sid = JfrStackTraceRepository::add(stacktrace);\n-      JfrCPUTimeThreadSampling::send_event(request._request._sample_ticks, sid, tid, request._cpu_time_period, false);\n-    }\n-  }\n-  if (queue.lost_samples() > 0) {\n-    const traceid tid = in_continuation ? tl->vthread_id_with_epoch_update(thread) : JfrThreadLocal::jvm_thread_id(thread);\n-    const JfrTicks now = JfrTicks::now();\n-    JfrCPUTimeThreadSampling::send_lost_event(now, tid, queue.get_and_reset_lost_samples());\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":6,"deletions":39,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -357,0 +357,23 @@\n+static void drain_enqueued_cpu_time_requests(const JfrTicks& now, JfrThreadLocal* tl, JavaThread* jt, Thread* current, bool lock) {\n+  assert(tl != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(current != nullptr, \"invariant\");\n+  tl->set_do_async_processing_of_cpu_time_jfr_requests(false);\n+  if (lock) {\n+    tl->acquire_cpu_time_jfr_dequeue_lock();\n+  }\n+  JfrCPUTimeTraceQueue& queue = tl->cpu_time_jfr_queue();\n+  for (u4 i = 0; i < queue.size(); i++) {\n+    record_cpu_time_thread(queue.at(i), now, tl, jt, current);\n+  }\n+  queue.clear();\n+  assert(queue.is_empty(), \"invariant\");\n+  tl->set_has_cpu_time_jfr_requests(false);\n+  if (queue.lost_samples() > 0) {\n+    JfrCPUTimeThreadSampling::send_lost_event( now, JfrThreadLocal::thread_id(jt), queue.get_and_reset_lost_samples());\n+  }\n+  if (lock) {\n+    tl->release_cpu_time_jfr_queue_lock();\n+  }\n+}\n+\n@@ -365,13 +388,1 @@\n-    tl->set_do_async_processing_of_cpu_time_jfr_requests(false);\n-    tl->acquire_cpu_time_jfr_dequeue_lock();\n-    JfrCPUTimeTraceQueue& queue = tl->cpu_time_jfr_queue();\n-    for (u4 i = 0; i < queue.size(); i++) {\n-      record_cpu_time_thread(queue.at(i), now, tl, jt, current);\n-    }\n-    queue.clear();\n-    assert(queue.is_empty(), \"invariant\");\n-    tl->set_has_cpu_time_jfr_requests(false);\n-    if (queue.lost_samples() > 0) {\n-      JfrCPUTimeThreadSampling::send_lost_event( now, JfrThreadLocal::thread_id(jt), queue.get_and_reset_lost_samples());\n-    }\n-    tl->release_cpu_time_jfr_queue_lock();\n+    drain_enqueued_cpu_time_requests(now, tl, jt, current, true);\n@@ -470,0 +481,9 @@\n+\n+\/\/ Entry point for a thread that has been sampled in native code and has a pending JFR CPU time request.\n+void JfrThreadSampling::process_cpu_time_request(JavaThread* jt, JfrThreadLocal* tl, bool lock) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(jt->thread_state() == _thread_in_native, \"invariant\");\n+\n+  const JfrTicks now = JfrTicks::now();\n+  drain_enqueued_cpu_time_requests(now, tl, jt, jt, lock);\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.cpp","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  static void process_cpu_time_request(JavaThread* jt, JfrThreadLocal* tl, bool lock);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}